task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,tam_Taml,js,"/ கொடுக்கப்பட்ட உச்சநிலை. / கொடுக்கப்பட்ட வரிசையில் எண்கள், க்கு அருகில் உள்ள எண்களை விட நெருக்கமாக உள்ளதா என சரிபார்க்கவும்.// >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
// false
// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
// true
function has_close_elements(numbers, threshold){
","function has_close_elements(numbers, threshold) {
    // First, sort the array to ensure we check adjacency for closest elements
    numbers.sort((a, b) => a - b);

    // Iterate through the sorted list and check differences between successive elements
    for (let i = 0; i < numbers.length - 1; i++) {
        if (Math.abs(numbers[i] - numbers[i + 1]) < threshold) {
            return true;
        }
    }

    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = has_close_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);
}

test();"
HumanEval_1,tam_Taml,js,"/ உள்ளீட்டு சரத்தில் உள்ள இடைவெளிகளை புறக்கணிக்கவும்./ தனித்தனி குழுக்கள் சமநிலையில் உள்ளன (ஒவ்வொரு திறந்த துணுக்கு முறையாக மூடப்பட்டுள்ளது) மற்றும் ஒருவருக்கொருவர் கூடு போடப்படவில்லை./ அந்த குழுவை தனித்தனி சரங்களாக பிரித்து அவற்றின் வரிசையைத் திருப்பி விடுகிறது./இந்த செயல்பாட்டிற்கான உள்ளீடு என்பது பல குழுக்களாக உள்ளமைக்கப்பட்ட அடைப்புக்குறிகளைக் கொண்ட ஒரு சரம் ஆகும். உங்கள் குறிக்கோள் // >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// [""()"", ""(())"", ""(()())""]
function separate_paren_groups(paren_string){
","function separate_paren_groups(paren_string) {
    paren_string = paren_string.replace(/\s+/g, ''); // Remove spaces
    const groups = [];
    let balance = 0;
    let currentGroup = '';

    for (let char of paren_string) {
        currentGroup += char;
        if (char === '(') {
            balance++;
        } else if (char === ')') {
            balance--;
        }
        
        if (balance === 0) {
            groups.push(currentGroup);
            currentGroup = '';
        }
    }

    return groups;
}","const assert = require('node:assert');


function test() {
  let candidate = separate_paren_groups;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[""(()())"", ""((()))"", ""()"", ""((())()())""]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[""()"", ""(())"", ""((()))"", ""(((())))""]);
  assert.deepEqual(candidate(""(()(())((())))""),[""(()(())((())))""]);
  assert.deepEqual(candidate(""( ) (( )) (( )( ))""),[""()"", ""(())"", ""(()())""]);
}

test();"
HumanEval_2,tam_Taml,js,"/ எண்ணின் தசம பகுதியைத் திருப்பிக் கொடு. / (இறுதிப் பகுதி எப்போதும் 1 ஐ விடக் குறைவாக இருக்கும்)./ மற்றும் முழு எண் பகுதி (கொடுக்கப்பட்ட எண்ணை விட பெரிய முழு எண் சிறியது) மற்றும் தசமங்கள் /ஒரு நேர்மறை மிதக்கும் புள்ளி எண் கொடுக்கப்பட்டால், அது க்கு உடைக்கப்படலாம்.// >>> truncate_number(3.5)
// 0.5
function truncate_number(number){
","function truncate_number(number) {
    return number - Math.floor(number);
}","const assert = require('node:assert');


function test() {
  let candidate = truncate_number;
  assert.deepEqual(candidate(3.5),0.5);
  assert.deepEqual(candidate(1.25),0.25);
  assert.deepEqual(candidate(123.0),0.0);
}

test();"
HumanEval_3,tam_Taml,js,"/ அந்த புள்ளியில் செயல்பாடு உண்மை திரும்ப வேண்டும். இல்லையெனில் அது தவறான திரும்ப வேண்டும்./ பூஜ்ஜிய இருப்பு. உங்கள் பணி எந்த நேரத்திலும் கணக்கு இருப்பு பூஜ்ஜியத்திற்கு கீழே விழுகிறதா என்பதைக் கண்டறிவது, மற்றும் /நீங்கள் ஒரு வங்கி கணக்கில் வைப்பு மற்றும் திரும்ப நடவடிக்கைகள் ஒரு வரிசை கொடுக்கப்பட்ட என்று தொடங்குகிறது // >>> below_zero([1, 2, 3])
// false
// >>> below_zero([1, 2, -4, 5])
// true
function below_zero(operations){
","function below_zero(operations) {
    let balance = 0;
    for (let i = 0; i < operations.length; i++) {
        balance += operations[i];
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = below_zero;
  assert.deepEqual(candidate([]),false);
  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);
  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);
  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);
}

test();"
HumanEval_4,tam_Taml,js,"/ MAD = சராசரி. x - x_mean. / உறுப்பு மற்றும் ஒரு மைய புள்ளி (இந்த வழக்கில் சராசரி): / சராசரி முழுமையான விலகல் என்பது ஒவ்வொரு க்கும் இடையிலான சராசரி முழுமையான வேறுபாடு ஆகும்./ இந்த தரவுத்தொகுப்பின் சராசரிக்கு அருகில்./உள்ளீடு எண்களின் கொடுக்கப்பட்ட வரிசைக்கு, சராசரி முழுமையான விலகலைக் கணக்கிடுங்கள்.// >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
// 1.0
function mean_absolute_deviation(numbers){
","function mean_absolute_deviation(numbers) {
    const n = numbers.length;
    if (n === 0) return 0;

    const mean = numbers.reduce((acc, val) => acc + val, 0) / n;
    const deviations = numbers.map(num => Math.abs(num - mean));
    const mad = deviations.reduce((acc, val) => acc + val, 0) / n;

    return mad;
}

// Example usage:
console.log(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])); // Output: 1.0","const assert = require('node:assert');


function test() {
  let candidate = mean_absolute_deviation;
  assert.deepEqual(candidate([1.0, 2.0]),0.5);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);
}

test();"
HumanEval_5,tam_Taml,js,"/உள்ளீட்டு வரிசையின் ஒவ்வொரு இரண்டு தொடர்ச்சியான கூறுகளுக்கும் இடையில் ஒரு எண் 'தொலைவு' சேர்க்கவும் `numbers' // >>> intersperse([], 4)
// []
// >>> intersperse([1, 2, 3], 4)
// [1, 4, 2, 4, 3]
function intersperse(numbers, delimeter){
","function intersperse(numbers, delimiter) {
    if (numbers.length === 0) return [];
    
    const result = [];
    for (let i = 0; i < numbers.length - 1; i++) {
        result.push(numbers[i]);
        result.push(delimiter);
    }
    result.push(numbers[numbers.length - 1]);

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = intersperse;
  assert.deepEqual(candidate([], 7),[]);
  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);
  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);
}

test();"
HumanEval_6,tam_Taml,js,"/ எ. கா. (() (()) அதிகபட்சம் இரண்டு நிலைகளை கொண்டிருக்கும் போது ((())) மூன்று உள்ளது. / குழுவின் ஒவ்வொரு பிரிவிற்கும், அடைப்புக்குறிகளின் ஆழமான நிலைகளை வெளியிடுக./இந்த செயல்பாட்டிற்கான உள்ளீடு இடைவெளிகளால் பிரிக்கப்பட்ட அடைப்புக்குறிகளுக்கான பல குழுக்களைக் குறிக்கும் ஒரு சரம் ஆகும்.// >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// [2, 3, 1, 3]
function parse_nested_parens(paren_string){
","function parse_nested_parens(paren_string) {
    // Split the input string into groups based on spaces
    const groups = paren_string.split(' ');
    // Map each group to its maximum nesting depth
    return groups.map(group => {
        let maxDepth = 0;
        let currentDepth = 0;

        // Iterate through each character in the group
        for (let char of group) {
            if (char === '(') {
                // Increment current depth for '('
                currentDepth++;
                // Update max depth if it's greater than the previous max
                if (currentDepth > maxDepth) {
                    maxDepth = currentDepth;
                }
            } else if (char === ')') {
                // Decrement current depth for ')'
                currentDepth--;
            }
        }
        
        return maxDepth; // Return max depth of this group
    });
}","const assert = require('node:assert');


function test() {
  let candidate = parse_nested_parens;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[2, 3, 1, 3]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[1, 2, 3, 4]);
  assert.deepEqual(candidate(""(()(())((())))""),[4]);
}

test();"
HumanEval_7,tam_Taml,js,"/உள்ளிடப்பட்ட துணைச்சரத்தை கொண்டிருக்கும் சரங்களை மட்டுமே உள்ளீட்டு வரிசையில் வடிகட்டவும்.// >>> filter_by_substring([], ""a"")
// []
// >>> filter_by_substring([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
// [""abc"", ""bacd"", ""array""]
function filter_by_substring(strings, substring){
","function filter_by_substring(strings, substring) {
    return strings.filter(str => str.includes(substring));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_by_substring;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""),[""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""),[""grunt"", ""prune""]);
}

test();"
HumanEval_8,tam_Taml,js,"/ காலியாக உள்ள தொகை 0 ஆகவும், காலியாக உள்ள கூட்டுச் சேர்க்கை 1 ஆகவும் இருக்க வேண்டும்./ கொடுக்கப்பட்ட முழு எண்களின் வரிசைக்கு, ஒரு வரிசையில் உள்ள அனைத்து முழு எண்களின் கூட்டுத்தொகை மற்றும் ஒரு தயாரிப்பு ஆகியவற்றைக் கொண்ட ஒரு வரிசையைத் திருப்பித் தரவும்.// >>> sum_product([])
// [0, 1]
// >>> sum_product([1, 2, 3, 4])
// [10, 24]
function sum_product(numbers){
","function sum_product(numbers) {
    let sum = 0;
    let product = 1;

    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i];
        product *= numbers[i];
    }

    return [sum, product];
}","const assert = require('node:assert');


function test() {
  let candidate = sum_product;
  assert.deepEqual(candidate([]),[0, 1]);
  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);
  assert.deepEqual(candidate([100, 0]),[100, 0]);
  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);
  assert.deepEqual(candidate([10]),[10, 10]);
}

test();"
HumanEval_9,tam_Taml,js,"/ வரிசையில். / கொடுக்கப்பட்ட முழு எண்களின் வரிசையில் இருந்து, கொடுக்கப்பட்ட தருணம் வரை காணப்படும் அதிகபட்ச உறுப்புகளின் வரிசையை உருவாக்குங்கள்.// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
// [1, 2, 3, 3, 3, 4, 4]
function rolling_max(numbers){
","function rolling_max(numbers) {
    let result = [];
    let currentMax = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < numbers.length; i++) {
        currentMax = Math.max(currentMax, numbers[i]);
        result.push(currentMax);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = rolling_max;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);
  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);
}

test();"
HumanEval_10,tam_Taml,js,"/ - palindromic பின்னொட்டுக்கு முன் வரும் ஒரு சரம் முன்னொட்டு சரம் பின்னோக்கி இறுதியில் சேர்க்க./ - வழங்கப்பட்ட சரத்தின் மிக நீளமான postfix ஐக் கண்டறியவும், அது ஒரு பாலிண்ட்ரோம் ஆகும்./ அல்காரிதம் யோசனை எளிது: /வழங்கப்பட்ட சரத்துடன் தொடங்கும் குறுகிய பாலிண்ட்ரோம் கண்டுபிடிக்கவும்.// >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
function make_palindrome(string){
","function make_palindrome(string) {
    // Helper function to check if a string is a palindrome
    function isPalindrome(s) {
        let left = 0;
        let right = s.length - 1;
        while (left < right) {
            if (s[left] !== s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    // Find the longest palindromic suffix
    let longestPalindromicSuffixLength = 0;
    for (let i = 0; i < string.length; i++) {
        if (isPalindrome(string.slice(i))) {
            longestPalindromicSuffixLength = string.length - i;
            break;
        }
    }

    // Create the shortest palindrome
    const prefixToReverse = string.slice(0, string.length - longestPalindromicSuffixLength);
    const reversedPrefix = prefixToReverse.split('').reverse().join('');
    return string + reversedPrefix;
}

// Examples
console.log(make_palindrome(""""));     // """"
console.log(make_palindrome(""cat""));  // ""catac""
console.log(make_palindrome(""cata"")); // ""catac""","const assert = require('node:assert');


function test() {
  let candidate = make_palindrome;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""x""),""x"");
  assert.deepEqual(candidate(""xyz""),""xyzyx"");
  assert.deepEqual(candidate(""xyx""),""xyx"");
  assert.deepEqual(candidate(""jerry""),""jerryrrej"");
}

test();"
HumanEval_11,tam_Taml,js,"/ இந்த உள்ளீடுகளில் பைனரி XOR ஐச் செய்து, முடிவை ஒரு சரமாகவும் திருப்பி விடுங்கள்./இன்புட் என்பது 1 மற்றும் 0 களை மட்டுமே கொண்டிருக்கும் a மற்றும் b எனும் இரண்டு சரங்கள் ஆகும்.// >>> string_xor(""010"", ""110"")
// ""100""
function string_xor(a, b){
","function string_xor(a, b) {
    let result = """";
    for (let i = 0; i < a.length; i++) {
        result += (a[i] === b[i]) ? ""0"" : ""1"";
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = string_xor;
  assert.deepEqual(candidate(""111000"", ""101010""),""010010"");
  assert.deepEqual(candidate(""1"", ""1""),""0"");
  assert.deepEqual(candidate(""0101"", ""0000""),""0101"");
}

test();"
HumanEval_12,tam_Taml,js,"/ ஒரே நீள சரங்கள். உள்ளீட்டு வரிசை காலியாக இருந்தால் வரையறுக்கப்படாதது./அரையிலிருந்து நீளமான சரத்தை திருப்பி விடு. பல க்கு முதல் ஒன்றை திருப்பி விடு.// >>> longest([])
// undefined
// >>> longest([""a"", ""b"", ""c""])
// ""a""
// >>> longest([""a"", ""bb"", ""ccc""])
// ""ccc""
function longest(strings){
","function longest(strings) {
    if (strings.length === 0) return undefined;
    let longestString = strings[0];

    for (let i = 1; i < strings.length; i++) {
        if (strings[i].length > longestString.length) {
            longestString = strings[i];
        }
    }

    return longestString;
}","const assert = require('node:assert');


function test() {
  let candidate = longest;
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""x"");
  assert.deepEqual(candidate([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]),""zzzz"");
}

test();"
HumanEval_13,tam_Taml,js,"/இரண்டு முழு எண்கள் a மற்றும் b க்கு மிகப்பெரிய பொது வகுப்பான் கொடுங்கள்// >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
function greatest_common_divisor(a, b){
","function greatest_common_divisor(a, b) {
    while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}","const assert = require('node:assert');


function test() {
  let candidate = greatest_common_divisor;
  assert.deepEqual(candidate(3, 7),1);
  assert.deepEqual(candidate(10, 15),5);
  assert.deepEqual(candidate(49, 14),7);
  assert.deepEqual(candidate(144, 60),12);
}

test();"
HumanEval_14,tam_Taml,js,"/உள்ளீட்டு சரத்தின் குறுகிய முதல் நீண்ட வரை உள்ள அனைத்து முன்னொட்டுகளின் வரிசையைத் திருப்பித் தருகிறது.// >>> all_prefixes(""abc"")
// [""a"", ""ab"", ""abc""]
function all_prefixes(string){
","function all_prefixes(string) {
    let prefixes = [];
    for (let i = 1; i <= string.length; i++) {
        prefixes.push(string.substring(0, i));
    }
    return prefixes;
}","const assert = require('node:assert');


function test() {
  let candidate = all_prefixes;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""asdfgh""),[""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""]);
  assert.deepEqual(candidate(""WWW""),[""W"", ""WW"", ""WWW""]);
}

test();"
HumanEval_15,tam_Taml,js,"0 முதல் n வரை உள்ளடக்கிய இட-வரையறுக்கப்பட்ட எண்களைக் கொண்ட ஒரு சரத்தைத் திருப்பித் தருகிறது.// >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
function string_sequence(n){
","function string_sequence(n) {
    let result = [];
    for (let i = 0; i <= n; i++) {
        result.push(i);
    }
    return result.join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = string_sequence;
  assert.deepEqual(candidate(0),""0"");
  assert.deepEqual(candidate(3),""0 1 2 3"");
  assert.deepEqual(candidate(10),""0 1 2 3 4 5 6 7 8 9 10"");
}

test();"
HumanEval_16,tam_Taml,js,"/ஒரு சரம் கொடுக்கப்பட்டால், எத்தனை தனித்தனி எழுத்துக்கள் (எந்த வழக்கு இருந்தாலும்) அதில் உள்ளன என்பதைக் கண்டறியவும்.// >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
function count_distinct_characters(string){
","function count_distinct_characters(string) {
    // Convert the string to lowercase to ignore case differences
    const lowercaseString = string.toLowerCase();
    // Create a Set to store distinct characters
    const distinctChars = new Set();
    // Iterate over each character in the string
    for (let char of lowercaseString) {
        distinctChars.add(char); // Add character to the set
    }
    // Return the size of the set which represents the number of distinct characters
    return distinctChars.size;
}","const assert = require('node:assert');


function test() {
  let candidate = count_distinct_characters;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abcde""),5);
  assert.deepEqual(candidate(""abcdecadeCADE""),5);
  assert.deepEqual(candidate(""aaaaAAAAaaaa""),1);
  assert.deepEqual(candidate(""Jerry jERRY JeRRRY""),5);
}

test();"
HumanEval_17,tam_Taml,js,"' 'சீ' - குவார்ட்டர் குறிப்பு, ஒரு துடிப்பு நீடிக்கும் / 'o dir dir dir' - அரை குறிப்பு, இரண்டு துடிப்பு நீடிக்கும் / 'ஓ' - முழு குறிப்பு, நான்கு துடிப்பு நீடிக்கும் / இங்கே ஒரு புராணக்கதை உள்ளது: / கடைசியாக இல்லை. / உங்கள் பணி இந்த சரம் பகுப்பாய்வு மற்றும் ஒவ்வொரு எத்தனை துடிப்புகளை செய்கிறது பொருந்தும் முழு எண்கள் வரிசை திரும்ப உள்ளது /இந்த செயல்பாட்டிற்கு உள்ளீடு ஒரு சிறப்பு ASCII வடிவத்தில் இசைக் குறிப்புகளை குறிக்கும் ஒரு சரம் ஆகும்.// >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
function parse_music(music_string){
","function parse_music(music_string) {
    let notes = music_string.split("" "");
    let beats = [];

    for (let note of notes) {
        switch (note) {
            case 'o':
                beats.push(4);
                break;
            case 'o|':
                beats.push(2);
                break;
            case '.|':
                beats.push(1);
                break;
            default:
                // Handle unexpected notes if necessary
                break;
        }
    }
    return beats;
}

// Example usage:
// console.log(parse_music(""o o| .| o| o| .| .| .| .| o o"")); 
// Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]","const assert = require('node:assert');


function test() {
  let candidate = parse_music;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""o o o o""),[4, 4, 4, 4]);
  assert.deepEqual(candidate("".| .| .| .|""),[1, 1, 1, 1]);
  assert.deepEqual(candidate(""o| o| .| .| o o o o""),[2, 2, 1, 1, 4, 4, 4, 4]);
  assert.deepEqual(candidate(""o| .| o| .| o o| o o|""),[2, 1, 2, 1, 4, 2, 4, 2]);
}

test();"
HumanEval_18,tam_Taml,js,"/உள்ளிடப்பட்ட சப்-ஸ்ட்ரிங் எத்தனை முறை அசல் சரத்தில் காணப்படுகிறது என்பதைக் கண்டறியவும். ஒன்றுடன் ஒன்று ஒட்டிக்கொள்ளும் நிகழ்வுகளை எண்ணவும்.// >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
function how_many_times(string, substring){
","function how_many_times(string, substring) {
  if (substring.length === 0) return 0;
  
  let count = 0;
  let position = 0;
  
  while ((position = string.indexOf(substring, position)) !== -1) {
    count++;
    position++;
  }
  
  return count;
}","const assert = require('node:assert');


function test() {
  let candidate = how_many_times;
  assert.deepEqual(candidate("""", ""x""),0);
  assert.deepEqual(candidate(""xyxyxyx"", ""x""),4);
  assert.deepEqual(candidate(""cacacacac"", ""cac""),4);
  assert.deepEqual(candidate(""john doe"", ""john""),1);
}

test();"
HumanEval_19,tam_Taml,js,"/ மிகச் சிறியதிலிருந்து மிகப் பெரியது வரை வரிசைப்படுத்தப்பட்ட எண்களைக் கொண்ட சரத்தை திருப்பித் தருகிறது ./ செல்லுபடியாகும் தேர்வுகள் 'பூஜ்யம்', 'ஒன்று', 'இரண்டு', 'மூன்று', 'நான்கு', 'ஐந்து', 'ஆறு', 'ஏழு', 'எட்டு' மற்றும் 'ஒன்பது'./இன்புட் என்பது '0' முதல் '9' வரையிலான எண்களின் விண்வெளி வரையறுக்கப்பட்ட சரம் ஆகும்.// >>> sort_numbers(""three one five"")
// ""one three five""
function sort_numbers(numbers){
","function sort_numbers(numbers) {
    const numberWords = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
    
    return numbers
        .split(' ')
        .sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b))
        .join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = sort_numbers;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""three""),""three"");
  assert.deepEqual(candidate(""three five nine""),""three five nine"");
  assert.deepEqual(candidate(""five zero four seven nine eight""),""zero four five seven eight nine"");
  assert.deepEqual(candidate(""six five four three two one zero""),""zero one two three four five six"");
}

test();"
HumanEval_20,tam_Taml,js,"/ மற்றவைகளை வரிசையில் கொடுத்துவிட்டு (குறைந்த எண்ணிக்கை, அதிக எண்ணிக்கை) திருப்பி அனுப்புங்கள்./ வழங்கப்பட்ட எண்களின் வரிசையில் இருந்து (குறைந்தது இரண்டு நீளங்கள்) ஒவ்வொருவருக்கும் மிக நெருக்கமான இரண்டு எண்களைத் தேர்ந்தெடுத்து திருப்பித் தரவும்.// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
// [2.0, 2.2]
// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
// [2.0, 2.0]
function find_closest_elements(numbers){
","function find_closest_elements(numbers) {
    if (numbers.length < 2) {
        throw new Error('Array must contain at least two elements.');
    }
    
    numbers.sort((a, b) => a - b);

    let minDiff = Infinity;
    let closestPair = [numbers[0], numbers[1]];

    for (let i = 0; i < numbers.length - 1; i++) {
        let diff = numbers[i + 1] - numbers[i];
        if (diff < minDiff) {
            minDiff = diff;
            closestPair = [numbers[i], numbers[i + 1]];
        }
    }

    return closestPair;
}","const assert = require('node:assert');


function test() {
  let candidate = find_closest_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);
}

test();"
HumanEval_21,tam_Taml,js,"/ மிகச்சிறிய எண் 0 ஆகவும், மிகப்பெரிய எண் 1 ஆகவும் மாறும்./எண் வரிசை கொடுக்கப்பட்டால் (குறைந்தது இரண்டு உறுப்புகள்), அந்த வரிசைக்கு ஒரு நேரியல் மாற்றத்தை பயன்படுத்துங்கள்,// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
// [0.0, 0.25, 0.5, 0.75, 1.0]
function rescale_to_unit(numbers){
","function rescale_to_unit(numbers) {
    if (numbers.length < 2) {
        throw new Error(""Array must contain at least two elements."");
    }
    
    let min = Math.min(...numbers);
    let max = Math.max(...numbers);
    
    return numbers.map(num => (num - min) / (max - min));
}

// Example usage
console.log(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])); // [0.0, 0.25, 0.5, 0.75, 1.0]","const assert = require('node:assert');


function test() {
  let candidate = rescale_to_unit;
  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);
  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);
  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
}

test();"
HumanEval_22,tam_Taml,js,"/எந்த jsthon மதிப்புகளின் கொடுக்கப்பட்ட வரிசையை முழு எண்களுக்கு மட்டுமே வடிகட்டவும் // >>> filter_integers([""a"", 3.14, 5])
// [5]
// >>> filter_integers([1, 2, 3, ""abc"", {}, []])
// [1, 2, 3]
function filter_integers(values){
","function filter_integers(values) {
    return values.filter(value => Number.isInteger(value));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_integers;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([4, {}, [], 23.2, 9, ""adasd""]),[4, 9]);
  assert.deepEqual(candidate([3, ""c"", 3, 3, ""a"", ""b""]),[3, 3, 3]);
}

test();"
HumanEval_23,tam_Taml,js,"/ கொடுக்கப்பட்ட சரத்தின் நீளத்தை திரும்ப கொடுங்கள் // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
function strlen(string){
","function strlen(string) {
    return string.length;
}","const assert = require('node:assert');


function test() {
  let candidate = strlen;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""x""),1);
  assert.deepEqual(candidate(""asdasnakj""),9);
}

test();"
HumanEval_24,tam_Taml,js,"/ கொடுக்கப்பட்ட n எண்ணுக்கு, n ஐ சமமாகப் பிரிக்கும் மிகப்பெரிய எண்ணைக் கண்டறியவும், இது n ஐ விட சிறியது.// >>> largest_divisor(15)
// 5
function largest_divisor(n){
","function largest_divisor(n) {
    for (let i = n - 1; i > 0; i--) {
        if (n % i === 0) {
            return i;
        }
    }
    return 1; // for the edge case where n is 1
}","const assert = require('node:assert');


function test() {
  let candidate = largest_divisor;
  assert.deepEqual(candidate(3),1);
  assert.deepEqual(candidate(7),1);
  assert.deepEqual(candidate(10),5);
  assert.deepEqual(candidate(100),50);
  assert.deepEqual(candidate(49),7);
}

test();"
HumanEval_25,tam_Taml,js,"/ உள்ளீடு எண் அனைத்து காரணிகளின் கூட்டுக்கு சமமாக இருக்க வேண்டும் / ஒவ்வொரு காரணிகளும் காரணி வரிசையில் எத்தனை முறை தோன்றினாலும் அதற்கு ஏற்ப வரிசைப்படுத்தப்பட வேண்டும்./ கொடுக்கப்பட்ட முழு எண் முதன்மை காரணிகளின் வரிசையை மிகச் சிறியதிலிருந்து மிகப் பெரியது வரை வரிசையில் திருப்பித் தருகிறது.// >>> factorize(8)
// [2, 2, 2]
// >>> factorize(25)
// [5, 5]
// >>> factorize(70)
// [2, 5, 7]
function factorize(n){
","function factorize(n) {
    const factors = [];
    let divisor = 2;

    while (n >= 2) {
        if (n % divisor === 0) {
            factors.push(divisor);
            n /= divisor;
        } else {
            divisor++;
        }
    }

    return factors;
}","const assert = require('node:assert');


function test() {
  let candidate = factorize;
  assert.deepEqual(candidate(2),[2]);
  assert.deepEqual(candidate(4),[2, 2]);
  assert.deepEqual(candidate(8),[2, 2, 2]);
  assert.deepEqual(candidate(57),[3, 19]);
  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);
  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);
  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);
  assert.deepEqual(candidate(18),[2, 3, 3]);
}

test();"
HumanEval_26,tam_Taml,js,"/ உள்ளீட்டில் உள்ள அதே வரிசையில் உள்ள உறுப்புகளை வைத்திருங்கள்./முழு எண்களின் வரிசையில் இருந்து, ஒரு முறைக்கு மேல் வரும் அனைத்து உறுப்புகளையும் நீக்கவும்.// >>> remove_duplicates([1, 2, 3, 2, 4])
// [1, 3, 4]
function remove_duplicates(numbers){
","function remove_duplicates(numbers) {
    const frequency = {};
    // Count occurrences of each number
    numbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });

    // Filter out numbers that occur more than once
    return numbers.filter(num => frequency[num] === 1);
}","const assert = require('node:assert');


function test() {
  let candidate = remove_duplicates;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);
}

test();"
HumanEval_27,tam_Taml,js,"/ கொடுக்கப்பட்ட சரத்திற்கு, சிறிய எழுத்துக்களை பெரிய எழுத்துக்களாகவும், பெரிய எழுத்துக்களை சிறிய எழுத்துக்களாகவும் மாற்றவும்.// >>> flip_case(""Hello"")
// ""hELLO""
function flip_case(string){
","function flip_case(string) {
    let flippedString = '';
    for (let i = 0; i < string.length; i++) {
        const char = string[i];
        if (char === char.toLowerCase()) {
            flippedString += char.toUpperCase();
        } else {
            flippedString += char.toLowerCase();
        }
    }
    return flippedString;
}","const assert = require('node:assert');


function test() {
  let candidate = flip_case;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hello!""),""hELLO!"");
  assert.deepEqual(candidate(""These violent delights have violent ends""),""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"");
}

test();"
HumanEval_28,tam_Taml,js,"/ஒற்றை சரமாக சரங்களின் வரிசையை இணைத்தல் // >>> concatenate([])
// """"
// >>> concatenate([""a"", ""b"", ""c""])
// ""abc""
function concatenate(strings){
","function concatenate(strings) {
    return strings.join('');
}","const assert = require('node:assert');


function test() {
  let candidate = concatenate;
  assert.deepEqual(candidate([]),"""");
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""xyz"");
  assert.deepEqual(candidate([""x"", ""y"", ""z"", ""w"", ""k""]),""xyzwk"");
}

test();"
HumanEval_29,tam_Taml,js,"/ கொடுக்கப்பட்ட முன்னொட்டுடன் தொடங்கும் சரங்களுக்கு மட்டுமே உள்ளீட்டு வரிசையை வடிகட்டவும்.// >>> filter_by_prefix([], ""a"")
// []
// >>> filter_by_prefix([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
// [""abc"", ""array""]
function filter_by_prefix(strings, prefix){
","function filter_by_prefix(strings, prefix) {
    return strings.filter(str => str.startsWith(prefix));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_by_prefix;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
}

test();"
HumanEval_30,tam_Taml,js,"/அரையில் உள்ள நேர்ம எண்களை மட்டும் திருப்பி விடுக.// >>> get_positive([-1, 2, -4, 5, 6])
// [2, 5, 6]
// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// [5, 3, 2, 3, 9, 123, 1]
function get_positive(l){
","function get_positive(l) {
    return l.filter(function(num) {
        return num > 0;
    });
}","const assert = require('node:assert');


function test() {
  let candidate = get_positive;
  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);
  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);
  assert.deepEqual(candidate([-1, -2]),[]);
  assert.deepEqual(candidate([]),[]);
}

test();"
HumanEval_31,tam_Taml,js,"/ கொடுக்கப்பட்ட எண் முதன்மையானது என்றால் உண்மை எனவும், இல்லையெனில் தவறானது எனவும் கொடுக்கும்.// >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
function is_prime(n){
","function is_prime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
  
    if (n % 2 === 0 || n % 3 === 0) return false;
  
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
  
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_prime;
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(101),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(13441),true);
  assert.deepEqual(candidate(61),true);
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(1),false);
  assert.deepEqual(candidate(5),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(17),true);
  assert.deepEqual(candidate(85),false);
  assert.deepEqual(candidate(77),false);
  assert.deepEqual(candidate(255379),false);
}

test();"
HumanEval_33,tam_Taml,js,"/ ன் மதிப்புகளுக்கு ஒத்த குறியீடுகள், ஆனால் வரிசைப்படுத்தப்பட்டவை./ l' என்பது மூன்று மூலம் வகுக்க முடியாத குறியீடுகளில் l உடன் ஒத்ததாகும், அதே நேரத்தில் மூன்று மூலம் வகுக்கக்கூடிய குறியீடுகளில் அதன் மதிப்புகள் சமமாக இருக்கும்./இந்த செயல்பாடு ஒரு வரிசை l ஐ எடுத்து ஒரு வரிசை l' ஐ திருப்பித் தருகிறது.// >>> sort_third([1, 2, 3])
// [1, 2, 3]
// >>> sort_third([5, 6, 3, 4, 8, 9, 2])
// [2, 6, 3, 4, 8, 9, 5]
function sort_third(l){
","function sort_third(l) {
    // Extract the elements at indices divisible by 3
    const elementsToSort = [];
    for (let i = 0; i < l.length; i++) {
        if (i % 3 === 0) {
            elementsToSort.push(l[i]);
        }
    }
    
    // Sort the extracted elements
    elementsToSort.sort((a, b) => a - b);

    // Place the sorted elements back into their original positions
    let sortedIndex = 0;
    for (let i = 0; i < l.length; i++) {
        if (i % 3 === 0) {
            l[i] = elementsToSort[sortedIndex++];
        }
    }
    
    return l;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_third;
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);
  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);
  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);
}

test();"
HumanEval_34,tam_Taml,js,"/ஒரு வரிசையில் வரிசைப்படுத்தப்பட்ட தனித்துவமான கூறுகளைத் திருப்பித் தருகிறது.// >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [0, 2, 3, 5, 9, 123]
function unique(l){
","function unique(l) {
    // Use a Set to remove duplicates and then spread into an array
    const uniqueElements = [...new Set(l)];
    // Sort the array in ascending order
    uniqueElements.sort((a, b) => a - b);
    return uniqueElements;
}","const assert = require('node:assert');


function test() {
  let candidate = unique;
  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);
}

test();"
HumanEval_35,tam_Taml,js,"/அரசியலில் அதிகபட்ச உறுப்பைத் திருப்பி விடுக.// >>> max_element([1, 2, 3])
// 3
// >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// 123
function max_element(l){
","function max_element(l) {
    if (l.length === 0) return undefined; // Return undefined if the array is empty
    return Math.max(...l);
}","const assert = require('node:assert');


function test() {
  let candidate = max_element;
  assert.deepEqual(candidate([1, 2, 3]),3);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);
}

test();"
HumanEval_36,tam_Taml,js,"11 அல்லது 13 ஆல் வகுபடும் n ஐ விட சிறிய முழு எண்களில் 7 என்ற இலக்கத்தின் எண்ணிக்கையைத் திருப்பிக் கொடுங்கள்.// >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
function fizz_buzz(n){
","function fizz_buzz(n) {
    let count = 0;
    
    for (let i = 1; i < n; i++) {
        if (i % 11 === 0 || i % 13 === 0) {
            let numStr = i.toString();
            for (let char of numStr) {
                if (char === '7') {
                    count++;
                }
            }
        }
    }
    
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = fizz_buzz;
  assert.deepEqual(candidate(50),0);
  assert.deepEqual(candidate(78),2);
  assert.deepEqual(candidate(79),3);
  assert.deepEqual(candidate(100),3);
  assert.deepEqual(candidate(200),6);
  assert.deepEqual(candidate(4000),192);
  assert.deepEqual(candidate(10000),639);
  assert.deepEqual(candidate(100000),8026);
}

test();"
HumanEval_37,tam_Taml,js,"/ l இன் சம குறியீடுகளின் மதிப்புகளுக்கு, ஆனால் வரிசைப்படுத்தப்பட்டது./ l' என்பது l உடன் ஒத்ததாகும், அதேசமயம் அதன் மதிப்புகள் சமமான குறியீடுகளில் சமமாக இருக்கும்./இந்த செயல்பாடு ஒரு வரிசை l ஐ எடுத்து ஒரு வரிசை l' ஐ திருப்பித் தருகிறது.// >>> sort_even([1, 2, 3])
// [1, 2, 3]
// >>> sort_even([5, 6, 3, 4])
// [3, 6, 5, 4]
function sort_even(l){
","function sort_even(l) {
    // Extract the elements at even indices
    let evenElements = [];
    for (let i = 0; i < l.length; i += 2) {
        evenElements.push(l[i]);
    }

    // Sort the even elements
    evenElements.sort((a, b) => a - b);

    // Reconstruct the array with sorted even indices
    let result = [];
    let evenIndex = 0;
    for (let i = 0; i < l.length; i++) {
        if (i % 2 === 0) {
            result.push(evenElements[evenIndex]);
            evenIndex++;
        } else {
            result.push(l[i]);
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_even;
  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

test();"
HumanEval_39,tam_Taml,js,"/prime_fib ஒரு n-வது எண்ணை தருகிறது அது ஒரு ஃபீபனச்சி எண் மற்றும் அது பிரதானம்.// >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
function prime_fib(n){
","function prime_fib(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2; i * i <= num; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }
    
    function fibonacci() {
        let a = 0, b = 1;
        return function() {
            const next = a + b;
            a = b;
            b = next;
            return a;
        };
    }

    const fib = fibonacci();
    let count = 0;
    let primeFibNum;

    while (count < n) {
        const fibNum = fib();
        if (isPrime(fibNum)) {
            count++;
            primeFibNum = fibNum;
        }
    }

    return primeFibNum;
}","const assert = require('node:assert');


function test() {
  let candidate = prime_fib;
  assert.deepEqual(candidate(1),2);
  assert.deepEqual(candidate(2),3);
  assert.deepEqual(candidate(3),5);
  assert.deepEqual(candidate(4),13);
  assert.deepEqual(candidate(5),89);
  assert.deepEqual(candidate(6),233);
  assert.deepEqual(candidate(7),1597);
  assert.deepEqual(candidate(8),28657);
  assert.deepEqual(candidate(9),514229);
  assert.deepEqual(candidate(10),433494437);
}

test();"
HumanEval_40,tam_Taml,js,"/ தொகை பூஜ்ஜியமாகவும், மற்றபடி தவறாகவும் இருக்கும்./ அது வரிசையில் மூன்று தனித்தனி கூறுகள் இருந்தால் உண்மை என்று /triples_sum_to_zero ஒரு முழு எண்களின் வரிசையை உள்ளீடாக எடுக்கிறது.// >>> triples_sum_to_zero([1, 3, 5, 0])
// false
// >>> triples_sum_to_zero([1, 3, -2, 1])
// true
// >>> triples_sum_to_zero([1, 2, 3, 7])
// false
// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
// true
// >>> triples_sum_to_zero([1])
// false
function triples_sum_to_zero(l){
","function triples_sum_to_zero(l) {
    // Sort the array first
    l.sort((a, b) => a - b);
    // Iterate through each element in the array
    for (let i = 0; i < l.length - 2; i++) {
        // Use two pointers to find the other two elements
        let left = i + 1;
        let right = l.length - 1;
        while (left < right) {
            const sum = l[i] + l[left] + l[right];
            if (sum === 0) {
                return true;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = triples_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, 5, -1]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),true);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([1, 2, 5, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([1, 3, 5, -100]),false);
  assert.deepEqual(candidate([100, 3, 5, -100]),false);
}

test();"
HumanEval_41,tam_Taml,js,"/ இந்த செயல்பாடு இத்தகைய மோதல்களின் எண்ணிக்கையை வெளியிடுகிறது./ அவர்கள் மோதி இல்லை போல் தங்கள் பாதையில். / எனினும், கார்கள் மிகவும் வலுவானவை; இதன் விளைவாக, அவை தொடர்ந்து நகர்கின்றன./ இடமிருந்து வலமாக நகரும் ஒரு கார் வலமிருந்து இடமாக நகரும் ஒரு காரைத் தாக்கும் போது./ ஒருவருக்கொருவர். அனைத்து கார்களும் ஒரே வேகத்தில் நகர்கின்றன. இரண்டு கார்கள் மோதுகின்றன என்று கூறப்படுகிறது./ வலது இடது ஓட்டுகிறார்கள். இரண்டு கார் தொடங்குகிறது மிகவும் தொலைவில் இருந்து / n கார்கள் இடமிருந்து வலமாக ஓடுகின்றன; ஒரே நேரத்தில், n கார்களின் வேறுபட்ட தொகுப்பு /ஒரு சாலை என்று கற்பனை செய்யுங்கள் அது ஒரு சரியான நேராக முடிவில்லாமல் நீண்ட வரி.function car_race_collision(n){
","function car_race_collision(n) {
    // Each car moving left to right will collide with each car moving right to left exactly once.
    // Therefore, the number of collisions is n * n.
    return n * n;
}","const assert = require('node:assert');


function test() {
  let candidate = car_race_collision;
  assert.deepEqual(candidate(2),4);
  assert.deepEqual(candidate(3),9);
  assert.deepEqual(candidate(4),16);
  assert.deepEqual(candidate(8),64);
  assert.deepEqual(candidate(10),100);
}

test();"
HumanEval_42,tam_Taml,js,"/ 1 ஆல் அதிகரிக்கப்பட்ட கூறுகளுடன் வரிசையைத் திரும்புக.// >>> incr_list([1, 2, 3])
// [2, 3, 4]
// >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [6, 4, 6, 3, 4, 4, 10, 1, 124]
function incr_list(l){
","function incr_list(l) {
    return l.map(element => element + 1);
}","const assert = require('node:assert');


function test() {
  let candidate = incr_list;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);
  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

test();"
HumanEval_43,tam_Taml,js,"/ தொகை பூஜ்ஜியமாகவும், மற்றபடி தவறாகவும் இருக்கும்./ அது வரிசையில் இரண்டு தனித்தனி கூறுகள் இருந்தால் உண்மை என்று /pairs_sum_to_zero ஒரு முழு எண்களின் வரிசையை உள்ளீடாக எடுக்கிறது.// >>> pairs_sum_to_zero([1, 3, 5, 0])
// false
// >>> pairs_sum_to_zero([1, 3, -2, 1])
// false
// >>> pairs_sum_to_zero([1, 2, 3, 7])
// false
// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
// true
// >>> pairs_sum_to_zero([1])
// false
function pairs_sum_to_zero(l){
","function pairs_sum_to_zero(l) {
    const seen = new Set();
    
    for (const num of l) {
        if (seen.has(-num)) {
            return true;
        }
        seen.add(num);
    }
    
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = pairs_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),false);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);
}

test();"
HumanEval_44,tam_Taml,js,"/ அடிப்படை எண்கள் 10 க்கும் குறைவாக உள்ளன./ மாற்றத்திற்குப் பிறகு சரம் பிரதிநிதித்துவத்தை திரும்பப் பெறுகிறது./உள்ளீட்டு எண் x இன் எண் அடிப்படையை அடிப்படைக்கு மாற்றவும்.// >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
function change_base(x, base){
","function change_base(x, base) {
    if (base < 2 || base > 9) {
        throw new Error(""Base must be between 2 and 9."");
    }

    if (x === 0) {
        return ""0"";
    }

    let result = '';
    while (x > 0) {
        result = (x % base) + result;
        x = Math.floor(x / base);
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = change_base;
  assert.deepEqual(candidate(8, 3),""22"");
  assert.deepEqual(candidate(9, 3),""100"");
  assert.deepEqual(candidate(234, 2),""11101010"");
  assert.deepEqual(candidate(16, 2),""10000"");
  assert.deepEqual(candidate(8, 2),""1000"");
  assert.deepEqual(candidate(7, 2),""111"");
  assert.deepEqual(candidate(2, 3),""2"");
  assert.deepEqual(candidate(3, 4),""3"");
  assert.deepEqual(candidate(4, 5),""4"");
  assert.deepEqual(candidate(5, 6),""5"");
  assert.deepEqual(candidate(6, 7),""6"");
  assert.deepEqual(candidate(7, 8),""7"");
}

test();"
HumanEval_45,tam_Taml,js,"/ஒரு முக்கோணத்தின் பக்க நீளம் மற்றும் உயர் திரும்பும் பகுதி கொடுக்கப்பட்டால்.// >>> triangle_area(5, 3)
// 7.5
function triangle_area(a, h){
","function triangle_area(a, h) {
    return 0.5 * a * h;
}","const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(5, 3),7.5);
  assert.deepEqual(candidate(2, 2),2.0);
  assert.deepEqual(candidate(10, 8),40.0);
}

test();"
HumanEval_46,tam_Taml,js,"/ fib4 எண் வரிசையின் n-வது உறுப்பை திறம்பட கணக்கிட ஒரு செயல்பாட்டை எழுதுங்கள். மறுபடியும் பயன்படுத்த வேண்டாம்./ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)./ fib4(3) -> 0 / fib4(2) -> 2 / fib4(1) -> 0 / fib4(0) -> 0 /Fib4 எண் வரிசை என்பது பின்வருமாறு வரையறுக்கப்பட்ட ஃபீபொனாச்சி வரிசைக்கு ஒத்த ஒரு வரிசை ஆகும்: // >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
function fib4(n){
","function fib4(n) {
    if (n === 0) return 0;
    if (n === 1) return 0;
    if (n === 2) return 2;
    if (n === 3) return 0;
    
    let fibs = [0, 0, 2, 0];
    
    for (let i = 4; i <= n; i++) {
        let nextFib = fibs[0] + fibs[1] + fibs[2] + fibs[3];
        fibs.shift(); // Remove the first element
        fibs.push(nextFib); // Add the new element to the end
    }
    
    return fibs[3];
}","const assert = require('node:assert');


function test() {
  let candidate = fib4;
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),28);
  assert.deepEqual(candidate(10),104);
  assert.deepEqual(candidate(12),386);
}

test();"
HumanEval_47,tam_Taml,js,"/அரசியல் வரிசையில் உள்ள உறுப்புகளின் நடுத்தரத்தை திரும்பப் பெறுக l. // >>> median([3, 1, 2, 4, 5])
// 3
// >>> median([-10, 4, 6, 1000, 10, 20])
// 15.0
function median(l){
","function median(l) {
    // First, sort the array
    l.sort((a, b) => a - b);

    // Calculate the middle index
    const mid = Math.floor(l.length / 2);

    // If array length is odd, return the middle element
    if (l.length % 2 !== 0) {
        return l[mid];
    }
    // If array length is even, return the average of the two middle elements
    else {
        return (l[mid - 1] + l[mid]) / 2;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = median;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);
  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);
  assert.deepEqual(candidate([5]),5);
  assert.deepEqual(candidate([6, 5]),5.5);
  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);
}

test();"
HumanEval_48,tam_Taml,js,"/ கொடுக்கப்பட்ட சரம் ஒரு பாலிண்ட்ரோம் என்பதை சரிபார்க்கிறது.// >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
function is_palindrome(text){
","function is_palindrome(text){
    // Remove non-alphanumeric characters and convert to lower case
    const cleanedText = text.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    // Reverse the cleaned text
    const reversedText = cleanedText.split('').reverse().join('');
    // Check if the cleaned text is equal to its reverse
    return cleanedText === reversedText;
}","const assert = require('node:assert');


function test() {
  let candidate = is_palindrome;
  assert.deepEqual(candidate(""""),true);
  assert.deepEqual(candidate(""aba""),true);
  assert.deepEqual(candidate(""aaaaa""),true);
  assert.deepEqual(candidate(""zbcd""),false);
  assert.deepEqual(candidate(""xywyx""),true);
  assert.deepEqual(candidate(""xywyz""),false);
  assert.deepEqual(candidate(""xywzx""),false);
}

test();"
HumanEval_49,tam_Taml,js,"/2^n modulo p ஐ திரும்பப் பெறுக (எண்மங்களை நினைவில் கொள்ளுங்கள்).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
function modp(n, p){
","function modp(n, p) {
    if (p === 1) return 0; // Base case when p is 1

    // Initialize result
    let result = 1;
    let base = 2;

    while (n > 0) {
        // If n is odd, multiply base with result
        if (n % 2 === 1) {
            result = (result * base) % p;
        }

        // n must be even now
        n = Math.floor(n / 2);
        base = (base * base) % p; 
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = modp;
  assert.deepEqual(candidate(3, 5),3);
  assert.deepEqual(candidate(1101, 101),2);
  assert.deepEqual(candidate(0, 101),1);
  assert.deepEqual(candidate(3, 11),8);
  assert.deepEqual(candidate(100, 101),1);
  assert.deepEqual(candidate(30, 5),4);
  assert.deepEqual(candidate(31, 5),3);
}

test();"
HumanEval_51,tam_Taml,js,"/remove_vowels என்பது ஒரு செயல்பாடு ஆகும். இது சரம் எடுத்து சரம் இல்லாமல் திருப்பி விடுகிறது.// >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
function remove_vowels(text){
","function remove_vowels(text) {
    return text.replace(/[aeiouAEIOU]/g, '');
}","const assert = require('node:assert');


function test() {
  let candidate = remove_vowels;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""abcdef
ghijklm""),""bcdf
ghjklm"");
  assert.deepEqual(candidate(""fedcba""),""fdcb"");
  assert.deepEqual(candidate(""eeeee""),"""");
  assert.deepEqual(candidate(""acBAA""),""cB"");
  assert.deepEqual(candidate(""EcBOO""),""cB"");
  assert.deepEqual(candidate(""ybcd""),""ybcd"");
}

test();"
HumanEval_52,tam_Taml,js,"/அரசியலில் உள்ள அனைத்து எண்களும் உச்சநிலை t க்குக் கீழே இருந்தால் true எனத் திருப்பித் தரவும்.// >>> below_threshold([1, 2, 4, 10], 100)
// true
// >>> below_threshold([1, 20, 4, 10], 5)
// false
function below_threshold(l, t){
","function below_threshold(l, t) {
    return l.every(num => num < t);
}","const assert = require('node:assert');


function test() {
  let candidate = below_threshold;
  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);
  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);
}

test();"
HumanEval_53,tam_Taml,js,"/இரண்டு எண்களை x மற்றும் y சேர்க்கவும்.// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
function add(x, y){
","function add(x, y) {
    return x + y;
}","const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate(0, 1),1);
  assert.deepEqual(candidate(1, 0),1);
  assert.deepEqual(candidate(2, 3),5);
  assert.deepEqual(candidate(5, 7),12);
  assert.deepEqual(candidate(7, 5),12);
}

test();"
HumanEval_54,tam_Taml,js,"/இரண்டு சொற்களில் ஒரே எழுத்துக்கள் உள்ளதா என சரிபார்க்கவும். // >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
function same_chars(s0, s1){
","function same_chars(s0, s1) {
    const charSet0 = new Set(s0);
    const charSet1 = new Set(s1);

    if (charSet0.size !== charSet1.size) return false;

    for (let char of charSet0) {
        if (!charSet1.has(char)) return false;
    }

    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = same_chars;
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""),true);
  assert.deepEqual(candidate(""abcd"", ""dddddddabc""),true);
  assert.deepEqual(candidate(""dddddddabc"", ""abcd""),true);
  assert.deepEqual(candidate(""eabcd"", ""dddddddabc""),false);
  assert.deepEqual(candidate(""abcd"", ""dddddddabcf""),false);
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""),false);
  assert.deepEqual(candidate(""aabb"", ""aaccc""),false);
}

test();"
HumanEval_55,tam_Taml,js,"/n-வது ஃபீபனச்சி எண்ணைத் திருப்பிக் கொடுங்கள். // >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
function fib(n){
","function fib(n) {
    if (n <= 1) return n;
    let a = 0, b = 1, result = 1;
    for (let i = 2; i <= n; i++) {
        result = a + b;
        a = b;
        b = result;
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = fib;
  assert.deepEqual(candidate(10),55);
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(8),21);
  assert.deepEqual(candidate(11),89);
  assert.deepEqual(candidate(12),144);
}

test();"
HumanEval_56,tam_Taml,js,"/ ஒவ்வொரு திறப்பு அடைப்புக்குறிக்கும் அதனுடன் தொடர்புடைய மூடுதல் அடைப்புக்குறி இருந்தால் true ஐத் திரும்புகிறது./brackets என்பது ""<"" மற்றும் "">"" ன் ஒரு சரம்.// >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
function correct_bracketing(brackets){
","function correct_bracketing(brackets) {
    let balance = 0;
    for (let char of brackets) {
        if (char === '<') {
            balance += 1;
        } else if (char === '>') {
            balance -= 1;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""<>""),true);
  assert.deepEqual(candidate(""<<><>>""),true);
  assert.deepEqual(candidate(""<><><<><>><>""),true);
  assert.deepEqual(candidate(""<><><<<><><>><>><<><><<>>>""),true);
  assert.deepEqual(candidate(""<<<><>>>>""),false);
  assert.deepEqual(candidate(""><<>""),false);
  assert.deepEqual(candidate(""<""),false);
  assert.deepEqual(candidate(""<<<<""),false);
  assert.deepEqual(candidate("">""),false);
  assert.deepEqual(candidate(""<<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>><<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>>><>""),false);
}

test();"
HumanEval_57,tam_Taml,js,"/ true எனத் திருப்பித் தரவும், வரிசை உறுப்புகள் ஒரே மாதிரியாக அதிகரிக்கும் அல்லது குறைந்துவிடும்.// >>> monotonic([1, 2, 4, 20])
// true
// >>> monotonic([1, 20, 4, 10])
// false
// >>> monotonic([4, 1, 0, -10])
// true
function monotonic(l){
","function monotonic(l) {
    if (l.length <= 1) return true;
    let isIncreasing = true;
    let isDecreasing = true;
    
    for (let i = 1; i < l.length; i++) {
        if (l[i] > l[i - 1]) {
            isDecreasing = false;
        } else if (l[i] < l[i - 1]) {
            isIncreasing = false;
        }
        
        if (!isIncreasing && !isDecreasing) return false;
    }
    
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = monotonic;
  assert.deepEqual(candidate([1, 2, 4, 10]),true);
  assert.deepEqual(candidate([1, 2, 4, 20]),true);
  assert.deepEqual(candidate([1, 20, 4, 10]),false);
  assert.deepEqual(candidate([4, 1, 0, -10]),true);
  assert.deepEqual(candidate([4, 1, 1, 0]),true);
  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);
  assert.deepEqual(candidate([9, 9, 9, 9]),true);
}

test();"
HumanEval_58,tam_Taml,js,"/இரண்டு வரிசைகளுக்கு ஒழுங்கமைக்கப்பட்ட தனித்துவமான பொதுவான கூறுகளைத் தருகிறது.// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
// [1, 5, 653]
// >>> common([5, 3, 2, 8], [3, 2])
// [2, 3]
function common(l1, l2){
","function common(l1, l2) {
    const set1 = new Set(l1);
    const set2 = new Set(l2);
    const result = [...set1].filter(item => set2.has(item));
    return result.sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = common;
  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);
  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);
  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);
}

test();"
HumanEval_59,tam_Taml,js,"/n இன் மிகப்பெரிய பிரதான காரணி திரும்பவும். n > 1 எனக் கருதி, பிரதான எண்ணாக இருக்காது.// >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
function largest_prime_factor(n){
","function largest_prime_factor(n) {
  let largest = -1;
  while (n % 2 === 0) {
    largest = 2;
    n /= 2;
  }
  
  for (let factor = 3; factor * factor <= n; factor += 2) {
    while (n % factor === 0) {
      largest = factor;
      n /= factor;
    }
  }
  
  if (n > 2) {
    largest = n;
  }
  
  return largest;
}","const assert = require('node:assert');


function test() {
  let candidate = largest_prime_factor;
  assert.deepEqual(candidate(15),5);
  assert.deepEqual(candidate(27),3);
  assert.deepEqual(candidate(63),7);
  assert.deepEqual(candidate(330),11);
  assert.deepEqual(candidate(13195),29);
}

test();"
HumanEval_60,tam_Taml,js,"/sum_to_n என்பது 1 முதல் n வரை உள்ள எண்களைக் கூட்டுகின்ற ஒரு செயல்பாடு ஆகும்.// >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
function sum_to_n(n){
","function sum_to_n(n) {
    return n * (n + 1) / 2;
}","const assert = require('node:assert');


function test() {
  let candidate = sum_to_n;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(6),21);
  assert.deepEqual(candidate(11),66);
  assert.deepEqual(candidate(30),465);
  assert.deepEqual(candidate(100),5050);
}

test();"
HumanEval_61,tam_Taml,js,"/ ஒவ்வொரு திறப்பு அடைப்புக்குறிக்கும் அதனுடன் தொடர்புடைய மூடுதல் அடைப்புக்குறி இருந்தால் true ஐத் திரும்புகிறது./brackets என்பது ""("" மற்றும் """") ன் ஒரு சரம்.// >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
function correct_bracketing(brackets){
","function correct_bracketing(brackets) {
    let balance = 0;
    for (let i = 0; i < brackets.length; i++) {
        if (brackets[i] === '(') {
            balance++;
        } else if (brackets[i] === ')') {
            balance--;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""()""),true);
  assert.deepEqual(candidate(""(()())""),true);
  assert.deepEqual(candidate(""()()(()())()""),true);
  assert.deepEqual(candidate(""()()((()()())())(()()(()))""),true);
  assert.deepEqual(candidate(""((()())))""),false);
  assert.deepEqual(candidate("")(()""),false);
  assert.deepEqual(candidate(""(""),false);
  assert.deepEqual(candidate(""((((""),false);
  assert.deepEqual(candidate("")""),false);
  assert.deepEqual(candidate(""(()""),false);
  assert.deepEqual(candidate(""()()(()())())(()""),false);
  assert.deepEqual(candidate(""()()(()())()))()""),false);
}

test();"
HumanEval_62,tam_Taml,js,"/ இந்த பன்மையின் வழித்தோன்றலை அதே வடிவத்தில் திருப்பிக் கொடுங்கள்./ xs[0] + xs[1] * x + xs[2] * x^2 + .... /xs என்பது பன்முனைகளின் குணகங்களை குறிக்கிறது.// >>> derivative([3, 1, 2, 4, 5])
// [1, 4, 12, 20]
// >>> derivative([1, 2, 3])
// [2, 6]
function derivative(xs){
","function derivative(xs) {
    const result = [];
    for (let i = 1; i < xs.length; i++) {
        result.push(xs[i] * i);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = derivative;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);
  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);
  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);
  assert.deepEqual(candidate([1]),[]);
}

test();"
HumanEval_63,tam_Taml,js,"/ தயவுசெய்து fibfib எண் வரிசையின் n-வது உறுப்பை திறம்பட கணக்கிட ஒரு செயல்பாட்டை எழுதுங்கள்./ fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). / fib fib ((2) == 1 / fib fib ((1) == 0 / fib fib ((0) == 0 /FibFib எண் வரிசை என்பது பின்வருமாறு வரையறுக்கப்பட்ட ஃபீபொனாச்சி வரிசைக்கு ஒத்த ஒரு வரிசை ஆகும்: // >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
function fibfib(n){
","function fibfib(n) {
    if (n === 0 || n === 1) return 0;
    if (n === 2) return 1;
    
    let a = 0, b = 0, c = 1, d;

    for (let i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    
    return c;
}","const assert = require('node:assert');


function test() {
  let candidate = fibfib;
  assert.deepEqual(candidate(2),1);
  assert.deepEqual(candidate(1),0);
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),24);
  assert.deepEqual(candidate(10),81);
  assert.deepEqual(candidate(12),274);
  assert.deepEqual(candidate(14),927);
}

test();"
HumanEval_64,tam_Taml,js,"/ உதாரணம்: / எழுத்து, ஆனால் அது கொடுக்கப்பட்ட வார்த்தையின் முடிவில் இருக்கும்போது மட்டுமே./ இந்த வழக்கில் உள்ள எழுத்துக்கள் 'a', 'e', 'i', 'o', 'u'. இங்கே, 'y' என்பது ஒரு / ஒரு வார்த்தையை உள்ளீடாக வைத்து, சரத்தில் உள்ள எழுத்துக்களின் எண்ணிக்கையைத் தருகிறது./ஒரு செயல்பாட்டை எழுதுங்கள் vowels_count இது ஒரு சரம் எடுக்கும் // >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
function vowels_count(s){
","function vowels_count(s) {
    const vowels = 'aeiou';
    let count = 0;
    s = s.toLowerCase();
    
    for (let i = 0; i < s.length; i++) {
        if (vowels.includes(s[i]) || (i === s.length - 1 && s[i] === 'y')) {
            count++;
        }
    }

    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = vowels_count;
  assert.deepEqual(candidate(""abcde""),2);
  assert.deepEqual(candidate(""Alone""),3);
  assert.deepEqual(candidate(""key""),2);
  assert.deepEqual(candidate(""bye""),1);
  assert.deepEqual(candidate(""keY""),2);
  assert.deepEqual(candidate(""bYe""),1);
  assert.deepEqual(candidate(""ACEDY""),3);
}

test();"
HumanEval_65,tam_Taml,js,"/ shift > இலக்கங்களின் எண்ணிக்கை என்றால், இலக்கங்கள் தலைகீழாக திரும்பும்./ மற்றும் ஒரு சரம் என முடிவு திரும்ப. /சுற்றுச்சூழல் x இன் முழு எண்களின் இலக்கங்களை இடமாற்றுகிறது, இடமாற்றத்தின் மூலம் இலக்கங்களை வலதுபுறமாக நகர்த்துகிறது.// >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
function circular_shift(x, shift){
","function circular_shift(x, shift) {
    let numStr = x.toString();
    let length = numStr.length;

    if (shift > length) {
        return numStr.split('').reverse().join('');
    } else {
        let endPart = numStr.slice(-shift);
        let startPart = numStr.slice(0, length - shift);
        return endPart + startPart;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = circular_shift;
  assert.deepEqual(candidate(100, 2),""001"");
  assert.deepEqual(candidate(12, 2),""12"");
  assert.deepEqual(candidate(97, 8),""79"");
  assert.deepEqual(candidate(12, 1),""21"");
  assert.deepEqual(candidate(11, 101),""11"");
}

test();"
HumanEval_66,tam_Taml,js,"/ உதாரணங்கள்: / ASCII குறியீடுகள்./ ஒரு சரத்தை உள்ளீடாக எடுத்து மேல் எழுத்துக்களின் தொகையை மட்டுமே திருப்பித் தரும் ஒரு செயல்பாட்டை எழுதுக' / பணி // >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
function digitSum(s){
","function digitSum(s) {
    let sum = 0;
    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (char >= 'A' && char <= 'Z') {
            sum += char.charCodeAt(0);
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = digitSum;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abAB""),131);
  assert.deepEqual(candidate(""abcCd""),67);
  assert.deepEqual(candidate(""helloE""),69);
  assert.deepEqual(candidate(""woArBld""),131);
  assert.deepEqual(candidate(""aAaaaXa""),153);
  assert.deepEqual(candidate("" How are yOu?""),151);
  assert.deepEqual(candidate(""You arE Very Smart""),327);
}

test();"
HumanEval_67,tam_Taml,js,"/ examble க்கு:/ கூடைக்குள் உள்ள மாங்கோ பழங்களின் எண்ணிக்கையைத் திருப்பிக் கொடுங்கள்./ ஆரஞ்சு மற்றும் ஆப்பிள் மற்றும் பழங்களின் மொத்த எண்ணிக்கையை குறிக்கும் ஒரு முழு எண் / ஆப்பிள்கள், ஆரஞ்சுகள், மற்றும் மாங்கோ பழங்கள்./ இந்த கூடை உள்ள பழங்கள் ஒரு கூடை விநியோகிக்கப்படும் என்று /இந்த பணியில், உங்களுக்கு ஒரு எண் ஆப்பிள் மற்றும் ஆரஞ்சுகளை குறிக்கும் ஒரு சரம் கொடுக்கப்படும்.// >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
function fruit_distribution(s, n){
","function fruit_distribution(s, n) {
    let apples = 0;
    let oranges = 0;
    
    // Regular expressions to extract the number of apples and oranges from the string
    const applesMatch = s.match(/(\d+)\s*apples/);
    const orangesMatch = s.match(/(\d+)\s*oranges/);
    
    // If a match is found, parse the number
    if (applesMatch) {
        apples = parseInt(applesMatch[1], 10);
    }
    if (orangesMatch) {
        oranges = parseInt(orangesMatch[1], 10);
    }
    
    // Calculate the number of mangoes
    const mangoes = n - (apples + oranges);
    return mangoes;
}","const assert = require('node:assert');


function test() {
  let candidate = fruit_distribution;
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 19),8);
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 21),10);
  assert.deepEqual(candidate(""0 apples and 1 oranges"", 3),2);
  assert.deepEqual(candidate(""1 apples and 0 oranges"", 3),2);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 100),95);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 5),0);
  assert.deepEqual(candidate(""1 apples and 100 oranges"", 120),19);
}

test();"
HumanEval_68,tam_Taml,js,"/ உதாரணம் 1: / சம மதிப்புகள் இல்லை அல்லது கொடுக்கப்பட்ட வரிசை காலியாக இருந்தால், திரும்பவும் []./ பிடுங்கப்பட்ட node ஒரு array, [small_value, அதன் index], ல் திரும்ப வேண்டும்,/ ஒரே சிறிய சம மதிப்பு கொண்ட பல முனைகள் காணப்பட்டால், மிகச்சிறிய குறியீட்டைக் கொண்ட முனையைத் திருப்பித் தரவும். / துண்டிக்கப்பட்ட முனை மிகச்சிறிய சம மதிப்புள்ள முனையாக இருக்க வேண்டும்./ உங்கள் பணி முனைகளில் ஒன்றை பிடுங்கி அதை திருப்பித் தருவது. /""ஒரு மரத்தின் கிளைகளை குறிக்கும் ஒரு வரிசை கொடுக்கப்பட்டால், அது எதிர்மறை அல்லாத முழு எண் முனைகளைக் கொண்டுள்ளது // >>> pluck([4, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([1, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([])
// []
// Example 4:
// >>> pluck([5, 0, 3, 0, 4, 2])
// [0, 1]
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
function pluck(arr){
","function pluck(arr) {
    let smallestEvenValue = Infinity;
    let smallestEvenIndex = -1;

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) {
            if (arr[i] < smallestEvenValue) {
                smallestEvenValue = arr[i];
                smallestEvenIndex = i;
            }
        }
    }

    return smallestEvenIndex === -1 ? [] : [smallestEvenValue, smallestEvenIndex];
}","const assert = require('node:assert');


function test() {
  let candidate = pluck;
  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);
  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);
  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);
  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);
  assert.deepEqual(candidate([7, 9, 7, 1]),[]);
}

test();"
HumanEval_69,tam_Taml,js,"/ உதாரணங்கள்: / அத்தகைய மதிப்பு இல்லை என்றால், திரும்ப -1./ ஒரு முழு எண்ணின் அதிர்வெண் என்பது அது வரிசையில் தோன்றும் முறைகளின் எண்ணிக்கை ஆகும்./ பூஜ்யம், மற்றும் முழு எண் மதிப்பை விட அதிகமாக அல்லது சமமாக ஒரு அதிர்வெண் உள்ளது./நீங்கள் நேர்மறை முழு எண்களின் காலியாக இல்லாத வரிசை கொடுக்கப்பட்டுள்ளது.  க்கு பெரிய பெரிய முழு எண் திரும்பவும்.// >>> search([4, 1, 2, 2, 3, 1])
// 2
// >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])
// 3
// >>> search([5, 5, 4, 4, 4])
// -1
function search(lst){
","function search(lst) {
    const frequencyMap = new Map();

    lst.forEach(num => {
        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
    });

    let result = -1;

    frequencyMap.forEach((count, num) => {
        if (count >= num && num > 0 && num > result) {
            result = num;
        }
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = search;
  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);
  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);
  assert.deepEqual(candidate([3, 3]),-1);
  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);
  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);
  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);
  assert.deepEqual(candidate([3, 2, 8, 2]),2);
  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);
  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);
  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);
  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);
  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);
  assert.deepEqual(candidate([1]),1);
  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);
  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);
  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);
  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);
  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);
  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);
  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);
  assert.deepEqual(candidate([10]),-1);
  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);
  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);
  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);
  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);
}

test();"
HumanEval_70,tam_Taml,js,"/ உதாரணங்கள்: / பின்னர் மீதமுள்ள முழு எண்களின் அதிகபட்ச, பின்னர் குறைந்தபட்ச மற்றும் பல./ விசித்திரமான வரிசைப்படுத்தல், நீங்கள் குறைந்தபட்ச மதிப்பு தொடங்கும் போது, /எழுத்துகள் கொடுக்கப்பட்டால், வரிசைகள் விசித்திரமான வரிசையில் திரும்பும்.// >>> strange_sort_list([1, 2, 3, 4])
// [1, 4, 2, 3]
// >>> strange_sort_list([5, 5, 5, 5])
// [5, 5, 5, 5]
// >>> strange_sort_list([])
// []
function strange_sort_list(lst){
","function strange_sort_list(lst) {
    let result = [];
    lst.sort((a, b) => a - b); // Sort the array in ascending order

    while (lst.length) {
        result.push(lst.shift()); // Add the minimum element
        if (lst.length) {
            result.push(lst.pop()); // Add the maximum element
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = strange_sort_list;
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);
  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);
  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);
  assert.deepEqual(candidate([111111]),[111111]);
}

test();"
HumanEval_71,tam_Taml,js,"/ உதாரணம்: / மூன்றாவது பக்கத்தை விட. / மூன்று பக்கங்கள் எந்த இரண்டு பக்கங்களின் கூட்டுத்தொகை அதிகமாக இருக்கும்போது ஒரு செல்லுபடியாகும் முக்கோணத்தை உருவாக்குகின்றன./ இல்லையெனில் -1 க்கு திரும்பு/ முக்கோணத்தின் மூன்று பக்கங்களும் ஒரு சரியான முக்கோணத்தை உருவாக்குகின்றன என்றால், முக்கோணத்தை 2 தசம புள்ளிகளுக்கு வட்டமாக்கவும்./ஒரு முக்கோணத்தின் மூன்று பக்கங்களின் நீளங்களைக் கொடுத்தால்.// >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
function triangle_area(a, b, c){
","function triangle_area(a, b, c) {
    // Check if the sides form a valid triangle
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area
        const s = (a + b + c) / 2;
        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        // Return the area rounded to 2 decimal places
        return Math.round(area * 100) / 100;
    } else {
        // Return -1 for an invalid triangle
        return -1;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(3, 4, 5),6.0);
  assert.deepEqual(candidate(1, 2, 10),-1);
  assert.deepEqual(candidate(4, 8, 5),8.18);
  assert.deepEqual(candidate(2, 2, 2),1.73);
  assert.deepEqual(candidate(1, 2, 3),-1);
  assert.deepEqual(candidate(10, 5, 7),16.25);
  assert.deepEqual(candidate(2, 6, 3),-1);
  assert.deepEqual(candidate(1, 1, 1),0.43);
  assert.deepEqual(candidate(2, 2, 10),-1);
}

test();"
HumanEval_72,tam_Taml,js,"/ உதாரணம்: / q என்பது சமநிலையில் இருந்தால் அது பறக்கும் (இது ஒரு பாலிண்ட்ரோம் வரிசை) மற்றும் அதன் கூறுகளின் தொகை அதிகபட்ச எடை w ஐ விட குறைவாகவோ அல்லது சமமாகவோ இருந்தால்./ஒரு செயல்பாட்டை எழுதுக, அது object q பறக்கும் போது true ஆகவும், இல்லையெனில் false ஆகவும் இருக்கும்.// >>> will_it_fly([1, 2], 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([3, 2, 3], 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([3, 2, 3], 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([3], 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
function will_it_fly(q, w){
","function will_it_fly(q, w) {
    // Check if q is a palindromic array
    function isPalindromic(arr) {
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] !== arr[arr.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }

    // Calculate the sum of the array
    function sumArray(arr) {
        return arr.reduce((acc, val) => acc + val, 0);
    }

    // Check if the array is balanced and the sum is within the limit
    return isPalindromic(q) && sumArray(q) <= w;
}","const assert = require('node:assert');


function test() {
  let candidate = will_it_fly;
  assert.deepEqual(candidate([3, 2, 3], 9),true);
  assert.deepEqual(candidate([1, 2], 5),false);
  assert.deepEqual(candidate([3], 5),true);
  assert.deepEqual(candidate([3, 2, 3], 1),false);
  assert.deepEqual(candidate([1, 2, 3], 6),false);
  assert.deepEqual(candidate([5], 5),true);
}

test();"
HumanEval_73,tam_Taml,js,"/ உதாரணமாக: / என்பது முன்னும் பின்னும் ஒரே மாதிரியாகப் படிக்கப்படுகிறது. ஒரு மாற்றத்தில், நீங்கள் ஒரு உறுப்பை வேறு எந்த உறுப்பிற்கும் மாற்றலாம்./ வரிசையை பாலிண்ட்ரோம் ஆக மாற்ற வேண்டும். ஒரு பாலிண்ட்ரோம் வரிசை என்பது ஒரு வரிசை ஆகும்./ஒரு வரிசை arr முழு எண்களைக் கொடுத்தால், க்கு குறைந்தபட்ச உறுப்புகளின் எண்ணிக்கையைக் கண்டறியவும்// >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])
// 4
// >>> smallest_change([1, 2, 3, 4, 3, 2, 2])
// 1
// >>> smallest_change([1, 2, 3, 2, 1])
// 0
function smallest_change(arr){
","function smallest_change(arr) {
    let changes = 0;
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        if (arr[left] !== arr[right]) {
            changes++;
        }
        left++;
        right--;
    }

    return changes;
}","const assert = require('node:assert');


function test() {
  let candidate = smallest_change;
  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);
  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);
  assert.deepEqual(candidate([1, 4, 2]),1);
  assert.deepEqual(candidate([1, 4, 4, 2]),1);
  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);
  assert.deepEqual(candidate([3, 1, 1, 3]),0);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([0, 1]),1);
}

test();"
HumanEval_74,tam_Taml,js,"/ உதாரணங்கள் / இரண்டு வரிசைகளும் ஒரே எண்ணிக்கையிலான எழுத்துக்களைக் கொண்டிருந்தால், முதல் வரிசையைத் திருப்பித் தரவும்./ வரிசையின் அனைத்து சரங்களிலும் உள்ள மொத்த எண்ணிக்கை மற்ற வரிசைகளை விட குறைவாக உள்ளது./ஒரு செயல்பாட்டை எழுதுக இரண்டு வரிசைகளை ஏற்றுக்கொண்டு வரிசையை திருப்பிக் கொடுக்கும்// >>> total_match([], [])
// []
// >>> total_match([""hi"", ""admin""], [""hI"", ""Hi""])
// [""hI"", ""Hi""]
// >>> total_match([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
// [""hi"", ""admin""]
// >>> total_match([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
// [""hI"", ""hi"", ""hi""]
// >>> total_match([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
// [""4""]
function total_match(lst1, lst2){
","function total_match(lst1, lst2) {
    // Helper function to calculate total characters in an array of strings
    const totalChars = (arr) => arr.reduce((sum, str) => sum + str.length, 0);

    const total1 = totalChars(lst1);
    const total2 = totalChars(lst2);

    if (total1 < total2) {
        return lst1;
    } else {
        return lst2;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = total_match;
  assert.deepEqual(candidate([], []),[]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi""]),[""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]),[""4""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""Hi""]),[""hI"", ""Hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]),[""hI"", ""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([], [""this""]),[]);
  assert.deepEqual(candidate([""this""], []),[]);
}

test();"
HumanEval_75,tam_Taml,js,"/ உதாரணம்: / (a) 100 க்குக் குறைவாக இருப்பதை அறிவது./ மற்றும் தவறான மற்றபடி. / கொடுக்கப்பட்ட எண் 3 பிரதான எண்களின் பெருக்கத்தால் true எனும் வினைச்சொல்லை எழுதுக.// >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
function is_multiply_prime(a){
","function is_prime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}

function generate_primes(upper_limit) {
    const primes = [];
    for (let num = 2; num < upper_limit; num++) {
        if (is_prime(num)) {
            primes.push(num);
        }
    }
    return primes;
}

function is_multiply_prime(a) {
    if (a < 2) return false;
    const primes = generate_primes(100);
    const primesLength = primes.length;

    for (let i = 0; i < primesLength; i++) {
        for (let j = i; j < primesLength; j++) {
            for (let k = j; k < primesLength; k++) {
                if (primes[i] * primes[j] * primes[k] === a) {
                    return true;
                }
            }
        }
    }

    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = is_multiply_prime;
  assert.deepEqual(candidate(5),false);
  assert.deepEqual(candidate(30),true);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),false);
  assert.deepEqual(candidate(125),true);
  assert.deepEqual(candidate(105),true);
  assert.deepEqual(candidate(126),false);
  assert.deepEqual(candidate(729),false);
  assert.deepEqual(candidate(891),false);
  assert.deepEqual(candidate(1001),true);
}

test();"
HumanEval_76,tam_Taml,js,"/ உதாரணமாக: / x என்பது n இன் எளிய பவர் ஆகும், n**int=x  என்றால்/ n இன் சக்தி மற்றும் மற்ற சந்தர்ப்பங்களில் தவறானது./உங்கள் பணி ஒரு எண் x ஒரு எளிய என்றால் உண்மை என்று ஒரு செயல்பாடு எழுத உள்ளது // >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
function is_simple_power(x, n){
","function is_simple_power(x, n) {
    if (x === 1) return true;  // Any number to the power of zero is 1
    if (n <= 1) return false;  // n must be greater than 1 to have simple powers other than itself

    let power = n;
    while (power < x) {
        power *= n;
    }

    return power === x;
}","const assert = require('node:assert');


function test() {
  let candidate = is_simple_power;
  assert.deepEqual(candidate(16, 2),true);
  assert.deepEqual(candidate(143214, 16),false);
  assert.deepEqual(candidate(4, 2),true);
  assert.deepEqual(candidate(9, 3),true);
  assert.deepEqual(candidate(16, 4),true);
  assert.deepEqual(candidate(24, 2),false);
  assert.deepEqual(candidate(128, 4),false);
  assert.deepEqual(candidate(12, 6),false);
  assert.deepEqual(candidate(1, 1),true);
  assert.deepEqual(candidate(1, 12),true);
}

test();"
HumanEval_77,tam_Taml,js,"/ உதாரணங்கள்: / குறிப்பு: உள்ளீடு எப்போதும் செல்லுபடியாகும் என்று நீங்கள் கருதலாம்./ இந்த இன்ஜெர் ஒரு முழு எண் ஒரு கனசதுரம் என்றால்./ஒரு முழு எண் aஐ எடுத்து trueஐ கொடுக்கும் ஒரு செயல்பாட்டை எழுதுக.// >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
function iscube(a){
","function iscube(a) {
    if (a < 0) a = -a;
    let cubeRoot = Math.round(Math.pow(a, 1/3));
    return cubeRoot * cubeRoot * cubeRoot === a;
}","const assert = require('node:assert');


function test() {
  let candidate = iscube;
  assert.deepEqual(candidate(1),true);
  assert.deepEqual(candidate(2),false);
  assert.deepEqual(candidate(-1),true);
  assert.deepEqual(candidate(64),true);
  assert.deepEqual(candidate(180),false);
  assert.deepEqual(candidate(1000),true);
  assert.deepEqual(candidate(0),true);
  assert.deepEqual(candidate(1729),false);
}

test();"
HumanEval_78,tam_Taml,js,"/ உதாரணங்கள்: / மற்றும் A,B,C,D,E,F ஆகிய குறியீடுகள் எப்போதும் பெரிய எழுத்துக்களில் எழுதப்பட்டிருக்கும்./ குறிப்பு: உள்ளீடு எப்போதும் சரியானது அல்லது காலியாக இருக்கும் என்று நீங்கள் கருதலாம் சரம், / B (= தசம 11), D (= தசம 13)./ எனவே நீங்கள் பின்வரும் இலக்கங்களின் எண்ணிக்கையை தீர்மானிக்க வேண்டும்: 2, 3, 5, 7, / பிரதான எண்கள் 2, 3, 5, 7, 11, 13, 17,... / அறுபது இலக்க இலக்கங்கள் 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. / 1 ஐ விட பெரியது இது இரண்டு சிறிய இயற்கை எண்களின் கூட்டுத்தொகை அல்ல)./ இலக்கங்கள் பிரதான எண்களாக உள்ளன (பிரதான எண், அல்லது ஒரு பிரதான எண், ஒரு இயற்கை எண் / ஒரு ஹெக்ஸாடெசிமல் எண்ணை ஒரு சரம் மற்றும் ஹெக்ஸாடெசிமல் எண்ணிக்கையை எண்ணும் /நீங்கள் ஒரு பெறுகின்ற செயல்பாடு எழுத பணிபுரிந்தனர் // >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
function hex_key(num){
","function hex_key(num) {
    // Define a set of hexadecimal digits that are prime numbers
    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);
    
    // Initialize a count variable to track the number of prime digits
    let count = 0;
    
    // Iterate over each character in the input string
    for (let char of num) {
        // Check if the character is in the set of prime hexadecimal digits
        if (primeHexDigits.has(char)) {
            // Increment the count if the character is a prime digit
            count++;
        }
    }
    
    // Return the total count of prime hexadecimal digits
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = hex_key;
  assert.deepEqual(candidate(""AB""),1);
  assert.deepEqual(candidate(""1077E""),2);
  assert.deepEqual(candidate(""ABED1A33""),4);
  assert.deepEqual(candidate(""2020""),2);
  assert.deepEqual(candidate(""123456789ABCDEF0""),6);
  assert.deepEqual(candidate(""112233445566778899AABBCCDDEEFF00""),12);
}

test();"
HumanEval_79,tam_Taml,js,"/ உதாரணங்கள்: / கூடுதல் எழுத்துக்கள் வடிவமைப்பிற்கு உதவுகின்றன./ தொடக்கத்திலும் இறுதியிலும் ஒரு கூடுதல் 'db' எழுத்துக்கள் இருக்கும்./ எண். சரத்தில் உள்ள ஒவ்வொரு எழுத்து '0' அல்லது '1' ஆக இருக்கும்./ பைனரி வடிவம். செயல்பாடு ஒரு சரத்தை திரும்பப் பெற வேண்டும், ஒவ்வொரு எழுத்து ஒரு பைனரி /உங்களுக்கு ஒரு எண் தசம வடிவத்தில் கொடுக்கப்படும், உங்கள் பணி அதை க்கு மாற்ற வேண்டும்.// >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
function decimal_to_binary(decimal){
","function decimal_to_binary(decimal) {
    // Convert the decimal number to a binary string
    let binaryString = decimal.toString(2);
    // Add 'db' at the beginning and end of the binary string
    return 'db' + binaryString + 'db';
}","const assert = require('node:assert');


function test() {
  let candidate = decimal_to_binary;
  assert.deepEqual(candidate(0),""db0db"");
  assert.deepEqual(candidate(32),""db100000db"");
  assert.deepEqual(candidate(103),""db1100111db"");
  assert.deepEqual(candidate(15),""db1111db"");
}

test();"
HumanEval_80,tam_Taml,js,"/ உதாரணமாக: / ஒரு சரம் அதன் நீளம் குறைந்தது 3 மற்றும் ஒவ்வொரு 3 தொடர்ச்சியான கடிதங்கள் வேறுபட்டவை என்றால் மகிழ்ச்சியாக உள்ளது / உங்கள் பணி சரம் hapjs அல்லது இல்லை என்பதை சரிபார்க்க உள்ளது. /நீங்கள் ஒரு சரம் கொடுக்கப்பட்ட // >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
function is_happy(s){
","function is_happy(s) {
    if (s.length < 3) return false;
    for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {
            return false;
        }
    }
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_happy;
  assert.deepEqual(candidate(""a""),false);
  assert.deepEqual(candidate(""aa""),false);
  assert.deepEqual(candidate(""abcd""),true);
  assert.deepEqual(candidate(""aabb""),false);
  assert.deepEqual(candidate(""adb""),true);
  assert.deepEqual(candidate(""xyy""),false);
  assert.deepEqual(candidate(""iopaxpoi""),true);
  assert.deepEqual(candidate(""iopaxioi""),false);
}

test();"
HumanEval_81,tam_Taml,js,"/ உதாரணம்: / 0.0 E / > 0.0 D- / > 0.7 D / > 1.0 D+ / > 1.3 C- / > 1.7 C / > 2.0 C+ / > 2.3 B- / > 2.7 B / > 3.0 பி+ / > 3.3 A- / > 3.7 A / 4.0 A+ / GPA  கடிதம் மதிப்பெண் / பின்வரும் அட்டவணையைப் பயன்படுத்தி எழுத்து தரங்களின் வரிசையை வெளியிடக்கூடிய ஒரு செயல்பாடு: / அவள் சில மாணவர்கள் GPA கள் ஒரு வரிசை கொடுத்துள்ளது மற்றும் நீங்கள் எழுத வேண்டும் ./ ஒரே பிரச்சனை, அவள் மதிப்பீடு பயன்படுத்தப்படும் குறியீடு இழந்து உள்ளது. / மாணவர்களுக்கு. ஆசிரியர் தனது சொந்த அல்காரிதத்தை உருவாக்கி வருகிறார்./இது செமஸ்டரின் கடைசி வாரம் மற்றும் ஆசிரியர் மதிப்பெண்களை கொடுக்க வேண்டும்.// >>> grade_equation([4.0, 3, 1.7, 2, 3.5])
// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
function numerical_letter_grade(grades){
","function numerical_letter_grade(grades){
    return grades.map(gpa => {
        if (gpa === 4.0) return ""A+"";
        else if (gpa > 3.7) return ""A"";
        else if (gpa > 3.3) return ""A-"";
        else if (gpa > 3.0) return ""B+"";
        else if (gpa > 2.7) return ""B"";
        else if (gpa > 2.3) return ""B-"";
        else if (gpa > 2.0) return ""C+"";
        else if (gpa > 1.7) return ""C"";
        else if (gpa > 1.3) return ""C-"";
        else if (gpa > 1.0) return ""D+"";
        else if (gpa > 0.7) return ""D"";
        else if (gpa > 0.0) return ""D-"";
        else return ""E"";
    });
}","const assert = require('node:assert');


function test() {
  let candidate = numerical_letter_grade;
  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[""A+"", ""B"", ""C-"", ""C"", ""A-""]);
  assert.deepEqual(candidate([1.2]),[""D+""]);
  assert.deepEqual(candidate([0.5]),[""D-""]);
  assert.deepEqual(candidate([0.0]),[""E""]);
  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[""D"", ""D-"", ""C-"", ""B"", ""B+""]);
  assert.deepEqual(candidate([0.0, 0.7]),[""E"", ""D-""]);
}

test();"
HumanEval_82,tam_Taml,js,"/ உதாரணங்கள் / நீளம் ஒரு பிரதான எண் அல்லது தவறானது /ஒரு சரம் எடுத்து சரம்  என்றால் உண்மை என்று ஒரு செயல்பாடு எழுத// >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
function prime_length(string){
","function prime_length(string) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
    
    return isPrime(string.length);
}","const assert = require('node:assert');


function test() {
  let candidate = prime_length;
  assert.deepEqual(candidate(""Hello""),true);
  assert.deepEqual(candidate(""abcdcba""),true);
  assert.deepEqual(candidate(""kittens""),true);
  assert.deepEqual(candidate(""orange""),false);
  assert.deepEqual(candidate(""wow""),true);
  assert.deepEqual(candidate(""world""),true);
  assert.deepEqual(candidate(""MadaM""),true);
  assert.deepEqual(candidate(""Wow""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""HI""),true);
  assert.deepEqual(candidate(""go""),true);
  assert.deepEqual(candidate(""gogo""),false);
  assert.deepEqual(candidate(""aaaaaaaaaaaaaaa""),false);
  assert.deepEqual(candidate(""Madam""),true);
  assert.deepEqual(candidate(""M""),false);
  assert.deepEqual(candidate(""0""),false);
}

test();"
HumanEval_83,tam_Taml,js,"/ நேர்மறை முழு எண்கள் 1 உடன் தொடங்குகின்றன அல்லது முடிவடைகின்றன./ஒரு நேர்மறை முழு எண் n கொடுக்கப்பட்டால், n- இலக்க எண்களின் எண்ணிக்கையைத் திருப்பித் தரவும் function starts_one_ends(n){
","function starts_one_ends(n) {
    if (n === 1) return 1; // For n = 1, only number is 1 itself

    // Calculate the number of n-digit numbers that either start or end with 1
    // Total n-digit numbers: 9 * 10^(n-1) (ranging from 10^(n-1) to 10^n - 1)

    let totalCount = 9 * Math.pow(10, n - 1);

    // Numbers that both start and end with 1: 10^(n-2) (e.g., 101, 111, 121, ..., 191 if n=3)
    let bothStartAndEndWithOne = Math.pow(10, n - 2);

    // Numbers that start with 1: 10^(n-1)
    let startWithOne = Math.pow(10, n - 1);

    // Numbers that end with 1: 9 * 10^(n-1) / 10 = 10^(n-1) (because we're counting 1 - 1, 11, 21, ..., 91)
    let endWithOne = Math.pow(10, n - 1);

    // Use inclusion-exclusion principle: number starts with 1 + numbers end with 1 - numbers that both start and end with 1
    return startWithOne + endWithOne - bothStartAndEndWithOne;
}","const assert = require('node:assert');


function test() {
  let candidate = starts_one_ends;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(2),18);
  assert.deepEqual(candidate(3),180);
  assert.deepEqual(candidate(4),1800);
  assert.deepEqual(candidate(5),18000);
}

test();"
HumanEval_84,tam_Taml,js,"/ உதாரணம் /ஒரு நேர்மறை முழு எண் N கொடுக்கப்பட்டால், அதன் இலக்கங்களின் மொத்த தொகையை பைனரியில் திருப்பிக் கொடுங்கள்.// >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
function solve(N){
","function solve(N) {
    // Convert the number to a string and split into individual characters (digits)
    let digits = N.toString().split('');
    // Calculate the sum of all digits
    let sum = digits.reduce((acc, digit) => acc + Number(digit), 0);
    // Convert the sum to a binary string and return
    return sum.toString(2);
}","const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(1000),""1"");
  assert.deepEqual(candidate(150),""110"");
  assert.deepEqual(candidate(147),""1100"");
  assert.deepEqual(candidate(333),""1001"");
  assert.deepEqual(candidate(963),""10010"");
}

test();"
HumanEval_85,tam_Taml,js,"/ உதாரணங்கள்: /இடது அல்லாத முழு எண்களின் வரிசை கொடுக்கப்பட்டால் lst. எண்களின் எண்களைக் கூட்டவும்.// >>> add([4, 2, 6, 7])
// 2
function add(lst){
","function add(lst) {
    let sum = 0;
    for (let i = 1; i < lst.length; i += 2) {
        if (lst[i] % 2 === 0) {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate([4, 88]),88);
  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);
  assert.deepEqual(candidate([4, 0, 6, 7]),0);
  assert.deepEqual(candidate([4, 4, 6, 8]),12);
}

test();"
HumanEval_86,tam_Taml,js,"/ உதாரணமாக: / குறிப்பு: வாக்கியத்தில் உள்ள சொற்களின் வரிசையையும் இடைவெளிகளையும் நீங்கள் பராமரிக்க வேண்டும்./ ASCII மதிப்பின் அடிப்படையில் உயரும் வரிசை./ ஒரு புதிய வார்த்தையால் மாற்றப்படுகிறது, அதில் அனைத்து எழுத்துக்களும் ஒழுங்கமைக்கப்பட்டுள்ளன / வரிசைப்படுத்தப்பட்ட வரிசை, அனைத்து வார்த்தைகளும் (வெளியால் பிரிக்கப்பட்டவை) /ஒரு சரத்தை எடுத்து அதன் ஒழுங்குபடுத்தப்பட்ட பதிப்பைத் தரும் ஒரு செயல்பாட்டை எழுதுக.// >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
function anti_shuffle(s){
","function anti_shuffle(s) {
    return s.split(' ').map(word => {
        return word.split('').sort().join('');
    }).join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = anti_shuffle;
  assert.deepEqual(candidate(""Hi""),""Hi"");
  assert.deepEqual(candidate(""hello""),""ehllo"");
  assert.deepEqual(candidate(""number""),""bemnru"");
  assert.deepEqual(candidate(""abcd""),""abcd"");
  assert.deepEqual(candidate(""Hello World!!!""),""Hello !!!Wdlor"");
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hi. My name is Mister Robot. How are you?""),"".Hi My aemn is Meirst .Rboot How aer ?ouy"");
}

test();"
HumanEval_87,tam_Taml,js,"/ உதாரணங்கள்: / மேலும், வரிசையின் ஒருங்கிணைப்புகளை வரிசைப்படி வரிசைப்படுத்தவும்./ ஒருங்கிணைப்புகளை முதலில் வரிசைப்படி ஏறும் வரிசையில் வரிசைப்படுத்துங்கள்./ ஒவ்வொரு வரிசையும் ஒரு ஒருங்கிணைப்பு - (வரிசை, நெடுவரிசைகள்), 0 உடன் தொடங்குகிறது./ மற்றும் arrays வரிசைகளை திரும்ப, [(x1, y1), (x2, y2) ...] போன்ற என்று / lst, மற்றும் முழு எண் x கொடுக்கப்பட்டால், வரிசையில் முழு எண்கள் x ஐக் கண்டறியவும், / ஒவ்வொரு வரிசையிலும் வெவ்வேறு எண்ணிக்கையிலான நெடுவரிசைகள் இருக்கலாம்./ இது மேட்ரிக்ஸுக்கு ஒத்ததாகும், ஆனால் மேட்ரிக்ஸ்களைப் போலல்லாமல், /உங்களுக்கு ஒரு 2 பரிமாண தரவு கொடுக்கப்பட்டுள்ளது, ஒரு கூண்டு வரிசைகளாக, // >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
// >>> get_row([], 1)
// []
// >>> get_row([[], [1], [1, 2, 3]], 3)
// [[2, 2]]
function get_row(lst, x){
","function get_row(lst, x) {
    const result = [];

    for (let i = 0; i < lst.length; i++) {
        for (let j = 0; j < lst[i].length; j++) {
            if (lst[i][j] === x) {
                result.push([i, j]);
            }
        }
    }

    result.sort((a, b) => {
        if (a[0] === b[0]) {
            return b[1] - a[1]; // Sort by columns in descending order for the same row
        }
        return a[0] - b[0]; // Sort by rows in ascending order
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = get_row;
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);
  assert.deepEqual(candidate([], 1),[]);
  assert.deepEqual(candidate([[1]], 2),[]);
  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);
}

test();"
HumanEval_88,tam_Taml,js,"/ உதாரணங்கள்: / * கொடுக்கப்பட்ட வரிசையை மாற்ற வேண்டாம். / குறிப்பு: / அல்லது தொகை ((முதல் குறியீட்டு மதிப்பு, கடைசி குறியீட்டு மதிப்பு) சமமாக இருந்தால், அதை இறங்கு வரிசையில் வரிசைப்படுத்துங்கள்./ கொடுக்கப்பட்ட வரிசையை ஏறுவரிசையில் வரிசைப்படுத்துவீர்கள், இதன் தொகை ((முதல் குறியீட்டு மதிப்பு, கடைசி குறியீட்டு மதிப்பு) ஒற்றைப்படை என்றால்,/எதிர்மறை அல்லாத முழு எண்களின் வரிசை கொடுக்கப்பட்டால், வரிசைப்படுத்திய பின் கொடுக்கப்பட்ட வரிசையின் ஒரு cojs ஐத் திருப்பித் தரவும்,// >>> sort_array([])
// []
// >>> sort_array([5])
// [5]
// >>> sort_array([2, 4, 3, 0, 1, 5])
// [0, 1, 2, 3, 4, 5]
// >>> sort_array([2, 4, 3, 0, 1, 5, 6])
// [6, 5, 4, 3, 2, 1, 0]
function sort_array(array){
","function sort_array(array) {
    if (array.length === 0) return [];

    let firstValue = array[0];
    let lastValue = array[array.length - 1];
    let sum = firstValue + lastValue;
    
    let sortedArray = [...array]; // Clone the array to avoid modifying the original

    if (sum % 2 === 0) {
        // Even sum: sort in descending order
        sortedArray.sort((a, b) => b - a);
    } else {
        // Odd sum: sort in ascending order
        sortedArray.sort((a, b) => a - b);
    }

    return sortedArray;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5]),[5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);
  assert.deepEqual(candidate([2, 1]),[1, 2]);
  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);
  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);
}

test();"
HumanEval_89,tam_Taml,js,"/ உதாரணமாக: / இரண்டு இடங்களுக்கு இரண்டு மடங்கு கீழே நகர்த்தவும். / எழுத்துக்கள் / எழுத்துக்களை சுழற்றுவதன் மூலம் ஒரு குறியாக்கப்பட்ட சரத்தை அளிக்கிறது./ஒரு விவாதமாக ஒரு சரத்தை எடுக்கும் ஒரு செயல்பாட்டை உருவாக்குகிறது மற்றும் // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
function encrypt(s){
","function encrypt(s) {
    const shift = 2 * 2; // shift down by two multiplied by two places
    let encrypted = '';
    for (let i = 0; i < s.length; i++) {
        let charCode = s.charCodeAt(i);
        let newCharCode = ((charCode - 97 + shift) % 26) + 97; // wrap around within 'a' to 'z'
        encrypted += String.fromCharCode(newCharCode);
    }
    return encrypted;
}","const assert = require('node:assert');


function test() {
  let candidate = encrypt;
  assert.deepEqual(candidate(""hi""),""lm"");
  assert.deepEqual(candidate(""asdfghjkl""),""ewhjklnop"");
  assert.deepEqual(candidate(""gf""),""kj"");
  assert.deepEqual(candidate(""et""),""ix"");
  assert.deepEqual(candidate(""faewfawefaewg""),""jeiajeaijeiak"");
  assert.deepEqual(candidate(""hellomyfriend""),""lippsqcjvmirh"");
  assert.deepEqual(candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""),""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"");
  assert.deepEqual(candidate(""a""),""e"");
}

test();"
HumanEval_90,tam_Taml,js,"/ அத்தகைய உறுப்பு இல்லாவிட்டால் வரையறுக்கப்படாதது என திருப்பி விடுக./ ஒரு செயல்பாட்டை எழுதுங்கள் next_smallest() இது வரிசையின் 2 வது சிறிய உறுப்பைத் தருகிறது. /உங்களுக்கு முழு எண்களின் வரிசை கொடுக்கப்பட்டுள்ளது.// >>> next_smallest([1, 2, 3, 4, 5])
// 2
// >>> next_smallest([5, 1, 4, 3, 2])
// 2
// >>> next_smallest([])
// undefined
// >>> next_smallest([1, 1])
// undefined
function next_smallest(lst){
","function next_smallest(lst) {
    if (lst.length < 2) return undefined;
    
    let firstSmallest = Infinity;
    let secondSmallest = Infinity;
    
    for (let num of lst) {
        if (num < firstSmallest) {
            secondSmallest = firstSmallest;
            firstSmallest = num;
        } else if (num < secondSmallest && num != firstSmallest) {
            secondSmallest = num;
        }
    }
    
    return secondSmallest === Infinity ? undefined : secondSmallest;
}","const assert = require('node:assert');


function test() {
  let candidate = next_smallest;
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);
  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);
}

test();"
HumanEval_91,tam_Taml,js,"/ உதாரணமாக: / வாக்கியங்கள் '.', '?' அல்லது '!'. ல் வரையறுக்கப்படுகின்றன./ சலிப்பு. ஒரு சலிப்பு ""நான்"" என்ற வார்த்தையுடன் தொடங்கும் ஒரு வாக்கியம்./நீங்கள் வார்த்தைகள் ஒரு சரம் கொடுக்கப்படும், உங்கள் பணி எண் எண்ண வேண்டும்.// >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
function is_bored(S){
","function is_bored(S) {
    // Split the string into sentences using '.', '?', and '!' as delimiters
    const sentences = S.split(/[.!?]/);
    
    // Initialize boredom count
    let boredomCount = 0;
    
    // Iterate over each sentence
    sentences.forEach(sentence => {
        // Trim any whitespace from the beginning of the sentence and check if it starts with ""I""
        if (sentence.trim().startsWith(""I"")) {
            boredomCount++;
        }
    });
    
    return boredomCount;
}","const assert = require('node:assert');


function test() {
  let candidate = is_bored;
  assert.deepEqual(candidate(""Hello world""),0);
  assert.deepEqual(candidate(""Is the sky blue?""),0);
  assert.deepEqual(candidate(""I love It !""),1);
  assert.deepEqual(candidate(""bIt""),0);
  assert.deepEqual(candidate(""I feel good today. I will be productive. will kill It""),2);
  assert.deepEqual(candidate(""You and I are going for a walk""),0);
}

test();"
HumanEval_92,tam_Taml,js,"/ உதாரணங்கள் / மற்ற எல்லா நிகழ்வுகளிலும் false எனத் தருகிறது./ எண்களில் ஒன்று மற்ற இரண்டின் கூட்டுத்தொகைக்கு சமமாக இருந்தால், மற்றும் அனைத்து எண்களும் முழு எண்கள் என்றால் உண்மை எனத் திருப்பித் தருகிறது./3 எண்களை எடுக்கும் ஒரு செயல்பாட்டை உருவாக்கவும்.// >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
function any_int(x, y, z){
","function any_int(x, y, z) {
    // Check if all numbers are integers
    if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {
        // Check if any number is the sum of the other two
        return x === y + z || y === x + z || z === x + y;
    }
    // Return false if not all numbers are integers
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = any_int;
  assert.deepEqual(candidate(2, 3, 1),true);
  assert.deepEqual(candidate(2.5, 2, 3),false);
  assert.deepEqual(candidate(1.5, 5, 3.5),false);
  assert.deepEqual(candidate(2, 6, 2),false);
  assert.deepEqual(candidate(4, 2, 2),true);
  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);
  assert.deepEqual(candidate(-4, 6, 2),true);
  assert.deepEqual(candidate(2, 1, 1),true);
  assert.deepEqual(candidate(3, 4, 7),true);
  assert.deepEqual(candidate(3.0, 4, 7),false);
}

test();"
HumanEval_93,tam_Taml,js,"/ உதாரணங்கள்: / எழுத்துக்களை மட்டும் எடுத்துக் கொள்ளுங்கள்./ ஆங்கில எழுத்துக்களில் உள்ள எழுத்துக்கள்./ அந்தக் கடிதத்துடன் கூடிய செய்தி அதற்கு முன்னால் 2 இடங்களில் தோன்றும் /எல்லா எழுத்துக்களின் மூல எழுத்துக்களை மாற்றி, ல் உள்ள அனைத்து ஒலி எழுத்துக்களையும் மாற்றுகிறது./ஒரு செய்தியை எடுத்து, ஒரு  க்கு குறியீட்டு ஒரு செயல்பாடு எழுத// >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
function encode(message){
","function encode(message) {
    // Helper function to swap the case of a character
    function swapCase(char) {
        if (char === char.toLowerCase()) {
            return char.toUpperCase();
        } else {
            return char.toLowerCase();
        }
    }

    // Vowel mapping
    const vowelMap = {
        'a': 'c',
        'e': 'g',
        'i': 'k',
        'o': 'q',
        'u': 'w',
        'A': 'C',
        'E': 'G',
        'I': 'K',
        'O': 'Q',
        'U': 'W'
    };

    // Encode the message
    let encodedMessage = '';
    
    for (let char of message) {
        if (/[aeiouAEIOU]/.test(char)) {
            // Replace vowel with appropriate letter
            encodedMessage += vowelMap[char];
        } else {
            // Swap case for non-vowel letters
            encodedMessage += swapCase(char);
        }
    }
    
    return encodedMessage;
}","const assert = require('node:assert');


function test() {
  let candidate = encode;
  assert.deepEqual(candidate(""TEST""),""tgst"");
  assert.deepEqual(candidate(""Mudasir""),""mWDCSKR"");
  assert.deepEqual(candidate(""YES""),""ygs"");
  assert.deepEqual(candidate(""This is a message""),""tHKS KS C MGSSCGG"");
  assert.deepEqual(candidate(""I DoNt KnOw WhAt tO WrItE""),""k dQnT kNqW wHcT Tq wRkTg"");
}

test();"
HumanEval_94,tam_Taml,js,"/ உதாரணங்கள்: / மிகப்பெரிய பிரதான மதிப்பைக் கண்டுபிடித்து அதன் இலக்கங்களின் தொகையைத் திருப்பித் தர வேண்டும்./உங்களுக்கு முழு எண்களின் வரிசை கொடுக்கப்பட்டுள்ளது.// >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
// 10
// >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
// 25
// >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
// 13
// >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
// 11
// >>> skjkasdkd([0, 81, 12, 3, 1, 21])
// 3
// >>> skjkasdkd([0, 8, 1, 2, 1, 7])
// 7
function skjkasdkd(lst){
","function skjkasdkd(lst) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    function sumOfDigits(num) {
        return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }

    let largestPrime = -1;

    for (let num of lst) {
        if (isPrime(num) && num > largestPrime) {
            largestPrime = num;
        }
    }
    
    return largestPrime !== -1 ? sumOfDigits(largestPrime) : 0;
}","const assert = require('node:assert');


function test() {
  let candidate = skjkasdkd;
  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);
  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);
  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);
  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);
  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);
  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);
  assert.deepEqual(candidate([8191]),19);
  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);
  assert.deepEqual(candidate([127, 97, 8192]),10);
}

test();"
HumanEval_95,tam_Taml,js,"/ உதாரணங்கள்: / கொடுக்கப்பட்ட பொருள் காலியாக இருந்தால் செயல்பாடு false ஐத் திருப்பித் தர வேண்டும்./ case அல்லது அனைத்து விசைகளும் பெரிய எழுத்துக்களில் உள்ள சரங்கள், இல்லையெனில் false எனத் திருப்பித் தரப்படும்./ஒரு பொருளின் கொடுக்கப்பட்ட, அனைத்து விசைகள் குறைந்த  உள்ள சரங்களை இருந்தால் உண்மை திரும்ப// >>> check_dict_case({""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case({""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case({""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case({""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
function check_dict_case(dict){
","function check_dict_case(dict) {
    const keys = Object.keys(dict);

    if (keys.length === 0) return false;

    const allLowerCase = keys.every(key => typeof key === 'string' && key === key.toLowerCase());
    const allUpperCase = keys.every(key => typeof key === 'string' && key === key.toUpperCase());

    return allLowerCase || allUpperCase;
}","const assert = require('node:assert');


function test() {
  let candidate = check_dict_case;
  assert.deepEqual(candidate({""p"": ""pineapple"", ""b"": ""banana""}),true);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}),false);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}),false);
  assert.deepEqual(candidate({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}),false);
  assert.deepEqual(candidate({""STATE"": ""NC"", ""ZIP"": ""12345""}),true);
  assert.deepEqual(candidate({""fruit"": ""Orange"", ""taste"": ""Sweet""}),true);
  assert.deepEqual(candidate({}),false);
}

test();"
HumanEval_96,tam_Taml,js,"/ உதாரணமாக: / முழு எண்கள் பிரதான எண்கள் மற்றும் n க்கு குறைவாக இருக்கும்./ஒரு எதிர்மறை அல்லாத முழு எண்ணை எடுத்து முதல் n இன் வரிசையைத் திரும்பும் ஒரு செயல்பாட்டை செயல்படுத்தவும் // >>> count_up_to(5)
// [2, 3]
// >>> count_up_to(11)
// [2, 3, 5, 7]
// >>> count_up_to(0)
// []
// >>> count_up_to(20)
// [2, 3, 5, 7, 11, 13, 17, 19]
// >>> count_up_to(1)
// []
// >>> count_up_to(18)
// [2, 3, 5, 7, 11, 13, 17]
function count_up_to(n){
","function count_up_to(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }

    const primes = [];
    for (let i = 2; i < n; i++) {
        if (isPrime(i)) {
            primes.push(i);
        }
    }
    return primes;
}","const assert = require('node:assert');


function test() {
  let candidate = count_up_to;
  assert.deepEqual(candidate(5),[2, 3]);
  assert.deepEqual(candidate(6),[2, 3, 5]);
  assert.deepEqual(candidate(7),[2, 3, 5]);
  assert.deepEqual(candidate(10),[2, 3, 5, 7]);
  assert.deepEqual(candidate(0),[]);
  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);
  assert.deepEqual(candidate(1),[]);
  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

test();"
HumanEval_97,tam_Taml,js,"/ உதாரணங்கள்: / உள்ளீடு எப்போதும் செல்லுபடியாகும் என்று கருதுக. / அவர்களின் அலகு இலக்கங்களின் கூட்டுத்தொகை./இரண்டு முழு எண்களை எடுத்துக்கொண்டு வினைத்திறனை பூர்த்தி செய்து திரும்பும் // >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
function multiply(a, b){
","function multiply(a, b) {
    // Get the absolute value of each number
    a = Math.abs(a);
    b = Math.abs(b);

    // Extract the unit digit of each number
    let unitDigitA = a % 10;
    let unitDigitB = b % 10;

    // Return the product of the unit digits
    return unitDigitA * unitDigitB;
}","const assert = require('node:assert');


function test() {
  let candidate = multiply;
  assert.deepEqual(candidate(148, 412),16);
  assert.deepEqual(candidate(19, 28),72);
  assert.deepEqual(candidate(2020, 1851),0);
  assert.deepEqual(candidate(14, -15),20);
  assert.deepEqual(candidate(76, 67),42);
  assert.deepEqual(candidate(17, 27),49);
  assert.deepEqual(candidate(0, 1),0);
  assert.deepEqual(candidate(0, 0),0);
}

test();"
HumanEval_98,tam_Taml,js,"/ உதாரணமாக: /ஒரு சரம் s கொடுக்கப்பட்டால், பெரிய எழுத்துக்களில் உள்ள எழுத்துக்களின் எண்ணிக்கையை எண்ணுங்கள்.// >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
function count_upper(s){
","function count_upper(s) {
    const vowels = new Set(['A', 'E', 'I', 'O', 'U']);
    let count = 0;
    for (let i = 0; i < s.length; i += 2) {
        if (vowels.has(s[i])) {
            count++;
        }
    }
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = count_upper;
  assert.deepEqual(candidate(""aBCdEf""),1);
  assert.deepEqual(candidate(""abcdefg""),0);
  assert.deepEqual(candidate(""dBBE""),0);
  assert.deepEqual(candidate(""B""),0);
  assert.deepEqual(candidate(""U""),1);
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""EEEE""),2);
}

test();"
HumanEval_99,tam_Taml,js,"/ உதாரணங்கள் / இரண்டு முழு எண்களிலிருந்து, அதை பூஜ்ஜியத்திலிருந்து சுற்றவும்./ மற்றும் அதற்கு மிக அருகில் உள்ள முழு எண்ணைத் தருகிறது. எண் சம தூரத்தில் இருந்தால் /ஒரு எண்ணை குறிக்கும் ஒரு மதிப்பை (சரம்) எடுக்கும் ஒரு செயல்பாட்டை உருவாக்கவும் // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
function closest_integer(value){
","function closest_integer(value) {
    let num = parseFloat(value);
    if (num > 0) {
        return Math.floor(num + 0.5);
    } else {
        return Math.ceil(num - 0.5);
    }
}","const assert = require('node:assert');


function test() {
  let candidate = closest_integer;
  assert.deepEqual(candidate(""10""),10);
  assert.deepEqual(candidate(""14.5""),15);
  assert.deepEqual(candidate(""-15.5""),-16);
  assert.deepEqual(candidate(""15.3""),15);
  assert.deepEqual(candidate(""0""),0);
}

test();"
HumanEval_100,tam_Taml,js,"/ உதாரணங்கள்: / i என்பது நிலை (i+1) இல் உள்ள கற்களின் எண்ணிக்கையைக் குறிக்கிறது./ ஒரு வரிசையில் ஒவ்வொரு மட்டத்திலும் உள்ள கற்களின் எண்ணிக்கையைத் தருகிறது, அங்கு எலெக்ட்மெண்ட் இன்டெக்ஸ் / - n சமமாக இருந்தால் அடுத்த சம எண்./ - n என்பது ஒரு எண் என்றால் அடுத்த எண்./ அடுத்த நிலை கற்களின் எண்ணிக்கை: / முதல் நிலை n கற்களைக் கொண்டுள்ளது. /ஒரு நேர்மறை முழு எண் n கொடுக்கப்பட்டால், நீங்கள் n நிலை கற்களைக் கொண்ட ஒரு குவியலை உருவாக்க வேண்டும்.// >>> make_a_pile(3)
// [3, 5, 7]
function make_a_pile(n){
","function make_a_pile(n) {
    const pile = [];
    let currentStones = n;
    
    for (let i = 0; i < n; i++) {
        pile.push(currentStones);
        currentStones += (currentStones % 2 === 0) ? 2 : 2;
    }

    return pile;
}","const assert = require('node:assert');


function test() {
  let candidate = make_a_pile;
  assert.deepEqual(candidate(3),[3, 5, 7]);
  assert.deepEqual(candidate(4),[4, 6, 8, 10]);
  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);
  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);
  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);
}

test();"
HumanEval_101,tam_Taml,js,"/ உதாரணமாக: / சொற்களில் சரம் பிரித்து வார்த்தைகள் ஒரு வரிசை திரும்ப./நீங்கள் காற்புள்ளிகள் அல்லது இடைவெளிகள் மூலம் பிரிக்கப்பட்ட வார்த்தைகள் ஒரு சரம் கொடுக்கப்படும். உங்கள் பணி உள்ளது // >>> words_string(""Hi, my name is John"")
// [""Hi"", ""my"", ""name"", ""is"", ""John""]
// >>> words_string(""One, two, three, four, five, six"")
// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
function words_string(s){
","function words_string(s) {
    // Split the string by removing commas and spaces, filter out any empty strings
    return s.split(/[\s,]+/).filter(Boolean);
}","const assert = require('node:assert');


function test() {
  let candidate = words_string;
  assert.deepEqual(candidate(""Hi, my name is John""),[""Hi"", ""my"", ""name"", ""is"", ""John""]);
  assert.deepEqual(candidate(""One, two, three, four, five, six""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""Hi, my name""),[""Hi"", ""my"", ""name""]);
  assert.deepEqual(candidate(""One,, two, three, four, five, six,""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""ahmed     , gamal""),[""ahmed"", ""gamal""]);
}

test();"
HumanEval_102,tam_Taml,js,"/ உதாரணமாக: / அப்படி ஒரு எண் இல்லை என்றால், பின் செயல்பாடு -1 ஐ திரும்பப் பெற வேண்டும்./ மிகப்பெரிய முழு எண், இது [x, y] வரம்பில் உள்ளது./இந்தச் செயல்பாடு இரண்டு நேர்ம எண்களை x மற்றும் y எடுத்து ஐத் தருகிறது.// >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
function choose_num(x, y){
","function choose_num(x, y) {
    if (x > y) {
        return -1;
    }
    for (let i = y; i >= x; i--) {
        if (i % 2 === 0) {
            return i;
        }
    }
    return -1;
}","const assert = require('node:assert');


function test() {
  let candidate = choose_num;
  assert.deepEqual(candidate(12, 15),14);
  assert.deepEqual(candidate(13, 12),-1);
  assert.deepEqual(candidate(33, 12354),12354);
  assert.deepEqual(candidate(5234, 5233),-1);
  assert.deepEqual(candidate(6, 29),28);
  assert.deepEqual(candidate(27, 10),-1);
  assert.deepEqual(candidate(7, 7),-1);
  assert.deepEqual(candidate(546, 546),546);
}

test();"
HumanEval_103,tam_Taml,js,"/ உதாரணம்: / n என்பது m ஐ விட பெரியதாக இருந்தால், திரும்பவும் -1./ அருகிலுள்ள முழு எண்ணுக்குச் சுற்றி அதை பைனரி எண்ணாக மாற்றவும்./ n முதல் m வரை உள்ள முழு எண்களின் சராசரி (n மற்றும் m உட்பட)./உங்களுக்கு இரண்டு நேர்ம முழு எண்கள் n மற்றும் m கொடுக்கப்பட்டுள்ளன, உங்கள் பணி // >>> rounded_avg(1, 5)
// ""0b11""
// >>> rounded_avg(7, 5)
// -1
// >>> rounded_avg(10, 20)
// ""0b1111""
// >>> rounded_avg(20, 33)
// ""0b11010""
function rounded_avg(n, m){
","function rounded_avg(n, m) {
    if (n > m) {
        return -1;
    }
    
    let sum = 0;
    let count = 0;
    
    for (let i = n; i <= m; i++) {
        sum += i;
        count++;
    }
    
    let average = sum / count;
    let roundedAverage = Math.round(average);
    return ""0b"" + roundedAverage.toString(2);
}

// Example Usage
console.log(rounded_avg(1, 5));   // ""0b11""
console.log(rounded_avg(7, 5));   // -1
console.log(rounded_avg(10, 20)); // ""0b1111""
console.log(rounded_avg(20, 33)); // ""0b11010""","const assert = require('node:assert');


function test() {
  let candidate = rounded_avg;
  assert.deepEqual(candidate(1, 5),""0b11"");
  assert.deepEqual(candidate(7, 13),""0b1010"");
  assert.deepEqual(candidate(964, 977),""0b1111001010"");
  assert.deepEqual(candidate(996, 997),""0b1111100100"");
  assert.deepEqual(candidate(560, 851),""0b1011000010"");
  assert.deepEqual(candidate(185, 546),""0b101101110"");
  assert.deepEqual(candidate(362, 496),""0b110101101"");
  assert.deepEqual(candidate(350, 902),""0b1001110010"");
  assert.deepEqual(candidate(197, 233),""0b11010111"");
  assert.deepEqual(candidate(7, 5),-1);
  assert.deepEqual(candidate(5, 1),-1);
  assert.deepEqual(candidate(5, 5),""0b101"");
}

test();"
HumanEval_104,tam_Taml,js,"/ உதாரணமாக: / குறிப்பு: திரும்பிய வரிசை அதிகரிக்கும் வரிசையில் வரிசைப்படுத்தப்பட வேண்டும்./ எண் இல்லாத உறுப்புகள். /ஒரு நேர்மறை முழு எண்களின் வரிசை x. அனைத்து வரிசைப்படுத்தப்பட்ட வரிசையை திரும்ப // >>> unique_digits([15, 33, 1422, 1])
// [1, 15, 33]
// >>> unique_digits([152, 323, 1422, 10])
// []
function unique_digits(x){
","function unique_digits(x) {
    return x.filter(num => {
        return !num.toString().split('').some(digit => digit % 2 === 0);
    }).sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = unique_digits;
  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);
  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);
  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);
  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);
}

test();"
HumanEval_105,tam_Taml,js,"/ உதாரணமாக: / ""ஒன்று"", ""இரண்டு"", ""மூன்று"", ""நான்கு"", ""ஐந்து"", ""ஆறு"", ""ஏழு"", ""எட்டு"", ""ஒன்பது""./ இதன் விளைவாக வரிசைக்கு தலைகீழாக, பின்னர் ஒவ்வொரு இலக்கத்தையும் அதன் தொடர்புடைய பெயரால் ல் இருந்து மாற்றவும்./ஒரு முழு எண்களின் வரிசையைக் கொடுத்தால், 1 முதல் 9 வரை உள்ள முழு எண்களை வரிசைப்படுத்துங்கள்,// >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])
// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
// If the array is empty, return an empty array:
// >>> by_length([])
// []
// If the array has any strange number ignore it:
// >>> by_length([1, -1, 55])
// [""One""]
function by_length(arr){
","function by_length(arr) {
  const numberNames = [
    ""One"", ""Two"", ""Three"", ""Four"", ""Five"",
    ""Six"", ""Seven"", ""Eight"", ""Nine""
  ];

  return arr.filter(num => num >= 1 && num <= 9)
            .sort((a, b) => a - b)
            .reverse()
            .map(num => numberNames[num - 1]);
}","const assert = require('node:assert');


function test() {
  let candidate = by_length;
  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -1, 55]),[""One""]);
  assert.deepEqual(candidate([1, -1, 3, 2]),[""Three"", ""Two"", ""One""]);
  assert.deepEqual(candidate([9, 4, 8]),[""Nine"", ""Eight"", ""Four""]);
}

test();"
HumanEval_106,tam_Taml,js,"/ உதாரணம்: / i இன் காரணி 1 முதல் i வரை உள்ள எண்களின் பெருக்கமாகும் (1 * 2 * . . . * i)./ i 1 முதல் தொடங்குகிறது./ அல்லது 1 முதல் i வரையிலான எண்களின் கூட்டுத்தொகை./ மற்றும் அளவு n இன் ஒரு வரிசையை அளிக்கிறது, அதாவது குறியீட்டு i இல் உள்ள உறுப்பு மதிப்பு i இன் காரணி ஆகும், i கூட இருந்தால் /n ஐ ஒரு அளவுருவாகக் கொண்ட f செயல்பாட்டை செயல்படுத்தவும், // >>> f(5)
// [1, 2, 6, 24, 15]
function f(n){
","function f(n) {
    function factorial(num) {
        let result = 1;
        for (let i = 2; i <= num; i++) {
            result *= i;
        }
        return result;
    }

    function sumUpTo(num) {
        return (num * (num + 1)) / 2; // Sum of first num natural numbers
    }

    let result = [];
    for (let i = 1; i <= n; i++) {
        if (i % 2 === 0) {
            result.push(factorial(i));
        } else {
            result.push(sumUpTo(i));
        }
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = f;
  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);
  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);
  assert.deepEqual(candidate(1),[1]);
  assert.deepEqual(candidate(3),[1, 2, 6]);
}

test();"
HumanEval_107,tam_Taml,js,"/ உதாரணம் 1: / முழு எண் பாலிண்ட்ரோம்ஸ் வரம்பிற்குள் வருகின்றன ((1, n), உட்பட./ஒரு நேர்மறை முழு எண் n கொடுக்கப்பட்டால், ஒரு வரிசையை திருப்பிக் கொடுங்கள், இது சம மற்றும் ஒற்றைப்படை எண்களின் எண்ணிக்கையைக் கொண்டுள்ளது.// >>> even_odd_palindrome(3)
// [1, 2]
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// [4, 6]
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned array has the number of even and odd integer palindromes respectively.
function even_odd_palindrome(n){
","function even_odd_palindrome(n) {
    function isPalindrome(num) {
        let str = num.toString();
        return str === str.split('').reverse().join('');
    }

    let evenCount = 0;
    let oddCount = 0;

    for (let i = 1; i <= n; i++) {
        if (isPalindrome(i)) {
            if (i % 2 === 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return [evenCount, oddCount];
}","const assert = require('node:assert');


function test() {
  let candidate = even_odd_palindrome;
  assert.deepEqual(candidate(123),[8, 13]);
  assert.deepEqual(candidate(12),[4, 6]);
  assert.deepEqual(candidate(3),[1, 2]);
  assert.deepEqual(candidate(63),[6, 8]);
  assert.deepEqual(candidate(25),[5, 6]);
  assert.deepEqual(candidate(19),[4, 6]);
  assert.deepEqual(candidate(9),[4, 5]);
  assert.deepEqual(candidate(1),[0, 1]);
}

test();"
HumanEval_108,tam_Taml,js,"/ எ. கா. -123 ல் -1, 2, மற்றும் 3 இலக்கங்கள் உள்ளன./ ஒரு எண் எதிர்மறையானதாக இருந்தால், அதன் முதல் கையொப்பமிடப்பட்ட இலக்கமும் எதிர்மறையாக இருக்கும்: / எண்களின் எண்ணிக்கை, இதில் இலக்கங்களின் தொகை > 0 ஆகும்./எழுத ஒரு செயல்பாடு count_nums இது ஒரு வரிசை முழு எண்களை எடுத்து திருப்பித் தருகிறது // >>> count_nums([])
// 0
// >>> count_nums([-1, 11, -11])
// 1
// >>> count_nums([1, 1, 2])
// 3
function count_nums(arr){
","function count_nums(arr) {
    return arr.reduce((count, num) => {
        let str = num.toString();
        let sum = 0;
        for (let i = 0; i < str.length; i++) {
            if (i === 0 && str[i] === '-') {
                continue;
            }
            sum += parseInt(str[i]);
        }
        if (num < 0) {
            sum += 2 * parseInt(str[1]); // Adjust for the negative signed digit
        }
        return sum > 0 ? count + 1 : count;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = count_nums;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([-1, -2, 0]),0);
  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);
  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);
  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);
  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);
  assert.deepEqual(candidate([0, 1]),1);
  assert.deepEqual(candidate([1]),1);
}

test();"
HumanEval_109,tam_Taml,js,"/ உதாரணமாக: / குறிப்பு: கொடுக்கப்பட்ட வரிசை தனித்துவமான கூறுகளைக் கொண்டிருப்பதை உறுதி செய்கிறது./ கொடுக்கப்பட்ட வரிசை காலியாக இருந்தால் true என திருப்பி விடுக./ பின்னர் true திரும்பவும் else return false. / மேலே உள்ள செயல்பாட்டைச் செய்வதன் மூலம் வரிசைப்படுத்தப்பட்ட வரிசையைப் பெற முடிந்தால் / வரிசையில் ஆரம்ப நிலை அதாவது 0-வது குறியீட்டு./ சரியான திசையில் நிலை. வரிசையின் கடைசி உறுப்பு க்கு நகர்த்தப்படும்./ ஒரு வலதுபுறம் நகரும் செயல்பாடு என்பது வரிசையின் அனைத்து கூறுகளையும் ஒரு முறை நகர்த்துவதைக் குறிக்கிறது ./ நீங்கள் வலது திருப்பம் செயல்பாடு எந்த எண்ணிக்கை முறை செய்ய அனுமதிக்கப்படுகின்றன. / கொடுக்கப்பட்ட வரிசையில் பின்வரும் செயல்பாடுஃ / ஒரு வரிசையை குறைந்து போகாத வரிசையில் வரிசைப்படுத்த முடியும்./ வரிசையில் எண்கள் தோராயமாக வரிசைப்படுத்தப்படும். உங்கள் பணி  என்பதை தீர்மானிக்க வேண்டும்./நமக்கு ஒரு வரிசை 'arr' உள்ளது N முழு எண்கள் arr[1], arr[2], ..., arr[N].// >>> move_one_ball([3, 4, 5, 1, 2])
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given array.
// >>> move_one_ball([3, 5, 4, 1, 2])
// false
// Explanation:It is not possible to get non-decreasing order for the given
// array by performing any number of right shift operations.
function move_one_ball(arr){
","function move_one_ball(arr) {
    // If the array is empty, it's trivially sorted
    if (arr.length === 0) return true;

    // Count the number of positions where the next element is smaller than the current one
    let dropCount = 0;
    let n = arr.length;

    for (let i = 0; i < n; i++) {
        if (arr[i] > arr[(i + 1) % n]) {
            dropCount++;
        }
    }

    // If the drop count is more than 1, it means more than one drop is there
    // and thus we cannot sort it with right shifts
    return dropCount <= 1;
}","const assert = require('node:assert');


function test() {
  let candidate = move_one_ball;
  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);
  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);
  assert.deepEqual(candidate([4, 3, 1, 2]),false);
  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);
  assert.deepEqual(candidate([]),true);
}

test();"
HumanEval_110,tam_Taml,js,"/ உதாரணமாக: / இல்லையெனில், ""இல்லை"" என்று திருப்பி அனுப்புங்கள்./ lst1 அனைத்து உறுப்புகளும் சமமாக இருக்க, ""YES"" திரும்ப./ LST1 மற்றும் LST2 இடையே கூறுகளை பரிமாறிக்கொள்ள முடியும் என்றால் / LST1 மற்றும் LST2 இடையே பரிமாறிக்கொள்ளப்பட்ட கூறுகளின் எண்ணிக்கையில் வரம்பு இல்லை./ இவற்றுக்கு இடையில் lst1 என்பது ஒரு எண் வரிசையாகும்./ மற்றும் உறுப்புகளை பரிமாறிக்கொள்ள முடியுமா என்பதை தீர்மானிக்கிறது ./இந்த சிக்கலில், நீங்கள் இரண்டு வரிசை எண்களை எடுக்கும் ஒரு செயல்பாட்டை செயல்படுத்த வேண்டும், // >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
// ""YES""
// >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
// ""NO""
// It is assumed that the input arrays will be non-empty.
function exchange(lst1, lst2){
","function exchange(lst1, lst2) {
    // Check if lst1 already consists of only even numbers
    let allEvenLst1 = lst1.every(num => num % 2 === 0);
    if (allEvenLst1) return ""YES"";
    
    // Check if there's at least one even number in lst2
    let hasEvenInLst2 = lst2.some(num => num % 2 === 0);
    
    // If there is at least one even number in lst2, it's possible to perform an exchange
    // to make all elements in lst1 even
    if (hasEvenInLst2) return ""YES"";
    
    // If no conditions above are met, it's not possible to make lst1 all even
    return ""NO"";
}","const assert = require('node:assert');


function test() {
  let candidate = exchange;
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),""YES"");
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),""NO"");
  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),""NO"");
  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),""NO"");
  assert.deepEqual(candidate([100, 200], [200, 200]),""YES"");
}

test();"
HumanEval_111,tam_Taml,js,"/ உதாரணம்: / பல எழுத்துக்கள் ஒரே நிகழ்வைக் கொண்டிருந்தால், அவை அனைத்தையும் திருப்பி அனுப்புங்கள்./ அதிக எண்ணிக்கையிலான எழுத்துக்களில் மீண்டும் மீண்டும் வரும் எழுத்துக்களின் எண்ணிக்கை./ஒரு இடைவெளி பிரிக்கப்பட்ட சிறிய எழுத்துக்களைக் குறிக்கும் ஒரு சரம் கொடுக்கப்பட்டால், ஒரு பொருளைத் திருப்பித் தரவும் // >>> histogram(""a b c"")
// {""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// {""b"": 4}
// >>> histogram("""")
// {}
function histogram(test){
","function histogram(test) {
  if (!test) return {};
  
  const letters = test.split(' ');
  const letterCount = {};
  
  for (let letter of letters) {
    if (letterCount[letter]) {
      letterCount[letter]++;
    } else {
      letterCount[letter] = 1;
    }
  }
  
  let maxCount = 0;
  for (let count of Object.values(letterCount)) {
    if (count > maxCount) {
      maxCount = count;
    }
  }
  
  const result = {};
  for (let [letter, count] of Object.entries(letterCount)) {
    if (count === maxCount) {
      result[letter] = count;
    }
  }
  
  return result;
}","const assert = require('node:assert');


function test() {
  let candidate = histogram;
  assert.deepEqual(candidate(""a b b a""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c a b""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c d g""),{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""b b b b a""),{""b"": 4});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""""),{});
  assert.deepEqual(candidate(""a""),{""a"": 1});
}

test();"
HumanEval_112,tam_Taml,js,"/ உதாரணம் / நீங்கள் ஒரு வரிசையை திரும்ப வேண்டும். அதில் முடிவு சரம் மற்றும் சரிபார்ப்புக்கு உண்மை/தவறு உள்ளது./ ஒரு சரம் முன்னோக்கி அதே பின்னோக்கி படிக்கும் என்றால் palindrome அழைக்கப்படுகிறது. / பின்பு முடிவு சரம் பாலிண்ட்ரோம் என்பதை சரிபார்க்கவும்./ நாம் இரண்டு சரங்களை கொடுக்கப்பட்டுள்ளோம் s மற்றும் c, நீங்கள் s இல் உள்ள அனைத்து எழுத்துக்களையும் நீக்க வேண்டும் c இல் உள்ள எந்த எழுத்துக்களுக்கும் சமம் / பணி // >>> reverse_delete(""abcde"", ""ae"")
// [""bcd"", false]
// >>> reverse_delete(""abcdef"", ""b"")
// [""acdef"", false]
// >>> reverse_delete(""abcdedcba"", ""ab"")
// [""cdedc"", true]
function reverse_delete(s, c){
","function reverse_delete(s, c) {
    let result = '';
    // Create a set of characters to be deleted
    const deleteChars = new Set(c);
    
    // Construct the result string excluding the characters in c
    for (let char of s) {
        if (!deleteChars.has(char)) {
            result += char;
        }
    }
    
    // Check if the result string is a palindrome
    const isPalindrome = result === result.split('').reverse().join('');
    
    return [result, isPalindrome];
}","const assert = require('node:assert');


function test() {
  let candidate = reverse_delete;
  assert.deepEqual(candidate(""abcde"", ""ae""),[""bcd"", false]);
  assert.deepEqual(candidate(""abcdef"", ""b""),[""acdef"", false]);
  assert.deepEqual(candidate(""abcdedcba"", ""ab""),[""cdedc"", true]);
  assert.deepEqual(candidate(""dwik"", ""w""),[""dik"", false]);
  assert.deepEqual(candidate(""a"", ""a""),["""", true]);
  assert.deepEqual(candidate(""abcdedcba"", """"),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""abcdedcba"", ""v""),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""vabba"", ""v""),[""abba"", true]);
  assert.deepEqual(candidate(""mamma"", ""mia""),["""", true]);
}

test();"
HumanEval_113,tam_Taml,js,"/ உள்ளீடு i'th சரம் உள்ள ஒற்றை இலக்கங்கள். / உள்ளீட்டு சரம் i. "" அங்கு அனைத்து i கள் எண் மூலம் மாற்றப்பட வேண்டும் / வெளியீட்டின் ஒவ்வொரு உறுப்பு i என்பது ""இடத்தில் உள்ள ஒற்றைப்படை உறுப்புகளின் எண்ணிக்கையாக இருக்க வேண்டும்./ஒரு வரிசை வரிசை கொடுக்கப்பட்டால், ஒவ்வொரு வரிசையும் இலக்கங்களை மட்டுமே கொண்டிருக்கும், ஒரு வரிசையைத் திருப்பித் தரவும்.// >>> odd_count([""1234567""])
// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
// >>> odd_count([""3"", ""11111111""])
// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
function odd_count(lst){
","function odd_count(lst) {
    return lst.map(str => {
        const oddCount = Array.from(str).filter(ch => parseInt(ch) % 2 !== 0).length;
        let sentence = ""the number of odd elements in the string i of the input."";
        return sentence.replace(/i/g, oddCount.toString());
    });
}","const assert = require('node:assert');


function test() {
  let candidate = odd_count;
  assert.deepEqual(candidate([""1234567""]),[""the number of odd elements 4n the str4ng 4 of the 4nput.""]);
  assert.deepEqual(candidate([""3"", ""11111111""]),[""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]);
  assert.deepEqual(candidate([""271"", ""137"", ""314""]),[""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""]);
}

test();"
HumanEval_114,tam_Taml,js,"/ உதாரணம் / எண்களின். /ஒரு முழு எண்கள் வரிசை கொடுக்கப்பட்டால், எந்தவொரு காலியாக இல்லாத துணை வரிசையின் குறைந்தபட்ச தொகையைக் கண்டறியவும்.// >>> minSubArraySum([2, 3, 4, 1, 2, 4])
// 1
// >>> minSubArraySum([-1, -2, -3])
// -6
function minSubArraySum(nums){
","function minSubArraySum(nums) {
    let minSum = nums[0];
    let currentSum = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        if (currentSum > 0) {
            currentSum = nums[i];
        } else {
            currentSum += nums[i];
        }
        minSum = Math.min(minSum, currentSum);
    }
    
    return minSum;
}","const assert = require('node:assert');


function test() {
  let candidate = minSubArraySum;
  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);
  assert.deepEqual(candidate([-1, -2, -3]),-6);
  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);
  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);
  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);
  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);
  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);
  assert.deepEqual(candidate([-10]),-10);
  assert.deepEqual(candidate([7]),7);
  assert.deepEqual(candidate([1, -1]),-1);
}

test();"
HumanEval_115,tam_Taml,js,"/ உதாரணம் 1: / நீங்கள் குடைகள் கீழே வேண்டும் முறை எண்ணிக்கை வெளியீடு. / உங்கள் பணி கிணறுகள் காலியாக குடைகள் பயன்படுத்த உள்ளது. / மற்றும் அனைத்து குடங்கள் அதே திறன் வேண்டும். / ஒவ்வொரு கிணற்றிலும் தண்ணீரைப் பிரித்தெடுக்க பயன்படுத்தக்கூடிய ஒரு குடம் உள்ளது, / மற்றும் ஒவ்வொரு 1 வரிசையில் ஒரு ஒற்றை நீர் அலகு குறிக்கிறது. ஒவ்வொரு வரிசையும் ஒரு கிணற்றை குறிக்கிறது.// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
// 6
// Example 2:
// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
// 5
// Example 3:
// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
function max_fill(grid, capacity){
","function max_fill(grid, capacity) {
    let totalWater = 0;
    
    for (let row of grid) {
        for (let cell of row) {
            totalWater += cell;
        }
    }
    
    return Math.ceil(totalWater / capacity);
}","const assert = require('node:assert');


function test() {
  let candidate = max_fill;
  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);
  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);
  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);
}

test();"
HumanEval_116,tam_Taml,js,"/ இது பின்வருமாறு செயல்படுத்தப்பட வேண்டும்: / ஒத்த எண்ணிக்கையிலான ஒற்றைகளுக்கு, தசம மதிப்பின் அடிப்படையில் வரிசைப்படுத்து./ அவற்றின் பைனரி பிரதிநிதித்துவத்தில் ஏறுவரிசையில் உள்ள எண்களின் எண்ணிக்கை./இந்த கட்டாவில், நீங்கள் எதிர்மறை அல்லாத முழு எண்களின் வரிசையை வரிசைப்படுத்த வேண்டும்// >>> sort_array([1, 5, 2, 3, 4])
// [1, 2, 3, 4, 5]
// >>> sort_array([-2, -3, -4, -5, -6])
// [-6, -5, -4, -3, -2]
// >>> sort_array([1, 0, 2, 3, 4])
// [0, 1, 2, 3, 4]
function sort_array(arr){
","function sort_array(arr) {
    return arr.slice().sort((a, b) => {
        const countOnes = num => num.toString(2).split('0').join('').length;
        const onesA = countOnes(a);
        const onesB = countOnes(b);
        if (onesA === onesB) {
            return a - b;
        }
        return onesA - onesB;
    });
}","const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);
  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);
  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
}

test();"
HumanEval_117,tam_Taml,js,"/ உதாரணங்கள்: / குறிப்பு: உள்ளீட்டு சரம் எழுத்துக்கள் மற்றும் இடைவெளிகள் மட்டுமே கொண்டிருப்பதாக நீங்கள் கருதலாம்./ string s காலியாக இருந்தால், function ஒரு காலியான array ஐ திரும்பப் பெற வேண்டும்./ n துணைக்குறிகள், இந்த வார்த்தைகள் வரிசையில் தோன்றும் வரிசையில் s./ ஒரு செயல்பாடு இது க்கு சரியாக உள்ள அனைத்து சொற்களின் வரிசையை க்குத் திரும்புகிறது/ஒரு சரம் s மற்றும் ஒரு இயற்கை எண் n கொடுக்கப்பட்டால், நீங்கள் செயல்படுத்த பணிபுரிந்தீர்கள் // >>> select_words(""Mary had a little lamb"", 4)
// [""little""]
// >>> select_words(""Mary had a little lamb"", 3)
// [""Mary"", ""lamb""]
// >>> select_words(""simple white space"", 2)
// []
// >>> select_words(""Hello world"", 4)
// [""world""]
// >>> select_words(""Uncle sam"", 3)
// [""Uncle""]
function select_words(s, n){
","function select_words(s, n) {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
    const words = s.split(' ');
    const result = [];

    for (let word of words) {
        let consonantCount = 0;
        
        for (let char of word) {
            if (!vowels.has(char)) {
                consonantCount += 1;
            }
        }

        if (consonantCount === n) {
            result.push(word);
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = select_words;
  assert.deepEqual(candidate(""Mary had a little lamb"", 4),[""little""]);
  assert.deepEqual(candidate(""Mary had a little lamb"", 3),[""Mary"", ""lamb""]);
  assert.deepEqual(candidate(""simple white space"", 2),[]);
  assert.deepEqual(candidate(""Hello world"", 4),[""world""]);
  assert.deepEqual(candidate(""Uncle sam"", 3),[""Uncle""]);
  assert.deepEqual(candidate("""", 4),[]);
  assert.deepEqual(candidate(""a b c d e f"", 1),[""b"", ""c"", ""d"", ""f""]);
}

test();"
HumanEval_118,tam_Taml,js,"/ உதாரணம்: / கொடுக்கப்பட்ட சரம் ஆங்கில எழுத்துக்களை மட்டுமே கொண்டிருக்கிறது என்று நீங்கள் கருதலாம்./ மேற்கண்ட நிபந்தனையை பூர்த்தி செய்த எந்தவொரு தனிச்சொல்லையும் கண்டறியவும். / ஆரம்பத்தில் மற்றும் முடிவில் உள்ள எழுத்துக்கள் கணக்கிடப்படவில்லை. நீங்கள் இல்லை என்றால் காலியாக சரம் திரும்ப / இரண்டு சரங்கள் வார்த்தையின் வலது பக்கத்தில் இருந்து (பெரிய எழுத்துக்களுக்கு முக்கியத்துவம்)./நீங்கள் ஒரு வார்த்தை கொடுக்கப்பட்ட. உங்கள் பணி இடையே நிற்கும் மிக நெருக்கமான எழுத்துரு கண்டுபிடிக்க வேண்டும்.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
function get_closest_vowel(word){
","function get_closest_vowel(word) {
    const vowels = ""aeiouAEIOU"";

    for (let i = word.length - 2; i > 0; i--) {
        if (vowels.includes(word[i]) && 
            !vowels.includes(word[i - 1]) && 
            !vowels.includes(word[i + 1])) {
            return word[i];
        }
    }

    return """";
}","const assert = require('node:assert');


function test() {
  let candidate = get_closest_vowel;
  assert.deepEqual(candidate(""yogurt""),""u"");
  assert.deepEqual(candidate(""full""),""u"");
  assert.deepEqual(candidate(""easy""),"""");
  assert.deepEqual(candidate(""eAsy""),"""");
  assert.deepEqual(candidate(""ali""),"""");
  assert.deepEqual(candidate(""bad""),""a"");
  assert.deepEqual(candidate(""most""),""o"");
  assert.deepEqual(candidate(""ab""),"""");
  assert.deepEqual(candidate(""ba""),"""");
  assert.deepEqual(candidate(""quick""),"""");
  assert.deepEqual(candidate(""anime""),""i"");
  assert.deepEqual(candidate(""Asia""),"""");
  assert.deepEqual(candidate(""Above""),""o"");
}

test();"
HumanEval_119,tam_Taml,js,"/ உதாரணங்கள்: / ஒரு நல்ல சரம் உருவாக்க ஒரு வழி இருந்தால் 'ஆம்' என்று திருப்பி, இல்லையெனில் 'இல்லை' என்று திருப்பி./ ""()) "" இல்லை./ சமநிலையில் உள்ளன. உதாரணமாக: சரம் '(()))) நல்லது, அதே நேரத்தில் சரம் / ஒரு சரம் S, S ல் உள்ள அனைத்து அடைப்புக்குறிகளும் இருந்தால் மட்டுமே, அது நல்லதாக கருதப்படுகிறது./ சில வரிசை, இதன் விளைவாக சரம் நன்றாக இருக்கும் என்று./ உங்கள் வேலை இரண்டு சரங்களை இணைக்க முடியுமா என்று சரிபார்க்க வேண்டும் / அடைப்புக்குறி ' ((' அல்லது நெருக்கமான அடைப்புக்குறி ') ' மட்டுமே./நீங்கள் இரண்டு சரங்களை ஒரு வரிசை கொடுக்கப்பட்ட, இரு சரங்கள் திறந்த கொண்டுள்ளன // >>> match_parens([""()("", "")""])
// ""Yes""
// >>> match_parens(["")"", "")""])
// ""No""
function match_parens(lst){
","function match_parens(lst) {
    function isBalanced(str) {
        let balance = 0;
        for (let char of str) {
            if (char === '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) return false;
        }
        return balance === 0;
    }

    const [s1, s2] = lst;
    if (isBalanced(s1 + s2) || isBalanced(s2 + s1)) {
        return 'Yes';
    }
    return 'No';
}","const assert = require('node:assert');


function test() {
  let candidate = match_parens;
  assert.deepEqual(candidate([""()("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", "")""]),""No"");
  assert.deepEqual(candidate([""(()(())"", ""())())""]),""No"");
  assert.deepEqual(candidate(["")())"", ""(()()(""]),""Yes"");
  assert.deepEqual(candidate([""(())))"", ""(()())((""]),""Yes"");
  assert.deepEqual(candidate([""()"", ""())""]),""No"");
  assert.deepEqual(candidate([""(()("", ""()))()""]),""Yes"");
  assert.deepEqual(candidate([""(((("", ""((())""]),""No"");
  assert.deepEqual(candidate(["")(()"", ""(()(""]),""No"");
  assert.deepEqual(candidate(["")("", "")(""]),""No"");
  assert.deepEqual(candidate([""("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", ""(""]),""Yes"");
}

test();"
HumanEval_120,tam_Taml,js,"/ உதாரணம் 1: / நீளம் k அதிகபட்சமாக k எண்களைக் கொண்டது arr. /ஒரு வரிசை arr முழு எண்கள் மற்றும் ஒரு நேர்மறை முழு எண் k கொடுக்கப்பட்டால், ஒரு வரிசை வரிசை திரும்ப // >>> maximum([-3, -4, 5], 3)
// [-4, -3, 5]
// Example 2:
// >>> maximum([4, -4, 4], 2)
// [4, 4]
// Example 3:
// >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)
// [2]
// Note:
// 1. The length of the array will be in the range of [1, 1000].
// 2. The elements in the array will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
function maximum(arr, k){
","function maximum(arr, k) {
    return arr.sort((a, b) => b - a).slice(0, k).sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = maximum;
  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);
  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);
  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);
  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);
  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);
  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);
  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);
  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);
  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);
  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);
  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);
}

test();"
HumanEval_121,tam_Taml,js,"/ உதாரணங்கள் /இல்லாத முழு எண்களின் வரிசை கொடுக்கப்பட்டால், சம நிலையில் உள்ள அனைத்து ஒற்றைப்படை உறுப்புகளின் கூட்டுத்தொகையைத் திருப்பித் தரவும்.// >>> solution([5, 8, 7, 1])
// 12
// >>> solution([3, 3, 3, 3, 3])
// 9
// >>> solution([30, 13, 24, 321])
// 0
function solution(lst){
","function solution(lst) {
    let sum = 0;
    for (let i = 0; i < lst.length; i += 2) {
        if (lst[i] % 2 !== 0) {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = solution;
  assert.deepEqual(candidate([5, 8, 7, 1]),12);
  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);
  assert.deepEqual(candidate([30, 13, 24, 321]),0);
  assert.deepEqual(candidate([5, 9]),5);
  assert.deepEqual(candidate([2, 4, 8]),0);
  assert.deepEqual(candidate([30, 13, 23, 32]),23);
  assert.deepEqual(candidate([3, 13, 2, 9]),3);
}

test();"
HumanEval_122,tam_Taml,js,"/ உதாரணம்: / arr இன் முதல் k உறுப்புகளில் இருந்து அதிகபட்சம் இரண்டு இலக்கங்களைக் கொண்ட உறுப்புகளின் தொகை./இல்லாத வெற்று வரிசை முழு எண்கள் arr மற்றும் ஒரு முழு எண் k கொடுக்கப்பட்டால், திரும்ப // >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
function add_elements(arr, k){
","function add_elements(arr, k) {
    let sum = 0;
    for (let i = 0; i < k; i++) {
        if (Math.abs(arr[i]) < 100) {
            sum += arr[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = add_elements;
  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);
  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);
  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);
  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);
  assert.deepEqual(candidate([1], 1),1);
}

test();"
HumanEval_123,tam_Taml,js,"/ get_odd_collatz(5) [1, 5] # 5 க்கான collatz வரிசை [5, 16, 8, 4, 2, 1], எனவே ஒற்றை எண்கள் 1, மற்றும் 5 மட்டுமே./ உதாரணமாக: / 2. திரும்பிய வரிசை அதிகரிக்கும் வரிசையில் வரிசைப்படுத்தப்பட்டது./ 1. Collatz(1) என்பது [1]. / குறிப்பு: / term plus 1. n இன் மதிப்பு எதுவாக இருந்தாலும், வரிசை எப்போதும் 1 ஐ அடைகிறது./ முந்தைய காலத்திற்கு. முந்தைய காலமானது ஒற்றைப்படை என்றால், அடுத்த காலமானது முந்தைய காலத்தின் 3 மடங்கு ஆகும்./ முந்தைய காலத்தின் பின்வருமாறு: முந்தைய காலமானது சமமாக இருந்தால், அடுத்த காலமானது ன் பாதி ஆகும்./ பின்வருமாறு: எந்த நேர்ம முழு எண் n உடன் தொடங்குங்கள். பின்னர் ஒவ்வொரு காலமும்  இலிருந்து பெறப்படுகிறது./ கோலாட்ஸ் அனுமானம் என்பது கணிதத்தில் ஒரு வரையறுக்கப்பட்ட வரிசை தொடர்பான ஒரு அனுமானம் ஆகும் ./ஒரு நேர்மறை முழு எண் n கொடுக்கப்பட்டால், ஒரு வரிசைப்படுத்தப்பட்ட வரிசையை திரும்பவும், இது கோலாட்ஸ் வரிசையில் ஒற்றைப்படை எண்களைக் கொண்டுள்ளது.// >>> get_odd_collatz(5)
// [1, 5]
function get_odd_collatz(n){
","function get_odd_collatz(n) {
    let collatzSequence = [];
    while (n !== 1) {
        if (n % 2 !== 0) {
            collatzSequence.push(n);
        }
        n = n % 2 === 0 ? n / 2 : 3 * n + 1;
    }
    collatzSequence.push(1); // Include 1 as it's part of the sequence and is odd
    return collatzSequence.sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = get_odd_collatz;
  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(5),[1, 5]);
  assert.deepEqual(candidate(12),[1, 3, 5]);
  assert.deepEqual(candidate(1),[1]);
}

test();"
HumanEval_124,tam_Taml,js,"/ 4. தேதி வடிவில் இருக்க வேண்டும்: mm-dd-yyyy / 3. மாதங்கள் 1 க்கு குறைவாகவோ அல்லது 12 க்கு மேல் இருக்கக்கூடாது./ 2. மாதங்களுக்கு 1,3,5,7,8,10,12 க்கு 1 அல்லது 31 நாட்களுக்கு மேல் இல்லை மற்றும் மாதங்களுக்கு 4,6,9,11 க்கு 1 அல்லது 30 நாட்களுக்கு மேல் இல்லை மற்றும் மாதத்திற்கு 2 க்கு 1 அல்லது 29 நாட்களுக்கு மேல் இல்லை./ 1. தேதி சரம் காலியாக இல்லை./ பின்வரும் விதிகளை பூர்த்தி செய்தால் தேதி செல்லுபடியாகும்: / தேதி செல்லுபடியாகும் என்றால் உண்மை என திருப்பித் தருகிறது இல்லையெனில் தவறு./நீங்கள் கொடுக்கப்பட்ட தேதி சரம் மற்றும்  சரிபார்க்கும் ஒரு செயல்பாடு எழுத வேண்டும்// >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
function valid_date(date){
","function valid_date(date) {
    if (!date) return false;
    
    // Regular expression to match the date pattern mm-dd-yyyy
    const datePattern = /^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\d{4}$/;
    if (!datePattern.test(date)) return false;

    // Split the date into parts
    const [month, day, year] = date.split('-').map(Number);

    // Check the valid number of days per month
    if (month === 2) {
        // Check for February, normally 28 max days, 29 if leap year
        const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        if (day > 29 || (day === 29 && !isLeapYear)) return false;
    } else if ([4, 6, 9, 11].includes(month)) {
        // April, June, September, November have 30 max days
        if (day > 30) return false;
    } else {
        // Other months have 31 max days
        if (day > 31) return false;
    }

    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = valid_date;
  assert.deepEqual(candidate(""03-11-2000""),true);
  assert.deepEqual(candidate(""15-01-2012""),false);
  assert.deepEqual(candidate(""04-0-2040""),false);
  assert.deepEqual(candidate(""06-04-2020""),true);
  assert.deepEqual(candidate(""01-01-2007""),true);
  assert.deepEqual(candidate(""03-32-2011""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""04-31-3000""),false);
  assert.deepEqual(candidate(""06-06-2005""),true);
  assert.deepEqual(candidate(""21-31-2000""),false);
  assert.deepEqual(candidate(""04-12-2003""),true);
  assert.deepEqual(candidate(""04122003""),false);
  assert.deepEqual(candidate(""20030412""),false);
  assert.deepEqual(candidate(""2003-04""),false);
  assert.deepEqual(candidate(""2003-04-12""),false);
  assert.deepEqual(candidate(""04-2003""),false);
}

test();"
HumanEval_125,tam_Taml,js,"/ உதாரணங்கள் / எழுத்துக்கள், ord (a) = 0, ord (b) = 1, . . . ord (z) = 25/ கமாக்களில் பிரிக்கப்பட வேண்டும் ',' கமாக்கள் இல்லை என்றால் நீங்கள் சிறிய எழுத்துக்களின் எண்ணிக்கையை ல் ஒற்றைப்படை வரிசையில் திருப்பித் தர வேண்டும்./ஒரு சொற்கள் வரிசையை கொடுத்தால், நீங்கள் தேடும் உரையில் வெற்றுவெளிகள் இல்லாவிட்டால், வெற்றுவெளியில் பிரிக்கப்பட்ட சொற்களின் வரிசையைத் திருப்பித் தரவும்.// >>> split_words(""Hello world!"")
// [""Hello"", ""world!""]
// >>> split_words(""Hello,world!"")
// [""Hello"", ""world!""]
// >>> split_words(""abcdef"")
// 3
function split_words(txt){
","function split_words(txt) {
    if (/\s/.test(txt)) {
        // Split on whitespace if it exists
        return txt.split(/\s+/);
    } else if (/,/.test(txt)) {
        // Split on commas if no whitespace exists
        return txt.split(',');
    } else {
        // Return count of lowercase letters with odd order in the alphabet
        let oddOrderCount = 0;
        for (let i = 0; i < txt.length; i++) {
            let char = txt[i];
            if (char >= 'a' && char <= 'z') {
                let order = char.charCodeAt(0) - 'a'.charCodeAt(0);
                if (order % 2 !== 0) {
                    oddOrderCount++;
                }
            }
        }
        return oddOrderCount;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = split_words;
  assert.deepEqual(candidate(""Hello world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello,world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello world,!""),[""Hello"", ""world,!""]);
  assert.deepEqual(candidate(""Hello,Hello,world !""),[""Hello,Hello,world"", ""!""]);
  assert.deepEqual(candidate(""abcdef""),3);
  assert.deepEqual(candidate(""aaabb""),2);
  assert.deepEqual(candidate(""aaaBb""),1);
  assert.deepEqual(candidate(""""),0);
}

test();"
HumanEval_126,tam_Taml,js,"/ உதாரணங்கள் / number, false எனத் திரும்பு. எதிர்மறை எண்கள் இல்லை, முழு எண்கள் மட்டுமே./ அதிகரிக்கும் வரிசையில். வரிசைக்கு ஒன்றுக்கு மேற்பட்ட இரட்டைப் பிரதிகள் இருந்தால்/எண்களின் வரிசை கொடுக்கப்பட்டால், அவை வரிசைப்படுத்தப்பட்டாலும் இல்லாவிட்டாலும் திரும்பும்.// >>> is_sorted([5])
// true
// >>> is_sorted([1, 2, 3, 4, 5])
// true
// >>> is_sorted([1, 3, 2, 4, 5])
// false
// >>> is_sorted([1, 2, 3, 4, 5, 6])
// true
// >>> is_sorted([1, 2, 3, 4, 5, 6, 7])
// true
// >>> is_sorted([1, 3, 2, 4, 5, 6, 7])
// false
// >>> is_sorted([1, 2, 2, 3, 3, 4])
// true
// >>> is_sorted([1, 2, 2, 2, 3, 4])
// false
function is_sorted(lst){
","function is_sorted(lst) {
    if (lst.length <= 1) return true;

    for (let i = 0; i < lst.length - 1; i++) {
        if (lst[i] > lst[i + 1]) {
            return false;
        }
        if (lst[i] === lst[i + 1]) {
            // Check if more than 1 duplicate by looking two steps ahead
            if (i + 2 < lst.length && lst[i] === lst[i + 2]) {
                return false;
            }
        }
    }
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_sorted;
  assert.deepEqual(candidate([5]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);
  assert.deepEqual(candidate([]),true);
  assert.deepEqual(candidate([1]),true);
  assert.deepEqual(candidate([3, 2, 1]),false);
  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);
  assert.deepEqual(candidate([1, 2, 3, 4]),true);
}

test();"
HumanEval_127,tam_Taml,js,"/ [உள்ளீடு/வெளியீடு] மாதிரிகள்: / இரண்டு இடைவெளிகள் குறுக்கிடவில்லை என்றால், ""NO"" எனத் திருப்பி அனுப்புக./ இல்லையெனில், ""இல்லை"" என்று திருப்பி அனுப்புங்கள்./ குறுக்குவெட்டு நீளம் ஒரு பிரதான எண் என்றால், ""YES"" எனத் திருப்பித் தரவும், / அதன் நீளம் 1 ஆகும், இது ஒரு பிரதான எண் அல்ல./ உதாரணமாக, இடைவெளிகளின் குறுக்குவெட்டு (1, 3), (2, 4) என்பது (2, 3) / இடைவெளிகள் ஒரு பிரதான எண் ஆகும்./ உங்கள் பணி இந்த இரண்டு ன் குறுக்குவெட்டு நீளம் என்பதை தீர்மானிக்க உள்ளது/ கொடுக்கப்பட்ட ஒவ்வொரு இடைவெளியிலும், அதன் ஆரம்பம் அதன் முடிவுக்கு குறைவாகவோ அல்லது சமமாகவோ இருக்கும் என்று கருதப்படுகிறது./ ஆரம்பம் மற்றும் முடிவு ஆகிய இரண்டையும் உள்ளடக்கியது./ கொடுக்கப்பட்ட இடைவெளிகள் மூடப்பட்டவை, அதாவது இடைவெளி (தொடக்கம், முடிவு) / ஒவ்வொரு இடைவெளியும் ஒரு ஜோடி முழு எண்கள். உதாரணமாக, இடைவெளி = (தொடக்கம், முடிவு) = (1, 2)./நீங்கள் இரண்டு இடைவெளிகள் கொடுக்கப்பட்ட, // >>> intersection([1, 2], [2, 3])
// ""NO""
// >>> intersection([-1, 1], [0, 4])
// ""NO""
// >>> intersection([-3, -1], [-5, 5])
// ""YES""
function intersection(interval1, interval2){
","function intersection(interval1, interval2) {
    const [start1, end1] = interval1;
    const [start2, end2] = interval2;

    // Determine the start and end of the intersection
    const startIntersection = Math.max(start1, start2);
    const endIntersection = Math.min(end1, end2);

    // Calculate the length of the intersection
    const intersectionLength = endIntersection - startIntersection;

    // Helper function to check if a number is prime
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    // Check if the length of the intersection is a prime number
    return intersectionLength > 0 && isPrime(intersectionLength) ? ""YES"" : ""NO"";
}","const assert = require('node:assert');


function test() {
  let candidate = intersection;
  assert.deepEqual(candidate([1, 2], [2, 3]),""NO"");
  assert.deepEqual(candidate([-1, 1], [0, 4]),""NO"");
  assert.deepEqual(candidate([-3, -1], [-5, 5]),""YES"");
  assert.deepEqual(candidate([-2, 2], [-4, 0]),""YES"");
  assert.deepEqual(candidate([-11, 2], [-1, -1]),""NO"");
  assert.deepEqual(candidate([1, 2], [3, 5]),""NO"");
  assert.deepEqual(candidate([1, 2], [1, 2]),""NO"");
  assert.deepEqual(candidate([-2, -2], [-3, -2]),""NO"");
}

test();"
HumanEval_128,tam_Taml,js,"/ உதாரணம்: / குறிப்பு: வெற்று arr க்கு வரையறுக்கப்படாதது./ வரிசையில் உள்ள ஒவ்வொரு எண்ணின், 1, -1 அல்லது 0 மூலம் பிரதிநிதித்துவப்படுத்தப்படுகிறது./ முழு எண்களின் அளவுகளின் கூட்டுத்தொகை அனைத்து அறிகுறிகளின் தயாரிப்புகளால் பெருக்கப்படுகிறது /நீங்கள் முழு எண்களின் வரிசை arr கொடுக்கப்பட்டு நீங்கள் திரும்ப வேண்டும் // >>> prod_signs([1, 2, 2, -4])
// 9
// >>> prod_signs([0, 1])
// 0
// >>> prod_signs([])
// undefined
function prod_signs(arr){
","function prod_signs(arr) {
    if (arr.length === 0) return undefined;

    let sumOfMagnitudes = 0;
    let productOfSigns = 1;

    for (let num of arr) {
        sumOfMagnitudes += Math.abs(num);
        productOfSigns *= (num === 0 ? 0 : Math.sign(num));
    }

    return sumOfMagnitudes * productOfSigns;
}","const assert = require('node:assert');


function test() {
  let candidate = prod_signs;
  assert.deepEqual(candidate([1, 2, 2, -4]),-9);
  assert.deepEqual(candidate([0, 1]),0);
  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);
  assert.deepEqual(candidate([-1, 1, -1, 1]),4);
  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);
  assert.deepEqual(candidate([-1, 1, 1, 0]),0);
}

test();"
HumanEval_129,tam_Taml,js,"/ உதாரணங்கள்: / குறைந்தபட்ச பாதை செல்லும் செல்களில் உள்ள மதிப்புகளின் வரிசை வரிசையைத் தருகிறது./ பதில் தனித்துவமானது என்று உத்தரவாதம் அளிக்கப்படுகிறது. / lst_A[j] = lst_B[j] க்கு சமம்./ lst_A[i] < lst_B[i] மற்றும் எந்த j (1 <= j < i) க்கும் நமக்கு / lst_B ஐ விட, வேறு வார்த்தைகளில் கூறுவதானால், ஒரு முழு எண் குறியீட்டு i (1 <= i <= k)  உள்ளது./ மூலம் (அவற்றை lst_A மற்றும் lst_B என்று அழைப்போம்), lst_A என்பது சொற்களஞ்சிய ரீதியாக குறைவாக உள்ளது / A மற்றும் B செல்லும் செல்கள் மீது மதிப்புகள் வரிசைப்படுத்தப்பட்ட வரிசைகளை செய்த பிறகு / ஒரு பாதை A (நீளம் k) ஒரு பாதை B (நீளம் k) விட குறைவாக கருதப்படுகிறது என்றால்/ நீங்கள் கட்டம் வெளியே போக முடியாது. / அவசியமாக வேறுபட்டது)./ k நீள பாதை என்பது சரியாக k செல்களை (இல்லை / செல். / வேறு வார்த்தைகளில் கூறுவதானால், நீங்கள் தற்போதைய ஒரு விளிம்பில் பகிர்ந்து கொள்ளும் செல்கள் செல்ல முடியும் / எந்த செல் இருந்து, ஒவ்வொரு படியிலும் நீங்கள் அண்டை செல்கள் எந்த நகர்த்த முடியும், நீங்கள் கட்டத்தில் நீளம் k குறைந்தபட்ச பாதையை கண்டுபிடிக்க வேண்டும். நீங்கள் தொடங்க முடியும்./ உள்ளடக்கியது கட்டத்தின் செல்களில் சரியாக ஒரு முறை தோன்றும்./ கட்டத்தின் ஒவ்வொரு கலமும் ஒரு மதிப்பைக் கொண்டுள்ளது. [1, N * N] வரம்பில் உள்ள ஒவ்வொரு முழு எண் க்கும்/N வரிசைகள் மற்றும் N நெடுவரிசைகள் (N >= 2) மற்றும் ஒரு நேர்மறை முழு எண் k,  கொண்ட ஒரு கட்டம் கொடுக்கப்பட்டால்,// >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
// [1, 2, 1]
// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
// [1]
function minPath(grid, k){
","function minPath(grid, k) {
    const N = grid.length;
    const directions = [
        [0, 1], // right
        [1, 0], // down
        [0, -1], // left
        [-1, 0]  // up
    ];
    
    let minPathResult = Array(k).fill(Infinity);

    function dfs(x, y, path) {
        if (path.length === k) {
            // Check if the current path is lexicographically smaller
            if (comparePaths(path, minPathResult)) {
                minPathResult = [...path];
            }
            return;
        }

        for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {
                path.push(grid[nx][ny]);
                dfs(nx, ny, path);
                path.pop();
            }
        }
    }
    
    function comparePaths(pathA, pathB) {
        for (let i = 0; i < pathA.length; i++) {
            if (pathA[i] < pathB[i]) return true;
            if (pathA[i] > pathB[i]) return false;
        }
        return false;
    }

    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            dfs(i, j, [grid[i][j]]);
        }
    }

    return minPathResult;
}","const assert = require('node:assert');


function test() {
  let candidate = minPath;
  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);
  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);
  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);
  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);
  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);
  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);
  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);
  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);
  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

test();"
HumanEval_130,tam_Taml,js,"/ உதாரணங்கள்: / முதல் n + 1 டிரிபோனச்சி வரிசையின் எண்கள்./ உங்களுக்கு ஒரு எதிர்மறை அல்லாத முழு எண் n கொடுக்கப்பட்டுள்ளது, நீங்கள் ஒரு வரிசையை திரும்ப வேண்டும் / = 2 + 3 + 3 = 8 / tri(3) = tri(2) + tri(1) + tri(4) / tri(4) = 3 / tri(2) = 1 + (2 / 2) = 2 / உதாரணமாக: / tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), n என்பது ஒற்றைப்படை என்றால்./tri(n) = 1 + n / 2, n சமமாக இருந்தால்./ tri(1) = 3 / டிரிபோனச்சி வரிசை பின்வரும் தொடர்ச்சியால் வரையறுக்கப்படுகிறது: ஆனால், மக்களுக்கு தெரியாதது டிரிபோனச்சி வரிசைமுறை./எல்லோருக்கும் ஃபீபனோச்சி வரிசை தெரியும், இது கணிதவியலாளர்களால் ஆழமாக ஆய்வு செய்யப்பட்டது // >>> tri(3)
// [1, 3, 2, 8]
function tri(n){
","function tri(n) {
    if (n < 0) return [];
    
    let tribonacci = new Array(n + 1);

    for (let i = 0; i <= n; i++) {
        if (i === 1) {
            tribonacci[i] = 3;
        } else if (i % 2 === 0) {
            tribonacci[i] = 1 + i / 2;
        } else {
            tribonacci[i] = 
                (tribonacci[i - 1] !== undefined ? tribonacci[i - 1] : 0) + 
                (tribonacci[i - 2] !== undefined ? tribonacci[i - 2] : 0) + 
                (tribonacci[i + 1] !== undefined ? tribonacci[i + 1] : 0);
        }
    }

    return tribonacci;
}","const assert = require('node:assert');


function test() {
  let candidate = tri;
  assert.deepEqual(candidate(3),[1, 3, 2, 8]);
  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);
  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);
  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);
  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);
  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);
  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
  assert.deepEqual(candidate(0),[1]);
  assert.deepEqual(candidate(1),[1, 3]);
}

test();"
HumanEval_131,tam_Taml,js,"/ உதாரணமாக: / அனைத்து இலக்கங்களும் சமமாக இருந்தால் 0 ஐத் திருப்பித் தரவும். /ஒரு நேர்மறை முழு எண் n கொடுக்கப்பட்டால், ஒற்றை இலக்கங்களின் பெருக்கலைத் திருப்பிக் கொடுங்கள்.// >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
function digits(n){
","function digits(n) {
    let product = 1;
    let hasOdd = false;

    while (n > 0) {
        let digit = n % 10;
        if (digit % 2 !== 0) {
            product *= digit;
            hasOdd = true;
        }
        n = Math.floor(n / 10);
    }

    return hasOdd ? product : 0;
}","const assert = require('node:assert');


function test() {
  let candidate = digits;
  assert.deepEqual(candidate(5),5);
  assert.deepEqual(candidate(54),5);
  assert.deepEqual(candidate(120),1);
  assert.deepEqual(candidate(5014),5);
  assert.deepEqual(candidate(98765),315);
  assert.deepEqual(candidate(5576543),2625);
  assert.deepEqual(candidate(2468),0);
}

test();"
HumanEval_132,tam_Taml,js,"/ இதில் குறைந்தபட்சம் ஒரு அடைப்புக்குறி பின் வரிசையில் உள்ளது./ செயல்பாடு சரியான அடைப்புக்குறிகளின் தொடர்ச்சியாக இருந்தால் மட்டுமே true எனத் திரும்ப வேண்டும்./சதுர அடைப்புக்குறிகளை மட்டுமே கொண்டிருக்கும் ஒரு சரத்தை உள்ளீடாக எடுக்கும் ஒரு செயல்பாட்டை உருவாக்கவும்.// >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
function is_nested(string){
","function is_nested(string) {
    let openCount = 0;
    let nested = false;

    for (let char of string) {
        if (char === '[') {
            if (openCount > 0) {
                nested = true;
            }
            openCount++;
        } else if (char === ']') {
            if (openCount > 0) {
                openCount--;
            }
        }
    }
    
    return nested && openCount === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = is_nested;
  assert.deepEqual(candidate(""[[]]""),true);
  assert.deepEqual(candidate(""[]]]]]]][[[[[]""),false);
  assert.deepEqual(candidate(""[][]""),false);
  assert.deepEqual(candidate(""[]""),false);
  assert.deepEqual(candidate(""[[[[]]]]""),true);
  assert.deepEqual(candidate(""[]]]]]]]]]]""),false);
  assert.deepEqual(candidate(""[][][[]]""),true);
  assert.deepEqual(candidate(""[[]""),false);
  assert.deepEqual(candidate(""[]]""),false);
  assert.deepEqual(candidate(""[[]][[""),true);
  assert.deepEqual(candidate(""[[][]]""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""[[[[[[[[""),false);
  assert.deepEqual(candidate(""]]]]]]]]""),false);
}

test();"
HumanEval_133,tam_Taml,js,"/ உதாரணங்கள்: / வரிசையில் உள்ள ஒவ்வொரு உறுப்பையும் மேல் int ((Ceiling) வரை சுற்றி வளைக்கவும்./ கொடுக்கப்பட்ட வரிசையில் உள்ள எண்களின் சதுரத்தின் கூட்டுத்தொகையை நீங்கள் திருப்பித் தர வேண்டும், /நீங்கள் எண்கள் ஒரு வரிசை கொடுக்கப்பட்ட. // >>> lst([1.0, 2.0, 3.0])
// 14
// >>> lst([1.0, 4.0, 9.0])
// 98
// >>> lst([1.0, 3.0, 5.0, 7.0])
// 84
// >>> lst([1.4, 4.2, 0.0])
// 29
// >>> lst([-2.4, 1.0, 1.0])
// 6
function sum_squares(lst){
","function sum_squares(lst) {
    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);
  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);
  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);
  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);
  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);
  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);
  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);
  assert.deepEqual(candidate([0.0]),0);
  assert.deepEqual(candidate([-1.0]),1);
  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);
}

test();"
HumanEval_134,tam_Taml,js,"/ உதாரணங்கள்: / குறிப்பு: ""வார்த்தை"" என்பது இடைவெளியால் பிரிக்கப்பட்ட எழுத்துக்களின் குழுவாகும்./ ஒரு வார்த்தையின் ஒரு பகுதி, மற்றும் தவறான மற்றபடி. / கொடுக்கப்பட்ட சரம் ஒரு அகரவரிசை எழுத்து மற்றும் இல்லை /ஒரு செயல்பாட்டை உருவாக்குங்கள், அது கடைசி எழுத்து இருந்தால் true எனத் திருப்பித் தரும்.// >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
function check_if_last_char_is_a_letter(txt){
","function check_if_last_char_is_a_letter(txt) {
    if (txt.length === 0) return false;
    
    txt = txt.trim();
    if (txt.length === 0) return false;
    
    let parts = txt.split(' ');
    let lastWord = parts[parts.length - 1];
    
    if (lastWord.length === 0) return false;
    
    let lastChar = lastWord[lastWord.length - 1];
    return /^[a-zA-Z]$/.test(lastChar);
}","const assert = require('node:assert');


function test() {
  let candidate = check_if_last_char_is_a_letter;
  assert.deepEqual(candidate(""apple""),false);
  assert.deepEqual(candidate(""apple pi e""),true);
  assert.deepEqual(candidate(""eeeee""),false);
  assert.deepEqual(candidate(""A""),true);
  assert.deepEqual(candidate(""Pumpkin pie ""),false);
  assert.deepEqual(candidate(""Pumpkin pie 1""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""eeeee e ""),false);
  assert.deepEqual(candidate(""apple pie""),false);
  assert.deepEqual(candidate(""apple pi e ""),false);
}

test();"
HumanEval_135,tam_Taml,js,"/ உதாரணங்கள்: / இரட்டை மதிப்புகள்./ அத்தகைய உறுப்பு இல்லை என்றால் -1. கொடுக்கப்பட்ட வரிசை  கொண்டிருக்காது./ என்பது அதற்கு முன்னால் உள்ள உறுப்பை விட பெரியது அல்லது சமம் அல்ல./ஒரு உறுப்பு மிகப்பெரிய குறியீட்டைத் திரும்பும் ஒரு செயல்பாட்டை உருவாக்கவும்// >>> can_arrange([1, 2, 4, 3, 5])
// 3
// >>> can_arrange([1, 2, 3])
// -1
function can_arrange(arr){
","function can_arrange(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            return i;
        }
    }
    return -1;
}","const assert = require('node:assert');


function test() {
  let candidate = can_arrange;
  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);
  assert.deepEqual(candidate([1, 2, 4, 5]),-1);
  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);
  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);
  assert.deepEqual(candidate([]),-1);
}

test();"
HumanEval_136,tam_Taml,js,"/ உதாரணங்கள்: / எதிர்மறை அல்லது நேர்மறை முழு எண்கள் இல்லையென்றால், அவற்றை வரையறுக்கப்படாததாக திருப்பி விடுங்கள்./ ஒரு வரிசையில் நேர்ம முழு எண்களின். / பெரிய எதிர்மறை முழு எண், மற்றும் 'b' சிறியதாக உள்ளது /ஒரு வரிசையை (a, b) திரும்பும் ஒரு செயல்பாட்டை உருவாக்கவும், அங்கு 'a' என்பது // >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])
// [undefined, 1]
// >>> largest_smallest_integers([])
// [undefined, undefined]
// >>> largest_smallest_integers([0])
// [undefined, undefined]
function largest_smallest_integers(lst){
","function largest_smallest_integers(lst) {
    let largestNegative = undefined;
    let smallestPositive = undefined;
    
    lst.forEach(num => {
        if (num < 0 && (largestNegative === undefined || num > largestNegative)) {
            largestNegative = num;
        }
        if (num > 0 && (smallestPositive === undefined || num < smallestPositive)) {
            smallestPositive = num;
        }
    });
    
    return [largestNegative, smallestPositive];
}","const assert = require('node:assert');


function test() {
  let candidate = largest_smallest_integers;
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);
  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);
  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);
  assert.deepEqual(candidate([]),[undefined, undefined]);
  assert.deepEqual(candidate([0]),[undefined, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);
  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);
  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);
}

test();"
HumanEval_137,tam_Taml,js,"/ குறிப்பு: ஒரு உண்மையான எண் ஒரு சரம் என குறிப்பிடப்பட்டால், மிதக்கும் புள்ளி இருக்கலாம் . அல்லது , / மதிப்புகள் சமமாக இருந்தால் undefined ஐத் தருக./ உண்மையான எண்கள், மற்றும் கொடுக்கப்பட்ட மாறி வகை பெரிய மாறி திரும்ப. /ஒரு செயல்பாட்டை உருவாக்குங்கள் இது முழு எண்கள், மிதக்கும், அல்லது வரிசைகளை குறிக்கும்// >>> compare_one(1, 2.5)
// 2.5
// >>> compare_one(1, ""2,3"")
// ""2,3""
// >>> compare_one(""5,1"", ""6"")
// ""6""
// >>> compare_one(""1"", 1)
// undefined
function compare_one(a, b){
","function compare_one(a, b) {
    // Function to parse the input into a real number.
    const parseNum = (val) => {
        if (typeof val === 'number') return val;
        if (typeof val === 'string') {
            // Replace comma with dot for parsing
            let parsed = parseFloat(val.replace(',', '.'));
            // If parsing fails, return NaN
            if (isNaN(parsed)) return NaN;
            return parsed;
        }
        return NaN;
    };

    // Get parsed numerical values
    const numA = parseNum(a);
    const numB = parseNum(b);

    // Compare the inputs to determine which is greater
    if (numA > numB) return a;
    if (numB > numA) return b;

    // If values are equal return undefined
    return undefined;
}","const assert = require('node:assert');


function test() {
  let candidate = compare_one;
  assert.deepEqual(candidate(1, 2),2);
  assert.deepEqual(candidate(1, 2.5),2.5);
  assert.deepEqual(candidate(2, 3),3);
  assert.deepEqual(candidate(5, 6),6);
  assert.deepEqual(candidate(1, ""2,3""),""2,3"");
  assert.deepEqual(candidate(""5,1"", ""6""),""6"");
  assert.deepEqual(candidate(""1"", ""2""),""2"");
  assert.deepEqual(candidate(""1"", 1),undefined);
}

test();"
HumanEval_138,tam_Taml,js,"/ உதாரணம் கொடுக்கப்பட்ட எண்ணை n என்பது சரியாக 4 நேர்மறை சம எண்களின் கூட்டுத்தொகையாக எழுத முடியுமா என்பதை மதிப்பீடு செய்யவும்.// >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
function is_equal_to_sum_even(n){
","function is_equal_to_sum_even(n) {
    // A number can be expressed as the sum of 4 positive even numbers
    // if it is greater than or equal to 8 and is even.

    if (n >= 8 && n % 2 === 0) {
        return true;
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = is_equal_to_sum_even;
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),true);
  assert.deepEqual(candidate(11),false);
  assert.deepEqual(candidate(12),true);
  assert.deepEqual(candidate(13),false);
  assert.deepEqual(candidate(16),true);
}

test();"
HumanEval_139,tam_Taml,js,"/ உதாரணமாக: / அங்கு n > 0 / brazilian_factorial(n) = n! * (n-1)! * (n-2)! * . . * 1! /பிரேசிலிய காரணி பின்வருமாறு வரையறுக்கப்படுகிறது: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
function special_factorial(n){
","function factorial(num) {
    if (num <= 1) return 1;
    return num * factorial(num - 1);
}

function special_factorial(n) {
    let result = 1;
    for (let i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = special_factorial;
  assert.deepEqual(candidate(4),288);
  assert.deepEqual(candidate(5),34560);
  assert.deepEqual(candidate(7),125411328000);
  assert.deepEqual(candidate(1),1);
}

test();"
HumanEval_140,tam_Taml,js,"/ பின்னர் அனைத்து தொடர்ச்சியான இடைவெளிகளை -  உடன் மாற்றவும்/ மற்றும் ஒரு சரம் 2 தொடர்ச்சியான இடைவெளிகளை விட அதிகமாக இருந்தால்,/ஒரு வரிசையைக் கொடுத்தால், அதில் உள்ள அனைத்து இடைவெளிகளையும் கீழ்நோக்கி கொண்டு மாற்றவும்,// >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
function fix_spaces(text){
","function fix_spaces(text) {
    return text.trim().replace(/\s{2,}/g, '-').replace(/\s/g, '_');
}","const assert = require('node:assert');


function test() {
  let candidate = fix_spaces;
  assert.deepEqual(candidate(""Example""),""Example"");
  assert.deepEqual(candidate(""Mudasir Hanif ""),""Mudasir_Hanif_"");
  assert.deepEqual(candidate(""Yellow Yellow  Dirty  Fellow""),""Yellow_Yellow__Dirty__Fellow"");
  assert.deepEqual(candidate(""Exa   mple""),""Exa-mple"");
  assert.deepEqual(candidate(""   Exa 1 2 2 mple""),""-Exa_1_2_2_mple"");
}

test();"
HumanEval_141,tam_Taml,js,"/ உதாரணங்கள்: / - புள்ளிக்கு பின் வரும் துணை சரம் பின்வருவனவற்றில் ஒன்றாக இருக்க வேண்டும்: ['txt', 'exe', 'dll'] / லத்தீன் எழுத்துக்கள் ('a'-'z' மற்றும் 'A'-'Z')./ - புள்ளியின் முன் உள்ள துணை சரம் காலியாக இருக்கக்கூடாது, அது ல் இருந்து ஒரு எழுத்துடன் தொடங்குகிறது./ - கோப்பின் பெயரில் சரியாக ஒரு புள்ளி உள்ளது./ - கோப்புப் பெயரில் மூன்று இலக்கங்களுக்கு மேல் ('0'-'9') இருக்கக் கூடாது./ பூர்த்தி செய்யப்படுகின்றன: / ஒரு கோப்பின் பெயர் பின்வரும் நிபந்தனைகள் அனைத்தும் இருந்தால் மட்டுமே செல்லுபடியாகும் என்று கருதப்படுகிறது./ கோப்பின் பெயர் செல்லுபடியாகும் என்றால் 'ஆம்', இல்லையெனில் 'இல்லை' எனத் தருகிறது./ஒரு கோப்பின் பெயரைக் குறிக்கும் ஒரு சரத்தை எடுத்து, க்குத் திரும்பும் ஒரு செயல்பாட்டை உருவாக்குக// >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
function file_name_check(file_name){
","function file_name_check(file_name) {
    const validExtensions = ['txt', 'exe', 'dll'];
    const parts = file_name.split('.');

    if (parts.length !== 2) {
        return 'No';
    }

    const [namePart, extensionPart] = parts;

    // Check that the name part is not empty, starts with a letter, and has at most 3 digits
    if (namePart.length === 0 || !/^[a-zA-Z]/.test(namePart)) {
        return 'No';
    }

    const digitCount = (namePart.match(/\d/g) || []).length;
    if (digitCount > 3) {
        return 'No';
    }

    // Check if the extension is one of the valid ones
    if (!validExtensions.includes(extensionPart)) {
        return 'No';
    }

    return 'Yes';
}","const assert = require('node:assert');


function test() {
  let candidate = file_name_check;
  assert.deepEqual(candidate(""example.txt""),""Yes"");
  assert.deepEqual(candidate(""1example.dll""),""No"");
  assert.deepEqual(candidate(""s1sdf3.asd""),""No"");
  assert.deepEqual(candidate(""K.dll""),""Yes"");
  assert.deepEqual(candidate(""MY16FILE3.exe""),""Yes"");
  assert.deepEqual(candidate(""His12FILE94.exe""),""No"");
  assert.deepEqual(candidate(""_Y.txt""),""No"");
  assert.deepEqual(candidate(""?aREYA.exe""),""No"");
  assert.deepEqual(candidate(""/this_is_valid.dll""),""No"");
  assert.deepEqual(candidate(""this_is_valid.wow""),""No"");
  assert.deepEqual(candidate(""this_is_valid.txt""),""Yes"");
  assert.deepEqual(candidate(""this_is_valid.txtexe""),""No"");
  assert.deepEqual(candidate(""#this2_i4s_5valid.ten""),""No"");
  assert.deepEqual(candidate(""@this1_is6_valid.exe""),""No"");
  assert.deepEqual(candidate(""this_is_12valid.6exe4.txt""),""No"");
  assert.deepEqual(candidate(""all.exe.txt""),""No"");
  assert.deepEqual(candidate(""I563_No.exe""),""Yes"");
  assert.deepEqual(candidate(""Is3youfault.txt""),""Yes"");
  assert.deepEqual(candidate(""no_one#knows.dll""),""Yes"");
  assert.deepEqual(candidate(""1I563_Yes3.exe""),""No"");
  assert.deepEqual(candidate(""I563_Yes3.txtt""),""No"");
  assert.deepEqual(candidate(""final..txt""),""No"");
  assert.deepEqual(candidate(""final132""),""No"");
  assert.deepEqual(candidate(""_f4indsartal132.""),""No"");
  assert.deepEqual(candidate("".txt""),""No"");
  assert.deepEqual(candidate(""s.""),""No"");
}

test();"
HumanEval_142,tam_Taml,js,"/ உதாரணங்கள்: / வரிசையில் உள்ள உள்ளீடுகளை மாற்றவும் அதன் குறியீடுகள் 3 அல்லது 4 இன் பெருக்கமாக இல்லை. பின் செயல்பாடு அனைத்து உள்ளீடுகளின் கூட்டுத்தொகையைத் திரும்பப் பெறும்./ 3 இன் பெருக்கல் மற்றும் அதன் குறியீட்டு 4 இன் பெருக்கலாக இருந்தால் முழு எண் உள்ளீட்டை கனமாக்கும்./ இந்த செயல்பாடு முழு எண்களின் வரிசையை எடுக்கும். வரிசையில் உள்ள அனைத்து உள்ளீடுகளுக்கும், அதன் குறியீடானது a  என்றால் செயல்பாடு முழு எண் உள்ளீட்டை சதுரமாக்க வேண்டும்./"" // >>> lst
// [1, 2, 3]
// >>> lst
// []
// >>> lst
// [-1, -5, 2, -1, -5]
function sum_squares(lst){
","function sum_squares(lst) {
    let sum = 0;
    for (let i = 0; i < lst.length; i++) {
        if (i % 3 === 0) {
            sum += Math.pow(lst[i], 2);
        } else if (i % 4 === 0) {
            sum += Math.pow(lst[i], 3);
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1, 2, 3]),6);
  assert.deepEqual(candidate([1, 4, 9]),14);
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);
  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);
  assert.deepEqual(candidate([0]),0);
  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);
  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);
  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);
  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);
  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);
}

test();"
HumanEval_143,tam_Taml,js,"/ உதாரணம் 1: / புதிய சரத்தில் உள்ள சொற்களின் வரிசை அசல் வரிசையில் உள்ளதைப் போலவே இருக்க வேண்டும்./ அதன் நீளங்கள் பிரதான எண்கள், / மற்றும் நீங்கள் அசல் வாக்கியம் இருந்து வார்த்தைகளை கொண்டிருக்கும் ஒரு சரம் திரும்ப வேண்டும், / வாக்கியத்தில் சில சொற்கள் இடைவெளிகளால் பிரிக்கப்பட்டுள்ளன, /நீங்கள் ஒரு வாக்கியத்தை குறிக்கும் ஒரு சரம் கொடுக்கப்படுகிறது, // >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
function words_in_sentence(sentence){
","function words_in_sentence(sentence) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    return sentence.split(' ')
                   .filter(word => isPrime(word.length))
                   .join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = words_in_sentence;
  assert.deepEqual(candidate(""This is a test""),""is"");
  assert.deepEqual(candidate(""lets go for swimming""),""go for"");
  assert.deepEqual(candidate(""there is no place available here""),""there is no place"");
  assert.deepEqual(candidate(""Hi I am Hussein""),""Hi am Hussein"");
  assert.deepEqual(candidate(""go for it""),""go for it"");
  assert.deepEqual(candidate(""here""),"""");
  assert.deepEqual(candidate(""here is""),""is"");
}

test();"
HumanEval_144,tam_Taml,js,"/ x, மற்றும் n ஆகியவை சரியான க்ராக்குகள் என்று நீங்கள் கருதலாம், மேலும் அவை பெயரளவில் பூஜ்ஜியத்தை கொண்டிருக்கவில்லை./ <எண்ணிக்கை>/<குறியீடு> இதில் எண்ணிக்கை மற்றும் கூற்று இருவரும் நேர்ம முழு எண்கள்./ மற்றபடி. x மற்றும் n இரண்டும், ஒரு பங்கின் சரம் பிரதிநிதித்துவம் ஆகும், பின்வரும் வடிவமைப்பைக் கொண்டுள்ளன,/ x * n. x * n ஒரு முழு எண்ணாக மதிப்பீடு செய்யப்பட்டு false  எனில் செயல்பாடு true எனத் திருப்பித் தரும்./உங்கள் பணி வெளிப்பாட்டை எளிமைப்படுத்தும் ஒரு செயல்பாட்டை செயல்படுத்துவது ஆகும்.// >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
function simplify(x, n){
","function simplify(x, n) {
    const parseFraction = (fraction) => {
        const [numerator, denominator] = fraction.split('/').map(Number);
        return { numerator, denominator };
    };

    const xFraction = parseFraction(x);
    const nFraction = parseFraction(n);

    const resultNumerator = xFraction.numerator * nFraction.numerator;
    const resultDenominator = xFraction.denominator * nFraction.denominator;

    return resultNumerator % resultDenominator === 0;
}

// Example usage
console.log(simplify(""1/5"", ""5/1"")); // true
console.log(simplify(""1/6"", ""2/1"")); // false
console.log(simplify(""7/10"", ""10/2"")); // false","const assert = require('node:assert');


function test() {
  let candidate = simplify;
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/6"", ""2/1""),false);
  assert.deepEqual(candidate(""5/1"", ""3/1""),true);
  assert.deepEqual(candidate(""7/10"", ""10/2""),false);
  assert.deepEqual(candidate(""2/10"", ""50/10""),true);
  assert.deepEqual(candidate(""7/2"", ""4/2""),true);
  assert.deepEqual(candidate(""11/6"", ""6/1""),true);
  assert.deepEqual(candidate(""2/3"", ""5/2""),false);
  assert.deepEqual(candidate(""5/2"", ""3/5""),false);
  assert.deepEqual(candidate(""2/4"", ""8/4""),true);
  assert.deepEqual(candidate(""2/4"", ""4/2""),true);
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/5"", ""1/5""),false);
}

test();"
HumanEval_145,tam_Taml,js,"/ உதாரணமாக: / அசல் வரிசையில் உள்ள குறியீட்டின் அடிப்படையில் அவற்றை வரிசைப்படுத்துங்கள்./ குறிப்பு: பல உருப்படிகள் இருந்தால் அவற்றின் இலக்கங்களின் கூட்டுத்தொகை ஒத்ததாக இருக்கும்,/ அவர்களின் இலக்கங்களின் கூட்டுத்தொகைக்கு ஏற்ப உயரும் வரிசையில்./ கொடுக்கப்பட்ட முழு எண்களின் வரிசையை வரிசைப்படுத்தும் ஒரு செயல்பாட்டை எழுதுக // >>> order_by_points([1, 11, -1, -11, -12])
// [-1, -11, 1, -12, 11]
// >>> order_by_points([])
// []
function order_by_points(nums){
","function order_by_points(nums) {
    function sumOfDigits(n) {
        // Absolute value to ensure digits are summed correctly for negative numbers
        return Math.abs(n).toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }

    nums.sort((a, b) => {
        const sumA = sumOfDigits(a);
        const sumB = sumOfDigits(b);
        if (sumA === sumB) {
            return 0; // Maintain original order
        }
        return sumA - sumB;
    });

    return nums;
}","const assert = require('node:assert');


function test() {
  let candidate = order_by_points;
  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);
  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);
}

test();"
HumanEval_146,tam_Taml,js,"/ உதாரணமாக: / ஒரு எண்ணின் முதல் மற்றும் கடைசி இலக்கங்கள் ஒற்றைப்படை (1, 3, 5, 7, 9)./ வரிசையில் உள்ள உறுப்புகளின் எண்ணிக்கை 10 மற்றும் இரண்டையும் விட அதிகமாக உள்ளது /எண்ணங்களின் வரிசையை உள்ளீடுகளாக எடுத்து, திரும்பும் ஒரு செயல்பாட்டை எழுதுக // >>> specialFilter([15, -73, 14, -15])
// 1
// >>> specialFilter([33, -2, -3, 45, 21, 109])
// 2
function specialFilter(nums){
","function specialFilter(nums) {
    return nums.reduce((count, num) => {
        if (Math.abs(num) > 10) {
            const numStr = Math.abs(num).toString();
            const firstDigit = parseInt(numStr[0]);
            const lastDigit = parseInt(numStr[numStr.length - 1]);
            if ([1, 3, 5, 7, 9].includes(firstDigit) && [1, 3, 5, 7, 9].includes(lastDigit)) {
                return count + 1;
            }
        }
        return count;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = specialFilter;
  assert.deepEqual(candidate([5, -2, 1, -5]),0);
  assert.deepEqual(candidate([15, -73, 14, -15]),1);
  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);
  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);
  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([]),0);
}

test();"
HumanEval_147,tam_Taml,js,"/ உதாரணம்: / மற்றும் a[i] + a[j] + a[k] என்பது 3 இன் பெருக்கமாகும்./ i < j < k,  எனும் இடத்தில் a இன் மூன்று மடங்குகளின் எண்ணிக்கையை (a[i], a[j], a[k]) கொடுங்கள்./ ஒவ்வொரு i (1 ≤ i ≤ n) க்கும், a[i] = i * i - i + 1 இன் மதிப்பு./உங்களுக்கு ஒரு நேர்ம முழு எண் n கொடுக்கப்பட்டுள்ளது. நீ n நீளமுள்ள ஒரு முழு எண் வரிசையை உருவாக்க வேண்டும்.// >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
function get_max_triples(n){
","function get_max_triples(n) {
    // Step 1: Create the integer array 'a'
    let a = new Array(n);
    for (let i = 1; i <= n; i++) {
        a[i - 1] = i * i - i + 1;
    }

    // Step 2: Count the triples
    let count = 0;
    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            for (let k = j + 1; k < n; k++) {
                if ((a[i] + a[j] + a[k]) % 3 === 0) {
                    count++;
                }
            }
        }
    }

    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = get_max_triples;
  assert.deepEqual(candidate(5),1);
  assert.deepEqual(candidate(6),4);
  assert.deepEqual(candidate(10),36);
  assert.deepEqual(candidate(100),53361);
}

test();"
HumanEval_148,tam_Taml,js,"/ உதாரணங்கள் / சரியான கிரக பெயர்கள் அல்ல./ செயல்பாடு ஒரு வெற்று வரிசையை திரும்ப வேண்டும் planet1 அல்லது planet2 / சூரியனுக்கு அருகாமையில் உள்ளது. / கிரகம் 1 மற்றும் கிரகம் 2 ஆகியவற்றின் சுற்றுப்பாதையில் அமைந்துள்ளது, / செயல்பாடு அனைத்து கிரகங்கள் கொண்ட ஒரு வரிசை திரும்ப வேண்டும் அதன் சுற்றுப்பாதைகள் உள்ளன / ஒரு செயல்பாட்டை எழுதுங்கள் இது இரண்டு கிரக பெயர்களை சரங்களாக கிரகம்1 மற்றும் கிரகம்2 என எடுக்கும்./ யுரேனஸ், நெப்டியூன்./ என்பது புதன், அடுத்தது வீனஸ், பின்னர் பூமி, செவ்வாய், வியாழன், சனி, நமது சூரிய மண்டலத்தில் எட்டு கிரகங்கள் உள்ளன.// >>> bf(""Jupiter"", ""Neptune"")
// [""Saturn"", ""Uranus""]
// >>> bf(""Earth"", ""Mercury"")
// ""Venus""
// >>> bf(""Mercury"", ""Uranus"")
// [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
function bf(planet1, planet2){
","function bf(planet1, planet2) {
    const planets = [
        ""Mercury"",
        ""Venus"",
        ""Earth"",
        ""Mars"",
        ""Jupiter"",
        ""Saturn"",
        ""Uranus"",
        ""Neptune""
    ];

    const index1 = planets.indexOf(planet1);
    const index2 = planets.indexOf(planet2);

    if (index1 === -1 || index2 === -1) {
        return [];
    }

    const start = Math.min(index1, index2) + 1;
    const end = Math.max(index1, index2);

    return planets.slice(start, end);
}","const assert = require('node:assert');


function test() {
  let candidate = bf;
  assert.deepEqual(candidate(""Jupiter"", ""Neptune""),[""Saturn"", ""Uranus""]);
  assert.deepEqual(candidate(""Earth"", ""Mercury""),[""Venus""]);
  assert.deepEqual(candidate(""Mercury"", ""Uranus""),[""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]);
  assert.deepEqual(candidate(""Neptune"", ""Venus""),[""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""]);
  assert.deepEqual(candidate(""Earth"", ""Earth""),[]);
  assert.deepEqual(candidate(""Mars"", ""Earth""),[]);
  assert.deepEqual(candidate(""Jupiter"", ""Makemake""),[]);
}

test();"
HumanEval_149,tam_Taml,js,"/ உதாரணமாக: / எல்லா வார்த்தைகளும் ஒரே நீளமாக இருக்கும் என்று நீங்கள் கருதலாம்./ செயல்பாடு வரிசைப்படுத்தப்பட்ட வரிசையில் சரங்களின் வரிசையைத் திரும்பப் பெற வேண்டும்./ இரண்டு சொற்களுக்கு ஒரே நீளம் இருந்தால், வரிசையை அகரவரிசையில் வரிசைப்படுத்துங்கள்./ அந்த விதியின்படி வரிசைப்படுத்தப்பட்ட வரிசையைத் திருப்பித் தர வேண்டும்./ வரிசையின் வரிசை ஒவ்வொரு வார்த்தையின் நீளத்தின் படி உயர்ந்து இருக்க வேண்டும், மற்றும் நீங்கள் / மற்றும் அது இரட்டைக் கொண்டிருக்கலாம். / வரிசை என்பது எப்போதும் சரங்களின் வரிசை மற்றும் எண்களின் வரிசை அல்ல,/ மற்றும் ஒரு வரிசைப்படுத்தப்பட்ட வரிசையுடன் விளைவாக வரிசையைத் தருகிறது, / அதிலிருந்து ஒற்றை நீள சரங்களை நீக்குகிறது, /ஒரு வரிசை வரிசைகளை ஒரு அளவுருவாக ஏற்றுக்கொள்ளும் ஒரு செயல்பாட்டை எழுதுக,// >>> list_sort([""aa"", ""a"", ""aaa""])
// [""aa""]
// >>> list_sort([""ab"", ""a"", ""aaa"", ""cd""])
// [""ab"", ""cd""]
function sorted_list_sum(lst){
","function sorted_list_sum(lst) {
    return lst
        .filter(word => word.length % 2 === 0)
        .sort((a, b) => {
            if (a.length === b.length) {
                return a.localeCompare(b);
            }
            return a.length - b.length;
        });
}","const assert = require('node:assert');


function test() {
  let candidate = sorted_list_sum;
  assert.deepEqual(candidate([""aa"", ""a"", ""aaa""]),[""aa""]);
  assert.deepEqual(candidate([""school"", ""AI"", ""asdf"", ""b""]),[""AI"", ""asdf"", ""school""]);
  assert.deepEqual(candidate([""d"", ""b"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""d"", ""dcba"", ""abcd"", ""a""]),[""abcd"", ""dcba""]);
  assert.deepEqual(candidate([""AI"", ""ai"", ""au""]),[""AI"", ""ai"", ""au""]);
  assert.deepEqual(candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""aaaa"", ""bbbb"", ""dd"", ""cc""]),[""cc"", ""dd"", ""aaaa"", ""bbbb""]);
}

test();"
HumanEval_150,tam_Taml,js,"/ உதாரணங்கள்: / ஒரு பிரதான எண் மற்றும் y இன் மதிப்பை திரும்பப் பெற வேண்டும்./ஒரு எளிய நிரல், இது n க்கு  என்றால் x இன் மதிப்பைத் திருப்பித் தர வேண்டும்.// >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
function x_or_y(n, x, y){
","function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;

    if (num % 2 === 0 || num % 3 === 0) return false;

    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }

    return true;
}

function x_or_y(n, x, y) {
    return isPrime(n) ? x : y;
}","const assert = require('node:assert');


function test() {
  let candidate = x_or_y;
  assert.deepEqual(candidate(7, 34, 12),34);
  assert.deepEqual(candidate(15, 8, 5),5);
  assert.deepEqual(candidate(3, 33, 5212),33);
  assert.deepEqual(candidate(1259, 3, 52),3);
  assert.deepEqual(candidate(7919, -1, 12),-1);
  assert.deepEqual(candidate(3609, 1245, 583),583);
  assert.deepEqual(candidate(91, 56, 129),129);
  assert.deepEqual(candidate(6, 34, 1234),1234);
  assert.deepEqual(candidate(1, 2, 0),0);
  assert.deepEqual(candidate(2, 2, 0),2);
}

test();"
HumanEval_151,tam_Taml,js,"/ அரியில் உள்ள எண்கள் ஒற்றைப்படை எண்கள். எதிர்மறை எண்கள் அல்லது முழு எண்கள் அல்லாத எண்களை புறக்கணிக்கவும்./எண்களின் வரிசை கொடுக்கப்பட்டால், எண்களின் சதுரங்களின் கூட்டுத்தொகையைத் திருப்பிக் கொடுங்கள்.// >>> double_the_difference([1, 3, 2, 0])
// 10
// >>> double_the_difference([-1, -2, 0])
// 0
// >>> double_the_difference([9, -2])
// 81
// >>> double_the_difference([0])
// 0
// If the input array is empty, return 0.
function double_the_difference(lst){
","function double_the_difference(lst) {
    return lst.reduce((sum, num) => {
        if (Number.isInteger(num) && num > 0 && num % 2 !== 0) {
            return sum + num * num;
        }
        return sum;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = double_the_difference;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([5.0, 4.0]),25);
  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);
  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);
  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);
  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);
  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);
}

test();"
HumanEval_152,tam_Taml,js,"/ உதாரணம்: / மதிப்பு 0 ஆக இருக்கும், இல்லையெனில் மதிப்பு என்பது யூகத்திற்கும் மதிப்பெண்ணுக்கும் இடையிலான முழுமையான வேறுபாடு./ ஒவ்வொரு யூகமும் எவ்வளவு தொலைவில் உள்ளது என்பதைக் குறிக்கும் அதே நீளத்தின் வரிசையைத் திரும்புக. அவர்கள் சரியாக யூகித்திருந்தால், / உங்களுக்கு இரண்டு வரிசை மதிப்பெண்கள் மற்றும் யூகங்கள் வழங்கப்படுகின்றன, ஒவ்வொரு குறியீடும் பொருந்தக்கூடியதாக இருக்கும்./ ஒரு நபர் பல போட்டிகளின் முடிவுகளை சரியாக யூகித்தாரா என்பதை தீர்மானிப்பதே உங்கள் பணி./ நிச்சயமாக குறிப்பிட்டு ஒப்பிடும் மதிப்புள்ள. / நிகழ்வு இறுதியாக அறியப்படுகிறது. நீங்கள் அந்த நேரத்தில் உணர்வுகள் மற்றும் எண்ணங்கள் உள்ளன /நான் நாம் அனைவரும் அந்த உணர்வு நினைவில் நினைக்கிறேன் போது சில நீண்ட காத்திருந்த விளைவாக // >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
// [0, 0, 0, 0, 3, 3]
// >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
// [4, 4, 1, 0, 0, 6]
function compare(game, guess){
","function compare(game, guess) {
    return game.map((score, index) => Math.abs(score - guess[index]));
}","const assert = require('node:assert');


function test() {
  let candidate = compare;
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);
  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);
  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);
  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);
}

test();"
HumanEval_153,tam_Taml,js,"/ உதாரணம்: / (அதன் வலிமை -1)./ return 'Slices.SErviNGSliCes' என்பதால் 'SErviNGSliCes' என்பது மிக வலுவான நீட்டிப்பாகும் / நீட்டிப்புகள்: ['SErviNGSliCes', 'Cheese', 'StuFfed'] நீங்கள் / உதாரணமாக, உங்களுக்கு ""Slices"" என கொடுக்கப்பட்டால் வகுப்பு மற்றும் ஒரு வரிசை என / வரிசையில் முதலில் வரும் ஒன்றைத் தேர்ந்தெடுக்கவும்./ இரண்டு அல்லது அதற்கு மேற்பட்ட நீட்டிப்புகளை அதே வலிமை இருந்தால், நீங்கள் / வடிவம்: ClassName.StrongestExtensionName. / நீங்கள் வலுவான நீட்டிப்பு கண்டுபிடிக்க வேண்டும் மற்றும் இந்த ஒரு சரம் திரும்ப வேண்டும் / நீட்டிப்பின் பெயரில், CAP - SM என்ற பிரிவு மூலம் வலிமை கொடுக்கப்படுகிறது./ எழுத்துக்கள் நீட்டிப்பு பெயரில், மற்றும் SM சிறிய எழுத்துக்களின் எண்ணிக்கை இருக்கட்டும் / நீட்டிப்பின் வலிமை பின்வருமாறு உள்ளது: CAP என்பது பெரிய எழுத்துக்களின் எண்ணாக இருக்கட்டும் / நீட்டிப்புகள் வகுப்பிற்கு கூடுதல் வகுப்புகளை ஏற்ற பயன்படுகின்றன./நீங்கள் ஒரு வர்க்கம் (ஒரு சரம்) மற்றும் நீட்டிப்புகளின் வரிசை பெயரை வழங்கப்படும்.// >>> Strongest_Extension(""my_class"", [""AA"", ""Be"", ""CC""])
// ""my_class.AA""
function Strongest_Extension(class_name, extensions){
","function Strongest_Extension(class_name, extensions) {
    let strongestExtension = '';
    let maxStrength = -Infinity;

    extensions.forEach(extension => {
        let capCount = 0;
        let smCount = 0;

        for (let char of extension) {
            if (char >= 'A' && char <= 'Z') {
                capCount++;
            } else if (char >= 'a' && char <= 'z') {
                smCount++;
            }
        }

        let strength = capCount - smCount;

        if (strength > maxStrength) {
            maxStrength = strength;
            strongestExtension = extension;
        }
    });

    return `${class_name}.${strongestExtension}`;
}","const assert = require('node:assert');


function test() {
  let candidate = Strongest_Extension;
  assert.deepEqual(candidate(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]),""Watashi.eIGHt8OKe"");
  assert.deepEqual(candidate(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]),""Boku123.YEs.WeCaNe"");
  assert.deepEqual(candidate(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]),""__YESIMHERE.NuLl__"");
  assert.deepEqual(candidate(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]),""K.TAR"");
  assert.deepEqual(candidate(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]),""__HAHA.123"");
  assert.deepEqual(candidate(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]),""YameRore.okIWILL123"");
  assert.deepEqual(candidate(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]),""finNNalLLly.WoW"");
  assert.deepEqual(candidate(""_"", [""Bb"", ""91245""]),""_.Bb"");
  assert.deepEqual(candidate(""Sp"", [""671235"", ""Bb""]),""Sp.671235"");
}

test();"
HumanEval_154,tam_Taml,js,"/உங்களுக்கு 2 சொற்கள் கொடுக்கப்பட்டுள்ளன. இரண்டாவது சொல் அல்லது அதன் சுழற்சிகளில் ஏதேனும் ஒன்று முதல் வார்த்தையில் ஒரு துணை சரம் என்றால் நீங்கள் true ஐத் திருப்பிவிட வேண்டும்.// >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
function cycpattern_check(a, b){
","function cycpattern_check(a, b) {
    if (b.length > a.length) return false;
    
    let currentRotation = b;
    for (let i = 0; i < b.length; i++) {
        if (a.includes(currentRotation)) {
            return true;
        }
        currentRotation = currentRotation.slice(1) + currentRotation[0];
    }
    
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = cycpattern_check;
  assert.deepEqual(candidate(""xyzw"", ""xyw""),false);
  assert.deepEqual(candidate(""yello"", ""ell""),true);
  assert.deepEqual(candidate(""whattup"", ""ptut""),false);
  assert.deepEqual(candidate(""efef"", ""fee""),true);
  assert.deepEqual(candidate(""abab"", ""aabb""),false);
  assert.deepEqual(candidate(""winemtt"", ""tinem""),true);
}

test();"
HumanEval_155,tam_Taml,js,"/ உதாரணம்: /ஒரு முழு எண் கொடுக்கப்பட்டால். ஒரு வரிசையை முறையே சம மற்றும் ஒற்றை இலக்கங்களின் எண்ணிக்கையுடன் திருப்பித் தருகிறது.// >>> even_odd_count(-12)
// [1, 1]
// >>> even_odd_count(123)
// [1, 2]
function even_odd_count(num){
","function even_odd_count(num) {
    // Convert the number to a string and take the absolute value for negative numbers
    const numStr = Math.abs(num).toString();
    let evenCount = 0;
    let oddCount = 0;

    // Loop through each digit in the string
    for (let char of numStr) {
        // Convert the character back to a number
        let digit = parseInt(char, 10);
        // Check if the digit is even or odd
        if (digit % 2 === 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return [evenCount, oddCount];
}","const assert = require('node:assert');


function test() {
  let candidate = even_odd_count;
  assert.deepEqual(candidate(7),[0, 1]);
  assert.deepEqual(candidate(-78),[1, 1]);
  assert.deepEqual(candidate(3452),[2, 2]);
  assert.deepEqual(candidate(346211),[3, 3]);
  assert.deepEqual(candidate(-345821),[3, 3]);
  assert.deepEqual(candidate(-2),[1, 0]);
  assert.deepEqual(candidate(-45347),[2, 3]);
  assert.deepEqual(candidate(0),[1, 0]);
}

test();"
HumanEval_156,tam_Taml,js,"/ உதாரணங்கள்: / கட்டுப்பாடுகள்: 1 <= num <= 1000 / மற்றும் சிறிய எழுத்துக்களில் திருப்பி அனுப்புங்கள். /ஒரு நேர்ம முழு எண் கொடுக்கப்பட்டால், அதன் ரோமன் எண் சமமான சரம், // >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
function int_to_mini_roman(number){
","function int_to_mini_roman(number) {
    const romanNumerals = [
        { value: 1000, numeral: 'm' },
        { value: 900, numeral: 'cm' },
        { value: 500, numeral: 'd' },
        { value: 400, numeral: 'cd' },
        { value: 100, numeral: 'c' },
        { value: 90, numeral: 'xc' },
        { value: 50, numeral: 'l' },
        { value: 40, numeral: 'xl' },
        { value: 10, numeral: 'x' },
        { value: 9, numeral: 'ix' },
        { value: 5, numeral: 'v' },
        { value: 4, numeral: 'iv' },
        { value: 1, numeral: 'i' }
    ];
    
    let result = '';
    for (const { value, numeral } of romanNumerals) {
        while (number >= value) {
            result += numeral;
            number -= value;
        }
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = int_to_mini_roman;
  assert.deepEqual(candidate(19),""xix"");
  assert.deepEqual(candidate(152),""clii"");
  assert.deepEqual(candidate(251),""ccli"");
  assert.deepEqual(candidate(426),""cdxxvi"");
  assert.deepEqual(candidate(500),""d"");
  assert.deepEqual(candidate(1),""i"");
  assert.deepEqual(candidate(4),""iv"");
  assert.deepEqual(candidate(43),""xliii"");
  assert.deepEqual(candidate(90),""xc"");
  assert.deepEqual(candidate(94),""xciv"");
  assert.deepEqual(candidate(532),""dxxxii"");
  assert.deepEqual(candidate(900),""cm"");
  assert.deepEqual(candidate(994),""cmxciv"");
  assert.deepEqual(candidate(1000),""m"");
}

test();"
HumanEval_157,tam_Taml,js,"/ உதாரணம்: / 90 டிகிரி. / ஒரு செவ்வக முக்கோணம் ஒரு முக்கோணம் இதில் ஒரு கோணம் செவ்வக கோணம் அல்லது / பக்கங்கள் ஒரு செவ்வக முக்கோணத்தை உருவாக்குகின்றன, மற்றபடி தவறானது./ஒரு முக்கோணத்தின் மூன்று பக்கங்களின் நீளங்களைக் கொடுத்தால். மூன்று // >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
function right_angle_triangle(a, b, c){
","function right_angle_triangle(a, b, c) {
    // Sort the sides to ensure the largest side is at the end (potential hypotenuse)
    let sides = [a, b, c].sort((x, y) => x - y);
    
    // Check the Pythagorean theorem to determine if it's a right-angled triangle
    return sides[0]**2 + sides[1]**2 === sides[2]**2;
}","const assert = require('node:assert');


function test() {
  let candidate = right_angle_triangle;
  assert.deepEqual(candidate(3, 4, 5),true);
  assert.deepEqual(candidate(1, 2, 3),false);
  assert.deepEqual(candidate(10, 6, 8),true);
  assert.deepEqual(candidate(2, 2, 2),false);
  assert.deepEqual(candidate(7, 24, 25),true);
  assert.deepEqual(candidate(10, 5, 7),false);
  assert.deepEqual(candidate(5, 12, 13),true);
  assert.deepEqual(candidate(15, 8, 17),true);
  assert.deepEqual(candidate(48, 55, 73),true);
  assert.deepEqual(candidate(1, 1, 1),false);
  assert.deepEqual(candidate(2, 2, 10),false);
}

test();"
HumanEval_158,tam_Taml,js,"/ எழுத்துக்கள், சொற்களஞ்சிய வரிசையில் முதலில் வரும் எழுத்தை திருப்பி விடுகிறது./ தனித்துவமான எழுத்துக்களின். பல சரங்கள் தனித்துவமான அதிகபட்ச எண்ணிக்கையைக் கொண்டிருந்தால் / வரிசையில் வெவ்வேறு சொற்கள் உள்ளன. அதிகபட்ச எண்ணிக்கையுடன் வார்த்தையைத் திருப்பி விடுங்கள் /ஒரு வரிசை சரங்களை ஏற்றுக்கொள்ளும் ஒரு செயல்பாட்டை எழுதுக.// >>> find_max([""name"", ""of"", ""string""])
// ""string""
// >>> find_max([""name"", ""enam"", ""game""])
// ""enam""
// >>> find_max([""aaaaaaa"", ""bb"", ""cc""])
// ""aaaaaaa""
function find_max(words){
","function find_max(words) {
    function uniqueCharacterCount(word) {
        const uniqueChars = new Set(word);
        return uniqueChars.size;
    }

    let maxUniqueCount = -1;
    let result = """";

    words.forEach(word => {
        const currentUniqueCount = uniqueCharacterCount(word);
        if (currentUniqueCount > maxUniqueCount || 
            (currentUniqueCount === maxUniqueCount && word < result)) {
            maxUniqueCount = currentUniqueCount;
            result = word;
        }
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = find_max;
  assert.deepEqual(candidate([""name"", ""of"", ""string""]),""string"");
  assert.deepEqual(candidate([""name"", ""enam"", ""game""]),""enam"");
  assert.deepEqual(candidate([""aaaaaaa"", ""bb"", ""cc""]),""aaaaaaa"");
  assert.deepEqual(candidate([""abc"", ""cba""]),""abc"");
  assert.deepEqual(candidate([""play"", ""this"", ""game"", ""of"", ""footbott""]),""footbott"");
  assert.deepEqual(candidate([""we"", ""are"", ""gonna"", ""rock""]),""gonna"");
  assert.deepEqual(candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]),""nation"");
  assert.deepEqual(candidate([""this"", ""is"", ""a"", ""prrk""]),""this"");
  assert.deepEqual(candidate([""b""]),""b"");
  assert.deepEqual(candidate([""play"", ""play"", ""play""]),""play"");
}

test();"
HumanEval_159,tam_Taml,js,"/ உதாரணம்: / போதுமான அளவு கரட் மீதமிருந்தால், மீதமுள்ள கரட் அனைத்தையும் சாப்பிடுவீர்கள், ஆனால் இன்னும் பசியுடன் இருப்பீர்கள்./ உங்கள் உணவுகள் பிறகு விட்டு கரட்ஸ் எண்ணிக்கை ] / நீங்கள் ஒரு வரிசையை திரும்ப வேண்டும் [உணவு உட்கொண்ட கேரட் மொத்த எண்ணிக்கை உங்கள் உணவு பிறகு, / ஆனால் இப்போது நீங்கள் நாள் உணவுகள் முடிக்க மேலும் கேரட் சாப்பிட வேண்டும். /நீங்கள் ஒரு பசி முயல், நீங்கள் ஏற்கனவே கேரட் ஒரு குறிப்பிட்ட எண்ணிக்கையிலான சாப்பிட்டேன், // >>> eat(5, 6, 10)
// [11, 4]
// >>> eat(4, 8, 9)
// [12, 1]
// >>> eat(1, 10, 10)
// [11, 0]
// >>> eat(2, 11, 5)
// [7, 0]
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
function eat(number, need, remaining){
","function eat(number, need, remaining) {
    const carrotsToEat = Math.min(need, remaining);
    const totalEaten = number + carrotsToEat;
    const carrotsLeft = remaining - carrotsToEat;
    return [totalEaten, carrotsLeft];
}","const assert = require('node:assert');


function test() {
  let candidate = eat;
  assert.deepEqual(candidate(5, 6, 10),[11, 4]);
  assert.deepEqual(candidate(4, 8, 9),[12, 1]);
  assert.deepEqual(candidate(1, 10, 10),[11, 0]);
  assert.deepEqual(candidate(2, 11, 5),[7, 0]);
  assert.deepEqual(candidate(4, 5, 7),[9, 2]);
  assert.deepEqual(candidate(4, 5, 1),[5, 0]);
}

test();"
HumanEval_160,tam_Taml,js,"/ ஆபரேட்டர் வரிசையில் குறைந்தது ஒரு ஆபரேட்டர் உள்ளது, மற்றும் ஆபரேண்ட் வரிசையில் குறைந்தது இரண்டு ஆபரேண்டுகள் உள்ளன./ ஆபரேண்ட் என்பது எதிர்மறை அல்லாத முழு எண்களின் வரிசை ஆகும்./ ஆபரேட்டர் வரிசையின் நீளம் ஆபரேண்ட் வரிசையின் நீளத்திற்கு சமம் கழித்தல் ஒன்று./ குறிப்பு: / => முடிவு = 9 / முடிவு = 2 + 3 * 4 - 5 / வரிசை = [2, 3, 4, 5] / ஆபரேட்டர்['+', '*', '-'] / உதாரணம்: / எக்ஸ்போனன்ஷியன் (**) / மாடிப் பிரிவு (//) / பெருக்கல் (*) / கழித்தல் ( - ) / சேர்த்தல் (+) / அடிப்படை அல்ஜீப்ரா செயல்பாடுகள்: / வெளிப்பாடு மற்றும் இந்த வெளிப்பாட்டின் மதிப்பீட்டைத் திருப்பி விடுங்கள்./ இரண்டாவது வரிசை முழு எண்களின் வரிசை ஆகும். கொடுக்கப்பட்ட இரண்டு வரிசைகளை பயன்படுத்தி அல்ஜீப்ரிக் உருவாக்கவும் /இரண்டு வரிசைகள் ஆபரேட்டர்கள், மற்றும் ஆபரேண்ட்கள் கொடுக்கப்பட்டன. முதல் வரிசை அடிப்படை அல்ஜீப்ரா செயல்பாடுகளைக் கொண்டுள்ளது, மற்றும் function do_algebra(operator, operand){
","function do_algebra(operator, operand) {
    let expression = operand[0].toString();
    
    for (let i = 0; i < operator.length; i++) {
        let op = operator[i];
        let currentOperand = operand[i + 1];
        
        // Replace floor division symbol '//' with actual JavaScript behavior
        if (op === '//') {
            expression += `Math.floor(${currentOperand})`;
        } else {
            expression += ` ${op} ${currentOperand}`;
        }
    }
    
    // Evaluate the resulting expression
    let result = eval(expression);
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = do_algebra;
  assert.deepEqual(candidate([""**"", ""*"", ""+""], [2, 3, 4, 5]),37);
  assert.deepEqual(candidate([""+"", ""*"", ""-""], [2, 3, 4, 5]),9);
  assert.deepEqual(candidate([""//"", ""*""], [7, 3, 4]),8);
}

test();"
HumanEval_161,tam_Taml,js,"/ உதாரணங்கள் / செயல்பாடு விளைவாக சரம் திரும்ப வேண்டும். / சரம் எந்த எழுத்துக்களையும் கொண்டிருக்கவில்லை என்றால், சரத்தை தலைகீழாக மாற்றவும்./ இல்லையெனில் அது அப்படியே இருக்கட்டும். / s[i] ஒரு எழுத்து என்றால், அதன் வழக்கை கீழ் முதல் மேல் அல்லது அதற்கு நேர்மாறாக மாற்றவும், /நீங்கள் ஒரு சரம் கொடுக்கப்பட்ட // >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
function solve(s){
","function solve(s) {
    let hasLetter = false;
    let result = '';

    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (/[a-zA-Z]/.test(char)) {
            hasLetter = true;
            if (char === char.toLowerCase()) {
                result += char.toUpperCase();
            } else {
                result += char.toLowerCase();
            }
        } else {
            result += char;
        }
    }

    if (!hasLetter) {
        return result.split('').reverse().join('');
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(""AsDf""),""aSdF"");
  assert.deepEqual(candidate(""1234""),""4321"");
  assert.deepEqual(candidate(""ab""),""AB"");
  assert.deepEqual(candidate(""#a@C""),""#A@c"");
  assert.deepEqual(candidate(""#AsdfW^45""),""#aSDFw^45"");
  assert.deepEqual(candidate(""#6@2""),""2@6#"");
  assert.deepEqual(candidate(""#$a^D""),""#$A^d"");
  assert.deepEqual(candidate(""#ccc""),""#CCC"");
}

test();"
HumanEval_162,tam_Taml,js,"/ 'text' என்பது ஒரு வெற்று சரம் என்றால், undefined ஐ திரும்பவும்./ஒரு சரம் 'text' கொடுக்கப்பட்டால், அதன் md5 ஹேஷ் சமமான சரத்தை திருப்பி விடுக.// >>> string_to_md5(""Hello world"")
// ""3e25960a79dbc69b674cd4ec67a72c62""
function string_to_md5(text){
","const crypto = require('crypto');

function string_to_md5(text) {
    if (text === """") {
        return undefined;
    }
    return crypto.createHash('md5').update(text).digest('hex');
}","const assert = require('node:assert');


function test() {
  let candidate = string_to_md5;
  assert.deepEqual(candidate(""Hello world""),""3e25960a79dbc69b674cd4ec67a72c62"");
  assert.deepEqual(candidate(""""),undefined);
  assert.deepEqual(candidate(""A B C""),""0ef78513b0cb8cef12743f5aeb35f888"");
  assert.deepEqual(candidate(""password""),""5f4dcc3b5aa765d61d8327deb882cf99"");
}

test();"
HumanEval_163,tam_Taml,js,"/ உதாரணமாக: / மற்றும் b, அதிகரிக்கும் வரிசையில்./இரண்டு நேர்ம முழு எண்கள் a மற்றும் b கொடுக்கப்பட்டால், a க்கு இடையில் உள்ள சம எண்களைத் திருப்பித் தரவும்.// >>> generate_integers(2, 8)
// [2, 4, 6, 8]
// >>> generate_integers(8, 2)
// [2, 4, 6, 8]
// >>> generate_integers(10, 14)
// []
function generate_integers(a, b){
","function generate_integers(a, b) {
    let start = Math.min(a, b);
    let end = Math.max(a, b);
    let evenDigits = [];

    for (let i = start; i <= end; i++) {
        if (i % 2 === 0) {
            evenDigits.push(i);
        }
    }

    return evenDigits;
}","const assert = require('node:assert');


function test() {
  let candidate = generate_integers;
  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);
  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(17, 89),[]);
}

test();"
