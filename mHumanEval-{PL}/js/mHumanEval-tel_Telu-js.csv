task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,tel_Telu,js,"/ ఇచ్చిన పరిమితి. /ఇచ్చిన సంఖ్యల శ్రేణిలో,  కంటే ఏవైనా రెండు సంఖ్యలు ఒకదానికొకటి దగ్గరగా ఉన్నాయో లేదో తనిఖీ చేయండి.// >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
// false
// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
// true
function has_close_elements(numbers, threshold){
","function has_close_elements(numbers, threshold) {
    // First, sort the array to ensure we check adjacency for closest elements
    numbers.sort((a, b) => a - b);

    // Iterate through the sorted list and check differences between successive elements
    for (let i = 0; i < numbers.length - 1; i++) {
        if (Math.abs(numbers[i] - numbers[i + 1]) < threshold) {
            return true;
        }
    }

    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = has_close_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);
}

test();"
HumanEval_1,tel_Telu,js,"/ ఇన్పుట్ స్ట్రింగ్ లో ఏ ఖాళీలను విస్మరించండి. / ప్రత్యేక సమూహాలు సమతుల్యంగా ఉంటాయి (ప్రతి ఓపెన్ బ్రేస్ సరిగ్గా మూసివేయబడుతుంది) మరియు ఒకదానిలో ఒకటిగా ఉండవు / ఆ సమూహాన్ని ప్రత్యేక స్ట్రింగ్లుగా వేరు చేసి వాటి శ్రేణిని తిరిగి ఇవ్వండి. / ఈ ఫంక్షన్ కు ఇన్పుట్ అనేది అనేక సమూహాల సమూహాలను కలిగి ఉన్న స్ట్రింగ్. మీ లక్ష్యం // >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// [""()"", ""(())"", ""(()())""]
function separate_paren_groups(paren_string){
","function separate_paren_groups(paren_string) {
    paren_string = paren_string.replace(/\s+/g, ''); // Remove spaces
    const groups = [];
    let balance = 0;
    let currentGroup = '';

    for (let char of paren_string) {
        currentGroup += char;
        if (char === '(') {
            balance++;
        } else if (char === ')') {
            balance--;
        }
        
        if (balance === 0) {
            groups.push(currentGroup);
            currentGroup = '';
        }
    }

    return groups;
}","const assert = require('node:assert');


function test() {
  let candidate = separate_paren_groups;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[""(()())"", ""((()))"", ""()"", ""((())()())""]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[""()"", ""(())"", ""((()))"", ""(((())))""]);
  assert.deepEqual(candidate(""(()(())((())))""),[""(()(())((())))""]);
  assert.deepEqual(candidate(""( ) (( )) (( )( ))""),[""()"", ""(())"", ""(()())""]);
}

test();"
HumanEval_2,tel_Telu,js,"/ సంఖ్య యొక్క దశాంశ భాగాన్ని తిరిగి ఇవ్వండి. / (మిగిలిన భాగం ఎల్లప్పుడూ 1 కంటే చిన్నది)./ మరియు పూర్ణాంకం భాగం (ఇచ్చిన సంఖ్య కంటే పెద్ద పూర్ణాంకం చిన్నది) మరియు దశాంశాలు /ఒక సానుకూల ఫ్లోటింగ్ పాయింట్ సంఖ్య ఇచ్చినట్లయితే, దీనిని గా విభజించవచ్చు.// >>> truncate_number(3.5)
// 0.5
function truncate_number(number){
","function truncate_number(number) {
    return number - Math.floor(number);
}","const assert = require('node:assert');


function test() {
  let candidate = truncate_number;
  assert.deepEqual(candidate(3.5),0.5);
  assert.deepEqual(candidate(1.25),0.25);
  assert.deepEqual(candidate(123.0),0.0);
}

test();"
HumanEval_3,tel_Telu,js,"/ ఆ సమయంలో ఫంక్షన్ true తిరిగి రావాలి. లేకపోతే అది false తిరిగి రావాలి./ సున్నా బ్యాలెన్స్. మీ పని ఏ సమయంలోనైనా ఖాతా బ్యాలెన్స్ సున్నా కంటే తక్కువగా పడిపోతే గుర్తించడం, మరియు / మీరు ఒక బ్యాంకు ఖాతాకు డిపాజిట్ మరియు ఉపసంహరణ కార్యకలాపాలు శ్రేణి ఇవ్వబడుతుంది తో మొదలవుతుంది // >>> below_zero([1, 2, 3])
// false
// >>> below_zero([1, 2, -4, 5])
// true
function below_zero(operations){
","function below_zero(operations) {
    let balance = 0;
    for (let i = 0; i < operations.length; i++) {
        balance += operations[i];
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = below_zero;
  assert.deepEqual(candidate([]),false);
  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);
  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);
  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);
}

test();"
HumanEval_4,tel_Telu,js,"/ MAD = సగటు ∙ x - x_mean ∙/ మూలకం మరియు కేంద్ర బిందువు (ఈ సందర్భంలో సగటు): / సగటు సంపూర్ణ విచలనం అనేది ప్రతి / ఈ డేటా సమితి యొక్క సగటు చుట్టూ. /ఇచ్చిన ఇన్పుట్ సంఖ్యల శ్రేణి కోసం, సగటు సంపూర్ణ విచలనాన్ని లెక్కించండి // >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
// 1.0
function mean_absolute_deviation(numbers){
","function mean_absolute_deviation(numbers) {
    const n = numbers.length;
    if (n === 0) return 0;

    const mean = numbers.reduce((acc, val) => acc + val, 0) / n;
    const deviations = numbers.map(num => Math.abs(num - mean));
    const mad = deviations.reduce((acc, val) => acc + val, 0) / n;

    return mad;
}

// Example usage:
console.log(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])); // Output: 1.0","const assert = require('node:assert');


function test() {
  let candidate = mean_absolute_deviation;
  assert.deepEqual(candidate([1.0, 2.0]),0.5);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);
}

test();"
HumanEval_5,tel_Telu,js,"/ఇన్పుట్ శ్రేణి యొక్క ప్రతి రెండు వరుస అంశాల మధ్య ఒక సంఖ్య 'డిలిమీటర్'ను చొప్పించండి `numbers' // >>> intersperse([], 4)
// []
// >>> intersperse([1, 2, 3], 4)
// [1, 4, 2, 4, 3]
function intersperse(numbers, delimeter){
","function intersperse(numbers, delimiter) {
    if (numbers.length === 0) return [];
    
    const result = [];
    for (let i = 0; i < numbers.length - 1; i++) {
        result.push(numbers[i]);
        result.push(delimiter);
    }
    result.push(numbers[numbers.length - 1]);

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = intersperse;
  assert.deepEqual(candidate([], 7),[]);
  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);
  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);
}

test();"
HumanEval_6,tel_Telu,js,"/ ఉదా. (() (()) గరిష్టంగా రెండు స్థాయిల గూడును కలిగి ఉండగా ((())) మూడు స్థాయిలను కలిగి ఉంటుంది. / ప్రతి సమూహం కోసం, కుండలీకరణాల యొక్క లోతైన గూడు స్థాయిని అవుట్పుట్ చేయండి. /ఈ ఫంక్షన్కు ఇన్పుట్ అనేది స్పేస్లతో వేరు చేయబడిన గూడు కుండలీకరణాల కోసం బహుళ సమూహాలను సూచించే స్ట్రింగ్. // >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// [2, 3, 1, 3]
function parse_nested_parens(paren_string){
","function parse_nested_parens(paren_string) {
    // Split the input string into groups based on spaces
    const groups = paren_string.split(' ');
    // Map each group to its maximum nesting depth
    return groups.map(group => {
        let maxDepth = 0;
        let currentDepth = 0;

        // Iterate through each character in the group
        for (let char of group) {
            if (char === '(') {
                // Increment current depth for '('
                currentDepth++;
                // Update max depth if it's greater than the previous max
                if (currentDepth > maxDepth) {
                    maxDepth = currentDepth;
                }
            } else if (char === ')') {
                // Decrement current depth for ')'
                currentDepth--;
            }
        }
        
        return maxDepth; // Return max depth of this group
    });
}","const assert = require('node:assert');


function test() {
  let candidate = parse_nested_parens;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[2, 3, 1, 3]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[1, 2, 3, 4]);
  assert.deepEqual(candidate(""(()(())((())))""),[4]);
}

test();"
HumanEval_7,tel_Telu,js,"/ఇచ్చిన సబ్ స్ట్రింగ్ ఉన్న స్ట్రింగ్ల యొక్క ఇన్పుట్ శ్రేణిని మాత్రమే ఫిల్టర్ చేయండి // >>> filter_by_substring([], ""a"")
// []
// >>> filter_by_substring([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
// [""abc"", ""bacd"", ""array""]
function filter_by_substring(strings, substring){
","function filter_by_substring(strings, substring) {
    return strings.filter(str => str.includes(substring));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_by_substring;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""),[""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""),[""grunt"", ""prune""]);
}

test();"
HumanEval_8,tel_Telu,js,"/ ఖాళీ మొత్తము 0 కి సమానంగా ఉండాలి మరియు ఖాళీ ఉత్పత్తి 1 కి సమానంగా ఉండాలి. /ఇచ్చిన పూర్ణాంకాల శ్రేణి కోసం, ఒక శ్రేణిలోని అన్ని పూర్ణాంకాల యొక్క మొత్తం మరియు ఉత్పత్తిని కలిగి ఉన్న శ్రేణిని తిరిగి ఇవ్వండి. // >>> sum_product([])
// [0, 1]
// >>> sum_product([1, 2, 3, 4])
// [10, 24]
function sum_product(numbers){
","function sum_product(numbers) {
    let sum = 0;
    let product = 1;

    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i];
        product *= numbers[i];
    }

    return [sum, product];
}","const assert = require('node:assert');


function test() {
  let candidate = sum_product;
  assert.deepEqual(candidate([]),[0, 1]);
  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);
  assert.deepEqual(candidate([100, 0]),[100, 0]);
  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);
  assert.deepEqual(candidate([10]),[10, 10]);
}

test();"
HumanEval_9,tel_Telu,js,"/ క్రమంలో. /ఇచ్చిన పూర్ణాంకాల శ్రేణి నుండి, ఇచ్చిన క్షణం వరకు కనుగొనబడిన గరిష్ట మూలకం యొక్క శ్రేణిని ఉత్పత్తి చేయండి // >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
// [1, 2, 3, 3, 3, 4, 4]
function rolling_max(numbers){
","function rolling_max(numbers) {
    let result = [];
    let currentMax = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < numbers.length; i++) {
        currentMax = Math.max(currentMax, numbers[i]);
        result.push(currentMax);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = rolling_max;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);
  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);
}

test();"
HumanEval_10,tel_Telu,js,"/ - స్ట్రింగ్ రివర్స్ యొక్క స్ట్రింగ్ పూర్వపదము యొక్క ముగింపుకు జోడించండి, ఇది పాలిండ్రోమిక్ ప్రత్యయం ముందు వస్తుంది. / - సరఫరా చేయబడిన స్ట్రింగ్ యొక్క పొడవైన పోస్ట్ఫిక్స్ను కనుగొనండి, ఇది పాలిండ్రోమ్. / అల్గోరిథం ఆలోచన సులభం: /ఇచ్చిన స్ట్రింగ్ తో ప్రారంభమయ్యే అతి తక్కువ పాలిండ్రోమ్ను కనుగొనండి. // >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
function make_palindrome(string){
","function make_palindrome(string) {
    // Helper function to check if a string is a palindrome
    function isPalindrome(s) {
        let left = 0;
        let right = s.length - 1;
        while (left < right) {
            if (s[left] !== s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    // Find the longest palindromic suffix
    let longestPalindromicSuffixLength = 0;
    for (let i = 0; i < string.length; i++) {
        if (isPalindrome(string.slice(i))) {
            longestPalindromicSuffixLength = string.length - i;
            break;
        }
    }

    // Create the shortest palindrome
    const prefixToReverse = string.slice(0, string.length - longestPalindromicSuffixLength);
    const reversedPrefix = prefixToReverse.split('').reverse().join('');
    return string + reversedPrefix;
}

// Examples
console.log(make_palindrome(""""));     // """"
console.log(make_palindrome(""cat""));  // ""catac""
console.log(make_palindrome(""cata"")); // ""catac""","const assert = require('node:assert');


function test() {
  let candidate = make_palindrome;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""x""),""x"");
  assert.deepEqual(candidate(""xyz""),""xyzyx"");
  assert.deepEqual(candidate(""xyx""),""xyx"");
  assert.deepEqual(candidate(""jerry""),""jerryrrej"");
}

test();"
HumanEval_11,tel_Telu,js,"/ ఈ ఇన్పుట్ లపై బైనరీ XOR ను నిర్వహించండి మరియు ఫలితాన్ని స్ట్రింగ్ గా కూడా తిరిగి ఇవ్వండి. /ఇన్పుట్ అనేది రెండు స్ట్రింగ్స్ a మరియు b, వీటిలో 1 లు మరియు 0 లు మాత్రమే ఉంటాయి.// >>> string_xor(""010"", ""110"")
// ""100""
function string_xor(a, b){
","function string_xor(a, b) {
    let result = """";
    for (let i = 0; i < a.length; i++) {
        result += (a[i] === b[i]) ? ""0"" : ""1"";
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = string_xor;
  assert.deepEqual(candidate(""111000"", ""101010""),""010010"");
  assert.deepEqual(candidate(""1"", ""1""),""0"");
  assert.deepEqual(candidate(""0101"", ""0000""),""0101"");
}

test();"
HumanEval_12,tel_Telu,js,"/ ఒకే పొడవు గల స్ట్రింగ్స్. ఇన్పుట్ శ్రేణి ఖాళీగా ఉంటే నిర్వచించబడని తిరిగి ఇవ్వండి. /అనేక స్ట్రింగ్స్ నుండి, పొడవైనదాన్ని తిరిగి ఇవ్వండి. బహుళ స్ట్రింగ్స్ ఉన్నట్లయితే మొదటిదాన్ని తిరిగి ఇవ్వండి.// >>> longest([])
// undefined
// >>> longest([""a"", ""b"", ""c""])
// ""a""
// >>> longest([""a"", ""bb"", ""ccc""])
// ""ccc""
function longest(strings){
","function longest(strings) {
    if (strings.length === 0) return undefined;
    let longestString = strings[0];

    for (let i = 1; i < strings.length; i++) {
        if (strings[i].length > longestString.length) {
            longestString = strings[i];
        }
    }

    return longestString;
}","const assert = require('node:assert');


function test() {
  let candidate = longest;
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""x"");
  assert.deepEqual(candidate([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]),""zzzz"");
}

test();"
HumanEval_13,tel_Telu,js,"/రెండు పూర్ణాంకాల a మరియు b యొక్క అతిపెద్ద సాధారణ విభజనను తిరిగి ఇవ్వండి // >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
function greatest_common_divisor(a, b){
","function greatest_common_divisor(a, b) {
    while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}","const assert = require('node:assert');


function test() {
  let candidate = greatest_common_divisor;
  assert.deepEqual(candidate(3, 7),1);
  assert.deepEqual(candidate(10, 15),5);
  assert.deepEqual(candidate(49, 14),7);
  assert.deepEqual(candidate(144, 60),12);
}

test();"
HumanEval_14,tel_Telu,js,"/ఇన్పుట్ స్ట్రింగ్ యొక్క పొడవైన నుండి చిన్న వరకు అన్ని పూర్వపదాల శ్రేణిని తిరిగి ఇవ్వండి // >>> all_prefixes(""abc"")
// [""a"", ""ab"", ""abc""]
function all_prefixes(string){
","function all_prefixes(string) {
    let prefixes = [];
    for (let i = 1; i <= string.length; i++) {
        prefixes.push(string.substring(0, i));
    }
    return prefixes;
}","const assert = require('node:assert');


function test() {
  let candidate = all_prefixes;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""asdfgh""),[""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""]);
  assert.deepEqual(candidate(""WWW""),[""W"", ""WW"", ""WWW""]);
}

test();"
HumanEval_15,tel_Telu,js,"/0 నుండి n వరకు ఉన్న సంఖ్యలను కలిగి ఉన్న స్ట్రింగ్ను తిరిగి ఇవ్వండి.// >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
function string_sequence(n){
","function string_sequence(n) {
    let result = [];
    for (let i = 0; i <= n; i++) {
        result.push(i);
    }
    return result.join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = string_sequence;
  assert.deepEqual(candidate(0),""0"");
  assert.deepEqual(candidate(3),""0 1 2 3"");
  assert.deepEqual(candidate(10),""0 1 2 3 4 5 6 7 8 9 10"");
}

test();"
HumanEval_16,tel_Telu,js,"/ఒక స్ట్రింగ్ ఇచ్చినట్లయితే, అది ఎన్ని విభిన్న అక్షరాలను కలిగి ఉందో తెలుసుకోండి (కేసుతో సంబంధం లేకుండా)// >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
function count_distinct_characters(string){
","function count_distinct_characters(string) {
    // Convert the string to lowercase to ignore case differences
    const lowercaseString = string.toLowerCase();
    // Create a Set to store distinct characters
    const distinctChars = new Set();
    // Iterate over each character in the string
    for (let char of lowercaseString) {
        distinctChars.add(char); // Add character to the set
    }
    // Return the size of the set which represents the number of distinct characters
    return distinctChars.size;
}","const assert = require('node:assert');


function test() {
  let candidate = count_distinct_characters;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abcde""),5);
  assert.deepEqual(candidate(""abcdecadeCADE""),5);
  assert.deepEqual(candidate(""aaaaAAAAaaaa""),1);
  assert.deepEqual(candidate(""Jerry jERRY JeRRRY""),5);
}

test();"
HumanEval_17,tel_Telu,js,"' ' ' ' ' ' ' ' ' ' ' - క్వార్టర్ నోట్, ఒక బీట్ వరకు ఉంటుంది / 'o rdsa' - సగం నోట్, రెండు బీట్స్ పడుతుంది / 'O' - మొత్తం గమనిక, నాలుగు బీట్స్ ఉంటుంది / ఇక్కడ ఒక పురాణం ఉంది: / చివరి కాదు. / మీ పని ఈ స్ట్రింగ్ను పార్స్ చేసి, ప్రతి ఒక్కటి ఎన్ని బీట్స్కు అనుగుణంగా పూర్ణాంకాల శ్రేణిని తిరిగి ఇవ్వడం./ఈ ఫంక్షన్కు ఇన్పుట్ ఒక ప్రత్యేక ASCII ఫార్మాట్లో సంగీత గమనికలను సూచించే స్ట్రింగ్. // >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
function parse_music(music_string){
","function parse_music(music_string) {
    let notes = music_string.split("" "");
    let beats = [];

    for (let note of notes) {
        switch (note) {
            case 'o':
                beats.push(4);
                break;
            case 'o|':
                beats.push(2);
                break;
            case '.|':
                beats.push(1);
                break;
            default:
                // Handle unexpected notes if necessary
                break;
        }
    }
    return beats;
}

// Example usage:
// console.log(parse_music(""o o| .| o| o| .| .| .| .| o o"")); 
// Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]","const assert = require('node:assert');


function test() {
  let candidate = parse_music;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""o o o o""),[4, 4, 4, 4]);
  assert.deepEqual(candidate("".| .| .| .|""),[1, 1, 1, 1]);
  assert.deepEqual(candidate(""o| o| .| .| o o o o""),[2, 2, 1, 1, 4, 4, 4, 4]);
  assert.deepEqual(candidate(""o| .| o| .| o o| o o|""),[2, 1, 2, 1, 4, 2, 4, 2]);
}

test();"
HumanEval_18,tel_Telu,js,"/ఒక సబ్ స్ట్రింగ్ అసలు స్ట్రింగ్లో ఎన్నిసార్లు దొరుకుతుందో తెలుసుకోండి. అతివ్యాప్తి కేసులను లెక్కించండి. // >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
function how_many_times(string, substring){
","function how_many_times(string, substring) {
  if (substring.length === 0) return 0;
  
  let count = 0;
  let position = 0;
  
  while ((position = string.indexOf(substring, position)) !== -1) {
    count++;
    position++;
  }
  
  return count;
}","const assert = require('node:assert');


function test() {
  let candidate = how_many_times;
  assert.deepEqual(candidate("""", ""x""),0);
  assert.deepEqual(candidate(""xyxyxyx"", ""x""),4);
  assert.deepEqual(candidate(""cacacacac"", ""cac""),4);
  assert.deepEqual(candidate(""john doe"", ""john""),1);
}

test();"
HumanEval_19,tel_Telu,js,"/ అతి చిన్న నుండి అతి పెద్ద వరకు క్రమబద్ధీకరించిన సంఖ్యలతో స్ట్రింగ్ను తిరిగి ఇవ్వండి / చెల్లుబాటు అయ్యే ఎంపికలు 'సున్నా', 'ఒకటి', 'రెండు', 'మూడు', 'నాలుగు', 'ఐదు', 'ఆరు', 'ఏడు', 'ఎనిమిది' మరియు 'తొమ్మిది'. /ఇన్పుట్ అనేది 'సున్నా' నుండి 'తొమ్మిది' వరకు సంఖ్యల యొక్క స్థలం-పరిమిత స్ట్రింగ్.// >>> sort_numbers(""three one five"")
// ""one three five""
function sort_numbers(numbers){
","function sort_numbers(numbers) {
    const numberWords = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
    
    return numbers
        .split(' ')
        .sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b))
        .join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = sort_numbers;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""three""),""three"");
  assert.deepEqual(candidate(""three five nine""),""three five nine"");
  assert.deepEqual(candidate(""five zero four seven nine eight""),""zero four five seven eight nine"");
  assert.deepEqual(candidate(""six five four three two one zero""),""zero one two three four five six"");
}

test();"
HumanEval_20,tel_Telu,js,"/ ఇతర మరియు వాటిని క్రమంలో తిరిగి (చిన్న సంఖ్య, పెద్ద సంఖ్యలో). /అందించిన సంఖ్యల శ్రేణి నుండి (కనీసం రెండు పొడవు) ప్రతిదానికి దగ్గరగా ఉన్న రెండు సంఖ్యలను ఎంచుకుని తిరిగి ఇవ్వండి // >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
// [2.0, 2.2]
// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
// [2.0, 2.0]
function find_closest_elements(numbers){
","function find_closest_elements(numbers) {
    if (numbers.length < 2) {
        throw new Error('Array must contain at least two elements.');
    }
    
    numbers.sort((a, b) => a - b);

    let minDiff = Infinity;
    let closestPair = [numbers[0], numbers[1]];

    for (let i = 0; i < numbers.length - 1; i++) {
        let diff = numbers[i + 1] - numbers[i];
        if (diff < minDiff) {
            minDiff = diff;
            closestPair = [numbers[i], numbers[i + 1]];
        }
    }

    return closestPair;
}","const assert = require('node:assert');


function test() {
  let candidate = find_closest_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);
}

test();"
HumanEval_21,tel_Telu,js,"/ చిన్న సంఖ్య 0 అవుతుంది మరియు అతిపెద్ద సంఖ్య 1 అవుతుంది / సంఖ్యల శ్రేణిని (కనీసం రెండు మూలకాలతో) ఇచ్చినట్లయితే, ఆ శ్రేణికి ఒక సరళ పరివర్తనను వర్తింపజేయండి, // >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
// [0.0, 0.25, 0.5, 0.75, 1.0]
function rescale_to_unit(numbers){
","function rescale_to_unit(numbers) {
    if (numbers.length < 2) {
        throw new Error(""Array must contain at least two elements."");
    }
    
    let min = Math.min(...numbers);
    let max = Math.max(...numbers);
    
    return numbers.map(num => (num - min) / (max - min));
}

// Example usage
console.log(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])); // [0.0, 0.25, 0.5, 0.75, 1.0]","const assert = require('node:assert');


function test() {
  let candidate = rescale_to_unit;
  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);
  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);
  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
}

test();"
HumanEval_22,tel_Telu,js,"/ఇచ్చిన శ్రేణిలో ఏదైనా jsthon విలువలను పూర్ణాంకాల కోసం మాత్రమే ఫిల్టర్ చేయండి // >>> filter_integers([""a"", 3.14, 5])
// [5]
// >>> filter_integers([1, 2, 3, ""abc"", {}, []])
// [1, 2, 3]
function filter_integers(values){
","function filter_integers(values) {
    return values.filter(value => Number.isInteger(value));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_integers;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([4, {}, [], 23.2, 9, ""adasd""]),[4, 9]);
  assert.deepEqual(candidate([3, ""c"", 3, 3, ""a"", ""b""]),[3, 3, 3]);
}

test();"
HumanEval_23,tel_Telu,js,"/ఇచ్చిన స్ట్రింగ్ యొక్క పొడవును తిరిగి ఇవ్వండి // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
function strlen(string){
","function strlen(string) {
    return string.length;
}","const assert = require('node:assert');


function test() {
  let candidate = strlen;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""x""),1);
  assert.deepEqual(candidate(""asdasnakj""),9);
}

test();"
HumanEval_24,tel_Telu,js,"/ ఇచ్చిన సంఖ్య n కోసం, n కంటే చిన్న, n ను సమానంగా విభజించే అతిపెద్ద సంఖ్యను కనుగొనండి // >>> largest_divisor(15)
// 5
function largest_divisor(n){
","function largest_divisor(n) {
    for (let i = n - 1; i > 0; i--) {
        if (n % i === 0) {
            return i;
        }
    }
    return 1; // for the edge case where n is 1
}","const assert = require('node:assert');


function test() {
  let candidate = largest_divisor;
  assert.deepEqual(candidate(3),1);
  assert.deepEqual(candidate(7),1);
  assert.deepEqual(candidate(10),5);
  assert.deepEqual(candidate(100),50);
  assert.deepEqual(candidate(49),7);
}

test();"
HumanEval_25,tel_Telu,js,"/ ఇన్పుట్ సంఖ్య అన్ని కారకాల యొక్క ఉత్పత్తికి సమానంగా ఉండాలి / ప్రతి కారకాలను కారకాల సంఖ్యలో ఎన్నిసార్లు కనిపిస్తుందో దానికి అనుగుణంగా అమర్చాలి./ఇచ్చిన పూర్ణాంకం యొక్క ప్రధాన కారకాల శ్రేణిని అతి చిన్న నుండి అతి పెద్ద వరకు క్రమంలో తిరిగి ఇవ్వండి. // >>> factorize(8)
// [2, 2, 2]
// >>> factorize(25)
// [5, 5]
// >>> factorize(70)
// [2, 5, 7]
function factorize(n){
","function factorize(n) {
    const factors = [];
    let divisor = 2;

    while (n >= 2) {
        if (n % divisor === 0) {
            factors.push(divisor);
            n /= divisor;
        } else {
            divisor++;
        }
    }

    return factors;
}","const assert = require('node:assert');


function test() {
  let candidate = factorize;
  assert.deepEqual(candidate(2),[2]);
  assert.deepEqual(candidate(4),[2, 2]);
  assert.deepEqual(candidate(8),[2, 2, 2]);
  assert.deepEqual(candidate(57),[3, 19]);
  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);
  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);
  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);
  assert.deepEqual(candidate(18),[2, 3, 3]);
}

test();"
HumanEval_26,tel_Telu,js,"/ ఎంట్రీలో ఉన్నట్టుగానే ఎలిమెంట్స్ ఆర్డర్ను ఉంచండి./ పూర్ణాంకాల శ్రేణి నుండి, ఒకటి కంటే ఎక్కువసార్లు సంభవించే అన్ని అంశాలను తొలగించండి. // >>> remove_duplicates([1, 2, 3, 2, 4])
// [1, 3, 4]
function remove_duplicates(numbers){
","function remove_duplicates(numbers) {
    const frequency = {};
    // Count occurrences of each number
    numbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });

    // Filter out numbers that occur more than once
    return numbers.filter(num => frequency[num] === 1);
}","const assert = require('node:assert');


function test() {
  let candidate = remove_duplicates;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);
}

test();"
HumanEval_27,tel_Telu,js,"/ఇచ్చిన స్ట్రింగ్ కోసం, చిన్న అక్షరాలను పెద్ద అక్షరాలకు, పెద్ద అక్షరాలను చిన్న అక్షరాలకు మార్చండి. // >>> flip_case(""Hello"")
// ""hELLO""
function flip_case(string){
","function flip_case(string) {
    let flippedString = '';
    for (let i = 0; i < string.length; i++) {
        const char = string[i];
        if (char === char.toLowerCase()) {
            flippedString += char.toUpperCase();
        } else {
            flippedString += char.toLowerCase();
        }
    }
    return flippedString;
}","const assert = require('node:assert');


function test() {
  let candidate = flip_case;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hello!""),""hELLO!"");
  assert.deepEqual(candidate(""These violent delights have violent ends""),""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"");
}

test();"
HumanEval_28,tel_Telu,js,"/కంటెనేట్ స్ట్రింగ్స్ యొక్క శ్రేణిని ఒకే స్ట్రింగ్ లోకి // >>> concatenate([])
// """"
// >>> concatenate([""a"", ""b"", ""c""])
// ""abc""
function concatenate(strings){
","function concatenate(strings) {
    return strings.join('');
}","const assert = require('node:assert');


function test() {
  let candidate = concatenate;
  assert.deepEqual(candidate([]),"""");
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""xyz"");
  assert.deepEqual(candidate([""x"", ""y"", ""z"", ""w"", ""k""]),""xyzwk"");
}

test();"
HumanEval_29,tel_Telu,js,"/ఇచ్చిన పూర్వపదంతో ప్రారంభమయ్యే స్ట్రింగ్ల కోసం మాత్రమే ఇన్పుట్ శ్రేణిని ఫిల్టర్ చేయండి. // >>> filter_by_prefix([], ""a"")
// []
// >>> filter_by_prefix([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
// [""abc"", ""array""]
function filter_by_prefix(strings, prefix){
","function filter_by_prefix(strings, prefix) {
    return strings.filter(str => str.startsWith(prefix));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_by_prefix;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
}

test();"
HumanEval_30,tel_Telu,js,"/మార్పు శ్రేణిలో సానుకూల సంఖ్యలను మాత్రమే తిరిగి ఇవ్వండి. // >>> get_positive([-1, 2, -4, 5, 6])
// [2, 5, 6]
// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// [5, 3, 2, 3, 9, 123, 1]
function get_positive(l){
","function get_positive(l) {
    return l.filter(function(num) {
        return num > 0;
    });
}","const assert = require('node:assert');


function test() {
  let candidate = get_positive;
  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);
  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);
  assert.deepEqual(candidate([-1, -2]),[]);
  assert.deepEqual(candidate([]),[]);
}

test();"
HumanEval_31,tel_Telu,js,"/ఇచ్చిన సంఖ్య ప్రైమ్ అయితే true, లేకపోతే false అని రిటర్న్ చేస్తుంది.// >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
function is_prime(n){
","function is_prime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
  
    if (n % 2 === 0 || n % 3 === 0) return false;
  
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
  
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_prime;
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(101),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(13441),true);
  assert.deepEqual(candidate(61),true);
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(1),false);
  assert.deepEqual(candidate(5),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(17),true);
  assert.deepEqual(candidate(85),false);
  assert.deepEqual(candidate(77),false);
  assert.deepEqual(candidate(255379),false);
}

test();"
HumanEval_33,tel_Telu,js,"/ l యొక్క సంబంధిత సూచికల విలువలకు, కానీ క్రమబద్ధీకరించబడింది./ l' అనేది మూడు ద్వారా విభజించబడని సూచికలలో l కు సమానంగా ఉంటుంది, అయితే మూడు ద్వారా విభజించబడే సూచికలలో దాని విలువలు సమానంగా ఉంటాయి /ఈ ఫంక్షన్ ఒక శ్రేణి l ను తీసుకుంటుంది మరియు ఒక శ్రేణి l' ను తిరిగి ఇస్తుంది// >>> sort_third([1, 2, 3])
// [1, 2, 3]
// >>> sort_third([5, 6, 3, 4, 8, 9, 2])
// [2, 6, 3, 4, 8, 9, 5]
function sort_third(l){
","function sort_third(l) {
    // Extract the elements at indices divisible by 3
    const elementsToSort = [];
    for (let i = 0; i < l.length; i++) {
        if (i % 3 === 0) {
            elementsToSort.push(l[i]);
        }
    }
    
    // Sort the extracted elements
    elementsToSort.sort((a, b) => a - b);

    // Place the sorted elements back into their original positions
    let sortedIndex = 0;
    for (let i = 0; i < l.length; i++) {
        if (i % 3 === 0) {
            l[i] = elementsToSort[sortedIndex++];
        }
    }
    
    return l;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_third;
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);
  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);
  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);
}

test();"
HumanEval_34,tel_Telu,js,"/అమరిక చేసిన ప్రత్యేక మూలకాలను శ్రేణిలో తిరిగి ఇవ్వండి // >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [0, 2, 3, 5, 9, 123]
function unique(l){
","function unique(l) {
    // Use a Set to remove duplicates and then spread into an array
    const uniqueElements = [...new Set(l)];
    // Sort the array in ascending order
    uniqueElements.sort((a, b) => a - b);
    return uniqueElements;
}","const assert = require('node:assert');


function test() {
  let candidate = unique;
  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);
}

test();"
HumanEval_35,tel_Telu,js,"/శ్రేణిలో గరిష్ట మూలకాన్ని తిరిగి ఇవ్వండి. // >>> max_element([1, 2, 3])
// 3
// >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// 123
function max_element(l){
","function max_element(l) {
    if (l.length === 0) return undefined; // Return undefined if the array is empty
    return Math.max(...l);
}","const assert = require('node:assert');


function test() {
  let candidate = max_element;
  assert.deepEqual(candidate([1, 2, 3]),3);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);
}

test();"
HumanEval_36,tel_Telu,js,"/11 లేదా 13తో విభజించదగిన n కంటే తక్కువ పూర్ణాంకాలలో 7 సంఖ్య ఎన్నిసార్లు కనిపిస్తుందో తిరిగి ఇవ్వండి. // >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
function fizz_buzz(n){
","function fizz_buzz(n) {
    let count = 0;
    
    for (let i = 1; i < n; i++) {
        if (i % 11 === 0 || i % 13 === 0) {
            let numStr = i.toString();
            for (let char of numStr) {
                if (char === '7') {
                    count++;
                }
            }
        }
    }
    
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = fizz_buzz;
  assert.deepEqual(candidate(50),0);
  assert.deepEqual(candidate(78),2);
  assert.deepEqual(candidate(79),3);
  assert.deepEqual(candidate(100),3);
  assert.deepEqual(candidate(200),6);
  assert.deepEqual(candidate(4000),192);
  assert.deepEqual(candidate(10000),639);
  assert.deepEqual(candidate(100000),8026);
}

test();"
HumanEval_37,tel_Telu,js,"/ l యొక్క జత సూచికల విలువలకు, కానీ క్రమబద్ధీకరించబడింది. / l' అనేది l తో సమానంగా ఉంటుంది, అయితే దాని విలువలు జత సూచికలలో సమానంగా ఉంటాయి./ఈ ఫంక్షన్ ఒక శ్రేణి l ను తీసుకుంటుంది మరియు ఒక శ్రేణి l' ను తిరిగి ఇస్తుంది// >>> sort_even([1, 2, 3])
// [1, 2, 3]
// >>> sort_even([5, 6, 3, 4])
// [3, 6, 5, 4]
function sort_even(l){
","function sort_even(l) {
    // Extract the elements at even indices
    let evenElements = [];
    for (let i = 0; i < l.length; i += 2) {
        evenElements.push(l[i]);
    }

    // Sort the even elements
    evenElements.sort((a, b) => a - b);

    // Reconstruct the array with sorted even indices
    let result = [];
    let evenIndex = 0;
    for (let i = 0; i < l.length; i++) {
        if (i % 2 === 0) {
            result.push(evenElements[evenIndex]);
            evenIndex++;
        } else {
            result.push(l[i]);
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_even;
  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

test();"
HumanEval_39,tel_Telu,js,"/prime_fib ఒక ఫిబోనాచి సంఖ్య మరియు అది కూడా ప్రైమ్ అని n వ సంఖ్యను తిరిగి ఇస్తుంది. // >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
function prime_fib(n){
","function prime_fib(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2; i * i <= num; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }
    
    function fibonacci() {
        let a = 0, b = 1;
        return function() {
            const next = a + b;
            a = b;
            b = next;
            return a;
        };
    }

    const fib = fibonacci();
    let count = 0;
    let primeFibNum;

    while (count < n) {
        const fibNum = fib();
        if (isPrime(fibNum)) {
            count++;
            primeFibNum = fibNum;
        }
    }

    return primeFibNum;
}","const assert = require('node:assert');


function test() {
  let candidate = prime_fib;
  assert.deepEqual(candidate(1),2);
  assert.deepEqual(candidate(2),3);
  assert.deepEqual(candidate(3),5);
  assert.deepEqual(candidate(4),13);
  assert.deepEqual(candidate(5),89);
  assert.deepEqual(candidate(6),233);
  assert.deepEqual(candidate(7),1597);
  assert.deepEqual(candidate(8),28657);
  assert.deepEqual(candidate(9),514229);
  assert.deepEqual(candidate(10),433494437);
}

test();"
HumanEval_40,tel_Telu,js,"/ సమ్ టు జీరో, మరియు ఫాల్స్ టు ఎల్./ అది శ్రేణిలో మూడు విభిన్న అంశాలు ఉంటే అది నిజమని తిరిగి ఇస్తుంది/triple_sum_to_zero పూర్ణాంకాల శ్రేణిని ఇన్పుట్గా తీసుకుంటుంది.// >>> triples_sum_to_zero([1, 3, 5, 0])
// false
// >>> triples_sum_to_zero([1, 3, -2, 1])
// true
// >>> triples_sum_to_zero([1, 2, 3, 7])
// false
// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
// true
// >>> triples_sum_to_zero([1])
// false
function triples_sum_to_zero(l){
","function triples_sum_to_zero(l) {
    // Sort the array first
    l.sort((a, b) => a - b);
    // Iterate through each element in the array
    for (let i = 0; i < l.length - 2; i++) {
        // Use two pointers to find the other two elements
        let left = i + 1;
        let right = l.length - 1;
        while (left < right) {
            const sum = l[i] + l[left] + l[right];
            if (sum === 0) {
                return true;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = triples_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, 5, -1]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),true);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([1, 2, 5, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([1, 3, 5, -100]),false);
  assert.deepEqual(candidate([100, 3, 5, -100]),false);
}

test();"
HumanEval_41,tel_Telu,js,"/ ఈ ఫంక్షన్ అటువంటి ఘర్షణల సంఖ్యను అవుట్పుట్ చేస్తుంది. / వారి పథంలో వారు కొల్లగొట్టారు లేదు వంటి. / అయితే, కార్లు అనంతంగా దృఢమైనవి మరియు బలంగా ఉంటాయి; ఫలితంగా, అవి కదులుతూనే ఉంటాయి / ఎడమ నుండి కుడికి కదిలే ఒక కారు కుడి నుండి ఎడమకు కదిలే ఒక కారును తాకినప్పుడు. / ప్రతి ఇతర. అన్ని కార్లు అదే వేగంతో తరలించడానికి. రెండు కార్లు ఢీకొన్న చెబుతారు / కుడి నుండి ఎడమకు డ్రైవింగ్ చేస్తున్నారు. రెండు జతల కార్లు చాలా దూరం నుండి ప్రారంభమవుతాయి / n కార్లు ఎడమ నుండి కుడికి డ్రైవింగ్ చేస్తున్నాయి; ఏకకాలంలో, n కార్లు వేరే సెట్ / ఒక రహదారి ఊహించుకోండి ఒక సంపూర్ణ నేరుగా అనంతంగా దీర్ఘ లైన్. function car_race_collision(n){
","function car_race_collision(n) {
    // Each car moving left to right will collide with each car moving right to left exactly once.
    // Therefore, the number of collisions is n * n.
    return n * n;
}","const assert = require('node:assert');


function test() {
  let candidate = car_race_collision;
  assert.deepEqual(candidate(2),4);
  assert.deepEqual(candidate(3),9);
  assert.deepEqual(candidate(4),16);
  assert.deepEqual(candidate(8),64);
  assert.deepEqual(candidate(10),100);
}

test();"
HumanEval_42,tel_Telu,js,"1 పెరిగిన అంశాలతో శ్రేణిని తిరిగి ఇవ్వండి.// >>> incr_list([1, 2, 3])
// [2, 3, 4]
// >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [6, 4, 6, 3, 4, 4, 10, 1, 124]
function incr_list(l){
","function incr_list(l) {
    return l.map(element => element + 1);
}","const assert = require('node:assert');


function test() {
  let candidate = incr_list;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);
  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

test();"
HumanEval_43,tel_Telu,js,"/ సమ్ టు జీరో, మరియు ఫాల్స్ టు ఎల్./ ఇది  అని శ్రేణిలో రెండు విభిన్న అంశాలు ఉంటే true తిరిగి వస్తుంది/pairs_sum_to_zero పూర్ణాంకాల శ్రేణిని ఇన్పుట్గా తీసుకుంటుంది.// >>> pairs_sum_to_zero([1, 3, 5, 0])
// false
// >>> pairs_sum_to_zero([1, 3, -2, 1])
// false
// >>> pairs_sum_to_zero([1, 2, 3, 7])
// false
// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
// true
// >>> pairs_sum_to_zero([1])
// false
function pairs_sum_to_zero(l){
","function pairs_sum_to_zero(l) {
    const seen = new Set();
    
    for (const num of l) {
        if (seen.has(-num)) {
            return true;
        }
        seen.add(num);
    }
    
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = pairs_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),false);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);
}

test();"
HumanEval_44,tel_Telu,js,"/ బేస్ సంఖ్యలు 10 కన్నా తక్కువ. / మార్పిడి తర్వాత స్ట్రింగ్ ప్రాతినిధ్యం తిరిగి. /ఇన్పుట్ సంఖ్య x యొక్క సంఖ్యా బేస్ ను బేస్ కు మార్చండి. // >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
function change_base(x, base){
","function change_base(x, base) {
    if (base < 2 || base > 9) {
        throw new Error(""Base must be between 2 and 9."");
    }

    if (x === 0) {
        return ""0"";
    }

    let result = '';
    while (x > 0) {
        result = (x % base) + result;
        x = Math.floor(x / base);
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = change_base;
  assert.deepEqual(candidate(8, 3),""22"");
  assert.deepEqual(candidate(9, 3),""100"");
  assert.deepEqual(candidate(234, 2),""11101010"");
  assert.deepEqual(candidate(16, 2),""10000"");
  assert.deepEqual(candidate(8, 2),""1000"");
  assert.deepEqual(candidate(7, 2),""111"");
  assert.deepEqual(candidate(2, 3),""2"");
  assert.deepEqual(candidate(3, 4),""3"");
  assert.deepEqual(candidate(4, 5),""4"");
  assert.deepEqual(candidate(5, 6),""5"");
  assert.deepEqual(candidate(6, 7),""6"");
  assert.deepEqual(candidate(7, 8),""7"");
}

test();"
HumanEval_45,tel_Telu,js,"/ ఒక త్రిభుజం కోసం ఒక వైపు మరియు అధిక తిరిగి ప్రాంతం యొక్క పొడవు ఇచ్చిన. // >>> triangle_area(5, 3)
// 7.5
function triangle_area(a, h){
","function triangle_area(a, h) {
    return 0.5 * a * h;
}","const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(5, 3),7.5);
  assert.deepEqual(candidate(2, 2),2.0);
  assert.deepEqual(candidate(10, 8),40.0);
}

test();"
HumanEval_46,tel_Telu,js,"/ దయచేసి fib4 సంఖ్యల శ్రేణి యొక్క n-వ మూలకాన్ని సమర్థవంతంగా లెక్కించడానికి ఒక ఫంక్షన్ను వ్రాయండి. పునరావృతతను ఉపయోగించవద్దు. / fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). / fib4(3) -> 0 / fib4(2) -> 2 / fib4(1) -> 0 / fib4(0) -> 0 /Fib4 సంఖ్యల వరుస అనేది ఫిబోనాచి వరుసకు సమానమైన వరుస, ఇది ఈ క్రింది విధంగా నిర్వచించబడింది: // >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
function fib4(n){
","function fib4(n) {
    if (n === 0) return 0;
    if (n === 1) return 0;
    if (n === 2) return 2;
    if (n === 3) return 0;
    
    let fibs = [0, 0, 2, 0];
    
    for (let i = 4; i <= n; i++) {
        let nextFib = fibs[0] + fibs[1] + fibs[2] + fibs[3];
        fibs.shift(); // Remove the first element
        fibs.push(nextFib); // Add the new element to the end
    }
    
    return fibs[3];
}","const assert = require('node:assert');


function test() {
  let candidate = fib4;
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),28);
  assert.deepEqual(candidate(10),104);
  assert.deepEqual(candidate(12),386);
}

test();"
HumanEval_47,tel_Telu,js,"/మార్పు శ్రేణిలోని మూలకాల మధ్యస్థం l. // >>> median([3, 1, 2, 4, 5])
// 3
// >>> median([-10, 4, 6, 1000, 10, 20])
// 15.0
function median(l){
","function median(l) {
    // First, sort the array
    l.sort((a, b) => a - b);

    // Calculate the middle index
    const mid = Math.floor(l.length / 2);

    // If array length is odd, return the middle element
    if (l.length % 2 !== 0) {
        return l[mid];
    }
    // If array length is even, return the average of the two middle elements
    else {
        return (l[mid - 1] + l[mid]) / 2;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = median;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);
  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);
  assert.deepEqual(candidate([5]),5);
  assert.deepEqual(candidate([6, 5]),5.5);
  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);
}

test();"
HumanEval_48,tel_Telu,js,"ఇచ్చిన స్ట్రింగ్ ఒక పాలిండ్రోమ్ కాదా అని తనిఖీ చేస్తుంది.// >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
function is_palindrome(text){
","function is_palindrome(text){
    // Remove non-alphanumeric characters and convert to lower case
    const cleanedText = text.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    // Reverse the cleaned text
    const reversedText = cleanedText.split('').reverse().join('');
    // Check if the cleaned text is equal to its reverse
    return cleanedText === reversedText;
}","const assert = require('node:assert');


function test() {
  let candidate = is_palindrome;
  assert.deepEqual(candidate(""""),true);
  assert.deepEqual(candidate(""aba""),true);
  assert.deepEqual(candidate(""aaaaa""),true);
  assert.deepEqual(candidate(""zbcd""),false);
  assert.deepEqual(candidate(""xywyx""),true);
  assert.deepEqual(candidate(""xywyz""),false);
  assert.deepEqual(candidate(""xywzx""),false);
}

test();"
HumanEval_49,tel_Telu,js,"/ 2^n మాడ్యూల్ p ను తిరిగి ఇవ్వండి (సంఖ్యల గురించి తెలుసుకోండి).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
function modp(n, p){
","function modp(n, p) {
    if (p === 1) return 0; // Base case when p is 1

    // Initialize result
    let result = 1;
    let base = 2;

    while (n > 0) {
        // If n is odd, multiply base with result
        if (n % 2 === 1) {
            result = (result * base) % p;
        }

        // n must be even now
        n = Math.floor(n / 2);
        base = (base * base) % p; 
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = modp;
  assert.deepEqual(candidate(3, 5),3);
  assert.deepEqual(candidate(1101, 101),2);
  assert.deepEqual(candidate(0, 101),1);
  assert.deepEqual(candidate(3, 11),8);
  assert.deepEqual(candidate(100, 101),1);
  assert.deepEqual(candidate(30, 5),4);
  assert.deepEqual(candidate(31, 5),3);
}

test();"
HumanEval_51,tel_Telu,js,"/remove_vowels అనేది స్ట్రింగ్ తీసుకుని, అచ్చులు లేని స్ట్రింగ్ను తిరిగి ఇచ్చే ఫంక్షన్.// >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
function remove_vowels(text){
","function remove_vowels(text) {
    return text.replace(/[aeiouAEIOU]/g, '');
}","const assert = require('node:assert');


function test() {
  let candidate = remove_vowels;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""abcdef
ghijklm""),""bcdf
ghjklm"");
  assert.deepEqual(candidate(""fedcba""),""fdcb"");
  assert.deepEqual(candidate(""eeeee""),"""");
  assert.deepEqual(candidate(""acBAA""),""cB"");
  assert.deepEqual(candidate(""EcBOO""),""cB"");
  assert.deepEqual(candidate(""ybcd""),""ybcd"");
}

test();"
HumanEval_52,tel_Telu,js,"/మార్చు true శ్రేణిలోని అన్ని సంఖ్యలు l పరిమితి t కంటే తక్కువగా ఉంటే. // >>> below_threshold([1, 2, 4, 10], 100)
// true
// >>> below_threshold([1, 20, 4, 10], 5)
// false
function below_threshold(l, t){
","function below_threshold(l, t) {
    return l.every(num => num < t);
}","const assert = require('node:assert');


function test() {
  let candidate = below_threshold;
  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);
  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);
}

test();"
HumanEval_53,tel_Telu,js,"x మరియు y అనే రెండు సంఖ్యలను జోడించండి.// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
function add(x, y){
","function add(x, y) {
    return x + y;
}","const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate(0, 1),1);
  assert.deepEqual(candidate(1, 0),1);
  assert.deepEqual(candidate(2, 3),5);
  assert.deepEqual(candidate(5, 7),12);
  assert.deepEqual(candidate(7, 5),12);
}

test();"
HumanEval_54,tel_Telu,js,"/రెండు పదాలు ఒకే అక్షరాలను కలిగి ఉన్నాయో లేదో తనిఖీ చేయండి. // >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
function same_chars(s0, s1){
","function same_chars(s0, s1) {
    const charSet0 = new Set(s0);
    const charSet1 = new Set(s1);

    if (charSet0.size !== charSet1.size) return false;

    for (let char of charSet0) {
        if (!charSet1.has(char)) return false;
    }

    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = same_chars;
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""),true);
  assert.deepEqual(candidate(""abcd"", ""dddddddabc""),true);
  assert.deepEqual(candidate(""dddddddabc"", ""abcd""),true);
  assert.deepEqual(candidate(""eabcd"", ""dddddddabc""),false);
  assert.deepEqual(candidate(""abcd"", ""dddddddabcf""),false);
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""),false);
  assert.deepEqual(candidate(""aabb"", ""aaccc""),false);
}

test();"
HumanEval_55,tel_Telu,js,"/n-వ ఫిబోనాచి సంఖ్యను తిరిగి ఇవ్వండి. // >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
function fib(n){
","function fib(n) {
    if (n <= 1) return n;
    let a = 0, b = 1, result = 1;
    for (let i = 2; i <= n; i++) {
        result = a + b;
        a = b;
        b = result;
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = fib;
  assert.deepEqual(candidate(10),55);
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(8),21);
  assert.deepEqual(candidate(11),89);
  assert.deepEqual(candidate(12),144);
}

test();"
HumanEval_56,tel_Telu,js,"/ ప్రతి ప్రారంభ బ్రాకెట్కు సంబంధిత మూసివేత బ్రాకెట్ ఉంటే true తిరిగి ఇవ్వబడుతుంది. / బ్రాకెట్స్ అనేది ""<"" మరియు "">"" యొక్క స్ట్రింగ్.// >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
function correct_bracketing(brackets){
","function correct_bracketing(brackets) {
    let balance = 0;
    for (let char of brackets) {
        if (char === '<') {
            balance += 1;
        } else if (char === '>') {
            balance -= 1;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""<>""),true);
  assert.deepEqual(candidate(""<<><>>""),true);
  assert.deepEqual(candidate(""<><><<><>><>""),true);
  assert.deepEqual(candidate(""<><><<<><><>><>><<><><<>>>""),true);
  assert.deepEqual(candidate(""<<<><>>>>""),false);
  assert.deepEqual(candidate(""><<>""),false);
  assert.deepEqual(candidate(""<""),false);
  assert.deepEqual(candidate(""<<<<""),false);
  assert.deepEqual(candidate("">""),false);
  assert.deepEqual(candidate(""<<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>><<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>>><>""),false);
}

test();"
HumanEval_57,tel_Telu,js,"/ true తిరిగి ఇవ్వడం అనేది శ్రేణి అంశాలు ఏకరీతిగా పెరుగుతున్నాయి లేదా తగ్గుతున్నాయి.// >>> monotonic([1, 2, 4, 20])
// true
// >>> monotonic([1, 20, 4, 10])
// false
// >>> monotonic([4, 1, 0, -10])
// true
function monotonic(l){
","function monotonic(l) {
    if (l.length <= 1) return true;
    let isIncreasing = true;
    let isDecreasing = true;
    
    for (let i = 1; i < l.length; i++) {
        if (l[i] > l[i - 1]) {
            isDecreasing = false;
        } else if (l[i] < l[i - 1]) {
            isIncreasing = false;
        }
        
        if (!isIncreasing && !isDecreasing) return false;
    }
    
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = monotonic;
  assert.deepEqual(candidate([1, 2, 4, 10]),true);
  assert.deepEqual(candidate([1, 2, 4, 20]),true);
  assert.deepEqual(candidate([1, 20, 4, 10]),false);
  assert.deepEqual(candidate([4, 1, 0, -10]),true);
  assert.deepEqual(candidate([4, 1, 1, 0]),true);
  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);
  assert.deepEqual(candidate([9, 9, 9, 9]),true);
}

test();"
HumanEval_58,tel_Telu,js,"/రెండు శ్రేణుల కోసం క్రమబద్ధీకరించిన ఏకైక సాధారణ అంశాలను తిరిగి ఇవ్వండి. // >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
// [1, 5, 653]
// >>> common([5, 3, 2, 8], [3, 2])
// [2, 3]
function common(l1, l2){
","function common(l1, l2) {
    const set1 = new Set(l1);
    const set2 = new Set(l2);
    const result = [...set1].filter(item => set2.has(item));
    return result.sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = common;
  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);
  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);
  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);
}

test();"
HumanEval_59,tel_Telu,js,"/n యొక్క అతిపెద్ద ప్రైమ్ ఫాక్టర్ ను తిరిగి ఇవ్వండి. n > 1 అని భావించండి మరియు ప్రైమ్ కాదు. // >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
function largest_prime_factor(n){
","function largest_prime_factor(n) {
  let largest = -1;
  while (n % 2 === 0) {
    largest = 2;
    n /= 2;
  }
  
  for (let factor = 3; factor * factor <= n; factor += 2) {
    while (n % factor === 0) {
      largest = factor;
      n /= factor;
    }
  }
  
  if (n > 2) {
    largest = n;
  }
  
  return largest;
}","const assert = require('node:assert');


function test() {
  let candidate = largest_prime_factor;
  assert.deepEqual(candidate(15),5);
  assert.deepEqual(candidate(27),3);
  assert.deepEqual(candidate(63),7);
  assert.deepEqual(candidate(330),11);
  assert.deepEqual(candidate(13195),29);
}

test();"
HumanEval_60,tel_Telu,js,"/sum_to_n అనేది 1 నుండి n వరకు సంఖ్యలను సంకలనం చేసే ఫంక్షన్.// >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
function sum_to_n(n){
","function sum_to_n(n) {
    return n * (n + 1) / 2;
}","const assert = require('node:assert');


function test() {
  let candidate = sum_to_n;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(6),21);
  assert.deepEqual(candidate(11),66);
  assert.deepEqual(candidate(30),465);
  assert.deepEqual(candidate(100),5050);
}

test();"
HumanEval_61,tel_Telu,js,"/ ప్రతి ప్రారంభ బ్రాకెట్కు సంబంధిత మూసివేత బ్రాకెట్ ఉంటే true తిరిగి ఇవ్వబడుతుంది. / బ్రాకెట్స్ అనేది ""("" మరియు """") లను కలిగి ఉన్న స్ట్రింగ్.// >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
function correct_bracketing(brackets){
","function correct_bracketing(brackets) {
    let balance = 0;
    for (let i = 0; i < brackets.length; i++) {
        if (brackets[i] === '(') {
            balance++;
        } else if (brackets[i] === ')') {
            balance--;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""()""),true);
  assert.deepEqual(candidate(""(()())""),true);
  assert.deepEqual(candidate(""()()(()())()""),true);
  assert.deepEqual(candidate(""()()((()()())())(()()(()))""),true);
  assert.deepEqual(candidate(""((()())))""),false);
  assert.deepEqual(candidate("")(()""),false);
  assert.deepEqual(candidate(""(""),false);
  assert.deepEqual(candidate(""((((""),false);
  assert.deepEqual(candidate("")""),false);
  assert.deepEqual(candidate(""(()""),false);
  assert.deepEqual(candidate(""()()(()())())(()""),false);
  assert.deepEqual(candidate(""()()(()())()))()""),false);
}

test();"
HumanEval_62,tel_Telu,js,"/ ఈ బహుపదము యొక్క ఉత్పన్నమును అదే రూపములో తిరిగి ఇవ్వండి. / xs[0] + xs[1] * x + xs[2] * x^2 + .... /xs ఒక బహుపదానికి గుణకాలు.// >>> derivative([3, 1, 2, 4, 5])
// [1, 4, 12, 20]
// >>> derivative([1, 2, 3])
// [2, 6]
function derivative(xs){
","function derivative(xs) {
    const result = [];
    for (let i = 1; i < xs.length; i++) {
        result.push(xs[i] * i);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = derivative;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);
  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);
  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);
  assert.deepEqual(candidate([1]),[]);
}

test();"
HumanEval_63,tel_Telu,js,"/ దయచేసి fibfib సంఖ్యల వరుస యొక్క n-వ మూలకాన్ని సమర్థవంతంగా లెక్కించడానికి ఒక ఫంక్షన్ను వ్రాయండి. / ఫైబ్రిడ్ (n) == ఫైబ్రిడ్ (n-1) + ఫైబ్రిడ్ (n-2) + ఫైబ్రిడ్ (n-3)/ fib fib ((2) == 1 / fib fib ((1) == 0 / fib fib ((0) == 0 /FibFib సంఖ్యల వరుస అనేది ఫిబొనాచి వరుసకు సమానమైన వరుస, ఇది ఈ క్రింది విధంగా నిర్వచించబడిందిః // >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
function fibfib(n){
","function fibfib(n) {
    if (n === 0 || n === 1) return 0;
    if (n === 2) return 1;
    
    let a = 0, b = 0, c = 1, d;

    for (let i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    
    return c;
}","const assert = require('node:assert');


function test() {
  let candidate = fibfib;
  assert.deepEqual(candidate(2),1);
  assert.deepEqual(candidate(1),0);
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),24);
  assert.deepEqual(candidate(10),81);
  assert.deepEqual(candidate(12),274);
  assert.deepEqual(candidate(14),927);
}

test();"
HumanEval_64,tel_Telu,js,"/ ఉదాహరణ: / అచ్చు, కానీ అది ఇచ్చిన పదం చివరిలో ఉన్నప్పుడు మాత్రమే.ఈ సందర్భంలో అచ్చులు 'a', 'e', 'i', 'o', 'u'. ఇక్కడ, 'y' కూడా ఒక / ఒక పదం ఇన్పుట్ మరియు స్ట్రింగ్ లో అచ్చుల సంఖ్యను తిరిగి. /ఒక ఫంక్షన్ వ్రాయండి vowels_count ఇది ని సూచించే స్ట్రింగ్ తీసుకుంటుంది// >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
function vowels_count(s){
","function vowels_count(s) {
    const vowels = 'aeiou';
    let count = 0;
    s = s.toLowerCase();
    
    for (let i = 0; i < s.length; i++) {
        if (vowels.includes(s[i]) || (i === s.length - 1 && s[i] === 'y')) {
            count++;
        }
    }

    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = vowels_count;
  assert.deepEqual(candidate(""abcde""),2);
  assert.deepEqual(candidate(""Alone""),3);
  assert.deepEqual(candidate(""key""),2);
  assert.deepEqual(candidate(""bye""),1);
  assert.deepEqual(candidate(""keY""),2);
  assert.deepEqual(candidate(""bYe""),1);
  assert.deepEqual(candidate(""ACEDY""),3);
}

test();"
HumanEval_65,tel_Telu,js,"/ shift > సంఖ్యల సంఖ్య ఉంటే, తిరిగి అంకెలు తిరగబడతాయి. / మరియు ఫలితాన్ని స్ట్రింగ్గా తిరిగి ఇవ్వండి. / వృత్తాకారము x పూర్ణాంకం యొక్క అంకెలను తరలించు, కుడివైపున ఉన్న అంకెలను తరలించు // >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
function circular_shift(x, shift){
","function circular_shift(x, shift) {
    let numStr = x.toString();
    let length = numStr.length;

    if (shift > length) {
        return numStr.split('').reverse().join('');
    } else {
        let endPart = numStr.slice(-shift);
        let startPart = numStr.slice(0, length - shift);
        return endPart + startPart;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = circular_shift;
  assert.deepEqual(candidate(100, 2),""001"");
  assert.deepEqual(candidate(12, 2),""12"");
  assert.deepEqual(candidate(97, 8),""79"");
  assert.deepEqual(candidate(12, 1),""21"");
  assert.deepEqual(candidate(11, 101),""11"");
}

test();"
HumanEval_66,tel_Telu,js,"/ ఉదాహరణలు: / ASCII సంకేతాలు / ఒక స్ట్రింగ్ ను ఇన్పుట్ గా తీసుకుని, ఎగువ అక్షరాల మొత్తాన్ని మాత్రమే తిరిగి ఇచ్చే ఫంక్షన్ను వ్రాయండి' /పని // >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
function digitSum(s){
","function digitSum(s) {
    let sum = 0;
    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (char >= 'A' && char <= 'Z') {
            sum += char.charCodeAt(0);
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = digitSum;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abAB""),131);
  assert.deepEqual(candidate(""abcCd""),67);
  assert.deepEqual(candidate(""helloE""),69);
  assert.deepEqual(candidate(""woArBld""),131);
  assert.deepEqual(candidate(""aAaaaXa""),153);
  assert.deepEqual(candidate("" How are yOu?""),151);
  assert.deepEqual(candidate(""You arE Very Smart""),327);
}

test();"
HumanEval_67,tel_Telu,js,"/ ఎక్సాంబల్ కోసం: / బుట్టలో బుట్టలో మామిడి పండ్ల సంఖ్యను తిరిగి ఇవ్వండి. / నారింజలు మరియు ఆపిల్స్ మరియు పండ్ల మొత్తం సంఖ్యను సూచించే పూర్ణాంకం / ఆపిల్, నారింజ, మరియు మామిడి పండ్లు. మొత్తం సంఖ్యను సూచించే స్ట్రింగ్ ఇచ్చిన / ఈ పండ్ల బుట్టలో ఈ బుట్టలో ఉన్న పండ్ల బుట్టలో పంపిణీ చేయబడతాయి ఈ పనిలో, మీకు ఆపిల్ మరియు ఆరెంజ్ ల సంఖ్యను సూచించే స్ట్రింగ్ ఇవ్వబడుతుంది.// >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
function fruit_distribution(s, n){
","function fruit_distribution(s, n) {
    let apples = 0;
    let oranges = 0;
    
    // Regular expressions to extract the number of apples and oranges from the string
    const applesMatch = s.match(/(\d+)\s*apples/);
    const orangesMatch = s.match(/(\d+)\s*oranges/);
    
    // If a match is found, parse the number
    if (applesMatch) {
        apples = parseInt(applesMatch[1], 10);
    }
    if (orangesMatch) {
        oranges = parseInt(orangesMatch[1], 10);
    }
    
    // Calculate the number of mangoes
    const mangoes = n - (apples + oranges);
    return mangoes;
}","const assert = require('node:assert');


function test() {
  let candidate = fruit_distribution;
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 19),8);
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 21),10);
  assert.deepEqual(candidate(""0 apples and 1 oranges"", 3),2);
  assert.deepEqual(candidate(""1 apples and 0 oranges"", 3),2);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 100),95);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 5),0);
  assert.deepEqual(candidate(""1 apples and 100 oranges"", 120),19);
}

test();"
HumanEval_68,tel_Telu,js,"/ ఉదాహరణ 1: / జత విలువలు లేకపోతే లేదా ఇచ్చిన శ్రేణి ఖాళీగా ఉంటే, తిరిగి []. / పిక్ నోడ్ ఒక శ్రేణిలో తిరిగి రావాలి, [ smalest_value, దాని సూచిక ], / ఒకే చిన్న జత విలువ కలిగిన బహుళ నోడ్లు కనుగొనబడితే అతి చిన్న సూచిక కలిగిన నోడ్ను తిరిగి ఇవ్వండి. / పిక్డ్ నోడ్ అతి చిన్న జత విలువ కలిగిన నోడ్ అయి ఉండాలి. / మీ పని నోడ్స్ ఒకటి pluck మరియు అది తిరిగి ఉంది. /""కాని ప్రతికూల పూర్ణాంక నోడ్స్ కలిగిన చెట్టు యొక్క శాఖను సూచించే శ్రేణిని ఇచ్చినట్లయితే // >>> pluck([4, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([1, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([])
// []
// Example 4:
// >>> pluck([5, 0, 3, 0, 4, 2])
// [0, 1]
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
function pluck(arr){
","function pluck(arr) {
    let smallestEvenValue = Infinity;
    let smallestEvenIndex = -1;

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) {
            if (arr[i] < smallestEvenValue) {
                smallestEvenValue = arr[i];
                smallestEvenIndex = i;
            }
        }
    }

    return smallestEvenIndex === -1 ? [] : [smallestEvenValue, smallestEvenIndex];
}","const assert = require('node:assert');


function test() {
  let candidate = pluck;
  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);
  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);
  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);
  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);
  assert.deepEqual(candidate([7, 9, 7, 1]),[]);
}

test();"
HumanEval_69,tel_Telu,js,"/ ఉదాహరణలు: / అటువంటి విలువ లేకపోతే, -1 ను తిరిగి ఇవ్వండి. / పూర్ణాంకం యొక్క ఫ్రీక్వెన్సీ అనేది శ్రేణిలో కనిపించే సార్లు సంఖ్య. / సున్నా, మరియు పూర్ణాంకం యొక్క విలువ కంటే ఎక్కువ లేదా సమానమైన పౌన frequency పున్యం కలిగి ఉంటుంది.మీకు సానుకూల పూర్ణాంకాల యొక్క ఖాళీ కాని శ్రేణి ఇవ్వబడింది.  కంటే పెద్దదిగా ఉన్న అతిపెద్ద పూర్ణాంకాన్ని తిరిగి ఇవ్వండి.// >>> search([4, 1, 2, 2, 3, 1])
// 2
// >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])
// 3
// >>> search([5, 5, 4, 4, 4])
// -1
function search(lst){
","function search(lst) {
    const frequencyMap = new Map();

    lst.forEach(num => {
        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
    });

    let result = -1;

    frequencyMap.forEach((count, num) => {
        if (count >= num && num > 0 && num > result) {
            result = num;
        }
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = search;
  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);
  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);
  assert.deepEqual(candidate([3, 3]),-1);
  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);
  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);
  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);
  assert.deepEqual(candidate([3, 2, 8, 2]),2);
  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);
  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);
  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);
  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);
  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);
  assert.deepEqual(candidate([1]),1);
  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);
  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);
  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);
  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);
  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);
  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);
  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);
  assert.deepEqual(candidate([10]),-1);
  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);
  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);
  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);
  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);
}

test();"
HumanEval_70,tel_Telu,js,"/ ఉదాహరణలు: / అప్పుడు మిగిలిన పూర్ణాంకాల గరిష్ట, అప్పుడు కనీస మరియు అందువలన న. / వింత సార్టింగ్, మీరు కనీస విలువ ప్రారంభించినప్పుడు, /ఇంటర్జైర్స్ యొక్క శ్రేణి ఇచ్చిన, వింత క్రమంలో శ్రేణి తిరిగి. // >>> strange_sort_list([1, 2, 3, 4])
// [1, 4, 2, 3]
// >>> strange_sort_list([5, 5, 5, 5])
// [5, 5, 5, 5]
// >>> strange_sort_list([])
// []
function strange_sort_list(lst){
","function strange_sort_list(lst) {
    let result = [];
    lst.sort((a, b) => a - b); // Sort the array in ascending order

    while (lst.length) {
        result.push(lst.shift()); // Add the minimum element
        if (lst.length) {
            result.push(lst.pop()); // Add the maximum element
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = strange_sort_list;
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);
  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);
  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);
  assert.deepEqual(candidate([111111]),[111111]);
}

test();"
HumanEval_71,tel_Telu,js,"/ ఉదాహరణ: / మూడవ వైపు కంటే. / మూడు వైపులా ఒక చెల్లుబాటు అయ్యే త్రిభుజం తయారు చేసినప్పుడు ఏ రెండు వైపులా మొత్తం ఎక్కువ ./ లేకపోతే తిరిగి -1 / మూడు వైపులా ఒక చెల్లుబాటు అయ్యే త్రిభుజం ఏర్పరుస్తాయి ఉంటే త్రిభుజం 2 దశాంశ బిందువులకు గుండ్రంగా. ఒక త్రిభుజం యొక్క మూడు వైపుల పొడవులు ఇచ్చినట్లయితే,  యొక్క ప్రాంతాన్ని తిరిగి ఇవ్వండి.// >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
function triangle_area(a, b, c){
","function triangle_area(a, b, c) {
    // Check if the sides form a valid triangle
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area
        const s = (a + b + c) / 2;
        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        // Return the area rounded to 2 decimal places
        return Math.round(area * 100) / 100;
    } else {
        // Return -1 for an invalid triangle
        return -1;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(3, 4, 5),6.0);
  assert.deepEqual(candidate(1, 2, 10),-1);
  assert.deepEqual(candidate(4, 8, 5),8.18);
  assert.deepEqual(candidate(2, 2, 2),1.73);
  assert.deepEqual(candidate(1, 2, 3),-1);
  assert.deepEqual(candidate(10, 5, 7),16.25);
  assert.deepEqual(candidate(2, 6, 3),-1);
  assert.deepEqual(candidate(1, 1, 1),0.43);
  assert.deepEqual(candidate(2, 2, 10),-1);
}

test();"
HumanEval_72,tel_Telu,js,"/ ఉదాహరణ: / వస్తువు q అది సమతుల్యమైతే ఎగురుతుంది (ఇది ఒక పాలిండ్రోమిక్ శ్రేణి) మరియు దాని మూలకాల మొత్తం గరిష్ట సాధ్యమైన బరువు w కంటే తక్కువగా లేదా సమానంగా ఉంటుంది. /ఒక ఫంక్షన్ వ్రాయండి, అది వస్తువు q ఎగురుతుంది, మరియు తప్పు లేకపోతే నిజమైన తిరిగి. // >>> will_it_fly([1, 2], 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([3, 2, 3], 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([3, 2, 3], 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([3], 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
function will_it_fly(q, w){
","function will_it_fly(q, w) {
    // Check if q is a palindromic array
    function isPalindromic(arr) {
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] !== arr[arr.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }

    // Calculate the sum of the array
    function sumArray(arr) {
        return arr.reduce((acc, val) => acc + val, 0);
    }

    // Check if the array is balanced and the sum is within the limit
    return isPalindromic(q) && sumArray(q) <= w;
}","const assert = require('node:assert');


function test() {
  let candidate = will_it_fly;
  assert.deepEqual(candidate([3, 2, 3], 9),true);
  assert.deepEqual(candidate([1, 2], 5),false);
  assert.deepEqual(candidate([3], 5),true);
  assert.deepEqual(candidate([3, 2, 3], 1),false);
  assert.deepEqual(candidate([1, 2, 3], 6),false);
  assert.deepEqual(candidate([5], 5),true);
}

test();"
HumanEval_73,tel_Telu,js,"/ ఉదాహరణకి: / ను ముందు మరియు వెనుకకు ఒకే విధంగా చదవవచ్చు. ఒక మార్పులో, మీరు ఒక మూలకాన్ని ఏదైనా ఇతర మూలకానికి మార్చవచ్చు./ మార్చాలి. శ్రేణిని పాలిండ్రోమిక్ చేయడానికి. పాలిండ్రోమిక్ శ్రేణి అనేది ఒక శ్రేణి, ఇది / పూర్ణాంకాల యొక్క arr శ్రేణిని ఇచ్చినట్లయితే, // >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])
// 4
// >>> smallest_change([1, 2, 3, 4, 3, 2, 2])
// 1
// >>> smallest_change([1, 2, 3, 2, 1])
// 0
function smallest_change(arr){
","function smallest_change(arr) {
    let changes = 0;
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        if (arr[left] !== arr[right]) {
            changes++;
        }
        left++;
        right--;
    }

    return changes;
}","const assert = require('node:assert');


function test() {
  let candidate = smallest_change;
  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);
  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);
  assert.deepEqual(candidate([1, 4, 2]),1);
  assert.deepEqual(candidate([1, 4, 4, 2]),1);
  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);
  assert.deepEqual(candidate([3, 1, 1, 3]),0);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([0, 1]),1);
}

test();"
HumanEval_74,tel_Telu,js,"/ ఉదాహరణలు / రెండు శ్రేణులు ఒకే సంఖ్యలో చార్స్ కలిగి ఉంటే, మొదటి శ్రేణిని తిరిగి ఇవ్వండి. / ఇతర శ్రేణి కంటే శ్రేణి యొక్క అన్ని తీగలలోని మొత్తం అక్షరాల సంఖ్య తక్కువ. / రెండు స్ట్రింగ్స్ యొక్క శ్రేణులను అంగీకరిస్తుంది మరియు కలిగి ఉన్న శ్రేణిని తిరిగి ఇచ్చే ఫంక్షన్ను వ్రాయండి // >>> total_match([], [])
// []
// >>> total_match([""hi"", ""admin""], [""hI"", ""Hi""])
// [""hI"", ""Hi""]
// >>> total_match([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
// [""hi"", ""admin""]
// >>> total_match([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
// [""hI"", ""hi"", ""hi""]
// >>> total_match([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
// [""4""]
function total_match(lst1, lst2){
","function total_match(lst1, lst2) {
    // Helper function to calculate total characters in an array of strings
    const totalChars = (arr) => arr.reduce((sum, str) => sum + str.length, 0);

    const total1 = totalChars(lst1);
    const total2 = totalChars(lst2);

    if (total1 < total2) {
        return lst1;
    } else {
        return lst2;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = total_match;
  assert.deepEqual(candidate([], []),[]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi""]),[""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]),[""4""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""Hi""]),[""hI"", ""Hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]),[""hI"", ""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([], [""this""]),[]);
  assert.deepEqual(candidate([""this""], []),[]);
}

test();"
HumanEval_75,tel_Telu,js,"/ ఉదాహరణ: / (a) 100 కన్నా తక్కువ అని తెలుసుకోవడం. / మరియు అబద్ధం లేకపోతే. /ఇచ్చిన సంఖ్య 3 ప్రైమ్ సంఖ్యల గుణకారం అయితే true తిరిగి ఇచ్చే ఫంక్షన్ను వ్రాయండి // >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
function is_multiply_prime(a){
","function is_prime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}

function generate_primes(upper_limit) {
    const primes = [];
    for (let num = 2; num < upper_limit; num++) {
        if (is_prime(num)) {
            primes.push(num);
        }
    }
    return primes;
}

function is_multiply_prime(a) {
    if (a < 2) return false;
    const primes = generate_primes(100);
    const primesLength = primes.length;

    for (let i = 0; i < primesLength; i++) {
        for (let j = i; j < primesLength; j++) {
            for (let k = j; k < primesLength; k++) {
                if (primes[i] * primes[j] * primes[k] === a) {
                    return true;
                }
            }
        }
    }

    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = is_multiply_prime;
  assert.deepEqual(candidate(5),false);
  assert.deepEqual(candidate(30),true);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),false);
  assert.deepEqual(candidate(125),true);
  assert.deepEqual(candidate(105),true);
  assert.deepEqual(candidate(126),false);
  assert.deepEqual(candidate(729),false);
  assert.deepEqual(candidate(891),false);
  assert.deepEqual(candidate(1001),true);
}

test();"
HumanEval_76,tel_Telu,js,"/ ఉదాహరణకి: / x అనేది n యొక్క ఒక సాధారణ శక్తి, n**int=x  అయితే/ n యొక్క శక్తి మరియు ఇతర సందర్భాలలో తప్పు. /మీ పని ఒక సంఖ్య x ఒక సాధారణ ఉంటే నిజమైన తిరిగి ఒక ఫంక్షన్ రాయడానికి ఉంది // >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
function is_simple_power(x, n){
","function is_simple_power(x, n) {
    if (x === 1) return true;  // Any number to the power of zero is 1
    if (n <= 1) return false;  // n must be greater than 1 to have simple powers other than itself

    let power = n;
    while (power < x) {
        power *= n;
    }

    return power === x;
}","const assert = require('node:assert');


function test() {
  let candidate = is_simple_power;
  assert.deepEqual(candidate(16, 2),true);
  assert.deepEqual(candidate(143214, 16),false);
  assert.deepEqual(candidate(4, 2),true);
  assert.deepEqual(candidate(9, 3),true);
  assert.deepEqual(candidate(16, 4),true);
  assert.deepEqual(candidate(24, 2),false);
  assert.deepEqual(candidate(128, 4),false);
  assert.deepEqual(candidate(12, 6),false);
  assert.deepEqual(candidate(1, 1),true);
  assert.deepEqual(candidate(1, 12),true);
}

test();"
HumanEval_77,tel_Telu,js,"/ ఉదాహరణలు: / గమనిక: మీరు ఎంట్రీ ఎల్లప్పుడూ చెల్లుబాటు అయ్యే అని అనుకోవచ్చు. / ఈ ingeger కొన్ని పూర్ణాంకం సంఖ్య యొక్క ఒక ఘనము ఉంటే. / ఒక పూర్ణాంక a ను తీసుకుని true ను తిరిగి ఇచ్చే ఫంక్షన్ను వ్రాయండి // >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
function iscube(a){
","function iscube(a) {
    if (a < 0) a = -a;
    let cubeRoot = Math.round(Math.pow(a, 1/3));
    return cubeRoot * cubeRoot * cubeRoot === a;
}","const assert = require('node:assert');


function test() {
  let candidate = iscube;
  assert.deepEqual(candidate(1),true);
  assert.deepEqual(candidate(2),false);
  assert.deepEqual(candidate(-1),true);
  assert.deepEqual(candidate(64),true);
  assert.deepEqual(candidate(180),false);
  assert.deepEqual(candidate(1000),true);
  assert.deepEqual(candidate(0),true);
  assert.deepEqual(candidate(1729),false);
}

test();"
HumanEval_78,tel_Telu,js,"/ ఉదాహరణలు: / మరియు చిహ్నాలు A, B, C, D, E, F ఎల్లప్పుడూ పెద్ద అక్షరాలతో ఉంటాయి. / గమనిక: మీరు ఇన్పుట్ ఎల్లప్పుడూ సరైనది లేదా ఖాళీ స్ట్రింగ్ అని అనుకోవచ్చు, / B (= దశాంశ 11), D (= దశాంశ 13). / కాబట్టి మీరు క్రింది అంకెల సంఖ్యను నిర్ణయించాలి: 2, 3, 5, 7, / ప్రైమ్ సంఖ్యలు 2, 3, 5, 7, 11, 13, 17,... / హెక్సాడెసిమల్ అంకెలు 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. / 1 కంటే పెద్దది, ఇది రెండు చిన్న సహజ సంఖ్యల యొక్క ఉత్పత్తి కాదు)./ అక్షరాల సంఖ్యలు ప్రైమ్ సంఖ్యలు (ప్రైమ్ సంఖ్య, లేదా ప్రైమ్, ఒక సహజ సంఖ్య / హెక్సాడెసిమల్ సంఖ్యను స్ట్రింగ్గా మరియు హెక్సాడెసిమల్ సంఖ్యను లెక్కిస్తుంది /మీరు ఒక ఫంక్షన్ వ్రాయడానికి అప్పగించారు చేశారు అందుకుంటుంది // >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
function hex_key(num){
","function hex_key(num) {
    // Define a set of hexadecimal digits that are prime numbers
    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);
    
    // Initialize a count variable to track the number of prime digits
    let count = 0;
    
    // Iterate over each character in the input string
    for (let char of num) {
        // Check if the character is in the set of prime hexadecimal digits
        if (primeHexDigits.has(char)) {
            // Increment the count if the character is a prime digit
            count++;
        }
    }
    
    // Return the total count of prime hexadecimal digits
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = hex_key;
  assert.deepEqual(candidate(""AB""),1);
  assert.deepEqual(candidate(""1077E""),2);
  assert.deepEqual(candidate(""ABED1A33""),4);
  assert.deepEqual(candidate(""2020""),2);
  assert.deepEqual(candidate(""123456789ABCDEF0""),6);
  assert.deepEqual(candidate(""112233445566778899AABBCCDDEEFF00""),12);
}

test();"
HumanEval_79,tel_Telu,js,"/ ఉదాహరణలు: / అదనపు అక్షరాలు ఫార్మాట్ తో సహాయం ఉన్నాయి. / స్ట్రింగ్ ప్రారంభంలో మరియు ముగింపులో అదనపు రెండు అక్షరాలు 'db' ఉంటాయి. / సంఖ్య. స్ట్రింగ్ లోని ప్రతి అక్షరం '0' లేదా '1' అవుతుంది./ బైనరీ ఫార్మాట్. ఫంక్షన్ ఒక స్ట్రింగ్ను తిరిగి ఇవ్వాలి, ప్రతి అక్షరం బైనరీని సూచిస్తుంది /మీకు దశాంశ రూపంలో ఒక సంఖ్య ఇవ్వబడుతుంది మరియు మీ పని దానిని గా మార్చడం.// >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
function decimal_to_binary(decimal){
","function decimal_to_binary(decimal) {
    // Convert the decimal number to a binary string
    let binaryString = decimal.toString(2);
    // Add 'db' at the beginning and end of the binary string
    return 'db' + binaryString + 'db';
}","const assert = require('node:assert');


function test() {
  let candidate = decimal_to_binary;
  assert.deepEqual(candidate(0),""db0db"");
  assert.deepEqual(candidate(32),""db100000db"");
  assert.deepEqual(candidate(103),""db1100111db"");
  assert.deepEqual(candidate(15),""db1111db"");
}

test();"
HumanEval_80,tel_Telu,js,"/ ఉదాహరణకి: / ఒక స్ట్రింగ్ దాని పొడవు కనీసం 3 మరియు ప్రతి 3 వరుస అక్షరాలు విభిన్నంగా ఉంటే హ్యాప్స్ / మీ పని స్ట్రింగ్ hapjs లేదా కాదా అని తనిఖీ చేయడం. / మీరు ఒక స్ట్రింగ్ ఇవ్వబడుతుంది s. // >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
function is_happy(s){
","function is_happy(s) {
    if (s.length < 3) return false;
    for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {
            return false;
        }
    }
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_happy;
  assert.deepEqual(candidate(""a""),false);
  assert.deepEqual(candidate(""aa""),false);
  assert.deepEqual(candidate(""abcd""),true);
  assert.deepEqual(candidate(""aabb""),false);
  assert.deepEqual(candidate(""adb""),true);
  assert.deepEqual(candidate(""xyy""),false);
  assert.deepEqual(candidate(""iopaxpoi""),true);
  assert.deepEqual(candidate(""iopaxioi""),false);
}

test();"
HumanEval_81,tel_Telu,js,"/ ఉదాహరణ: / 0.0 E / > 0.0 డి- / > 0.7 డి / > 1.0 డి + / > 1.3 C- / > 1.7 C / > 2.0 C+ / > 2.3 బి- / > 2.7 బి / > 3.0 బి + / > 3.3 A- / > 3.7 A / 4.0 A+ / GPA ∙ అక్షర గ్రేడ్ ∙/ కింది పట్టికను ఉపయోగించి అక్షరాల తరగతుల శ్రేణిని అవుట్పుట్ చేయగల ఫంక్షన్ః / ఆమె కొన్ని విద్యార్థులకు GPA లు శ్రేణిని ఇచ్చింది మరియు మీరు వ్రాయాలి / ఆమె మాత్రమే సమస్య, ఆమె గ్రేడింగ్ కోసం ఉపయోగిస్తారు కోడ్ కోల్పోయింది ఉంది. / విద్యార్థులకు. ఉపాధ్యాయుడు తన సొంత అల్గోరిథంను గ్రేడింగ్ కోసం తయారు చేస్తాడు. సెమిస్టర్ చివరి వారం, ఉపాధ్యాయుడు తరగతులు ఇవ్వాలి.// >>> grade_equation([4.0, 3, 1.7, 2, 3.5])
// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
function numerical_letter_grade(grades){
","function numerical_letter_grade(grades){
    return grades.map(gpa => {
        if (gpa === 4.0) return ""A+"";
        else if (gpa > 3.7) return ""A"";
        else if (gpa > 3.3) return ""A-"";
        else if (gpa > 3.0) return ""B+"";
        else if (gpa > 2.7) return ""B"";
        else if (gpa > 2.3) return ""B-"";
        else if (gpa > 2.0) return ""C+"";
        else if (gpa > 1.7) return ""C"";
        else if (gpa > 1.3) return ""C-"";
        else if (gpa > 1.0) return ""D+"";
        else if (gpa > 0.7) return ""D"";
        else if (gpa > 0.0) return ""D-"";
        else return ""E"";
    });
}","const assert = require('node:assert');


function test() {
  let candidate = numerical_letter_grade;
  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[""A+"", ""B"", ""C-"", ""C"", ""A-""]);
  assert.deepEqual(candidate([1.2]),[""D+""]);
  assert.deepEqual(candidate([0.5]),[""D-""]);
  assert.deepEqual(candidate([0.0]),[""E""]);
  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[""D"", ""D-"", ""C-"", ""B"", ""B+""]);
  assert.deepEqual(candidate([0.0, 0.7]),[""E"", ""D-""]);
}

test();"
HumanEval_82,tel_Telu,js,"/ ఉదాహరణలు / పొడవు ఒక ప్రధాన సంఖ్య లేదా తప్పు లేకపోతే / ఒక స్ట్రింగ్ తీసుకుని ఒక స్ట్రింగ్  ఉంటే నిజమైన తిరిగి ఒక ఫంక్షన్ వ్రాయండి// >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
function prime_length(string){
","function prime_length(string) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
    
    return isPrime(string.length);
}","const assert = require('node:assert');


function test() {
  let candidate = prime_length;
  assert.deepEqual(candidate(""Hello""),true);
  assert.deepEqual(candidate(""abcdcba""),true);
  assert.deepEqual(candidate(""kittens""),true);
  assert.deepEqual(candidate(""orange""),false);
  assert.deepEqual(candidate(""wow""),true);
  assert.deepEqual(candidate(""world""),true);
  assert.deepEqual(candidate(""MadaM""),true);
  assert.deepEqual(candidate(""Wow""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""HI""),true);
  assert.deepEqual(candidate(""go""),true);
  assert.deepEqual(candidate(""gogo""),false);
  assert.deepEqual(candidate(""aaaaaaaaaaaaaaa""),false);
  assert.deepEqual(candidate(""Madam""),true);
  assert.deepEqual(candidate(""M""),false);
  assert.deepEqual(candidate(""0""),false);
}

test();"
HumanEval_83,tel_Telu,js,"/ 1 తో ప్రారంభమయ్యే లేదా ముగుస్తున్న సానుకూల పూర్ణాంకాలు. /ఒక సానుకూల పూర్ణాంకం n ఇచ్చినట్లయితే, n-అంకెల సంఖ్యల గణనను తిరిగి ఇవ్వండి function starts_one_ends(n){
","function starts_one_ends(n) {
    if (n === 1) return 1; // For n = 1, only number is 1 itself

    // Calculate the number of n-digit numbers that either start or end with 1
    // Total n-digit numbers: 9 * 10^(n-1) (ranging from 10^(n-1) to 10^n - 1)

    let totalCount = 9 * Math.pow(10, n - 1);

    // Numbers that both start and end with 1: 10^(n-2) (e.g., 101, 111, 121, ..., 191 if n=3)
    let bothStartAndEndWithOne = Math.pow(10, n - 2);

    // Numbers that start with 1: 10^(n-1)
    let startWithOne = Math.pow(10, n - 1);

    // Numbers that end with 1: 9 * 10^(n-1) / 10 = 10^(n-1) (because we're counting 1 - 1, 11, 21, ..., 91)
    let endWithOne = Math.pow(10, n - 1);

    // Use inclusion-exclusion principle: number starts with 1 + numbers end with 1 - numbers that both start and end with 1
    return startWithOne + endWithOne - bothStartAndEndWithOne;
}","const assert = require('node:assert');


function test() {
  let candidate = starts_one_ends;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(2),18);
  assert.deepEqual(candidate(3),180);
  assert.deepEqual(candidate(4),1800);
  assert.deepEqual(candidate(5),18000);
}

test();"
HumanEval_84,tel_Telu,js,"/ ఉదాహరణ /ఒక పాజిటివ్ పూర్ణాంకం N ఇచ్చినట్లయితే, దాని అంకెల మొత్తం మొత్తాన్ని బైనరీలో తిరిగి ఇవ్వండి. // >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
function solve(N){
","function solve(N) {
    // Convert the number to a string and split into individual characters (digits)
    let digits = N.toString().split('');
    // Calculate the sum of all digits
    let sum = digits.reduce((acc, digit) => acc + Number(digit), 0);
    // Convert the sum to a binary string and return
    return sum.toString(2);
}","const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(1000),""1"");
  assert.deepEqual(candidate(150),""110"");
  assert.deepEqual(candidate(147),""1100"");
  assert.deepEqual(candidate(333),""1001"");
  assert.deepEqual(candidate(963),""10010"");
}

test();"
HumanEval_85,tel_Telu,js,"/ ఉదాహరణలు: / ఖాళీ కాని పూర్ణాంకాల శ్రేణి ఇచ్చిన lst. అసమాన సూచికలలో ఉన్న జత మూలకాలను జోడించండి .. // >>> add([4, 2, 6, 7])
// 2
function add(lst){
","function add(lst) {
    let sum = 0;
    for (let i = 1; i < lst.length; i += 2) {
        if (lst[i] % 2 === 0) {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate([4, 88]),88);
  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);
  assert.deepEqual(candidate([4, 0, 6, 7]),0);
  assert.deepEqual(candidate([4, 4, 6, 8]),12);
}

test();"
HumanEval_86,tel_Telu,js,"/ ఉదాహరణకి: / గమనిక: మీరు వాక్యంలోని పదాల క్రమాన్ని మరియు ఖాళీలను పాటించాలి. / ASCII విలువ ఆధారంగా పెరుగుతున్న క్రమంలో. / అనే కొత్త పదంతో భర్తీ చేయబడతాయి, ఇక్కడ అన్ని అక్షరాలు / స్ట్రింగ్ యొక్క క్రమబద్ధమైన వెర్షన్, అన్ని పదాలు (స్పేస్ ద్వారా వేరు) / ఒక స్ట్రింగ్ తీసుకుని దాని యొక్క క్రమబద్ధమైన సంస్కరణను తిరిగి ఇచ్చే ఫంక్షన్ను వ్రాయండి. // >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
function anti_shuffle(s){
","function anti_shuffle(s) {
    return s.split(' ').map(word => {
        return word.split('').sort().join('');
    }).join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = anti_shuffle;
  assert.deepEqual(candidate(""Hi""),""Hi"");
  assert.deepEqual(candidate(""hello""),""ehllo"");
  assert.deepEqual(candidate(""number""),""bemnru"");
  assert.deepEqual(candidate(""abcd""),""abcd"");
  assert.deepEqual(candidate(""Hello World!!!""),""Hello !!!Wdlor"");
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hi. My name is Mister Robot. How are you?""),"".Hi My aemn is Meirst .Rboot How aer ?ouy"");
}

test();"
HumanEval_87,tel_Telu,js,"/ ఉదాహరణలు: / అలాగే, వరుస యొక్క కోఆర్డినేట్లను వరుసల ద్వారా క్రమబద్ధీకరించండి. / అక్షాంశాలను మొదట వరుసల ద్వారా క్రమంలో క్రమబద్ధీకరించండి. / ప్రతి శ్రేణి ఒక కోఆర్డినేట్ - (వరుస, కాలమ్లు), 0 తో మొదలవుతుంది. / మరియు శ్రేణుల శ్రేణిని తిరిగి ఇవ్వండి, [(x1, y1), (x2, y2) ...] అలాంటిది / lst, మరియు పూర్ణాంకం x ఇచ్చినట్లయితే, శ్రేణిలో పూర్ణాంకాలు x ను కనుగొనండి, / ప్రతి వరుసలో వేర్వేరు సంఖ్యలో నిలువు వరుసలు ఉండవచ్చు./ ఇది మాతృకకు సమానమైనది, అయితే, మాతృకలకు భిన్నంగా, /మీరు ఒక 2 డైమెన్షనల్ డేటా ఇవ్వబడుతుంది, ఒక గూడు అమరికలు, // >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
// >>> get_row([], 1)
// []
// >>> get_row([[], [1], [1, 2, 3]], 3)
// [[2, 2]]
function get_row(lst, x){
","function get_row(lst, x) {
    const result = [];

    for (let i = 0; i < lst.length; i++) {
        for (let j = 0; j < lst[i].length; j++) {
            if (lst[i][j] === x) {
                result.push([i, j]);
            }
        }
    }

    result.sort((a, b) => {
        if (a[0] === b[0]) {
            return b[1] - a[1]; // Sort by columns in descending order for the same row
        }
        return a[0] - b[0]; // Sort by rows in ascending order
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = get_row;
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);
  assert.deepEqual(candidate([], 1),[]);
  assert.deepEqual(candidate([[1]], 2),[]);
  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);
}

test();"
HumanEval_88,tel_Telu,js,"/ ఉదాహరణలు: / * ఇచ్చిన శ్రేణిని మార్చవద్దు. / గమనిక: / లేదా మొత్తం ((మొదటి సూచిక విలువ, చివరి సూచిక విలువ) జత అయితే దానిని క్రిందికి క్రమబద్ధీకరించండి. / మీరు ఇచ్చిన శ్రేణిని పెరుగుతున్న క్రమంలో క్రమబద్ధీకరించాలి, మొత్తం ((మొదటి సూచిక విలువ, చివరి సూచిక విలువ) బేసి అయితే, /కాని ప్రతికూల పూర్ణాంకాల శ్రేణిని ఇచ్చిన తరువాత, ఇచ్చిన శ్రేణి యొక్క cojs ను క్రమబద్ధీకరించండి, // >>> sort_array([])
// []
// >>> sort_array([5])
// [5]
// >>> sort_array([2, 4, 3, 0, 1, 5])
// [0, 1, 2, 3, 4, 5]
// >>> sort_array([2, 4, 3, 0, 1, 5, 6])
// [6, 5, 4, 3, 2, 1, 0]
function sort_array(array){
","function sort_array(array) {
    if (array.length === 0) return [];

    let firstValue = array[0];
    let lastValue = array[array.length - 1];
    let sum = firstValue + lastValue;
    
    let sortedArray = [...array]; // Clone the array to avoid modifying the original

    if (sum % 2 === 0) {
        // Even sum: sort in descending order
        sortedArray.sort((a, b) => b - a);
    } else {
        // Odd sum: sort in ascending order
        sortedArray.sort((a, b) => a - b);
    }

    return sortedArray;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5]),[5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);
  assert.deepEqual(candidate([2, 1]),[1, 2]);
  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);
  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);
}

test();"
HumanEval_89,tel_Telu,js,"/ ఉదాహరణకి: / రెండు స్థానాలకు రెండు గుణించి / అక్షరమాల ను అక్షరాల / అక్షరమాల తిరిగే విధంగా ఎన్క్రిప్ట్ చేయబడిన స్ట్రింగ్ను తిరిగి ఇస్తుంది. / ఒక స్ట్రింగ్ ను ఒక వాదనగా తీసుకునే ఫంక్షన్ ఎన్క్రిప్ట్ ను సృష్టించండి మరియు // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
function encrypt(s){
","function encrypt(s) {
    const shift = 2 * 2; // shift down by two multiplied by two places
    let encrypted = '';
    for (let i = 0; i < s.length; i++) {
        let charCode = s.charCodeAt(i);
        let newCharCode = ((charCode - 97 + shift) % 26) + 97; // wrap around within 'a' to 'z'
        encrypted += String.fromCharCode(newCharCode);
    }
    return encrypted;
}","const assert = require('node:assert');


function test() {
  let candidate = encrypt;
  assert.deepEqual(candidate(""hi""),""lm"");
  assert.deepEqual(candidate(""asdfghjkl""),""ewhjklnop"");
  assert.deepEqual(candidate(""gf""),""kj"");
  assert.deepEqual(candidate(""et""),""ix"");
  assert.deepEqual(candidate(""faewfawefaewg""),""jeiajeaijeiak"");
  assert.deepEqual(candidate(""hellomyfriend""),""lippsqcjvmirh"");
  assert.deepEqual(candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""),""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"");
  assert.deepEqual(candidate(""a""),""e"");
}

test();"
HumanEval_90,tel_Telu,js,"/ అటువంటి మూలకం లేకపోతే నిర్వచించబడని తిరిగి ఇవ్వండి. / ఒక ఫంక్షన్ next_smallest() ను వ్రాసి, శ్రేణి యొక్క 2వ చిన్న మూలకాన్ని తిరిగి ఇస్తుంది. /మీరు పూర్ణాంకాల శ్రేణిని ఇవ్వబడ్డారు. // >>> next_smallest([1, 2, 3, 4, 5])
// 2
// >>> next_smallest([5, 1, 4, 3, 2])
// 2
// >>> next_smallest([])
// undefined
// >>> next_smallest([1, 1])
// undefined
function next_smallest(lst){
","function next_smallest(lst) {
    if (lst.length < 2) return undefined;
    
    let firstSmallest = Infinity;
    let secondSmallest = Infinity;
    
    for (let num of lst) {
        if (num < firstSmallest) {
            secondSmallest = firstSmallest;
            firstSmallest = num;
        } else if (num < secondSmallest && num != firstSmallest) {
            secondSmallest = num;
        }
    }
    
    return secondSmallest === Infinity ? undefined : secondSmallest;
}","const assert = require('node:assert');


function test() {
  let candidate = next_smallest;
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);
  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);
}

test();"
HumanEval_91,tel_Telu,js,"/ ఉదాహరణకి: / వాక్యాలను '.', '?' లేదా '!' తో వేరు చేస్తారు./ విసుగు యొక్క. ఒక విసుగు ""నేను"" అనే పదంతో ప్రారంభమయ్యే ఒక వాక్యం. / మీరు పదాల ఒక స్ట్రింగ్ ఇవ్వబడుతుంది, మరియు మీ పని సంఖ్య లెక్కించడానికి ఉంది // >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
function is_bored(S){
","function is_bored(S) {
    // Split the string into sentences using '.', '?', and '!' as delimiters
    const sentences = S.split(/[.!?]/);
    
    // Initialize boredom count
    let boredomCount = 0;
    
    // Iterate over each sentence
    sentences.forEach(sentence => {
        // Trim any whitespace from the beginning of the sentence and check if it starts with ""I""
        if (sentence.trim().startsWith(""I"")) {
            boredomCount++;
        }
    });
    
    return boredomCount;
}","const assert = require('node:assert');


function test() {
  let candidate = is_bored;
  assert.deepEqual(candidate(""Hello world""),0);
  assert.deepEqual(candidate(""Is the sky blue?""),0);
  assert.deepEqual(candidate(""I love It !""),1);
  assert.deepEqual(candidate(""bIt""),0);
  assert.deepEqual(candidate(""I feel good today. I will be productive. will kill It""),2);
  assert.deepEqual(candidate(""You and I are going for a walk""),0);
}

test();"
HumanEval_92,tel_Telu,js,"/ ఉదాహరణలు / ఇతర సందర్భాల్లో తప్పుగా తిరిగి వస్తుంది. / సంఖ్యలలో ఒకటి ఇతర రెండు సంఖ్యల మొత్తానికి సమానంగా ఉంటే, మరియు అన్ని సంఖ్యలు పూర్ణాంకాలు అయితే నిజమైన సంఖ్యను తిరిగి ఇస్తుంది. /3 సంఖ్యలను తీసుకునే ఫంక్షన్ను సృష్టించండి. // >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
function any_int(x, y, z){
","function any_int(x, y, z) {
    // Check if all numbers are integers
    if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {
        // Check if any number is the sum of the other two
        return x === y + z || y === x + z || z === x + y;
    }
    // Return false if not all numbers are integers
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = any_int;
  assert.deepEqual(candidate(2, 3, 1),true);
  assert.deepEqual(candidate(2.5, 2, 3),false);
  assert.deepEqual(candidate(1.5, 5, 3.5),false);
  assert.deepEqual(candidate(2, 6, 2),false);
  assert.deepEqual(candidate(4, 2, 2),true);
  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);
  assert.deepEqual(candidate(-4, 6, 2),true);
  assert.deepEqual(candidate(2, 1, 1),true);
  assert.deepEqual(candidate(3, 4, 7),true);
  assert.deepEqual(candidate(3.0, 4, 7),false);
}

test();"
HumanEval_93,tel_Telu,js,"/ ఉదాహరణలు: / అక్షరాలు మాత్రమే ఊహించుకోండి. / ఆంగ్ల అక్షరమాలలో అచ్చు. / ఆ ముందు 2 స్థానాలు కనిపించే లేఖతో సందేశం / అన్ని అక్షరాల కేసులను మార్చుకునే విధంగా,  లోని అన్ని అచ్చులను భర్తీ చేస్తుంది/ఒక సందేశాన్ని తీసుకునే ఫంక్షన్ను వ్రాయండి, మరియు అలాంటి // >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
function encode(message){
","function encode(message) {
    // Helper function to swap the case of a character
    function swapCase(char) {
        if (char === char.toLowerCase()) {
            return char.toUpperCase();
        } else {
            return char.toLowerCase();
        }
    }

    // Vowel mapping
    const vowelMap = {
        'a': 'c',
        'e': 'g',
        'i': 'k',
        'o': 'q',
        'u': 'w',
        'A': 'C',
        'E': 'G',
        'I': 'K',
        'O': 'Q',
        'U': 'W'
    };

    // Encode the message
    let encodedMessage = '';
    
    for (let char of message) {
        if (/[aeiouAEIOU]/.test(char)) {
            // Replace vowel with appropriate letter
            encodedMessage += vowelMap[char];
        } else {
            // Swap case for non-vowel letters
            encodedMessage += swapCase(char);
        }
    }
    
    return encodedMessage;
}","const assert = require('node:assert');


function test() {
  let candidate = encode;
  assert.deepEqual(candidate(""TEST""),""tgst"");
  assert.deepEqual(candidate(""Mudasir""),""mWDCSKR"");
  assert.deepEqual(candidate(""YES""),""ygs"");
  assert.deepEqual(candidate(""This is a message""),""tHKS KS C MGSSCGG"");
  assert.deepEqual(candidate(""I DoNt KnOw WhAt tO WrItE""),""k dQnT kNqW wHcT Tq wRkTg"");
}

test();"
HumanEval_94,tel_Telu,js,"/ ఉదాహరణలు: / మీరు అతిపెద్ద ప్రైమ్ విలువను కనుగొని దాని అంకెల మొత్తాన్ని తిరిగి ఇవ్వాలి. /మీరు పూర్ణాంకాల శ్రేణిని ఇవ్వబడ్డారు. // >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
// 10
// >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
// 25
// >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
// 13
// >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
// 11
// >>> skjkasdkd([0, 81, 12, 3, 1, 21])
// 3
// >>> skjkasdkd([0, 8, 1, 2, 1, 7])
// 7
function skjkasdkd(lst){
","function skjkasdkd(lst) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    function sumOfDigits(num) {
        return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }

    let largestPrime = -1;

    for (let num of lst) {
        if (isPrime(num) && num > largestPrime) {
            largestPrime = num;
        }
    }
    
    return largestPrime !== -1 ? sumOfDigits(largestPrime) : 0;
}","const assert = require('node:assert');


function test() {
  let candidate = skjkasdkd;
  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);
  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);
  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);
  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);
  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);
  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);
  assert.deepEqual(candidate([8191]),19);
  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);
  assert.deepEqual(candidate([127, 97, 8192]),10);
}

test();"
HumanEval_95,tel_Telu,js,"/ ఉదాహరణలు: / ఫంక్షన్ false తిరిగి ఇవ్వాలి ఇచ్చిన వస్తువు ఖాళీగా ఉంది. / కేసు లేదా అన్ని కీలు పెద్ద అక్షరాలలో స్ట్రింగ్స్, లేకపోతే తప్పు తిరిగి. /ఒక వస్తువు ఇచ్చినట్లయితే, అన్ని కీలు తక్కువ  లో స్ట్రింగ్స్ అయితే true తిరిగి ఇవ్వండి.// >>> check_dict_case({""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case({""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case({""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case({""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
function check_dict_case(dict){
","function check_dict_case(dict) {
    const keys = Object.keys(dict);

    if (keys.length === 0) return false;

    const allLowerCase = keys.every(key => typeof key === 'string' && key === key.toLowerCase());
    const allUpperCase = keys.every(key => typeof key === 'string' && key === key.toUpperCase());

    return allLowerCase || allUpperCase;
}","const assert = require('node:assert');


function test() {
  let candidate = check_dict_case;
  assert.deepEqual(candidate({""p"": ""pineapple"", ""b"": ""banana""}),true);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}),false);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}),false);
  assert.deepEqual(candidate({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}),false);
  assert.deepEqual(candidate({""STATE"": ""NC"", ""ZIP"": ""12345""}),true);
  assert.deepEqual(candidate({""fruit"": ""Orange"", ""taste"": ""Sweet""}),true);
  assert.deepEqual(candidate({}),false);
}

test();"
HumanEval_96,tel_Telu,js,"/ ఉదాహరణకు: / పూర్ణాంకాలు ప్రైమ్ సంఖ్యలు మరియు n కన్నా తక్కువ. / ప్రతికూల సంఖ్య కాని పూర్ణాంకమును తీసుకొని మొదటి n యొక్క శ్రేణిని తిరిగి ఇచ్చే ఫంక్షన్ను అమలు చేయండి // >>> count_up_to(5)
// [2, 3]
// >>> count_up_to(11)
// [2, 3, 5, 7]
// >>> count_up_to(0)
// []
// >>> count_up_to(20)
// [2, 3, 5, 7, 11, 13, 17, 19]
// >>> count_up_to(1)
// []
// >>> count_up_to(18)
// [2, 3, 5, 7, 11, 13, 17]
function count_up_to(n){
","function count_up_to(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }

    const primes = [];
    for (let i = 2; i < n; i++) {
        if (isPrime(i)) {
            primes.push(i);
        }
    }
    return primes;
}","const assert = require('node:assert');


function test() {
  let candidate = count_up_to;
  assert.deepEqual(candidate(5),[2, 3]);
  assert.deepEqual(candidate(6),[2, 3, 5]);
  assert.deepEqual(candidate(7),[2, 3, 5]);
  assert.deepEqual(candidate(10),[2, 3, 5, 7]);
  assert.deepEqual(candidate(0),[]);
  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);
  assert.deepEqual(candidate(1),[]);
  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

test();"
HumanEval_97,tel_Telu,js,"/ ఉదాహరణలు: / ఇన్పుట్ ఎల్లప్పుడూ చెల్లుబాటు అయ్యేదిగా భావించండి. / వారి యూనిట్ అంకెల ఉత్పత్తి. / రెండు పూర్ణాంకాలతో ఫంక్షన్ను పూర్తి చేసి తిరిగి // >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
function multiply(a, b){
","function multiply(a, b) {
    // Get the absolute value of each number
    a = Math.abs(a);
    b = Math.abs(b);

    // Extract the unit digit of each number
    let unitDigitA = a % 10;
    let unitDigitB = b % 10;

    // Return the product of the unit digits
    return unitDigitA * unitDigitB;
}","const assert = require('node:assert');


function test() {
  let candidate = multiply;
  assert.deepEqual(candidate(148, 412),16);
  assert.deepEqual(candidate(19, 28),72);
  assert.deepEqual(candidate(2020, 1851),0);
  assert.deepEqual(candidate(14, -15),20);
  assert.deepEqual(candidate(76, 67),42);
  assert.deepEqual(candidate(17, 27),49);
  assert.deepEqual(candidate(0, 1),0);
  assert.deepEqual(candidate(0, 0),0);
}

test();"
HumanEval_98,tel_Telu,js,"/ ఉదాహరణకి: / ఒక స్ట్రింగ్ s ఇచ్చిన, పెద్ద అచ్చులు సంఖ్యను లెక్కించండి.// >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
function count_upper(s){
","function count_upper(s) {
    const vowels = new Set(['A', 'E', 'I', 'O', 'U']);
    let count = 0;
    for (let i = 0; i < s.length; i += 2) {
        if (vowels.has(s[i])) {
            count++;
        }
    }
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = count_upper;
  assert.deepEqual(candidate(""aBCdEf""),1);
  assert.deepEqual(candidate(""abcdefg""),0);
  assert.deepEqual(candidate(""dBBE""),0);
  assert.deepEqual(candidate(""B""),0);
  assert.deepEqual(candidate(""U""),1);
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""EEEE""),2);
}

test();"
HumanEval_99,tel_Telu,js,"/ ఉదాహరణలు / రెండు పూర్ణాంకాల నుండి, సున్నా నుండి దూరంగా గుండ్రంగా. / మరియు దానికి సమీప పూర్ణాంకమును తిరిగి ఇస్తుంది. సంఖ్య సమాన దూరమైతే /సంఖ్యను సూచించే విలువను (స్ట్రింగ్) తీసుకునే ఫంక్షన్ను సృష్టించండి // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
function closest_integer(value){
","function closest_integer(value) {
    let num = parseFloat(value);
    if (num > 0) {
        return Math.floor(num + 0.5);
    } else {
        return Math.ceil(num - 0.5);
    }
}","const assert = require('node:assert');


function test() {
  let candidate = closest_integer;
  assert.deepEqual(candidate(""10""),10);
  assert.deepEqual(candidate(""14.5""),15);
  assert.deepEqual(candidate(""-15.5""),-16);
  assert.deepEqual(candidate(""15.3""),15);
  assert.deepEqual(candidate(""0""),0);
}

test();"
HumanEval_100,tel_Telu,js,"/ ఉదాహరణలు: / i అనేది స్థాయిలోని రాళ్ల సంఖ్యను సూచిస్తుంది (i+1)./ ఒక శ్రేణిలో ప్రతి స్థాయిలో రాళ్ల సంఖ్యను తిరిగి ఇస్తుంది, ఇక్కడ మూలకం ఇండెక్స్ వద్ద / - n జత సంఖ్య అయితే తదుపరి జత సంఖ్య. / - n ఒక బేసి సంఖ్య అయితే తదుపరి బేసి సంఖ్య. / తదుపరి స్థాయిలో రాళ్ల సంఖ్యః / మొదటి స్థాయిలో n రాళ్ళు ఉన్నాయి. /ఒక సానుకూల పూర్ణాంకం n ఇచ్చినట్లయితే, మీరు n స్థాయిల రాళ్ళతో ఒక కుప్ప తయారు చేయాలి.// >>> make_a_pile(3)
// [3, 5, 7]
function make_a_pile(n){
","function make_a_pile(n) {
    const pile = [];
    let currentStones = n;
    
    for (let i = 0; i < n; i++) {
        pile.push(currentStones);
        currentStones += (currentStones % 2 === 0) ? 2 : 2;
    }

    return pile;
}","const assert = require('node:assert');


function test() {
  let candidate = make_a_pile;
  assert.deepEqual(candidate(3),[3, 5, 7]);
  assert.deepEqual(candidate(4),[4, 6, 8, 10]);
  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);
  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);
  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);
}

test();"
HumanEval_101,tel_Telu,js,"/ ఉదాహరణకి: / స్ట్రింగ్ను పదాలుగా విభజించి పదాల శ్రేణిని తిరిగి ఇవ్వడానికి. మీకు కామాలతో లేదా ఖాళీలతో వేరు చేయబడిన పదాల స్ట్రింగ్ ఇవ్వబడుతుంది. మీ పని // >>> words_string(""Hi, my name is John"")
// [""Hi"", ""my"", ""name"", ""is"", ""John""]
// >>> words_string(""One, two, three, four, five, six"")
// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
function words_string(s){
","function words_string(s) {
    // Split the string by removing commas and spaces, filter out any empty strings
    return s.split(/[\s,]+/).filter(Boolean);
}","const assert = require('node:assert');


function test() {
  let candidate = words_string;
  assert.deepEqual(candidate(""Hi, my name is John""),[""Hi"", ""my"", ""name"", ""is"", ""John""]);
  assert.deepEqual(candidate(""One, two, three, four, five, six""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""Hi, my name""),[""Hi"", ""my"", ""name""]);
  assert.deepEqual(candidate(""One,, two, three, four, five, six,""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""ahmed     , gamal""),[""ahmed"", ""gamal""]);
}

test();"
HumanEval_102,tel_Telu,js,"/ ఉదాహరణకి: / అటువంటి సంఖ్య లేదు, అప్పుడు ఫంక్షన్ తిరిగి -1 ఉండాలి. [x, y] పరిధిలో ఉన్న అతి పెద్ద జత పూర్ణాంక సంఖ్య.ఈ ఫంక్షన్ రెండు సానుకూల సంఖ్యలను x మరియు y తీసుకుంటుంది మరియు  ను తిరిగి ఇస్తుంది// >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
function choose_num(x, y){
","function choose_num(x, y) {
    if (x > y) {
        return -1;
    }
    for (let i = y; i >= x; i--) {
        if (i % 2 === 0) {
            return i;
        }
    }
    return -1;
}","const assert = require('node:assert');


function test() {
  let candidate = choose_num;
  assert.deepEqual(candidate(12, 15),14);
  assert.deepEqual(candidate(13, 12),-1);
  assert.deepEqual(candidate(33, 12354),12354);
  assert.deepEqual(candidate(5234, 5233),-1);
  assert.deepEqual(candidate(6, 29),28);
  assert.deepEqual(candidate(27, 10),-1);
  assert.deepEqual(candidate(7, 7),-1);
  assert.deepEqual(candidate(546, 546),546);
}

test();"
HumanEval_103,tel_Telu,js,"/ ఉదాహరణ: / n m కన్నా పెద్దది అయితే, -1 ను తిరిగి ఇవ్వండి. / సమీప పూర్ణాంకం వరకు సమాధానాన్ని గుండ్రంగా చేసి దానిని బైనరీగా మార్చండి. / n నుండి m వరకు (n మరియు m తో సహా) పూర్ణాంకాల సగటు.మీకు రెండు పాజిటివ్ పూర్ణాంకాలు n మరియు m ఇవ్వబడ్డాయి, మరియు మీ పని // >>> rounded_avg(1, 5)
// ""0b11""
// >>> rounded_avg(7, 5)
// -1
// >>> rounded_avg(10, 20)
// ""0b1111""
// >>> rounded_avg(20, 33)
// ""0b11010""
function rounded_avg(n, m){
","function rounded_avg(n, m) {
    if (n > m) {
        return -1;
    }
    
    let sum = 0;
    let count = 0;
    
    for (let i = n; i <= m; i++) {
        sum += i;
        count++;
    }
    
    let average = sum / count;
    let roundedAverage = Math.round(average);
    return ""0b"" + roundedAverage.toString(2);
}

// Example Usage
console.log(rounded_avg(1, 5));   // ""0b11""
console.log(rounded_avg(7, 5));   // -1
console.log(rounded_avg(10, 20)); // ""0b1111""
console.log(rounded_avg(20, 33)); // ""0b11010""","const assert = require('node:assert');


function test() {
  let candidate = rounded_avg;
  assert.deepEqual(candidate(1, 5),""0b11"");
  assert.deepEqual(candidate(7, 13),""0b1010"");
  assert.deepEqual(candidate(964, 977),""0b1111001010"");
  assert.deepEqual(candidate(996, 997),""0b1111100100"");
  assert.deepEqual(candidate(560, 851),""0b1011000010"");
  assert.deepEqual(candidate(185, 546),""0b101101110"");
  assert.deepEqual(candidate(362, 496),""0b110101101"");
  assert.deepEqual(candidate(350, 902),""0b1001110010"");
  assert.deepEqual(candidate(197, 233),""0b11010111"");
  assert.deepEqual(candidate(7, 5),-1);
  assert.deepEqual(candidate(5, 1),-1);
  assert.deepEqual(candidate(5, 5),""0b101"");
}

test();"
HumanEval_104,tel_Telu,js,"/ ఉదాహరణకి: / గమనిక: తిరిగి వచ్చిన శ్రేణిని క్రమ క్రమంలో క్రమబద్ధీకరించాలి./ ఏ ఒక్క అంకెలు లేని మూలకాలు. /సమర్థ పూర్ణాంకాల శ్రేణి x ఇచ్చినట్లయితే. అన్ని  యొక్క క్రమబద్ధీకరించిన శ్రేణిని తిరిగి ఇవ్వండి// >>> unique_digits([15, 33, 1422, 1])
// [1, 15, 33]
// >>> unique_digits([152, 323, 1422, 10])
// []
function unique_digits(x){
","function unique_digits(x) {
    return x.filter(num => {
        return !num.toString().split('').some(digit => digit % 2 === 0);
    }).sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = unique_digits;
  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);
  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);
  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);
  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);
}

test();"
HumanEval_105,tel_Telu,js,"/ ఉదాహరణకి: / ""ఒకటి"", ""రెండు"", ""మూడు"", ""నాలుగు"", ""ఐదు"", ""ఆరు"", ""ఏడు"", ""ఎనిమిది"", ""తొమ్మిది"". / ఫలిత శ్రేణిని తిరగండి, ఆపై ప్రతి అంకెను దాని సంబంధిత పేరుతో  నుండి భర్తీ చేయండి./ఇంటిగెర్స్ యొక్క శ్రేణి ఇచ్చిన, 1 మరియు 9 మధ్య ఉన్న పూర్ణాంకాలను క్రమబద్ధీకరించండి, // >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])
// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
// If the array is empty, return an empty array:
// >>> by_length([])
// []
// If the array has any strange number ignore it:
// >>> by_length([1, -1, 55])
// [""One""]
function by_length(arr){
","function by_length(arr) {
  const numberNames = [
    ""One"", ""Two"", ""Three"", ""Four"", ""Five"",
    ""Six"", ""Seven"", ""Eight"", ""Nine""
  ];

  return arr.filter(num => num >= 1 && num <= 9)
            .sort((a, b) => a - b)
            .reverse()
            .map(num => numberNames[num - 1]);
}","const assert = require('node:assert');


function test() {
  let candidate = by_length;
  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -1, 55]),[""One""]);
  assert.deepEqual(candidate([1, -1, 3, 2]),[""Three"", ""Two"", ""One""]);
  assert.deepEqual(candidate([9, 4, 8]),[""Nine"", ""Eight"", ""Four""]);
}

test();"
HumanEval_106,tel_Telu,js,"/ ఉదాహరణ: / i యొక్క కారకం 1 నుండి i వరకు ఉన్న సంఖ్యల గుణకారం (1 * 2 * . . . * i)./ i 1 నుండి మొదలవుతుంది. / లేదా 1 నుండి i వరకు ఉన్న సంఖ్యల మొత్తం./ మరియు పరిమాణం n యొక్క శ్రేణిని తిరిగి ఇస్తుంది, ఇటువంటిది ఇండెక్స్ i వద్ద మూలకం యొక్క విలువ i యొక్క కారకం i ఉంటే కూడా /n ను పారామితిగా తీసుకునే ఫంక్షన్ f ను అమలు చేయండి, // >>> f(5)
// [1, 2, 6, 24, 15]
function f(n){
","function f(n) {
    function factorial(num) {
        let result = 1;
        for (let i = 2; i <= num; i++) {
            result *= i;
        }
        return result;
    }

    function sumUpTo(num) {
        return (num * (num + 1)) / 2; // Sum of first num natural numbers
    }

    let result = [];
    for (let i = 1; i <= n; i++) {
        if (i % 2 === 0) {
            result.push(factorial(i));
        } else {
            result.push(sumUpTo(i));
        }
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = f;
  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);
  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);
  assert.deepEqual(candidate(1),[1]);
  assert.deepEqual(candidate(3),[1, 2, 6]);
}

test();"
HumanEval_107,tel_Telu,js,"/ ఉదాహరణ 1: / పూర్ణాంక పాలిండ్రోమ్లు ఇవి పరిధిలో వస్తాయి ((1, n), కలుపుకొని. /ఒక సానుకూల పూర్ణాంకం n ఇచ్చినట్లయితే, ఒక శ్రేణిని తిరిగి ఇవ్వండి, అది జత మరియు అసమాన సంఖ్యలను కలిగి ఉంటుంది // >>> even_odd_palindrome(3)
// [1, 2]
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// [4, 6]
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned array has the number of even and odd integer palindromes respectively.
function even_odd_palindrome(n){
","function even_odd_palindrome(n) {
    function isPalindrome(num) {
        let str = num.toString();
        return str === str.split('').reverse().join('');
    }

    let evenCount = 0;
    let oddCount = 0;

    for (let i = 1; i <= n; i++) {
        if (isPalindrome(i)) {
            if (i % 2 === 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return [evenCount, oddCount];
}","const assert = require('node:assert');


function test() {
  let candidate = even_odd_palindrome;
  assert.deepEqual(candidate(123),[8, 13]);
  assert.deepEqual(candidate(12),[4, 6]);
  assert.deepEqual(candidate(3),[1, 2]);
  assert.deepEqual(candidate(63),[6, 8]);
  assert.deepEqual(candidate(25),[5, 6]);
  assert.deepEqual(candidate(19),[4, 6]);
  assert.deepEqual(candidate(9),[4, 5]);
  assert.deepEqual(candidate(1),[0, 1]);
}

test();"
HumanEval_108,tel_Telu,js,"/ ఉదా. -123 కు -1, 2, మరియు 3 అంకెలు ఉన్నాయి. / ఒక సంఖ్య ప్రతికూలంగా ఉంటే, దాని మొదటి సంతకం చేసిన అంకె ప్రతికూలంగా ఉంటుంది: / అంకెల మొత్తం 0 కంటే ఎక్కువ ఉన్న మూలకాల సంఖ్య. / count_nums అనే ఫంక్షన్ను వ్రాయండి, ఇది పూర్ణాంకాల శ్రేణిని తీసుకుంటుంది మరియు తిరిగి వస్తుంది // >>> count_nums([])
// 0
// >>> count_nums([-1, 11, -11])
// 1
// >>> count_nums([1, 1, 2])
// 3
function count_nums(arr){
","function count_nums(arr) {
    return arr.reduce((count, num) => {
        let str = num.toString();
        let sum = 0;
        for (let i = 0; i < str.length; i++) {
            if (i === 0 && str[i] === '-') {
                continue;
            }
            sum += parseInt(str[i]);
        }
        if (num < 0) {
            sum += 2 * parseInt(str[1]); // Adjust for the negative signed digit
        }
        return sum > 0 ? count + 1 : count;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = count_nums;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([-1, -2, 0]),0);
  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);
  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);
  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);
  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);
  assert.deepEqual(candidate([0, 1]),1);
  assert.deepEqual(candidate([1]),1);
}

test();"
HumanEval_109,tel_Telu,js,"/ ఉదాహరణకి: / గమనిక: ఇచ్చిన శ్రేణికి ప్రత్యేకమైన అంశాలు ఉండేలా హామీ ఇవ్వబడింది./ ఇచ్చిన శ్రేణి ఖాళీగా ఉంటే అప్పుడు true తిరిగి. / అప్పుడు తిరిగి true else తిరిగి false. / పైన ఆపరేషన్ చేయడం ద్వారా క్రమబద్ధీకరించిన శ్రేణిని పొందడం సాధ్యమైతే / శ్రేణిలో ప్రారంభ స్థానం అంటే 0 వ సూచిక. / సరైన దిశలో స్థానం. శ్రేణి యొక్క చివరి మూలకం  కు తరలించబడుతుంది/ ఒక కుడివైపు షిఫ్ట్ ఆపరేషన్ అంటే శ్రేణి యొక్క అన్ని అంశాలను ఒకదానితో షిఫ్ట్ చేయడం./ మీరు కుడి షిఫ్ట్ ఆపరేషన్ ఎన్ని సార్లు నిర్వహించడానికి అనుమతి ఉంది. / ఇచ్చిన శ్రేణిపై కింది ఆపరేషన్ః / ఒక శ్రేణిని క్రమంలో క్రమబద్ధీకరించడం సాధ్యమే / శ్రేణిలోని సంఖ్యలు యాదృచ్ఛికంగా క్రమబద్ధీకరించబడతాయి. మీ పని ఏమిటో నిర్ణయించడం / మనకు N పూర్ణాంకాల శ్రేణి 'arr' arr[1], arr[2], ..., arr[N] ఉంది. // >>> move_one_ball([3, 4, 5, 1, 2])
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given array.
// >>> move_one_ball([3, 5, 4, 1, 2])
// false
// Explanation:It is not possible to get non-decreasing order for the given
// array by performing any number of right shift operations.
function move_one_ball(arr){
","function move_one_ball(arr) {
    // If the array is empty, it's trivially sorted
    if (arr.length === 0) return true;

    // Count the number of positions where the next element is smaller than the current one
    let dropCount = 0;
    let n = arr.length;

    for (let i = 0; i < n; i++) {
        if (arr[i] > arr[(i + 1) % n]) {
            dropCount++;
        }
    }

    // If the drop count is more than 1, it means more than one drop is there
    // and thus we cannot sort it with right shifts
    return dropCount <= 1;
}","const assert = require('node:assert');


function test() {
  let candidate = move_one_ball;
  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);
  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);
  assert.deepEqual(candidate([4, 3, 1, 2]),false);
  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);
  assert.deepEqual(candidate([]),true);
}

test();"
HumanEval_110,tel_Telu,js,"/ ఉదాహరణకి: / లేకపోతే, ""NO"" ను తిరిగి ఇవ్వండి./ lst1 యొక్క అన్ని అంశాలు కూడా, ""YES"" ను తిరిగి ఇవ్వండి./ lst1 మరియు lst2 మధ్య అంశాలను మార్పిడి చేయడం సాధ్యమైతే / lst1 మరియు lst2 ల మధ్య మార్పిడి చేయబడిన అంశాల సంఖ్యకు పరిమితి లేదు./ వాటి మధ్య lst1 ను కేవలం జత సంఖ్యల శ్రేణిగా చేయడానికి. / మరియు అంశాలను మార్పిడి చేసేందుకు సాధ్యం అని నిర్ణయిస్తుంది /ఈ సమస్యలో, మీరు రెండు సంఖ్యల శ్రేణులను తీసుకునే ఫంక్షన్ను అమలు చేస్తారు, // >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
// ""YES""
// >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
// ""NO""
// It is assumed that the input arrays will be non-empty.
function exchange(lst1, lst2){
","function exchange(lst1, lst2) {
    // Check if lst1 already consists of only even numbers
    let allEvenLst1 = lst1.every(num => num % 2 === 0);
    if (allEvenLst1) return ""YES"";
    
    // Check if there's at least one even number in lst2
    let hasEvenInLst2 = lst2.some(num => num % 2 === 0);
    
    // If there is at least one even number in lst2, it's possible to perform an exchange
    // to make all elements in lst1 even
    if (hasEvenInLst2) return ""YES"";
    
    // If no conditions above are met, it's not possible to make lst1 all even
    return ""NO"";
}","const assert = require('node:assert');


function test() {
  let candidate = exchange;
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),""YES"");
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),""NO"");
  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),""NO"");
  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),""NO"");
  assert.deepEqual(candidate([100, 200], [200, 200]),""YES"");
}

test();"
HumanEval_111,tel_Telu,js,"/ ఉదాహరణ: / అనేక అక్షరాలు ఒకేలా సంభవించినట్లయితే, వాటిని అన్నింటినీ తిరిగి ఇవ్వండి. / ఎక్కువ సార్లు పునరావృతమయ్యే అక్షరం మరియు దానికి అనుగుణంగా ఉన్న సంఖ్య. / స్పేస్ వేరుచేసిన చిన్న అక్షరాలను సూచించే స్ట్రింగ్ ఇచ్చినట్లయితే, ఒక వస్తువును తిరిగి ఇవ్వండి // >>> histogram(""a b c"")
// {""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// {""b"": 4}
// >>> histogram("""")
// {}
function histogram(test){
","function histogram(test) {
  if (!test) return {};
  
  const letters = test.split(' ');
  const letterCount = {};
  
  for (let letter of letters) {
    if (letterCount[letter]) {
      letterCount[letter]++;
    } else {
      letterCount[letter] = 1;
    }
  }
  
  let maxCount = 0;
  for (let count of Object.values(letterCount)) {
    if (count > maxCount) {
      maxCount = count;
    }
  }
  
  const result = {};
  for (let [letter, count] of Object.entries(letterCount)) {
    if (count === maxCount) {
      result[letter] = count;
    }
  }
  
  return result;
}","const assert = require('node:assert');


function test() {
  let candidate = histogram;
  assert.deepEqual(candidate(""a b b a""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c a b""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c d g""),{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""b b b b a""),{""b"": 4});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""""),{});
  assert.deepEqual(candidate(""a""),{""a"": 1});
}

test();"
HumanEval_112,tel_Telu,js,"/ ఉదాహరణ / మీరు ఫలిత స్ట్రింగ్ మరియు చెక్ కోసం true/false కలిగి ఉన్న ఒక శ్రేణిని తిరిగి ఇవ్వాలి. / ఒక స్ట్రింగ్ ను పాలిండ్రోమ్ అంటారు, అది ముందు మరియు వెనుకకు ఒకే విధంగా చదివితే./ అప్పుడు ఫలిత స్ట్రింగ్ పాలిండ్రోమ్ కాదా అని తనిఖీ చేయండి. / మాకు రెండు స్ట్రింగ్స్ s మరియు c ఇవ్వబడ్డాయి, మీరు s లోని అన్ని అక్షరాలను తొలగించాలి c లోని ఏ అక్షరానికి సమానం /పని // >>> reverse_delete(""abcde"", ""ae"")
// [""bcd"", false]
// >>> reverse_delete(""abcdef"", ""b"")
// [""acdef"", false]
// >>> reverse_delete(""abcdedcba"", ""ab"")
// [""cdedc"", true]
function reverse_delete(s, c){
","function reverse_delete(s, c) {
    let result = '';
    // Create a set of characters to be deleted
    const deleteChars = new Set(c);
    
    // Construct the result string excluding the characters in c
    for (let char of s) {
        if (!deleteChars.has(char)) {
            result += char;
        }
    }
    
    // Check if the result string is a palindrome
    const isPalindrome = result === result.split('').reverse().join('');
    
    return [result, isPalindrome];
}","const assert = require('node:assert');


function test() {
  let candidate = reverse_delete;
  assert.deepEqual(candidate(""abcde"", ""ae""),[""bcd"", false]);
  assert.deepEqual(candidate(""abcdef"", ""b""),[""acdef"", false]);
  assert.deepEqual(candidate(""abcdedcba"", ""ab""),[""cdedc"", true]);
  assert.deepEqual(candidate(""dwik"", ""w""),[""dik"", false]);
  assert.deepEqual(candidate(""a"", ""a""),["""", true]);
  assert.deepEqual(candidate(""abcdedcba"", """"),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""abcdedcba"", ""v""),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""vabba"", ""v""),[""abba"", true]);
  assert.deepEqual(candidate(""mamma"", ""mia""),["""", true]);
}

test();"
HumanEval_113,tel_Telu,js,"/ ఇన్పుట్ యొక్క i'th స్ట్రింగ్ లో బేసి అంకెలు. / ఇన్పుట్ యొక్క స్ట్రింగ్ i. "" ఇక్కడ అన్ని i లు సంఖ్య ద్వారా భర్తీ చేయాలి / అవుట్పుట్ యొక్క ప్రతి మూలకం i అనేది  లోని అసమాన మూలకాల సంఖ్య./ఇది ఒక స్ట్రింగ్స్ యొక్క శ్రేణి, ఇక్కడ ప్రతి స్ట్రింగ్లో కేవలం అంకెలు మాత్రమే ఉంటాయి, ఒక శ్రేణిని తిరిగి ఇవ్వండి.// >>> odd_count([""1234567""])
// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
// >>> odd_count([""3"", ""11111111""])
// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
function odd_count(lst){
","function odd_count(lst) {
    return lst.map(str => {
        const oddCount = Array.from(str).filter(ch => parseInt(ch) % 2 !== 0).length;
        let sentence = ""the number of odd elements in the string i of the input."";
        return sentence.replace(/i/g, oddCount.toString());
    });
}","const assert = require('node:assert');


function test() {
  let candidate = odd_count;
  assert.deepEqual(candidate([""1234567""]),[""the number of odd elements 4n the str4ng 4 of the 4nput.""]);
  assert.deepEqual(candidate([""3"", ""11111111""]),[""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]);
  assert.deepEqual(candidate([""271"", ""137"", ""314""]),[""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""]);
}

test();"
HumanEval_114,tel_Telu,js,"/ ఉదాహరణ / సంఖ్యల /ఇంటిగెర్స్ నం యొక్క శ్రేణిని ఇచ్చినట్లయితే, ఏదైనా ఖాళీ కాని ఉప శ్రేణి యొక్క కనీస మొత్తాన్ని కనుగొనండి // >>> minSubArraySum([2, 3, 4, 1, 2, 4])
// 1
// >>> minSubArraySum([-1, -2, -3])
// -6
function minSubArraySum(nums){
","function minSubArraySum(nums) {
    let minSum = nums[0];
    let currentSum = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        if (currentSum > 0) {
            currentSum = nums[i];
        } else {
            currentSum += nums[i];
        }
        minSum = Math.min(minSum, currentSum);
    }
    
    return minSum;
}","const assert = require('node:assert');


function test() {
  let candidate = minSubArraySum;
  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);
  assert.deepEqual(candidate([-1, -2, -3]),-6);
  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);
  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);
  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);
  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);
  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);
  assert.deepEqual(candidate([-10]),-10);
  assert.deepEqual(candidate([7]),7);
  assert.deepEqual(candidate([1, -1]),-1);
}

test();"
HumanEval_115,tel_Telu,js,"/ ఉదాహరణ 1: / మీరు డబ్బాలు డౌన్ అవసరం సార్లు సంఖ్య అవుట్పుట్. / మీ పని బావులు ఖాళీ చేయడానికి బకెట్లు ఉపయోగించడానికి ఉంది. / మరియు అన్ని బకెట్ అదే సామర్థ్యం కలిగి. / ప్రతి బావిలో దాని నుండి నీరు సేకరించేందుకు ఉపయోగించే ఒక సంబంధిత బకెట్ ఉంది, / మరియు వరుసలో ఉన్న ప్రతి 1 ఒక్క నీటి యూనిట్ను సూచిస్తుంది. మీకు బావుల యొక్క దీర్ఘచతురస్రాకార గ్రిడ్ ఇవ్వబడుతుంది. ప్రతి వరుస ఒక్క బావిని సూచిస్తుంది,// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
// 6
// Example 2:
// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
// 5
// Example 3:
// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
function max_fill(grid, capacity){
","function max_fill(grid, capacity) {
    let totalWater = 0;
    
    for (let row of grid) {
        for (let cell of row) {
            totalWater += cell;
        }
    }
    
    return Math.ceil(totalWater / capacity);
}","const assert = require('node:assert');


function test() {
  let candidate = max_fill;
  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);
  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);
  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);
}

test();"
HumanEval_116,tel_Telu,js,"/ ఇది ఇలా అమలు చేయాలి: / సమాన సంఖ్యలో ఉన్న వాటి కోసం, దశాంశ విలువ ఆధారంగా క్రమబద్ధీకరించండి. / సంఖ్యలు వారి బైనరీ ప్రాతినిధ్యంలో పెరుగుతున్న క్రమంలో. / ఈ కాటాలో, మీరు  ప్రకారం ప్రతికూల-కాని పూర్ణాంకాల శ్రేణిని క్రమబద్ధీకరించాలి// >>> sort_array([1, 5, 2, 3, 4])
// [1, 2, 3, 4, 5]
// >>> sort_array([-2, -3, -4, -5, -6])
// [-6, -5, -4, -3, -2]
// >>> sort_array([1, 0, 2, 3, 4])
// [0, 1, 2, 3, 4]
function sort_array(arr){
","function sort_array(arr) {
    return arr.slice().sort((a, b) => {
        const countOnes = num => num.toString(2).split('0').join('').length;
        const onesA = countOnes(a);
        const onesB = countOnes(b);
        if (onesA === onesB) {
            return a - b;
        }
        return onesA - onesB;
    });
}","const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);
  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);
  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
}

test();"
HumanEval_117,tel_Telu,js,"/ ఉదాహరణలు: / గమనిక: మీరు ఇన్పుట్ స్ట్రింగ్ అక్షరాలు మరియు ఖాళీలు మాత్రమే కలిగి ఉన్నట్లు భావించవచ్చు. / స్ట్రింగ్ s ఖాళీగా ఉంటే ఫంక్షన్ ఖాళీ శ్రేణిని తిరిగి ఇవ్వాలి. / n అచ్చులు, ఈ పదాలు స్ట్రింగ్ s లో కనిపిస్తాయి. / ఒక ఫంక్షన్ ఇది సరిగ్గా కలిగి స్ట్రింగ్ s నుండి అన్ని పదాల శ్రేణిని తిరిగి ఇస్తుంది / ఒక స్ట్రింగ్ s మరియు ఒక సహజ సంఖ్య n ఇచ్చిన, మీరు అమలు // >>> select_words(""Mary had a little lamb"", 4)
// [""little""]
// >>> select_words(""Mary had a little lamb"", 3)
// [""Mary"", ""lamb""]
// >>> select_words(""simple white space"", 2)
// []
// >>> select_words(""Hello world"", 4)
// [""world""]
// >>> select_words(""Uncle sam"", 3)
// [""Uncle""]
function select_words(s, n){
","function select_words(s, n) {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
    const words = s.split(' ');
    const result = [];

    for (let word of words) {
        let consonantCount = 0;
        
        for (let char of word) {
            if (!vowels.has(char)) {
                consonantCount += 1;
            }
        }

        if (consonantCount === n) {
            result.push(word);
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = select_words;
  assert.deepEqual(candidate(""Mary had a little lamb"", 4),[""little""]);
  assert.deepEqual(candidate(""Mary had a little lamb"", 3),[""Mary"", ""lamb""]);
  assert.deepEqual(candidate(""simple white space"", 2),[]);
  assert.deepEqual(candidate(""Hello world"", 4),[""world""]);
  assert.deepEqual(candidate(""Uncle sam"", 3),[""Uncle""]);
  assert.deepEqual(candidate("""", 4),[]);
  assert.deepEqual(candidate(""a b c d e f"", 1),[""b"", ""c"", ""d"", ""f""]);
}

test();"
HumanEval_118,tel_Telu,js,"/ ఉదాహరణ: / ఇచ్చిన స్ట్రింగ్లో ఆంగ్ల అక్షరం మాత్రమే ఉందని మీరు అనుకోవచ్చు. / పైన పేర్కొన్న పరిస్థితిని ఏ స్వరం కలుసుకున్నారో కనుగొనండి. / ప్రారంభంలో అచ్చులు మరియు ముగింపు లెక్కించబడవు. మీరు లేకపోతే ఖాళీ స్ట్రింగ్ తిరిగి / రెండు హల్లులు పదానికి కుడి వైపు నుండి (కేస్ సెన్సిటివ్).మీరు ఒక పదం ఇవ్వబడుతుంది. మీ పని మధ్య నిలబడి సమీప అచ్చు కనుగొనేందుకు ఉంది.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
function get_closest_vowel(word){
","function get_closest_vowel(word) {
    const vowels = ""aeiouAEIOU"";

    for (let i = word.length - 2; i > 0; i--) {
        if (vowels.includes(word[i]) && 
            !vowels.includes(word[i - 1]) && 
            !vowels.includes(word[i + 1])) {
            return word[i];
        }
    }

    return """";
}","const assert = require('node:assert');


function test() {
  let candidate = get_closest_vowel;
  assert.deepEqual(candidate(""yogurt""),""u"");
  assert.deepEqual(candidate(""full""),""u"");
  assert.deepEqual(candidate(""easy""),"""");
  assert.deepEqual(candidate(""eAsy""),"""");
  assert.deepEqual(candidate(""ali""),"""");
  assert.deepEqual(candidate(""bad""),""a"");
  assert.deepEqual(candidate(""most""),""o"");
  assert.deepEqual(candidate(""ab""),"""");
  assert.deepEqual(candidate(""ba""),"""");
  assert.deepEqual(candidate(""quick""),"""");
  assert.deepEqual(candidate(""anime""),""i"");
  assert.deepEqual(candidate(""Asia""),"""");
  assert.deepEqual(candidate(""Above""),""o"");
}

test();"
HumanEval_119,tel_Telu,js,"/ ఉదాహరణలు: / ఒక మంచి స్ట్రింగ్ చేయడానికి ఒక మార్గం ఉంటే 'అవును' తిరిగి, మరియు లేకపోతే 'నో' తిరిగి. / ""()) "" కాదు. / సమతుల్యంగా ఉంటాయి. ఉదాహరణకు: స్ట్రింగ్ '(()))) మంచిది, అయితే స్ట్రింగ్ / ఒక స్ట్రింగ్ S లోని అన్ని బ్రాంచీలు ఉంటే మరియు మాత్రమే S మంచిగా పరిగణించబడుతుంది / కొన్ని క్రమంలో, ఫలితంగా స్ట్రింగ్ మంచి ఉంటుంది. / మీ పని రెండు తీగలను కలిపి ఉంచడం సాధ్యమేనా అని తనిఖీ చేయడం / కుండలీకరణాలు "" (("" లేదా దగ్గరి కుండలీకరణాలు "") "" మాత్రమే./ మీరు రెండు తీగలను ఒక శ్రేణి ఇవ్వబడుతుంది, రెండు తీగలను కలిగి ఓపెన్ // >>> match_parens([""()("", "")""])
// ""Yes""
// >>> match_parens(["")"", "")""])
// ""No""
function match_parens(lst){
","function match_parens(lst) {
    function isBalanced(str) {
        let balance = 0;
        for (let char of str) {
            if (char === '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) return false;
        }
        return balance === 0;
    }

    const [s1, s2] = lst;
    if (isBalanced(s1 + s2) || isBalanced(s2 + s1)) {
        return 'Yes';
    }
    return 'No';
}","const assert = require('node:assert');


function test() {
  let candidate = match_parens;
  assert.deepEqual(candidate([""()("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", "")""]),""No"");
  assert.deepEqual(candidate([""(()(())"", ""())())""]),""No"");
  assert.deepEqual(candidate(["")())"", ""(()()(""]),""Yes"");
  assert.deepEqual(candidate([""(())))"", ""(()())((""]),""Yes"");
  assert.deepEqual(candidate([""()"", ""())""]),""No"");
  assert.deepEqual(candidate([""(()("", ""()))()""]),""Yes"");
  assert.deepEqual(candidate([""(((("", ""((())""]),""No"");
  assert.deepEqual(candidate(["")(()"", ""(()(""]),""No"");
  assert.deepEqual(candidate(["")("", "")(""]),""No"");
  assert.deepEqual(candidate([""("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", ""(""]),""Yes"");
}

test();"
HumanEval_120,tel_Telu,js,"/ ఉదాహరణ 1: / పొడవు k తో గరిష్టంగా k సంఖ్యలు arr లో. / పూర్ణాంకాల శ్రేణి arr మరియు సానుకూల పూర్ణాంకం k ఇచ్చినట్లయితే, క్రమబద్ధీకరించిన శ్రేణిని తిరిగి ఇవ్వండి // >>> maximum([-3, -4, 5], 3)
// [-4, -3, 5]
// Example 2:
// >>> maximum([4, -4, 4], 2)
// [4, 4]
// Example 3:
// >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)
// [2]
// Note:
// 1. The length of the array will be in the range of [1, 1000].
// 2. The elements in the array will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
function maximum(arr, k){
","function maximum(arr, k) {
    return arr.sort((a, b) => b - a).slice(0, k).sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = maximum;
  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);
  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);
  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);
  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);
  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);
  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);
  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);
  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);
  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);
  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);
  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);
}

test();"
HumanEval_121,tel_Telu,js,"/ ఉదాహరణలు / ఖాళీ కాని పూర్ణాంకాల శ్రేణిని ఇచ్చినట్లయితే, సమాన స్థానాల్లో ఉన్న అన్ని బేసి మూలకాల మొత్తాన్ని తిరిగి ఇవ్వండి.// >>> solution([5, 8, 7, 1])
// 12
// >>> solution([3, 3, 3, 3, 3])
// 9
// >>> solution([30, 13, 24, 321])
// 0
function solution(lst){
","function solution(lst) {
    let sum = 0;
    for (let i = 0; i < lst.length; i += 2) {
        if (lst[i] % 2 !== 0) {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = solution;
  assert.deepEqual(candidate([5, 8, 7, 1]),12);
  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);
  assert.deepEqual(candidate([30, 13, 24, 321]),0);
  assert.deepEqual(candidate([5, 9]),5);
  assert.deepEqual(candidate([2, 4, 8]),0);
  assert.deepEqual(candidate([30, 13, 23, 32]),23);
  assert.deepEqual(candidate([3, 13, 2, 9]),3);
}

test();"
HumanEval_122,tel_Telu,js,"/ ఉదాహరణ: / arr యొక్క మొదటి k మూలకాల నుండి గరిష్టంగా రెండు అంకెలతో ఉన్న మూలకాల మొత్తం. /అంతర్ సంఖ్యల యొక్క ఖాళీ కాని శ్రేణి arr మరియు పూర్ణాంకం k ఇచ్చినట్లయితే, తిరిగి // >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
function add_elements(arr, k){
","function add_elements(arr, k) {
    let sum = 0;
    for (let i = 0; i < k; i++) {
        if (Math.abs(arr[i]) < 100) {
            sum += arr[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = add_elements;
  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);
  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);
  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);
  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);
  assert.deepEqual(candidate([1], 1),1);
}

test();"
HumanEval_123,tel_Telu,js,"/ get_odd_collatz(5) తిరిగి [1, 5] # 5 కొరకు collatz వరుస [5, 16, 8, 4, 2, 1], కాబట్టి బేసి సంఖ్యలు 1, మరియు 5 మాత్రమే. / ఉదాహరణకి: / 2. తిరిగి వచ్చిన శ్రేణి క్రమంలో క్రమబద్ధీకరించబడింది. / 1. కోలట్జ్ ((1) అనేది [1]. / గమనిక: / పదము + 1. n యొక్క విలువ ఏమైనప్పటికీ, ఈ క్రమము ఎల్లప్పుడూ 1 కి చేరుకుంటుంది./ మునుపటి పదము. మునుపటి పదము బేసి అయితే, తదుపరి పదము మునుపటి 3 సార్లు / మునుపటి పదము ఈ విధంగా ఉంటుంది: మునుపటి పదము జత అయితే, తదుపరి పదము లో సగం అవుతుంది./ ఈ క్రింది విధంగాః ఏదైనా సానుకూల పూర్ణాంకం n తో ప్రారంభించండి. అప్పుడు ప్రతి పదం  నుండి లభిస్తుంది./ కొల్లాట్జ్ ఊహ అనేది గణిత శాస్త్రంలో ఒక ఊహ , ఇది ఒక నిర్వచించిన వరుసను సూచిస్తుంది /ఒక సానుకూల పూర్ణాంకం n ఇచ్చినట్లయితే, ఒక క్రమబద్ధీకరించిన శ్రేణిని తిరిగి ఇవ్వండి, అది కోలాట్జ్ వరుసలో బేసి సంఖ్యలను కలిగి ఉంటుంది. // >>> get_odd_collatz(5)
// [1, 5]
function get_odd_collatz(n){
","function get_odd_collatz(n) {
    let collatzSequence = [];
    while (n !== 1) {
        if (n % 2 !== 0) {
            collatzSequence.push(n);
        }
        n = n % 2 === 0 ? n / 2 : 3 * n + 1;
    }
    collatzSequence.push(1); // Include 1 as it's part of the sequence and is odd
    return collatzSequence.sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = get_odd_collatz;
  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(5),[1, 5]);
  assert.deepEqual(candidate(12),[1, 3, 5]);
  assert.deepEqual(candidate(1),[1]);
}

test();"
HumanEval_124,tel_Telu,js,"/ 4. తేదీని ఈ ఫార్మాట్లో రాయాలి: mm-dd-yyyy / 3. నెలలు 1 కన్నా తక్కువ లేదా 12 కన్నా ఎక్కువ ఉండకూడదు./ 2. నెల 1,3,5,7,8,10,12 లకు రోజుల సంఖ్య 1 కన్నా తక్కువ లేదా 31 రోజుల కంటే ఎక్కువ కాదు. నెల 4,6,9,11 లకు రోజుల సంఖ్య 1 కన్నా తక్కువ లేదా 30 రోజుల కంటే ఎక్కువ కాదు. నెల 2 కోసం రోజుల సంఖ్య 1 కన్నా తక్కువ లేదా 29 రోజుల కంటే ఎక్కువ కాదు./ 1. తేదీ స్ట్రింగ్ ఖాళీగా లేదు. / కింది నియమాలన్నీ నెరవేర్చినట్లయితే తేదీ చెల్లుతుంది: / తేదీ చెల్లుబాటు అయితే true గా తిరిగి వస్తుంది లేకపోతే false అవుతుంది. / మీరు ఇచ్చిన తేదీ స్ట్రింగ్ను ధృవీకరించే ఫంక్షన్ను వ్రాయాలి మరియు // >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
function valid_date(date){
","function valid_date(date) {
    if (!date) return false;
    
    // Regular expression to match the date pattern mm-dd-yyyy
    const datePattern = /^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\d{4}$/;
    if (!datePattern.test(date)) return false;

    // Split the date into parts
    const [month, day, year] = date.split('-').map(Number);

    // Check the valid number of days per month
    if (month === 2) {
        // Check for February, normally 28 max days, 29 if leap year
        const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        if (day > 29 || (day === 29 && !isLeapYear)) return false;
    } else if ([4, 6, 9, 11].includes(month)) {
        // April, June, September, November have 30 max days
        if (day > 30) return false;
    } else {
        // Other months have 31 max days
        if (day > 31) return false;
    }

    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = valid_date;
  assert.deepEqual(candidate(""03-11-2000""),true);
  assert.deepEqual(candidate(""15-01-2012""),false);
  assert.deepEqual(candidate(""04-0-2040""),false);
  assert.deepEqual(candidate(""06-04-2020""),true);
  assert.deepEqual(candidate(""01-01-2007""),true);
  assert.deepEqual(candidate(""03-32-2011""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""04-31-3000""),false);
  assert.deepEqual(candidate(""06-06-2005""),true);
  assert.deepEqual(candidate(""21-31-2000""),false);
  assert.deepEqual(candidate(""04-12-2003""),true);
  assert.deepEqual(candidate(""04122003""),false);
  assert.deepEqual(candidate(""20030412""),false);
  assert.deepEqual(candidate(""2003-04""),false);
  assert.deepEqual(candidate(""2003-04-12""),false);
  assert.deepEqual(candidate(""04-2003""),false);
}

test();"
HumanEval_125,tel_Telu,js,"/ ఉదాహరణలు / అక్షరమాల, ఆర్డియమ్ a') = 0, ఆర్డియమ్ b') = 1, . . . ఆర్డియమ్ z') = 25 / కామాలతో విభజించబడాలి ',' కామాలు లేకుంటే మీరు  లో అసమాన క్రమంలో చిన్న అక్షరాల సంఖ్యను తిరిగి ఇవ్వాలి/ పదాల స్ట్రింగ్ ఇచ్చిన, మీరు టెక్స్ట్ లో ఏ శ్వేతజాతీయులు ఉనికిలో ఉంటే, శ్వేతజాతీయులు విభజించబడింది పదాల శ్రేణి తిరిగి // >>> split_words(""Hello world!"")
// [""Hello"", ""world!""]
// >>> split_words(""Hello,world!"")
// [""Hello"", ""world!""]
// >>> split_words(""abcdef"")
// 3
function split_words(txt){
","function split_words(txt) {
    if (/\s/.test(txt)) {
        // Split on whitespace if it exists
        return txt.split(/\s+/);
    } else if (/,/.test(txt)) {
        // Split on commas if no whitespace exists
        return txt.split(',');
    } else {
        // Return count of lowercase letters with odd order in the alphabet
        let oddOrderCount = 0;
        for (let i = 0; i < txt.length; i++) {
            let char = txt[i];
            if (char >= 'a' && char <= 'z') {
                let order = char.charCodeAt(0) - 'a'.charCodeAt(0);
                if (order % 2 !== 0) {
                    oddOrderCount++;
                }
            }
        }
        return oddOrderCount;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = split_words;
  assert.deepEqual(candidate(""Hello world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello,world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello world,!""),[""Hello"", ""world,!""]);
  assert.deepEqual(candidate(""Hello,Hello,world !""),[""Hello,Hello,world"", ""!""]);
  assert.deepEqual(candidate(""abcdef""),3);
  assert.deepEqual(candidate(""aaabb""),2);
  assert.deepEqual(candidate(""aaaBb""),1);
  assert.deepEqual(candidate(""""),0);
}

test();"
HumanEval_126,tel_Telu,js,"/ ఉదాహరణలు / సంఖ్య, తిరిగి false. ప్రతికూల సంఖ్యలు మరియు పూర్ణాంకాలు మాత్రమే తీసుకోకండి./ క్రమంలో పెరుగుతుంది. శ్రేణిలో ఒకటి కంటే ఎక్కువ నకిలీలు ఉంటే అదే / సంఖ్యల శ్రేణిని ఇచ్చినట్లయితే, అవి క్రమబద్ధీకరించబడినా లేదా తిరిగి ఇవ్వబడతాయి // >>> is_sorted([5])
// true
// >>> is_sorted([1, 2, 3, 4, 5])
// true
// >>> is_sorted([1, 3, 2, 4, 5])
// false
// >>> is_sorted([1, 2, 3, 4, 5, 6])
// true
// >>> is_sorted([1, 2, 3, 4, 5, 6, 7])
// true
// >>> is_sorted([1, 3, 2, 4, 5, 6, 7])
// false
// >>> is_sorted([1, 2, 2, 3, 3, 4])
// true
// >>> is_sorted([1, 2, 2, 2, 3, 4])
// false
function is_sorted(lst){
","function is_sorted(lst) {
    if (lst.length <= 1) return true;

    for (let i = 0; i < lst.length - 1; i++) {
        if (lst[i] > lst[i + 1]) {
            return false;
        }
        if (lst[i] === lst[i + 1]) {
            // Check if more than 1 duplicate by looking two steps ahead
            if (i + 2 < lst.length && lst[i] === lst[i + 2]) {
                return false;
            }
        }
    }
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_sorted;
  assert.deepEqual(candidate([5]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);
  assert.deepEqual(candidate([]),true);
  assert.deepEqual(candidate([1]),true);
  assert.deepEqual(candidate([3, 2, 1]),false);
  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);
  assert.deepEqual(candidate([1, 2, 3, 4]),true);
}

test();"
HumanEval_127,tel_Telu,js,"/ [ఇన్పుట్/అవుట్పుట్] నమూనాలు: / రెండు విరామాలు కలుసుకోకపోతే, ""NO"" ను తిరిగి ఇవ్వండి./ లేకపోతే, ""NO"" అని తిరిగి ఇవ్వండి./ ఖండన యొక్క పొడవు ఒక ప్రధాన సంఖ్య అయితే, ""YES"" తిరిగి ఇవ్వండి, / దీని పొడవు 1 , ఇది ఒక ప్రధాన సంఖ్య కాదు. / ఉదాహరణ, విరామాల ఖండన (1, 3), (2, 4) (2, 3) / విరామాలు ఒక ప్రధాన సంఖ్య. / మీ పని ఈ రెండు యొక్క ఖండన యొక్క పొడవు లేదో గుర్తించడానికి ఉంది / ప్రతి ఇచ్చిన విరామం కోసం, దాని ప్రారంభం దాని ముగింపు కంటే తక్కువగా లేదా సమానంగా ఉంటుందని భావించబడుతుంది. / ప్రారంభం మరియు ముగింపు రెండింటినీ కలిగి ఉంటుంది. / ఇచ్చిన విరామాలు మూసివేయబడ్డాయి అంటే విరామం (ప్రారంభం, ముగింపు) / ఇక్కడ ప్రతి విరామం ఒక జత పూర్ణాంకాలు. ఉదాహరణకు, విరామం = (ప్రారంభం, ముగింపు) = (1, 2)./మీరు రెండు విరామాలు ఇవ్వబడ్డాయి, // >>> intersection([1, 2], [2, 3])
// ""NO""
// >>> intersection([-1, 1], [0, 4])
// ""NO""
// >>> intersection([-3, -1], [-5, 5])
// ""YES""
function intersection(interval1, interval2){
","function intersection(interval1, interval2) {
    const [start1, end1] = interval1;
    const [start2, end2] = interval2;

    // Determine the start and end of the intersection
    const startIntersection = Math.max(start1, start2);
    const endIntersection = Math.min(end1, end2);

    // Calculate the length of the intersection
    const intersectionLength = endIntersection - startIntersection;

    // Helper function to check if a number is prime
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    // Check if the length of the intersection is a prime number
    return intersectionLength > 0 && isPrime(intersectionLength) ? ""YES"" : ""NO"";
}","const assert = require('node:assert');


function test() {
  let candidate = intersection;
  assert.deepEqual(candidate([1, 2], [2, 3]),""NO"");
  assert.deepEqual(candidate([-1, 1], [0, 4]),""NO"");
  assert.deepEqual(candidate([-3, -1], [-5, 5]),""YES"");
  assert.deepEqual(candidate([-2, 2], [-4, 0]),""YES"");
  assert.deepEqual(candidate([-11, 2], [-1, -1]),""NO"");
  assert.deepEqual(candidate([1, 2], [3, 5]),""NO"");
  assert.deepEqual(candidate([1, 2], [1, 2]),""NO"");
  assert.deepEqual(candidate([-2, -2], [-3, -2]),""NO"");
}

test();"
HumanEval_128,tel_Telu,js,"/ ఉదాహరణ: / గమనిక: ఖాళీ arr కోసం నిర్వచించబడని తిరిగి. / శ్రేణిలోని ప్రతి సంఖ్యను 1, -1 లేదా 0 ద్వారా సూచిస్తారు. / పూర్ణాంకాల పరిమాణాల మొత్తాన్ని అన్ని సంకేతాల ఉత్పత్తితో గుణించడం /మీరు పూర్ణాంకాల యొక్క ఒక శ్రేణిని ఇవ్వబడుతుంది మరియు మీరు తిరిగి రావాలి // >>> prod_signs([1, 2, 2, -4])
// 9
// >>> prod_signs([0, 1])
// 0
// >>> prod_signs([])
// undefined
function prod_signs(arr){
","function prod_signs(arr) {
    if (arr.length === 0) return undefined;

    let sumOfMagnitudes = 0;
    let productOfSigns = 1;

    for (let num of arr) {
        sumOfMagnitudes += Math.abs(num);
        productOfSigns *= (num === 0 ? 0 : Math.sign(num));
    }

    return sumOfMagnitudes * productOfSigns;
}","const assert = require('node:assert');


function test() {
  let candidate = prod_signs;
  assert.deepEqual(candidate([1, 2, 2, -4]),-9);
  assert.deepEqual(candidate([0, 1]),0);
  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);
  assert.deepEqual(candidate([-1, 1, -1, 1]),4);
  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);
  assert.deepEqual(candidate([-1, 1, 1, 0]),0);
}

test();"
HumanEval_129,tel_Telu,js,"/ ఉదాహరణలు: / కనీస మార్గం వెళ్ళే కణాలపై విలువల క్రమబద్ధమైన శ్రేణిని తిరిగి ఇవ్వండి. / సమాధానం ప్రత్యేకం అని హామీ ఇస్తున్నారు. / lst_A[j] = lst_B[j]  అని రాస్తారు./ lst_A[i] < lst_B[i] మరియు ఏదైనా j (1 <= j < i) కోసం మనకు / lst_B కన్నా, మరో మాటలో చెప్పాలంటే, i (1 <= i <= k) అనే పూర్ణాంక సూచిక ఉంది./ ద్వారా (వాటిని lst_A మరియు lst_B అని పిలుద్దాం), lst_A పదజాలపరంగా తక్కువ / A మరియు B వెళ్ళే కణాలపై విలువలు క్రమబద్ధీకరించిన శ్రేణులను చేసిన తరువాత / ఒక మార్గం A (పొడవు k) ఒక మార్గం B (పొడవు k) కంటే తక్కువగా పరిగణించబడుతుంది, / మీరు గ్రిడ్ ఆఫ్ వెళ్ళడానికి కాదు. / తప్పనిసరిగా వేరు వేరుగా ఉంటాయి)./ దయచేసి k పొడవు యొక్క మార్గం సరిగ్గా k కణాలను సందర్శిస్తుందని గమనించండి (కాదు / సెల్. / ఇతర మాటలలో, మీరు ప్రస్తుత ఒక అంచు పంచుకునే కణాలు వెళ్ళవచ్చు / ఏ సెల్ నుండి, మరియు ప్రతి దశలో మీరు పొరుగు కణాలు ఏ తరలించవచ్చు, మీరు గ్రిడ్ లో పొడవు k యొక్క కనీస మార్గం కనుగొనేందుకు కలిగి. మీరు ప్రారంభించవచ్చు / inclusive గ్రిడ్లోని కణాలలో సరిగ్గా ఒకసారి కనిపిస్తుంది./ గ్రిడ్ యొక్క ప్రతి సెల్ ఒక విలువను కలిగి ఉంటుంది. [1, N * N] పరిధిలోని ప్రతి పూర్ణాంకం /N వరుసలు మరియు N నిలువు వరుసలు (N >= 2) మరియు సానుకూల పూర్ణాంకం k ఉన్న గ్రిడ్ ఇచ్చినట్లయితే, // >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
// [1, 2, 1]
// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
// [1]
function minPath(grid, k){
","function minPath(grid, k) {
    const N = grid.length;
    const directions = [
        [0, 1], // right
        [1, 0], // down
        [0, -1], // left
        [-1, 0]  // up
    ];
    
    let minPathResult = Array(k).fill(Infinity);

    function dfs(x, y, path) {
        if (path.length === k) {
            // Check if the current path is lexicographically smaller
            if (comparePaths(path, minPathResult)) {
                minPathResult = [...path];
            }
            return;
        }

        for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {
                path.push(grid[nx][ny]);
                dfs(nx, ny, path);
                path.pop();
            }
        }
    }
    
    function comparePaths(pathA, pathB) {
        for (let i = 0; i < pathA.length; i++) {
            if (pathA[i] < pathB[i]) return true;
            if (pathA[i] > pathB[i]) return false;
        }
        return false;
    }

    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            dfs(i, j, [grid[i][j]]);
        }
    }

    return minPathResult;
}","const assert = require('node:assert');


function test() {
  let candidate = minPath;
  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);
  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);
  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);
  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);
  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);
  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);
  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);
  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);
  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

test();"
HumanEval_130,tel_Telu,js,"/ ఉదాహరణలు: / ట్రిబోనాచి వరుస యొక్క మొదటి n + 1 సంఖ్యలు. మీకు ఒక ప్రతికూల సంఖ్య n ఇవ్వబడినది, మీరు ఒక శ్రేణిని తిరిగి ఇవ్వాలి/ = 2 + 3 + 3 = 8 / త్రి) = త్రి) + త్రి) + త్రి)/ త్రి () = 3 / త్రి () = 1 + (2 / 2) = 2 / ఉదాహరణకి: / tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), n బేసి అయితే./ tri (n) = 1 + n / 2, n జత సంఖ్య అయితే./ త్రి () = 3 / ట్రిబోనాక్సీ సీక్వెన్స్ పునరావృతంతో నిర్వచించబడింది: అయితే, ప్రజలకు తెలియనిది ట్రిబొనాచి క్రమం.ఫిబోనాచి వరుస అందరికీ తెలుసు, దీనిని గణిత శాస్త్రజ్ఞులు లోతుగా అధ్యయనం చేశారు.// >>> tri(3)
// [1, 3, 2, 8]
function tri(n){
","function tri(n) {
    if (n < 0) return [];
    
    let tribonacci = new Array(n + 1);

    for (let i = 0; i <= n; i++) {
        if (i === 1) {
            tribonacci[i] = 3;
        } else if (i % 2 === 0) {
            tribonacci[i] = 1 + i / 2;
        } else {
            tribonacci[i] = 
                (tribonacci[i - 1] !== undefined ? tribonacci[i - 1] : 0) + 
                (tribonacci[i - 2] !== undefined ? tribonacci[i - 2] : 0) + 
                (tribonacci[i + 1] !== undefined ? tribonacci[i + 1] : 0);
        }
    }

    return tribonacci;
}","const assert = require('node:assert');


function test() {
  let candidate = tri;
  assert.deepEqual(candidate(3),[1, 3, 2, 8]);
  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);
  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);
  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);
  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);
  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);
  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
  assert.deepEqual(candidate(0),[1]);
  assert.deepEqual(candidate(1),[1, 3]);
}

test();"
HumanEval_131,tel_Telu,js,"/ ఉదాహరణకి: / అన్ని అంకెలు జత అయితే 0 ను తిరిగి ఇవ్వండి. /ఒక సానుకూల పూర్ణాంకం n ఇచ్చినట్లయితే, బేసి అంకెల యొక్క ఉత్పత్తిని తిరిగి ఇవ్వండి. // >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
function digits(n){
","function digits(n) {
    let product = 1;
    let hasOdd = false;

    while (n > 0) {
        let digit = n % 10;
        if (digit % 2 !== 0) {
            product *= digit;
            hasOdd = true;
        }
        n = Math.floor(n / 10);
    }

    return hasOdd ? product : 0;
}","const assert = require('node:assert');


function test() {
  let candidate = digits;
  assert.deepEqual(candidate(5),5);
  assert.deepEqual(candidate(54),5);
  assert.deepEqual(candidate(120),1);
  assert.deepEqual(candidate(5014),5);
  assert.deepEqual(candidate(98765),315);
  assert.deepEqual(candidate(5576543),2625);
  assert.deepEqual(candidate(2468),0);
}

test();"
HumanEval_132,tel_Telu,js,"/ ఇక్కడ కనీసం ఒక బ్రాకెట్ ఉపక్రమణలో గూడులో ఉంటుంది. / ఫంక్షన్ తిరిగి తప్పక నిజమైన ఉంటే మరియు మాత్రమే ఉంటే ఒక చెల్లుబాటు అయ్యే ఉప క్రమం బ్రాకెట్లలో / చదరపు బ్రాకెట్లను మాత్రమే కలిగి ఉన్న స్ట్రింగ్ను ఇన్పుట్గా తీసుకునే ఫంక్షన్ను సృష్టించండి. // >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
function is_nested(string){
","function is_nested(string) {
    let openCount = 0;
    let nested = false;

    for (let char of string) {
        if (char === '[') {
            if (openCount > 0) {
                nested = true;
            }
            openCount++;
        } else if (char === ']') {
            if (openCount > 0) {
                openCount--;
            }
        }
    }
    
    return nested && openCount === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = is_nested;
  assert.deepEqual(candidate(""[[]]""),true);
  assert.deepEqual(candidate(""[]]]]]]][[[[[]""),false);
  assert.deepEqual(candidate(""[][]""),false);
  assert.deepEqual(candidate(""[]""),false);
  assert.deepEqual(candidate(""[[[[]]]]""),true);
  assert.deepEqual(candidate(""[]]]]]]]]]]""),false);
  assert.deepEqual(candidate(""[][][[]]""),true);
  assert.deepEqual(candidate(""[[]""),false);
  assert.deepEqual(candidate(""[]]""),false);
  assert.deepEqual(candidate(""[[]][[""),true);
  assert.deepEqual(candidate(""[[][]]""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""[[[[[[[[""),false);
  assert.deepEqual(candidate(""]]]]]]]]""),false);
}

test();"
HumanEval_133,tel_Telu,js,"/ ఉదాహరణలు: / శ్రేణిలోని ప్రతి మూలకాన్ని మొదటి ఎగువ int ((సీలింగ్) కు రౌండ్ చేయండి. / మీరు ఇచ్చిన శ్రేణిలో చతురస్ర సంఖ్యల మొత్తాన్ని తిరిగి ఇవ్వాలి, /మీరు సంఖ్యల శ్రేణి ఇవ్వబడుతుంది. // >>> lst([1.0, 2.0, 3.0])
// 14
// >>> lst([1.0, 4.0, 9.0])
// 98
// >>> lst([1.0, 3.0, 5.0, 7.0])
// 84
// >>> lst([1.4, 4.2, 0.0])
// 29
// >>> lst([-2.4, 1.0, 1.0])
// 6
function sum_squares(lst){
","function sum_squares(lst) {
    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);
  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);
  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);
  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);
  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);
  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);
  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);
  assert.deepEqual(candidate([0.0]),0);
  assert.deepEqual(candidate([-1.0]),1);
  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);
}

test();"
HumanEval_134,tel_Telu,js,"/ ఉదాహరణలు: / గమనిక: ""పదం"" అనేది స్పేస్ ద్వారా వేరు చేయబడిన అక్షరాల సమూహం. / ఒక పదం యొక్క ఒక భాగం, మరియు అబద్ధం లేకపోతే. / ఇచ్చిన స్ట్రింగ్ యొక్క అక్షరమాల అక్షరం మరియు కాదు చివరి అక్షరం  ఉంటే true తిరిగి ఒక ఫంక్షన్ సృష్టించు// >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
function check_if_last_char_is_a_letter(txt){
","function check_if_last_char_is_a_letter(txt) {
    if (txt.length === 0) return false;
    
    txt = txt.trim();
    if (txt.length === 0) return false;
    
    let parts = txt.split(' ');
    let lastWord = parts[parts.length - 1];
    
    if (lastWord.length === 0) return false;
    
    let lastChar = lastWord[lastWord.length - 1];
    return /^[a-zA-Z]$/.test(lastChar);
}","const assert = require('node:assert');


function test() {
  let candidate = check_if_last_char_is_a_letter;
  assert.deepEqual(candidate(""apple""),false);
  assert.deepEqual(candidate(""apple pi e""),true);
  assert.deepEqual(candidate(""eeeee""),false);
  assert.deepEqual(candidate(""A""),true);
  assert.deepEqual(candidate(""Pumpkin pie ""),false);
  assert.deepEqual(candidate(""Pumpkin pie 1""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""eeeee e ""),false);
  assert.deepEqual(candidate(""apple pie""),false);
  assert.deepEqual(candidate(""apple pi e ""),false);
}

test();"
HumanEval_135,tel_Telu,js,"/ ఉదాహరణలు: / విలువలు రెట్టింపు అవుతాయి. / అటువంటి మూలకం ఉనికిలో లేదు అప్పుడు తిరిగి -1. ఇచ్చిన శ్రేణిలో  ఉండదు/ అనేది దాని ముందు ఉన్న మూలకం కంటే ఎక్కువ లేదా సమానం కాదు./ఒక ఫంక్షన్ ను సృష్టించండి, ఇది ఒక మూలకం యొక్క అతిపెద్ద సూచికను తిరిగి ఇస్తుంది, ఇది // >>> can_arrange([1, 2, 4, 3, 5])
// 3
// >>> can_arrange([1, 2, 3])
// -1
function can_arrange(arr){
","function can_arrange(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            return i;
        }
    }
    return -1;
}","const assert = require('node:assert');


function test() {
  let candidate = can_arrange;
  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);
  assert.deepEqual(candidate([1, 2, 4, 5]),-1);
  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);
  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);
  assert.deepEqual(candidate([]),-1);
}

test();"
HumanEval_136,tel_Telu,js,"/ ఉదాహరణలు: / ప్రతికూల లేదా సానుకూల పూర్ణాంకాలు లేకపోతే, వాటిని నిర్వచించబడని విధంగా తిరిగి ఇవ్వండి. / ఒక శ్రేణిలో సానుకూల పూర్ణాంకాల యొక్క. / అతి పెద్ద ప్రతికూల పూర్ణాంకం, మరియు 'b' అతి చిన్నది /a అనేది  అని ఒక శ్రేణి (a, b) ను తిరిగి ఇచ్చే ఫంక్షన్ను సృష్టించండి.// >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])
// [undefined, 1]
// >>> largest_smallest_integers([])
// [undefined, undefined]
// >>> largest_smallest_integers([0])
// [undefined, undefined]
function largest_smallest_integers(lst){
","function largest_smallest_integers(lst) {
    let largestNegative = undefined;
    let smallestPositive = undefined;
    
    lst.forEach(num => {
        if (num < 0 && (largestNegative === undefined || num > largestNegative)) {
            largestNegative = num;
        }
        if (num > 0 && (smallestPositive === undefined || num < smallestPositive)) {
            smallestPositive = num;
        }
    });
    
    return [largestNegative, smallestPositive];
}","const assert = require('node:assert');


function test() {
  let candidate = largest_smallest_integers;
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);
  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);
  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);
  assert.deepEqual(candidate([]),[undefined, undefined]);
  assert.deepEqual(candidate([0]),[undefined, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);
  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);
  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);
}

test();"
HumanEval_137,tel_Telu,js,"/ గమనిక: ఒక వాస్తవ సంఖ్యను స్ట్రింగ్ గా సూచించినట్లయితే, ఫ్లోటింగ్ పాయింట్ కావచ్చు . లేదా , / విలువలు సమానంగా ఉంటే నిర్వచించబడని తిరిగి ఇవ్వండి. / వాస్తవ సంఖ్యలు, మరియు దాని ఇచ్చిన వేరియబుల్ రకం లో పెద్ద వేరియబుల్ తిరిగి. / పూర్ణాంకాలు, ఫ్లోట్స్, లేదా స్ట్రింగ్ లను సూచించే ఫంక్షన్ను సృష్టించండి// >>> compare_one(1, 2.5)
// 2.5
// >>> compare_one(1, ""2,3"")
// ""2,3""
// >>> compare_one(""5,1"", ""6"")
// ""6""
// >>> compare_one(""1"", 1)
// undefined
function compare_one(a, b){
","function compare_one(a, b) {
    // Function to parse the input into a real number.
    const parseNum = (val) => {
        if (typeof val === 'number') return val;
        if (typeof val === 'string') {
            // Replace comma with dot for parsing
            let parsed = parseFloat(val.replace(',', '.'));
            // If parsing fails, return NaN
            if (isNaN(parsed)) return NaN;
            return parsed;
        }
        return NaN;
    };

    // Get parsed numerical values
    const numA = parseNum(a);
    const numB = parseNum(b);

    // Compare the inputs to determine which is greater
    if (numA > numB) return a;
    if (numB > numA) return b;

    // If values are equal return undefined
    return undefined;
}","const assert = require('node:assert');


function test() {
  let candidate = compare_one;
  assert.deepEqual(candidate(1, 2),2);
  assert.deepEqual(candidate(1, 2.5),2.5);
  assert.deepEqual(candidate(2, 3),3);
  assert.deepEqual(candidate(5, 6),6);
  assert.deepEqual(candidate(1, ""2,3""),""2,3"");
  assert.deepEqual(candidate(""5,1"", ""6""),""6"");
  assert.deepEqual(candidate(""1"", ""2""),""2"");
  assert.deepEqual(candidate(""1"", 1),undefined);
}

test();"
HumanEval_138,tel_Telu,js,"/ ఉదాహరణ / ఇచ్చిన సంఖ్య n ను సరిగ్గా 4 సానుకూల జత సంఖ్యల మొత్తంగా వ్రాయవచ్చా అని అంచనా వేయండి // >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
function is_equal_to_sum_even(n){
","function is_equal_to_sum_even(n) {
    // A number can be expressed as the sum of 4 positive even numbers
    // if it is greater than or equal to 8 and is even.

    if (n >= 8 && n % 2 === 0) {
        return true;
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = is_equal_to_sum_even;
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),true);
  assert.deepEqual(candidate(11),false);
  assert.deepEqual(candidate(12),true);
  assert.deepEqual(candidate(13),false);
  assert.deepEqual(candidate(16),true);
}

test();"
HumanEval_139,tel_Telu,js,"/ ఉదాహరణకి: / ఇక్కడ n > 0 / brazilian_factorial (n) = n! * (n-1)! * (n-2)! * . . . * 1! /బ్రెజిలియన్ కారకమును ఈ విధంగా నిర్వచించారు: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
function special_factorial(n){
","function factorial(num) {
    if (num <= 1) return 1;
    return num * factorial(num - 1);
}

function special_factorial(n) {
    let result = 1;
    for (let i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = special_factorial;
  assert.deepEqual(candidate(4),288);
  assert.deepEqual(candidate(5),34560);
  assert.deepEqual(candidate(7),125411328000);
  assert.deepEqual(candidate(1),1);
}

test();"
HumanEval_140,tel_Telu,js,"/ అప్పుడు అన్ని వరుస ఖాళీలను -  తో భర్తీ చేయండి/ మరియు ఒక స్ట్రింగ్ 2 కంటే ఎక్కువ వరుస ఖాళీలను కలిగి ఉంటే, /ఇచ్చిన టెక్స్ట్ స్ట్రింగ్, అన్ని ఖాళీలను అండర్ స్కోర్లతో భర్తీ చేయండి, // >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
function fix_spaces(text){
","function fix_spaces(text) {
    return text.trim().replace(/\s{2,}/g, '-').replace(/\s/g, '_');
}","const assert = require('node:assert');


function test() {
  let candidate = fix_spaces;
  assert.deepEqual(candidate(""Example""),""Example"");
  assert.deepEqual(candidate(""Mudasir Hanif ""),""Mudasir_Hanif_"");
  assert.deepEqual(candidate(""Yellow Yellow  Dirty  Fellow""),""Yellow_Yellow__Dirty__Fellow"");
  assert.deepEqual(candidate(""Exa   mple""),""Exa-mple"");
  assert.deepEqual(candidate(""   Exa 1 2 2 mple""),""-Exa_1_2_2_mple"");
}

test();"
HumanEval_141,tel_Telu,js,"/ ఉదాహరణలు: / - చుక్క తర్వాత ఉన్న ఉప స్ట్రింగ్ ఈ క్రింది వాటిలో ఒకటిగా ఉండాలి: ['txt', 'exe', 'dll'] / లాటిన్ అక్షరమాల ('a'-'z' మరియు 'A'-'Z'). / - చుక్క ముందు ఉన్న సబ్ స్ట్రింగ్ ఖాళీగా ఉండకూడదు, మరియు ఇది  నుండి ఒక అక్షరంతో మొదలవుతుంది./ - ఫైల్ పేరులో సరిగ్గా ఒక డాట్ '.' / - ఫైల్ పేరులో మూడు అంకెల కంటే ఎక్కువ ఉండకూడదు ('0'-'9'). / నెరవేరుతాయి: / ఒక ఫైల్ పేరు అన్ని కింది పరిస్థితులు ఉంటే మరియు మాత్రమే చెల్లుబాటు అయ్యేదిగా పరిగణించబడుతుంది / ఫైల్ పేరు చెల్లుబాటు అయితే 'అవును', లేకపోతే 'లేదు' అని తిరిగి వస్తుంది./ఫైల్ పేరును సూచించే స్ట్రింగ్ తీసుకుని, తిరిగి వచ్చే ఫంక్షన్ను సృష్టించండి // >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
function file_name_check(file_name){
","function file_name_check(file_name) {
    const validExtensions = ['txt', 'exe', 'dll'];
    const parts = file_name.split('.');

    if (parts.length !== 2) {
        return 'No';
    }

    const [namePart, extensionPart] = parts;

    // Check that the name part is not empty, starts with a letter, and has at most 3 digits
    if (namePart.length === 0 || !/^[a-zA-Z]/.test(namePart)) {
        return 'No';
    }

    const digitCount = (namePart.match(/\d/g) || []).length;
    if (digitCount > 3) {
        return 'No';
    }

    // Check if the extension is one of the valid ones
    if (!validExtensions.includes(extensionPart)) {
        return 'No';
    }

    return 'Yes';
}","const assert = require('node:assert');


function test() {
  let candidate = file_name_check;
  assert.deepEqual(candidate(""example.txt""),""Yes"");
  assert.deepEqual(candidate(""1example.dll""),""No"");
  assert.deepEqual(candidate(""s1sdf3.asd""),""No"");
  assert.deepEqual(candidate(""K.dll""),""Yes"");
  assert.deepEqual(candidate(""MY16FILE3.exe""),""Yes"");
  assert.deepEqual(candidate(""His12FILE94.exe""),""No"");
  assert.deepEqual(candidate(""_Y.txt""),""No"");
  assert.deepEqual(candidate(""?aREYA.exe""),""No"");
  assert.deepEqual(candidate(""/this_is_valid.dll""),""No"");
  assert.deepEqual(candidate(""this_is_valid.wow""),""No"");
  assert.deepEqual(candidate(""this_is_valid.txt""),""Yes"");
  assert.deepEqual(candidate(""this_is_valid.txtexe""),""No"");
  assert.deepEqual(candidate(""#this2_i4s_5valid.ten""),""No"");
  assert.deepEqual(candidate(""@this1_is6_valid.exe""),""No"");
  assert.deepEqual(candidate(""this_is_12valid.6exe4.txt""),""No"");
  assert.deepEqual(candidate(""all.exe.txt""),""No"");
  assert.deepEqual(candidate(""I563_No.exe""),""Yes"");
  assert.deepEqual(candidate(""Is3youfault.txt""),""Yes"");
  assert.deepEqual(candidate(""no_one#knows.dll""),""Yes"");
  assert.deepEqual(candidate(""1I563_Yes3.exe""),""No"");
  assert.deepEqual(candidate(""I563_Yes3.txtt""),""No"");
  assert.deepEqual(candidate(""final..txt""),""No"");
  assert.deepEqual(candidate(""final132""),""No"");
  assert.deepEqual(candidate(""_f4indsartal132.""),""No"");
  assert.deepEqual(candidate("".txt""),""No"");
  assert.deepEqual(candidate(""s.""),""No"");
}

test();"
HumanEval_142,tel_Telu,js,"/ ఉదాహరణలు: / శ్రేణిలోని ఎంట్రీలను మార్చండి, దీని సూచికలు 3 లేదా 4 యొక్క గుణకం కాదు. ఫంక్షన్ అప్పుడు అన్ని ఎంట్రీల మొత్తాన్ని తిరిగి ఇస్తుంది./ 3 యొక్క బహుళ మరియు దాని సూచిక 4 యొక్క బహుళ మరియు 3 యొక్క బహుళ కాదు ఉంటే పూర్ణాంక ఎంట్రీ క్యూబ్ ఉంటుంది. ఫంక్షన్ కాదు / ఈ ఫంక్షన్ పూర్ణాంకాల శ్రేణిని తీసుకుంటుంది. శ్రేణిలోని అన్ని ఎంట్రీలకు, ఫంక్షన్ పూర్ణాంక ఎంట్రీని చతురస్రంగా తీసుకుంటుంది, దాని సూచిక a  అయితే./"" // >>> lst
// [1, 2, 3]
// >>> lst
// []
// >>> lst
// [-1, -5, 2, -1, -5]
function sum_squares(lst){
","function sum_squares(lst) {
    let sum = 0;
    for (let i = 0; i < lst.length; i++) {
        if (i % 3 === 0) {
            sum += Math.pow(lst[i], 2);
        } else if (i % 4 === 0) {
            sum += Math.pow(lst[i], 3);
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1, 2, 3]),6);
  assert.deepEqual(candidate([1, 4, 9]),14);
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);
  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);
  assert.deepEqual(candidate([0]),0);
  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);
  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);
  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);
  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);
  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);
}

test();"
HumanEval_143,tel_Telu,js,"/ ఉదాహరణ 1: / కొత్త స్ట్రింగ్ లోని పదాల క్రమం అసలు పదాల క్రమం లాగానే ఉండాలి. / దీని పొడవులు ప్రైమ్ సంఖ్యలు, / మరియు మీరు అసలు వాక్యం నుండి పదాలు కలిగి ఒక స్ట్రింగ్ తిరిగి ఉంటుంది, / వాక్యంలో కొన్ని పదాలు స్పేస్ ద్వారా వేరు చేయబడ్డాయి, /మీరు ఒక వాక్యం ప్రాతినిధ్యం ఒక స్ట్రింగ్ ఇవ్వబడుతుంది, // >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
function words_in_sentence(sentence){
","function words_in_sentence(sentence) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    return sentence.split(' ')
                   .filter(word => isPrime(word.length))
                   .join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = words_in_sentence;
  assert.deepEqual(candidate(""This is a test""),""is"");
  assert.deepEqual(candidate(""lets go for swimming""),""go for"");
  assert.deepEqual(candidate(""there is no place available here""),""there is no place"");
  assert.deepEqual(candidate(""Hi I am Hussein""),""Hi am Hussein"");
  assert.deepEqual(candidate(""go for it""),""go for it"");
  assert.deepEqual(candidate(""here""),"""");
  assert.deepEqual(candidate(""here is""),""is"");
}

test();"
HumanEval_144,tel_Telu,js,"మీరు x, మరియు n చెల్లుబాటు అయ్యే భిన్నాలు అని అనుకోవచ్చు, మరియు సున్నాను నామకరణంగా కలిగి ఉండకూడదు./ <సూచకం>/<సూచకం> ఇక్కడ శ్రేణి మరియు సారం రెండూ సానుకూల పూర్ణాంకాలు./ లేకపోతే. x మరియు n రెండూ, ఒక భిన్నం యొక్క స్ట్రింగ్ ప్రాతినిధ్యం, మరియు క్రింది ఆకృతిని కలిగి ఉంటాయి, / x * n. x * n ఒక పూర్ణాంకం మరియు false  గా అంచనా వేస్తే ఫంక్షన్ true గా తిరిగి వస్తుంది/మీ పని వ్యక్తీకరణను సరళీకృతం చేసే ఫంక్షన్ను అమలు చేయడం // >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
function simplify(x, n){
","function simplify(x, n) {
    const parseFraction = (fraction) => {
        const [numerator, denominator] = fraction.split('/').map(Number);
        return { numerator, denominator };
    };

    const xFraction = parseFraction(x);
    const nFraction = parseFraction(n);

    const resultNumerator = xFraction.numerator * nFraction.numerator;
    const resultDenominator = xFraction.denominator * nFraction.denominator;

    return resultNumerator % resultDenominator === 0;
}

// Example usage
console.log(simplify(""1/5"", ""5/1"")); // true
console.log(simplify(""1/6"", ""2/1"")); // false
console.log(simplify(""7/10"", ""10/2"")); // false","const assert = require('node:assert');


function test() {
  let candidate = simplify;
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/6"", ""2/1""),false);
  assert.deepEqual(candidate(""5/1"", ""3/1""),true);
  assert.deepEqual(candidate(""7/10"", ""10/2""),false);
  assert.deepEqual(candidate(""2/10"", ""50/10""),true);
  assert.deepEqual(candidate(""7/2"", ""4/2""),true);
  assert.deepEqual(candidate(""11/6"", ""6/1""),true);
  assert.deepEqual(candidate(""2/3"", ""5/2""),false);
  assert.deepEqual(candidate(""5/2"", ""3/5""),false);
  assert.deepEqual(candidate(""2/4"", ""8/4""),true);
  assert.deepEqual(candidate(""2/4"", ""4/2""),true);
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/5"", ""1/5""),false);
}

test();"
HumanEval_145,tel_Telu,js,"/ ఉదాహరణకి: / వాటికి అసలు శ్రేణిలో ఉన్న ఇండెక్స్ ఆధారంగా ఆర్డర్ చేయండి. / గమనిక: ఒకే రకమైన అంకెల మొత్తాన్ని కలిగి ఉన్న అనేక అంశాలు ఉంటే, / వారి అంకెల మొత్తానికి అనుగుణంగా క్రమంలో పెరుగుతుంది. ఇచ్చిన పూర్ణాంకాల శ్రేణిని క్రమబద్ధీకరించే ఫంక్షన్ను వ్రాయండి.// >>> order_by_points([1, 11, -1, -11, -12])
// [-1, -11, 1, -12, 11]
// >>> order_by_points([])
// []
function order_by_points(nums){
","function order_by_points(nums) {
    function sumOfDigits(n) {
        // Absolute value to ensure digits are summed correctly for negative numbers
        return Math.abs(n).toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }

    nums.sort((a, b) => {
        const sumA = sumOfDigits(a);
        const sumB = sumOfDigits(b);
        if (sumA === sumB) {
            return 0; // Maintain original order
        }
        return sumA - sumB;
    });

    return nums;
}","const assert = require('node:assert');


function test() {
  let candidate = order_by_points;
  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);
  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);
}

test();"
HumanEval_146,tel_Telu,js,"/ ఉదాహరణకి: / సంఖ్య యొక్క మొదటి మరియు చివరి అంకెలు బేసి (1, 3, 5, 7, 9). / శ్రేణిలో 10 కంటే ఎక్కువ మరియు రెండింటిలోనూ ఉన్న మూలకాల సంఖ్య /ఇన్పుట్ మరియు రిటర్న్స్ గా సంఖ్యల శ్రేణిని తీసుకునే ఫంక్షన్ను వ్రాయండి // >>> specialFilter([15, -73, 14, -15])
// 1
// >>> specialFilter([33, -2, -3, 45, 21, 109])
// 2
function specialFilter(nums){
","function specialFilter(nums) {
    return nums.reduce((count, num) => {
        if (Math.abs(num) > 10) {
            const numStr = Math.abs(num).toString();
            const firstDigit = parseInt(numStr[0]);
            const lastDigit = parseInt(numStr[numStr.length - 1]);
            if ([1, 3, 5, 7, 9].includes(firstDigit) && [1, 3, 5, 7, 9].includes(lastDigit)) {
                return count + 1;
            }
        }
        return count;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = specialFilter;
  assert.deepEqual(candidate([5, -2, 1, -5]),0);
  assert.deepEqual(candidate([15, -73, 14, -15]),1);
  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);
  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);
  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([]),0);
}

test();"
HumanEval_147,tel_Telu,js,"/ ఉదాహరణ: / మరియు a[i] + a[j] + a[k] అనేది 3 యొక్క గుణకం. / i < j < k,  అనే a యొక్క ట్రిపుల్స్ (a[i], a[j], a[k]) సంఖ్యను తిరిగి ఇవ్వండి./ ప్రతి i (1 ≤ i ≤ n) కోసం, a[i] = i * i - i + 1 యొక్క విలువ./ మీకు ఒక సానుకూల పూర్ణాంకం n ఇవ్వబడింది. మీరు పొడవు n యొక్క పూర్ణాంక శ్రేణిని సృష్టించాలి.// >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
function get_max_triples(n){
","function get_max_triples(n) {
    // Step 1: Create the integer array 'a'
    let a = new Array(n);
    for (let i = 1; i <= n; i++) {
        a[i - 1] = i * i - i + 1;
    }

    // Step 2: Count the triples
    let count = 0;
    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            for (let k = j + 1; k < n; k++) {
                if ((a[i] + a[j] + a[k]) % 3 === 0) {
                    count++;
                }
            }
        }
    }

    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = get_max_triples;
  assert.deepEqual(candidate(5),1);
  assert.deepEqual(candidate(6),4);
  assert.deepEqual(candidate(10),36);
  assert.deepEqual(candidate(100),53361);
}

test();"
HumanEval_148,tel_Telu,js,"/ ఉదాహరణలు / సరైన గ్రహ పేర్లు కాదు. / ఫంక్షన్ ఒక ఖాళీ శ్రేణిని తిరిగి ఇవ్వాలి planet1 లేదా planet2 / సూర్యునికి సమీపంలో. / గ్రహం 1 మరియు గ్రహం 2 యొక్క కక్ష్యల మధ్య ఉన్నది,  ద్వారా క్రమబద్ధీకరించబడింది/ ఫంక్షన్                                                                                                                                                                                                                                                                                                         / రెండు గ్రహాల పేర్లను స్ట్రింగ్స్ గ్రహం 1 మరియు గ్రహం 2 గా తీసుకునే ఫంక్షన్ను వ్రాయండి. / యురేనస్, నెప్ట్యూన్ / మెర్క్యురీ, తదుపరి ఒకటి వీనస్, అప్పుడు భూమి, మార్స్, బృహస్పతి, శని, సూర్యుడికి అతి సమీపంలో ఉన్న ఎనిమిది గ్రహాలు మన సౌర వ్యవస్థలో ఉన్నాయి.// >>> bf(""Jupiter"", ""Neptune"")
// [""Saturn"", ""Uranus""]
// >>> bf(""Earth"", ""Mercury"")
// ""Venus""
// >>> bf(""Mercury"", ""Uranus"")
// [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
function bf(planet1, planet2){
","function bf(planet1, planet2) {
    const planets = [
        ""Mercury"",
        ""Venus"",
        ""Earth"",
        ""Mars"",
        ""Jupiter"",
        ""Saturn"",
        ""Uranus"",
        ""Neptune""
    ];

    const index1 = planets.indexOf(planet1);
    const index2 = planets.indexOf(planet2);

    if (index1 === -1 || index2 === -1) {
        return [];
    }

    const start = Math.min(index1, index2) + 1;
    const end = Math.max(index1, index2);

    return planets.slice(start, end);
}","const assert = require('node:assert');


function test() {
  let candidate = bf;
  assert.deepEqual(candidate(""Jupiter"", ""Neptune""),[""Saturn"", ""Uranus""]);
  assert.deepEqual(candidate(""Earth"", ""Mercury""),[""Venus""]);
  assert.deepEqual(candidate(""Mercury"", ""Uranus""),[""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]);
  assert.deepEqual(candidate(""Neptune"", ""Venus""),[""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""]);
  assert.deepEqual(candidate(""Earth"", ""Earth""),[]);
  assert.deepEqual(candidate(""Mars"", ""Earth""),[]);
  assert.deepEqual(candidate(""Jupiter"", ""Makemake""),[]);
}

test();"
HumanEval_149,tel_Telu,js,"/ ఉదాహరణకి: / అన్ని పదాలూ ఒకే పొడవు కలిగి ఉంటాయని మీరు అనుకోవచ్చు. / ఫంక్షన్ క్రమబద్ధమైన క్రమంలో స్ట్రింగ్స్ యొక్క శ్రేణిని తిరిగి ఇవ్వాలి. / రెండు పదాలు ఒకే పొడవు కలిగి ఉంటే, శ్రేణిని అక్షర క్రమంలో క్రమబద్ధీకరించండి. / ఆ నియమం ద్వారా క్రమబద్ధీకరించిన శ్రేణిని తిరిగి ఇవ్వాలి. / శ్రేణి యొక్క ఆర్డర్ ప్రతి పదం యొక్క పొడవు ద్వారా పెరుగుతున్న ఉండాలి, మరియు మీరు / మరియు అది నకిలీలను కలిగి ఉండవచ్చు. / శ్రేణి ఎల్లప్పుడూ స్ట్రింగ్స్ యొక్క శ్రేణి మరియు సంఖ్యల శ్రేణి కాదు, / మరియు క్రమబద్ధీకరించిన క్రమంతో ఫలిత శ్రేణిని తిరిగి ఇస్తుంది, / దాని నుండి అసమాన పొడవు ఉన్న స్ట్రింగ్లను తొలగిస్తుంది, / స్ట్రింగ్స్ యొక్క శ్రేణిని పారామితిగా అంగీకరించే ఫంక్షన్ను వ్రాయండి, // >>> list_sort([""aa"", ""a"", ""aaa""])
// [""aa""]
// >>> list_sort([""ab"", ""a"", ""aaa"", ""cd""])
// [""ab"", ""cd""]
function sorted_list_sum(lst){
","function sorted_list_sum(lst) {
    return lst
        .filter(word => word.length % 2 === 0)
        .sort((a, b) => {
            if (a.length === b.length) {
                return a.localeCompare(b);
            }
            return a.length - b.length;
        });
}","const assert = require('node:assert');


function test() {
  let candidate = sorted_list_sum;
  assert.deepEqual(candidate([""aa"", ""a"", ""aaa""]),[""aa""]);
  assert.deepEqual(candidate([""school"", ""AI"", ""asdf"", ""b""]),[""AI"", ""asdf"", ""school""]);
  assert.deepEqual(candidate([""d"", ""b"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""d"", ""dcba"", ""abcd"", ""a""]),[""abcd"", ""dcba""]);
  assert.deepEqual(candidate([""AI"", ""ai"", ""au""]),[""AI"", ""ai"", ""au""]);
  assert.deepEqual(candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""aaaa"", ""bbbb"", ""dd"", ""cc""]),[""cc"", ""dd"", ""aaaa"", ""bbbb""]);
}

test();"
HumanEval_150,tel_Telu,js,"/ ఉదాహరణలు: / ఒక ప్రధాన సంఖ్య మరియు y విలువను తిరిగి ఇవ్వాలి./ఒక సాధారణ ప్రోగ్రామ్ ఇది n ఉంటే x విలువను తిరిగి ఇవ్వాలి// >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
function x_or_y(n, x, y){
","function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;

    if (num % 2 === 0 || num % 3 === 0) return false;

    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }

    return true;
}

function x_or_y(n, x, y) {
    return isPrime(n) ? x : y;
}","const assert = require('node:assert');


function test() {
  let candidate = x_or_y;
  assert.deepEqual(candidate(7, 34, 12),34);
  assert.deepEqual(candidate(15, 8, 5),5);
  assert.deepEqual(candidate(3, 33, 5212),33);
  assert.deepEqual(candidate(1259, 3, 52),3);
  assert.deepEqual(candidate(7919, -1, 12),-1);
  assert.deepEqual(candidate(3609, 1245, 583),583);
  assert.deepEqual(candidate(91, 56, 129),129);
  assert.deepEqual(candidate(6, 34, 1234),1234);
  assert.deepEqual(candidate(1, 2, 0),0);
  assert.deepEqual(candidate(2, 2, 0),2);
}

test();"
HumanEval_151,tel_Telu,js,"/ శ్రేణిలో అసమానమైనవి. ప్రతికూల సంఖ్యలు లేదా పూర్ణాంకాలు లేని సంఖ్యలను విస్మరించండి. / సంఖ్యల శ్రేణిని ఇచ్చినట్లయితే, సంఖ్యల చతురస్రాల మొత్తాన్ని తిరిగి ఇవ్వండి // >>> double_the_difference([1, 3, 2, 0])
// 10
// >>> double_the_difference([-1, -2, 0])
// 0
// >>> double_the_difference([9, -2])
// 81
// >>> double_the_difference([0])
// 0
// If the input array is empty, return 0.
function double_the_difference(lst){
","function double_the_difference(lst) {
    return lst.reduce((sum, num) => {
        if (Number.isInteger(num) && num > 0 && num % 2 !== 0) {
            return sum + num * num;
        }
        return sum;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = double_the_difference;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([5.0, 4.0]),25);
  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);
  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);
  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);
  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);
  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);
}

test();"
HumanEval_152,tel_Telu,js,"/ ఉదాహరణ: / విలువ 0 మరియు లేకపోతే, విలువ అంచనా మరియు స్కోరు మధ్య సంపూర్ణ వ్యత్యాసం. / వారు సరిగ్గా ఊహించినట్లయితే, ప్రతి ఊహ ఎంత దూరం అని సూచించే అదే పొడవు యొక్క శ్రేణిని తిరిగి ఇవ్వండి./ మీకు రెండు స్కోర్లు మరియు అంచనాలు సమాన పొడవుతో ఇవ్వబడ్డాయి, ఇక్కడ ప్రతి సూచిక మ్యాచ్ చూపిస్తుంది. / మీ పని ఒక వ్యక్తి సరిగ్గా మ్యాచ్లు అనేక ఫలితాలు ఊహించిన లేదో గుర్తించడానికి ఉంది. / ఖచ్చితంగా గమనించడం మరియు పోల్చడం విలువ. / ఈవెంట్ చివరకు తెలిసిన. మీరు ఆ క్షణం కలిగి భావాలు మరియు ఆలోచనలు /నేను మేము అన్ని దీర్ఘ ఎదురుచూస్తున్న కొన్ని ఫలితంగా ఉన్నప్పుడు ఆ భావన గుర్తుంచుకోవాలి అనుకుంటున్నాను // >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
// [0, 0, 0, 0, 3, 3]
// >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
// [4, 4, 1, 0, 0, 6]
function compare(game, guess){
","function compare(game, guess) {
    return game.map((score, index) => Math.abs(score - guess[index]));
}","const assert = require('node:assert');


function test() {
  let candidate = compare;
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);
  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);
  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);
  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);
}

test();"
HumanEval_153,tel_Telu,js,"/ ఉదాహరణ: / (దాని బలం -1). / తిరిగి 'Slices. SERviNGSliCes' ఎందుకంటే 'SErviNGSliCes' అనేది బలమైన పొడిగింపు / పొడిగింపులు: ['SERVINGSliCes', 'Cheese', 'StuFfed'] అప్పుడు మీరు / ఉదాహరణకు, మీకు ""స్లైస్"" అని ఇచ్చినట్లయితే,  యొక్క తరగతి మరియు శ్రేణి/ శ్రేణిలో మొదటిది వచ్చినదాన్ని ఎంచుకోండి. / రెండు లేదా అంతకంటే ఎక్కువ పొడిగింపులు ఒకే బలం కలిగి ఉంటే, మీరు / ఫార్మాట్: క్లాస్ పేరు. బలమైన పొడిగింపు పేరు. / మీరు బలమైన పొడిగింపును కనుగొని, దీనిలో ఒక స్ట్రింగ్ను తిరిగి ఇవ్వాలి / పొడిగింపు పేరులో, CAP - SM భిన్నం ద్వారా బలం ఇవ్వబడుతుంది. / అక్షరాలు పొడిగింపు పేరులో, మరియు SM చిన్న అక్షరాల సంఖ్య / పొడిగింపు యొక్క బలం ఈ క్రింది విధంగా ఉంటుంది: CAP పెద్ద అక్షరం యొక్క సంఖ్యగా భావించండి / పొడిగింపులు తరగతికి అదనపు తరగతులను లోడ్ చేయడానికి ఉపయోగించబడతాయి./మీకు ఒక తరగతి పేరు (ఒక స్ట్రింగ్) మరియు పొడిగింపుల శ్రేణి ఇవ్వబడుతుంది.// >>> Strongest_Extension(""my_class"", [""AA"", ""Be"", ""CC""])
// ""my_class.AA""
function Strongest_Extension(class_name, extensions){
","function Strongest_Extension(class_name, extensions) {
    let strongestExtension = '';
    let maxStrength = -Infinity;

    extensions.forEach(extension => {
        let capCount = 0;
        let smCount = 0;

        for (let char of extension) {
            if (char >= 'A' && char <= 'Z') {
                capCount++;
            } else if (char >= 'a' && char <= 'z') {
                smCount++;
            }
        }

        let strength = capCount - smCount;

        if (strength > maxStrength) {
            maxStrength = strength;
            strongestExtension = extension;
        }
    });

    return `${class_name}.${strongestExtension}`;
}","const assert = require('node:assert');


function test() {
  let candidate = Strongest_Extension;
  assert.deepEqual(candidate(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]),""Watashi.eIGHt8OKe"");
  assert.deepEqual(candidate(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]),""Boku123.YEs.WeCaNe"");
  assert.deepEqual(candidate(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]),""__YESIMHERE.NuLl__"");
  assert.deepEqual(candidate(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]),""K.TAR"");
  assert.deepEqual(candidate(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]),""__HAHA.123"");
  assert.deepEqual(candidate(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]),""YameRore.okIWILL123"");
  assert.deepEqual(candidate(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]),""finNNalLLly.WoW"");
  assert.deepEqual(candidate(""_"", [""Bb"", ""91245""]),""_.Bb"");
  assert.deepEqual(candidate(""Sp"", [""671235"", ""Bb""]),""Sp.671235"");
}

test();"
HumanEval_154,tel_Telu,js,"/మీరు 2 పదాలు ఇవ్వబడ్డాయి. మీరు రెండవ పదం లేదా దాని భ్రమణాల ఏ మొదటి పదం లో ఒక ఉప స్ట్రింగ్ ఉంటే నిజమైన తిరిగి అవసరం // >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
function cycpattern_check(a, b){
","function cycpattern_check(a, b) {
    if (b.length > a.length) return false;
    
    let currentRotation = b;
    for (let i = 0; i < b.length; i++) {
        if (a.includes(currentRotation)) {
            return true;
        }
        currentRotation = currentRotation.slice(1) + currentRotation[0];
    }
    
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = cycpattern_check;
  assert.deepEqual(candidate(""xyzw"", ""xyw""),false);
  assert.deepEqual(candidate(""yello"", ""ell""),true);
  assert.deepEqual(candidate(""whattup"", ""ptut""),false);
  assert.deepEqual(candidate(""efef"", ""fee""),true);
  assert.deepEqual(candidate(""abab"", ""aabb""),false);
  assert.deepEqual(candidate(""winemtt"", ""tinem""),true);
}

test();"
HumanEval_155,tel_Telu,js,"/ ఉదాహరణ: /ఇంటర్ ఇచ్చినట్లయితే. వరుసగా జత మరియు బేసి అంకెల సంఖ్యను కలిగి ఉన్న శ్రేణిని తిరిగి ఇవ్వండి. // >>> even_odd_count(-12)
// [1, 1]
// >>> even_odd_count(123)
// [1, 2]
function even_odd_count(num){
","function even_odd_count(num) {
    // Convert the number to a string and take the absolute value for negative numbers
    const numStr = Math.abs(num).toString();
    let evenCount = 0;
    let oddCount = 0;

    // Loop through each digit in the string
    for (let char of numStr) {
        // Convert the character back to a number
        let digit = parseInt(char, 10);
        // Check if the digit is even or odd
        if (digit % 2 === 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return [evenCount, oddCount];
}","const assert = require('node:assert');


function test() {
  let candidate = even_odd_count;
  assert.deepEqual(candidate(7),[0, 1]);
  assert.deepEqual(candidate(-78),[1, 1]);
  assert.deepEqual(candidate(3452),[2, 2]);
  assert.deepEqual(candidate(346211),[3, 3]);
  assert.deepEqual(candidate(-345821),[3, 3]);
  assert.deepEqual(candidate(-2),[1, 0]);
  assert.deepEqual(candidate(-45347),[2, 3]);
  assert.deepEqual(candidate(0),[1, 0]);
}

test();"
HumanEval_156,tel_Telu,js,"/ ఉదాహరణలు: / పరిమితులు: 1 <= num <= 1000 / మరియు చిన్న అక్షరాలతో తిరిగి ఇవ్వండి. /ఒక సానుకూల పూర్ణాంకం ఇచ్చినట్లయితే, దాని రోమన్ అంకెల సమానమైన స్ట్రింగ్ ను పొందండి, // >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
function int_to_mini_roman(number){
","function int_to_mini_roman(number) {
    const romanNumerals = [
        { value: 1000, numeral: 'm' },
        { value: 900, numeral: 'cm' },
        { value: 500, numeral: 'd' },
        { value: 400, numeral: 'cd' },
        { value: 100, numeral: 'c' },
        { value: 90, numeral: 'xc' },
        { value: 50, numeral: 'l' },
        { value: 40, numeral: 'xl' },
        { value: 10, numeral: 'x' },
        { value: 9, numeral: 'ix' },
        { value: 5, numeral: 'v' },
        { value: 4, numeral: 'iv' },
        { value: 1, numeral: 'i' }
    ];
    
    let result = '';
    for (const { value, numeral } of romanNumerals) {
        while (number >= value) {
            result += numeral;
            number -= value;
        }
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = int_to_mini_roman;
  assert.deepEqual(candidate(19),""xix"");
  assert.deepEqual(candidate(152),""clii"");
  assert.deepEqual(candidate(251),""ccli"");
  assert.deepEqual(candidate(426),""cdxxvi"");
  assert.deepEqual(candidate(500),""d"");
  assert.deepEqual(candidate(1),""i"");
  assert.deepEqual(candidate(4),""iv"");
  assert.deepEqual(candidate(43),""xliii"");
  assert.deepEqual(candidate(90),""xc"");
  assert.deepEqual(candidate(94),""xciv"");
  assert.deepEqual(candidate(532),""dxxxii"");
  assert.deepEqual(candidate(900),""cm"");
  assert.deepEqual(candidate(994),""cmxciv"");
  assert.deepEqual(candidate(1000),""m"");
}

test();"
HumanEval_157,tel_Telu,js,"/ ఉదాహరణ: / 90 డిగ్రీలు. / ఒక కుడి కోణ త్రిభుజం ఒక కోణం కుడి కోణం లేదా / వైపులా ఒక కుడి కోణ త్రిభుజం, లేకపోతే తప్పు. / ఇచ్చిన ఒక త్రిభుజం యొక్క మూడు వైపులా యొక్క పొడవులు. మూడు // >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
function right_angle_triangle(a, b, c){
","function right_angle_triangle(a, b, c) {
    // Sort the sides to ensure the largest side is at the end (potential hypotenuse)
    let sides = [a, b, c].sort((x, y) => x - y);
    
    // Check the Pythagorean theorem to determine if it's a right-angled triangle
    return sides[0]**2 + sides[1]**2 === sides[2]**2;
}","const assert = require('node:assert');


function test() {
  let candidate = right_angle_triangle;
  assert.deepEqual(candidate(3, 4, 5),true);
  assert.deepEqual(candidate(1, 2, 3),false);
  assert.deepEqual(candidate(10, 6, 8),true);
  assert.deepEqual(candidate(2, 2, 2),false);
  assert.deepEqual(candidate(7, 24, 25),true);
  assert.deepEqual(candidate(10, 5, 7),false);
  assert.deepEqual(candidate(5, 12, 13),true);
  assert.deepEqual(candidate(15, 8, 17),true);
  assert.deepEqual(candidate(48, 55, 73),true);
  assert.deepEqual(candidate(1, 1, 1),false);
  assert.deepEqual(candidate(2, 2, 10),false);
}

test();"
HumanEval_158,tel_Telu,js,"/ అక్షరాలు, పదకోశ క్రమంలో మొదటిది తిరిగి ఇవ్వండి. / ప్రత్యేక అక్షరాల సంఖ్య. బహుళ స్ట్రింగ్స్ గరిష్ట సంఖ్యలో ప్రత్యేకమైన  కలిగి ఉంటే/ శ్రేణిలో వేర్వేరు పదాలు ఉన్నాయి. గరిష్ట సంఖ్యతో పదమును తిరిగి ఇవ్వండి / స్ట్రింగ్స్ యొక్క శ్రేణిని అంగీకరించే ఫంక్షన్ను వ్రాయండి. // >>> find_max([""name"", ""of"", ""string""])
// ""string""
// >>> find_max([""name"", ""enam"", ""game""])
// ""enam""
// >>> find_max([""aaaaaaa"", ""bb"", ""cc""])
// ""aaaaaaa""
function find_max(words){
","function find_max(words) {
    function uniqueCharacterCount(word) {
        const uniqueChars = new Set(word);
        return uniqueChars.size;
    }

    let maxUniqueCount = -1;
    let result = """";

    words.forEach(word => {
        const currentUniqueCount = uniqueCharacterCount(word);
        if (currentUniqueCount > maxUniqueCount || 
            (currentUniqueCount === maxUniqueCount && word < result)) {
            maxUniqueCount = currentUniqueCount;
            result = word;
        }
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = find_max;
  assert.deepEqual(candidate([""name"", ""of"", ""string""]),""string"");
  assert.deepEqual(candidate([""name"", ""enam"", ""game""]),""enam"");
  assert.deepEqual(candidate([""aaaaaaa"", ""bb"", ""cc""]),""aaaaaaa"");
  assert.deepEqual(candidate([""abc"", ""cba""]),""abc"");
  assert.deepEqual(candidate([""play"", ""this"", ""game"", ""of"", ""footbott""]),""footbott"");
  assert.deepEqual(candidate([""we"", ""are"", ""gonna"", ""rock""]),""gonna"");
  assert.deepEqual(candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]),""nation"");
  assert.deepEqual(candidate([""this"", ""is"", ""a"", ""prrk""]),""this"");
  assert.deepEqual(candidate([""b""]),""b"");
  assert.deepEqual(candidate([""play"", ""play"", ""play""]),""play"");
}

test();"
HumanEval_159,tel_Telu,js,"/ ఉదాహరణ: / తగినంత క్యారెట్లు మిగిలి లేనట్లయితే, మీరు మిగిలిన క్యారెట్లు తినవచ్చు, కానీ ఇప్పటికీ ఆకలితో ఉంటారు. / మీ భోజనం తర్వాత మిగిలిపోయిన క్యారెట్లు సంఖ్య ] / మీరు మీ భోజనం తర్వాత తిన్న క్యారెట్లు మొత్తం సంఖ్య, / కానీ ఇప్పుడు మీరు రోజు భోజనం పూర్తి చేయడానికి మరింత క్యారెట్లు తినడానికి అవసరం. / మీరు ఒక ఆకలితో కుందేలు, మరియు మీరు ఇప్పటికే క్యారెట్లు ఒక నిర్దిష్ట సంఖ్యలో తింటారు, // >>> eat(5, 6, 10)
// [11, 4]
// >>> eat(4, 8, 9)
// [12, 1]
// >>> eat(1, 10, 10)
// [11, 0]
// >>> eat(2, 11, 5)
// [7, 0]
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
function eat(number, need, remaining){
","function eat(number, need, remaining) {
    const carrotsToEat = Math.min(need, remaining);
    const totalEaten = number + carrotsToEat;
    const carrotsLeft = remaining - carrotsToEat;
    return [totalEaten, carrotsLeft];
}","const assert = require('node:assert');


function test() {
  let candidate = eat;
  assert.deepEqual(candidate(5, 6, 10),[11, 4]);
  assert.deepEqual(candidate(4, 8, 9),[12, 1]);
  assert.deepEqual(candidate(1, 10, 10),[11, 0]);
  assert.deepEqual(candidate(2, 11, 5),[7, 0]);
  assert.deepEqual(candidate(4, 5, 7),[9, 2]);
  assert.deepEqual(candidate(4, 5, 1),[5, 0]);
}

test();"
HumanEval_160,tel_Telu,js,"/ ఆపరేటర్ శ్రేణిలో కనీసం ఒక ఆపరేటర్ ఉంటుంది, మరియు ఆపరేండ్ శ్రేణిలో కనీసం రెండు ఆపరేండాలు ఉంటాయి./ ఆపరేండ్ అనేది ప్రతికూల సంఖ్యలు కాని పూర్ణాంకాల శ్రేణి. / ఆపరేటర్ శ్రేణి యొక్క పొడవు ఆపరేండ్ శ్రేణి యొక్క పొడవు మైనస్ ఒకటికి సమానం. / గమనిక: / => ఫలితం = 9 / ఫలితం = 2 + 3 * 4 - 5 / శ్రేణి = [2, 3, 4, 5] / ఆపరేటర్ ['+', '*', '-'] / ఉదాహరణ: / ఎక్స్పోనెన్షియేషన్ (**) లను/ అంతస్తు విభజన ( // ) / గుణకారం (* ) / తీసివేత ( - ) / జోడింపు (+ ) / ప్రాథమిక బీజగణిత కార్యకలాపాలు: / వ్యక్తీకరణ మరియు ఈ వ్యక్తీకరణ యొక్క అంచనాను తిరిగి ఇవ్వండి. / రెండవ శ్రేణి పూర్ణాంకాల శ్రేణి. ఇచ్చిన రెండు శ్రేణులను ఉపయోగించి అల్జీబ్రిక్ ను నిర్మించండి / రెండు శ్రేణుల ఆపరేటర్ మరియు ఆపరేండ్ ఇచ్చినట్లయితే. మొదటి శ్రేణి ప్రాథమిక బీజగణిత కార్యకలాపాలను కలిగి ఉంటుంది, మరియు function do_algebra(operator, operand){
","function do_algebra(operator, operand) {
    let expression = operand[0].toString();
    
    for (let i = 0; i < operator.length; i++) {
        let op = operator[i];
        let currentOperand = operand[i + 1];
        
        // Replace floor division symbol '//' with actual JavaScript behavior
        if (op === '//') {
            expression += `Math.floor(${currentOperand})`;
        } else {
            expression += ` ${op} ${currentOperand}`;
        }
    }
    
    // Evaluate the resulting expression
    let result = eval(expression);
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = do_algebra;
  assert.deepEqual(candidate([""**"", ""*"", ""+""], [2, 3, 4, 5]),37);
  assert.deepEqual(candidate([""+"", ""*"", ""-""], [2, 3, 4, 5]),9);
  assert.deepEqual(candidate([""//"", ""*""], [7, 3, 4]),8);
}

test();"
HumanEval_161,tel_Telu,js,"/ ఉదాహరణలు / ఫంక్షన్ ఫలిత స్ట్రింగ్ ను తిరిగి ఇవ్వాలి. / స్ట్రింగ్ లో అక్షరాలు లేకపోతే, స్ట్రింగ్ను రివర్స్ చేయండి. / లేకపోతే అది వంటి ఉంచడానికి. / s[i] ఒక అక్షరం అయితే, దాని కేసును దిగువ నుండి ఎగువకు లేదా విసర్జనకు తిప్పండి, / మీరు ఒక స్ట్రింగ్ ఇవ్వబడుతుంది s. // >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
function solve(s){
","function solve(s) {
    let hasLetter = false;
    let result = '';

    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (/[a-zA-Z]/.test(char)) {
            hasLetter = true;
            if (char === char.toLowerCase()) {
                result += char.toUpperCase();
            } else {
                result += char.toLowerCase();
            }
        } else {
            result += char;
        }
    }

    if (!hasLetter) {
        return result.split('').reverse().join('');
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(""AsDf""),""aSdF"");
  assert.deepEqual(candidate(""1234""),""4321"");
  assert.deepEqual(candidate(""ab""),""AB"");
  assert.deepEqual(candidate(""#a@C""),""#A@c"");
  assert.deepEqual(candidate(""#AsdfW^45""),""#aSDFw^45"");
  assert.deepEqual(candidate(""#6@2""),""2@6#"");
  assert.deepEqual(candidate(""#$a^D""),""#$A^d"");
  assert.deepEqual(candidate(""#ccc""),""#CCC"");
}

test();"
HumanEval_162,tel_Telu,js,"/ 'టెక్స్ట్' ఒక ఖాళీ స్ట్రింగ్ అయితే, undefined ను తిరిగి ఇవ్వండి./ఇచ్చిన స్ట్రింగ్ 'టెక్స్ట్', దాని md5 హాష్ సమానమైన స్ట్రింగ్ను తిరిగి ఇవ్వండి. // >>> string_to_md5(""Hello world"")
// ""3e25960a79dbc69b674cd4ec67a72c62""
function string_to_md5(text){
","const crypto = require('crypto');

function string_to_md5(text) {
    if (text === """") {
        return undefined;
    }
    return crypto.createHash('md5').update(text).digest('hex');
}","const assert = require('node:assert');


function test() {
  let candidate = string_to_md5;
  assert.deepEqual(candidate(""Hello world""),""3e25960a79dbc69b674cd4ec67a72c62"");
  assert.deepEqual(candidate(""""),undefined);
  assert.deepEqual(candidate(""A B C""),""0ef78513b0cb8cef12743f5aeb35f888"");
  assert.deepEqual(candidate(""password""),""5f4dcc3b5aa765d61d8327deb882cf99"");
}

test();"
HumanEval_163,tel_Telu,js,"/ ఉదాహరణకి: / మరియు b, పెరుగుతున్న క్రమంలో. / రెండు సానుకూల పూర్ణాంకాలు a మరియు b ఇచ్చినట్లయితే, a  మధ్య ఉన్న జత అంకెలను తిరిగి ఇవ్వండి// >>> generate_integers(2, 8)
// [2, 4, 6, 8]
// >>> generate_integers(8, 2)
// [2, 4, 6, 8]
// >>> generate_integers(10, 14)
// []
function generate_integers(a, b){
","function generate_integers(a, b) {
    let start = Math.min(a, b);
    let end = Math.max(a, b);
    let evenDigits = [];

    for (let i = start; i <= end; i++) {
        if (i % 2 === 0) {
            evenDigits.push(i);
        }
    }

    return evenDigits;
}","const assert = require('node:assert');


function test() {
  let candidate = generate_integers;
  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);
  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(17, 89),[]);
}

test();"
