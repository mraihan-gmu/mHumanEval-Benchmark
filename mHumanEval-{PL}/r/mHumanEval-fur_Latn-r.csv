task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,fur_Latn,r,"                           Controlâ se in cheste liste di numars, a son doi numars plui dongje un di chel altri di # >>> has_close_elements(c(1.0, 2.0, 3.0), 0.5)
# FALSE
# >>> has_close_elements(c(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)
# TRUE
has_close_elements <- function(numbers, threshold) {","has_close_elements <- function(numbers, threshold) {
  for (i in seq_along(numbers)) {
    for (j in seq_along(numbers)) {
      if (i != j && abs(numbers[i] - numbers[j]) < threshold) {
        return(TRUE)
      }
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- has_close_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.95), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.8), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 1.0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 0.5), FALSE)))
}
test_humaneval()"
HumanEval_1,fur_Latn,r,"Ignorâ ogni spazi inte stringhe di input.I grups separâts a son in equilibri (ogni braç viert al è ben sierât) e no a son imbastîts un dentri di chel altri.separâ chei grups in stradis separadis e tornâ la liste di chei. La jentrade di cheste funzion e je une stringhe che e conten plui grups di parentesi imbastîts. Il to obietîf al è di # >>> separate_paren_groups('( ) (( )) (( )( ))')
# c('()', '(())', '(()())')
separate_paren_groups <- function(paren_string) {","separate_paren_groups <- function(paren_string) {
  # Remove spaces from the input string
  paren_string <- gsub("" "", """", paren_string)
  
  # Initialize variables for processing
  result <- c()
  current_group <- """"
  balance <- 0
  
  # Iterate through each character in the string
  for (char in strsplit(paren_string, """")[[1]]) {
    current_group <- paste0(current_group, char)
    if (char == ""("") {
      balance <- balance + 1
    } else if (char == "")"") {
      balance <- balance - 1
    }
    
    # If balance is zero, we found a complete group
    if (balance == 0 && nchar(current_group) > 0) {
      result <- c(result, current_group)
      current_group <- """"
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- separate_paren_groups
    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c('(()())', '((()))', '()', '((())()())'))))
    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c('()', '(())', '((()))', '(((())))'))))
    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c('(()(())((())))'))))
    stopifnot(isTRUE(all.equal(candidate('( ) (( )) (( )( ))'), c('()', '(())', '(()())'))))
}
test_humaneval()"
HumanEval_2,fur_Latn,r,"Torne la part decimâl dal numar. (la part restante e je simpri plui piçule di 1).e part intîr (inteîr plui grant plui piçul dal numar dât) e decimâi Dât un numar in virgule mobile positîf, al pues jessi dividût in # >>> truncate_number(3.5)
# 0.5
truncate_number <- function(number) {","truncate_number <- function(number) {
  return(number - floor(number))
}","test_humaneval <- function() {
    candidate <- truncate_number
    stopifnot(isTRUE(all.equal(candidate(3.5), 0.5)))
    stopifnot(isTRUE(all.equal(candidate(1.25), 0.25)))
    stopifnot(isTRUE(all.equal(candidate(123.0), 0.0)))
}
test_humaneval()"
HumanEval_3,fur_Latn,r,"In chest pont la funzion e varès di tornâ VÊR. In câs contrari e varès di tornâ FALSE.Il to compit al è di rilevâ se in cualsisei moment il saldo dal cont al rive sot di zero, e Ti ven dade une liste di operazions di deposit e ritiradure su un cont bancari che al scomence cun # >>> below_zero(c(1, 2, 3))
# FALSE
# >>> below_zero(c(1, 2, -4, 5))
# TRUE
below_zero <- function(operations) {","below_zero <- function(operations) {
  balance <- 0
  for (op in operations) {
    balance <- balance + op
    if (balance < 0) {
      return(TRUE)
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- below_zero
    stopifnot(isTRUE(all.equal(candidate(c()), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -3, 1, 2, -3)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, 2, -2, 5, -5, 4, -4)), TRUE)))
}
test_humaneval()"
HumanEval_4,fur_Latn,r,"MAD = medie. x - x_mean. element e un pont centrâl (mean in chest câs): La deviazion medie assolude e je la diference medie assolude tra ogni cirche la medie di chest insiemi di dâts. Par une liste di numars di input, calcolâ la deviazion medie assolude # >>> mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))
# 1.0
mean_absolute_deviation <- function(numbers) {","mean_absolute_deviation <- function(numbers) {
  x_mean <- mean(numbers)
  mad <- mean(abs(numbers - x_mean))
  return(mad)
}

# Example usage
mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))","test_humaneval <- function() {
    candidate <- mean_absolute_deviation
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0)), 0.5)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0)), 1.0)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), 1.2)))
}
test_humaneval()"
HumanEval_5,fur_Latn,r,"""Inserìs un numar 'delimitor' tra ogni doi elements consecutivs de liste di input ∀numars"" # >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
intersperse <- function(numbers, delimeter) {","intersperse <- function(numbers, delimeter) {
  if (length(numbers) <= 1) {
    return(numbers)
  }
  result <- c()
  for (i in 1:(length(numbers) - 1)) {
    result <- c(result, numbers[i], delimeter)
  }
  result <- c(result, numbers[length(numbers)])
  return(result)
}","test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()"
HumanEval_6,fur_Latn,r,"Par esempli (() (()) al à un massim di doi nivei di nidificazion, invezit ((())) al à trê. Par ogni grup, output il nivel plui profont di imbastî di parentesiis. La jentrade di cheste funzion e je une stringhe rapresentade di grups multipli par parentesis imbastîts separâts di spazis.# >>> parse_nested_parens('(()()) ((())) () ((())()())')
# c(2, 3, 1, 3)
parse_nested_parens <- function(paren_string) {","parse_nested_parens <- function(paren_string) {
  sapply(strsplit(paren_string, "" "")[[1]], function(group) {
    max_nesting <- 0
    current_nesting <- 0
    for (char in strsplit(group, """")[[1]]) {
      if (char == ""("") {
        current_nesting <- current_nesting + 1
        max_nesting <- max(max_nesting, current_nesting)
      } else if (char == "")"") {
        current_nesting <- current_nesting - 1
      }
    }
    return(max_nesting)
  })
}","test_humaneval <- function() {
    candidate <- parse_nested_parens
    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c(2, 3, 1, 3))))
    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c(4))))
}
test_humaneval()"
HumanEval_7,fur_Latn,r,"Filtrâ une liste di input di stringhis dome par chês che a contegnin une specifiche sot-stringje # >>> filter_by_substring(c(), 'a')
# c()
# >>> filter_by_substring(c('abc', 'bacd', 'cde', 'array'), 'a')
# c('abc', 'bacd', 'array')
filter_by_substring <- function(strings, substring) {","filter_by_substring <- function(strings, substring) {
  return(strings[grepl(substring, strings)])
}","test_humaneval <- function() {
    candidate <- filter_by_substring
    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))
    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))
    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'), 'xx'), c('xxx', 'aaaxxy', 'xxxAAA', 'xxx'))))
    stopifnot(isTRUE(all.equal(candidate(c('grunt', 'trumpet', 'prune', 'gruesome'), 'run'), c('grunt', 'prune'))))
}
test_humaneval()"
HumanEval_8,fur_Latn,r,"La sume vueide e à di jessi avuâl a 0 e il prodot vueit al à di jessi avuâl a 1. Par une date liste di intîrs, torne une liste che e je fate di une sume e un prodot di ducj i intîrs intune liste. # >>> sum_product(c())
# c(0, 1)
# >>> sum_product(c(1, 2, 3, 4))
# c(10, 24)
sum_product <- function(numbers) {","sum_product <- function(numbers) {
  sum_val <- sum(numbers)
  prod_val <- ifelse(length(numbers) == 0, 1, prod(numbers))
  return(c(sum_val, prod_val))
}","test_humaneval <- function() {
    candidate <- sum_product
    stopifnot(isTRUE(all.equal(candidate(c()), c(0, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1)), c(3, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(100, 0)), c(100, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 7)), c(15, 105))))
    stopifnot(isTRUE(all.equal(candidate(c(10)), c(10, 10))))
}
test_humaneval()"
HumanEval_9,fur_Latn,r,"in sequence. Da une date liste dai intîrs, gjenere une liste dai elements plui grancj cjatâts fin al moment specificât # >>> rolling_max(c(1, 2, 3, 2, 3, 4, 2))
# c(1, 2, 3, 3, 3, 4, 4)
rolling_max <- function(numbers) {","rolling_max <- function(numbers) {
  max_list <- c()
  current_max <- -Inf
  for (number in numbers) {
    current_max <- max(current_max, number)
    max_list <- c(max_list, current_max)
  }
  return(max_list)
}","test_humaneval <- function() {
    candidate <- rolling_max
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))))
}
test_humaneval()"
HumanEval_10,fur_Latn,r,"- Agjornâ ae fin de stringhe il contrari di un prefìs stringhe che al ven prime dal sufiç palindromic. - Cjate il postfix plui lunc de stringhe furnide che al è un palindromo. L'algoritmi al è sempliç:Cjate il palindròm plui curt che al scomence cun une stringhe furnide. # >>> make_palindrome('')
# ''
# >>> make_palindrome('cat')
# 'catac'
# >>> make_palindrome('cata')
# 'catac'
make_palindrome <- function(string) {","make_palindrome <- function(string) {
  is_palindrome <- function(s) {
    return(s == stringi::stri_reverse(s))
  }
  
  n <- nchar(string)
  
  for (i in seq(n, 0, by = -1)) {
    suffix <- substr(string, i, n)
    if (is_palindrome(suffix)) {
      prefix <- substr(string, 1, i - 1)
      return(paste0(string, stringi::stri_reverse(prefix)))
    }
  }
  
  return(string) # for the empty string case
}","test_humaneval <- function() {
    candidate <- make_palindrome
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('x'), 'x')))
    stopifnot(isTRUE(all.equal(candidate('xyz'), 'xyzyx')))
    stopifnot(isTRUE(all.equal(candidate('xyx'), 'xyx')))
    stopifnot(isTRUE(all.equal(candidate('jerry'), 'jerryrrej')))
}
test_humaneval()"
HumanEval_11,fur_Latn,r,"Eseguìs XOR binari su chescj input e torne ancje il risultât come stringhe. Input a son dôs stringhis a e b che a son dome 1 e 0.# >>> string_xor('010', '110')
# '100'
string_xor <- function(a, b) {","string_xor <- function(a, b) {
  xor_result <- mapply(function(x, y) { 
    ifelse(x == y, 0, 1) 
  }, strsplit(a, NULL)[[1]], strsplit(b, NULL)[[1]])
  return(paste(xor_result, collapse = """"))
}","test_humaneval <- function() {
    candidate <- string_xor
    stopifnot(isTRUE(all.equal(candidate('111000', '101010'), '010010')))
    stopifnot(isTRUE(all.equal(candidate('1', '1'), '0')))
    stopifnot(isTRUE(all.equal(candidate('0101', '0000'), '0101')))
}
test_humaneval()"
HumanEval_12,fur_Latn,r,"Ritorne NULL se la liste di input e je vueide. Da la liste des stringhis, torne il plui lunc.# >>> longest(c())
# NULL
# >>> longest(c('a', 'b', 'c'))
# 'a'
# >>> longest(c('a', 'bb', 'ccc'))
# 'ccc'
longest <- function(strings) {","longest <- function(strings) {
  if (length(strings) == 0) return(NULL)
  longest_string <- strings[1]
  for (s in strings) {
    if (nchar(s) > nchar(longest_string)) {
      longest_string <- s
    }
  }
  return(longest_string)
}","test_humaneval <- function() {
    candidate <- longest
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'x')))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc')), 'zzzz')))
}
test_humaneval()"
HumanEval_13,fur_Latn,r,"Ritorne il plui grant comun divisôr di doi intîrs a e b # >>> greatest_common_divisor(3, 5)
# 1
# >>> greatest_common_divisor(25, 15)
# 5
greatest_common_divisor <- function(a, b) {","greatest_common_divisor <- function(a, b) {
  while (b != 0) {
    temp <- b
    b <- a %% b
    a <- temp
  }
  return(abs(a))
}","test_humaneval <- function() {
    candidate <- greatest_common_divisor
    stopifnot(isTRUE(all.equal(candidate(3, 7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10, 15), 5)))
    stopifnot(isTRUE(all.equal(candidate(49, 14), 7)))
    stopifnot(isTRUE(all.equal(candidate(144, 60), 12)))
}
test_humaneval()"
HumanEval_14,fur_Latn,r,"Al torne la liste di ducj i prefissis dal plui curt al plui lunc de stringhe di input # >>> all_prefixes('abc')
# c('a', 'ab', 'abc')
all_prefixes <- function(string) {","all_prefixes <- function(string) {
  prefixes <- character(nchar(string))
  for (i in seq_along(prefixes)) {
    prefixes[i] <- substr(string, 1, i)
  }
  return(prefixes)
}","test_humaneval <- function() {
    candidate <- all_prefixes
    stopifnot(isTRUE(all.equal(candidate(''), c())))
    stopifnot(isTRUE(all.equal(candidate('asdfgh'), c('a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'))))
    stopifnot(isTRUE(all.equal(candidate('WWW'), c('W', 'WW', 'WWW'))))
}
test_humaneval()"
HumanEval_15,fur_Latn,r,"Al torne une stringhe che e conten numars delimitât dal spazi che a scomencin di 0 fin a n includût. # >>> string_sequence(0)
# '0'
# >>> string_sequence(5)
# '0 1 2 3 4 5'
string_sequence <- function(n) {","string_sequence <- function(n) {
  return(paste(0:n, collapse = "" ""))
}","test_humaneval <- function() {
    candidate <- string_sequence
    stopifnot(isTRUE(all.equal(candidate(0), '0')))
    stopifnot(isTRUE(all.equal(candidate(3), '0 1 2 3')))
    stopifnot(isTRUE(all.equal(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')))
}
test_humaneval()"
HumanEval_16,fur_Latn,r,"Dât un string, cjate di cantos caratars distints (cence contâ il cas) al è fat # >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4
count_distinct_characters <- function(string) {","count_distinct_characters <- function(string) {
  # Convert the string to lowercase to handle case insensitivity
  lower_string <- tolower(string)
  # Split the string into individual characters
  chars <- strsplit(lower_string, NULL)[[1]]
  # Find the unique characters and count them
  distinct_count <- length(unique(chars))
  return(distinct_count)
}","test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()"
HumanEval_17,fur_Latn,r,"""Hockey"" - note di cuart, dure un toc""O savarès"" - mieç note, dure dôs batudis""O"" - note interie, e dure cuatri batudis Cheste e je une liende:no il ultin. Il to compit al è di analizâ cheste stringhe e tornâ a une liste di intîrs corispondents a cuâi batiments a fasin ognidun La jentrade di cheste funzion e je une stringhe che e rapresente lis notes musicâls intun formât ASCII speciâl.# >>> parse_music('o o| .| o| o| .| .| .| .| o o')
# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)
parse_music <- function(music_string) {","parse_music <- function(music_string) {
  # Split the input string by spaces to get individual notes
  notes <- strsplit(music_string, "" "")[[1]]
  
  # Map each note to its corresponding beat duration
  beats <- sapply(notes, function(note) {
    if (note == 'o') {
      return(4)
    } else if (note == 'o|') {
      return(2)
    } else if (note == '.|') {
      return(1)
    } else {
      stop(""Invalid note"")
    }
  })
  
  return(beats)
}

# Example usage:
# parse_music('o o| .| o| o| .| .| .| .| o o')
# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)","test_humaneval <- function() {
    candidate <- parse_music
    stopifnot(isTRUE(all.equal(candidate(''), c())))
    stopifnot(isTRUE(all.equal(candidate('o o o o'), c(4, 4, 4, 4))))
    stopifnot(isTRUE(all.equal(candidate('.| .| .| .|'), c(1, 1, 1, 1))))
    stopifnot(isTRUE(all.equal(candidate('o| o| .| .| o o o o'), c(2, 2, 1, 1, 4, 4, 4, 4))))
    stopifnot(isTRUE(all.equal(candidate('o| .| o| .| o o| o o|'), c(2, 1, 2, 1, 4, 2, 4, 2))))
}
test_humaneval()"
HumanEval_18,fur_Latn,r,"Cjate il numar di voltis che une stringhe di caratars e je intal stringhe origjinâl.# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
how_many_times <- function(string, substring) {","how_many_times <- function(string, substring) {
  if (nchar(substring) == 0) {
    return(0)
  }
  
  count <- 0
  for (i in seq(nchar(string) - nchar(substring) + 1)) {
    if (substr(string, i, i + nchar(substring) - 1) == substring) {
      count <- count + 1
    }
  }
  
  return(count)
}","test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()"
HumanEval_19,fur_Latn,r,"Torne la stringhe cun numars ordenâts dal plui piçul al plui grant Lis opzions validis a son ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"" e ""nine"". L'input e je une stringhe di numars dal ""zero"" al ""nine"" delimitât dal spazi.# >>> sort_numbers('three one five')
# 'one three five'
sort_numbers <- function(numbers) {","sort_numbers <- function(numbers) {
  words_to_numbers <- c(
    ""zero"" = 0, ""one"" = 1, ""two"" = 2, ""three"" = 3, ""four"" = 4, 
    ""five"" = 5, ""six"" = 6, ""seven"" = 7, ""eight"" = 8, ""nine"" = 9
  )
  
  number_list <- strsplit(numbers, "" "")[[1]]
  sorted_numbers <- number_list[order(sapply(number_list, function(word) words_to_numbers[word]))]
  return(paste(sorted_numbers, collapse = "" ""))
}","test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()"
HumanEval_20,fur_Latn,r,"altri e tornâ a dâju in ordin (plui piçul numar, plui grant numar).Da une liste di numars (di lungjece almancul dôs) si selezionin e si rindin dôs che a son lis plui dongje di ognidun # >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)
find_closest_elements <- function(numbers) {","find_closest_elements <- function(numbers) {
  sorted_numbers <- sort(numbers)
  min_diff <- Inf
  closest_pair <- c()

  for (i in 1:(length(sorted_numbers) - 1)) {
    diff <- sorted_numbers[i + 1] - sorted_numbers[i]
    if (diff < min_diff) {
      min_diff <- diff
      closest_pair <- c(sorted_numbers[i], sorted_numbers[i + 1])
    }
  }

  return(closest_pair)
}","test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()"
HumanEval_21,fur_Latn,r,"cussì che il plui piçul numar al deventarà 0 e il plui grant 1 Dât un elenc di numars (di almancul doi elements), aplica une trasformazion lineâr a chel elenc, # >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
rescale_to_unit <- function(numbers) {","rescale_to_unit <- function(numbers) {
  min_val <- min(numbers)
  max_val <- max(numbers)
  (numbers - min_val) / (max_val - min_val)
}","test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()"
HumanEval_22,fur_Latn,r,"Filtre la liste dai valôrs rthon dome pai intîrs # >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
filter_integers <- function(values) {","filter_integers <- function(values) {
  return(unlist(Filter(is.integer, values)))
}","test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()"
HumanEval_23,fur_Latn,r,"Ritornâ la lungjece de stringhe dât # >>> strlen('')
# 0
# >>> strlen('abc')
# 3
strlen <- function(string) {","strlen <- function(string) {
  return(nchar(string))
}","test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()"
HumanEval_24,fur_Latn,r,"Par un numar dât n, cîr il numar plui grant che al divît n in maniere uniforme, plui piçul di n # >>> largest_divisor(15)
# 5
largest_divisor <- function(n) {","largest_divisor <- function(n) {
  for (i in (n-1):1) {
    if (n %% i == 0) {
      return(i)
    }
  }
}","test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()"
HumanEval_25,fur_Latn,r,"Il numar di input al varès di jessi avuâl al prodot di ducj i fatôrs.Ogni fatôr al à di jessi listât il numar di voltis che al corispuint a ce tantis voltis che al ven fûr inte fatorizazion.Al torne la liste dai fatôrs prins di un ciert intîr in ordin dal plui piçul al plui grant.# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
factorize <- function(n) {","factorize <- function(n) {
  if (n < 2) {
    return(c())
  }
  factors <- c()
  divisor <- 2
  
  while (n > 1) {
    while (n %% divisor == 0) {
      factors <- c(factors, divisor)
      n <- n / divisor
    }
    divisor <- divisor + 1
  }
  
  return(factors)
}","test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()"
HumanEval_26,fur_Latn,r,"Mantignî l'ordin dai elements lassâts come tal input.Da une liste di intîrs, gjavâ ducj i elements che a son plui di une volte.# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
remove_duplicates <- function(numbers) {","remove_duplicates <- function(numbers) {
  unique_numbers <- numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]
  return(unique_numbers)
}","test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()"
HumanEval_27,fur_Latn,r,"Par une stringhe dât, cambiâ i caratars minuscui in maiuscul e i maiusculs in minuscui. # >>> flip_case('Hello')
# 'hELLO'
flip_case <- function(string) {","flip_case <- function(string) {
  chars <- strsplit(string, NULL)[[1]]
  flipped_chars <- sapply(chars, function(c) {
    if (grepl(""[a-z]"", c)) {
      return(toupper(c))
    } else if (grepl(""[A-Z]"", c)) {
      return(tolower(c))
    } else {
      return(c)
    }
  })
  return(paste(flipped_chars, collapse = """"))
}","test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()"
HumanEval_28,fur_Latn,r,"Concatenâ lis stringhis intune singule stringhe# >>> concatenate(c())
# ''
# >>> concatenate(c('a', 'b', 'c'))
# 'abc'
concatenate <- function(strings) {","concatenate <- function(strings) {
  paste(strings, collapse = """")
}","test_humaneval <- function() {
    candidate <- concatenate
    stopifnot(isTRUE(all.equal(candidate(c()), '')))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'xyz')))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z', 'w', 'k')), 'xyzwk')))
}
test_humaneval()"
HumanEval_29,fur_Latn,r,"Filtre une liste di stradis di input dome par chês che a scomencin cuntun prefìs dât. # >>> filter_by_prefix(c(), 'a')
# c()
# >>> filter_by_prefix(c('abc', 'bcd', 'cde', 'array'), 'a')
# c('abc', 'array')
filter_by_prefix <- function(strings, prefix) {","filter_by_prefix <- function(strings, prefix) {
  return(strings[startsWith(strings, prefix)])
}","test_humaneval <- function() {
    candidate <- filter_by_prefix
    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))
    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))
}
test_humaneval()"
HumanEval_30,fur_Latn,r,"Torne dome i numars positîfs de liste. # >>> get_positive(c(-1, 2, -4, 5, 6))
# c(2, 5, 6)
# >>> get_positive(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))
# c(5, 3, 2, 3, 9, 123, 1)
get_positive <- function(l) {","get_positive <- function(l) {
  return(l[l > 0])
}","test_humaneval <- function() {
    candidate <- get_positive
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 4, 5, 6)), c(4, 5, 6))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)), c(5, 3, 2, 3, 3, 9, 123, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2)), c())))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
}
test_humaneval()"
HumanEval_31,fur_Latn,r,"Al torne vêr se un dât numar al è prin, e fals se no.# >>> is_prime(6)
# FALSE
# >>> is_prime(101)
# TRUE
# >>> is_prime(11)
# TRUE
# >>> is_prime(13441)
# TRUE
# >>> is_prime(61)
# TRUE
# >>> is_prime(4)
# FALSE
# >>> is_prime(1)
# FALSE
is_prime <- function(n) {","is_prime <- function(n) {
  if (n <= 1) {
    return(FALSE)
  }
  if (n <= 3) {
    return(TRUE)
  }
  if (n %% 2 == 0 || n %% 3 == 0) {
    return(FALSE)
  }
  i <- 5
  while (i * i <= n) {
    if (n %% i == 0 || n %% (i + 2) == 0) {
      return(FALSE)
    }
    i <- i + 6
  }
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- is_prime
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(101), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13441), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(61), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(17), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(85), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(77), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(255379), FALSE)))
}
test_humaneval()"
HumanEval_33,fur_Latn,r,"I indics di l corispuindint ai valôrs di l, ma ordenâts.l' al è identic a l tai indizis che no son diviers di trê, invezit i siei valôrs tai indizis che a son diviers di trê a son compagns Cheste funzion e cjape une liste l e e torne une liste l' di mût che # >>> sort_third(c(1, 2, 3))
# c(1, 2, 3)
# >>> sort_third(c(5, 6, 3, 4, 8, 9, 2))
# c(2, 6, 3, 4, 8, 9, 5)
sort_third <- function(l) {","sort_third <- function(l) {
  # Find the indices that are divisible by three
  indices_div_by_3 <- seq(3, length(l), by = 3)
  
  # Extract the elements at those indices and sort them
  elements_to_sort <- l[indices_div_by_3]
  sorted_elements <- sort(elements_to_sort)
  
  # Replace the original elements at those indices with sorted ones
  l[indices_div_by_3] <- sorted_elements
  
  return(l)
}","test_humaneval <- function() {
    candidate <- sort_third
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2)), c(2, 6, 3, 4, 8, 9, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 3, 4, 6, 9, 2)), c(2, 8, 3, 4, 6, 9, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 9, 4, 8, 3, 2)), c(2, 6, 9, 4, 8, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2, 1)), c(2, 6, 3, 4, 8, 9, 5, 1))))
}
test_humaneval()"
HumanEval_34,fur_Latn,r,"Torne i elements unics ordenâts intune liste# >>> unique(c(5, 3, 5, 2, 3, 3, 9, 0, 123))
# c(0, 2, 3, 5, 9, 123)
unique <- function(l) {","unique <- function(l) {
  return(sort(unique(l)))
}","test_humaneval <- function() {
    candidate <- unique
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 5, 2, 3, 3, 9, 0, 123)), c(0, 2, 3, 5, 9, 123))))
}
test_humaneval()"
HumanEval_35,fur_Latn,r,"Al torne il massim element de liste. # >>> max_element(c(1, 2, 3))
# 3
# >>> max_element(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))
# 123
max_element <- function(l) {","max_element <- function(l) {
  return(max(l))
}","test_humaneval <- function() {
    candidate <- max_element
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10)), 124)))
}
test_humaneval()"
HumanEval_36,fur_Latn,r,"Al torne il numar di voltis che la cifre 7 e je dentri di intîrs minôrs di n che a son diviers di 11 o 13. # >>> fizz_buzz(50)
# 0
# >>> fizz_buzz(78)
# 2
# >>> fizz_buzz(79)
# 3
fizz_buzz <- function(n) {","fizz_buzz <- function(n) {
  count <- 0
  for (i in 1:(n-1)) {
    if (i %% 11 == 0 || i %% 13 == 0) {
      count <- count + sum(unlist(strsplit(as.character(i), """")) == ""7"")
    }
  }
  return(count)
}","test_humaneval <- function() {
    candidate <- fizz_buzz
    stopifnot(isTRUE(all.equal(candidate(50), 0)))
    stopifnot(isTRUE(all.equal(candidate(78), 2)))
    stopifnot(isTRUE(all.equal(candidate(79), 3)))
    stopifnot(isTRUE(all.equal(candidate(100), 3)))
    stopifnot(isTRUE(all.equal(candidate(200), 6)))
    stopifnot(isTRUE(all.equal(candidate(4000), 192)))
    stopifnot(isTRUE(all.equal(candidate(10000), 639)))
    stopifnot(isTRUE(all.equal(candidate(100000), 8026)))
}
test_humaneval()"
HumanEval_37,fur_Latn,r,"I indicis par i indicis par di l, ma ordenâts.l' al è identic a l tai indizis dispari, invezit i siei valôrs tai indizis pari a son compagns Cheste funzion e cjape une liste l e e torne une liste l' di mût che # >>> sort_even(c(1, 2, 3))
# c(1, 2, 3)
# >>> sort_even(c(5, 6, 3, 4))
# c(3, 6, 5, 4)
sort_even <- function(l) {","sort_even <- function(l) {
  even_indices <- seq(2, length(l), by=2)
  l[even_indices] <- sort(l[even_indices])
  return(l)
}","test_humaneval <- function() {
    candidate <- sort_even
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(1, 2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)), c(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, -12, 4, 23, 2, 3, 11, 12, -10)), c(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10))))
}
test_humaneval()"
HumanEval_39,fur_Latn,r,"prime_fib al torne il numar n-esim che al è un numar di Fibonacci e al è ancje un numar prin. # >>> prime_fib(1)
# 2
# >>> prime_fib(2)
# 3
# >>> prime_fib(3)
# 5
# >>> prime_fib(4)
# 13
# >>> prime_fib(5)
# 89
prime_fib <- function(n) {","prime_fib <- function(n) {
  is_prime <- function(num) {
    if (num < 2) return(FALSE)
    for (i in 2:sqrt(num)) {
      if (num %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  fibonacci <- function() {
    a <- 0
    b <- 1
    while (TRUE) {
      yield <- a + b
      a <<- b
      b <<- yield
      yield
    }
  }
  
  fib_gen <- fibonacci()
  count <- 0
  repeat {
    current_fib <- fib_gen()
    if (is_prime(current_fib)) {
      count <- count + 1
      if (count == n) return(current_fib)
    }
  }
}","test_humaneval <- function() {
    candidate <- prime_fib
    stopifnot(isTRUE(all.equal(candidate(1), 2)))
    stopifnot(isTRUE(all.equal(candidate(2), 3)))
    stopifnot(isTRUE(all.equal(candidate(3), 5)))
    stopifnot(isTRUE(all.equal(candidate(4), 13)))
    stopifnot(isTRUE(all.equal(candidate(5), 89)))
    stopifnot(isTRUE(all.equal(candidate(6), 233)))
    stopifnot(isTRUE(all.equal(candidate(7), 1597)))
    stopifnot(isTRUE(all.equal(candidate(8), 28657)))
    stopifnot(isTRUE(all.equal(candidate(9), 514229)))
    stopifnot(isTRUE(all.equal(candidate(10), 433494437)))
}
test_humaneval()"
HumanEval_40,fur_Latn,r,"sum a zero, e FALSE in altri câs. al torne TRUE se a son trê elements distints inte liste che triples_sum_to_zero al cjape une liste di intîrs come input. # >>> triples_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> triples_sum_to_zero(c(1, 3, -2, 1))
# TRUE
# >>> triples_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> triples_sum_to_zero(c(2, 4, -5, 3, 9, 7))
# TRUE
# >>> triples_sum_to_zero(c(1))
# FALSE
triples_sum_to_zero <- function(l) {","triples_sum_to_zero <- function(l) {
  n <- length(l)
  if (n < 3) {
    return(FALSE)
  }
  for (i in 1:(n - 2)) {
    for (j in (i + 1):(n - 1)) {
      for (k in (j + 1):n) {
        if (l[i] + l[j] + l[k] == 0) {
          return(TRUE)
        }
      }
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- triples_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 5, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 9, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -100)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(100, 3, 5, -100)), FALSE)))
}
test_humaneval()"
HumanEval_41,fur_Latn,r,"Cheste funzion e rive a il numar di chestis colisions. La lôr traietorie e je come se no si fossin mai scontradis.Dut câs, lis machinis a son une vore robustas e fuartis; par chest a van indenant.Cuant che une machine che e va di çampe a drete e colpìs une machine che e va di drete a çampe.Ducj i veicui a van a la stesse velocitât.Lis dôs machinis a scomencin a jessi une vore lontanis di n autôs a van di çampe a drete; in simultanie, un altri grup di n autôs Imagjinìn une strade che e je une linie perfete e direte infinide.car_race_collision <- function(n) {","car_race_collision <- function(n) {
  # Each car moving left to right will eventually collide with each car moving right to left
  return(n)
}","test_humaneval <- function() {
    candidate <- car_race_collision
    stopifnot(isTRUE(all.equal(candidate(2), 4)))
    stopifnot(isTRUE(all.equal(candidate(3), 9)))
    stopifnot(isTRUE(all.equal(candidate(4), 16)))
    stopifnot(isTRUE(all.equal(candidate(8), 64)))
    stopifnot(isTRUE(all.equal(candidate(10), 100)))
}
test_humaneval()"
HumanEval_42,fur_Latn,r,"Liste di tornade cun elements incrementâts di 1. # >>> incr_list(c(1, 2, 3))
# c(2, 3, 4)
# >>> incr_list(c(5, 3, 5, 2, 3, 3, 9, 0, 123))
# c(6, 4, 6, 3, 4, 4, 10, 1, 124)
incr_list <- function(l) {","incr_list <- function(l) {
  return(l + 1)
}","test_humaneval <- function() {
    candidate <- incr_list
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(4, 3, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 2, 5, 2, 3, 3, 9, 0, 123)), c(6, 3, 6, 3, 4, 4, 10, 1, 124))))
}
test_humaneval()"
HumanEval_43,fur_Latn,r,"sum a zero, e FALSE in altri câs. al torne TRUE se a son doi elements diferents inte liste che pairs_sum_to_zero al cjape une liste di intîrs come input. # >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE
pairs_sum_to_zero <- function(l) {","pairs_sum_to_zero <- function(l) {
  n <- length(l)
  if (n < 2) return(FALSE)
  
  for (i in 1:(n-1)) {
    for (j in (i+1):n) {
      if (l[i] + l[j] == 0) {
        return(TRUE)
      }
    }
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()"
HumanEval_44,fur_Latn,r,"i numars di base a son mancul di 10.al torne a rapresentâ la stringhe dopo de conversion.Cambiâ la base numeriche dal numar di jentrade x par base.# >>> change_base(8, 3)
# '22'
# >>> change_base(8, 2)
# '1000'
# >>> change_base(7, 2)
# '111'
change_base <- function(x, base) {","change_base <- function(x, base) {
  if (x == 0) return('0')
  result <- ''
  while (x > 0) {
    remainder <- x %% base
    result <- paste0(remainder, result)
    x <- x %/% base
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- change_base
    stopifnot(isTRUE(all.equal(candidate(8, 3), '22')))
    stopifnot(isTRUE(all.equal(candidate(9, 3), '100')))
    stopifnot(isTRUE(all.equal(candidate(234, 2), '11101010')))
    stopifnot(isTRUE(all.equal(candidate(16, 2), '10000')))
    stopifnot(isTRUE(all.equal(candidate(8, 2), '1000')))
    stopifnot(isTRUE(all.equal(candidate(7, 2), '111')))
    stopifnot(isTRUE(all.equal(candidate(2, 3), '2')))
    stopifnot(isTRUE(all.equal(candidate(3, 4), '3')))
    stopifnot(isTRUE(all.equal(candidate(4, 5), '4')))
    stopifnot(isTRUE(all.equal(candidate(5, 6), '5')))
    stopifnot(isTRUE(all.equal(candidate(6, 7), '6')))
    stopifnot(isTRUE(all.equal(candidate(7, 8), '7')))
}
test_humaneval()"
HumanEval_45,fur_Latn,r,"Dade la lungjece di un lat e la alte aree di tornade par un triangul.# >>> triangle_area(5, 3)
# 7.5
triangle_area <- function(a, h) {","triangle_area <- function(a, h) {
  return(0.5 * a * h)
}","test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(5, 3), 7.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 2), 2.0)))
    stopifnot(isTRUE(all.equal(candidate(10, 8), 40.0)))
}
test_humaneval()"
HumanEval_46,fur_Latn,r,"Par plasê scrivi une funzion par calcolâ in mût efficient l'element n-esim de secuence di numars fib4. No doprâ la ricorzion. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 La secuence dai numars Fib4 e je une secuence simil a chê di Fibbonacci che e je definide cussì: # >>> fib4(5)
# 4
# >>> fib4(6)
# 8
# >>> fib4(7)
# 14
fib4 <- function(n) {","fib4 <- function(n) {
  if (n == 0) return(0)
  if (n == 1) return(0)
  if (n == 2) return(2)
  if (n == 3) return(0)
  
  fib_seq <- c(0, 0, 2, 0) # Initialize with base cases
  for (i in 4:n) {
    fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2] + fib_seq[i-3] + fib_seq[i-4]
  }
  return(fib_seq[n])
}","test_humaneval <- function() {
    candidate <- fib4
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 28)))
    stopifnot(isTRUE(all.equal(candidate(10), 104)))
    stopifnot(isTRUE(all.equal(candidate(12), 386)))
}
test_humaneval()"
HumanEval_47,fur_Latn,r,"Mediane di tornade dai elements de liste l. # >>> median(c(3, 1, 2, 4, 5))
# 3
# >>> median(c(-10, 4, 6, 1000, 10, 20))
# 15.0
median <- function(l) {","median <- function(l) {
  return(median(l))
}","test_humaneval <- function() {
    candidate <- median
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(-10, 4, 6, 1000, 10, 20)), 8.0)))
    stopifnot(isTRUE(all.equal(candidate(c(5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 5)), 5.5)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 1, 3, 9, 9, 2, 7)), 7)))
}
test_humaneval()"
HumanEval_48,fur_Latn,r,"Controlâ se la stringhe e je un palindromo# >>> is_palindrome('')
# TRUE
# >>> is_palindrome('aba')
# TRUE
# >>> is_palindrome('aaaaa')
# TRUE
# >>> is_palindrome('zbcd')
# FALSE
is_palindrome <- function(text) {","is_palindrome <- function(text) {
  return(text == paste(rev(unlist(strsplit(text, NULL))), collapse = """"))
}","test_humaneval <- function() {
    candidate <- is_palindrome
    stopifnot(isTRUE(all.equal(candidate(''), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aba'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aaaaa'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('zbcd'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('xywyx'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xywyz'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('xywzx'), FALSE)))
}
test_humaneval()"
HumanEval_49,fur_Latn,r,"Torne 2^n modulo p (si à di jessi cussients dai numars).# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
modp <- function(n, p) {","modp <- function(n, p) {
  result <- 1
  base <- 2
  
  while (n > 0) {
    if (n %% 2 == 1) {
      result <- (result * base) %% p
    }
    base <- (base * base) %% p
    n <- n %/% 2
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()"
HumanEval_51,fur_Latn,r,"remove_vowels e je une funzion che e cjape stringhe e e torne stringhe cence vocâls. # >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
remove_vowels <- function(text) {","remove_vowels <- function(text) {
  gsub(""[aeiouAEIOU]"", """", text)
}","test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()"
HumanEval_52,fur_Latn,r,"Al torne TRUE se ducj i numars de liste l a son sot dal tiermin t. # >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
below_threshold <- function(l, t) {","below_threshold <- function(l, t) {
  return(all(l < t))
}","test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()"
HumanEval_53,fur_Latn,r,"Zontâ doi numars x e y # >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
add <- function(x, y) {","add <- function(x, y) {
  return(x + y)
}","test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()"
HumanEval_54,fur_Latn,r,"Controlâ se dôs peraulis a àn i stes caratars. # >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
same_chars <- function(s0, s1) {","same_chars <- function(s0, s1) {
  return(identical(sort(unique(unlist(strsplit(s0, """")))), sort(unique(unlist(strsplit(s1, """"))))))
}","test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()"
HumanEval_55,fur_Latn,r,"Ritorne il numar di Fibonacci n-esim. # >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
fib <- function(n) {","fib <- function(n) {
  if (n <= 1) {
    return(n)
  }
  a <- 0
  b <- 1
  for (i in 2:n) {
    temp <- b
    b <- a + b
    a <- temp
  }
  return(b)
}","test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()"
HumanEval_56,fur_Latn,r,"return TRUE se ogni bracket di vierzidure e à une bracket di sieradure corispondent. ""<"" e "">"". # >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE
correct_bracketing <- function(brackets) {","correct_bracketing <- function(brackets) {
  count <- 0
  for (char in strsplit(brackets, NULL)[[1]]) {
    if (char == ""<"") {
      count <- count + 1
    } else if (char == "">"") {
      count <- count - 1
    }
    if (count < 0) {
      return(FALSE)
    }
  }
  return(count == 0)
}","test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()"
HumanEval_57,fur_Latn,r,"Al torne TRUE se i elements de liste a son in mût monoton in cressite o in decrescite. # >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
monotonic <- function(l) {","monotonic <- function(l) {
  is_increasing <- all(diff(l) >= 0)
  is_decreasing <- all(diff(l) <= 0)
  return(is_increasing || is_decreasing)
}","test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()"
HumanEval_58,fur_Latn,r,"Al torne a ordenâ elements comuns unics par dôs listis.# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
common <- function(l1, l2) {","common <- function(l1, l2) {
  common_elements <- intersect(l1, l2)
  sorted_unique_common <- sort(unique(common_elements))
  return(sorted_unique_common)
}","test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()"
HumanEval_59,fur_Latn,r,"Ritorne il plui grant fatôr prin di n. Si supon che n > 1 e nol sedi un numar prin. # >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
largest_prime_factor <- function(n) {","largest_prime_factor <- function(n) {
  # Initialize the largest prime factor
  largest_prime <- -1
  
  # Remove factors of 2
  while (n %% 2 == 0) {
    largest_prime <- 2
    n <- n / 2
  }
  
  # Try odd factors from 3 upwards
  factor <- 3
  while (factor * factor <= n) {
    while (n %% factor == 0) {
      largest_prime <- factor
      n <- n / factor
    }
    factor <- factor + 2
  }
  
  # If n is a prime number greater than 2
  if (n > 2) {
    largest_prime <- n
  }
  
  # Return the largest prime factor found
  return(largest_prime)
}","test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()"
HumanEval_60,fur_Latn,r,"sum_to_n e je une funzion che e somme i numars di 1 a n. # >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
sum_to_n <- function(n) {","sum_to_n <- function(n) {
  return(sum(1:n))
}","test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()"
HumanEval_61,fur_Latn,r,"return TRUE se ogni bracket di vierzidure e à une bracket di sieradure corispondent. parentesis e je une stringhe di ""("" e "")"". # >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE
correct_bracketing <- function(brackets) {","correct_bracketing <- function(brackets) {
  balance <- 0
  for (char in strsplit(brackets, NULL)[[1]]) {
    if (char == ""("") {
      balance <- balance + 1
    } else if (char == "")"") {
      balance <- balance - 1
    }
    if (balance < 0) {
      return(FALSE)
    }
  }
  return(balance == 0)
}","test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()"
HumanEval_62,fur_Latn,r,"Torne la derivade di chest polinomi te stesse forme.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs a rapresentin i coeficients di un polinomi. # >>> derivative(c(3, 1, 2, 4, 5))
# c(1, 4, 12, 20)
# >>> derivative(c(1, 2, 3))
# c(2, 6)
derivative <- function(xs) {","derivative <- function(xs) {
  n <- length(xs)
  if (n <= 1) return(numeric(0))  # Derivative of a constant is zero
  
  deriv <- numeric(n - 1)
  for (i in 2:n) {
    deriv[i - 1] <- xs[i] * (i - 1)
  }
  return(deriv)
}","test_humaneval <- function() {
    candidate <- derivative
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), c(1, 4, 12, 20))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 6))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1, 0, 4)), c(2, 2, 0, 16))))
    stopifnot(isTRUE(all.equal(candidate(c(1)), c())))
}
test_humaneval()"
HumanEval_63,fur_Latn,r,"Scrivi une funzion par calcolâ in mût efficient l'element n-esim de secuence di numars fibfib. fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). fig. [it. sbiadito adi.] (di cdn. che al à une sensibilitât)fig. [it. sbiadito adi.] (di cdn. che al à lafibfib(0) == 0 La secuence dai numars FibFib e je une secuence simil a chê di Fibbonacci che e je definide cussì: # >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24
fibfib <- function(n) {","fibfib <- function(n) {
  # Base cases
  if (n == 0) return(0)
  if (n == 1) return(0)
  if (n == 2) return(1)

  # Initialize the first three values
  fibfib_values <- c(0, 0, 1)
  
  # Compute fibfib for the rest using iteration
  for (i in 3:n) {
    fibfib_values[i + 1] <- fibfib_values[i] + fibfib_values[i - 1] + fibfib_values[i - 2]
  }
  # Return the nth value
  return(fibfib_values[n + 1])
}","test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()"
HumanEval_64,fur_Latn,r,"Esempli: la vocâl, ma dome cuant che e je a la fin de peraule.Lis vocâls in chest câs a son ""a"", ""e"", ""i"", ""o"", ""u"".une peraule come input e e torne il numar di vocâls inte stringhe. Scrivi une funzion vowels_count che e cjape une stringhe che e rapresente # >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
vowels_count <- function(s) {","vowels_count <- function(s) {
  s <- tolower(s)
  n <- nchar(s)
  count <- sum(unlist(strsplit(s, NULL)) %in% c('a', 'e', 'i', 'o', 'u'))
  if (n > 0 && substr(s, n, n) == 'y') {
    count <- count + 1
  }
  return(count)
}","test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()"
HumanEval_65,fur_Latn,r,"Se shift > numar di cifras, al torne a inviâ lis cifras. e al torne il risultât come stringhe. Circolâr spostâ lis cifris dal intîr x, spostâ lis cifris a diestre par spostament # >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
circular_shift <- function(x, shift) {","circular_shift <- function(x, shift) {
  digits <- as.character(x)
  n <- nchar(digits)
  
  if (shift > n) {
    return(paste0(rev(unlist(strsplit(digits, """"))), collapse = """"))
  }
  
  shift <- shift %% n
  if (shift == 0) {
    return(digits)
  }
  
  right_part <- substr(digits, n - shift + 1, n)
  left_part <- substr(digits, 1, n - shift)
  result <- paste0(right_part, left_part)
  
  return(result)
}","test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()"
HumanEval_66,fur_Latn,r,"Esemplis: Codis ASCII. Scrivi une funzion che e cjapi une stringhe come input e e torne dome la sume dai caratars superiôrs' Cjâf di vore # >>> digitSum('')
# 0
# >>> digitSum('abAB')
# 131
# >>> digitSum('abcCd')
# 67
# >>> digitSum('helloE')
# 69
# >>> digitSum('woArBld')
# 131
# >>> digitSum('aAaaaXa')
# 153
digitSum <- function(s) {","digitSum <- function(s) {
  sum(sapply(unlist(strsplit(s, """")), function(x) {
    if (grepl(""[A-Z]"", x)) {
      return(as.integer(charToRaw(x)))
    } else {
      return(0)
    }
  }))
}","test_humaneval <- function() {
    candidate <- digitSum
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abAB'), 131)))
    stopifnot(isTRUE(all.equal(candidate('abcCd'), 67)))
    stopifnot(isTRUE(all.equal(candidate('helloE'), 69)))
    stopifnot(isTRUE(all.equal(candidate('woArBld'), 131)))
    stopifnot(isTRUE(all.equal(candidate('aAaaaXa'), 153)))
    stopifnot(isTRUE(all.equal(candidate(' How are yOu?'), 151)))
    stopifnot(isTRUE(all.equal(candidate('You arE Very Smart'), 327)))
}
test_humaneval()"
HumanEval_67,fur_Latn,r,"par esamble: tal cric al torne il numar di mangjis tal cric. lis narancis e lis mele e un intîr che al rapresente il numar totâl dai fruits Dât il numar che al rapresente il numar totâl di che a son distribuîts intune cjarte di frute che cheste cjarte e conten In chest compit, ti vignarà dade une stringhe che e rapresente un numar di pomis e naranzis.# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19
fruit_distribution <- function(s, n) {","fruit_distribution <- function(s, n) {
  # Extract numbers using regular expressions
  matches <- regmatches(s, gregexpr(""\\d+"", s))
  # Convert extracted number strings to integers
  fruits_count <- as.integer(unlist(matches))
  # Total fruits described in the string
  total_apples_oranges <- sum(fruits_count)
  # Calculate mangoes
  mangoes <- n - total_apples_oranges
  return(mangoes)
}","test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()"
HumanEval_68,fur_Latn,r,"Esempli 1: Se no son valôrs pari o il vetôr dât al è vueit, torne []. Il nôt cjapât al varès di jessi tornât intune liste, [smallest_value, il so indiç] , Se a son cjatâts plui nodis cul stes valôr plui piçul e par, torne il nod che al à il indiç plui piçul. Il nod cjocât al varès di jessi il nod cul valôr pari plui piçul.Il to compit al è di tirâ fûr un dai nodis e tornâ indaûr.""Dât un vetôr che al rapresente un ram di un arbul che al à nodis intîrs no negatîfs # >>> pluck(c(4, 2, 3))
# c(2, 1)
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck(c(1, 2, 3))
# c(2, 1)
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck(c())
# c()
# Example 4:
# >>> pluck(c(5, 0, 3, 0, 4, 2))
# c(0, 1)
# Explanation: 0 is the smallest value, but  there are two zeros,
#              so we will choose the first zero, which has the smallest index.
# Constraints:
#     * 1 <= nodes.length <= 10000
#     * 0 <= node.value
pluck <- function(arr) {","pluck <- function(arr) {
  # Find indices for even numbers in the array
  even_indices <- which(arr %% 2 == 0)
  
  # If no even numbers are found, return an empty list
  if (length(even_indices) == 0) {
    return(c())
  }
  
  # Extract even numbers
  even_values <- arr[even_indices]
  
  # Find the smallest even value
  min_even_value <- min(even_values)
  
  # Find the index of the first occurrence of the smallest even value
  min_index <- even_indices[which.min(even_values)]
  
  # Return the smallest even value and its index (0-based index)
  return(c(min_even_value, min_index - 1))
}","test_humaneval <- function() {
    candidate <- pluck
    stopifnot(isTRUE(all.equal(candidate(c(4, 2, 3)), c(2, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 1))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 0, 3, 0, 4, 2)), c(0, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 0, 5, 3)), c(0, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 8, 4, 8)), c(4, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(7, 6, 7, 1)), c(6, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 7, 1)), c())))
}
test_humaneval()"
HumanEval_69,fur_Latn,r,"Esemplis: Se no esisti un valôr di cheste fate, torne -1.La frecuence di un intîr e je il numar di voltis che al compare te liste.zero, e al à une frecuence plui grande di o avuâl al valôr dal intîr stes. Tu âs une liste no vueide di intîrs positifs.# >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1
search <- function(lst) {","search <- function(lst) {
  # Calculate the frequency table
  freq_table <- table(lst)
  
  # Convert to a data frame for easier processing
  freq_df <- as.data.frame(freq_table)
  
  # Rename columns for convenience
  names(freq_df) <- c(""value"", ""frequency"")
  
  # Filter the values where the frequency is greater than or equal to the value itself
  valid_values <- freq_df[freq_df$value <= freq_df$frequency, ""value""]
  
  # If no valid values exist, return -1
  if (length(valid_values) == 0) {
    return(-1)
  }
  
  # Otherwise, return the greatest valid value
  return(max(valid_values))
}","test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()"
HumanEval_70,fur_Latn,r,"Esemplis: daspò il massim dai intîrs restants, daspò il minim e vie indenant.La classificazion stranie e je cuant che tu scomencis cul valôr minim, Dât une liste di intîrs, torne la liste in ordin stran.# >>> strange_sort_list(c(1, 2, 3, 4))
# c(1, 4, 2, 3)
# >>> strange_sort_list(c(5, 5, 5, 5))
# c(5, 5, 5, 5)
# >>> strange_sort_list(c())
# c()
strange_sort_list <- function(lst) {","strange_sort_list <- function(lst) {
  result <- c()
  while (length(lst) > 0) {
    # Find and append the minimum of the list
    min_val <- min(lst)
    result <- c(result, min_val)
    lst <- lst[lst != min_val]
    
    # Check if list is not empty before finding maximum
    if (length(lst) > 0) {
      # Find and append the maximum of the list
      max_val <- max(lst)
      result <- c(result, max_val)
      lst <- lst[lst != max_val]
    }
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- strange_sort_list
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 4, 2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9)), c(5, 9, 6, 8, 7))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), c(1, 5, 2, 4, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9, 1)), c(1, 9, 5, 8, 6, 7))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5)), c(5, 5, 5, 5))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8)), c(1, 8, 2, 7, 3, 6, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(0, 2, 2, 2, 5, 5, -5, -5)), c(-5, 5, -5, 5, 0, 2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(111111)), c(111111))))
}
test_humaneval()"
HumanEval_71,fur_Latn,r,"Esempli: che il tierç plan.Trê bandis a formin un triangul valid cuant che la sume di cualsisei dôs bandis e je plui grande.In câs contrari, al torne -1 il triangul rotondât a 2 ponts decimâi se i trê ladris a formin un triangul valid. Dadis lis lungjis dai trê ladrâts di un triangul, torne l'are di # >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1
triangle_area <- function(a, b, c) {","triangle_area <- function(a, b, c) {
  if (a + b > c && a + c > b && b + c > a) {
    # Using Heron's formula
    s <- (a + b + c) / 2
    area <- sqrt(s * (s - a) * (s - b) * (s - c))
    return(round(area, 2))
  } else {
    return(-1)
  }
}","test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()"
HumanEval_72,fur_Latn,r,"Esempli: L'ogjet q al volarà se al è in equilibri (e je une liste palindromiche) e la sume dai siei elements e je minôr o avuâl al massim pês pussibil w.Scrivi une funzion che e torni VÊR se l'ogjet q al volarà, e FALS se no. # >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.
will_it_fly <- function(q, w) {","will_it_fly <- function(q, w) {
  is_palindromic <- function(lst) {
    return(all(lst == rev(lst)))
  }
  
  is_balanced <- is_palindromic(q)
  sum_elements <- sum(q)
  
  return(is_balanced && (sum_elements <= w))
}","test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()"
HumanEval_73,fur_Latn,r,"Par esempli: Al è il stes discors in sens contrari. intun cambiament, tu puedis cambiâ un element cun un altri element.al bisugne cambiâ par fâ il vetôr palindromic. Un vetôr palindromic al è un vetôr che Dât un vetôr arr di intîrs, cjate il numar minim di elements che # >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
smallest_change <- function(arr) {","smallest_change <- function(arr) {
  n <- length(arr)
  changes <- 0
  
  for (i in 1:(n %/% 2)) {
    if (arr[i] != arr[n - i + 1]) {
      changes <- changes + 1
    }
  }
  
  return(changes)
}","test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()"
HumanEval_74,fur_Latn,r,"Esemplis Se lis dôs listis a àn il stes numar di caratars, torne la prime liste.numar totâl di caratars in dutis lis stradis de liste mancul di chê de altre liste. Scrivi une funzion che e acete dôs listis di stringhis e e torne la liste che e à # >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
total_match <- function(lst1, lst2) {","total_match <- function(lst1, lst2) {
  chars_count <- function(lst) {
    sum(nchar(lst))
  }
  
  count1 <- chars_count(lst1)
  count2 <- chars_count(lst2)
  
  if (count1 < count2) {
    return(lst1)
  } else if (count1 > count2) {
    return(lst2)
  } else {
    return(lst1)
  }
}","test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()"
HumanEval_75,fur_Latn,r,"Esempli: Se si sa che (a) al è mancul di 100.e fals in ogni altri câs.Scrivi une funzion che e torni vere se il numar dât al è la moltiplicazion di 3 numars prins # >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
is_multiply_prime <- function(a) {","is_multiply_prime <- function(a) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n <= 3) return(TRUE)
    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)
    i <- 5
    while (i * i <= n) {
      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)
      i <- i + 6
    }
    return(TRUE)
  }

  if (a >= 100) return(FALSE)
  
  primes <- c()
  for (i in 2:a) {
    if (is_prime(i)) {
      primes <- c(primes, i)
    }
  }
  
  for (i in 1:length(primes)) {
    for (j in i:length(primes)) {
      for (k in j:length(primes)) {
        if (primes[i] * primes[j] * primes[k] == a) {
          return(TRUE)
        }
      }
    }
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()"
HumanEval_76,fur_Latn,r,"Par esempli: x al è une potence di n se n**int=x potence di n e false in altris câs. Il to compit al è di scrivi une funzion che e torni vere se un numar x al è un sempliç # >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE
is_simple_power <- function(x, n) {","is_simple_power <- function(x, n) {
  if (x == 1) return(TRUE)
  power <- 1
  while (power < x) {
    power <- power * n
    if (power == x) return(TRUE)
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()"
HumanEval_77,fur_Latn,r,"Esemplis: Note: tu puedis pensâ che il input al sedi simpri valid.Se chest ingjer al è un cubic di un ciert numar intîr.Scrivi une funzion che e cjape un intîr a e e torne VÊR # >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE
iscube <- function(a) {","iscube <- function(a) {
  if (a == 0) return(TRUE)
  root <- round(abs(a)^(1/3))
  return(root^3 == abs(a))
}","test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()"
HumanEval_78,fur_Latn,r,"Esemplis: e i simbui A,B,C,D,E,F a son simpri maiuscui.Note: tu puedis pensâ che il input al sedi simpri coret o che al sedi une stringhe vueide, B (= decimâl 11), D (= decimâl 13). Duncje tu âs di determinâ un numar di chestis cifris: 2, 3, 5, 7, I numars prins a son 2, 3, 5, 7, 11, 13, 17,...Lis cifris esadecimâls a son 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. plui grant di 1 che nol è un prodot di doi numars naturâi plui piçui).Lis cifris che a son prins (un numar prin, o un prin, al è un numar naturâl)un numar esadecimâl come stringhe e conte il numar di esadecimâi Ti è stât domandât di scrivi une funzion che ricevi # >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2
hex_key <- function(num) {","hex_key <- function(num) {
  # Define the set of prime hexadecimal digits
  prime_hex_digits <- c('2', '3', '5', '7', 'B', 'D')
  
  # Initialize a counter
  count <- 0
  
  # Convert the input string to a list of characters
  chars <- strsplit(num, NULL)[[1]]
  
  # Loop over each character in the list
  for (char in chars) {
    # Check if the character is in the list of prime hexadecimal digits
    if (char %in% prime_hex_digits) {
      # Increment the count
      count <- count + 1
    }
  }
  
  # Return the count
  return(count)
}","test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()"
HumanEval_79,fur_Latn,r,"Esemplis: I caratars in plui a son par judâ il formât. A saran un pâr di caratars in plui ""db"" tal inizi e ae fin de stringhe. Ogni caratari de stringhe al sarà ""0"" o ""1"".il formât binari. La funzion e varès di tornâ une stringhe, cun ogni caratâr che al rapresente un binari Ti ven dât un numar in forme decimâl e il to compit al è di convertîlu in # >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'
decimal_to_binary <- function(decimal) {","decimal_to_binary <- function(decimal) {
  binary_string <- as.character(intToBits(decimal))
  binary_clean <- paste0(rev(binary_string), collapse = """")
  binary_trimmed <- sub(""^0+"", """", binary_clean)
  return(paste0(""db"", binary_trimmed, ""db""))
}","test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()"
HumanEval_80,fur_Latn,r,"Par esempli: Une stringhe e je hapr se la sô lungjece e je almancul 3 e ogni 3 letaris consecutivis a son distintis Il to compit al è di controlâ se la stringhe e je vere o no.Ti ven dade une stringhe di peraulis.# >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE
is_happy <- function(s) {","is_happy <- function(s) {
  n <- nchar(s)
  if (n < 3) {
    return(FALSE)
  }
  for (i in 1:(n - 2)) {
    if (length(unique(substring(s, i, i + 2))) != 3) {
      return(FALSE)
    }
  }
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()"
HumanEval_81,fur_Latn,r,"Esempli: 0,0 E > 0,0 D- > 0,7 D > 1,0 D+ > 1,3 C- > 1,7 C > 2,0 C+ > 2.3 B- > 2,7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ GPA. Note di letare.une funzion che e pues produsi une liste di grâts di letare doprant la tabele chi sot: Ti à dât une liste des notis di cualchi student e tu âs di scrivi .L'unic probleme al è che e à pierdût il codiç che e doprave par dâ lis notis.La maestre e à creât il so algoritmi par dâ lis notis.E je la ultime setemane dal semestri e il professôr al à di dâ i notis.# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')
numerical_letter_grade <- function(grades) {","numerical_letter_grade <- function(grades) {
  letter_grades <- sapply(grades, function(gpa) {
    if (gpa == 4.0) {
      ""A+""
    } else if (gpa > 3.7) {
      ""A""
    } else if (gpa > 3.3) {
      ""A-""
    } else if (gpa > 3.0) {
      ""B+""
    } else if (gpa > 2.7) {
      ""B""
    } else if (gpa > 2.3) {
      ""B-""
    } else if (gpa > 2.0) {
      ""C+""
    } else if (gpa > 1.7) {
      ""C""
    } else if (gpa > 1.3) {
      ""C-""
    } else if (gpa > 1.0) {
      ""D+""
    } else if (gpa > 0.7) {
      ""D""
    } else if (gpa > 0.0) {
      ""D-""
    } else {
      ""E""
    }
  })
  return(letter_grades)
}","test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()"
HumanEval_82,fur_Latn,r,"Esemplis length al è un numar prin o FALS altrimentri Scrivi une funzion che e cjape une stringhe e e torne VÊR se la stringhe # >>> prime_length('Hello')
# TRUE
# >>> prime_length('abcdcba')
# TRUE
# >>> prime_length('kittens')
# TRUE
# >>> prime_length('orange')
# FALSE
prime_length <- function(string) {","prime_length <- function(string) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n <= 3) return(TRUE)
    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)
    
    i <- 5
    while (i * i <= n) {
      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)
      i <- i + 6
    }
    
    return(TRUE)
  }
  
  string_length <- nchar(string)
  return(is_prime(string_length))
}","test_humaneval <- function() {
    candidate <- prime_length
    stopifnot(isTRUE(all.equal(candidate('Hello'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcdcba'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('kittens'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('orange'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('wow'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('world'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('MadaM'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Wow'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('HI'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('go'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('gogo'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aaaaaaaaaaaaaaa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Madam'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('M'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('0'), FALSE)))
}
test_humaneval()"
HumanEval_83,fur_Latn,r,"I intîrs positifs che a scomencin o a finissin cun 1. Dât un intîr positîf n, torne il numar dai numars di n-cifre starts_one_ends <- function(n) {","starts_one_ends <- function(n) {
  if (n == 1) {
    return(1)
  } else {
    return(9 * (10^(n-2)) * 2)
  }
}","test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()"
HumanEval_84,fur_Latn,r,"Esempli Dât un intîr positîf N, torne la sume totâl des sôs cifras in binari. # >>> solve(1000)
# '1'
# >>> solve(150)
# '110'
# >>> solve(147)
# '1100'
# Variables:
#     @N integer
#          Constraints: 0 ≤ N ≤ 10000.
# Output:
#      a string of binary number
solve <- function(N) {","solve <- function(N) {
  # Sum the digits of the number
  digit_sum <- sum(as.numeric(unlist(strsplit(as.character(N), """"))))
  # Convert the sum to binary and return as a string
  return(as.character(as.binary(digit_sum)))
}

# Helper function to convert number to binary
as.binary <- function(number) {
  if (number == 0) return(""0"")
  binary <- """"
  while (number > 0) {
    binary <- paste0(number %% 2, binary)
    number <- number %/% 2
  }
  return(binary)
}","test_humaneval <- function() {
    candidate <- solve
    stopifnot(isTRUE(all.equal(candidate(1000), '1')))
    stopifnot(isTRUE(all.equal(candidate(150), '110')))
    stopifnot(isTRUE(all.equal(candidate(147), '1100')))
    stopifnot(isTRUE(all.equal(candidate(333), '1001')))
    stopifnot(isTRUE(all.equal(candidate(963), '10010')))
}
test_humaneval()"
HumanEval_85,fur_Latn,r,"Esemplis: Dât une liste di intîrs no vueide, prin zontâ i elements pari che a son a indicis dispariis.# >>> add(c(4, 2, 6, 7))
# 2
add <- function(lst) {","add <- function(lst) {
  # Select elements at odd indices (which are even positions)
  elements_at_odd_indices <- lst[seq(2, length(lst), by=2)]
  # Keep only the even elements
  even_elements <- elements_at_odd_indices[elements_at_odd_indices %% 2 == 0]
  # Sum the even elements
  sum(even_elements)
}","test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()"
HumanEval_86,fur_Latn,r,"Par esempli: Note: Tu âs di mantignî l'ordin des peraulis e i spazis vuadagnâts inte frase. ordini ascendent basât sul valôr ascii. son rimplaçadis di une peraule gnove dulà che ducj i caratars disposûts in La version ordenade de stringhe, e je une stringhe dulà che dutis lis peraulis (separadis di spazi) Scrivi une funzion che e cjape une stringhe e e torne une version ordenade di chê.# >>> anti_shuffle('Hi')
# 'Hi'
# >>> anti_shuffle('hello')
# 'ehllo'
# >>> anti_shuffle('Hello World!!!')
# 'Hello !!!Wdlor'
anti_shuffle <- function(s) {","anti_shuffle <- function(s) {
  words <- strsplit(s, ""(\\s+)"", perl = TRUE)[[1]]
  sorted_words <- sapply(words, function(word) {
    if (word == """") return(word)
    chars <- unlist(strsplit(word, split = """"))
    return(paste0(sort(chars), collapse = """"))
  })
  return(paste0(sorted_words, collapse = """"))
}","test_humaneval <- function() {
    candidate <- anti_shuffle
    stopifnot(isTRUE(all.equal(candidate('Hi'), 'Hi')))
    stopifnot(isTRUE(all.equal(candidate('hello'), 'ehllo')))
    stopifnot(isTRUE(all.equal(candidate('number'), 'bemnru')))
    stopifnot(isTRUE(all.equal(candidate('abcd'), 'abcd')))
    stopifnot(isTRUE(all.equal(candidate('Hello World!!!'), 'Hello !!!Wdlor')))
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')))
}
test_humaneval()"
HumanEval_87,fur_Latn,r,"Esemplis: Cun di plui, si classifichin lis coordinadis de rie daûr des colonis in ordin decrescent.Ordene lis coordinadis in ordin alçât.ogni liste e je une coordenade - (rie, colone), che e tache cun 0. e al torne la liste des listis, [(x1, y1), (x2, y2) ...] cussì che Dât lst, e intîr x, cîr intîrs x te liste, ogni rie e pues contignî un numar di colonis diferent. che al è simil a matrice, dut câs, a diference des matriçs, Ti dan un dât bidimensionâl, come lis listis imbastîdis, # >>> get_row(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1)
# list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0))
# >>> get_row(c(), 1)
# c()
# >>> get_row(list(c(), c(1), c(1, 2, 3)), 3)
# list(c(2, 2))
get_row <- function(lst, x) {","get_row <- function(lst, x) {
  result <- list()
  for (i in seq_along(lst)) {
    row <- lst[[i]]
    cols <- which(row == x)
    for (col in rev(sort(cols - 1))) {
      result <- append(result, list(c(i - 1, col)))
    }
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- get_row
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0)))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6)), 2), list(c(0, 1), c(1, 1), c(2, 1), c(3, 1), c(4, 1), c(5, 1)))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 1, 3, 4, 5, 6), c(1, 2, 1, 4, 5, 6), c(1, 2, 3, 1, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 0), c(2, 1), c(2, 0), c(3, 2), c(3, 0), c(4, 3), c(4, 0), c(5, 4), c(5, 0), c(6, 5), c(6, 0)))))
    stopifnot(isTRUE(all.equal(candidate(c(), 1), c())))
    stopifnot(isTRUE(all.equal(candidate(list(c(1)), 2), c())))
    stopifnot(isTRUE(all.equal(candidate(list(c(), c(1), c(1, 2, 3)), 3), list(c(2, 2)))))
}
test_humaneval()"
HumanEval_88,fur_Latn,r,"Esemplis: * no cambiâ il vetôr dât. Note: o ordenâle in ordin decrescint se la sume (il prin valôr dal indiç, l'ultin valôr dal indiç) e je pari. Tu ordenarâs il dât vetôr in ordin alçât se la sume (il prin valôr indiç, l'ultin valôr indiç) e je dispari, Dât un vetôr di intîrs no negatîfs, torne un cor dal vetôr dât dopo la classificazion, # >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)
sort_array <- function(array) {","sort_array <- function(array) {
  if (length(array) <= 1) {
    return(array)
  }
  
  first_value <- array[1]
  last_value <- array[length(array)]
  sum_values <- first_value + last_value
  
  if (sum_values %% 2 == 1) {
    return(sort(array))
  } else {
    return(sort(array, decreasing = TRUE))
  }
}","test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()"
HumanEval_89,fur_Latn,r,"Par esempli: cambiâ par doi moltiplicât par doi puescj.L' alfabet al à di jessi gjavad in mût che lis letaris al torne une stringhe cifrade cul alfabet che al ven gjavât. Cree une funzion di cript che e cjape une stringhe come argoment e # >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'
encrypt <- function(s) {","encrypt <- function(s) {
  alphabet <- letters
  shift <- 2 * 2
  encrypted <- sapply(strsplit(s, NULL)[[1]], function(char) {
    if (char %in% alphabet) {
      new_index <- (match(char, alphabet) + shift - 1) %% 26 + 1
      alphabet[new_index]
    } else {
      char
    }
  })
  paste(encrypted, collapse = """")
}","test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()"
HumanEval_90,fur_Latn,r,"Al torne NULL se nol è nissun element. Scrivi une funzion next_smallest ({}) che e torne il secont element plui piçul de liste. Ti ven dade une liste di intîrs.# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL
next_smallest <- function(lst) {","next_smallest <- function(lst) {
  # Sort the list and remove duplicates
  unique_sorted_lst <- sort(unique(lst))
  
  # Check if list contains at least two distinct elements
  if (length(unique_sorted_lst) < 2) {
    return(NULL)
  }
  
  # Return the second smallest element
  return(unique_sorted_lst[2])
}","test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()"
HumanEval_91,fur_Latn,r,"Par esempli: Lis sentencis a son delimitât di """", ""?"" o ""!"" Une noie e je une frase che e scomence cu la peraule ""I"".Ti ven dade une serie di peraulis, e il to compit al è di contâ il numar.# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1
is_bored <- function(S) {","is_bored <- function(S) {
  # Split the string into sentences using '.', '?', and '!' as delimiters
  sentences <- unlist(strsplit(S, split = ""[.?!]""))
  
  # Trim leading and trailing whitespace from each sentence
  sentences <- trimws(sentences)
  
  # Count the number of sentences that start with ""I""
  boredom_count <- sum(startsWith(sentences, ""I""))
  
  return(boredom_count)
}","test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()"
HumanEval_92,fur_Latn,r,"Esemplis Al torne falç in ducj i altris câs.Al torne vêr se un dai numars al è avuâl a la sume dai altris doi, e ducj i numars a son intîrs.Creâ une funzion che e cjape 3 numars.# >>> any_int(5, 2, 7)
# TRUE
# >>> any_int(3, 2, 2)
# FALSE
# >>> any_int(3, -2, 1)
# TRUE
# >>> any_int(3.6, -2.2, 2)
# FALSE
any_int <- function(x, y, z) {","any_int <- function(x, y, z) {
  if (is.integer(x) && is.integer(y) && is.integer(z)) {
    return(x == y + z || y == x + z || z == x + y)
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- any_int
    stopifnot(isTRUE(all.equal(candidate(2, 3, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2.5, 2, 3), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1.5, 5, 3.5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2.2, 2.2, 2.2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-4, 6, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2, 1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(3, 4, 7), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(3.0, 4, 7), FALSE)))
}
test_humaneval()"
HumanEval_93,fur_Latn,r,"Esemplis: Si presume dome lis letaris.vocâl tal alfabet inglês.Il messaç cun la letare che e je doi puescj prime di chê In chest mût al cambie la maiusculis di dutis lis letaris, al rimplace dutis lis vocâls in Scrivi une funzion che cjape un messaç e al codifiche in chest mût# >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'
encode <- function(message) {","encode <- function(message) {
  # Function to swap case of letters
  swap_case <- function(char) {
    if (grepl(""[A-Za-z]"", char)) {
      if (char %in% LETTERS) {
        return(tolower(char))
      } else {
        return(toupper(char))
      }
    } else {
      return(char)
    }
  }
  
  # Vowel replacement rules
  vowel_replacement <- function(char) {
    vowels <- c(""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U"")
    replacements <- c(""c"", ""g"", ""k"", ""q"", ""w"", ""C"", ""G"", ""K"", ""Q"", ""W"")
    if (char %in% vowels) {
      index <- match(char, vowels)
      return(replacements[index])
    } else {
      return(char)
    }
  }
  
  # Splitting the message into its characters
  message_chars <- strsplit(message, """")[[1]]
  
  # Apply swap case and vowel replacement
  encoded_chars <- sapply(message_chars, function(x) vowel_replacement(swap_case(x)))
  
  # Combine the characters back into a single string
  return(paste(encoded_chars, collapse = """"))
}","test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()"
HumanEval_94,fur_Latn,r,"Esemplis: Tu âs di cjatâ il plui grant valôr prin e tornâ la sume des sôs cifras.Ti ven dade une liste di intîrs.# >>> skjkasdkd(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))
# 10
# >>> skjkasdkd(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))
# 25
# >>> skjkasdkd(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))
# 13
# >>> skjkasdkd(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))
# 11
# >>> skjkasdkd(c(0, 81, 12, 3, 1, 21))
# 3
# >>> skjkasdkd(c(0, 8, 1, 2, 1, 7))
# 7
skjkasdkd <- function(lst) {","skjkasdkd <- function(lst) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n == 2) return(TRUE)
    if (n %% 2 == 0) return(FALSE)
    for (i in 3:sqrt(n)) {
      if (n %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  prime_values <- lst[sapply(lst, is_prime)]
  if (length(prime_values) == 0) return(0)
  
  largest_prime <- max(prime_values)
  
  sum_of_digits <- function(n) {
    sum(as.numeric(unlist(strsplit(as.character(n), """"))))
  }
  
  return(sum_of_digits(largest_prime))
}","test_humaneval <- function() {
    candidate <- skjkasdkd
    stopifnot(isTRUE(all.equal(candidate(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)), 10)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)), 25)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)), 13)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)), 11)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 81, 12, 3, 1, 21)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 8, 1, 2, 1, 7)), 7)))
    stopifnot(isTRUE(all.equal(candidate(c(8191)), 19)))
    stopifnot(isTRUE(all.equal(candidate(c(8191, 123456, 127, 7)), 19)))
    stopifnot(isTRUE(all.equal(candidate(c(127, 97, 8192)), 10)))
}
test_humaneval()"
HumanEval_95,fur_Latn,r,"Esemplis: La funzion e varès di tornâ FALSE se la liste dai nons e je vueide. case o ducj i tascj a son stradis in maiusc, altrimentri al torne FALSE. Dât un non a liste, torne TRUE se dutis lis clâfs a son stringhis in lower # >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE
check_dict_case <- function(dict) {","check_dict_case <- function(dict) {
  if (length(dict) == 0) return(FALSE)
  
  keys <- names(dict)
  
  all_lower <- all(keys == tolower(keys))
  all_upper <- all(keys == toupper(keys))
  
  return(all_lower || all_upper)
}","test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()"
HumanEval_96,fur_Latn,r,"par esempli: I intîrs che a son numars prins e minôrs di n. Implente une funzion che e cjape un intîr no negatîf e e torne un vetôr dal prin n # >>> count_up_to(5)
# c(2, 3)
# >>> count_up_to(11)
# c(2, 3, 5, 7)
# >>> count_up_to(0)
# c()
# >>> count_up_to(20)
# c(2, 3, 5, 7, 11, 13, 17, 19)
# >>> count_up_to(1)
# c()
# >>> count_up_to(18)
# c(2, 3, 5, 7, 11, 13, 17)
count_up_to <- function(n) {","count_up_to <- function(n) {
  is_prime <- function(num) {
    if (num <= 1) return(FALSE)
    if (num == 2) return(TRUE)
    if (num %% 2 == 0) return(FALSE)
    for (i in 3:sqrt(num)) {
      if (num %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  primes_below_n <- c()
  for (i in 2:(n-1)) {
    if (is_prime(i)) {
      primes_below_n <- c(primes_below_n, i)
    }
  }
  
  return(primes_below_n)
}","test_humaneval <- function() {
    candidate <- count_up_to
    stopifnot(isTRUE(all.equal(candidate(5), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(6), c(2, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(7), c(2, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(10), c(2, 3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(0), c())))
    stopifnot(isTRUE(all.equal(candidate(22), c(2, 3, 5, 7, 11, 13, 17, 19))))
    stopifnot(isTRUE(all.equal(candidate(1), c())))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(47), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43))))
    stopifnot(isTRUE(all.equal(candidate(101), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))))
}
test_humaneval()"
HumanEval_97,fur_Latn,r,"Esemplis: Si presume che la jentrade e sedi simpri valide.il prodot des lôr cifras unitariis. Complete la funzion che e cjape doi intîrs e e torne # >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20
multiply <- function(a, b) {","multiply <- function(a, b) {
  unit_digit_a <- abs(a) %% 10
  unit_digit_b <- abs(b) %% 10
  return(unit_digit_a * unit_digit_b)
}","test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()"
HumanEval_98,fur_Latn,r,"Par esempli: Dât un string s, contâ il numar di vocâls maiusculis in indizis parons. # >>> count_upper('aBCdEf')
# 1
# >>> count_upper('abcdefg')
# 0
# >>> count_upper('dBBE')
# 0
count_upper <- function(s) {","count_upper <- function(s) {
  # Define uppercase vowels
  uppercase_vowels <- c('A', 'E', 'I', 'O', 'U')
  
  # Initialize counter
  count <- 0
  
  # Iterate over string indices
  for (i in seq(1, nchar(s), by=2)) {
    # Check if character at even index is an uppercase vowel
    if (substr(s, i, i) %in% uppercase_vowels) {
      count <- count + 1
    }
  }
  
  return(count)
}","test_humaneval <- function() {
    candidate <- count_upper
    stopifnot(isTRUE(all.equal(candidate('aBCdEf'), 1)))
    stopifnot(isTRUE(all.equal(candidate('abcdefg'), 0)))
    stopifnot(isTRUE(all.equal(candidate('dBBE'), 0)))
    stopifnot(isTRUE(all.equal(candidate('B'), 0)))
    stopifnot(isTRUE(all.equal(candidate('U'), 1)))
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('EEEE'), 2)))
}
test_humaneval()"
HumanEval_99,fur_Latn,r,"Esemplis di doi intîrs, arrotondâlu di zero.E torne il intîr plui dongje di jê.Creâ une funzion che e cjape un valôr (string) che al rapresente un numar # >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
closest_integer <- function(value) {","closest_integer <- function(value) {
  num <- as.numeric(value)
  if (num %% 1 == 0.5 || num %% 1 == -0.5) {
    return(ifelse(num > 0, ceiling(num), floor(num)))
  } else {
    return(round(num))
  }
}","test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()"
HumanEval_100,fur_Latn,r,"Esemplis: i al rapresente il numar di pieris tal nivel (i+1). Al torne il numar di pieris in ogni nivel intune liste, dulà che l'element al è l'indic - il prossim numar pari se n al è pari. - il numar dispari dopo se n al è dispari. Il numar di pieris tal nivel dopo al è: Il prin nivel al à n pieris.Dât un intîr positîf n, tu âs di fâ une pile di n nivei di pieris.# >>> make_a_pile(3)
# c(3, 5, 7)
make_a_pile <- function(n) {","make_a_pile <- function(n) {
  stones <- numeric(n)
  stones[1] <- n
  for (i in 2:n) {
    if (n %% 2 == 0) {
      stones[i] <- stones[i - 1] + 2
    } else {
      stones[i] <- stones[i - 1] + 2
    }
  }
  return(stones)
}","test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()"
HumanEval_101,fur_Latn,r,"Par esempli: par dividî la stringhe in peraulis e tornâ un vetôr des peraulis.Ti ven dade une stringhe di peraulis separadis di virgule o spazis.# >>> words_string('Hi, my name is John')
# c('Hi', 'my', 'name', 'is', 'John')
# >>> words_string('One, two, three, four, five, six')
# c('One', 'two', 'three', 'four', 'five', 'six')
words_string <- function(s) {","words_string <- function(s) {
  s <- gsub("","", "" "", s)
  words <- unlist(strsplit(s, ""\\s+""))
  words <- words[words != """"]
  return(words)
}","test_humaneval <- function() {
    candidate <- words_string
    stopifnot(isTRUE(all.equal(candidate('Hi, my name is John'), c('Hi', 'my', 'name', 'is', 'John'))))
    stopifnot(isTRUE(all.equal(candidate('One, two, three, four, five, six'), c('One', 'two', 'three', 'four', 'five', 'six'))))
    stopifnot(isTRUE(all.equal(candidate('Hi, my name'), c('Hi', 'my', 'name'))))
    stopifnot(isTRUE(all.equal(candidate('One,, two, three, four, five, six,'), c('One', 'two', 'three', 'four', 'five', 'six'))))
    stopifnot(isTRUE(all.equal(candidate(''), c())))
    stopifnot(isTRUE(all.equal(candidate('ahmed     , gamal'), c('ahmed', 'gamal'))))
}
test_humaneval()"
HumanEval_102,fur_Latn,r,"Par esempli: Se nol è un numar cussì, la funzion e varès di tornâ -1.Il plui grant intîr pari che al è tal interval [x, y] includût.Cheste funzion e cjape doi numars positîfs x e y e e torne il # >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
choose_num <- function(x, y) {","choose_num <- function(x, y) {
  if (x > y) {
    return(-1)
  }
  
  for (num in seq(y, x, by = -1)) {
    if (num %% 2 == 0) {
      return(num)
    }
  }
  
  return(-1)
}","test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()"
HumanEval_103,fur_Latn,r,"Esempli: Se n al è plui grant di m, torne -1. Circondi la rispueste al numar intîr plui dongje e converti chest in binari.medie dai intîrs di n a m (includût n e m).Ti son dâts doi intîrs positifs n e m, e il to compit al è di calcolâ il # >>> rounded_avg(1, 5)
# '0b11'
# >>> rounded_avg(7, 5)
# -1
# >>> rounded_avg(10, 20)
# '0b1111'
# >>> rounded_avg(20, 33)
# '0b11010'
rounded_avg <- function(n, m) {","rounded_avg <- function(n, m) {
  if (n > m) {
    return(-1)
  }
  avg <- mean(n:m)
  rounded_avg <- round(avg)
  binary_avg <- as.character(as.binary(rounded_avg))
  return(paste0(""0b"", binary_avg))
}

as.binary <- function(num) {
  if (num == 0) {
    return(""0"")
  }
  binary <- """"
  while (num > 0) {
    binary <- paste0(num %% 2, binary)
    num <- num %/% 2
  }
  return(binary)
}","test_humaneval <- function() {
    candidate <- rounded_avg
    stopifnot(isTRUE(all.equal(candidate(1, 5), '0b11')))
    stopifnot(isTRUE(all.equal(candidate(7, 13), '0b1010')))
    stopifnot(isTRUE(all.equal(candidate(964, 977), '0b1111001010')))
    stopifnot(isTRUE(all.equal(candidate(996, 997), '0b1111100100')))
    stopifnot(isTRUE(all.equal(candidate(560, 851), '0b1011000010')))
    stopifnot(isTRUE(all.equal(candidate(185, 546), '0b101101110')))
    stopifnot(isTRUE(all.equal(candidate(362, 496), '0b110101101')))
    stopifnot(isTRUE(all.equal(candidate(350, 902), '0b1001110010')))
    stopifnot(isTRUE(all.equal(candidate(197, 233), '0b11010111')))
    stopifnot(isTRUE(all.equal(candidate(7, 5), -1)))
    stopifnot(isTRUE(all.equal(candidate(5, 1), -1)))
    stopifnot(isTRUE(all.equal(candidate(5, 5), '0b101')))
}
test_humaneval()"
HumanEval_104,fur_Latn,r,"Par esempli: Note: La liste tornade e varès di jessi ordenade in ordin crescint.elements che no àn nissun numar pari.Dât une liste di intîrs positifs x. torne une liste ordenade di ducj # >>> unique_digits(c(15, 33, 1422, 1))
# c(1, 15, 33)
# >>> unique_digits(c(152, 323, 1422, 10))
# c()
unique_digits <- function(x) {","unique_digits <- function(x) {
  has_no_even_digit <- function(num) {
    digits <- as.numeric(strsplit(as.character(num), """")[[1]])
    return(all(digits %% 2 != 0))
  }
  
  result <- Filter(has_no_even_digit, x)
  return(sort(result))
}","test_humaneval <- function() {
    candidate <- unique_digits
    stopifnot(isTRUE(all.equal(candidate(c(15, 33, 1422, 1)), c(1, 15, 33))))
    stopifnot(isTRUE(all.equal(candidate(c(152, 323, 1422, 10)), c())))
    stopifnot(isTRUE(all.equal(candidate(c(12345, 2033, 111, 151)), c(111, 151))))
    stopifnot(isTRUE(all.equal(candidate(c(135, 103, 31)), c(31, 135))))
}
test_humaneval()"
HumanEval_105,fur_Latn,r,"Par esempli: ""Un"", ""Doi"", ""Trê"", ""Cuatri"", ""Cincj"", ""Sîs"", ""Sîs"", ""Vot"" ""Nûf"". invertî il vetôr risultant, e daspò rimplaçâ ogni cifre cul so non corispondent di Dât un vetôr di intîrs, met in ordin i intîrs tra 1 e 9 includûts, # >>> by_length(c(2, 1, 1, 4, 5, 8, 2, 3))
# c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One')
#   If the vector is empty, return an empty vector:
# >>> by_length(c())
# c()
#   If the vector has any strange number ignore it:
# >>> by_length(c(1, -1, 55))
# c('One')
by_length <- function(arr) {","by_length <- function(arr) {
  # Filter numbers between 1 and 9
  valid_nums <- arr[arr >= 1 & arr <= 9]
  # Sort the numbers
  sorted_nums <- sort(valid_nums, decreasing = TRUE)
  # Map numbers to their names
  num_to_name <- c(""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"")
  result <- num_to_name[sorted_nums]
  return(result)
}","test_humaneval <- function() {
    candidate <- by_length
    stopifnot(isTRUE(all.equal(candidate(c(2, 1, 1, 4, 5, 8, 2, 3)), c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 55)), c('One'))))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 3, 2)), c('Three', 'Two', 'One'))))
    stopifnot(isTRUE(all.equal(candidate(c(9, 4, 8)), c('Nine', 'Eight', 'Four'))))
}
test_humaneval()"
HumanEval_106,fur_Latn,r,"Esempli: Il fatoriâl di i al è la moltiplicazion dai numars di 1 a i (1 * 2 * ... * i).i al scomençe di 1. o la sume dai numars dal 1 al i altrimentri. e al torne une liste di dimension n, cussì che il valôr dal element a l'indiç i al è il fatoriâl di i se i al è pari Implementâ la funzion f che e cjape n come parametri, # >>> f(5)
# c(1, 2, 6, 24, 15)
f <- function(n) {","f <- function(n) {
  result <- numeric(n)  # Initialize a numeric vector of length n
  for (i in 1:n) {
    if (i %% 2 == 0) {  # Check if i is even
      result[i] <- factorial(i)
    } else {
      result[i] <- sum(1:i)
    }
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()"
HumanEval_107,fur_Latn,r,"Esempli 1: palindroms intîrs che a son dentri dal interval ((1, n), includût. Dât un intîr positîf n, torne une liste che e à il numar di imparis e pari # >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.
even_odd_palindrome <- function(n) {","even_odd_palindrome <- function(n) {
  is_palindrome <- function(x) {
    str_x <- as.character(x)
    return(str_x == paste(rev(unlist(strsplit(str_x, """"))), collapse = """"))
  }
  
  even_count <- 0
  odd_count <- 0
  
  for (i in 1:n) {
    if (is_palindrome(i)) {
      if (i %% 2 == 0) {
        even_count <- even_count + 1
      } else {
        odd_count <- odd_count + 1
      }
    }
  }
  
  return(c(even_count, odd_count))
}","test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()"
HumanEval_108,fur_Latn,r,"Par esempli -123 al à lis cifris -1, 2 e 3.Se un numar al è negatîf, la sô prime cifre a sarà negative: il numar di elements che a àn une sume di cifras > 0. Scrivi une funzion count_nums che e cjape un vetôr di intîrs e e torne # >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
count_nums <- function(arr) {","count_nums <- function(arr) {
  # Helper function to calculate sum of digits
  sum_of_digits <- function(num) {
    digits <- as.numeric(unlist(strsplit(as.character(num), """")))
    return(sum(digits, na.rm = TRUE))
  }
  
  # Apply the sum_of_digits function and count numbers with sum > 0
  return(sum(sapply(arr, sum_of_digits) > 0))
}","test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()"
HumanEval_109,fur_Latn,r,"Par esempli: Note: La liste e je garantide par vê elements unics.Se il vetôr dât al è vueit, alore al torne VÊR. alore al torne VÊR altrimenti al torne FALS. Se al è pussibil otignî il vetôr ordenât fasint la operazion di parsore la posizion di partence tal vetôr, ven a stâi l'indiç 0.La ultime part dal vetôr e sarà spostade a Une operazion di spostament a diestre e vûl dî spostâ ducj i elements dal vetôr di un.Tu puedis fâ l'operazion di spostament a diestre un numar di voltis che tu vuelis.la seguinte operazion sul dât vetôr: al è pussibil ordenâ un vetôr in ordin no decrescint fasint I numars tal vetôr a saran ordenâts in mût casuâl.Si à un vetôr 'arr' di N intîrs arr[1], arr[2], ..., arr[N].# >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.
move_one_ball <- function(arr) {","move_one_ball <- function(arr) {
  if (length(arr) == 0) {
    return(TRUE)
  }
  
  n <- length(arr)
  for (i in 1:n) {
    shifted_arr <- c(tail(arr, n - i), head(arr, i))
    if (all(diff(shifted_arr) >= 0)) {
      return(TRUE)
    }
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()"
HumanEval_110,fur_Latn,r,"Par esempli: In câs contrari, torne ""NO"". Par che ducj i elements di lst1 a sedin par, torne ""SÌ"".Se al è pussibil scambiâ elements tra lst1 e lst2 par fâ No son limits al numar di elements scambiâts tra lst1 e lst2. A son dome i numars pari.e al determine se al è pussibil fâ un scambi di elements In chest probleme, tu implementarâs une funzion che e cjape dôs listis di numars, # >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.
exchange <- function(lst1, lst2) {","exchange <- function(lst1, lst2) {
  # Identify even and odd numbers in lst1
  lst1_even <- lst1[lst1 %% 2 == 0]
  lst1_odd <- lst1[lst1 %% 2 != 0]
  
  # Identify even numbers in lst2
  lst2_even <- lst2[lst2 %% 2 == 0]
  
  # Check if the number of odd elements in lst1 can be replaced with even elements from lst2
  if (length(lst1_odd) <= length(lst2_even)) {
    return(""YES"")
  } else {
    return(""NO"")
  }
}","test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()"
HumanEval_111,fur_Latn,r,"Esempli: Se plui letaris a àn la stesse ocasion, torne a scrivi dutis.di une letare che e je plui ripetude e che e conten il numar corispondent. Dade une stringhe che e rapresente une letare minuscule separade di spazi, torne une liste nomeade # >>> histogram('a b c')
# list('a' = 1, 'b' = 1, 'c' = 1)
# >>> histogram('a b b a')
# list('a' = 2, 'b' = 2)
# >>> histogram('a b c a b')
# list('a' = 2, 'b' = 2)
# >>> histogram('b b b b a')
# list('b' = 4)
# >>> histogram('')
# list()
histogram <- function(test) {","histogram <- function(test) {
  # Split the string into individual letters.
  letters <- unlist(strsplit(test, "" ""))
  
  # Create a table to count the occurrences of each letter.
  count_table <- table(letters)
  
  # Find the maximum frequency of occurrences.
  max_count <- max(count_table, na.rm = TRUE)
  
  # Find all letters that have the maximum frequency.
  max_letters <- names(count_table[count_table == max_count])
  
  # Create a named list with letters as names and their max occurrences as values.
  result <- setNames(as.list(rep(max_count, length(max_letters))), max_letters)
  
  return(result)
}","test_humaneval <- function() {
    candidate <- histogram
    stopifnot(isTRUE(all.equal(candidate('a b b a'), list('a' = 2, 'b' = 2))))
    stopifnot(isTRUE(all.equal(candidate('a b c a b'), list('a' = 2, 'b' = 2))))
    stopifnot(isTRUE(all.equal(candidate('a b c d g'), list('a' = 1, 'b' = 1, 'c' = 1, 'd' = 1, 'g' = 1))))
    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))
    stopifnot(isTRUE(all.equal(candidate('b b b b a'), list('b' = 4))))
    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))
    stopifnot(isTRUE(all.equal(candidate(''), list())))
    stopifnot(isTRUE(all.equal(candidate('a'), list('a' = 1))))
}
test_humaneval()"
HumanEval_112,fur_Latn,r,"Esempli Tu varessis di tornâ une liste che e conten la stringhe di risultât e TRUE/FALSE par il control.Une stringhe e je clamade palindrome se e si lei come che si lei in prin e in dopo.daspò controlâ se la stringhe risultante e je palindrome. Us dan dôs stringhis s e c, o vin di eliminâ ducj i caratars di s che a son avuâi a un caratar di c Cjâf di vore # >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)
reverse_delete <- function(s, c) {","reverse_delete <- function(s, c) {
  # Remove characters in 'c' from 's'
  for (char in strsplit(c, '')[[1]]) {
    s <- gsub(char, """", s)
  }
  
  # Check if the resultant string is a palindrome
  is_palindrome <- s == paste(rev(strsplit(s, NULL)[[1]]), collapse = """")
  
  # Return the resultant string and the palindrome check result
  return(list(s, is_palindrome))
}","test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()"
HumanEval_113,fur_Latn,r,"di cifras dispariis inte stringhe i' de jentrade.stringhe i dal input. "" dulà che dutis lis i a varessin di jessi rimplaçadis dal numar Ogni element i dal output al varès di jessi il numar di elements dispariis tal Dât un elenc di stringhis, dulà che ogni stringhe e je fate dome di cifras, torne une liste. # >>> odd_count(c('1234567'))
# c('the number of odd elements 4n the str4ng 4 of the 4nput.')
# >>> odd_count(c('3', '11111111'))
# c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.')
odd_count <- function(lst) {","odd_count <- function(lst) {
  sapply(lst, function(x) {
    odd_digits <- sum(as.numeric(unlist(strsplit(x, """"))) %% 2 == 1)
    sprintf(""the number of odd elements %dn the str%2$sing %1$d of the %3$nput."", odd_digits, odd_digits, odd_digits)
  })
}

# Example usage
print(odd_count(c('1234567')))
print(odd_count(c('3', '11111111')))","test_humaneval <- function() {
    candidate <- odd_count
    stopifnot(isTRUE(all.equal(candidate(c('1234567')), c('the number of odd elements 4n the str4ng 4 of the 4nput.'))))
    stopifnot(isTRUE(all.equal(candidate(c('3', '11111111')), c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'))))
    stopifnot(isTRUE(all.equal(candidate(c('271', '137', '314')), c('the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'))))
}
test_humaneval()"
HumanEval_114,fur_Latn,r,"Esempli di numars. Dât un vetôr di intîrs numars, cjate la sume minime di ogni sot-vetôr no vueit # >>> minSubArraySum(c(2, 3, 4, 1, 2, 4))
# 1
# >>> minSubArraySum(c(-1, -2, -3))
# -6
minSubArraySum <- function(nums) {","minSubArraySum <- function(nums) {
  min_sum <- nums[1]
  current_sum <- 0
  
  for (num in nums) {
    if (current_sum > 0) {
      current_sum <- 0
    }
    current_sum <- current_sum + num
    if (current_sum < min_sum) {
      min_sum <- current_sum
    }
  }
  
  return(min_sum)
}","test_humaneval <- function() {
    candidate <- minSubArraySum
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 4, 1, 2, 4)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3)), -6)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 2, -10)), -14)))
    stopifnot(isTRUE(all.equal(candidate(c(-9999999999999999)), -9999999999999999)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 10, 20, 1000000)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 10, -5)), -6)))
    stopifnot(isTRUE(all.equal(candidate(c(100, -1, -2, -3, 10, -5)), -6)))
    stopifnot(isTRUE(all.equal(candidate(c(10, 11, 13, 8, 3, 4)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(100, -33, 32, -1, 0, -2)), -33)))
    stopifnot(isTRUE(all.equal(candidate(c(-10)), -10)))
    stopifnot(isTRUE(all.equal(candidate(c(7)), 7)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1)), -1)))
}
test_humaneval()"
HumanEval_115,fur_Latn,r,"Esempli 1: Meti il numar di voltis che tu âs di lâ jù i secui.Il to compit al è chel di doprâ i secs par svuedâ i puars.e ducj i secui a àn la stesse capacitât.Ogni poç al à un balcon corispondent che al pues jessi doprât par estrai l'aghe di chel, e ogni 1 intune rie al rapresente une singule unitât di aghe. Si à une griglie di poçs di forme rettangolâr, ogni rie e rapresente un singul poç.# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10
max_fill <- function(grid, capacity) {","max_fill <- function(grid, capacity) {
  total_water <- sum(unlist(grid))
  num_buckets_needed <- ceiling(total_water / capacity)
  return(num_buckets_needed)
}","test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()"
HumanEval_116,fur_Latn,r,"Al à di jessi metût in vore cussì: Par un numar simil di unis, ordenâ su la base dal valôr decimâl. numar di unis inte lôr rapresentazion binarie in ordin alçât. In chest kata, tu âs di ordenâ un vetôr di intîrs no negatîfs secont # >>> sort_array(c(1, 5, 2, 3, 4))
# c(1, 2, 3, 4, 5)
# >>> sort_array(c(-2, -3, -4, -5, -6))
# c(-6, -5, -4, -3, -2)
# >>> sort_array(c(1, 0, 2, 3, 4))
# c(0, 1, 2, 3, 4)
sort_array <- function(arr) {","sort_array <- function(arr) {
  # Filter out negative numbers and sort them directly
  negative_numbers <- sort(arr[arr < 0])
  
  # Process non-negative numbers
  non_negative_numbers <- arr[arr >= 0]
  
  # Sort non-negative numbers based on number of 1s in binary representation, then by decimal value
  sorted_non_negative_numbers <- non_negative_numbers[order(sapply(non_negative_numbers, function(x) {
    sum(as.integer(intToBits(x)))
  }), non_negative_numbers)]
  
  # Combine sorted negative and non-negative numbers
  c(negative_numbers, sorted_non_negative_numbers)
}","test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c(1, 5, 2, 3, 4)), c(1, 2, 4, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(-2, -3, -4, -5, -6)), c(-4, -2, -6, -5, -3))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 2, 3, 4)), c(0, 1, 2, 4, 3))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4)), c(2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 6, 44, 12, 32, 5)), c(32, 3, 5, 6, 12, 44))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))
}
test_humaneval()"
HumanEval_117,fur_Latn,r,"Esemplis: Note: tu puedis pensâ che la stringhe di input e conten dome letaris e spazis.Se la stringhe s e je vueide, la funzion e varès di tornâ une liste vueide. n consonantis, par ordin che chestis peraulis a vegnin dentri de stringhe s. une funzion che e torne une liste di dutis lis peraulis de stringhe s che a contegnin propit Dade une stringhe s e un numar naturâl n, tu âs di implementâ # >>> select_words('Mary had a little lamb', 4)
# c('little')
# >>> select_words('Mary had a little lamb', 3)
# c('Mary', 'lamb')
# >>> select_words('simple white space', 2)
# c()
# >>> select_words('Hello world', 4)
# c('world')
# >>> select_words('Uncle sam', 3)
# c('Uncle')
select_words <- function(s, n) {","select_words <- function(s, n) {
  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
  words <- strsplit(s, "" "")[[1]]
  result <- sapply(words, function(word) {
    consonants_count <- nchar(gsub(paste(vowels, collapse = ""|""), """", word))
    if (consonants_count == n) return(word)
    else return(NULL)
  })
  result <- result[!sapply(result, is.null)]
  unname(result)
}","test_humaneval <- function() {
    candidate <- select_words
    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 4), c('little'))))
    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 3), c('Mary', 'lamb'))))
    stopifnot(isTRUE(all.equal(candidate('simple white space', 2), c())))
    stopifnot(isTRUE(all.equal(candidate('Hello world', 4), c('world'))))
    stopifnot(isTRUE(all.equal(candidate('Uncle sam', 3), c('Uncle'))))
    stopifnot(isTRUE(all.equal(candidate('', 4), c())))
    stopifnot(isTRUE(all.equal(candidate('a b c d e f', 1), c('b', 'c', 'd', 'f'))))
}
test_humaneval()"
HumanEval_118,fur_Latn,r,"Esempli: Tu puedis pensâ che la stringhe dât e conten dome letaris inglês.cjatâ cualsisei vocâl che e sodisfe la condizion di cui che al è parsore.Lis vocâls tal inizi e tal fin no si contin.dôs consonants de bande di destra de peraule (sensibil a la casse). Ti ven dade une peraule. Il to compit al è di cjatâ la vocâl plui dongje che e je tra di lôr.# >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''
get_closest_vowel <- function(word) {","get_closest_vowel <- function(word) {
  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
  n <- nchar(word)
  
  # Iterate from the second to last position to the second position
  for (i in (n-1):2) {
    if (substr(word, i, i) %in% vowels) {
      if (!substr(word, i-1, i-1) %in% vowels && !substr(word, i+1, i+1) %in% vowels) {
        return(substr(word, i, i))
      }
    }
  }
  
  # Return empty string if no vowel is found
  return('')
}","test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()"
HumanEval_119,fur_Latn,r,"Esemplis: Tornâ ""Sì"" se al è un mût di fâ une stringhe buine, e tornâ ""No"" se no."" (()) "" nol è.A son par esempli: la stringhe '(((() ' e je buine, invezit la stringhe Une stringhe S e je considerade buine se e dome se dutis lis parentesis in S Cualchi ordin, che la stringhe risultante e sarà buine.Il to compit al è di controlâ se al è pussibil incatenâ lis dôs stringhis in dome lis parentis "" (("") o lis parentis plui dongje "") "". Ti ven dade une liste di dôs stringhis, dutis dôs lis stringhis a son di ""open""# >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'
match_parens <- function(lst) {","match_parens <- function(lst) {
  is_balanced <- function(s) {
    balance <- 0
    for (ch in strsplit(s, """")[[1]]) {
      if (ch == '(') {
        balance <- balance + 1
      } else {
        balance <- balance - 1
      }
      if (balance < 0) return(FALSE)
    }
    return(balance == 0)
  }
  
  s1 <- lst[1]
  s2 <- lst[2]
  
  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {
    return('Yes')
  } else {
    return('No')
  }
}","test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()"
HumanEval_120,fur_Latn,r,"Esempli 1: di lungjece k cun il massim di k numars in arr. Dât un vetôr arr di intîrs e un intîr positîf k, torne une liste ordenade # >>> maximum(c(-3, -4, 5), 3)
# c(-4, -3, 5)
# Example 2:
# >>> maximum(c(4, -4, 4), 2)
# c(4, 4)
# Example 3:
# >>> maximum(c(-3, 2, 1, 2, -1, -2, 1), 1)
# c(2)
# Note:
#     1. The length of the vector will be in the range of [1, 1000].
#     2. The elements in the vector will be in the range of [-1000, 1000].
#     3. 0 <= k <= len(arr)
maximum <- function(arr, k) {","maximum <- function(arr, k) {
  return(sort(tail(sort(arr), k)))
}","test_humaneval <- function() {
    candidate <- maximum
    stopifnot(isTRUE(all.equal(candidate(c(-3, -4, 5), 3), c(-4, -3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(4, -4, 4), 2), c(4, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 2, 1, 2, -1, -2, 1), 1), c(2))))
    stopifnot(isTRUE(all.equal(candidate(c(123, -123, 20, 0, 1, 2, -3), 3), c(2, 20, 123))))
    stopifnot(isTRUE(all.equal(candidate(c(-123, 20, 0, 1, 2, -3), 4), c(0, 1, 2, 20))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 15, 0, 3, -13, -8, 0), 7), c(-13, -8, 0, 0, 3, 5, 15))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 2, 5, 3, -10), 2), c(3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 5, -7), 1), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(4, -4), 2), c(-4, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(-10, 10), 2), c(-10, 10))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, -23, 243, -400, 0), 0), c())))
}
test_humaneval()"
HumanEval_121,fur_Latn,r,"Esemplis Dât un non vuadagn di intîrs, torne la sume di ducj i elements dispariis che a son in posizion pari.# >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0
solution <- function(lst) {","solution <- function(lst) {
  sum(lst[seq(2, length(lst), by = 2)][lst[seq(2, length(lst), by = 2)] %% 2 != 0])
}","test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()"
HumanEval_122,fur_Latn,r,"Esempli: la sume dai elements cun al massimo dôs cifris dai prins k elements di arr. Dât un vetôr no vueit di intîrs arr e un intîr k, torne # >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)
add_elements <- function(arr, k) {","add_elements <- function(arr, k) {
  sum(arr[1:k][nchar(abs(arr[1:k])) <= 2])
}","test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()"
HumanEval_123,fur_Latn,r,"get_odd_collatz(5) al torne [1, 5] # La secuence di collatz par 5 e je [5, 16, 8, 4, 2, 1], duncje i numars dispariis a son dome 1, e 5. Par esempli: 2. liste tornade ordenade in ordin di cressite. 1. Collatz(1) al è [1]. Note: La conieture e je che no impuarte ce valôr di n, la secuence e rivarà simpri a 1.Se il tiermin precedent al è dispari, il tiermin dopo al è 3 voltis il tiermin precedent.tiermin precedent cussì: se il tiermin precedent al è pari, il tiermin dopo al è la metât di Come che al ven: si scomenç cun un cualsisei intîr positîf n. Alore ogni tiermin al ven otignût dal La conieture di Collatz e je une conieture in matematiche che e rivuarde une secuence definide Dât un intîr positîf n, torne une liste ordenade che e à i numars dispariis te secuence di collatz. # >>> get_odd_collatz(5)
# c(1, 5)
get_odd_collatz <- function(n) {","get_odd_collatz <- function(n) {
  collatz_sequence <- function(n) {
    sequence <- c(n)
    while (n != 1) {
      if (n %% 2 == 0) {
        n <- n / 2
      } else {
        n <- 3 * n + 1
      }
      sequence <- c(sequence, n)
    }
    return(sequence)
  }
  
  sequence <- collatz_sequence(n)
  odd_numbers <- unique(sequence[sequence %% 2 != 0])
  return(sort(odd_numbers))
}","test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()"
HumanEval_124,fur_Latn,r,"4. La date e à di jessi tal formât: mm-dd-yyyy 3. I mês no dovaressin jessi mancul di 1 e plui di 12.2. Il numar di dîs nol è mancul di 1 o plui di 31 dîs pai mês 1,3,5,7,8,10,12 e il numar di dîs nol è mancul di 1 o plui di 30 dîs pai mês 4,6,9,11 e il numar di dîs nol è mancul di 1 o plui di 29 pai mês 2.1. La stringhe di date no je vueide.La date e je valide se a son sodisfatis dutis lis regulis seguitivis: al torne VÊR se la date e je valide, se no VÊR. Tu âs di scrivi une funzion che e valide une stringhe di datis e # >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE
valid_date <- function(date) {","valid_date <- function(date) {
  # Check if the date is not empty
  if (date == """") {
    return(FALSE)
  }
  
  # Check the format of the date
  if (!grepl(""^\\d{2}-\\d{2}-\\d{4}$"", date)) {
    return(FALSE)
  }
  
  # Extract the month, day, and year
  parts <- unlist(strsplit(date, ""-""))
  month <- as.numeric(parts[1])
  day <- as.numeric(parts[2])
  year <- as.numeric(parts[3])
  
  # Check if the month is valid
  if (month < 1 || month > 12) {
    return(FALSE)
  }
  
  # Check if the day is valid
  if (month %in% c(1, 3, 5, 7, 8, 10, 12) && (day < 1 || day > 31)) {
    return(FALSE)
  }
  
  if (month %in% c(4, 6, 9, 11) && (day < 1 || day > 30)) {
    return(FALSE)
  }
  
  if (month == 2 && (day < 1 || day > 29)) {
    return(FALSE)
  }
  
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()"
HumanEval_125,fur_Latn,r,"Esemplis alfabet, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 Se no esistin comatis, tu varessis di tornâ il numar di letaris minuscolis in ordin impar te Dât un string di peraulis, torne une liste di peraulis dividudis su spazis blancs, se no esistin spazis blancs intal test che tu stâs cirint # >>> split_words('Hello world!')
# c('Hello', 'world!')
# >>> split_words('Hello,world!')
# c('Hello', 'world!')
# >>> split_words('abcdef')
# 3
split_words <- function(txt) {","split_words <- function(txt) {
  if (grepl(""\\s"", txt)) {
    return(strsplit(txt, ""\\s+"")[[1]])
  } else if (grepl("","", txt)) {
    return(strsplit(txt, "","")[[1]])
  } else {
    odd_order_count <- sum(
      sapply(unlist(strsplit(txt, """")), function(x) {
        ord <- utf8ToInt(tolower(x)) - utf8ToInt(""a"")
        ord %% 2 == 1
      })
    )
    return(odd_order_count)
  }
}","test_humaneval <- function() {
    candidate <- split_words
    stopifnot(isTRUE(all.equal(candidate('Hello world!'), c('Hello', 'world!'))))
    stopifnot(isTRUE(all.equal(candidate('Hello,world!'), c('Hello', 'world!'))))
    stopifnot(isTRUE(all.equal(candidate('Hello world,!'), c('Hello', 'world,!'))))
    stopifnot(isTRUE(all.equal(candidate('Hello,Hello,world !'), c('Hello,Hello,world', '!'))))
    stopifnot(isTRUE(all.equal(candidate('abcdef'), 3)))
    stopifnot(isTRUE(all.equal(candidate('aaabb'), 2)))
    stopifnot(isTRUE(all.equal(candidate('aaaBb'), 1)))
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
}
test_humaneval()"
HumanEval_126,fur_Latn,r,"Esemplis numar, al torne FALSE. No si à di cjapâ numars negatîfs e dome intîrs.Se la liste e à plui di un duplicât dal stes Dât un elenc di numars, torne se a son ordenâts o no.# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE
is_sorted <- function(lst) {","is_sorted <- function(lst) {
  if (length(lst) <= 1) {
    return(TRUE)
  }
  
  # Check for duplicates more than once
  tbl <- table(lst)
  if (any(tbl > 2)) {
    return(FALSE)
  }
  
  # Check if the list is sorted in ascending order
  for (i in 2:length(lst)) {
    if (lst[i] < lst[i - 1]) {
      return(FALSE)
    }
  }
  
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()"
HumanEval_127,fur_Latn,r,"[input/output] campions: Se i doi intervals no si incrosin, torne ""NO"".in câs contrari, torne ""NO"". Se la lungjece de intersezion e je un numar prin, torne ""SÌ"", che la sô lungjece e je 1, che nol è un numar prin.Esempli, la intersezion dai intervals (1, 3), (2, 4) e je (2, 3) intervals al è un numar prin. Il to compit al è di determinâ se la lungjece de intersezion di chescj doi Par ogni interval dât, si presume che il so inizi al sedi mancul o avuâl a la sô fin.al inclût il principi e la fin. I intervals dâts a son sierâts, chest al vûl dî che l'interval (començ, fin) dulà che ogni interval al è une paia di intîrs. Par esempli, interval = (inizi, fin) = (1, 2).Ti son dâts doi intervals, # >>> intersection(c(1, 2), c(2, 3))
# 'NO'
# >>> intersection(c(-1, 1), c(0, 4))
# 'NO'
# >>> intersection(c(-3, -1), c(-5, 5))
# 'YES'
intersection <- function(interval1, interval2) {","intersection <- function(interval1, interval2) {
  start1 <- interval1[1]
  end1 <- interval1[2]
  start2 <- interval2[1]
  end2 <- interval2[2]
  
  # Determine the start and end of the intersection
  intersection_start <- max(start1, start2)
  intersection_end <- min(end1, end2)
  
  # Calculate the length of the intersection
  length_of_intersection <- intersection_end - intersection_start
  
  # If there's no intersection, return ""NO""
  if (length_of_intersection < 0) {
    return('NO')
  }
  
  # Check if the length is a prime number
  is_prime <- function(num) {
    if (num <= 1) {
      return(FALSE)
    }
    for (i in 2:sqrt(num)) {
      if (num %% i == 0) {
        return(FALSE)
      }
    }
    return(TRUE)
  }
  
  # Return ""YES"" if the length is prime, otherwise ""NO""
  if (is_prime(length_of_intersection)) {
    return('YES')
  } else {
    return('NO')
  }
}","test_humaneval <- function() {
    candidate <- intersection
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(2, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1), c(0, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(-3, -1), c(-5, 5)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(-2, 2), c(-4, 0)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(-11, 2), c(-1, -1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(3, 5)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(1, 2)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(-2, -2), c(-3, -2)), 'NO')))
}
test_humaneval()"
HumanEval_128,fur_Latn,r,"Esempli: Note: return NULL par un numar di arcs vueit. di ogni numar tal vetôr, rapresentât cun 1, -1 o 0. La sume des magnitudins dai intîrs moltiplicade par il prodot di ducj i segns Ti ven dât un vetôr di intîrs e tu âs di tornâ # >>> prod_signs(c(1, 2, 2, -4))
# 9
# >>> prod_signs(c(0, 1))
# 0
# >>> prod_signs(c())
# NULL
prod_signs <- function(arr) {","prod_signs <- function(arr) {
  if (length(arr) == 0) {
    return(NULL)
  }
  magnitude_sum <- sum(abs(arr))
  sign_product <- prod(sign(arr))
  return(magnitude_sum * sign_product)
}","test_humaneval <- function() {
    candidate <- prod_signs
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, -4)), -9)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 2, 3, -1, 1)), -10)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 2, -1, -1, 9)), 20)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, -1, 1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 1)), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 0)), 0)))
}
test_humaneval()"
HumanEval_129,fur_Latn,r,"Esemplis: Al torne une liste ordenade dai valôrs des celulis che il percors minim al passe. La rispueste e je sigure di jessi uniche. lst_A[j] = lst_B[j]. cussì che lst_A[i] < lst_B[i] e par ogni j (1 <= j < i) o vin di lst_B, in altris peraulis, al esist un indiç intîr i (1 <= i <= k) [e] (che si puedin clamâ ""lst_A"" e ""lst_B""), ""lst_A"" al è mancul lexicograficDopo vê fat lis listis ordenadis dai valôrs su lis celulis che A e B a van Un percors A (de lungjece k) al è considerât plui piçul di un percors B (de lungjece k) se No tu puedis lâ fûr dal sisteme.[e no dome, ma ancje e no dome]Si pree di notâ che un percors di lungjece k al vûl dî visitâ propit k celulis (no celulâr. In altris peraulis, tu puedis lâ a celulis che a condividin un confin cun te corint di ogni celule, e in ogni pas tu puedis passâ a cualsisei celule dongje, Tu âs di cjatâ il percors minim di lungjece k inte griglie.incl. al ven fûr une volte in ogni celle de griglie. ogni celule de griglie e conten un valôr. Ogni intîr tal interval [1, N * N] Dade une griglie cun N riis e N colonis (N >= 2) e un intîr positîf k, # >>> minPath(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3)
# c(1, 2, 1)
# >>> minPath(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1)
# c(1)
minPath <- function(grid, k) {","minPath <- function(grid, k) {
  N <- length(grid)
  directions <- list(c(0, 1), c(1, 0), c(0, -1), c(-1, 0))
  
  is_valid <- function(x, y) {
    return(x >= 1 && x <= N && y >= 1 && y <= N)
  }
  
  # DFS to find all paths
  dfs <- function(x, y, path) {
    if (length(path) == k) {
      paths <<- append(paths, list(path))
      return()
    }
    
    for (direction in directions) {
      nx <- x + direction[1]
      ny <- y + direction[2]
      if (is_valid(nx, ny)) {
        dfs(nx, ny, c(path, grid[[nx]][[ny]]))
      }
    }
  }
  
  paths <- list()
  
  # Start from every cell
  for (i in 1:N) {
    for (j in 1:N) {
      dfs(i, j, c(grid[[i]][[j]]))
    }
  }
  
  # Find and return the lexicographically smallest path
  min_path <- paths[[1]]
  for (path in paths) {
    if (path < min_path) {
      min_path <- path
    }
  }
  
  return(min_path)
}","test_humaneval <- function() {
    candidate <- minPath
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3), c(1, 2, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4), c(5, 6, 7, 8), c(9, 10, 11, 12), c(13, 14, 15, 16)), 4), c(1, 2, 1, 2))))
    stopifnot(isTRUE(all.equal(candidate(list(c(6, 4, 13, 10), c(5, 7, 12, 1), c(3, 16, 11, 15), c(8, 14, 9, 2)), 7), c(1, 10, 1, 10, 1, 10, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(8, 14, 9, 2), c(6, 4, 13, 15), c(5, 7, 1, 12), c(3, 10, 11, 16)), 5), c(1, 7, 1, 7, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(11, 8, 7, 2), c(5, 16, 14, 4), c(9, 3, 15, 6), c(12, 13, 10, 1)), 9), c(1, 6, 1, 6, 1, 6, 1, 6, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(12, 13, 10, 1), c(9, 3, 15, 6), c(5, 16, 14, 4), c(11, 8, 7, 2)), 12), c(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6))))
    stopifnot(isTRUE(all.equal(candidate(list(c(2, 7, 4), c(3, 1, 5), c(6, 8, 9)), 8), c(1, 3, 1, 3, 1, 3, 1, 3))))
    stopifnot(isTRUE(all.equal(candidate(list(c(6, 1, 5), c(3, 8, 9), c(2, 7, 4)), 8), c(1, 5, 1, 5, 1, 5, 1, 5))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2), c(3, 4)), 10), c(1, 2, 1, 2, 1, 2, 1, 2, 1, 2))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 3), c(3, 2)), 10), c(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))))
}
test_humaneval()"
HumanEval_130,fur_Latn,r,"Esemplis: I prins n + 1 numars de secuence di Tribonacci. Ti ven dât un numar intîr no negatîf n, tu âs di tornâ a une liste di = 2 + 3 + 3 = 8 tri(3) = tri(2) + tri(1) + tri(4) tri(4) = 3 tri(2) = 1 + (2 / 2) = 2 Par esempli: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), se n al è dispari. tri (n) = 1 + n / 2, se n al è pari. tri(1) = 3 La secuence di Tribonacci e je definide de ricorince: Dut câs, ce che la int no sa al è la secuence di Tribonacci.Ducj a cognossin la secuence di Fibonacci, e je stade studiade in profonditât dai matematics tal # >>> tri(3)
# c(1, 3, 2, 8)
tri <- function(n) {","tri <- function(n) {
  if (n == 0) return(c(3))
  
  tribonacci <- numeric(n + 1)
  tribonacci[1] <- 3
  
  for (i in 2:(n + 1)) {
    if (i %% 2 == 0) {
      tribonacci[i] <- 1 + i / 2
    } else {
      if (i == 3) {
        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1]  # tri(3) requires tri(4)
      } else {
        # When i > 3 and i is odd, dependencies are always available
        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3 + 2]  # i + 1 becomes i - 3 + 2
      }
    }
  }
  
  return(tribonacci)
}","test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()"
HumanEval_131,fur_Latn,r,"Par esempli: Al torne 0 se dutis lis cifris a son paris. Dât un intîr positîf n, torne il prodot des cifris dispariis. # >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15
digits <- function(n) {","digits <- function(n) {
  # Convert the number to a character vector
  digits_vector <- unlist(strsplit(as.character(n), """"))
  
  # Convert the character vector back to numeric
  digits_vector <- as.numeric(digits_vector)
  
  # Filter out the odd digits
  odd_digits <- digits_vector[digits_vector %% 2 != 0]
  
  # If all digits are even, return 0
  if (length(odd_digits) == 0) {
    return(0)
  }
  
  # Calculate and return the product of odd digits
  return(prod(odd_digits))
}","test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()"
HumanEval_132,fur_Latn,r,"dulà che almancul une corispondence inte subsequence e je imbastide. La funzion e varès di tornâ VÊR se e dome se e je une sotsecuence valide di parentesiis Creâ une funzion che e cjape come input une stringhe che e conten dome parentesis cuadradis. # >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE
is_nested <- function(string) {","is_nested <- function(string) {
  open_count <- 0
  for (char in unlist(strsplit(string, """"))) {
    if (char == ""["") {
      open_count <- open_count + 1
    } else if (char == ""]"") {
      if (open_count > 1) {
        return(TRUE)
      }
      open_count <- open_count - 1
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()"
HumanEval_133,fur_Latn,r,"Esemplis: circolâ ogni element de liste al int plui alt (talc) prin. Tu âs di tornâ la sume dal cuadrat dai numars inte liste dade, Ti ven dade une liste di numars.# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6
sum_squares <- function(lst) {","sum_squares <- function(lst) {
  sum(ceiling(lst)^2)
}","test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()"
HumanEval_134,fur_Latn,r,"Esemplis: Note: ""parol"" al è un grup di caratars separâts di spazi. une part di une peraule, e FALS se no.di une stringhe e je un caratâr alfabetic e no Cree une funzion che e torne VÊR se l' ultin caratar # >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE
check_if_last_char_is_a_letter <- function(txt) {","check_if_last_char_is_a_letter <- function(txt) {
  # Trim any trailing whitespace
  trimmed_txt <- trimws(txt, which = ""right"")
  
  # If the trimmed text is empty, return FALSE
  if (nchar(trimmed_txt) == 0) {
    return(FALSE)
  }
  
  # Get the last character
  last_char <- substr(trimmed_txt, nchar(trimmed_txt), nchar(trimmed_txt))
  
  # Check if the last character is an alphabetical character
  if (grepl(""[a-zA-Z]"", last_char)) {
    # Split the text by spaces
    words <- strsplit(trimmed_txt, "" "")[[1]]
    # Get the last word
    last_word <- tail(words, n = 1)
    # If last character is the only character in the last ""word"", return TRUE
    # Otherwise, it is part of a word, return FALSE
    return(nchar(last_word) == 1)
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()"
HumanEval_135,fur_Latn,r,"Esemplis: valôrs duplicâts. no esistin elements di chest gjenar, alore si torne -1. Il vetôr dât nol contignarà nol è plui grant o avuâl a l'element che lu precêt in maniere imediade. Se Creâ une funzion che e torne l'indiç plui grant di un element che # >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
can_arrange <- function(arr) {","can_arrange <- function(arr) {
  for (i in seq(length(arr) - 1, 1)) {
    if (arr[i] > arr[i + 1]) {
      return(i)
    }
  }
  return(-1)
}","test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()"
HumanEval_136,fur_Latn,r,"Esemplis: Se no son intîrs negatîfs o positîfs, al ven tornât NULL.di intîrs positifs intune liste. Il plui grant dai intîrs negatîfs, e ""b"" al è il plui piçul Creâ une funzion che e torne une liste (a, b), dulà che 'a' al è # >>> largest_smallest_integers(c(2, 4, 1, 3, 5, 7))
# list(NULL, 1)
# >>> largest_smallest_integers(c())
# list(NULL, NULL)
# >>> largest_smallest_integers(c(0))
# list(NULL, NULL)
largest_smallest_integers <- function(lst) {","largest_smallest_integers <- function(lst) {
  negatives <- lst[lst < 0]
  positives <- lst[lst > 0]
  
  largest_negative <- if(length(negatives) > 0) max(negatives) else NULL
  smallest_positive <- if(length(positives) > 0) min(positives) else NULL
  
  list(largest_negative, smallest_positive)
}","test_humaneval <- function() {
    candidate <- largest_smallest_integers
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7)), list(NULL, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7, 0)), list(NULL, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, -2)), c(-2, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 3, 6, 2, 7, -7)), c(-7, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(7, 3, 8, 4, 9, 2, 5, -9)), c(-9, 2))))
    stopifnot(isTRUE(all.equal(candidate(c()), list(NULL, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(0)), list(NULL, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6)), list(-1, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6, 0)), list(-1, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, 1)), c(-3, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, -100, 1)), c(-3, 1))))
}
test_humaneval()"
HumanEval_137,fur_Latn,r,"Note: Se un numar reâl al è rapresentât come une stringhe, il pont floating al pues jessi . o , Al torne NULL se i valôrs a son compagns. numars reâi, e torne la variabile plui grande tal so gjenar di variabile dât. Creâ une funzion che e cjape intîrs, floats, o stringhis che a rapresentin # >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
compare_one <- function(a, b) {","compare_one <- function(a, b) {
  to_number <- function(x) {
    if (is.character(x)) {
      x <- gsub("","", ""."", x)
      as.numeric(x)
    } else {
      as.numeric(x)
    }
  }
  
  a_num <- to_number(a)
  b_num <- to_number(b)
  
  if (a_num == b_num) {
    return(NULL)
  } else if (a_num > b_num) {
    return(a)
  } else {
    return(b)
  }
}","test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()"
HumanEval_138,fur_Latn,r,"Esempli Valori se il numar dât n al pues jessi scrit come la sume di 4 numars pari positifs# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
is_equal_to_sum_even <- function(n) {","is_equal_to_sum_even <- function(n) {
  if (n <= 0 || n %% 2 != 0 || n < 8) {
    return(FALSE)
  }
  remaining_sum <- n
  count <- 0
  for (i in seq(2, n, by = 2)) {
    if (remaining_sum - i >= 2 * (4 - count - 1)) {
      remaining_sum <- remaining_sum - i
      count <- count + 1
    }
    if (count == 4) {
      return(TRUE)
    }
  }
  return(FALSE)
}

# Examples
is_equal_to_sum_even(4)   # FALSE
is_equal_to_sum_even(6)   # FALSE
is_equal_to_sum_even(8)   # TRUE","test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()"
HumanEval_139,fur_Latn,r,"Par esempli: dulà che n > 0 brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! Il fatoriâl brasiliân al è definît come: # >>> special_factorial(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
special_factorial <- function(n) {","special_factorial <- function(n) {
  result <- 1
  for (i in 1:n) {
    result <- result * factorial(i)
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- special_factorial
    stopifnot(isTRUE(all.equal(candidate(4), 288)))
    stopifnot(isTRUE(all.equal(candidate(5), 34560)))
    stopifnot(isTRUE(all.equal(candidate(7), 125411328000)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
}
test_humaneval()"
HumanEval_140,fur_Latn,r,"alore si sostituissin ducj i spazis consecutivs cun - e se une stringhe e à plui di 2 spazis consecutivs, Dât un string di test, sostituìs ducj i spazis cun sotliniis, # >>> fix_spaces(' Example')
# 'Example'
# >>> fix_spaces(' Example 1')
# 'Example_1'
# >>> fix_spaces(' Example 2')
# '_Example_2'
# >>> fix_spaces(' Example 3')
# '_Example-3'
fix_spaces <- function(text) {","fix_spaces <- function(text) {
  # Trim leading and trailing spaces
  text <- trimws(text)
  # Replace 3 or more consecutive spaces with a dash
  text <- gsub("" {3,}"", ""-"", text)
  # Replace remaining spaces with underscores
  text <- gsub("" "", ""_"", text)
  return(text)
}","test_humaneval <- function() {
    candidate <- fix_spaces
    stopifnot(isTRUE(all.equal(candidate('Example'), 'Example')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')))
    stopifnot(isTRUE(all.equal(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')))
    stopifnot(isTRUE(all.equal(candidate('Exa   mple'), 'Exa-mple')))
    stopifnot(isTRUE(all.equal(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')))
}
test_humaneval()"
HumanEval_141,fur_Latn,r,"Esemplis: - La sot-string daspò dal pont e à di jessi une di chestis: ['txt', 'exe', 'dll'] ""A"" al è il non dal alfabet latin (""a"" - ""z"" e ""A"" - ""Z"").- La sotstrade prime dal pont no à di jessi vueide, e e scomence cun une letare di - Il non dal file al à un pont '.'- Il non dal file nol à di vê plui di trê cifris ('0'-'9'). a son sodisfats: Un non di file al è considerât valid se e dome se a son sodisfats ducj i criteris che a vegnin daûr.""Sì"" se il non dal file al è valid, e al torne ""No"" se no. Creâ une funzion che e cjape une stringhe che e rapresente il non di un file e e torne # >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'
file_name_check <- function(file_name) {","file_name_check <- function(file_name) {
  # Split the file name into the name part and the extension part
  parts <- strsplit(file_name, ""\\."", fixed = TRUE)[[1]]
  
  # Check there is exactly one dot
  if (length(parts) != 2) {
    return('No')
  }
  
  # Extract the name and extension
  name_part <- parts[1]
  ext_part <- parts[2]
  
  # Check the extension is valid
  if (!(ext_part %in% c('txt', 'exe', 'dll'))) {
    return('No')
  }
  
  # Check the name part is not empty and starts with a letter
  if (nchar(name_part) == 0 || !grepl(""^[A-Za-z]"", name_part)) {
    return('No')
  }
  
  # Count digits in the name part
  digit_count <- nchar(gsub(""[^0-9]"", """", name_part))
  
  # Check there are no more than three digits
  if (digit_count > 3) {
    return('No')
  }
  
  return('Yes')
}","test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()"
HumanEval_142,fur_Latn,r,"Esemplis: cambiâ lis vôs de liste che i lôr indizis a no son un multipli di 3 o 4. La funzion e tornarà la sume di dutis lis vôs. Il cuarp al è un multiplic di 3 e al cuvierzarà la entrade intîr se l'indiç al è un multiplic di 4 e no un multiplic di 3. La funzion no Cheste funzion e cjaparà une liste di intîrs. Par dutis lis iscrizions inte liste, la funzion e scuen meti al cuadrât la iscrizion intîr se il so indiç al è "" # >>> lst
# c(1, 2, 3)
# >>> lst
# c()
# >>> lst
# c(-1, -5, 2, -1, -5)
sum_squares <- function(lst) {","sum_squares <- function(lst) {
  lst <- sapply(seq_along(lst), function(i) {
    if (i %% 3 == 0) {
      return(lst[i]^2)
    } else if (i %% 4 == 0) {
      return(lst[i]^3)
    } else {
      return(lst[i])
    }
  })
  return(sum(lst))
}","test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 9)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 1, 1, 1, 1, 1)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -1, -1, -1, -1, -1, -1, -1, -1)), -3)))
    stopifnot(isTRUE(all.equal(candidate(c(0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -5, 2, -1, -5)), -126)))
    stopifnot(isTRUE(all.equal(candidate(c(-56, -99, 1, 0, -2)), 3030)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 0, 0, 0, 0, 0, 0, -1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)), -14196)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)), -1448)))
}
test_humaneval()"
HumanEval_143,fur_Latn,r,"Esempli 1: L'ordin des peraulis inte gnove stringhe al à di jessi chel dal origjinâl.la cui lungjece e je un numar prin, E tu âs di tornâ une stringhe che e conten lis peraulis de frase origjinâl, la frase e conten cualchi peraule separade di un spazi, Ti ven dade une stringhe che e rapresente une frase, # >>> words_in_sentence('This is a test')
# 'is'
# Example 2:
# >>> words_in_sentence('lets go for swimming')
# 'go for'
# Constraints:
#     * 1 <= len(sentence) <= 100
#     * sentence contains only letters
words_in_sentence <- function(sentence) {","words_in_sentence <- function(sentence) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n == 2) return(TRUE)
    for (i in 2:sqrt(n)) {
      if (n %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  words <- strsplit(sentence, "" "")[[1]]
  prime_words <- words[sapply(words, function(word) is_prime(nchar(word)))]
  return(paste(prime_words, collapse = "" ""))
}","test_humaneval <- function() {
    candidate <- words_in_sentence
    stopifnot(isTRUE(all.equal(candidate('This is a test'), 'is')))
    stopifnot(isTRUE(all.equal(candidate('lets go for swimming'), 'go for')))
    stopifnot(isTRUE(all.equal(candidate('there is no place available here'), 'there is no place')))
    stopifnot(isTRUE(all.equal(candidate('Hi I am Hussein'), 'Hi am Hussein')))
    stopifnot(isTRUE(all.equal(candidate('go for it'), 'go for it')))
    stopifnot(isTRUE(all.equal(candidate('here'), '')))
    stopifnot(isTRUE(all.equal(candidate('here is'), 'is')))
}
test_humaneval()"
HumanEval_144,fur_Latn,r,"Tu puedis presumî che x, e n a sedin frazions validis, e no àn zero come denominadôr.<numeradôr>/<denominadôr> dulà che sedi il numeradôr sedi il denominadôr a son numars intîrs positîfs. In ogni câs, x e n a son rapresentazions strings di une frazion e a àn il formât:x * n. La funzion e torne VÊR se x * n al è un numar intîr e FALS Il to compit al è di implementâ une funzion che e semplifichi l'espression # >>> simplify('1/5', '5/1')
# TRUE
# >>> simplify('1/6', '2/1')
# FALSE
# >>> simplify('7/10', '10/2')
# FALSE
simplify <- function(x, n) {","simplify <- function(x, n) {
  parse_fraction <- function(fraction) {
    parts <- strsplit(fraction, ""/"")[[1]]
    return(as.numeric(parts[1]) / as.numeric(parts[2]))
  }
  
  x_value <- parse_fraction(x)
  n_value <- parse_fraction(n)
  
  product <- x_value * n_value
  
  # Check if the product is a whole number
  return(product == floor(product))
}","test_humaneval <- function() {
    candidate <- simplify
    stopifnot(isTRUE(all.equal(candidate('1/5', '5/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('1/6', '2/1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('5/1', '3/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('7/10', '10/2'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2/10', '50/10'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('7/2', '4/2'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('11/6', '6/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('2/3', '5/2'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('5/2', '3/5'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2/4', '8/4'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('2/4', '4/2'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('1/5', '5/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('1/5', '1/5'), FALSE)))
}
test_humaneval()"
HumanEval_145,fur_Latn,r,"Par esempli: ordenâju daûr dal lôr indiç te liste origjinâl.Note: se a son diviersis partidis cun sumis similis des lôr cifras, in ordin ascendent daûr de sume des lôr cifras. Scrivi une funzion che e classifiche la liste dai intîrs # >>> order_by_points(c(1, 11, -1, -11, -12))
# c(-1, -11, 1, -12, 11)
# >>> order_by_points(c())
# c()
order_by_points <- function(nums) {","order_by_points <- function(nums) {
  # Helper function to calculate the sum of digits
  sum_of_digits <- function(n) {
    sum(as.integer(unlist(strsplit(as.character(abs(n)), """"))))
  }
  
  # Order the numbers based on the sum of their digits first, 
  # and then by their original index
  indices <- seq_along(nums)
  nums[order(sapply(nums, sum_of_digits), indices)]
}","test_humaneval <- function() {
    candidate <- order_by_points
    stopifnot(isTRUE(all.equal(candidate(c(1, 11, -1, -11, -12)), c(-1, -11, 1, -12, 11))))
    stopifnot(isTRUE(all.equal(candidate(c(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)), c(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, -11, -32, 43, 54, -98, 2, -3)), c(-3, -32, -98, -11, 1, 2, 43, 54))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), c(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9))))
    stopifnot(isTRUE(all.equal(candidate(c(0, 6, 6, -76, -21, 23, 4)), c(-76, -21, 0, 4, 23, 6, 6))))
}
test_humaneval()"
HumanEval_146,fur_Latn,r,"Par esempli: La prime e la ultime cifre di un numar a son dispariis (1, 3, 5, 7, 9).il numar di elements dal vetôr che a son plui grancj di 10 e ducj i doi Scrivi une funzion che e cjape un vetôr di numars come input e e torne # >>> specialFilter(c(15, -73, 14, -15))
# 1
# >>> specialFilter(c(33, -2, -3, 45, 21, 109))
# 2
specialFilter <- function(nums) {","specialFilter <- function(nums) {
  # Helper function to check if both first and last digits are odd
  are_first_last_digits_odd <- function(x) {
    str_num <- as.character(abs(x))
    first_digit <- as.numeric(substr(str_num, 1, 1))
    last_digit <- as.numeric(substr(str_num, nchar(str_num), nchar(str_num)))
    first_digit %% 2 == 1 && last_digit %% 2 == 1
  }

  # Filter numbers greater than 10 with both first and last digits odd
  filtered_nums <- nums[nums > 10 & sapply(nums, are_first_last_digits_odd)]
  
  # Return the count of such numbers
  length(filtered_nums)
}","test_humaneval <- function() {
    candidate <- specialFilter
    stopifnot(isTRUE(all.equal(candidate(c(5, -2, 1, -5)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(15, -73, 14, -15)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(33, -2, -3, 45, 21, 109)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(43, -12, 93, 125, 121, 109)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(71, -2, -33, 75, 21, 19)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
}
test_humaneval()"
HumanEval_147,fur_Latn,r,"Esempli: e a[i] + a[j] + a[k] al è un multipli di 3. Ritorne il numar di triplis (a[i], a[j], a[k]) di a dulà che i < j < k, Par ogni i (1 ≤ i ≤ n), il valôr di a[i] = i * i - i + 1. Tu âs un intîr positîf n. Tu âs di creâ un intîr vetôr a di lungjece n.#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
get_max_triples <- function(n) {","get_max_triples <- function(n) {
  # Create the vector a according to the given rule
  a <- sapply(1:n, function(i) i * i - i + 1)
  
  # Initialize the count of valid triples
  count <- 0
  
  # Iterate over all possible triples (i, j, k) with i < j < k
  for (i in 1:(n-2)) {
    for (j in (i+1):(n-1)) {
      for (k in (j+1):n) {
        # Check if the sum of the selected triple is a multiple of 3
        if ((a[i] + a[j] + a[k]) %% 3 == 0) {
          count <- count + 1
        }
      }
    }
  }
  
  # Return the count of valid triples
  return(count)
}","test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()"
HumanEval_148,fur_Latn,r,"Esemplis a no son nons corets dai planets.La funzion e varès di tornâ une liste vueide se planet1 o planet2 la prossimitât dal soreli.a son tra l'orbit dal planet1 e l'orbit dal planet2, ordenâts par La funzion e varès di tornâ une liste cun ducj i planets che a àn orbitais che a son Scrivi une funzion che e cjapi doi nons di planetis come stringhe planet1 e planet2.Urano, Nettun.Al è Mercuri, il prossim al è Venere, po la Tiere, Mart, Zovi, Saturn,A son otante planets tal nestri sisteme solâr: i plui dongje dal Soreli.# >>> bf('Jupiter', 'Neptune')
# c('Saturn', 'Uranus')
# >>> bf('Earth', 'Mercury')
# 'Venus'
# >>> bf('Mercury', 'Uranus')
# c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')
bf <- function(planet1, planet2) {","bf <- function(planet1, planet2) {
  planets <- c('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')
  if (!(planet1 %in% planets) || !(planet2 %in% planets)) {
    return(c())
  }
  
  index1 <- which(planets == planet1)
  index2 <- which(planets == planet2)
  
  if (index1 < index2) {
    return(planets[(index1 + 1):(index2 - 1)])
  } else if (index2 < index1) {
    return(planets[(index2 + 1):(index1 - 1)])
  } else {
    return(c())
  }
}","test_humaneval <- function() {
    candidate <- bf
    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Neptune'), c('Saturn', 'Uranus'))))
    stopifnot(isTRUE(all.equal(candidate('Earth', 'Mercury'), c('Venus'))))
    stopifnot(isTRUE(all.equal(candidate('Mercury', 'Uranus'), c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'))))
    stopifnot(isTRUE(all.equal(candidate('Neptune', 'Venus'), c('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'))))
    stopifnot(isTRUE(all.equal(candidate('Earth', 'Earth'), c())))
    stopifnot(isTRUE(all.equal(candidate('Mars', 'Earth'), c())))
    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Makemake'), c())))
}
test_humaneval()"
HumanEval_149,fur_Latn,r,"Par esempli: Tu puedis pensâ che dutis lis peraulis a àn la stesse lungjece.La funzion e varès di tornâ une liste di stringhis in ordin ordinât.Se dôs peraulis a àn la stesse lungjece, ordenâ la liste in ordin alfabetic. al varès di tornâ la liste ordenade daûr di chê regule. L'ordin de liste al varès di jessi in cressite daûr de lungjece di ogni peraule, e tu e al pues contignî duplicâts.La liste e je simpri une liste di stringhis e mai un vetôr di numars, e al torne la liste risultante cuntun ordin ordinât, al elimine lis stringhis che a àn une lungjece dispari di chel, Scrivi une funzion che e acete une liste di stringhis come parametri, # >>> list_sort(c('aa', 'a', 'aaa'))
# c('aa')
# >>> list_sort(c('ab', 'a', 'aaa', 'cd'))
# c('ab', 'cd')
sorted_list_sum <- function(lst) {","list_sort <- function(lst) {
  # Filter out strings with odd lengths
  filtered_list <- lst[nchar(lst) %% 2 == 0]
  
  # Sort the list first by length, then alphabetically
  sorted_list <- filtered_list[order(nchar(filtered_list), filtered_list)]
  
  return(sorted_list)
}","test_humaneval <- function() {
    candidate <- sorted_list_sum
    stopifnot(isTRUE(all.equal(candidate(c('aa', 'a', 'aaa')), c('aa'))))
    stopifnot(isTRUE(all.equal(candidate(c('school', 'AI', 'asdf', 'b')), c('AI', 'asdf', 'school'))))
    stopifnot(isTRUE(all.equal(candidate(c('d', 'b', 'c', 'a')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('d', 'dcba', 'abcd', 'a')), c('abcd', 'dcba'))))
    stopifnot(isTRUE(all.equal(candidate(c('AI', 'ai', 'au')), c('AI', 'ai', 'au'))))
    stopifnot(isTRUE(all.equal(candidate(c('a', 'b', 'b', 'c', 'c', 'a')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('aaaa', 'bbbb', 'dd', 'cc')), c('cc', 'dd', 'aaaa', 'bbbb'))))
}
test_humaneval()"
HumanEval_150,fur_Latn,r,"Esemplis: un numar prin e al varès di tornâ il valôr di y altrimentri. Un sempliç program che al varès di tornâ il valôr di x se n al è # >>> x_or_y(7, 34, 12)
# 34
# >>> x_or_y(15, 8, 5)
# 5
x_or_y <- function(n, x, y) {","x_or_y <- function(n, x, y) {
  is_prime <- function(num) {
    if (num <= 1) {
      return(FALSE)
    }
    for (i in 2:sqrt(num)) {
      if (num %% i == 0) {
        return(FALSE)
      }
    }
    return(TRUE)
  }
  
  if (is_prime(n)) {
    return(x)
  } else {
    return(y)
  }
}","test_humaneval <- function() {
    candidate <- x_or_y
    stopifnot(isTRUE(all.equal(candidate(7, 34, 12), 34)))
    stopifnot(isTRUE(all.equal(candidate(15, 8, 5), 5)))
    stopifnot(isTRUE(all.equal(candidate(3, 33, 5212), 33)))
    stopifnot(isTRUE(all.equal(candidate(1259, 3, 52), 3)))
    stopifnot(isTRUE(all.equal(candidate(7919, -1, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(3609, 1245, 583), 583)))
    stopifnot(isTRUE(all.equal(candidate(91, 56, 129), 129)))
    stopifnot(isTRUE(all.equal(candidate(6, 34, 1234), 1234)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 0), 0)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 0), 2)))
}
test_humaneval()"
HumanEval_151,fur_Latn,r,"Ignorâ i numars che a son negatîfs o che a no son intîrs.Dât un elenc di numars, torne la sume dai cuadrâts dai numars # >>> double_the_difference(c(1, 3, 2, 0))
# 10
# >>> double_the_difference(c(-1, -2, 0))
# 0
# >>> double_the_difference(c(9, -2))
# 81
# >>> double_the_difference(c(0))
# 0
# If the input list is empty, return 0.
double_the_difference <- function(lst) {","double_the_difference <- function(lst) {
  # Filter out non-positive, non-integer, and non-odd numbers
  lst <- lst[lst > 0 & lst %% 1 == 0 & lst %% 2 == 1]
  # Calculate the sum of squares of remaining numbers
  sum(lst^2)
}","test_humaneval <- function() {
    candidate <- double_the_difference
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5.0, 4.0)), 25)))
    stopifnot(isTRUE(all.equal(candidate(c(0.1, 0.2, 0.3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-10.0, -20.0, -30.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, -2.0, 8.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0.2, 3.0, 5.0)), 34)))
    stopifnot(isTRUE(all.equal(candidate(c(-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0)), 165)))
}
test_humaneval()"
HumanEval_152,fur_Latn,r,"esempli: il valôr al è 0, e se no, il valôr al è la diference assolute tra la coniugazion e il pont. Tornâ un vetôr de stesse lungjece che al indiche ce tant lontane che e je stade ogni indovinade.Si dan doi vetôrs di puntegj e indovinaments di lungjece compagne, dulà che ogni indiç al mostre une corispondence.Il to compit al è di determinâ se une persone e à indovinât in mût coret i risultâts di un ciert numar di partidis.di sigûr al vâl la pene di notâsi e di confrontâsi.I pinsîrs e i sintiments che tu âs in chel moment a sonO crôt che ducj si ricuardin di chê sensazion cuant che il risultât di cualchi tant spietade# >>> compare(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2))
# c(0, 0, 0, 0, 3, 3)
# >>> compare(c(0, 5, 0, 0, 0, 4), c(4, 1, 1, 0, 0, -2))
# c(4, 4, 1, 0, 0, 6)
compare <- function(game, guess) {","compare <- function(game, guess) {
  abs(game - guess)
}","test_humaneval <- function() {
    candidate <- compare
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2)), c(0, 0, 0, 0, 3, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(0, 0, 0, 0, 0, 0), c(0, 0, 0, 0, 0, 0)), c(0, 0, 0, 0, 0, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), c(-1, -2, -3)), c(2, 4, 6))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5), c(-1, 2, 3, 4)), c(2, 0, 0, 1))))
}
test_humaneval()"
HumanEval_153,fur_Latn,r,"Esempli: (la sô fuarce e je -1).return ""Slices.SErviNGSliCes"" parcè che ""SErviNGSliCes"" e je la estension plui fuarte ['SERVINGSliCes', 'Cheese', 'StuFfed'] alore tu varessis di Par esempli, se tu âs ""Slices"" come classe e une liste des sielç chê che e je prime te liste.Se a son dôs o plui estensionis cun la stesse fuarce, tu varâs di fâle.format: ClassName.StrongestExtensionName. Tu varessis di cjatâ la estension plui fuarte e tornâ une stringhe in chest .tal non de estension, la intensitât e je dade de frazion CAP - SM. Letaris tal non de estension, e SM al è il numar di letaris minuscolârs La fuarce de estension e je cheste: CAP al è il numar dal maiusclet Lis estensions a son par doprâ par cargjâ classis adizionâls ae classe.Ti ven dât il non di une classe (une stringhe) e une liste di estensions.# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'
Strongest_Extension <- function(class_name, extensions) {","Strongest_Extension <- function(class_name, extensions) {
  # Function to calculate the strength of an extension
  extension_strength <- function(ext) {
    cap_count <- sum(grepl(""[A-Z]"", strsplit(ext, """")[[1]]))
    sm_count <- sum(grepl(""[a-z]"", strsplit(ext, """")[[1]]))
    return(cap_count - sm_count)
  }
  
  # Calculate strength for each extension and find the strongest one
  strengths <- sapply(extensions, extension_strength)
  max_strength_index <- which.max(strengths)
  
  # Construct the result string
  return(paste0(class_name, ""."", extensions[max_strength_index]))
}","test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()"
HumanEval_154,fur_Latn,r,"Tu âs di tornâ TRUE se la seconde peraule o cualchidun di chei altris cambiaments e je une sotstring inte prime peraule.# >>> cycpattern_check('abcd', 'abd')
# FALSE
# >>> cycpattern_check('hello', 'ell')
# TRUE
# >>> cycpattern_check('whassup', 'psus')
# FALSE
# >>> cycpattern_check('abab', 'baa')
# TRUE
# >>> cycpattern_check('efef', 'eeff')
# FALSE
# >>> cycpattern_check('himenss', 'simen')
# TRUE
cycpattern_check <- function(a, b) {","cycpattern_check <- function(a, b) {
  n <- nchar(b)
  # Check all rotations of b
  for (i in 0:(n-1)) {
    # Rotate the string b by i characters
    rotated_b <- substring(b, i+1, n) %/% substring(b, 1, i)
    # Check if the rotated string is a substring of a
    if (grepl(rotated_b, a)) {
      return(TRUE)
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- cycpattern_check
    stopifnot(isTRUE(all.equal(candidate('xyzw', 'xyw'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('yello', 'ell'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('whattup', 'ptut'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('efef', 'fee'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abab', 'aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('winemtt', 'tinem'), TRUE)))
}
test_humaneval()"
HumanEval_155,fur_Latn,r,"Esempli: Dât un intîr, al torne une liste che e à il numar di cifras pari e dispariis. #     >>> even_odd_count(-12)
#     c(1, 1)
#     >>> even_odd_count(123)
#     c(1, 2)
even_odd_count <- function(num) {","even_odd_count <- function(num) {
  # Handle negative numbers by taking the absolute value
  num <- abs(num)
  
  # Convert the number to a character vector to access digits
  digits <- unlist(strsplit(as.character(num), """"))
  
  # Convert character vector back to integer
  digits <- as.integer(digits)
  
  # Count even digits
  even_count <- sum(digits %% 2 == 0)
  
  # Count odd digits
  odd_count <- length(digits) - even_count
  
  # Return a vector with even and odd counts
  return(c(even_count, odd_count))
}","test_humaneval <- function() {
    candidate <- even_odd_count
    stopifnot(isTRUE(all.equal(candidate(7), c(0, 1))))
    stopifnot(isTRUE(all.equal(candidate(-78), c(1, 1))))
    stopifnot(isTRUE(all.equal(candidate(3452), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(346211), c(3, 3))))
    stopifnot(isTRUE(all.equal(candidate(-345821), c(3, 3))))
    stopifnot(isTRUE(all.equal(candidate(-2), c(1, 0))))
    stopifnot(isTRUE(all.equal(candidate(-45347), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1, 0))))
}
test_humaneval()"
HumanEval_156,fur_Latn,r,"Esemplis: Restrizions: 1 <= num <= 1000 e tornâle in minuscule.Dât un intîr positîf, otign il so ecuivalent in numars romans come une stringhe, # >>> int_to_mini_roman(19)
# 'xix'
# >>> int_to_mini_roman(152)
# 'clii'
# >>> int_to_mini_roman(426)
# 'cdxxvi'
int_to_mini_roman <- function(number) {","int_to_mini_roman <- function(number) {
  values <- c(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
  numerals <- c(""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i"")
  
  result <- """"
  remainder <- number
  
  for (i in seq_along(values)) {
    while (remainder >= values[i]) {
      result <- paste0(result, numerals[i])
      remainder <- remainder - values[i]
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- int_to_mini_roman
    stopifnot(isTRUE(all.equal(candidate(19), 'xix')))
    stopifnot(isTRUE(all.equal(candidate(152), 'clii')))
    stopifnot(isTRUE(all.equal(candidate(251), 'ccli')))
    stopifnot(isTRUE(all.equal(candidate(426), 'cdxxvi')))
    stopifnot(isTRUE(all.equal(candidate(500), 'd')))
    stopifnot(isTRUE(all.equal(candidate(1), 'i')))
    stopifnot(isTRUE(all.equal(candidate(4), 'iv')))
    stopifnot(isTRUE(all.equal(candidate(43), 'xliii')))
    stopifnot(isTRUE(all.equal(candidate(90), 'xc')))
    stopifnot(isTRUE(all.equal(candidate(94), 'xciv')))
    stopifnot(isTRUE(all.equal(candidate(532), 'dxxxii')))
    stopifnot(isTRUE(all.equal(candidate(900), 'cm')))
    stopifnot(isTRUE(all.equal(candidate(994), 'cmxciv')))
    stopifnot(isTRUE(all.equal(candidate(1000), 'm')))
}
test_humaneval()"
HumanEval_157,fur_Latn,r,"Esempli: 90 grâts. Un triangul retangolâr al è un triangul dulà che un dai angui al è retângul o I doi ladrins a formin un triangul retangolâr, se no FALS.Dât i lungjons dai trê ladrâts di un triangul.# >>> right_angle_triangle(3, 4, 5)
# TRUE
# >>> right_angle_triangle(1, 2, 3)
# FALSE
right_angle_triangle <- function(a, b, c) {","right_angle_triangle <- function(a, b, c) {
  # Sort the sides to easily compare the largest side
  sides <- sort(c(a, b, c))
  
  # Check if the sum of squares of the two smaller sides equals the square of the largest side
  return(sides[1]^2 + sides[2]^2 == sides[3]^2)
}","test_humaneval <- function() {
    candidate <- right_angle_triangle
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(10, 6, 8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(7, 24, 25), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(5, 12, 13), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(15, 8, 17), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(48, 55, 73), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), FALSE)))
}
test_humaneval()"
HumanEval_158,fur_Latn,r,"caratars, al torne chel che al ven prin in ordin lessicografic. Se plui stringhis a àn un numar massim di caratars unicis La liste e conten peraulis diviersis.Scrivi une funzion che e acete une liste di stringhis. # >>> find_max(c('name', 'of', 'string'))
# 'string'
# >>> find_max(c('name', 'enam', 'game'))
# 'enam'
# >>> find_max(c('aaaaaaa', 'bb', 'cc'))
# 'aaaaaaa'
find_max <- function(words) {","find_max <- function(words) {
  max_unique_chars <- 0
  result <- """"
  
  for (word in words) {
    unique_chars_count <- length(unique(strsplit(word, NULL)[[1]]))
    
    if (unique_chars_count > max_unique_chars ||
       (unique_chars_count == max_unique_chars && word < result)) {
      max_unique_chars <- unique_chars_count
      result <- word
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- find_max
    stopifnot(isTRUE(all.equal(candidate(c('name', 'of', 'string')), 'string')))
    stopifnot(isTRUE(all.equal(candidate(c('name', 'enam', 'game')), 'enam')))
    stopifnot(isTRUE(all.equal(candidate(c('aaaaaaa', 'bb', 'cc')), 'aaaaaaa')))
    stopifnot(isTRUE(all.equal(candidate(c('abc', 'cba')), 'abc')))
    stopifnot(isTRUE(all.equal(candidate(c('play', 'this', 'game', 'of', 'footbott')), 'footbott')))
    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'gonna', 'rock')), 'gonna')))
    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'a', 'mad', 'nation')), 'nation')))
    stopifnot(isTRUE(all.equal(candidate(c('this', 'is', 'a', 'prrk')), 'this')))
    stopifnot(isTRUE(all.equal(candidate(c('b')), 'b')))
    stopifnot(isTRUE(all.equal(candidate(c('play', 'play', 'play')), 'play')))
}
test_humaneval()"
HumanEval_159,fur_Latn,r,"Esempli: se no son bastantis zupetis, tu mangjarâs dutis lis zupetis, ma tu varâs ancjemò fam.il numar di zupetis che ti restin dopo lis misuris] tu varessis di tornâ un vetôr di [ numar totâl di zvarots mangjâts daspò dai pasti, Ma cumò tu âs di mangjâ plui carote par completâ i pasti di chê dì.Tu sês un conîl affamât, e tu âs za mangjât un ciert numar di carote,# >>> eat(5, 6, 10)
# c(11, 4)
# >>> eat(4, 8, 9)
# c(12, 1)
# >>> eat(1, 10, 10)
# c(11, 0)
# >>> eat(2, 11, 5)
# c(7, 0)
# Variables:
# @number : integer
#     the number of carrots that you have eaten.
# @need : integer
#     the number of carrots that you need to eat.
# @remaining : integer
#     the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
eat <- function(number, need, remaining) {","eat <- function(number, need, remaining) {
  total_eaten <- number + min(need, remaining)
  remaining_carrots <- max(0, remaining - need)
  return(c(total_eaten, remaining_carrots))
}","test_humaneval <- function() {
    candidate <- eat
    stopifnot(isTRUE(all.equal(candidate(5, 6, 10), c(11, 4))))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 9), c(12, 1))))
    stopifnot(isTRUE(all.equal(candidate(1, 10, 10), c(11, 0))))
    stopifnot(isTRUE(all.equal(candidate(2, 11, 5), c(7, 0))))
    stopifnot(isTRUE(all.equal(candidate(4, 5, 7), c(9, 2))))
    stopifnot(isTRUE(all.equal(candidate(4, 5, 1), c(5, 0))))
}
test_humaneval()"
HumanEval_160,fur_Latn,r,"La liste dai operadôrs e à almancul un operadôr e la liste dai operands e à almancul doi operands.L'operand al è une liste di intîrs no negatîfs.La lungjece de liste dai operadôrs e je avuâl a la lungjece de liste dai operands mancul un.Note: => risultât = 9 risultât = 2 + 3 * 4 - 5 vetôr = [2, 3, 4, 5] operadôr['+', '*', '-'] Esempli: Esponenziâzion (**) Division dal paviment ( //) Moltiplicazion (*) Sottrazion ( - ) Agregazion (+) Lis operazions di base de algjebre: espression e a ridâ la valutazion di cheste espression. La seconde liste e je une liste di intîrs.Dât doi listis di operadôr e operand, la prime liste e à operazions di base di algjebre, e do_algebra <- function(operator, operand) {","do_algebra <- function(operator, operand) {
  if (length(operator) != length(operand) - 1) {
    stop(""The length of operator list must be equal to the length of operand list minus one."")
  }
  
  # Initialize the result with the first operand
  result <- operand[1]
  
  # Iterate through the operators and operands
  for (i in 1:length(operator)) {
    op <- operator[i]
    num <- operand[i + 1]
    
    # Apply the appropriate operation
    if (op == '+') {
      result <- result + num
    } else if (op == '-') {
      result <- result - num
    } else if (op == '*') {
      result <- result * num
    } else if (op == '//') {
      result <- result %/% num
    } else if (op == '**') {
      result <- result ^ num
    } else {
      stop(""Unsupported operation"")
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- do_algebra
    stopifnot(isTRUE(all.equal(candidate(c('**', '*', '+'), c(2, 3, 4, 5)), 37)))
    stopifnot(isTRUE(all.equal(candidate(c('+', '*', '-'), c(2, 3, 4, 5)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c('//', '*'), c(7, 3, 4)), 8)))
}
test_humaneval()"
HumanEval_161,fur_Latn,r,"Esemplis La funzion e varès di tornâ la stringhe risultante. Se la stringhe no conten letaris, invertî la stringhe.Se no, no si pues cambiâ.se s[i] al è une letare, al è inviert dal piçul al grant o vice versa, Ti ven dade une stringhe di peraulis.# >>> solve('1234')
# '4321'
# >>> solve('ab')
# 'AB'
# >>> solve('#a@C')
# '#A@c'
solve <- function(s) {","solve <- function(s) {
  if (grepl(""[a-zA-Z]"", s)) {
    return(chartr(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"",
                  ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"", s))
  } else {
    return(intToUtf8(rev(utf8ToInt(s))))
  }
}","test_humaneval <- function() {
    candidate <- solve
    stopifnot(isTRUE(all.equal(candidate('AsDf'), 'aSdF')))
    stopifnot(isTRUE(all.equal(candidate('1234'), '4321')))
    stopifnot(isTRUE(all.equal(candidate('ab'), 'AB')))
    stopifnot(isTRUE(all.equal(candidate('#a@C'), '#A@c')))
    stopifnot(isTRUE(all.equal(candidate('#AsdfW^45'), '#aSDFw^45')))
    stopifnot(isTRUE(all.equal(candidate('#6@2'), '2@6#')))
    stopifnot(isTRUE(all.equal(candidate('#$a^D'), '#$A^d')))
    stopifnot(isTRUE(all.equal(candidate('#ccc'), '#CCC')))
}
test_humaneval()"
HumanEval_162,fur_Latn,r,"Se 'text' e je une stringhe vuide, torne NULL. Dade une stringhe 'text', torne la stringhe di hash md5 avuâl. # >>> string_to_md5('Hello world')
# '3e25960a79dbc69b674cd4ec67a72c62'
string_to_md5 <- function(text) {","string_to_md5 <- function(text) {
  if (text == """") {
    return(NULL)
  } else {
    return(digest::digest(text, algo = ""md5"", serialize = FALSE))
  }
}

# Ensure the required library is loaded
if(!requireNamespace(""digest"", quietly = TRUE)) {
  install.packages(""digest"")
}

# Load the digest library
library(digest)","test_humaneval <- function() {
    candidate <- string_to_md5
    stopifnot(isTRUE(all.equal(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')))
    stopifnot(isTRUE(all.equal(candidate(''), NULL)))
    stopifnot(isTRUE(all.equal(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')))
    stopifnot(isTRUE(all.equal(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')))
}
test_humaneval()"
HumanEval_163,fur_Latn,r,"Par esempli: e b, in ordin di cressite. Dâts doi intîrs positîfs a e b, torne lis cifris pari tra a # >>> generate_integers(2, 8)
# c(2, 4, 6, 8)
# >>> generate_integers(8, 2)
# c(2, 4, 6, 8)
# >>> generate_integers(10, 14)
# c()
generate_integers <- function(a, b) {","generate_integers <- function(a, b) {
  start <- min(a, b)
  end <- max(a, b)
  even_digits <- seq(start, end)[seq(start, end) %% 2 == 0 & seq(start, end) <= 8]
  return(even_digits)
}","test_humaneval <- function() {
    candidate <- generate_integers
    stopifnot(isTRUE(all.equal(candidate(2, 10), c(2, 4, 6, 8))))
    stopifnot(isTRUE(all.equal(candidate(10, 2), c(2, 4, 6, 8))))
    stopifnot(isTRUE(all.equal(candidate(132, 2), c(2, 4, 6, 8))))
    stopifnot(isTRUE(all.equal(candidate(17, 89), c())))
}
test_humaneval()"
