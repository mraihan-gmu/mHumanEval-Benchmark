task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,ydd_Hebr,r,"געגעבן טרעסעל. קאָנטראָלירן צי אין דער געגעבן רשימה פון נומערן, זענען קיין צוויי נומערן נעענטער צו יעדער אנדערער ווי # >>> has_close_elements(c(1.0, 2.0, 3.0), 0.5)
# FALSE
# >>> has_close_elements(c(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)
# TRUE
has_close_elements <- function(numbers, threshold) {","has_close_elements <- function(numbers, threshold) {
  for (i in seq_along(numbers)) {
    for (j in seq_along(numbers)) {
      if (i != j && abs(numbers[i] - numbers[j]) < threshold) {
        return(TRUE)
      }
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- has_close_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.95), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.8), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 1.0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 0.5), FALSE)))
}
test_humaneval()"
HumanEval_1,ydd_Hebr,r,"איגנאָרירן קיין ספּייסיז אין די ינפּוט שטריקל. באַזונדער גרופּעס זענען באַלאַנסט (יעדע עפענען בראַסע איז רעכט פארמאכט) און נישט נעסטעד אין יעדער אנדערער באַזונדער די גרופּע אין באַזונדער סטרינגס און צוריקקומען די רשימה פון די. אַרייַנפיר צו דעם פונקציע איז אַ שטריקל וואָס כּולל קייפל גרופּעס פון נעסטעד פּאַראַנטעזעס. דיין ציל איז צו # >>> separate_paren_groups('( ) (( )) (( )( ))')
# c('()', '(())', '(()())')
separate_paren_groups <- function(paren_string) {","separate_paren_groups <- function(paren_string) {
  # Remove spaces from the input string
  paren_string <- gsub("" "", """", paren_string)
  
  # Initialize variables for processing
  result <- c()
  current_group <- """"
  balance <- 0
  
  # Iterate through each character in the string
  for (char in strsplit(paren_string, """")[[1]]) {
    current_group <- paste0(current_group, char)
    if (char == ""("") {
      balance <- balance + 1
    } else if (char == "")"") {
      balance <- balance - 1
    }
    
    # If balance is zero, we found a complete group
    if (balance == 0 && nchar(current_group) > 0) {
      result <- c(result, current_group)
      current_group <- """"
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- separate_paren_groups
    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c('(()())', '((()))', '()', '((())()())'))))
    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c('()', '(())', '((()))', '(((())))'))))
    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c('(()(())((())))'))))
    stopifnot(isTRUE(all.equal(candidate('( ) (( )) (( )( ))'), c('()', '(())', '(()())'))))
}
test_humaneval()"
HumanEval_2,ydd_Hebr,r,"צוריקקומען די דעצימאַל טייל פון די נומער. (רעקווערט טייל שטענדיק קלענערער ווי 1).און ינטאַדזשער טייל (גרעסטער ינטאַדזשער קלענערער ווי געגעבן נומער) און דעצימאַלס געגעבען א פאזיטיווע פלאָוטינג פונט נומער, קען מען עס צעטיילן אין # >>> truncate_number(3.5)
# 0.5
truncate_number <- function(number) {","truncate_number <- function(number) {
  return(number - floor(number))
}","test_humaneval <- function() {
    candidate <- truncate_number
    stopifnot(isTRUE(all.equal(candidate(3.5), 0.5)))
    stopifnot(isTRUE(all.equal(candidate(1.25), 0.25)))
    stopifnot(isTRUE(all.equal(candidate(123.0), 0.0)))
}
test_humaneval()"
HumanEval_3,ydd_Hebr,r,"אין דעם פונט פונקציע זאָל צוריקקומען אמת. אַנדערש עס זאָל צוריקקומען פאַלש. נול וואָג. דיין אַרבעט איז צו דעטעקט אויב אין קיין פונט די וואָג פון חשבון פאלס אונטער נול, און מען גיט א ליסטע פון דיפאזיט און אפטרעטן אפעראציעס אויף א באנק אקאונט וואס הייבט זיך אן מיט # >>> below_zero(c(1, 2, 3))
# FALSE
# >>> below_zero(c(1, 2, -4, 5))
# TRUE
below_zero <- function(operations) {","below_zero <- function(operations) {
  balance <- 0
  for (op in operations) {
    balance <- balance + op
    if (balance < 0) {
      return(TRUE)
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- below_zero
    stopifnot(isTRUE(all.equal(candidate(c()), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -3, 1, 2, -3)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, 2, -2, 5, -5, 4, -4)), TRUE)))
}
test_humaneval()"
HumanEval_4,ydd_Hebr,r,"MAD = דורכשניטלעך. x - x_מענין. עלעמענט און אַ צענטערפּונקט (מיינונג אין דעם פאַל): מיטל אַבסאָלוט דעוויאַישאַן איז די דורכשניטלעך אַבסאָלוט חילוק צווישן יעדער אַרום די מיטל פון דעם דאַטאַסעט. פֿאַר אַ געגעבן רשימה פון ינפּוט נומערן, רעכענען מיטל אַבסאָלוט דעוויאַישאַן # >>> mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))
# 1.0
mean_absolute_deviation <- function(numbers) {","mean_absolute_deviation <- function(numbers) {
  x_mean <- mean(numbers)
  mad <- mean(abs(numbers - x_mean))
  return(mad)
}

# Example usage
mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))","test_humaneval <- function() {
    candidate <- mean_absolute_deviation
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0)), 0.5)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0)), 1.0)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), 1.2)))
}
test_humaneval()"
HumanEval_5,ydd_Hebr,r,"אַרייַנלייגן אַ נומער ""דילימעטער"" צווישן יעדער צוויי קאָנסעקוטיווע עלעמענטן פון ינפּוט רשימה `numbers' # >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
intersperse <- function(numbers, delimeter) {","intersperse <- function(numbers, delimeter) {
  if (length(numbers) <= 1) {
    return(numbers)
  }
  result <- c()
  for (i in 1:(length(numbers) - 1)) {
    result <- c(result, numbers[i], delimeter)
  }
  result <- c(result, numbers[length(numbers)])
  return(result)
}","test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()"
HumanEval_6,ydd_Hebr,r,"למשל (() (()) האט מאַקסימום צוויי לעוועלס פון נעסטינג בשעת ((())) האט דרייַ. פֿאַר יעדער פון די גרופּע, אַרויספירן די דיפּאַסט מדרגה פון נעסטינג פון פּאַראַנטעסיז. אַרייַנפיר צו דעם פונקציע איז אַ שטריקל רעפּריזענטיד קייפל גרופּעס פֿאַר נעסטעד פּאַראַנטעזעס אפגעשיידט דורך ספּייסאַז. # >>> parse_nested_parens('(()()) ((())) () ((())()())')
# c(2, 3, 1, 3)
parse_nested_parens <- function(paren_string) {","parse_nested_parens <- function(paren_string) {
  sapply(strsplit(paren_string, "" "")[[1]], function(group) {
    max_nesting <- 0
    current_nesting <- 0
    for (char in strsplit(group, """")[[1]]) {
      if (char == ""("") {
        current_nesting <- current_nesting + 1
        max_nesting <- max(max_nesting, current_nesting)
      } else if (char == "")"") {
        current_nesting <- current_nesting - 1
      }
    }
    return(max_nesting)
  })
}","test_humaneval <- function() {
    candidate <- parse_nested_parens
    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c(2, 3, 1, 3))))
    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c(4))))
}
test_humaneval()"
HumanEval_7,ydd_Hebr,r,"פילטערן אַ ינפּוט רשימה פון סטרינגס בלויז פֿאַר די וואָס אַנטהאַלטן געגעבן סאַבסטראַנג # >>> filter_by_substring(c(), 'a')
# c()
# >>> filter_by_substring(c('abc', 'bacd', 'cde', 'array'), 'a')
# c('abc', 'bacd', 'array')
filter_by_substring <- function(strings, substring) {","filter_by_substring <- function(strings, substring) {
  return(strings[grepl(substring, strings)])
}","test_humaneval <- function() {
    candidate <- filter_by_substring
    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))
    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))
    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'), 'xx'), c('xxx', 'aaaxxy', 'xxxAAA', 'xxx'))))
    stopifnot(isTRUE(all.equal(candidate(c('grunt', 'trumpet', 'prune', 'gruesome'), 'run'), c('grunt', 'prune'))))
}
test_humaneval()"
HumanEval_8,ydd_Hebr,r,"ליידיק סומע זאָל זיין גלייַך צו 0 און ליידיק פּראָדוקט זאָל זיין גלייַך צו 1. פֿאַר אַ געגעבן רשימה פון ינטיידזשערז, צוריקקומען אַ רשימה קאַנסיסטינג פון אַ סכום און אַ פּראָדוקט פון אַלע די ינטיידזשערז אין אַ רשימה. # >>> sum_product(c())
# c(0, 1)
# >>> sum_product(c(1, 2, 3, 4))
# c(10, 24)
sum_product <- function(numbers) {","sum_product <- function(numbers) {
  sum_val <- sum(numbers)
  prod_val <- ifelse(length(numbers) == 0, 1, prod(numbers))
  return(c(sum_val, prod_val))
}","test_humaneval <- function() {
    candidate <- sum_product
    stopifnot(isTRUE(all.equal(candidate(c()), c(0, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1)), c(3, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(100, 0)), c(100, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 7)), c(15, 105))))
    stopifnot(isTRUE(all.equal(candidate(c(10)), c(10, 10))))
}
test_humaneval()"
HumanEval_9,ydd_Hebr,r,"אין דער סיקוואַנס. פון אַ געגעבן רשימה פון ינטיידזשערז, דזשענערייט אַ רשימה פון ראָולינג מאַקסימום עלעמענט געפֿונען ביז געגעבן מאָמענט # >>> rolling_max(c(1, 2, 3, 2, 3, 4, 2))
# c(1, 2, 3, 3, 3, 4, 4)
rolling_max <- function(numbers) {","rolling_max <- function(numbers) {
  max_list <- c()
  current_max <- -Inf
  for (number in numbers) {
    current_max <- max(current_max, number)
    max_list <- c(max_list, current_max)
  }
  return(max_list)
}","test_humaneval <- function() {
    candidate <- rolling_max
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))))
}
test_humaneval()"
HumanEval_10,ydd_Hebr,r,"- צוגעבן צו די סוף פון די שטריקל פאַרקערט פון אַ שטריקל פּרעפיקס וואָס קומט איידער די פּאַלינדראָמיק סופפיקס. - געפינען די לאָנגעסט פּאָסטפיקס פון סאַפּלייד שטריקל וואָס איז אַ פּאַלינדראָם. אַלגערידאַם געדאַנק איז פּשוט: געפינען די שאָרטיסט פּאַלינדראָם אַז הייבט מיט אַ סאַפּלייד שטריקל. # >>> make_palindrome('')
# ''
# >>> make_palindrome('cat')
# 'catac'
# >>> make_palindrome('cata')
# 'catac'
make_palindrome <- function(string) {","make_palindrome <- function(string) {
  is_palindrome <- function(s) {
    return(s == stringi::stri_reverse(s))
  }
  
  n <- nchar(string)
  
  for (i in seq(n, 0, by = -1)) {
    suffix <- substr(string, i, n)
    if (is_palindrome(suffix)) {
      prefix <- substr(string, 1, i - 1)
      return(paste0(string, stringi::stri_reverse(prefix)))
    }
  }
  
  return(string) # for the empty string case
}","test_humaneval <- function() {
    candidate <- make_palindrome
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('x'), 'x')))
    stopifnot(isTRUE(all.equal(candidate('xyz'), 'xyzyx')))
    stopifnot(isTRUE(all.equal(candidate('xyx'), 'xyx')))
    stopifnot(isTRUE(all.equal(candidate('jerry'), 'jerryrrej')))
}
test_humaneval()"
HumanEval_11,ydd_Hebr,r,"דורכפירן ביינערי XOR אויף די ינפּוץ און צוריקקומען רעזולטאַט אויך ווי אַ שטריקל. ינפּוט זענען צוויי סטרינגס אַ און ב קאַנסיסטינג בלויז פון 1 ס און 0 ס. # >>> string_xor('010', '110')
# '100'
string_xor <- function(a, b) {","string_xor <- function(a, b) {
  xor_result <- mapply(function(x, y) { 
    ifelse(x == y, 0, 1) 
  }, strsplit(a, NULL)[[1]], strsplit(b, NULL)[[1]])
  return(paste(xor_result, collapse = """"))
}","test_humaneval <- function() {
    candidate <- string_xor
    stopifnot(isTRUE(all.equal(candidate('111000', '101010'), '010010')))
    stopifnot(isTRUE(all.equal(candidate('1', '1'), '0')))
    stopifnot(isTRUE(all.equal(candidate('0101', '0000'), '0101')))
}
test_humaneval()"
HumanEval_12,ydd_Hebr,r,"קערט NULL אין פאַל די ינפּוט רשימה איז ליידיק. אויס פון רשימה פון סטרינגס, צוריקקומען די לאָנגעסט איינער. צוריקקומען דער ערשטער איינער אין פאַל פון קייפל # >>> longest(c())
# NULL
# >>> longest(c('a', 'b', 'c'))
# 'a'
# >>> longest(c('a', 'bb', 'ccc'))
# 'ccc'
longest <- function(strings) {","longest <- function(strings) {
  if (length(strings) == 0) return(NULL)
  longest_string <- strings[1]
  for (s in strings) {
    if (nchar(s) > nchar(longest_string)) {
      longest_string <- s
    }
  }
  return(longest_string)
}","test_humaneval <- function() {
    candidate <- longest
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'x')))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc')), 'zzzz')))
}
test_humaneval()"
HumanEval_13,ydd_Hebr,r,"צוריקקומען אַ גרעסטע פּראָסט דיוויזאָר פון צוויי ינטעדזשערז אַ און ב # >>> greatest_common_divisor(3, 5)
# 1
# >>> greatest_common_divisor(25, 15)
# 5
greatest_common_divisor <- function(a, b) {","greatest_common_divisor <- function(a, b) {
  while (b != 0) {
    temp <- b
    b <- a %% b
    a <- temp
  }
  return(abs(a))
}","test_humaneval <- function() {
    candidate <- greatest_common_divisor
    stopifnot(isTRUE(all.equal(candidate(3, 7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10, 15), 5)))
    stopifnot(isTRUE(all.equal(candidate(49, 14), 7)))
    stopifnot(isTRUE(all.equal(candidate(144, 60), 12)))
}
test_humaneval()"
HumanEval_14,ydd_Hebr,r,"צוריקקומען רשימה פון אַלע פּרעפיקסעס פון שאָרטיסט צו לאָנגעסט פון די ינפּוט שטריקל # >>> all_prefixes('abc')
# c('a', 'ab', 'abc')
all_prefixes <- function(string) {","all_prefixes <- function(string) {
  prefixes <- character(nchar(string))
  for (i in seq_along(prefixes)) {
    prefixes[i] <- substr(string, 1, i)
  }
  return(prefixes)
}","test_humaneval <- function() {
    candidate <- all_prefixes
    stopifnot(isTRUE(all.equal(candidate(''), c())))
    stopifnot(isTRUE(all.equal(candidate('asdfgh'), c('a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'))))
    stopifnot(isTRUE(all.equal(candidate('WWW'), c('W', 'WW', 'WWW'))))
}
test_humaneval()"
HumanEval_15,ydd_Hebr,r,"צוריקקומען אַ שטריקל וואָס כּולל פּלאַץ-דילימאַטעד נומערן סטאַרטינג פון 0 אַרויף צו n ינקלוסיוו. # >>> string_sequence(0)
# '0'
# >>> string_sequence(5)
# '0 1 2 3 4 5'
string_sequence <- function(n) {","string_sequence <- function(n) {
  return(paste(0:n, collapse = "" ""))
}","test_humaneval <- function() {
    candidate <- string_sequence
    stopifnot(isTRUE(all.equal(candidate(0), '0')))
    stopifnot(isTRUE(all.equal(candidate(3), '0 1 2 3')))
    stopifnot(isTRUE(all.equal(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')))
}
test_humaneval()"
HumanEval_16,ydd_Hebr,r,"געגעבן אַ שטריקל, געפינען אויס ווי פילע באַזונדער אותיות (אָפֿרויס פון פאַל) טוט עס באשטייט פון # >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4
count_distinct_characters <- function(string) {","count_distinct_characters <- function(string) {
  # Convert the string to lowercase to handle case insensitivity
  lower_string <- tolower(string)
  # Split the string into individual characters
  chars <- strsplit(lower_string, NULL)[[1]]
  # Find the unique characters and count them
  distinct_count <- length(unique(chars))
  return(distinct_count)
}","test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()"
HumanEval_17,ydd_Hebr,r,"""איי"" - קוואַרטער נאָט, לאַסץ איין קייט.""אָ""א""א""א - האַלב־נאָט, געדויערט צוויי באַטס.""אָ"" - גאנצע נאָט, געדויערט פיר באַטס.דאָ איז אַ לעגענדע: נישט לעצט.דיין אַרבעט איז צו פּאַרסירן דעם שטריקל און צוריקקומען רשימה פון ינטיידזשערז קאָראַספּאַנדינג צו ווי פילע ביץ טוט יעדער אַרייַנפיר צו דעם פונקציע איז אַ שטריקל רעפּריזענטינג מוזיקאַליש נאָטן אין אַ ספּעציעל אַסקי פֿאָרמאַט. # >>> parse_music('o o| .| o| o| .| .| .| .| o o')
# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)
parse_music <- function(music_string) {","parse_music <- function(music_string) {
  # Split the input string by spaces to get individual notes
  notes <- strsplit(music_string, "" "")[[1]]
  
  # Map each note to its corresponding beat duration
  beats <- sapply(notes, function(note) {
    if (note == 'o') {
      return(4)
    } else if (note == 'o|') {
      return(2)
    } else if (note == '.|') {
      return(1)
    } else {
      stop(""Invalid note"")
    }
  })
  
  return(beats)
}

# Example usage:
# parse_music('o o| .| o| o| .| .| .| .| o o')
# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)","test_humaneval <- function() {
    candidate <- parse_music
    stopifnot(isTRUE(all.equal(candidate(''), c())))
    stopifnot(isTRUE(all.equal(candidate('o o o o'), c(4, 4, 4, 4))))
    stopifnot(isTRUE(all.equal(candidate('.| .| .| .|'), c(1, 1, 1, 1))))
    stopifnot(isTRUE(all.equal(candidate('o| o| .| .| o o o o'), c(2, 2, 1, 1, 4, 4, 4, 4))))
    stopifnot(isTRUE(all.equal(candidate('o| .| o| .| o o| o o|'), c(2, 1, 2, 1, 4, 2, 4, 2))))
}
test_humaneval()"
HumanEval_18,ydd_Hebr,r,"געפינען ווי פילע מאל אַ געגעבן סאַבסטראַנג קענען זיין געפֿונען אין דער אָריגינעל שטריקל. ציילן אָוווערלאַפּינג פאלן. # >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
how_many_times <- function(string, substring) {","how_many_times <- function(string, substring) {
  if (nchar(substring) == 0) {
    return(0)
  }
  
  count <- 0
  for (i in seq(nchar(string) - nchar(substring) + 1)) {
    if (substr(string, i, i + nchar(substring) - 1) == substring) {
      count <- count + 1
    }
  }
  
  return(count)
}","test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()"
HumanEval_19,ydd_Hebr,r,"צוריקקומען די שטריקל מיט נומערן סאָרטיד פון קלענסטער צו גרעסטער גילטיק ברירות זענען ""נול"", ""איין"", ""צוויי"", ""דרייַ"", ""פיר"", ""פופֿט"", ""זעקס"", ""זיבן"", ""אכט"" און ""ניין"". ינפּוט איז אַ פּלאַץ-דילימאַטעד שטריקל פון נומעראַלס פון 'נול' צו 'ניין'.# >>> sort_numbers('three one five')
# 'one three five'
sort_numbers <- function(numbers) {","sort_numbers <- function(numbers) {
  words_to_numbers <- c(
    ""zero"" = 0, ""one"" = 1, ""two"" = 2, ""three"" = 3, ""four"" = 4, 
    ""five"" = 5, ""six"" = 6, ""seven"" = 7, ""eight"" = 8, ""nine"" = 9
  )
  
  number_list <- strsplit(numbers, "" "")[[1]]
  sorted_numbers <- number_list[order(sapply(number_list, function(word) words_to_numbers[word]))]
  return(paste(sorted_numbers, collapse = "" ""))
}","test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()"
HumanEval_20,ydd_Hebr,r,"אנדערע און צוריקקומען זיי אין סדר (מינסטער נומער, גרעסערע נומער).פון אַ צוגעשטעלטע רשימה פון נומערן (פון לענג בייַ מינדסטער צוויי) אויסקלייַבן און צוריקקומען צוויי וואָס זענען די קלאָוסאַסט צו יעדער # >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)
find_closest_elements <- function(numbers) {","find_closest_elements <- function(numbers) {
  sorted_numbers <- sort(numbers)
  min_diff <- Inf
  closest_pair <- c()

  for (i in 1:(length(sorted_numbers) - 1)) {
    diff <- sorted_numbers[i + 1] - sorted_numbers[i]
    if (diff < min_diff) {
      min_diff <- diff
      closest_pair <- c(sorted_numbers[i], sorted_numbers[i + 1])
    }
  }

  return(closest_pair)
}","test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()"
HumanEval_21,ydd_Hebr,r,"אַזוי אַז די קלענסטער נומער וועט ווערן 0 און די גרעסטע וועט ווערן 1 געגעבן ליסטע פון נומערן (פון כאטש צוויי עלעמענטן), לייג אן א לינעארע טראנספארמאציע צו יענע ליסטע, # >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
rescale_to_unit <- function(numbers) {","rescale_to_unit <- function(numbers) {
  min_val <- min(numbers)
  max_val <- max(numbers)
  (numbers - min_val) / (max_val - min_val)
}","test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()"
HumanEval_22,ydd_Hebr,r,"פילטער געגעבן רשימה פון קיין רטהאָן וואַלועס בלויז פֿאַר ינטיידזשערז # >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
filter_integers <- function(values) {","filter_integers <- function(values) {
  return(unlist(Filter(is.integer, values)))
}","test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()"
HumanEval_23,ydd_Hebr,r,"צוריקקומען לענג פון געגעבן שטריקל # >>> strlen('')
# 0
# >>> strlen('abc')
# 3
strlen <- function(string) {","strlen <- function(string) {
  return(nchar(string))
}","test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()"
HumanEval_24,ydd_Hebr,r,"פֿאַר אַ געגעבן נומער n, געפֿינען די גרעסטע נומער וואָס צעטיילט n גלייַך, קלענערער ווי n # >>> largest_divisor(15)
# 5
largest_divisor <- function(n) {","largest_divisor <- function(n) {
  for (i in (n-1):1) {
    if (n %% i == 0) {
      return(i)
    }
  }
}","test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()"
HumanEval_25,ydd_Hebr,r,"אַרייַנפיר נומער זאָל זיין גלייַך צו די פּראָדוקט פון אַלע פאַקטאָרס יעדער פון די סיבות זאָל זיין ליסטעד נומער פון מאל קאָראַספּאַנדינג צו ווי פילע מאל עס ערשיינט אין פאַקטאָריזאַטיאָן. צוריקקומען רשימה פון פּרייעם פאַקטאָריס פון געגעבן ינטייגער אין דער סדר פון קלענסטער צו גרעסטער. # >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
factorize <- function(n) {","factorize <- function(n) {
  if (n < 2) {
    return(c())
  }
  factors <- c()
  divisor <- 2
  
  while (n > 1) {
    while (n %% divisor == 0) {
      factors <- c(factors, divisor)
      n <- n / divisor
    }
    divisor <- divisor + 1
  }
  
  return(factors)
}","test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()"
HumanEval_26,ydd_Hebr,r,"האַלטן סדר פון עלעמענטן לינקס די זעלבע ווי אין די ינפּוט. פֿון אַ רשימה פֿון אינטעדזשערס, אַראָפּנעמען אַלע עלעמענטן וואָס קומען פֿאָר מער ווי איין מאָל.# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
remove_duplicates <- function(numbers) {","remove_duplicates <- function(numbers) {
  unique_numbers <- numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]
  return(unique_numbers)
}","test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()"
HumanEval_27,ydd_Hebr,r,"פֿאַר אַ געגעבן שטריקל, איבערדרייען קליינע אותיות צו הויך און הויך צו קליינע אותיות. # >>> flip_case('Hello')
# 'hELLO'
flip_case <- function(string) {","flip_case <- function(string) {
  chars <- strsplit(string, NULL)[[1]]
  flipped_chars <- sapply(chars, function(c) {
    if (grepl(""[a-z]"", c)) {
      return(toupper(c))
    } else if (grepl(""[A-Z]"", c)) {
      return(tolower(c))
    } else {
      return(c)
    }
  })
  return(paste(flipped_chars, collapse = """"))
}","test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()"
HumanEval_28,ydd_Hebr,r,"קאָנקאַטאַנייט ליסטע פון סטרינגס אין איין סטרינג # >>> concatenate(c())
# ''
# >>> concatenate(c('a', 'b', 'c'))
# 'abc'
concatenate <- function(strings) {","concatenate <- function(strings) {
  paste(strings, collapse = """")
}","test_humaneval <- function() {
    candidate <- concatenate
    stopifnot(isTRUE(all.equal(candidate(c()), '')))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'xyz')))
    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z', 'w', 'k')), 'xyzwk')))
}
test_humaneval()"
HumanEval_29,ydd_Hebr,r,"פילטער אַ ינפּוט רשימה פון סטרינגס בלויז פֿאַר יענע וואָס אָנהייבן מיט אַ געגעבן פּרעפיקס. # >>> filter_by_prefix(c(), 'a')
# c()
# >>> filter_by_prefix(c('abc', 'bcd', 'cde', 'array'), 'a')
# c('abc', 'array')
filter_by_prefix <- function(strings, prefix) {","filter_by_prefix <- function(strings, prefix) {
  return(strings[startsWith(strings, prefix)])
}","test_humaneval <- function() {
    candidate <- filter_by_prefix
    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))
    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))
}
test_humaneval()"
HumanEval_30,ydd_Hebr,r,"צוריקקומען בלויז positive נומערן אין דער רשימה. # >>> get_positive(c(-1, 2, -4, 5, 6))
# c(2, 5, 6)
# >>> get_positive(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))
# c(5, 3, 2, 3, 9, 123, 1)
get_positive <- function(l) {","get_positive <- function(l) {
  return(l[l > 0])
}","test_humaneval <- function() {
    candidate <- get_positive
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 4, 5, 6)), c(4, 5, 6))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)), c(5, 3, 2, 3, 3, 9, 123, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2)), c())))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
}
test_humaneval()"
HumanEval_31,ydd_Hebr,r,"צוריקקומען אמת אויב אַ געגעבן נומער איז פּריים, און פאַלש אַנדערש. # >>> is_prime(6)
# FALSE
# >>> is_prime(101)
# TRUE
# >>> is_prime(11)
# TRUE
# >>> is_prime(13441)
# TRUE
# >>> is_prime(61)
# TRUE
# >>> is_prime(4)
# FALSE
# >>> is_prime(1)
# FALSE
is_prime <- function(n) {","is_prime <- function(n) {
  if (n <= 1) {
    return(FALSE)
  }
  if (n <= 3) {
    return(TRUE)
  }
  if (n %% 2 == 0 || n %% 3 == 0) {
    return(FALSE)
  }
  i <- 5
  while (i * i <= n) {
    if (n %% i == 0 || n %% (i + 2) == 0) {
      return(FALSE)
    }
    i <- i + 6
  }
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- is_prime
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(101), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13441), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(61), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(17), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(85), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(77), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(255379), FALSE)))
}
test_humaneval()"
HumanEval_33,ydd_Hebr,r,"צו די וואַלועס פון די קאָראַספּאַנדינג ינדיסיז פון ל, אָבער סאָרטעד. l' איז אידענטיש צו l אין די אינדעקס וואָס זענען נישט דיוויידזשאַבאַל דורך דרייַ, בשעת זייַן וואַלועס אין די אינדעקס וואָס זענען דיוויידזשאַבאַל דורך דרייַ זענען גלייַך דעם פונקציע נעמט אַ רשימה ל און ריטורנס אַ רשימה ל ' אַזאַ אַז # >>> sort_third(c(1, 2, 3))
# c(1, 2, 3)
# >>> sort_third(c(5, 6, 3, 4, 8, 9, 2))
# c(2, 6, 3, 4, 8, 9, 5)
sort_third <- function(l) {","sort_third <- function(l) {
  # Find the indices that are divisible by three
  indices_div_by_3 <- seq(3, length(l), by = 3)
  
  # Extract the elements at those indices and sort them
  elements_to_sort <- l[indices_div_by_3]
  sorted_elements <- sort(elements_to_sort)
  
  # Replace the original elements at those indices with sorted ones
  l[indices_div_by_3] <- sorted_elements
  
  return(l)
}","test_humaneval <- function() {
    candidate <- sort_third
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2)), c(2, 6, 3, 4, 8, 9, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 3, 4, 6, 9, 2)), c(2, 8, 3, 4, 6, 9, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 9, 4, 8, 3, 2)), c(2, 6, 9, 4, 8, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2, 1)), c(2, 6, 3, 4, 8, 9, 5, 1))))
}
test_humaneval()"
HumanEval_34,ydd_Hebr,r,"צוריקקומען סאָרטעד יינציק עלעמענטן אין אַ רשימה# >>> unique(c(5, 3, 5, 2, 3, 3, 9, 0, 123))
# c(0, 2, 3, 5, 9, 123)
unique <- function(l) {","unique <- function(l) {
  return(sort(unique(l)))
}","test_humaneval <- function() {
    candidate <- unique
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 5, 2, 3, 3, 9, 0, 123)), c(0, 2, 3, 5, 9, 123))))
}
test_humaneval()"
HumanEval_35,ydd_Hebr,r,"צוריקקומען מאַקסימום עלעמענט אין דער רשימה. # >>> max_element(c(1, 2, 3))
# 3
# >>> max_element(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))
# 123
max_element <- function(l) {","max_element <- function(l) {
  return(max(l))
}","test_humaneval <- function() {
    candidate <- max_element
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10)), 124)))
}
test_humaneval()"
HumanEval_36,ydd_Hebr,r,"צוריקקומען די נומער פון מאל די ציפער 7 ערשיינט אין ינטעריערז ווייניקער ווי n וואָס זענען דיוויידזשאַבאַל דורך 11 אָדער 13. # >>> fizz_buzz(50)
# 0
# >>> fizz_buzz(78)
# 2
# >>> fizz_buzz(79)
# 3
fizz_buzz <- function(n) {","fizz_buzz <- function(n) {
  count <- 0
  for (i in 1:(n-1)) {
    if (i %% 11 == 0 || i %% 13 == 0) {
      count <- count + sum(unlist(strsplit(as.character(i), """")) == ""7"")
    }
  }
  return(count)
}","test_humaneval <- function() {
    candidate <- fizz_buzz
    stopifnot(isTRUE(all.equal(candidate(50), 0)))
    stopifnot(isTRUE(all.equal(candidate(78), 2)))
    stopifnot(isTRUE(all.equal(candidate(79), 3)))
    stopifnot(isTRUE(all.equal(candidate(100), 3)))
    stopifnot(isTRUE(all.equal(candidate(200), 6)))
    stopifnot(isTRUE(all.equal(candidate(4000), 192)))
    stopifnot(isTRUE(all.equal(candidate(10000), 639)))
    stopifnot(isTRUE(all.equal(candidate(100000), 8026)))
}
test_humaneval()"
HumanEval_37,ydd_Hebr,r,"צו די וואַלועס פון די פּאַרע ינדאַסיז פון ל, אָבער סאָרטעד. l' איז אידענטישע צו l אין די פּאַרע אינדעסיז, בשעת זייַן וואַלועס אין די פּאַרע אינדעסיז זענען גלייַך דעם פונקציע נעמט אַ רשימה ל און ריטורנס אַ רשימה ל ' אַזאַ אַז # >>> sort_even(c(1, 2, 3))
# c(1, 2, 3)
# >>> sort_even(c(5, 6, 3, 4))
# c(3, 6, 5, 4)
sort_even <- function(l) {","sort_even <- function(l) {
  even_indices <- seq(2, length(l), by=2)
  l[even_indices] <- sort(l[even_indices])
  return(l)
}","test_humaneval <- function() {
    candidate <- sort_even
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(1, 2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)), c(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, -12, 4, 23, 2, 3, 11, 12, -10)), c(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10))))
}
test_humaneval()"
HumanEval_39,ydd_Hebr,r,"prime_fib גיט צוריק די n-טע נומער וואס איז א פיבאנאצקי נומער און עס איז אויך פריים. # >>> prime_fib(1)
# 2
# >>> prime_fib(2)
# 3
# >>> prime_fib(3)
# 5
# >>> prime_fib(4)
# 13
# >>> prime_fib(5)
# 89
prime_fib <- function(n) {","prime_fib <- function(n) {
  is_prime <- function(num) {
    if (num < 2) return(FALSE)
    for (i in 2:sqrt(num)) {
      if (num %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  fibonacci <- function() {
    a <- 0
    b <- 1
    while (TRUE) {
      yield <- a + b
      a <<- b
      b <<- yield
      yield
    }
  }
  
  fib_gen <- fibonacci()
  count <- 0
  repeat {
    current_fib <- fib_gen()
    if (is_prime(current_fib)) {
      count <- count + 1
      if (count == n) return(current_fib)
    }
  }
}","test_humaneval <- function() {
    candidate <- prime_fib
    stopifnot(isTRUE(all.equal(candidate(1), 2)))
    stopifnot(isTRUE(all.equal(candidate(2), 3)))
    stopifnot(isTRUE(all.equal(candidate(3), 5)))
    stopifnot(isTRUE(all.equal(candidate(4), 13)))
    stopifnot(isTRUE(all.equal(candidate(5), 89)))
    stopifnot(isTRUE(all.equal(candidate(6), 233)))
    stopifnot(isTRUE(all.equal(candidate(7), 1597)))
    stopifnot(isTRUE(all.equal(candidate(8), 28657)))
    stopifnot(isTRUE(all.equal(candidate(9), 514229)))
    stopifnot(isTRUE(all.equal(candidate(10), 433494437)))
}
test_humaneval()"
HumanEval_40,ydd_Hebr,r,"סכום צו נול, און FALSE אַנדערש. עס קערט אמת אויב עס זענען דרייַ באַזונדער עלעמענטן אין דער רשימה אַז triples_sum_to_zero נעמט אַ רשימה פון ינטיידזשערז ווי אַ ינפּוט. # >>> triples_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> triples_sum_to_zero(c(1, 3, -2, 1))
# TRUE
# >>> triples_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> triples_sum_to_zero(c(2, 4, -5, 3, 9, 7))
# TRUE
# >>> triples_sum_to_zero(c(1))
# FALSE
triples_sum_to_zero <- function(l) {","triples_sum_to_zero <- function(l) {
  n <- length(l)
  if (n < 3) {
    return(FALSE)
  }
  for (i in 1:(n - 2)) {
    for (j in (i + 1):(n - 1)) {
      for (k in (j + 1):n) {
        if (l[i] + l[j] + l[k] == 0) {
          return(TRUE)
        }
      }
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- triples_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 5, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 9, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -100)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(100, 3, 5, -100)), FALSE)))
}
test_humaneval()"
HumanEval_41,ydd_Hebr,r,"דעם פונקציע אַוטפּוץ די נומער פון אַזאַ קאַלליזשאַנז. אין זייער טרייעקטאָריע ווי אויב זיי האבן ניט קאַלאַדזשאַד. אָבער, די קאַרס זענען ינפיניטלי סטראָובאַדי און שטאַרק; ווי אַ רעזולטאַט, זיי פאָרזעצן צו מאַך.ווען א קאר וואס פארט לינקס צו רעכטס טרעפט א קאר וואס פארט רעכטס צו לינקס.אַלע קאַרס מאַך אין דער זעלביקער גיכקייַט. צוויי קאַרס זענען געזאגט צו קאַליידז.די צוויי פּערז פון קאַרס אָנהייבן אויס זייַענדיק זייער ווייַט פון n קאַרס זענען דרייווינג לינקס צו רעכט; סיימאַלטייניאַסלי, אַ אַנדערש שטעלן פון n קאַרס שטעלט אייך פאר א וועג וואס איז א גאנץ גלייך אינדאנסטיטלי לאנגע ליניע.car_race_collision <- function(n) {","car_race_collision <- function(n) {
  # Each car moving left to right will eventually collide with each car moving right to left
  return(n)
}","test_humaneval <- function() {
    candidate <- car_race_collision
    stopifnot(isTRUE(all.equal(candidate(2), 4)))
    stopifnot(isTRUE(all.equal(candidate(3), 9)))
    stopifnot(isTRUE(all.equal(candidate(4), 16)))
    stopifnot(isTRUE(all.equal(candidate(8), 64)))
    stopifnot(isTRUE(all.equal(candidate(10), 100)))
}
test_humaneval()"
HumanEval_42,ydd_Hebr,r,"צוריקקער רשימה מיט עלעמענטן ינקרימענטיד דורך 1. # >>> incr_list(c(1, 2, 3))
# c(2, 3, 4)
# >>> incr_list(c(5, 3, 5, 2, 3, 3, 9, 0, 123))
# c(6, 4, 6, 3, 4, 4, 10, 1, 124)
incr_list <- function(l) {","incr_list <- function(l) {
  return(l + 1)
}","test_humaneval <- function() {
    candidate <- incr_list
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(4, 3, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 2, 5, 2, 3, 3, 9, 0, 123)), c(6, 3, 6, 3, 4, 4, 10, 1, 124))))
}
test_humaneval()"
HumanEval_43,ydd_Hebr,r,"סכום צו נול, און FALSE אַנדערש. עס קערט אמת אויב עס זענען צוויי באַזונדער עלעמענטן אין דער רשימה אַז pairs_sum_to_zero נעמט אַ רשימה פון ינטיידזשערז ווי אַ ינפּוט. # >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE
pairs_sum_to_zero <- function(l) {","pairs_sum_to_zero <- function(l) {
  n <- length(l)
  if (n < 2) return(FALSE)
  
  for (i in 1:(n-1)) {
    for (j in (i+1):n) {
      if (l[i] + l[j] == 0) {
        return(TRUE)
      }
    }
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()"
HumanEval_44,ydd_Hebr,r,"באַזע נומערן זענען ווייניקער ווי 10.צוריקקומען שטריקל רעפּראַזענץ נאָך די קאַנווערזשאַן. טוישן נומעריקאַל באַזע פון ינפּוט נומער קסנומקס צו באַזע. # >>> change_base(8, 3)
# '22'
# >>> change_base(8, 2)
# '1000'
# >>> change_base(7, 2)
# '111'
change_base <- function(x, base) {","change_base <- function(x, base) {
  if (x == 0) return('0')
  result <- ''
  while (x > 0) {
    remainder <- x %% base
    result <- paste0(remainder, result)
    x <- x %/% base
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- change_base
    stopifnot(isTRUE(all.equal(candidate(8, 3), '22')))
    stopifnot(isTRUE(all.equal(candidate(9, 3), '100')))
    stopifnot(isTRUE(all.equal(candidate(234, 2), '11101010')))
    stopifnot(isTRUE(all.equal(candidate(16, 2), '10000')))
    stopifnot(isTRUE(all.equal(candidate(8, 2), '1000')))
    stopifnot(isTRUE(all.equal(candidate(7, 2), '111')))
    stopifnot(isTRUE(all.equal(candidate(2, 3), '2')))
    stopifnot(isTRUE(all.equal(candidate(3, 4), '3')))
    stopifnot(isTRUE(all.equal(candidate(4, 5), '4')))
    stopifnot(isTRUE(all.equal(candidate(5, 6), '5')))
    stopifnot(isTRUE(all.equal(candidate(6, 7), '6')))
    stopifnot(isTRUE(all.equal(candidate(7, 8), '7')))
}
test_humaneval()"
HumanEval_45,ydd_Hebr,r,"געגעבן לענג פון אַ זייַט און הויך צוריקקומען געגנט פֿאַר אַ דרייַעק. # >>> triangle_area(5, 3)
# 7.5
triangle_area <- function(a, h) {","triangle_area <- function(a, h) {
  return(0.5 * a * h)
}","test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(5, 3), 7.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 2), 2.0)))
    stopifnot(isTRUE(all.equal(candidate(10, 8), 40.0)))
}
test_humaneval()"
HumanEval_46,ydd_Hebr,r,"ביטע שרײַבן אַ פֿונקציע צו רעכענען די נ-טע עלעמענט פֿון דער fib4 נומערן־שריפט. ניצט נישט רעקורסיע. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 די פיבאָנאַקסי צאָלן סיקוואַנס איז אַ סיקוואַנס ענלעך צו די פיבאָנאַקסי סיקוואַנס וואָס איז דעפינירט ווי גייט:# >>> fib4(5)
# 4
# >>> fib4(6)
# 8
# >>> fib4(7)
# 14
fib4 <- function(n) {","fib4 <- function(n) {
  if (n == 0) return(0)
  if (n == 1) return(0)
  if (n == 2) return(2)
  if (n == 3) return(0)
  
  fib_seq <- c(0, 0, 2, 0) # Initialize with base cases
  for (i in 4:n) {
    fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2] + fib_seq[i-3] + fib_seq[i-4]
  }
  return(fib_seq[n])
}","test_humaneval <- function() {
    candidate <- fib4
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 28)))
    stopifnot(isTRUE(all.equal(candidate(10), 104)))
    stopifnot(isTRUE(all.equal(candidate(12), 386)))
}
test_humaneval()"
HumanEval_47,ydd_Hebr,r,"צוריקקומען מעדיאַן פון עלעמענטן אין דער רשימה l. # >>> median(c(3, 1, 2, 4, 5))
# 3
# >>> median(c(-10, 4, 6, 1000, 10, 20))
# 15.0
median <- function(l) {","median <- function(l) {
  return(median(l))
}","test_humaneval <- function() {
    candidate <- median
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(-10, 4, 6, 1000, 10, 20)), 8.0)))
    stopifnot(isTRUE(all.equal(candidate(c(5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 5)), 5.5)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 1, 3, 9, 9, 2, 7)), 7)))
}
test_humaneval()"
HumanEval_48,ydd_Hebr,r,"קאָנטראָלירט אויב געגעבן שטריקל איז אַ פּאַלינדראָם # >>> is_palindrome('')
# TRUE
# >>> is_palindrome('aba')
# TRUE
# >>> is_palindrome('aaaaa')
# TRUE
# >>> is_palindrome('zbcd')
# FALSE
is_palindrome <- function(text) {","is_palindrome <- function(text) {
  return(text == paste(rev(unlist(strsplit(text, NULL))), collapse = """"))
}","test_humaneval <- function() {
    candidate <- is_palindrome
    stopifnot(isTRUE(all.equal(candidate(''), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aba'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aaaaa'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('zbcd'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('xywyx'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xywyz'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('xywzx'), FALSE)))
}
test_humaneval()"
HumanEval_49,ydd_Hebr,r,"צוריקקומען 2^n מאָדולאָ פּ (זאָל זיין אַווער פון נומעריקס).# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
modp <- function(n, p) {","modp <- function(n, p) {
  result <- 1
  base <- 2
  
  while (n > 0) {
    if (n %% 2 == 1) {
      result <- (result * base) %% p
    }
    base <- (base * base) %% p
    n <- n %/% 2
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()"
HumanEval_51,ydd_Hebr,r,"remove_vowels איז אַ פונקציע וואָס נעמט שטריקל און ריטורנס שטריקל אָן וואָקאַלז. # >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
remove_vowels <- function(text) {","remove_vowels <- function(text) {
  gsub(""[aeiouAEIOU]"", """", text)
}","test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()"
HumanEval_52,ydd_Hebr,r,"צוריקקומען אמת אויב אַלע נומערן אין דער רשימה ל זענען אונטער שיעור ט. # >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
below_threshold <- function(l, t) {","below_threshold <- function(l, t) {
  return(all(l < t))
}","test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()"
HumanEval_53,ydd_Hebr,r,"לייג צו צוויי נומערן x און y.# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
add <- function(x, y) {","add <- function(x, y) {
  return(x + y)
}","test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()"
HumanEval_54,ydd_Hebr,r,"קאָנטראָלירן אויב צוויי ווערטער האָבן די זעלבע אותיות. # >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
same_chars <- function(s0, s1) {","same_chars <- function(s0, s1) {
  return(identical(sort(unique(unlist(strsplit(s0, """")))), sort(unique(unlist(strsplit(s1, """"))))))
}","test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()"
HumanEval_55,ydd_Hebr,r,"צוריקקומען n-טע פיבאָנאַצקי נומער. # >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
fib <- function(n) {","fib <- function(n) {
  if (n <= 1) {
    return(n)
  }
  a <- 0
  b <- 1
  for (i in 2:n) {
    temp <- b
    b <- a + b
    a <- temp
  }
  return(b)
}","test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()"
HumanEval_56,ydd_Hebr,r,"צוריקקומען אמת אויב יעדער עפן בראַקאַץ האט אַ קאָראַספּאַנדינג קלאָוזינג בראַקאַץ. קראַקיץ איז אַ שטריקל פון ""<"" און "">"". # >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE
correct_bracketing <- function(brackets) {","correct_bracketing <- function(brackets) {
  count <- 0
  for (char in strsplit(brackets, NULL)[[1]]) {
    if (char == ""<"") {
      count <- count + 1
    } else if (char == "">"") {
      count <- count - 1
    }
    if (count < 0) {
      return(FALSE)
    }
  }
  return(count == 0)
}","test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()"
HumanEval_57,ydd_Hebr,r,"צוריקקומען אמת איז רשימה עלעמענטן זענען מאָנאָטאָניקלי ינקריסינג אָדער דיקריסינג. # >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
monotonic <- function(l) {","monotonic <- function(l) {
  is_increasing <- all(diff(l) >= 0)
  is_decreasing <- all(diff(l) <= 0)
  return(is_increasing || is_decreasing)
}","test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()"
HumanEval_58,ydd_Hebr,r,"צוריקקומען סאָרטעד יינציק פּראָסט עלעמענטן פֿאַר צוויי רשימות. # >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
common <- function(l1, l2) {","common <- function(l1, l2) {
  common_elements <- intersect(l1, l2)
  sorted_unique_common <- sort(unique(common_elements))
  return(sorted_unique_common)
}","test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()"
HumanEval_59,ydd_Hebr,r,"צוריקקומען די גרעסטע פריים פאַקטאָר פון n. נעמט n > 1 און איז נישט אַ פריים. # >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
largest_prime_factor <- function(n) {","largest_prime_factor <- function(n) {
  # Initialize the largest prime factor
  largest_prime <- -1
  
  # Remove factors of 2
  while (n %% 2 == 0) {
    largest_prime <- 2
    n <- n / 2
  }
  
  # Try odd factors from 3 upwards
  factor <- 3
  while (factor * factor <= n) {
    while (n %% factor == 0) {
      largest_prime <- factor
      n <- n / factor
    }
    factor <- factor + 2
  }
  
  # If n is a prime number greater than 2
  if (n > 2) {
    largest_prime <- n
  }
  
  # Return the largest prime factor found
  return(largest_prime)
}","test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()"
HumanEval_60,ydd_Hebr,r,"סומע_צו_נ איז א פונקציע וואס סומע צאלן נומערן פון 1 ביז נ. # >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
sum_to_n <- function(n) {","sum_to_n <- function(n) {
  return(sum(1:n))
}","test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()"
HumanEval_61,ydd_Hebr,r,"צוריקקומען אמת אויב יעדער עפן בראַקאַץ האט אַ קאָראַספּאַנדינג קלאָוזינג בראַקאַץ. קראַקיץ איז אַ שטריקל פון ""("" און "")"". # >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE
correct_bracketing <- function(brackets) {","correct_bracketing <- function(brackets) {
  balance <- 0
  for (char in strsplit(brackets, NULL)[[1]]) {
    if (char == ""("") {
      balance <- balance + 1
    } else if (char == "")"") {
      balance <- balance - 1
    }
    if (balance < 0) {
      return(FALSE)
    }
  }
  return(balance == 0)
}","test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()"
HumanEval_62,ydd_Hebr,r,"צוריקקומען דעריוויוואַט פון דעם פּאַלינאָמיאַל אין דער זעלביקער פאָרעם. קס [0] + קס [1] * קס + קס [2] * קס ^ 2 + .... xs רעפּריזענץ קאָעפֿיציענטן פֿון אַ פּאַלינאָמיאַל.# >>> derivative(c(3, 1, 2, 4, 5))
# c(1, 4, 12, 20)
# >>> derivative(c(1, 2, 3))
# c(2, 6)
derivative <- function(xs) {","derivative <- function(xs) {
  n <- length(xs)
  if (n <= 1) return(numeric(0))  # Derivative of a constant is zero
  
  deriv <- numeric(n - 1)
  for (i in 2:n) {
    deriv[i - 1] <- xs[i] * (i - 1)
  }
  return(deriv)
}","test_humaneval <- function() {
    candidate <- derivative
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), c(1, 4, 12, 20))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 6))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1, 0, 4)), c(2, 2, 0, 16))))
    stopifnot(isTRUE(all.equal(candidate(c(1)), c())))
}
test_humaneval()"
HumanEval_63,ydd_Hebr,r,"ביטע שרייבן א פונקציע צו עפעקטיוו רעכענען די n-טע עלעמענט פון די fibfib נומער סיקווענסע. פאַביבאַינ) == פאַביבאַינ-1) + פאַביבאַינ-2) + פאַביבאַינ-3).פאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַפאַדי פיבפיב נומערן סיקווענץ איז א סיקווענץ ענליך צו די פיבבאנאקי סיקווענץ וואס איז דעפינירט ווי פאלגענד:# >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24
fibfib <- function(n) {","fibfib <- function(n) {
  # Base cases
  if (n == 0) return(0)
  if (n == 1) return(0)
  if (n == 2) return(1)

  # Initialize the first three values
  fibfib_values <- c(0, 0, 1)
  
  # Compute fibfib for the rest using iteration
  for (i in 3:n) {
    fibfib_values[i + 1] <- fibfib_values[i] + fibfib_values[i - 1] + fibfib_values[i - 2]
  }
  # Return the nth value
  return(fibfib_values[n + 1])
}","test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()"
HumanEval_64,ydd_Hebr,r,"בייַשפּיל: אַ וואַקל, אָבער נאָר ווען עס איז אין די סוף פון דעם געגעבן וואָרט.וואָקאַלס אין דעם פאַל זענען ""אַ"", ""ע"", ""י"", ""אָ"", ""ו"". דאָ, ""י"" איז אויך אַ אַ וואָרט ווי ינפּוט און קערט די נומער פון וואָקאַלס אין די שטריקל. שרײַבן אַ פֿונקציע וואָקאַלס_קאַונט וואָס נעמט אַ שטריקל וואָס רעפּריזענץ # >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
vowels_count <- function(s) {","vowels_count <- function(s) {
  s <- tolower(s)
  n <- nchar(s)
  count <- sum(unlist(strsplit(s, NULL)) %in% c('a', 'e', 'i', 'o', 'u'))
  if (n > 0 && substr(s, n, n) == 'y') {
    count <- count + 1
  }
  return(count)
}","test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()"
HumanEval_65,ydd_Hebr,r,"אויב שיף > נומער פון דידזשיץ, צוריקקומען דידזשיץ ריווערסט. און צוריקקומען די רעזולטאַט ווי אַ שטריקל. סירקאַלער באַוועגן די דידזשאַטעס פון די ינטיידזשער קס, באַוועגן די דידזשאַטעס רעכט דורך באַוועגן # >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
circular_shift <- function(x, shift) {","circular_shift <- function(x, shift) {
  digits <- as.character(x)
  n <- nchar(digits)
  
  if (shift > n) {
    return(paste0(rev(unlist(strsplit(digits, """"))), collapse = """"))
  }
  
  shift <- shift %% n
  if (shift == 0) {
    return(digits)
  }
  
  right_part <- substr(digits, n - shift + 1, n)
  left_part <- substr(digits, 1, n - shift)
  result <- paste0(right_part, left_part)
  
  return(result)
}","test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()"
HumanEval_66,ydd_Hebr,r,"ביישפילן: אַסקי קאָודז. שרייַבן אַ פונקציע אַז נעמט אַ שטריקל ווי ינפּוט און ריטורנס די סומע פון די אויבערשטער אותיות בלויז' אַרבעט # >>> digitSum('')
# 0
# >>> digitSum('abAB')
# 131
# >>> digitSum('abcCd')
# 67
# >>> digitSum('helloE')
# 69
# >>> digitSum('woArBld')
# 131
# >>> digitSum('aAaaaXa')
# 153
digitSum <- function(s) {","digitSum <- function(s) {
  sum(sapply(unlist(strsplit(s, """")), function(x) {
    if (grepl(""[A-Z]"", x)) {
      return(as.integer(charToRaw(x)))
    } else {
      return(0)
    }
  }))
}","test_humaneval <- function() {
    candidate <- digitSum
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abAB'), 131)))
    stopifnot(isTRUE(all.equal(candidate('abcCd'), 67)))
    stopifnot(isTRUE(all.equal(candidate('helloE'), 69)))
    stopifnot(isTRUE(all.equal(candidate('woArBld'), 131)))
    stopifnot(isTRUE(all.equal(candidate('aAaaaXa'), 153)))
    stopifnot(isTRUE(all.equal(candidate(' How are yOu?'), 151)))
    stopifnot(isTRUE(all.equal(candidate('You arE Very Smart'), 327)))
}
test_humaneval()"
HumanEval_67,ydd_Hebr,r,"פֿאַר עקסאַמבלע: אין די קאָרב צוריקקומען די נומער פון די מאַנגאָ פירות אין די קאָרב. די אָראַנדזשאַז און apples און אַ גאַנץ נומער וואָס רעפּראַזענץ די גאַנץ נומער פון די פירות אפל, מאַראַנץ, און מאַנגאָ פירות. געגעבן די שטריקל וואָס רעפּראַזענץ די גאַנץ נומער פון וואָס זענען פונאנדערגעטיילט אין אַ קאָרב פון פרוכט דעם קאָרב כּולל אין דעם אויפֿפֿירונג, וועט מען דיר געבן אַ שטריקל וואָס רעפּריזענץ אַ נומער פון עפּל און מאַראַנץ.# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19
fruit_distribution <- function(s, n) {","fruit_distribution <- function(s, n) {
  # Extract numbers using regular expressions
  matches <- regmatches(s, gregexpr(""\\d+"", s))
  # Convert extracted number strings to integers
  fruits_count <- as.integer(unlist(matches))
  # Total fruits described in the string
  total_apples_oranges <- sum(fruits_count)
  # Calculate mangoes
  mangoes <- n - total_apples_oranges
  return(mangoes)
}","test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()"
HumanEval_68,ydd_Hebr,r,"בייַשפּיל 1: אויב עס זענען נישט קיין פּער וואַלועס אָדער די געגעבן וועקטאָר איז ליידיק, צוריקקומען []. די פּליקט נאָדע זאָל זיין אומגעקערט אין אַ רשימה, [סמאַלעסט_וואַלוע, זייַן אינדעקס ], אויב קייפל נאָודז מיט די זעלבע קלענסטער אפילו ווערט זענען געפֿונען צוריקקומען די נאָדע וואָס האט קלענסטער אינדעקס. דער געפּלעקטער נאָדע זאָל זיין דער נאָדע מיט דעם קלענסטער פּאַרע ווערט.איר אַרבעט איז צו צונויפנעמען איינער פון די נאָודז און צוריקקומען עס. ""געגעבען א וועקטאר וואס רעפרעזענטירט א צווייג פון א בוים וואס האט נישט-נעגאטיווע אינטעדזשער נאדוס # >>> pluck(c(4, 2, 3))
# c(2, 1)
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck(c(1, 2, 3))
# c(2, 1)
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck(c())
# c()
# Example 4:
# >>> pluck(c(5, 0, 3, 0, 4, 2))
# c(0, 1)
# Explanation: 0 is the smallest value, but  there are two zeros,
#              so we will choose the first zero, which has the smallest index.
# Constraints:
#     * 1 <= nodes.length <= 10000
#     * 0 <= node.value
pluck <- function(arr) {","pluck <- function(arr) {
  # Find indices for even numbers in the array
  even_indices <- which(arr %% 2 == 0)
  
  # If no even numbers are found, return an empty list
  if (length(even_indices) == 0) {
    return(c())
  }
  
  # Extract even numbers
  even_values <- arr[even_indices]
  
  # Find the smallest even value
  min_even_value <- min(even_values)
  
  # Find the index of the first occurrence of the smallest even value
  min_index <- even_indices[which.min(even_values)]
  
  # Return the smallest even value and its index (0-based index)
  return(c(min_even_value, min_index - 1))
}","test_humaneval <- function() {
    candidate <- pluck
    stopifnot(isTRUE(all.equal(candidate(c(4, 2, 3)), c(2, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 1))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 0, 3, 0, 4, 2)), c(0, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 0, 5, 3)), c(0, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 8, 4, 8)), c(4, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(7, 6, 7, 1)), c(6, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 7, 1)), c())))
}
test_humaneval()"
HumanEval_69,ydd_Hebr,r,"ביישפילן: אויב קיין אַזאַ ווערט עקסיסטירט, צוריקקומען -1. די אָפטקייַט פון אַ ינטייגער איז די נומער פון מאל עס ערשיינט אין דער רשימה. נול, און האט אַ אָפטקייַט גרעסער ווי אָדער גלייַך צו די ווערט פון די ינטיידזשער זיך. מען גיט דיר א נישט ליידיגע ליסטע פון פאזיטיווע אינטעדזשערס. צוריקקומען די גרעסטע אינטעדזשער וואס איז גרעסער ווי # >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1
search <- function(lst) {","search <- function(lst) {
  # Calculate the frequency table
  freq_table <- table(lst)
  
  # Convert to a data frame for easier processing
  freq_df <- as.data.frame(freq_table)
  
  # Rename columns for convenience
  names(freq_df) <- c(""value"", ""frequency"")
  
  # Filter the values where the frequency is greater than or equal to the value itself
  valid_values <- freq_df[freq_df$value <= freq_df$frequency, ""value""]
  
  # If no valid values exist, return -1
  if (length(valid_values) == 0) {
    return(-1)
  }
  
  # Otherwise, return the greatest valid value
  return(max(valid_values))
}","test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()"
HumanEval_70,ydd_Hebr,r,"ביישפילן: דערנאך די מערסטע פון די איבעריגע אינטעדזשערס, דערנאך די מינימום, און אזוי ווייטער.מאָדנע סאָרטינג, איז ווען איר אָנהייבן מיט די מינימום ווערט, געגעבן ליסטע פון אינטעדזשערס, צוריקקומען ליסטע אין אומזיסטע סדר.# >>> strange_sort_list(c(1, 2, 3, 4))
# c(1, 4, 2, 3)
# >>> strange_sort_list(c(5, 5, 5, 5))
# c(5, 5, 5, 5)
# >>> strange_sort_list(c())
# c()
strange_sort_list <- function(lst) {","strange_sort_list <- function(lst) {
  result <- c()
  while (length(lst) > 0) {
    # Find and append the minimum of the list
    min_val <- min(lst)
    result <- c(result, min_val)
    lst <- lst[lst != min_val]
    
    # Check if list is not empty before finding maximum
    if (length(lst) > 0) {
      # Find and append the maximum of the list
      max_val <- max(lst)
      result <- c(result, max_val)
      lst <- lst[lst != max_val]
    }
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- strange_sort_list
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 4, 2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9)), c(5, 9, 6, 8, 7))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), c(1, 5, 2, 4, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9, 1)), c(1, 9, 5, 8, 6, 7))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5)), c(5, 5, 5, 5))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8)), c(1, 8, 2, 7, 3, 6, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(0, 2, 2, 2, 5, 5, -5, -5)), c(-5, 5, -5, 5, 0, 2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(111111)), c(111111))))
}
test_humaneval()"
HumanEval_71,ydd_Hebr,r,"בייַשפּיל: ווי די דריט זייַט. דרײַ זײַטן מאַכן אַ גילטיקן דרײַקונגל ווען די סכום פֿון צוויי זײַטן איז גרעסער.אַנדערש צוריקקומען -1 די טריאַנגלע ראָונדאַד צו 2 דעצימאַל פונקטן אויב די דרייַ זייטן פאָרעם אַ גילטיק טריאַנגלע. געגעבען די לענג פון די דריי זייטן פון א דרייקעלע, צוריקקומען די שטח פון # >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1
triangle_area <- function(a, b, c) {","triangle_area <- function(a, b, c) {
  if (a + b > c && a + c > b && b + c > a) {
    # Using Heron's formula
    s <- (a + b + c) / 2
    area <- sqrt(s * (s - a) * (s - b) * (s - c))
    return(round(area, 2))
  } else {
    return(-1)
  }
}","test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()"
HumanEval_72,ydd_Hebr,r,"בייַשפּיל: דער כייפעץ q וועט פליען אויב ער איז באלאנסירט (עס איז א פאלינדראמישע ליסטע) און די סכום פון זיינע עלעמענטן איז ווייניגער ווי אדער גלייך צו די מאקסימום מעגליכע וואג w.שרײַבן אַ פֿונקציע וואָס גיט צוריק TRUE אויב דער אָבדזשעקט q וועט פליען, און FALSE אַנדערש. # >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.
will_it_fly <- function(q, w) {","will_it_fly <- function(q, w) {
  is_palindromic <- function(lst) {
    return(all(lst == rev(lst)))
  }
  
  is_balanced <- is_palindromic(q)
  sum_elements <- sum(q)
  
  return(is_balanced && (sum_elements <= w))
}","test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()"
HumanEval_73,ydd_Hebr,r,"למשל: איז לייענען די זעלבע צוריק און פאָרויס. אין איין ענדערונג, איר קענען טוישן איין עלעמענט צו קיין אנדערע עלעמענט. מען דארף עס טוישן צו מאכן דעם וועקטאר פאלינדראמיש. א פאלינדראמישער וועקטאר איז א וועקטאר וואסגעגעבן אַ וועקטאָר arr פון ינטיידזשערז, געפינען די מינימום נומער פון עלעמענטן אַז # >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
smallest_change <- function(arr) {","smallest_change <- function(arr) {
  n <- length(arr)
  changes <- 0
  
  for (i in 1:(n %/% 2)) {
    if (arr[i] != arr[n - i + 1]) {
      changes <- changes + 1
    }
  }
  
  return(changes)
}","test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()"
HumanEval_74,ydd_Hebr,r,"ביישפילן אויב די צוויי ליסטעס האָבן די זעלבע נומער פון טשאַרז, צוריקקומען די ערשטער רשימה. גאַנץ נומער פון טשאַרז אין די אַלע סטרינגס פון די רשימה ווייניקער ווי די אנדערע רשימה. שרײַבן אַ פֿונקציע וואָס אַקסעפּט צוויי ליסטעס פון סטרינגס און ריטורנס די ליסט וואָס האט # >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
total_match <- function(lst1, lst2) {","total_match <- function(lst1, lst2) {
  chars_count <- function(lst) {
    sum(nchar(lst))
  }
  
  count1 <- chars_count(lst1)
  count2 <- chars_count(lst2)
  
  if (count1 < count2) {
    return(lst1)
  } else if (count1 > count2) {
    return(lst2)
  } else {
    return(lst1)
  }
}","test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()"
HumanEval_75,ydd_Hebr,r,"בייַשפּיל: וויסנדיג אז (א) איז ווייניגער ווי 100.און פאַלש אַנדערש. שרײַבן אַ פֿונקציע וואָס גיט צוריק אמת אויב די געגעבן נומער איז די מאַלטאַפּליקאַציע פון 3 פּריים נומערן # >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
is_multiply_prime <- function(a) {","is_multiply_prime <- function(a) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n <= 3) return(TRUE)
    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)
    i <- 5
    while (i * i <= n) {
      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)
      i <- i + 6
    }
    return(TRUE)
  }

  if (a >= 100) return(FALSE)
  
  primes <- c()
  for (i in 2:a) {
    if (is_prime(i)) {
      primes <- c(primes, i)
    }
  }
  
  for (i in 1:length(primes)) {
    for (j in i:length(primes)) {
      for (k in j:length(primes)) {
        if (primes[i] * primes[j] * primes[k] == a) {
          return(TRUE)
        }
      }
    }
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()"
HumanEval_76,ydd_Hebr,r,"למשל: x איז אַ פּשוט מאַכט פון n אויב n**int=x מאַכט פון n און פאַלש אין אנדערע קאַסעס. דיין אַרבעט איז צו שרייַבן אַ פונקציע אַז ריטורנס אמת אויב אַ נומער קס איז אַ פּשוט # >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE
is_simple_power <- function(x, n) {","is_simple_power <- function(x, n) {
  if (x == 1) return(TRUE)
  power <- 1
  while (power < x) {
    power <- power * n
    if (power == x) return(TRUE)
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()"
HumanEval_77,ydd_Hebr,r,"ביישפילן: באַמערקונג: איר קענט פאַרנעמען אַז די אַרייַנפיר איז שטענדיק גילטיק. אויב דעם ינגגער איז אַ קוב פון עטלעכע ינטיידזשער נומער.שרײַבן אַ פֿונקציע וואָס נעמט אַן אינטעגער a און גיט צוריק TRUE # >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE
iscube <- function(a) {","iscube <- function(a) {
  if (a == 0) return(TRUE)
  root <- round(abs(a)^(1/3))
  return(root^3 == abs(a))
}","test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()"
HumanEval_78,ydd_Hebr,r,"ביישפילן: און סימבאָלס אַ, ב, C, D, E, F זענען שטענדיק אַפּפּערקאַסער. באַמערקונג: איר קענען יבערנעמען די ינפּוט איז שטענדיק ריכטיק אָדער ליידיק שטריקל, B (= דעצימאַל 11), D (= דעצימאַל 13). איר מוזט אויסקלייַבן אַ נומער פֿון די פאלגענדע ציפֿערן: 2, 3, 5, 7, פּרײַמע נומערן זענען 2, 3, 5, 7, 11, 13, 17,...העקסאַדעסימאַל דידזשיץ זענען 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, אַ, ב, C, D, E, F. גרעסער ווי 1 וואָס איז נישט אַ פּראָדוקט פון צוויי קלענערער נאַטירלעך נומערן).דידזשיטס וואָס זענען פּריימס (פּרימע נומער, אָדער אַ פּריימע, איז אַ נאַטירלעך נומער אַ כעקסאַדעסימאַל נומער ווי אַ שטריקל און קאַונץ די נומער פון כעקסאַדעסימאַל איר האָט שוין טאַסקט צו שרייַבן אַ פונקציע וואָס ריסיווז # >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2
hex_key <- function(num) {","hex_key <- function(num) {
  # Define the set of prime hexadecimal digits
  prime_hex_digits <- c('2', '3', '5', '7', 'B', 'D')
  
  # Initialize a counter
  count <- 0
  
  # Convert the input string to a list of characters
  chars <- strsplit(num, NULL)[[1]]
  
  # Loop over each character in the list
  for (char in chars) {
    # Check if the character is in the list of prime hexadecimal digits
    if (char %in% prime_hex_digits) {
      # Increment the count
      count <- count + 1
    }
  }
  
  # Return the count
  return(count)
}","test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()"
HumanEval_79,ydd_Hebr,r,"ביישפילן: די עקסטרע אותיות זענען דאָרט צו העלפן מיט די פֿאָרמאַט. עס וועט זיין אַן עקסטרע פּאָר פון אותיות 'דב' אין די אָנהייב און אין די סוף פון די שטריקל. יעדער כאַראַקטער אין די שטריקל וועט זיין '0' אָדער '1'.בינארישע פֿאָרמאַט. די פונקציע זאָל צוריקקומען אַ שטריקל, מיט יעדער כאַראַקטער רעפּריזענטינג אַ בינארישע איר וועט באַקומען אַ נומער אין דעצימאַל פאָרעם און דיין אַרבעט איז צו קאָנווערט עס צו # >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'
decimal_to_binary <- function(decimal) {","decimal_to_binary <- function(decimal) {
  binary_string <- as.character(intToBits(decimal))
  binary_clean <- paste0(rev(binary_string), collapse = """")
  binary_trimmed <- sub(""^0+"", """", binary_clean)
  return(paste0(""db"", binary_trimmed, ""db""))
}","test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()"
HumanEval_80,ydd_Hebr,r,"למשל: א שטריקל איז כאַפּר אויב זייַן לענג איז לפּחות 3 און יעדער 3 קאָנסעקוטיווע אותיות זענען באַזונדער דיין אַרבעט איז צו קאָנטראָלירן אויב די שטריקל איז כאַפּר אָדער ניט. איר זענט געגעבן אַ שטריקל ס. # >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE
is_happy <- function(s) {","is_happy <- function(s) {
  n <- nchar(s)
  if (n < 3) {
    return(FALSE)
  }
  for (i in 1:(n - 2)) {
    if (length(unique(substring(s, i, i + 2))) != 3) {
      return(FALSE)
    }
  }
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()"
HumanEval_81,ydd_Hebr,r,"בייַשפּיל: 0.0 E > 0.0 ד- > 0.7 ד > 1.0 ד + > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 ב- > 2.7 B > 3.0 ב + > 3.3 א- > 3.7 אַ 4.0 א + די דורכשניטלעך. די בריוו-מדרגה.אַ פונקציע וואָס קענען אַרויסגעבן אַ רשימה פון בריוו גראַדעס ניצן די פאלגענדע טיש: זי האָט דיר געגעבן אַ רשימה פֿון די GPA פֿון עטלעכע סטודענטן און דו מוזט שרײַבן.דער בלויז פּראָבלעם איז, זי האָט פֿאַרלוירן דעם קאָד וואָס זי האָט גענוצט פֿאַרן אָפּשאַצן.דער לערער האָט געשאַפֿן אַן אַלגערידאַם פֿאַרן באַצייכענען.עס איז די לעצטע וואָך פֿון דעם סעמיסטער און דער לערער דאַרף געבן די גראַדעס.# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')
numerical_letter_grade <- function(grades) {","numerical_letter_grade <- function(grades) {
  letter_grades <- sapply(grades, function(gpa) {
    if (gpa == 4.0) {
      ""A+""
    } else if (gpa > 3.7) {
      ""A""
    } else if (gpa > 3.3) {
      ""A-""
    } else if (gpa > 3.0) {
      ""B+""
    } else if (gpa > 2.7) {
      ""B""
    } else if (gpa > 2.3) {
      ""B-""
    } else if (gpa > 2.0) {
      ""C+""
    } else if (gpa > 1.7) {
      ""C""
    } else if (gpa > 1.3) {
      ""C-""
    } else if (gpa > 1.0) {
      ""D+""
    } else if (gpa > 0.7) {
      ""D""
    } else if (gpa > 0.0) {
      ""D-""
    } else {
      ""E""
    }
  })
  return(letter_grades)
}","test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()"
HumanEval_82,ydd_Hebr,r,"ביישפילן לענג איז אַ פּיריאַם נומער אָדער פאַלש אַנדערש שרײַבן אַ פֿונקציע וואָס נעמט אַ שטריקל און גיט צוריק TRUE אויב דער שטריקל # >>> prime_length('Hello')
# TRUE
# >>> prime_length('abcdcba')
# TRUE
# >>> prime_length('kittens')
# TRUE
# >>> prime_length('orange')
# FALSE
prime_length <- function(string) {","prime_length <- function(string) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n <= 3) return(TRUE)
    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)
    
    i <- 5
    while (i * i <= n) {
      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)
      i <- i + 6
    }
    
    return(TRUE)
  }
  
  string_length <- nchar(string)
  return(is_prime(string_length))
}","test_humaneval <- function() {
    candidate <- prime_length
    stopifnot(isTRUE(all.equal(candidate('Hello'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcdcba'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('kittens'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('orange'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('wow'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('world'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('MadaM'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Wow'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('HI'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('go'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('gogo'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aaaaaaaaaaaaaaa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Madam'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('M'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('0'), FALSE)))
}
test_humaneval()"
HumanEval_83,ydd_Hebr,r,"פאזיטיווע אינטעדזשערס וואס הייבן זיך אן אדער ענדיגן זיך מיט 1.געגעבן אַ positive גאַנץ נומער n, צוריקקומען די ציילן פון די נומערן פון n-ציפֿער starts_one_ends <- function(n) {","starts_one_ends <- function(n) {
  if (n == 1) {
    return(1)
  } else {
    return(9 * (10^(n-2)) * 2)
  }
}","test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()"
HumanEval_84,ydd_Hebr,r,"ביישפּיל געגעבן אַ positive גאַנץ נומער N, צוריקקומען די גאַנץ סומע פון זייַן דידזשיץ אין ביינערי. # >>> solve(1000)
# '1'
# >>> solve(150)
# '110'
# >>> solve(147)
# '1100'
# Variables:
#     @N integer
#          Constraints: 0 ≤ N ≤ 10000.
# Output:
#      a string of binary number
solve <- function(N) {","solve <- function(N) {
  # Sum the digits of the number
  digit_sum <- sum(as.numeric(unlist(strsplit(as.character(N), """"))))
  # Convert the sum to binary and return as a string
  return(as.character(as.binary(digit_sum)))
}

# Helper function to convert number to binary
as.binary <- function(number) {
  if (number == 0) return(""0"")
  binary <- """"
  while (number > 0) {
    binary <- paste0(number %% 2, binary)
    number <- number %/% 2
  }
  return(binary)
}","test_humaneval <- function() {
    candidate <- solve
    stopifnot(isTRUE(all.equal(candidate(1000), '1')))
    stopifnot(isTRUE(all.equal(candidate(150), '110')))
    stopifnot(isTRUE(all.equal(candidate(147), '1100')))
    stopifnot(isTRUE(all.equal(candidate(333), '1001')))
    stopifnot(isTRUE(all.equal(candidate(963), '10010')))
}
test_humaneval()"
HumanEval_85,ydd_Hebr,r,"ביישפילן: געגעבן אַ ניט-רוקן רשימה פון ינטיידזשערז, לייג די פּאַרע עלעמענטן וואָס זענען אין מאָדנע אינדעקס ..# >>> add(c(4, 2, 6, 7))
# 2
add <- function(lst) {","add <- function(lst) {
  # Select elements at odd indices (which are even positions)
  elements_at_odd_indices <- lst[seq(2, length(lst), by=2)]
  # Keep only the even elements
  even_elements <- elements_at_odd_indices[elements_at_odd_indices %% 2 == 0]
  # Sum the even elements
  sum(even_elements)
}","test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()"
HumanEval_86,ydd_Hebr,r,"למשל: באַמערקונג: איר זאָל האַלטן די סדר פון ווערטער און ליידיק ספּייסאַז אין דעם זאַץ. אַקסיע באַשטעטיקן. זענען ריפּלייסט דורך אַ נייַ וואָרט ווו אַלע די אותיות עריינדזשד אין אָרדערד ווערסיע פון שטריקל, איז אַ שטריקל ווו אַלע ווערטער (ספּעאַראַטעד דורך פּלאַץ) שרײַבן אַ פֿונקציע וואָס נעמט אַ שטריקל און גיט צוריק אַ אָרדערד ווערסיע פֿון אים.# >>> anti_shuffle('Hi')
# 'Hi'
# >>> anti_shuffle('hello')
# 'ehllo'
# >>> anti_shuffle('Hello World!!!')
# 'Hello !!!Wdlor'
anti_shuffle <- function(s) {","anti_shuffle <- function(s) {
  words <- strsplit(s, ""(\\s+)"", perl = TRUE)[[1]]
  sorted_words <- sapply(words, function(word) {
    if (word == """") return(word)
    chars <- unlist(strsplit(word, split = """"))
    return(paste0(sort(chars), collapse = """"))
  })
  return(paste0(sorted_words, collapse = """"))
}","test_humaneval <- function() {
    candidate <- anti_shuffle
    stopifnot(isTRUE(all.equal(candidate('Hi'), 'Hi')))
    stopifnot(isTRUE(all.equal(candidate('hello'), 'ehllo')))
    stopifnot(isTRUE(all.equal(candidate('number'), 'bemnru')))
    stopifnot(isTRUE(all.equal(candidate('abcd'), 'abcd')))
    stopifnot(isTRUE(all.equal(candidate('Hello World!!!'), 'Hello !!!Wdlor')))
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')))
}
test_humaneval()"
HumanEval_87,ydd_Hebr,r,"ביישפילן: אויך, סאָרט קאָואָרדאַנאַץ פון די רודערן דורך זייַלען אין דעסקרינדינג סדר. סאָרט קאָואָרדאַנאַץ ערשט דורך ראָוז אין אַסיענדינג סדר. יעדער רשימה איז אַ קאָואָרדאַנאַט - (רודערן, קאָלאָנס), סטאַרטינג מיט 0. און צוריקקומען רשימה פון רשימות, [(קס1, ו 1), (קס2, ו 2) ...] אַזאַ אַז געגעבן lst, און אינטעגער x, געפינען אינטעגערס x אין דער ליסטע, יעדער רודערן קען אַנטהאַלטן אַ אַנדערש נומער פון זייַלען. וואָס איז ענלעך צו מאַטריץ, אָבער, ניט ענלעך מאַטריץ, איר זענט געגעבן אַ 2 דימענשאַנאַל דאַטן, ווי אַ נעסטיד רשימות, # >>> get_row(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1)
# list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0))
# >>> get_row(c(), 1)
# c()
# >>> get_row(list(c(), c(1), c(1, 2, 3)), 3)
# list(c(2, 2))
get_row <- function(lst, x) {","get_row <- function(lst, x) {
  result <- list()
  for (i in seq_along(lst)) {
    row <- lst[[i]]
    cols <- which(row == x)
    for (col in rev(sort(cols - 1))) {
      result <- append(result, list(c(i - 1, col)))
    }
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- get_row
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0)))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6)), 2), list(c(0, 1), c(1, 1), c(2, 1), c(3, 1), c(4, 1), c(5, 1)))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 1, 3, 4, 5, 6), c(1, 2, 1, 4, 5, 6), c(1, 2, 3, 1, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 0), c(2, 1), c(2, 0), c(3, 2), c(3, 0), c(4, 3), c(4, 0), c(5, 4), c(5, 0), c(6, 5), c(6, 0)))))
    stopifnot(isTRUE(all.equal(candidate(c(), 1), c())))
    stopifnot(isTRUE(all.equal(candidate(list(c(1)), 2), c())))
    stopifnot(isTRUE(all.equal(candidate(list(c(), c(1), c(1, 2, 3)), 3), list(c(2, 2)))))
}
test_humaneval()"
HumanEval_88,ydd_Hebr,r,"ביישפילן: * טאָן ניט טוישן די געגעבן וועקטאָר. באַמערקונג: אָדער סאָרט עס אין דיסידינג סדר אויב די סומע ((פירסט אינדעקס ווערט, לעצט אינדעקס ווערט) איז פּער. איר וועט סאָרטירן דעם געגעבן וועקטאָר אין אַסינדענדינג סדר אויב די סומע ((פירסט אינדעקס ווערט, לעצט אינדעקס ווערט) איז פּאַרד, געגעבן אַ וועקטאָר פון ניט-נעגאַטיוו ינטיידזשערז, צוריקקומען אַ קאָר פון די געגעבן וועקטאָר נאָך סאָרטינג, # >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)
sort_array <- function(array) {","sort_array <- function(array) {
  if (length(array) <= 1) {
    return(array)
  }
  
  first_value <- array[1]
  last_value <- array[length(array)]
  sum_values <- first_value + last_value
  
  if (sum_values %% 2 == 1) {
    return(sort(array))
  } else {
    return(sort(array, decreasing = TRUE))
  }
}","test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()"
HumanEval_89,ydd_Hebr,r,"למשל: פאַרשווינדן אַראָפּ דורך צוויי מאל צו צוויי ערטער. די אַלפאַבע זאָל זיין ראָוטייטיד אין אַזאַ אַ וועג אַז די אותיות צוריקקומען אַ שטריקל ענקריפּטעד מיט די אַלפאַבע איז ראָוטייטיד. שאַפֿן אַ פונקציע ענקריפּט אַז נעמט אַ שטריקל ווי אַ אַרגומענט און # >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'
encrypt <- function(s) {","encrypt <- function(s) {
  alphabet <- letters
  shift <- 2 * 2
  encrypted <- sapply(strsplit(s, NULL)[[1]], function(char) {
    if (char %in% alphabet) {
      new_index <- (match(char, alphabet) + shift - 1) %% 26 + 1
      alphabet[new_index]
    } else {
      char
    }
  })
  paste(encrypted, collapse = """")
}","test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()"
HumanEval_90,ydd_Hebr,r,"צוריקקומען נול אויב עס איז ניט אַזאַ עלעמענט. שרײַבן אַ פֿונקציע next_smallest() וואָס גיט צוריק דעם צווייטן קלענסטן עלעמענט פֿון דער ליסטע. מען גיט דיר א ליסטע פון אינטעדזשערס.# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL
next_smallest <- function(lst) {","next_smallest <- function(lst) {
  # Sort the list and remove duplicates
  unique_sorted_lst <- sort(unique(lst))
  
  # Check if list contains at least two distinct elements
  if (length(unique_sorted_lst) < 2) {
    return(NULL)
  }
  
  # Return the second smallest element
  return(unique_sorted_lst[2])
}","test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()"
HumanEval_91,ydd_Hebr,r,"למשל: זאַץ זענען דילימאַטעד דורך """", ""?"" אָדער ""!"". אַ באָרד איז אַ זאַץ וואָס הייבט זיך אָן מיטן וואָרט ""איך"".איר וועט באַקומען אַ שטריקל ווערטער, און איר אַרבעט איז צו ציילן די נומער.# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1
is_bored <- function(S) {","is_bored <- function(S) {
  # Split the string into sentences using '.', '?', and '!' as delimiters
  sentences <- unlist(strsplit(S, split = ""[.?!]""))
  
  # Trim leading and trailing whitespace from each sentence
  sentences <- trimws(sentences)
  
  # Count the number of sentences that start with ""I""
  boredom_count <- sum(startsWith(sentences, ""I""))
  
  return(boredom_count)
}","test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()"
HumanEval_92,ydd_Hebr,r,"ביישפילן ריטורנס פאַלש אין קיין אנדערע קאַסעס. ריטורנס אמת אויב איינער פון די נומערן איז גלייַך צו די סכום פון די אנדערע צוויי, און אַלע נומערן זענען ינטיידזשערז. שאַפֿן אַ פונקציע וואָס נעמט 3 נומערן.# >>> any_int(5, 2, 7)
# TRUE
# >>> any_int(3, 2, 2)
# FALSE
# >>> any_int(3, -2, 1)
# TRUE
# >>> any_int(3.6, -2.2, 2)
# FALSE
any_int <- function(x, y, z) {","any_int <- function(x, y, z) {
  if (is.integer(x) && is.integer(y) && is.integer(z)) {
    return(x == y + z || y == x + z || z == x + y)
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- any_int
    stopifnot(isTRUE(all.equal(candidate(2, 3, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2.5, 2, 3), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1.5, 5, 3.5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2.2, 2.2, 2.2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-4, 6, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2, 1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(3, 4, 7), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(3.0, 4, 7), FALSE)))
}
test_humaneval()"
HumanEval_93,ydd_Hebr,r,"ביישפילן: נעמט נאָר אותיות.אַ וואָקאַל אין דעם ענגלישן אַלפאַבע.די אָנזאָג מיט דעם בריוו וואָס איז 2 ערטער פאָרויס פון דעם אַזוי אַז עס סוואַפּס פאַל פון אַלע אותיות, ריפּלייסיז אַלע וואָקאַלז אין שרײַבן אַ פֿונקציע וואָס נעמט אַ אָנזאָג, און קאָדירט אין אַזאַ אַ # >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'
encode <- function(message) {","encode <- function(message) {
  # Function to swap case of letters
  swap_case <- function(char) {
    if (grepl(""[A-Za-z]"", char)) {
      if (char %in% LETTERS) {
        return(tolower(char))
      } else {
        return(toupper(char))
      }
    } else {
      return(char)
    }
  }
  
  # Vowel replacement rules
  vowel_replacement <- function(char) {
    vowels <- c(""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U"")
    replacements <- c(""c"", ""g"", ""k"", ""q"", ""w"", ""C"", ""G"", ""K"", ""Q"", ""W"")
    if (char %in% vowels) {
      index <- match(char, vowels)
      return(replacements[index])
    } else {
      return(char)
    }
  }
  
  # Splitting the message into its characters
  message_chars <- strsplit(message, """")[[1]]
  
  # Apply swap case and vowel replacement
  encoded_chars <- sapply(message_chars, function(x) vowel_replacement(swap_case(x)))
  
  # Combine the characters back into a single string
  return(paste(encoded_chars, collapse = """"))
}","test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()"
HumanEval_94,ydd_Hebr,r,"ביישפילן: איר דאַרפֿן צו געפֿינען די גרעסטע פּירימע ווערט און צוריקקומען די סכום פון זייַן דידזשיץ. מען גיט דיר א ליסטע פון אינטעדזשערס.# >>> skjkasdkd(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))
# 10
# >>> skjkasdkd(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))
# 25
# >>> skjkasdkd(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))
# 13
# >>> skjkasdkd(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))
# 11
# >>> skjkasdkd(c(0, 81, 12, 3, 1, 21))
# 3
# >>> skjkasdkd(c(0, 8, 1, 2, 1, 7))
# 7
skjkasdkd <- function(lst) {","skjkasdkd <- function(lst) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n == 2) return(TRUE)
    if (n %% 2 == 0) return(FALSE)
    for (i in 3:sqrt(n)) {
      if (n %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  prime_values <- lst[sapply(lst, is_prime)]
  if (length(prime_values) == 0) return(0)
  
  largest_prime <- max(prime_values)
  
  sum_of_digits <- function(n) {
    sum(as.numeric(unlist(strsplit(as.character(n), """"))))
  }
  
  return(sum_of_digits(largest_prime))
}","test_humaneval <- function() {
    candidate <- skjkasdkd
    stopifnot(isTRUE(all.equal(candidate(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)), 10)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)), 25)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)), 13)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)), 11)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 81, 12, 3, 1, 21)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 8, 1, 2, 1, 7)), 7)))
    stopifnot(isTRUE(all.equal(candidate(c(8191)), 19)))
    stopifnot(isTRUE(all.equal(candidate(c(8191, 123456, 127, 7)), 19)))
    stopifnot(isTRUE(all.equal(candidate(c(127, 97, 8192)), 10)))
}
test_humaneval()"
HumanEval_95,ydd_Hebr,r,"ביישפילן: די פונקציע זאָל צוריקקומען FALSE איז די געגעבן געהייסן רשימה איז ליידיק. פאַל אָדער אַלע שליסלען זענען סטרינגס אין הויך פאַל, אַנדערש צוריקקומען פאַלש. געגעבן אַ געהייסן רשימה, צוריקקומען אמת אויב אַלע שליסלען זענען סטרינגס אין נידעריקער # >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE
check_dict_case <- function(dict) {","check_dict_case <- function(dict) {
  if (length(dict) == 0) return(FALSE)
  
  keys <- names(dict)
  
  all_lower <- all(keys == tolower(keys))
  all_upper <- all(keys == toupper(keys))
  
  return(all_lower || all_upper)
}","test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()"
HumanEval_96,ydd_Hebr,r,"פֿאַר בייַשפּיל: אינטעדזשערס וואס זענען פריים נומערן און ווייניגער ווי n. ימפּלאַמענט אַ פונקציע וואָס נעמט אַ ניט-נעגאַטיוו ינטייגער און ריטורנס אַ וועקטאָר פון דער ערשטער n # >>> count_up_to(5)
# c(2, 3)
# >>> count_up_to(11)
# c(2, 3, 5, 7)
# >>> count_up_to(0)
# c()
# >>> count_up_to(20)
# c(2, 3, 5, 7, 11, 13, 17, 19)
# >>> count_up_to(1)
# c()
# >>> count_up_to(18)
# c(2, 3, 5, 7, 11, 13, 17)
count_up_to <- function(n) {","count_up_to <- function(n) {
  is_prime <- function(num) {
    if (num <= 1) return(FALSE)
    if (num == 2) return(TRUE)
    if (num %% 2 == 0) return(FALSE)
    for (i in 3:sqrt(num)) {
      if (num %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  primes_below_n <- c()
  for (i in 2:(n-1)) {
    if (is_prime(i)) {
      primes_below_n <- c(primes_below_n, i)
    }
  }
  
  return(primes_below_n)
}","test_humaneval <- function() {
    candidate <- count_up_to
    stopifnot(isTRUE(all.equal(candidate(5), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(6), c(2, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(7), c(2, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(10), c(2, 3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(0), c())))
    stopifnot(isTRUE(all.equal(candidate(22), c(2, 3, 5, 7, 11, 13, 17, 19))))
    stopifnot(isTRUE(all.equal(candidate(1), c())))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(47), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43))))
    stopifnot(isTRUE(all.equal(candidate(101), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))))
}
test_humaneval()"
HumanEval_97,ydd_Hebr,r,"ביישפילן: נעמט אן אז די אינפּוט איז שטענדיק גילטיק.די פּראָדוקט פון זייער וניט דידזשערז. פאַרענדיקן די פונקציע אַז נעמט צוויי ינטיידזשערז און קערט # >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20
multiply <- function(a, b) {","multiply <- function(a, b) {
  unit_digit_a <- abs(a) %% 10
  unit_digit_b <- abs(b) %% 10
  return(unit_digit_a * unit_digit_b)
}","test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()"
HumanEval_98,ydd_Hebr,r,"למשל: געגעבן אַ שטריקל s, ציילן די נומער פון הויפּטקאַסער וואָקאַלס אין פּאַרע ינדאַסיז. # >>> count_upper('aBCdEf')
# 1
# >>> count_upper('abcdefg')
# 0
# >>> count_upper('dBBE')
# 0
count_upper <- function(s) {","count_upper <- function(s) {
  # Define uppercase vowels
  uppercase_vowels <- c('A', 'E', 'I', 'O', 'U')
  
  # Initialize counter
  count <- 0
  
  # Iterate over string indices
  for (i in seq(1, nchar(s), by=2)) {
    # Check if character at even index is an uppercase vowel
    if (substr(s, i, i) %in% uppercase_vowels) {
      count <- count + 1
    }
  }
  
  return(count)
}","test_humaneval <- function() {
    candidate <- count_upper
    stopifnot(isTRUE(all.equal(candidate('aBCdEf'), 1)))
    stopifnot(isTRUE(all.equal(candidate('abcdefg'), 0)))
    stopifnot(isTRUE(all.equal(candidate('dBBE'), 0)))
    stopifnot(isTRUE(all.equal(candidate('B'), 0)))
    stopifnot(isTRUE(all.equal(candidate('U'), 1)))
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('EEEE'), 2)))
}
test_humaneval()"
HumanEval_99,ydd_Hebr,r,"ביישפילן פון צוויי אינטעדזשערס, רונדיקט עס אוועק פון נול.און גיט צוריק די נענטסטע אינטעדזשער צו אים. אויב די נומער איז עקווידיסטענט שאַפֿן אַ פונקציע וואָס נעמט אַ ווערט (שטרינג) רעפּריזענטינג אַ נומער # >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
closest_integer <- function(value) {","closest_integer <- function(value) {
  num <- as.numeric(value)
  if (num %% 1 == 0.5 || num %% 1 == -0.5) {
    return(ifelse(num > 0, ceiling(num), floor(num)))
  } else {
    return(round(num))
  }
}","test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()"
HumanEval_100,ydd_Hebr,r,"ביישפילן: i רעפּראַזענץ די נומער פון שטיינער אין די מדרגה (i+1). צוריקקומען די נומער פון שטיינער אין יעדער מדרגה אין אַ רשימה, ווו עלעמענט בייַ אינדעקס - די קומענדיגע פּאָרע נומער אויב n איז פּאָרע. - די קומענדיגע אומגעלייגטע נומער אויב n איז אומגעלייגט. די נומער פון שטיינער אין דער ווייַטער מדרגה איז: דער ערשטער שטאַפּל האָט n שטיינער.געגעבן אַ positive גאַנץ נומער n, איר האָבן צו מאַכן אַ הויפן פון n לעוועלס פון שטיינער. # >>> make_a_pile(3)
# c(3, 5, 7)
make_a_pile <- function(n) {","make_a_pile <- function(n) {
  stones <- numeric(n)
  stones[1] <- n
  for (i in 2:n) {
    if (n %% 2 == 0) {
      stones[i] <- stones[i - 1] + 2
    } else {
      stones[i] <- stones[i - 1] + 2
    }
  }
  return(stones)
}","test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()"
HumanEval_101,ydd_Hebr,r,"למשל: צו צעטיילט די שטריקל אין ווערטער און צוריקקומען אַ וועקטאָר פון די ווערטער. איר וועט באַקומען אַ שטריקל ווערטער אפגעשיידט דורך קאָמאַס אָדער ספּייסיז.# >>> words_string('Hi, my name is John')
# c('Hi', 'my', 'name', 'is', 'John')
# >>> words_string('One, two, three, four, five, six')
# c('One', 'two', 'three', 'four', 'five', 'six')
words_string <- function(s) {","words_string <- function(s) {
  s <- gsub("","", "" "", s)
  words <- unlist(strsplit(s, ""\\s+""))
  words <- words[words != """"]
  return(words)
}","test_humaneval <- function() {
    candidate <- words_string
    stopifnot(isTRUE(all.equal(candidate('Hi, my name is John'), c('Hi', 'my', 'name', 'is', 'John'))))
    stopifnot(isTRUE(all.equal(candidate('One, two, three, four, five, six'), c('One', 'two', 'three', 'four', 'five', 'six'))))
    stopifnot(isTRUE(all.equal(candidate('Hi, my name'), c('Hi', 'my', 'name'))))
    stopifnot(isTRUE(all.equal(candidate('One,, two, three, four, five, six,'), c('One', 'two', 'three', 'four', 'five', 'six'))))
    stopifnot(isTRUE(all.equal(candidate(''), c())))
    stopifnot(isTRUE(all.equal(candidate('ahmed     , gamal'), c('ahmed', 'gamal'))))
}
test_humaneval()"
HumanEval_102,ydd_Hebr,r,"למשל: עס איז נישט דא אזא נומער, דערנאך דארף די פונקציע צוריקקומען -1.די גרעסטע פּאַרע אינטעדזשער נומער וואָס איז אין די קייט [x, y] ינקלוסיוו. אויב די פונקציע נעמט צוויי positive נומערן x און y און גיט צוריק די # >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
choose_num <- function(x, y) {","choose_num <- function(x, y) {
  if (x > y) {
    return(-1)
  }
  
  for (num in seq(y, x, by = -1)) {
    if (num %% 2 == 0) {
      return(num)
    }
  }
  
  return(-1)
}","test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()"
HumanEval_103,ydd_Hebr,r,"בייַשפּיל: אויב n איז גרעסער ווי m, צוריקקומען -1.ראָונד די ענטפער צו די ניראַסט ינטיידזשער און קאָנווערט אַז צו ביינערי. דורכשניט פון די ינטעדזשערז פון n דורך m (אַרייַנגערעכנט n און m). מען גיט דיר צוויי פאזיטיווע אינטעדזשערס n און m, און דיין אויפגאבע איז צו רעכענען די # >>> rounded_avg(1, 5)
# '0b11'
# >>> rounded_avg(7, 5)
# -1
# >>> rounded_avg(10, 20)
# '0b1111'
# >>> rounded_avg(20, 33)
# '0b11010'
rounded_avg <- function(n, m) {","rounded_avg <- function(n, m) {
  if (n > m) {
    return(-1)
  }
  avg <- mean(n:m)
  rounded_avg <- round(avg)
  binary_avg <- as.character(as.binary(rounded_avg))
  return(paste0(""0b"", binary_avg))
}

as.binary <- function(num) {
  if (num == 0) {
    return(""0"")
  }
  binary <- """"
  while (num > 0) {
    binary <- paste0(num %% 2, binary)
    num <- num %/% 2
  }
  return(binary)
}","test_humaneval <- function() {
    candidate <- rounded_avg
    stopifnot(isTRUE(all.equal(candidate(1, 5), '0b11')))
    stopifnot(isTRUE(all.equal(candidate(7, 13), '0b1010')))
    stopifnot(isTRUE(all.equal(candidate(964, 977), '0b1111001010')))
    stopifnot(isTRUE(all.equal(candidate(996, 997), '0b1111100100')))
    stopifnot(isTRUE(all.equal(candidate(560, 851), '0b1011000010')))
    stopifnot(isTRUE(all.equal(candidate(185, 546), '0b101101110')))
    stopifnot(isTRUE(all.equal(candidate(362, 496), '0b110101101')))
    stopifnot(isTRUE(all.equal(candidate(350, 902), '0b1001110010')))
    stopifnot(isTRUE(all.equal(candidate(197, 233), '0b11010111')))
    stopifnot(isTRUE(all.equal(candidate(7, 5), -1)))
    stopifnot(isTRUE(all.equal(candidate(5, 1), -1)))
    stopifnot(isTRUE(all.equal(candidate(5, 5), '0b101')))
}
test_humaneval()"
HumanEval_104,ydd_Hebr,r,"למשל: באַמערקונג: די אומגעקערטע ליסטע זאָל זיין סאָרטירט אין אַקסענטינג סדר.עלעמענטן וואס האבן נישט קיין פּאַרע ציפערן.געגעבן אַ רשימה פון positive integers x. צוריקקומען אַ סאָרטעד רשימה פון אַלע # >>> unique_digits(c(15, 33, 1422, 1))
# c(1, 15, 33)
# >>> unique_digits(c(152, 323, 1422, 10))
# c()
unique_digits <- function(x) {","unique_digits <- function(x) {
  has_no_even_digit <- function(num) {
    digits <- as.numeric(strsplit(as.character(num), """")[[1]])
    return(all(digits %% 2 != 0))
  }
  
  result <- Filter(has_no_even_digit, x)
  return(sort(result))
}","test_humaneval <- function() {
    candidate <- unique_digits
    stopifnot(isTRUE(all.equal(candidate(c(15, 33, 1422, 1)), c(1, 15, 33))))
    stopifnot(isTRUE(all.equal(candidate(c(152, 323, 1422, 10)), c())))
    stopifnot(isTRUE(all.equal(candidate(c(12345, 2033, 111, 151)), c(111, 151))))
    stopifnot(isTRUE(all.equal(candidate(c(135, 103, 31)), c(31, 135))))
}
test_humaneval()"
HumanEval_105,ydd_Hebr,r,"למשל: ""איין"", ""צוויי"", ""דריי"", ""פיר"", ""פופֿץ"", ""זעקס"", ""זיבן"", ""אכט"", ""ניין"". צוריקקערן דעם רעזולטאט וועקטאָר, און דערנאך פאַרבייַטן יעדער ציפער מיט זיין קאָראַספּאַנדינג נאָמען פון געגעבן אַ וועקטאָר פון ינטיידזשערז, סאָרט די ינטיידזשערז וואָס זענען צווישן 1 און 9 ינקלוסיוו, # >>> by_length(c(2, 1, 1, 4, 5, 8, 2, 3))
# c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One')
#   If the vector is empty, return an empty vector:
# >>> by_length(c())
# c()
#   If the vector has any strange number ignore it:
# >>> by_length(c(1, -1, 55))
# c('One')
by_length <- function(arr) {","by_length <- function(arr) {
  # Filter numbers between 1 and 9
  valid_nums <- arr[arr >= 1 & arr <= 9]
  # Sort the numbers
  sorted_nums <- sort(valid_nums, decreasing = TRUE)
  # Map numbers to their names
  num_to_name <- c(""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"")
  result <- num_to_name[sorted_nums]
  return(result)
}","test_humaneval <- function() {
    candidate <- by_length
    stopifnot(isTRUE(all.equal(candidate(c(2, 1, 1, 4, 5, 8, 2, 3)), c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 55)), c('One'))))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 3, 2)), c('Three', 'Two', 'One'))))
    stopifnot(isTRUE(all.equal(candidate(c(9, 4, 8)), c('Nine', 'Eight', 'Four'))))
}
test_humaneval()"
HumanEval_106,ydd_Hebr,r,"בייַשפּיל: די פאַקטאָריאַל פון איך איז די מאַלטאַפּליישאַן פון די נומערן פון 1 צו איך (1 * 2 * ... * איך).איך הייב אן פון 1.אָדער די סכום פון נומערן פון 1 צו i אַנדערש. און צוריקגעגעבן אַ רשימה פון גרייס n, אַזאַ אַז די ווערט פון דער עלעמענט אין אינדעקס i איז די פאַקטאָריאַל פון i אויב i איז פּער ימפּלאַמענט די פונקציע f אַז נעמט n ווי אַ פּאַראַמעטער, # >>> f(5)
# c(1, 2, 6, 24, 15)
f <- function(n) {","f <- function(n) {
  result <- numeric(n)  # Initialize a numeric vector of length n
  for (i in 1:n) {
    if (i %% 2 == 0) {  # Check if i is even
      result[i] <- factorial(i)
    } else {
      result[i] <- sum(1:i)
    }
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()"
HumanEval_107,ydd_Hebr,r,"בייַשפּיל 1: גאַנץ נומער פּאַלינדראָמס וואָס פאַלן אין די קייט ((1, n), ינקלוסיוו. געגעבן אַ positive integer n, צוריקקומען אַ רשימה אַז האט די נומער פון פּאָר און מאָדנע # >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.
even_odd_palindrome <- function(n) {","even_odd_palindrome <- function(n) {
  is_palindrome <- function(x) {
    str_x <- as.character(x)
    return(str_x == paste(rev(unlist(strsplit(str_x, """"))), collapse = """"))
  }
  
  even_count <- 0
  odd_count <- 0
  
  for (i in 1:n) {
    if (is_palindrome(i)) {
      if (i %% 2 == 0) {
        even_count <- even_count + 1
      } else {
        odd_count <- odd_count + 1
      }
    }
  }
  
  return(c(even_count, odd_count))
}","test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()"
HumanEval_108,ydd_Hebr,r,"למשל -123 האט געחתמעט ציפערן -1, 2, און 3.אויב אַ נומער איז נעגאַטיוו, וועט זיין ערשטע אונטערגעשריבן ציפער זיין נעגאַטיוו:די נומער פון עלעמענטן וואָס האט אַ סכום פון דידזשיץ > 0. שרײַבן אַ פֿונקציע count_nums וואָס נעמט אַ וועקטאָר פון אינטיידזשערז און צוריקגעגעבן # >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
count_nums <- function(arr) {","count_nums <- function(arr) {
  # Helper function to calculate sum of digits
  sum_of_digits <- function(num) {
    digits <- as.numeric(unlist(strsplit(as.character(num), """")))
    return(sum(digits, na.rm = TRUE))
  }
  
  # Apply the sum_of_digits function and count numbers with sum > 0
  return(sum(sapply(arr, sum_of_digits) > 0))
}","test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()"
HumanEval_109,ydd_Hebr,r,"פֿאַר בייַשפּיל: באַמערקונג: די געגעבן רשימה איז געראַנטיד צו האָבן יינציק עלעמענטן.אויב די געגעבן וועקטאָר איז ליידיק דעמאָלט צוריקקומען אמת. דעמאָלט צוריקקומען אמת אַנדערש צוריקקומען פאַלש. אויב עס איז מעגלעך צו באַקומען די סאָרטעד וועקטאָר דורך פּערפאָרמינג די אויבן אָפּעראַציע די אָנהייב שטעלע אין די וועקטאָר ד""ה 0th אינדעקס. די לעצטע עלעמענט פון די וועקטאָר וועט זיין אריבערגעפארן צו איין רעכט שוויפט אָפּעראַציע מיטל שוויפט אַלע עלעמענטן פון דעם וועקטאָר דורך איין.איר זענט ערלויבט צו דורכפירן רעכט שיף אָפּעראַציע קיין נומער פון מאל. די פאלגענדע אָפּעראַציע אויף די געגעבן וועקטאָר: עס איז מעגלעך צו באַקומען אַ וועקטאָר סאָרטעד אין ניט-דעקריסינג סדר דורך פּערפאָרמינג די נומערן אין דעם וועקטאָר וועלן זיין ראַנדאַמלי אָרדערד. דיין אַרבעט איז צו באַשליסן אויב מיר האָבן אַ וועקטאָר 'אַרר' פון N אינטעדזשערז אַרר[1], אַרר[2], ..., אַרר[N]. די # >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.
move_one_ball <- function(arr) {","move_one_ball <- function(arr) {
  if (length(arr) == 0) {
    return(TRUE)
  }
  
  n <- length(arr)
  for (i in 1:n) {
    shifted_arr <- c(tail(arr, n - i), head(arr, i))
    if (all(diff(shifted_arr) >= 0)) {
      return(TRUE)
    }
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()"
HumanEval_110,ydd_Hebr,r,"למשל: אַנדערש, צוריקקומען ""ניין"". אַלע די עלעמענטן פון lst1 צו זיין פּער, צוריקקומען ""יעס"". אויב עס איז מעגלעך צו וועקסל עלעמענטן צווישן די LST1 און LST2 צו מאַכן עס איז קיין שיעור אויף די נומער פון עקסטשאַנגע עלעמענטן צווישן lst1 און lst2. צווישן זיי צו מאַכן LST1 אַ רשימה פון בלויז פּאַרע נומערן. און דיטערמאַנייץ צי עס איז מעגלעך צו דורכפירן אַ וועקסל פון עלעמענטן אין דעם פּראָבלעם, איר וועט ימפּלאַמענט אַ פונקציע אַז נעמט צוויי רשימות פון נומערן, # >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.
exchange <- function(lst1, lst2) {","exchange <- function(lst1, lst2) {
  # Identify even and odd numbers in lst1
  lst1_even <- lst1[lst1 %% 2 == 0]
  lst1_odd <- lst1[lst1 %% 2 != 0]
  
  # Identify even numbers in lst2
  lst2_even <- lst2[lst2 %% 2 == 0]
  
  # Check if the number of odd elements in lst1 can be replaced with even elements from lst2
  if (length(lst1_odd) <= length(lst2_even)) {
    return(""YES"")
  } else {
    return(""NO"")
  }
}","test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()"
HumanEval_111,ydd_Hebr,r,"בייַשפּיל: אויב עטלעכע אותיות האָבן די זעלבע פּאַסירונג, צוריקקומען אַלע פון זיי. פון די בריוו מיט די מערסט ריפּיטינג און קאַנטיינד די קאָראַספּאַנדינג ציילן. געגעבן אַ שטריקל רעפּריזענטינג אַ פּלאַץ סעפּעראַטעד לאָוקאַסע אותיות, צוריקקומען אַ געהייסן רשימה # >>> histogram('a b c')
# list('a' = 1, 'b' = 1, 'c' = 1)
# >>> histogram('a b b a')
# list('a' = 2, 'b' = 2)
# >>> histogram('a b c a b')
# list('a' = 2, 'b' = 2)
# >>> histogram('b b b b a')
# list('b' = 4)
# >>> histogram('')
# list()
histogram <- function(test) {","histogram <- function(test) {
  # Split the string into individual letters.
  letters <- unlist(strsplit(test, "" ""))
  
  # Create a table to count the occurrences of each letter.
  count_table <- table(letters)
  
  # Find the maximum frequency of occurrences.
  max_count <- max(count_table, na.rm = TRUE)
  
  # Find all letters that have the maximum frequency.
  max_letters <- names(count_table[count_table == max_count])
  
  # Create a named list with letters as names and their max occurrences as values.
  result <- setNames(as.list(rep(max_count, length(max_letters))), max_letters)
  
  return(result)
}","test_humaneval <- function() {
    candidate <- histogram
    stopifnot(isTRUE(all.equal(candidate('a b b a'), list('a' = 2, 'b' = 2))))
    stopifnot(isTRUE(all.equal(candidate('a b c a b'), list('a' = 2, 'b' = 2))))
    stopifnot(isTRUE(all.equal(candidate('a b c d g'), list('a' = 1, 'b' = 1, 'c' = 1, 'd' = 1, 'g' = 1))))
    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))
    stopifnot(isTRUE(all.equal(candidate('b b b b a'), list('b' = 4))))
    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))
    stopifnot(isTRUE(all.equal(candidate(''), list())))
    stopifnot(isTRUE(all.equal(candidate('a'), list('a' = 1))))
}
test_humaneval()"
HumanEval_112,ydd_Hebr,r,"ביישפּיל איר זאָל צוריקקומען אַ רשימה מיט די רעזולטאַט שטריקל און אמת / פאַלש פֿאַר די קאָנטראָל. א שטריקל ווערט גערופֿן פּאַלינדראָם אויב עס לייענט זיך די זעלבע צוריק ווי פֿאָר.דעמאָלט קאָנטראָלירן אויב די רעזולטאַט שטריקל איז פּאַלינדראָם. מיר האָבן צוויי סטרינגס s און c, איר מוזן אויסמעקן אַלע די אותיות אין s וואָס זענען גלייַך צו קיין אות אין c אַרבעט # >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)
reverse_delete <- function(s, c) {","reverse_delete <- function(s, c) {
  # Remove characters in 'c' from 's'
  for (char in strsplit(c, '')[[1]]) {
    s <- gsub(char, """", s)
  }
  
  # Check if the resultant string is a palindrome
  is_palindrome <- s == paste(rev(strsplit(s, NULL)[[1]]), collapse = """")
  
  # Return the resultant string and the palindrome check result
  return(list(s, is_palindrome))
}","test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()"
HumanEval_113,ydd_Hebr,r,"פון פּאַרד דידזשיץ אין די י'טה שטריקל פון די אַרייַנפיר. סטרינג י פון די ינפּוט. "" ווו אַלע די י זאָל זיין ריפּלייסט דורך די נומער יעדער עלעמענט i פון די רעזולטאַט זאָל זיין ""די נומער פון מאָדנע עלעמענטן אין די געגעבן אַ רשימה פון סטרינגס, ווו יעדער שטריקל באשטייט פון בלויז דידזשיץ, צוריקקומען אַ רשימה. # >>> odd_count(c('1234567'))
# c('the number of odd elements 4n the str4ng 4 of the 4nput.')
# >>> odd_count(c('3', '11111111'))
# c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.')
odd_count <- function(lst) {","odd_count <- function(lst) {
  sapply(lst, function(x) {
    odd_digits <- sum(as.numeric(unlist(strsplit(x, """"))) %% 2 == 1)
    sprintf(""the number of odd elements %dn the str%2$sing %1$d of the %3$nput."", odd_digits, odd_digits, odd_digits)
  })
}

# Example usage
print(odd_count(c('1234567')))
print(odd_count(c('3', '11111111')))","test_humaneval <- function() {
    candidate <- odd_count
    stopifnot(isTRUE(all.equal(candidate(c('1234567')), c('the number of odd elements 4n the str4ng 4 of the 4nput.'))))
    stopifnot(isTRUE(all.equal(candidate(c('3', '11111111')), c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'))))
    stopifnot(isTRUE(all.equal(candidate(c('271', '137', '314')), c('the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'))))
}
test_humaneval()"
HumanEval_114,ydd_Hebr,r,"ביישפּיל פון נאַמס. געגעבן אַ וועקטאָר פון ינטיידזשערז נאַמז, געפינען די מינימום סומע פון קיין ניט-טאָול סאַב-וועקטאָר # >>> minSubArraySum(c(2, 3, 4, 1, 2, 4))
# 1
# >>> minSubArraySum(c(-1, -2, -3))
# -6
minSubArraySum <- function(nums) {","minSubArraySum <- function(nums) {
  min_sum <- nums[1]
  current_sum <- 0
  
  for (num in nums) {
    if (current_sum > 0) {
      current_sum <- 0
    }
    current_sum <- current_sum + num
    if (current_sum < min_sum) {
      min_sum <- current_sum
    }
  }
  
  return(min_sum)
}","test_humaneval <- function() {
    candidate <- minSubArraySum
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 4, 1, 2, 4)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3)), -6)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 2, -10)), -14)))
    stopifnot(isTRUE(all.equal(candidate(c(-9999999999999999)), -9999999999999999)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 10, 20, 1000000)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 10, -5)), -6)))
    stopifnot(isTRUE(all.equal(candidate(c(100, -1, -2, -3, 10, -5)), -6)))
    stopifnot(isTRUE(all.equal(candidate(c(10, 11, 13, 8, 3, 4)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(100, -33, 32, -1, 0, -2)), -33)))
    stopifnot(isTRUE(all.equal(candidate(c(-10)), -10)))
    stopifnot(isTRUE(all.equal(candidate(c(7)), 7)))
    stopifnot(isTRUE(all.equal(candidate(c(1, -1)), -1)))
}
test_humaneval()"
HumanEval_115,ydd_Hebr,r,"בייַשפּיל 1: אַרויספירן די נומער פון מאל איר דאַרפֿן צו נידעריקער די בעקץ. אײַער אַרבעט איז צו באַנוצן די בעקץ צו רוקן די קוואַלן.און אַלע בעקץ האָבן די זעלבע קאַפּאַציטעט. יעדע באר האט א קארעספאנדענטע בעקער וואס קען ווערן גענוצט צו ארויסנעמען וואסער פון איר, און יעדער 1 אין אַ רודערן רעפּריזענץ אַ איין אַפּאַראַט פון וואַסער. איר זענט געגעבן אַ רעקטאַנגגיאַלער גריד פון וועלז. יעדער רודערן רעפּראַזענץ אַ איין געזונט, # >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10
max_fill <- function(grid, capacity) {","max_fill <- function(grid, capacity) {
  total_water <- sum(unlist(grid))
  num_buckets_needed <- ceiling(total_water / capacity)
  return(num_buckets_needed)
}","test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()"
HumanEval_116,ydd_Hebr,r,"עס דאַרף זיין ימפּלאַמענאַד ווי דאָס: פֿאַר ענלעך נומער פון איינס, סאָרט באזירט אויף דעצימאַל ווערט. נומער פון איינס אין זייער ביינערי רעפּראַזענץ אין אַסינדענט סדר. אין דעם קאַטאַ, איר האָבן צו סאָרטירן אַ וועקטאָר פון ניט-נעגאַטיוו ינטיידזשערז לויט צו # >>> sort_array(c(1, 5, 2, 3, 4))
# c(1, 2, 3, 4, 5)
# >>> sort_array(c(-2, -3, -4, -5, -6))
# c(-6, -5, -4, -3, -2)
# >>> sort_array(c(1, 0, 2, 3, 4))
# c(0, 1, 2, 3, 4)
sort_array <- function(arr) {","sort_array <- function(arr) {
  # Filter out negative numbers and sort them directly
  negative_numbers <- sort(arr[arr < 0])
  
  # Process non-negative numbers
  non_negative_numbers <- arr[arr >= 0]
  
  # Sort non-negative numbers based on number of 1s in binary representation, then by decimal value
  sorted_non_negative_numbers <- non_negative_numbers[order(sapply(non_negative_numbers, function(x) {
    sum(as.integer(intToBits(x)))
  }), non_negative_numbers)]
  
  # Combine sorted negative and non-negative numbers
  c(negative_numbers, sorted_non_negative_numbers)
}","test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c(1, 5, 2, 3, 4)), c(1, 2, 4, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(-2, -3, -4, -5, -6)), c(-4, -2, -6, -5, -3))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 2, 3, 4)), c(0, 1, 2, 4, 3))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4)), c(2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77))))
    stopifnot(isTRUE(all.equal(candidate(c(3, 6, 44, 12, 32, 5)), c(32, 3, 5, 6, 12, 44))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))
}
test_humaneval()"
HumanEval_117,ydd_Hebr,r,"ביישפילן: באַמערקונג: איר קענען יבערנעמען די ינפּוט שטריקל כּולל בלויז אותיות און ספּייסיז. אויב די שטריקל s איז ליידיק דעמאָלט די פונקציע זאָל צוריקקומען אַ ליידיק רשימה. n קאָנסאָנאַנץ, אין סדר אַז די ווערטער קומען אין די שטריקל s. אַ פונקציע וואָס קערט אַ רשימה פון אַלע ווערטער פון סטרינג s וואָס אַנטהאַלטן פּונקט געגעבן אַ שטריקל s און אַ נאַטירלעך נומער n, איר האָבן שוין טאַסקט צו ימפּלאַמענט # >>> select_words('Mary had a little lamb', 4)
# c('little')
# >>> select_words('Mary had a little lamb', 3)
# c('Mary', 'lamb')
# >>> select_words('simple white space', 2)
# c()
# >>> select_words('Hello world', 4)
# c('world')
# >>> select_words('Uncle sam', 3)
# c('Uncle')
select_words <- function(s, n) {","select_words <- function(s, n) {
  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
  words <- strsplit(s, "" "")[[1]]
  result <- sapply(words, function(word) {
    consonants_count <- nchar(gsub(paste(vowels, collapse = ""|""), """", word))
    if (consonants_count == n) return(word)
    else return(NULL)
  })
  result <- result[!sapply(result, is.null)]
  unname(result)
}","test_humaneval <- function() {
    candidate <- select_words
    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 4), c('little'))))
    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 3), c('Mary', 'lamb'))))
    stopifnot(isTRUE(all.equal(candidate('simple white space', 2), c())))
    stopifnot(isTRUE(all.equal(candidate('Hello world', 4), c('world'))))
    stopifnot(isTRUE(all.equal(candidate('Uncle sam', 3), c('Uncle'))))
    stopifnot(isTRUE(all.equal(candidate('', 4), c())))
    stopifnot(isTRUE(all.equal(candidate('a b c d e f', 1), c('b', 'c', 'd', 'f'))))
}
test_humaneval()"
HumanEval_118,ydd_Hebr,r,"בייַשפּיל: איר קענען יבערנעמען אַז די געגעבן שטריקל כּולל ענגליש בריוו בלויז. געפֿינען קיין וואָקאַל געגעבען די אויבן צושטאַנד. וואָקאַלס אין די אָנהייב און ענדיקן טוט נישט ציילן. צוריקקומען ליידיק שטריקל אויב איר האט ניט צוויי קאָנסאָנאַנץ פֿון דער רעכטער זײַט פֿונעם וואָרט (קאַסע סענסיטיוו).איר האָט באַקומען אַ וואָרט. אײַער אויפֿגאַבע איז צו געפֿינען דעם נאָענטסטן וואַקאַל וואָס שטייט צווישן # >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''
get_closest_vowel <- function(word) {","get_closest_vowel <- function(word) {
  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
  n <- nchar(word)
  
  # Iterate from the second to last position to the second position
  for (i in (n-1):2) {
    if (substr(word, i, i) %in% vowels) {
      if (!substr(word, i-1, i-1) %in% vowels && !substr(word, i+1, i+1) %in% vowels) {
        return(substr(word, i, i))
      }
    }
  }
  
  # Return empty string if no vowel is found
  return('')
}","test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()"
HumanEval_119,ydd_Hebr,r,"ביישפילן: צוריקקומען 'יא' אויב עס איז אַ וועג צו מאַכן אַ גוט שטריקל, און צוריקקומען 'ניין' אַנדערש. ""()) "" איז נישט. זענען באַלאַנסט. למשל: די שטריקל '(((() ' איז גוט, בשעת די שטריקל א שטריקל S ווערט באטראכט ווי גוט אויב און נאר אויב אלע קרענטעז אין S עטלעכע סדר, אַז די ריזאַלטינג שטריקל וועט זיין גוט. אײַער אַרבעט איז צו קאָנטראָלירן צי עס איז מעגלעך צו קאָנקאַטיינירן די צוויי שטריכן איןפּאַראַנטעזעס ""("" אָדער נאָענט פּאַראַנטעזעס "") "" בלויז. איר זענט געגעבן אַ רשימה פון צוויי סטרינגס, ביידע סטרינגס קאָסטן פון עפענען # >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'
match_parens <- function(lst) {","match_parens <- function(lst) {
  is_balanced <- function(s) {
    balance <- 0
    for (ch in strsplit(s, """")[[1]]) {
      if (ch == '(') {
        balance <- balance + 1
      } else {
        balance <- balance - 1
      }
      if (balance < 0) return(FALSE)
    }
    return(balance == 0)
  }
  
  s1 <- lst[1]
  s2 <- lst[2]
  
  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {
    return('Yes')
  } else {
    return('No')
  }
}","test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()"
HumanEval_120,ydd_Hebr,r,"בייַשפּיל 1: פון לענג k מיט די מאַקסימום ק נומערן אין אַרר. געגעבן אַ וועקטאָר arr פון ינטיידזשערז און אַ positive ינטיידזשער ק, צוריקקומען אַ סאָרטעד רשימה # >>> maximum(c(-3, -4, 5), 3)
# c(-4, -3, 5)
# Example 2:
# >>> maximum(c(4, -4, 4), 2)
# c(4, 4)
# Example 3:
# >>> maximum(c(-3, 2, 1, 2, -1, -2, 1), 1)
# c(2)
# Note:
#     1. The length of the vector will be in the range of [1, 1000].
#     2. The elements in the vector will be in the range of [-1000, 1000].
#     3. 0 <= k <= len(arr)
maximum <- function(arr, k) {","maximum <- function(arr, k) {
  return(sort(tail(sort(arr), k)))
}","test_humaneval <- function() {
    candidate <- maximum
    stopifnot(isTRUE(all.equal(candidate(c(-3, -4, 5), 3), c(-4, -3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(4, -4, 4), 2), c(4, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 2, 1, 2, -1, -2, 1), 1), c(2))))
    stopifnot(isTRUE(all.equal(candidate(c(123, -123, 20, 0, 1, 2, -3), 3), c(2, 20, 123))))
    stopifnot(isTRUE(all.equal(candidate(c(-123, 20, 0, 1, 2, -3), 4), c(0, 1, 2, 20))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 15, 0, 3, -13, -8, 0), 7), c(-13, -8, 0, 0, 3, 5, 15))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 2, 5, 3, -10), 2), c(3, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 5, -7), 1), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(4, -4), 2), c(-4, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(-10, 10), 2), c(-10, 10))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, -23, 243, -400, 0), 0), c())))
}
test_humaneval()"
HumanEval_121,ydd_Hebr,r,"ביישפילן געגעבן אַ ניט-טאָול רשימה פון ינטיידזשערז, צוריקקומען די סומע פון אַלע פון די מאָדנע עלעמענטן וואָס זענען אין אַפֿילו שטעלעס. # >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0
solution <- function(lst) {","solution <- function(lst) {
  sum(lst[seq(2, length(lst), by = 2)][lst[seq(2, length(lst), by = 2)] %% 2 != 0])
}","test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()"
HumanEval_122,ydd_Hebr,r,"בייַשפּיל: די סומע פון די עלעמענטן מיט מאַקסימום צוויי דידזשיץ פון די ערשטער ק עלעמענטן פון arr. געגעבן אַ ניט-לאָך וועקטאָר פון ינטיידזשערז arr און אַ ינטיידזשער ק, צוריקקומען # >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)
add_elements <- function(arr, k) {","add_elements <- function(arr, k) {
  sum(arr[1:k][nchar(abs(arr[1:k])) <= 2])
}","test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()"
HumanEval_123,ydd_Hebr,r,"get_odd_collatz(5) גיט צוריק [1, 5] # די קאָללאַץ סיקווענסע פֿאַר 5 איז [5, 16, 8, 4, 2, 1], אַזוי די מאָדנע נומערן זענען בלויז 1, און 5. למשל: 2. צוריקגעגעבן רשימה סאָרטעד אין ינקריסינג סדר. 1. קאָללאַץ () איז [1]. באַמערקונג: דער משער איז אַז נישט קיין ענין וואָס ווערט פון n, די סיקוואַנס וועט שטענדיק דערגרייכן 1.אויב דער פריערדיקער טערמין איז פּאַרע, איז דער ווייַטער טערמין 3 מאל דער פריערדיקער.די פֿריִערדיקע טערמין איז אַזוי: אויב די פֿריִערדיקע טערמין איז פּאַרע, איז די קומענדיקע טערמין אַ האַלבֿ פֿון אזוי: אנהייבן מיט סיי וועלכע פאזיטיווע אינטעדזשער n. דערנאך ווערט יעדער טערם באקומען פון די די קאָלאַטזער השערה איז אַ השערה אין מאטעמאטיק וואָס באַטראכט אַ סעקווענץ וואָס איז דעפינירט געגעבן אַ positive integer n, צוריקקומען אַ סאָרטעד רשימה אַז האט די פּאַרע נומערן אין קאָללאַץ סיקוואַנס. # >>> get_odd_collatz(5)
# c(1, 5)
get_odd_collatz <- function(n) {","get_odd_collatz <- function(n) {
  collatz_sequence <- function(n) {
    sequence <- c(n)
    while (n != 1) {
      if (n %% 2 == 0) {
        n <- n / 2
      } else {
        n <- 3 * n + 1
      }
      sequence <- c(sequence, n)
    }
    return(sequence)
  }
  
  sequence <- collatz_sequence(n)
  odd_numbers <- unique(sequence[sequence %% 2 != 0])
  return(sort(odd_numbers))
}","test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()"
HumanEval_124,ydd_Hebr,r,"4. די דאַטע זאָל זיין אין די פֿאָרמאַט: מם-דד-ייי 3. די חדשים זאָל ניט זיין ווייניקער ווי 1 אָדער העכער ווי 12.2. די נומער פון טעג איז ניט ווייניקער ווי 1 אָדער העכער ווי 31 טעג פֿאַר חדשים 1,3,5,7,8,10,12. און די נומער פון טעג איז ניט ווייניקער ווי 1 אָדער העכער ווי 30 טעג פֿאַר חדשים 4,6,9,11. און, די נומער פון טעג איז ניט ווייניקער ווי 1 אָדער העכער ווי 29 פֿאַר די חודש 2. 1. די דאַטע שטריקל איז נישט ליידיק.די דאַטע איז גילטיק אויב אַלע פון די פאלגענדע כּללים זענען באגעגנט: צוריקקומען אמת אויב די דאַטע איז גילטיק אַנדערש פאַלש. איר האָבן צו שרייַבן אַ פונקציע וואָס וואַלאַדייץ אַ געגעבן דאַטע שטריקל און # >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE
valid_date <- function(date) {","valid_date <- function(date) {
  # Check if the date is not empty
  if (date == """") {
    return(FALSE)
  }
  
  # Check the format of the date
  if (!grepl(""^\\d{2}-\\d{2}-\\d{4}$"", date)) {
    return(FALSE)
  }
  
  # Extract the month, day, and year
  parts <- unlist(strsplit(date, ""-""))
  month <- as.numeric(parts[1])
  day <- as.numeric(parts[2])
  year <- as.numeric(parts[3])
  
  # Check if the month is valid
  if (month < 1 || month > 12) {
    return(FALSE)
  }
  
  # Check if the day is valid
  if (month %in% c(1, 3, 5, 7, 8, 10, 12) && (day < 1 || day > 31)) {
    return(FALSE)
  }
  
  if (month %in% c(4, 6, 9, 11) && (day < 1 || day > 30)) {
    return(FALSE)
  }
  
  if (month == 2 && (day < 1 || day > 29)) {
    return(FALSE)
  }
  
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()"
HumanEval_125,ydd_Hebr,r,"ביישפילן אַלפאַבע, אָרדאָ'אַ') = 0, אָרדאָ'ב') = 1, ... אָרדאָ'ז') = 25 זאָל צעטיילט אויף קאָמאַס ',' אויב קיין קאָמאַס יגזיסץ איר זאָל צוריקקומען די נומער פון קלענערער אותיות מיט מאָדנע סדר אין די געגעבן אַ שטריקל פון ווערטער, צוריקקומען אַ רשימה פון ווערטער שפּאַלטן אויף ווייץפּאַסעס, אויב קיין ווייץפּאַסעס עקסיסטירט אין דעם טעקסט איר # >>> split_words('Hello world!')
# c('Hello', 'world!')
# >>> split_words('Hello,world!')
# c('Hello', 'world!')
# >>> split_words('abcdef')
# 3
split_words <- function(txt) {","split_words <- function(txt) {
  if (grepl(""\\s"", txt)) {
    return(strsplit(txt, ""\\s+"")[[1]])
  } else if (grepl("","", txt)) {
    return(strsplit(txt, "","")[[1]])
  } else {
    odd_order_count <- sum(
      sapply(unlist(strsplit(txt, """")), function(x) {
        ord <- utf8ToInt(tolower(x)) - utf8ToInt(""a"")
        ord %% 2 == 1
      })
    )
    return(odd_order_count)
  }
}","test_humaneval <- function() {
    candidate <- split_words
    stopifnot(isTRUE(all.equal(candidate('Hello world!'), c('Hello', 'world!'))))
    stopifnot(isTRUE(all.equal(candidate('Hello,world!'), c('Hello', 'world!'))))
    stopifnot(isTRUE(all.equal(candidate('Hello world,!'), c('Hello', 'world,!'))))
    stopifnot(isTRUE(all.equal(candidate('Hello,Hello,world !'), c('Hello,Hello,world', '!'))))
    stopifnot(isTRUE(all.equal(candidate('abcdef'), 3)))
    stopifnot(isTRUE(all.equal(candidate('aaabb'), 2)))
    stopifnot(isTRUE(all.equal(candidate('aaaBb'), 1)))
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
}
test_humaneval()"
HumanEval_126,ydd_Hebr,r,"ביישפילן נומער, צוריקקומען FALSE. נעמט קיין נעגאַטיוו נומערן און בלויז ינטעדזשערז. אויב רשימה האט מער ווי 1 דופּליקאַט פון די זעלבע געגעבן אַ רשימה פון נומערן, צוריקקומען צי זיי זענען סאָרטעד אָדער ניט.# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE
is_sorted <- function(lst) {","is_sorted <- function(lst) {
  if (length(lst) <= 1) {
    return(TRUE)
  }
  
  # Check for duplicates more than once
  tbl <- table(lst)
  if (any(tbl > 2)) {
    return(FALSE)
  }
  
  # Check if the list is sorted in ascending order
  for (i in 2:length(lst)) {
    if (lst[i] < lst[i - 1]) {
      return(FALSE)
    }
  }
  
  return(TRUE)
}","test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()"
HumanEval_127,ydd_Hebr,r,"[אינפּוט/אַוטפּוט] סאַמפּאַלז: אויב די צוויי ינטערוואַלז טאָן ניט קרייַז, צוריקקומען ""ניין"". אַנדערש, צוריקקומען ""ניין"".אויב די לענג פון די ינטערסעקשאַן איז אַ פּריים נומער, צוריקקומען ""יעס"", וואָס איז 1 אין לענג, וואָס איז נישט אַ פּריים נומער.ביישפּיל, די ינטערסעקשאַן פון די ינטערוואַלז (1, 3), (2, 4) איז (2, 3) איז אַ פּריים נומער.דיין אַרבעט איז צו באַשליסן צי די לענג פון ינטערסעקשאַן פון די צוויי פֿאַר יעדער געגעבן ינטערוואַל, עס איז אנגענומען אַז זייַן אָנהייב איז ווייניקער אָדער גלייַך זייַן סוף. כולל ביידע אָנהייב און סוף. די געגעבן ינטערוואַלז זענען פארמאכט וואָס מיטל אַז די ינטערוואַל ( אָנהייב, סוף) וווּ יעדער אינטערוואַל איז אַ פּאָר פון ינטיידזשערז. למשל, אינטערוואַל = (התחלה, סוף) = (1, 2).איר זענט געגעבן צוויי ינטערוואַלז, # >>> intersection(c(1, 2), c(2, 3))
# 'NO'
# >>> intersection(c(-1, 1), c(0, 4))
# 'NO'
# >>> intersection(c(-3, -1), c(-5, 5))
# 'YES'
intersection <- function(interval1, interval2) {","intersection <- function(interval1, interval2) {
  start1 <- interval1[1]
  end1 <- interval1[2]
  start2 <- interval2[1]
  end2 <- interval2[2]
  
  # Determine the start and end of the intersection
  intersection_start <- max(start1, start2)
  intersection_end <- min(end1, end2)
  
  # Calculate the length of the intersection
  length_of_intersection <- intersection_end - intersection_start
  
  # If there's no intersection, return ""NO""
  if (length_of_intersection < 0) {
    return('NO')
  }
  
  # Check if the length is a prime number
  is_prime <- function(num) {
    if (num <= 1) {
      return(FALSE)
    }
    for (i in 2:sqrt(num)) {
      if (num %% i == 0) {
        return(FALSE)
      }
    }
    return(TRUE)
  }
  
  # Return ""YES"" if the length is prime, otherwise ""NO""
  if (is_prime(length_of_intersection)) {
    return('YES')
  } else {
    return('NO')
  }
}","test_humaneval <- function() {
    candidate <- intersection
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(2, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1), c(0, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(-3, -1), c(-5, 5)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(-2, 2), c(-4, 0)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(-11, 2), c(-1, -1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(3, 5)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(1, 2)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(-2, -2), c(-3, -2)), 'NO')))
}
test_humaneval()"
HumanEval_128,ydd_Hebr,r,"בייַשפּיל: באַמערקונג: צוריקקומען נול פֿאַר ליידיק אַרר. פון יעדער נומער אין דעם וועקטאָר, רעפּריזענטיד דורך 1, -1 אָדער 0. סכום פון מאַגנאַטודז פון ינטיידזשערז מאלד דורך פּראָדוקט פון אַלע וואונדער מען גיט דיר א וועקטאר אר פון אינטעדזשערס און דו דארפסט צוריקקומען # >>> prod_signs(c(1, 2, 2, -4))
# 9
# >>> prod_signs(c(0, 1))
# 0
# >>> prod_signs(c())
# NULL
prod_signs <- function(arr) {","prod_signs <- function(arr) {
  if (length(arr) == 0) {
    return(NULL)
  }
  magnitude_sum <- sum(abs(arr))
  sign_product <- prod(sign(arr))
  return(magnitude_sum * sign_product)
}","test_humaneval <- function() {
    candidate <- prod_signs
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, -4)), -9)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 2, 3, -1, 1)), -10)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 2, -1, -1, 9)), 20)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, -1, 1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 1)), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 0)), 0)))
}
test_humaneval()"
HumanEval_129,ydd_Hebr,r,"ביישפילן: צוריקקומען אַ אָרדערד רשימה פון די וואַלועס אויף די סעלז אַז די מינימום דרך גיין דורך. עס איז געראַנטיד אַז דער ענטפער איז יינציק.lst_A[j] = lst_B[j]. אַזאַ אַז lst_A[i] < lst_B[i] און פֿאַר קיין j (1 <= j < i) מיר האָבן ווי lst_B, אין אנדערע ווערטער, עס עקזיסטירט אַן אינטעדזשער אינדעקס i (1 <= i <= k) דורך (לאמיר זיי רופן lst_A און lst_B), lst_A איז לעקסיקאגראפיש ווייניקער נאָך מאכן די אָרדערד ליסטעס פון די וואַלועס אויף די סעלז אַז א און ב גיין א וועג א (פון לענג ק) איז באטראכט ווייניקער ווי א וועג ב (פון לענג ק) אויב איר קענט נישט גיין אויסער דעם רעטל.דאַווקע באַזונדער).ביטע טאָן אַז אַ דרך פון לענג k מיטל באזוכן פּונקט k סעלז (ניט צעל. אין אנדערע ווערטער, איר קענען גיין צו סעלז וואָס טיילן אַ ברעג מיט איר קראַנט פון קיין צעל, און אין יעדער שריט איר קענען מאַך צו קיין פון די שכנים סעלז, איר מוזט געפֿינען דעם מינימום וועג פון לענג k אין דעם גריד. איר קענט אָנהייבן ינקלוסיוו איז פּונקט אַמאָל אויף די סעלז פון די גריד. יעדער צעל אין דער גריד אנטהאלט א ווערט. יעדער אינטעדזשער אין דער ריי [1, N * N] געגעבן אַ גריד מיט N ראָוז און N קאָלאָנס (N >= 2) און אַ positive גאַנץ נומער k, # >>> minPath(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3)
# c(1, 2, 1)
# >>> minPath(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1)
# c(1)
minPath <- function(grid, k) {","minPath <- function(grid, k) {
  N <- length(grid)
  directions <- list(c(0, 1), c(1, 0), c(0, -1), c(-1, 0))
  
  is_valid <- function(x, y) {
    return(x >= 1 && x <= N && y >= 1 && y <= N)
  }
  
  # DFS to find all paths
  dfs <- function(x, y, path) {
    if (length(path) == k) {
      paths <<- append(paths, list(path))
      return()
    }
    
    for (direction in directions) {
      nx <- x + direction[1]
      ny <- y + direction[2]
      if (is_valid(nx, ny)) {
        dfs(nx, ny, c(path, grid[[nx]][[ny]]))
      }
    }
  }
  
  paths <- list()
  
  # Start from every cell
  for (i in 1:N) {
    for (j in 1:N) {
      dfs(i, j, c(grid[[i]][[j]]))
    }
  }
  
  # Find and return the lexicographically smallest path
  min_path <- paths[[1]]
  for (path in paths) {
    if (path < min_path) {
      min_path <- path
    }
  }
  
  return(min_path)
}","test_humaneval <- function() {
    candidate <- minPath
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3), c(1, 2, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4), c(5, 6, 7, 8), c(9, 10, 11, 12), c(13, 14, 15, 16)), 4), c(1, 2, 1, 2))))
    stopifnot(isTRUE(all.equal(candidate(list(c(6, 4, 13, 10), c(5, 7, 12, 1), c(3, 16, 11, 15), c(8, 14, 9, 2)), 7), c(1, 10, 1, 10, 1, 10, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(8, 14, 9, 2), c(6, 4, 13, 15), c(5, 7, 1, 12), c(3, 10, 11, 16)), 5), c(1, 7, 1, 7, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(11, 8, 7, 2), c(5, 16, 14, 4), c(9, 3, 15, 6), c(12, 13, 10, 1)), 9), c(1, 6, 1, 6, 1, 6, 1, 6, 1))))
    stopifnot(isTRUE(all.equal(candidate(list(c(12, 13, 10, 1), c(9, 3, 15, 6), c(5, 16, 14, 4), c(11, 8, 7, 2)), 12), c(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6))))
    stopifnot(isTRUE(all.equal(candidate(list(c(2, 7, 4), c(3, 1, 5), c(6, 8, 9)), 8), c(1, 3, 1, 3, 1, 3, 1, 3))))
    stopifnot(isTRUE(all.equal(candidate(list(c(6, 1, 5), c(3, 8, 9), c(2, 7, 4)), 8), c(1, 5, 1, 5, 1, 5, 1, 5))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2), c(3, 4)), 10), c(1, 2, 1, 2, 1, 2, 1, 2, 1, 2))))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 3), c(3, 2)), 10), c(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))))
}
test_humaneval()"
HumanEval_130,ydd_Hebr,r,"ביישפילן: די ערשטע n + 1 נומערן פון די טריבאָנאַקסי סיקווענסע. מען גיט דיר א נישט-נעגאטיווע אינטעדזשער נומער n, דו מוזט צוריקקומען א ליסטע פון די = 2 + 3 + 3 = 8 טרי(3) = טרי(2) + טרי(1) + טרי(4) טרי ((4) = 3 טרי(2) = 1 + (2 / 2) = 2 למשל: טרי (נ) = טרי (נ - 1) + טרי (נ - 2) + טרי (נ + 1), אויב n איז פּאַרע. טרי (נ) = 1 + נ / 2, אויב נ איז פּער. טרי(1) = 3 טריבאָנאַקי סיקוואַנס איז דעפינירט דורך די ריסידעראַנס: אָבער, וואָס מענטשן טאָן ניט וויסן איז טריבאָנאַצקי סיקוואַנס.יעדער ווייסט פיבאָנאַצקי סיקוואַנס, עס איז געווען שטאַרק געלערנט דורך מאַטעמאַטיקער אין # >>> tri(3)
# c(1, 3, 2, 8)
tri <- function(n) {","tri <- function(n) {
  if (n == 0) return(c(3))
  
  tribonacci <- numeric(n + 1)
  tribonacci[1] <- 3
  
  for (i in 2:(n + 1)) {
    if (i %% 2 == 0) {
      tribonacci[i] <- 1 + i / 2
    } else {
      if (i == 3) {
        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1]  # tri(3) requires tri(4)
      } else {
        # When i > 3 and i is odd, dependencies are always available
        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3 + 2]  # i + 1 becomes i - 3 + 2
      }
    }
  }
  
  return(tribonacci)
}","test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()"
HumanEval_131,ydd_Hebr,r,"למשל: צוריקקומען 0 אויב אַלע דידזשיץ זענען פּאַרע. געגעבן אַ positive גאַנץ נומער n, צוריקקומען די פּראָדוקט פון די פּאַרע דידזשיץ. # >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15
digits <- function(n) {","digits <- function(n) {
  # Convert the number to a character vector
  digits_vector <- unlist(strsplit(as.character(n), """"))
  
  # Convert the character vector back to numeric
  digits_vector <- as.numeric(digits_vector)
  
  # Filter out the odd digits
  odd_digits <- digits_vector[digits_vector %% 2 != 0]
  
  # If all digits are even, return 0
  if (length(odd_digits) == 0) {
    return(0)
  }
  
  # Calculate and return the product of odd digits
  return(prod(odd_digits))
}","test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()"
HumanEval_132,ydd_Hebr,r,"וווּ לפּחות איין בראַקעט אין די סאַבסעקווענסע איז נעסטיד. די פונקציע זאָל צוריקקומען TRUE אויב און בלויז אויב עס איז אַ גילטיק סאַבסעקווענסע פון בראַקאַץ שאַפֿן אַ פונקציע וואָס נעמט אַ שטריקל ווי ינפּוט וואָס כּולל בלויז קוואַדראַט בראַקאַץ. # >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE
is_nested <- function(string) {","is_nested <- function(string) {
  open_count <- 0
  for (char in unlist(strsplit(string, """"))) {
    if (char == ""["") {
      open_count <- open_count + 1
    } else if (char == ""]"") {
      if (open_count > 1) {
        return(TRUE)
      }
      open_count <- open_count - 1
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()"
HumanEval_133,ydd_Hebr,r,"ביישפילן: ראָונד יעדער עלעמענט אין דער רשימה צו די אויבערשטער int ((טאַפּ) ערשטער. איר דאַרפֿן צו צוריקקומען די סכום פון סקוואַדראַט נומערן אין די געגעבן רשימה, איר ווערט געגעבן אַ רשימה פֿון נומערן.# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6
sum_squares <- function(lst) {","sum_squares <- function(lst) {
  sum(ceiling(lst)^2)
}","test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()"
HumanEval_134,ydd_Hebr,r,"ביישפילן: באַמערקונג: ""וואָרט"" איז אַ גרופּע פון אותיות אפגעשיידט דורך פּלאַץ. אַ טייל פֿון אַ וואָרט, און FALSE אַנדערש. פון אַ געגעבן שטריקל איז אַן אַלפאַבעטיש כאַראַקטער און איז נישט שאַפֿן אַ פונקציע וואָס קערט TRUE אויב די לעצטע כאַראַקטער # >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE
check_if_last_char_is_a_letter <- function(txt) {","check_if_last_char_is_a_letter <- function(txt) {
  # Trim any trailing whitespace
  trimmed_txt <- trimws(txt, which = ""right"")
  
  # If the trimmed text is empty, return FALSE
  if (nchar(trimmed_txt) == 0) {
    return(FALSE)
  }
  
  # Get the last character
  last_char <- substr(trimmed_txt, nchar(trimmed_txt), nchar(trimmed_txt))
  
  # Check if the last character is an alphabetical character
  if (grepl(""[a-zA-Z]"", last_char)) {
    # Split the text by spaces
    words <- strsplit(trimmed_txt, "" "")[[1]]
    # Get the last word
    last_word <- tail(words, n = 1)
    # If last character is the only character in the last ""word"", return TRUE
    # Otherwise, it is part of a word, return FALSE
    return(nchar(last_word) == 1)
  }
  
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()"
HumanEval_135,ydd_Hebr,r,"ביישפילן: דופּליקאַט וואַלועס. קיין אַזאַ עלעמענט עקסיסטירט דעמאָלט צוריקקומען -1. די געגעבן וועקטאָר וועט נישט אַנטהאַלטן איז נישט גרעסער ווי אָדער גלייַך צו די עלעמענט גלייך פריערדיק עס. אויב שאַפֿן אַ פונקציע וואָס ריטורנס די גרעסטע אינדעקס פון אַן עלעמענט וואָס # >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
can_arrange <- function(arr) {","can_arrange <- function(arr) {
  for (i in seq(length(arr) - 1, 1)) {
    if (arr[i] > arr[i + 1]) {
      return(i)
    }
  }
  return(-1)
}","test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()"
HumanEval_136,ydd_Hebr,r,"ביישפילן: אויב עס איז קיין נעגאַטיוו אָדער positive ינטעדזשערז, צוריקקומען זיי ווי נול. פון positive integers אין אַ רשימה. די גרעסטע פון נעגאַטיוו אינטעדזשערס, און ""b"" איז די קלענסטע שאַפֿן אַ פונקציע וואָס קערט אַ רשימה (אַ, ב), ווו 'אַ' איז # >>> largest_smallest_integers(c(2, 4, 1, 3, 5, 7))
# list(NULL, 1)
# >>> largest_smallest_integers(c())
# list(NULL, NULL)
# >>> largest_smallest_integers(c(0))
# list(NULL, NULL)
largest_smallest_integers <- function(lst) {","largest_smallest_integers <- function(lst) {
  negatives <- lst[lst < 0]
  positives <- lst[lst > 0]
  
  largest_negative <- if(length(negatives) > 0) max(negatives) else NULL
  smallest_positive <- if(length(positives) > 0) min(positives) else NULL
  
  list(largest_negative, smallest_positive)
}","test_humaneval <- function() {
    candidate <- largest_smallest_integers
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7)), list(NULL, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7, 0)), list(NULL, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, -2)), c(-2, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 3, 6, 2, 7, -7)), c(-7, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(7, 3, 8, 4, 9, 2, 5, -9)), c(-9, 2))))
    stopifnot(isTRUE(all.equal(candidate(c()), list(NULL, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(0)), list(NULL, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6)), list(-1, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6, 0)), list(-1, NULL))))
    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, 1)), c(-3, 1))))
    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, -100, 1)), c(-3, 1))))
}
test_humaneval()"
HumanEval_137,ydd_Hebr,r,"באַמערקונג: אויב אַ רעאַל נומער איז רעפּריזענטיד ווי אַ שטריקל, די פלאָוטינג פונט קען זיין . אָדער , צוריקקומען נול אויב די וואַלועס זענען גלייַך. רעאַל נומערן, און קערט די גרעסערע בייַטעוודיק אין זייַן געגעבן בייַטעוודיק טיפּ. שאַפֿן אַ פונקציע וואָס נעמט ינטיידזשערז, פלאָאַטס, אָדער סטרינגס רעפּריזענטינג # >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
compare_one <- function(a, b) {","compare_one <- function(a, b) {
  to_number <- function(x) {
    if (is.character(x)) {
      x <- gsub("","", ""."", x)
      as.numeric(x)
    } else {
      as.numeric(x)
    }
  }
  
  a_num <- to_number(a)
  b_num <- to_number(b)
  
  if (a_num == b_num) {
    return(NULL)
  } else if (a_num > b_num) {
    return(a)
  } else {
    return(b)
  }
}","test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()"
HumanEval_138,ydd_Hebr,r,"ביישפּיל אָפּשאַצן צי די געגעבן נומער n קענען זיין געשריבן ווי די סומע פון פּונקט 4 positive פּער נומערן # >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
is_equal_to_sum_even <- function(n) {","is_equal_to_sum_even <- function(n) {
  if (n <= 0 || n %% 2 != 0 || n < 8) {
    return(FALSE)
  }
  remaining_sum <- n
  count <- 0
  for (i in seq(2, n, by = 2)) {
    if (remaining_sum - i >= 2 * (4 - count - 1)) {
      remaining_sum <- remaining_sum - i
      count <- count + 1
    }
    if (count == 4) {
      return(TRUE)
    }
  }
  return(FALSE)
}

# Examples
is_equal_to_sum_even(4)   # FALSE
is_equal_to_sum_even(6)   # FALSE
is_equal_to_sum_even(8)   # TRUE","test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()"
HumanEval_139,ydd_Hebr,r,"למשל: ווו n > 0 brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! דער בראַזיליאַן פאַקטאָריאַל איז דיפיינד ווי: # >>> special_factorial(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
special_factorial <- function(n) {","special_factorial <- function(n) {
  result <- 1
  for (i in 1:n) {
    result <- result * factorial(i)
  }
  return(result)
}","test_humaneval <- function() {
    candidate <- special_factorial
    stopifnot(isTRUE(all.equal(candidate(4), 288)))
    stopifnot(isTRUE(all.equal(candidate(5), 34560)))
    stopifnot(isTRUE(all.equal(candidate(7), 125411328000)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
}
test_humaneval()"
HumanEval_140,ydd_Hebr,r,"דעמאָלט פאַרבייַטן אַלע קאָנסעקוטיווע ספּייסיז מיט - און אויב אַ שטריקל האט מער ווי 2 קאָנסעקוטיווע ספּייסאַז, געגעבן אַ שטריקל טעקסט, פאַרבייַטן אַלע ספּייסאַז אין עס מיט אַנדערסקאָרעס, # >>> fix_spaces(' Example')
# 'Example'
# >>> fix_spaces(' Example 1')
# 'Example_1'
# >>> fix_spaces(' Example 2')
# '_Example_2'
# >>> fix_spaces(' Example 3')
# '_Example-3'
fix_spaces <- function(text) {","fix_spaces <- function(text) {
  # Trim leading and trailing spaces
  text <- trimws(text)
  # Replace 3 or more consecutive spaces with a dash
  text <- gsub("" {3,}"", ""-"", text)
  # Replace remaining spaces with underscores
  text <- gsub("" "", ""_"", text)
  return(text)
}","test_humaneval <- function() {
    candidate <- fix_spaces
    stopifnot(isTRUE(all.equal(candidate('Example'), 'Example')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')))
    stopifnot(isTRUE(all.equal(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')))
    stopifnot(isTRUE(all.equal(candidate('Exa   mple'), 'Exa-mple')))
    stopifnot(isTRUE(all.equal(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')))
}
test_humaneval()"
HumanEval_141,ydd_Hebr,r,"ביישפילן: - די סאַבסטראַנג נאָך די פונט זאָל זיין איינער פון די: ['טקסט', 'עקסע', 'דל'] די לאַטייַן אַלפאַבעט ('אַ'-'ז' און 'אַ'-'ז'). - די סאַבסטראַנג איידער די פונט זאָל ניט זיין ליידיק, און עס הייבט מיט אַ בריוו פון - דער פֿיילן ס נאָמען כּולל פּונקט איין פּונקט '.' - עס זאָל ניט זיין מער ווי דרייַ דידזשיץ ('0'-'9') אין די טעקע 'ס נאָמען. זענען באגעגנט: א טעקע ס נאָמען איז באטראכט צו זיין גילטיק אויב און בלויז אויב אַלע די פאלגענדע באדינגונגען 'יא' אויב די די טעקע ס נאָמען איז גילטיק, און ריטורנס 'ניין' אַנדערש. שאַפֿן אַ פונקציע וואָס נעמט אַ שטריקל רעפּריזענטינג אַ טעקע ס נאָמען, און ריטורנס # >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'
file_name_check <- function(file_name) {","file_name_check <- function(file_name) {
  # Split the file name into the name part and the extension part
  parts <- strsplit(file_name, ""\\."", fixed = TRUE)[[1]]
  
  # Check there is exactly one dot
  if (length(parts) != 2) {
    return('No')
  }
  
  # Extract the name and extension
  name_part <- parts[1]
  ext_part <- parts[2]
  
  # Check the extension is valid
  if (!(ext_part %in% c('txt', 'exe', 'dll'))) {
    return('No')
  }
  
  # Check the name part is not empty and starts with a letter
  if (nchar(name_part) == 0 || !grepl(""^[A-Za-z]"", name_part)) {
    return('No')
  }
  
  # Count digits in the name part
  digit_count <- nchar(gsub(""[^0-9]"", """", name_part))
  
  # Check there are no more than three digits
  if (digit_count > 3) {
    return('No')
  }
  
  return('Yes')
}","test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()"
HumanEval_142,ydd_Hebr,r,"ביישפילן: טוישן די ענטריס אין דער רשימה וועמענס ינדעקסעס זענען נישט אַ קייפל פון 3 אָדער 4. די פונקציע וועט דעמאָלט צוריקקומען די סומע פון אַלע ענטריס. א מעריב פון 3 און וועט קובירן די אינטעדזשער אריינגאנג אויב זיין אינדעקס איז א מעריב פון 4 און נישט א מעריב פון 3. די פונקציע וועט נישט די פונקציע וועט נעמען א ליסטע פון אינטעדזשערס. פאר אלע ארטיקלען אין דער ליסטע, די פונקציע וועט קוואדראטירן די אינטעדזשער ארטיקל אויב איר אינדעקס איז א "" # >>> lst
# c(1, 2, 3)
# >>> lst
# c()
# >>> lst
# c(-1, -5, 2, -1, -5)
sum_squares <- function(lst) {","sum_squares <- function(lst) {
  lst <- sapply(seq_along(lst), function(i) {
    if (i %% 3 == 0) {
      return(lst[i]^2)
    } else if (i %% 4 == 0) {
      return(lst[i]^3)
    } else {
      return(lst[i])
    }
  })
  return(sum(lst))
}","test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 9)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 1, 1, 1, 1, 1)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -1, -1, -1, -1, -1, -1, -1, -1)), -3)))
    stopifnot(isTRUE(all.equal(candidate(c(0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -5, 2, -1, -5)), -126)))
    stopifnot(isTRUE(all.equal(candidate(c(-56, -99, 1, 0, -2)), 3030)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 0, 0, 0, 0, 0, 0, -1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)), -14196)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)), -1448)))
}
test_humaneval()"
HumanEval_143,ydd_Hebr,r,"בייַשפּיל 1: די סדר פון די ווערטער אין די נייַע שטריקל זאָל זיין די זעלבע ווי די אָריגינעל. וועמענס לענג זענען פריים נומערן, און איר האָבן צו צוריקקומען אַ שטריקל אַז כּולל די ווערטער פון די אָריגינעל זאַץ, דער זאַץ כּולל עטלעכע ווערטער אפגעשיידט דורך אַ פּלאַץ, מען גיט א שטריקל וואס רעפרעזענטירט א זאץ,# >>> words_in_sentence('This is a test')
# 'is'
# Example 2:
# >>> words_in_sentence('lets go for swimming')
# 'go for'
# Constraints:
#     * 1 <= len(sentence) <= 100
#     * sentence contains only letters
words_in_sentence <- function(sentence) {","words_in_sentence <- function(sentence) {
  is_prime <- function(n) {
    if (n <= 1) return(FALSE)
    if (n == 2) return(TRUE)
    for (i in 2:sqrt(n)) {
      if (n %% i == 0) return(FALSE)
    }
    return(TRUE)
  }
  
  words <- strsplit(sentence, "" "")[[1]]
  prime_words <- words[sapply(words, function(word) is_prime(nchar(word)))]
  return(paste(prime_words, collapse = "" ""))
}","test_humaneval <- function() {
    candidate <- words_in_sentence
    stopifnot(isTRUE(all.equal(candidate('This is a test'), 'is')))
    stopifnot(isTRUE(all.equal(candidate('lets go for swimming'), 'go for')))
    stopifnot(isTRUE(all.equal(candidate('there is no place available here'), 'there is no place')))
    stopifnot(isTRUE(all.equal(candidate('Hi I am Hussein'), 'Hi am Hussein')))
    stopifnot(isTRUE(all.equal(candidate('go for it'), 'go for it')))
    stopifnot(isTRUE(all.equal(candidate('here'), '')))
    stopifnot(isTRUE(all.equal(candidate('here is'), 'is')))
}
test_humaneval()"
HumanEval_144,ydd_Hebr,r,"איר קענט אננעמען אז x, און n זענען גילטיגע ברעקלעך, און האבן נישט זערא אלס נומענאטאר.<נאַמעראַטאָר>/<דענאָמינאַטאָר> ווו ביידע נומעראַטאָר און נומענאַטאָר זענען positive גאַנץ נומערן. ביידע x און n, זענען סטרינג רעפּראַזענטאַציע פון אַ בראָך, און האָבן די פאלגענדע פֿאָרמאַט, x * n. די פונקציע ריטורנס TRUE אויב x * n עוואַלואַטעס צו אַ גאַנץ נומער און FALSE דיין אַרבעט איז צו ימפּלאַמענט אַ פונקציע וואָס וועט פאַרפּשוטן דעם אויסדרוק # >>> simplify('1/5', '5/1')
# TRUE
# >>> simplify('1/6', '2/1')
# FALSE
# >>> simplify('7/10', '10/2')
# FALSE
simplify <- function(x, n) {","simplify <- function(x, n) {
  parse_fraction <- function(fraction) {
    parts <- strsplit(fraction, ""/"")[[1]]
    return(as.numeric(parts[1]) / as.numeric(parts[2]))
  }
  
  x_value <- parse_fraction(x)
  n_value <- parse_fraction(n)
  
  product <- x_value * n_value
  
  # Check if the product is a whole number
  return(product == floor(product))
}","test_humaneval <- function() {
    candidate <- simplify
    stopifnot(isTRUE(all.equal(candidate('1/5', '5/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('1/6', '2/1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('5/1', '3/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('7/10', '10/2'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2/10', '50/10'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('7/2', '4/2'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('11/6', '6/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('2/3', '5/2'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('5/2', '3/5'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2/4', '8/4'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('2/4', '4/2'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('1/5', '5/1'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('1/5', '1/5'), FALSE)))
}
test_humaneval()"
HumanEval_145,ydd_Hebr,r,"למשל: סדר זיי באזירט אויף זייער אינדעקס אין אָריגינעל רשימה. באַמערקונג: אויב עס זענען עטלעכע זאכן מיט ענלעך סומע פון זייער דידזשיץ, אין אַקסענדינג סדר לויט צו די סומע פון זייער דידזשיץ. שרײַבן אַ פֿונקציע וואָס סאָרטירט די געגעבןע ליסטע פון אינטעדזשערס # >>> order_by_points(c(1, 11, -1, -11, -12))
# c(-1, -11, 1, -12, 11)
# >>> order_by_points(c())
# c()
order_by_points <- function(nums) {","order_by_points <- function(nums) {
  # Helper function to calculate the sum of digits
  sum_of_digits <- function(n) {
    sum(as.integer(unlist(strsplit(as.character(abs(n)), """"))))
  }
  
  # Order the numbers based on the sum of their digits first, 
  # and then by their original index
  indices <- seq_along(nums)
  nums[order(sapply(nums, sum_of_digits), indices)]
}","test_humaneval <- function() {
    candidate <- order_by_points
    stopifnot(isTRUE(all.equal(candidate(c(1, 11, -1, -11, -12)), c(-1, -11, 1, -12, 11))))
    stopifnot(isTRUE(all.equal(candidate(c(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)), c(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457))))
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, -11, -32, 43, 54, -98, 2, -3)), c(-3, -32, -98, -11, 1, 2, 43, 54))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), c(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9))))
    stopifnot(isTRUE(all.equal(candidate(c(0, 6, 6, -76, -21, 23, 4)), c(-76, -21, 0, 4, 23, 6, 6))))
}
test_humaneval()"
HumanEval_146,ydd_Hebr,r,"למשל: די ערשטע און לעצטע ציפערן פון א נומער זענען אומגעלייגט (1, 3, 5, 7, 9).די נומער פון עלעמענטן אין דעם וועקטאָר וואָס זענען גרעסער ווי 10 און ביידע שרײַבן אַ פֿונקציע וואָס נעמט אַ וועקטאָר פון נומערן ווי אַרייַנפיר און קערט צוריק # >>> specialFilter(c(15, -73, 14, -15))
# 1
# >>> specialFilter(c(33, -2, -3, 45, 21, 109))
# 2
specialFilter <- function(nums) {","specialFilter <- function(nums) {
  # Helper function to check if both first and last digits are odd
  are_first_last_digits_odd <- function(x) {
    str_num <- as.character(abs(x))
    first_digit <- as.numeric(substr(str_num, 1, 1))
    last_digit <- as.numeric(substr(str_num, nchar(str_num), nchar(str_num)))
    first_digit %% 2 == 1 && last_digit %% 2 == 1
  }

  # Filter numbers greater than 10 with both first and last digits odd
  filtered_nums <- nums[nums > 10 & sapply(nums, are_first_last_digits_odd)]
  
  # Return the count of such numbers
  length(filtered_nums)
}","test_humaneval <- function() {
    candidate <- specialFilter
    stopifnot(isTRUE(all.equal(candidate(c(5, -2, 1, -5)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(15, -73, 14, -15)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(33, -2, -3, 45, 21, 109)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(43, -12, 93, 125, 121, 109)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(71, -2, -33, 75, 21, 19)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
}
test_humaneval()"
HumanEval_147,ydd_Hebr,r,"בייַשפּיל: און אַ[י] + אַ[י] + אַ[ק] איז אַ קייפל פון 3.צוריקקומען די נומער פון טריפּאַלז (אַ [י], אַ [דזש], אַ [ק]) פון אַ ווו איך < דזש < ק, פֿאַר יעדער איך (1 ≤ איך ≤ נ), די ווערט פון אַ [איך] = איך * איך - איך + 1. מען גיט א פאזיטיווע אינטעדזשער n. מען דארף מאכן א אינטעדזשער וועקטאר a פון לאנגקייט n.#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
get_max_triples <- function(n) {","get_max_triples <- function(n) {
  # Create the vector a according to the given rule
  a <- sapply(1:n, function(i) i * i - i + 1)
  
  # Initialize the count of valid triples
  count <- 0
  
  # Iterate over all possible triples (i, j, k) with i < j < k
  for (i in 1:(n-2)) {
    for (j in (i+1):(n-1)) {
      for (k in (j+1):n) {
        # Check if the sum of the selected triple is a multiple of 3
        if ((a[i] + a[j] + a[k]) %% 3 == 0) {
          count <- count + 1
        }
      }
    }
  }
  
  # Return the count of valid triples
  return(count)
}","test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()"
HumanEval_148,ydd_Hebr,r,"ביישפילן זענען נישט ריכטיקע פּלאַנעט נעמען.די פונקציע זאָל צוריקקומען אַ ליידיק רשימה אויב planet1 אָדער planet2 די נאָענטקייט צו דער זון.געפינט זיך צווישן דער אָרביט פון פּלאַנעט 1 און דער אָרביט פון פּלאַנעט 2, סאָרטירט דורך די פונקציע זאָל צוריקקומען אַ רשימה מיט אַלע פּלאַנאַץ וועמענס אָרביטעס זענען שרײַבן אַ פונקציע וואָס נעמט צוויי פּלאַנעט נעמען ווי סטרינגס פּלאַנעט1 און פּלאַנעט2. אוראן, נעפטון.איז מערקורי, דער ווייַטער איינער איז ווענוס, דעמאָלט ערד, מאַרס, דזשופּיטער, סאַטורן,עס זענען אַכט פּלאַנאַץ אין אונדזער זון סיסטעם: די קלאָוסאַסט צו די זון # >>> bf('Jupiter', 'Neptune')
# c('Saturn', 'Uranus')
# >>> bf('Earth', 'Mercury')
# 'Venus'
# >>> bf('Mercury', 'Uranus')
# c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')
bf <- function(planet1, planet2) {","bf <- function(planet1, planet2) {
  planets <- c('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')
  if (!(planet1 %in% planets) || !(planet2 %in% planets)) {
    return(c())
  }
  
  index1 <- which(planets == planet1)
  index2 <- which(planets == planet2)
  
  if (index1 < index2) {
    return(planets[(index1 + 1):(index2 - 1)])
  } else if (index2 < index1) {
    return(planets[(index2 + 1):(index1 - 1)])
  } else {
    return(c())
  }
}","test_humaneval <- function() {
    candidate <- bf
    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Neptune'), c('Saturn', 'Uranus'))))
    stopifnot(isTRUE(all.equal(candidate('Earth', 'Mercury'), c('Venus'))))
    stopifnot(isTRUE(all.equal(candidate('Mercury', 'Uranus'), c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'))))
    stopifnot(isTRUE(all.equal(candidate('Neptune', 'Venus'), c('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'))))
    stopifnot(isTRUE(all.equal(candidate('Earth', 'Earth'), c())))
    stopifnot(isTRUE(all.equal(candidate('Mars', 'Earth'), c())))
    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Makemake'), c())))
}
test_humaneval()"
HumanEval_149,ydd_Hebr,r,"למשל: איר קענט זיך דערוואַרטן אַז אַלע ווערטער וועלן האָבן די זעלבע לענג.די פונקציע זאָל צוריקקומען אַ רשימה פון סטרינגס אין סאָרטעד סדר. אויב צוויי ווערטער האָבן די זעלבע לענג, סאָרט די רשימה אַלפאַבעטיקלי. זאָל צוריקקומען די רשימה סאָרטעד דורך אַז הערשן. די סדר פֿון דער רשימה זאָל זיין אַרויפֿגייענדיק לויט די לענג פֿון יעדן וואָרט, און איר און עס קען אַנטהאַלטן דופּליקאַטן.די ליסטע איז שטענדיק אַ ליסטע פון סטרינגס און קיינמאָל אַ וועקטאָר פון נומערן,און קערט די ריזאַלטיד רשימה מיט אַ סאָרטעד סדר, דיליץ די סטרינגס וואָס האָבן פּאַרד לענג פון עס, שרײַבן אַ פֿונקציע וואָס נעמט אַן רשימה פֿון סטרינגס ווי אַ פּאַראַמעטער, # >>> list_sort(c('aa', 'a', 'aaa'))
# c('aa')
# >>> list_sort(c('ab', 'a', 'aaa', 'cd'))
# c('ab', 'cd')
sorted_list_sum <- function(lst) {","list_sort <- function(lst) {
  # Filter out strings with odd lengths
  filtered_list <- lst[nchar(lst) %% 2 == 0]
  
  # Sort the list first by length, then alphabetically
  sorted_list <- filtered_list[order(nchar(filtered_list), filtered_list)]
  
  return(sorted_list)
}","test_humaneval <- function() {
    candidate <- sorted_list_sum
    stopifnot(isTRUE(all.equal(candidate(c('aa', 'a', 'aaa')), c('aa'))))
    stopifnot(isTRUE(all.equal(candidate(c('school', 'AI', 'asdf', 'b')), c('AI', 'asdf', 'school'))))
    stopifnot(isTRUE(all.equal(candidate(c('d', 'b', 'c', 'a')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('d', 'dcba', 'abcd', 'a')), c('abcd', 'dcba'))))
    stopifnot(isTRUE(all.equal(candidate(c('AI', 'ai', 'au')), c('AI', 'ai', 'au'))))
    stopifnot(isTRUE(all.equal(candidate(c('a', 'b', 'b', 'c', 'c', 'a')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('aaaa', 'bbbb', 'dd', 'cc')), c('cc', 'dd', 'aaaa', 'bbbb'))))
}
test_humaneval()"
HumanEval_150,ydd_Hebr,r,"ביישפילן: אַ פּירימאַל נומער און זאָל צוריקקומען די ווערט פון y אַנדערש. א פּשוטע פּראָגראַם וואָס זאָל צוריקקומען די ווערט פון x אויב n איז # >>> x_or_y(7, 34, 12)
# 34
# >>> x_or_y(15, 8, 5)
# 5
x_or_y <- function(n, x, y) {","x_or_y <- function(n, x, y) {
  is_prime <- function(num) {
    if (num <= 1) {
      return(FALSE)
    }
    for (i in 2:sqrt(num)) {
      if (num %% i == 0) {
        return(FALSE)
      }
    }
    return(TRUE)
  }
  
  if (is_prime(n)) {
    return(x)
  } else {
    return(y)
  }
}","test_humaneval <- function() {
    candidate <- x_or_y
    stopifnot(isTRUE(all.equal(candidate(7, 34, 12), 34)))
    stopifnot(isTRUE(all.equal(candidate(15, 8, 5), 5)))
    stopifnot(isTRUE(all.equal(candidate(3, 33, 5212), 33)))
    stopifnot(isTRUE(all.equal(candidate(1259, 3, 52), 3)))
    stopifnot(isTRUE(all.equal(candidate(7919, -1, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(3609, 1245, 583), 583)))
    stopifnot(isTRUE(all.equal(candidate(91, 56, 129), 129)))
    stopifnot(isTRUE(all.equal(candidate(6, 34, 1234), 1234)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 0), 0)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 0), 2)))
}
test_humaneval()"
HumanEval_151,ydd_Hebr,r,"איגנארירן נומערן וואס זענען נעגאַטיוו אדער נישט אינטעדזשערס.געגעבן אַ רשימה פון נומערן, צוריקקומען די סכום פון סקוואַדראַץ פון די נומערן # >>> double_the_difference(c(1, 3, 2, 0))
# 10
# >>> double_the_difference(c(-1, -2, 0))
# 0
# >>> double_the_difference(c(9, -2))
# 81
# >>> double_the_difference(c(0))
# 0
# If the input list is empty, return 0.
double_the_difference <- function(lst) {","double_the_difference <- function(lst) {
  # Filter out non-positive, non-integer, and non-odd numbers
  lst <- lst[lst > 0 & lst %% 1 == 0 & lst %% 2 == 1]
  # Calculate the sum of squares of remaining numbers
  sum(lst^2)
}","test_humaneval <- function() {
    candidate <- double_the_difference
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5.0, 4.0)), 25)))
    stopifnot(isTRUE(all.equal(candidate(c(0.1, 0.2, 0.3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-10.0, -20.0, -30.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, -2.0, 8.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0.2, 3.0, 5.0)), 34)))
    stopifnot(isTRUE(all.equal(candidate(c(-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0)), 165)))
}
test_humaneval()"
HumanEval_152,ydd_Hebr,r,"בייַשפּיל: דער ווערט איז 0, און אויב נישט, דער ווערט איז די אַבסאָלוט חילוק צווישן די טרעפן און די כעזשבן. צוריקקומען אַ וועקטאָר פון דער זעלביקער לענג דענאָטינג ווי ווייַט אַוועק יעדער טרעפן איז געווען. אויב זיי האָבן געמיינט ריכטיק, מען גיט איר צוויי וועקטאָרס פון סקאָרז און געסעס פון גלייַך לענג, וווּ יעדער אינדעקס ווייזט אַ גלייַכן.א מענטש האָט גערעכט געטראַכט די רעזולטאַטן פֿון אַ סך גלײַכן.אַפֿילו די פּינטלעך זענען געווען אַפֿילו אין די יו.די געפילן און געדאנקען וואָס איר האָט אין דעם מאָמענט זענעןאיך מיין מיר געדענקען אַלע אַז געפיל ווען דער רעזולטאַט פון עטלעכע לאַנג-וואַרטעד # >>> compare(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2))
# c(0, 0, 0, 0, 3, 3)
# >>> compare(c(0, 5, 0, 0, 0, 4), c(4, 1, 1, 0, 0, -2))
# c(4, 4, 1, 0, 0, 6)
compare <- function(game, guess) {","compare <- function(game, guess) {
  abs(game - guess)
}","test_humaneval <- function() {
    candidate <- compare
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2)), c(0, 0, 0, 0, 3, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(0, 0, 0, 0, 0, 0), c(0, 0, 0, 0, 0, 0)), c(0, 0, 0, 0, 0, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), c(-1, -2, -3)), c(2, 4, 6))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5), c(-1, 2, 3, 4)), c(2, 0, 0, 1))))
}
test_humaneval()"
HumanEval_153,ydd_Hebr,r,"בייַשפּיל: (זייער שטאַרקייַט איז -1). צוריקקומען ""סלייסיז. סערווינגסליסיז"" זינט ""סערווינגסליסיז"" איז די סטראָנגעסט פאַרלענגערונג עקסטענשאַנז: ['SERVINGSliCes', 'Cheese', 'StuFfed'] דעמאָלט איר זאָל למשל, אויב איר זענט געגעבן ""סלייסעס"" ווי די קלאַס און אַ רשימה פון די אויסקלײַב די ערשטע אין דער ליסטע.אויב עס זענען צוויי אָדער מער עקסטענשאַנז מיט די זעלבע שטאַרקייַט, איר זאָל פֿאָרמאַט: ClassName.StrongestExtensionName. איר זאָל געפֿינען די סטראָנגעסט פאַרלענגערונג און צוריקקומען אַ שטריקל אין דעם אין דער נאָמען פון דער עקסטענשאַן, די שטאַרקייַט איז געגעבן דורך די בראָך CAP - SM. אותיות אין דער עקסטענסיע ס נאָמען, און לאָזן סם זיין די נומער פון קליינע אותיות שטאַרקייַט פון די פאַרלענגערונג איז ווי גייט: זאל CAP זיין די נומער פון די אַפּפּערקאַסער די עקסטענשאַנז זענען צו זיין געניצט צו לאָדן נאָך קלאסן צו די קלאַס. די איר וועט באַקומען די נאָמען פון אַ קלאַס (אַ שטריקל) און אַ רשימה פון עקסטענשאַנז. # >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'
Strongest_Extension <- function(class_name, extensions) {","Strongest_Extension <- function(class_name, extensions) {
  # Function to calculate the strength of an extension
  extension_strength <- function(ext) {
    cap_count <- sum(grepl(""[A-Z]"", strsplit(ext, """")[[1]]))
    sm_count <- sum(grepl(""[a-z]"", strsplit(ext, """")[[1]]))
    return(cap_count - sm_count)
  }
  
  # Calculate strength for each extension and find the strongest one
  strengths <- sapply(extensions, extension_strength)
  max_strength_index <- which.max(strengths)
  
  # Construct the result string
  return(paste0(class_name, ""."", extensions[max_strength_index]))
}","test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()"
HumanEval_154,ydd_Hebr,r,"איר זענט געגעבן 2 ווערטער. איר דאַרפֿן צו צוריקקומען אמת אויב די רגע וואָרט אָדער קיין פון זייַן ראָוטיישאַנז איז אַ סאַבסטראַנג אין דער ערשטער וואָרט # >>> cycpattern_check('abcd', 'abd')
# FALSE
# >>> cycpattern_check('hello', 'ell')
# TRUE
# >>> cycpattern_check('whassup', 'psus')
# FALSE
# >>> cycpattern_check('abab', 'baa')
# TRUE
# >>> cycpattern_check('efef', 'eeff')
# FALSE
# >>> cycpattern_check('himenss', 'simen')
# TRUE
cycpattern_check <- function(a, b) {","cycpattern_check <- function(a, b) {
  n <- nchar(b)
  # Check all rotations of b
  for (i in 0:(n-1)) {
    # Rotate the string b by i characters
    rotated_b <- substring(b, i+1, n) %/% substring(b, 1, i)
    # Check if the rotated string is a substring of a
    if (grepl(rotated_b, a)) {
      return(TRUE)
    }
  }
  return(FALSE)
}","test_humaneval <- function() {
    candidate <- cycpattern_check
    stopifnot(isTRUE(all.equal(candidate('xyzw', 'xyw'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('yello', 'ell'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('whattup', 'ptut'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('efef', 'fee'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abab', 'aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('winemtt', 'tinem'), TRUE)))
}
test_humaneval()"
HumanEval_155,ydd_Hebr,r,"בייַשפּיל: געגעבן אַ ינטיידזשער. צוריקקומען אַ רשימה אַז האט די נומער פון פּאַרע און מאָדנע דידזשיץ ריספּעקטיוולי. #     >>> even_odd_count(-12)
#     c(1, 1)
#     >>> even_odd_count(123)
#     c(1, 2)
even_odd_count <- function(num) {","even_odd_count <- function(num) {
  # Handle negative numbers by taking the absolute value
  num <- abs(num)
  
  # Convert the number to a character vector to access digits
  digits <- unlist(strsplit(as.character(num), """"))
  
  # Convert character vector back to integer
  digits <- as.integer(digits)
  
  # Count even digits
  even_count <- sum(digits %% 2 == 0)
  
  # Count odd digits
  odd_count <- length(digits) - even_count
  
  # Return a vector with even and odd counts
  return(c(even_count, odd_count))
}","test_humaneval <- function() {
    candidate <- even_odd_count
    stopifnot(isTRUE(all.equal(candidate(7), c(0, 1))))
    stopifnot(isTRUE(all.equal(candidate(-78), c(1, 1))))
    stopifnot(isTRUE(all.equal(candidate(3452), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(346211), c(3, 3))))
    stopifnot(isTRUE(all.equal(candidate(-345821), c(3, 3))))
    stopifnot(isTRUE(all.equal(candidate(-2), c(1, 0))))
    stopifnot(isTRUE(all.equal(candidate(-45347), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1, 0))))
}
test_humaneval()"
HumanEval_156,ydd_Hebr,r,"ביישפילן: באַגרענעצונגען: 1 <= num <= 1000 און צוריקקומען עס אין קליינע אותיות.געגעבען אַ positive גאַנץ נומער, באַקומען זייַן רוימישע נומעראַל עקוויוואַלענט ווי אַ שטריקל, # >>> int_to_mini_roman(19)
# 'xix'
# >>> int_to_mini_roman(152)
# 'clii'
# >>> int_to_mini_roman(426)
# 'cdxxvi'
int_to_mini_roman <- function(number) {","int_to_mini_roman <- function(number) {
  values <- c(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
  numerals <- c(""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i"")
  
  result <- """"
  remainder <- number
  
  for (i in seq_along(values)) {
    while (remainder >= values[i]) {
      result <- paste0(result, numerals[i])
      remainder <- remainder - values[i]
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- int_to_mini_roman
    stopifnot(isTRUE(all.equal(candidate(19), 'xix')))
    stopifnot(isTRUE(all.equal(candidate(152), 'clii')))
    stopifnot(isTRUE(all.equal(candidate(251), 'ccli')))
    stopifnot(isTRUE(all.equal(candidate(426), 'cdxxvi')))
    stopifnot(isTRUE(all.equal(candidate(500), 'd')))
    stopifnot(isTRUE(all.equal(candidate(1), 'i')))
    stopifnot(isTRUE(all.equal(candidate(4), 'iv')))
    stopifnot(isTRUE(all.equal(candidate(43), 'xliii')))
    stopifnot(isTRUE(all.equal(candidate(90), 'xc')))
    stopifnot(isTRUE(all.equal(candidate(94), 'xciv')))
    stopifnot(isTRUE(all.equal(candidate(532), 'dxxxii')))
    stopifnot(isTRUE(all.equal(candidate(900), 'cm')))
    stopifnot(isTRUE(all.equal(candidate(994), 'cmxciv')))
    stopifnot(isTRUE(all.equal(candidate(1000), 'm')))
}
test_humaneval()"
HumanEval_157,ydd_Hebr,r,"בייַשפּיל: 90 גראַד. אַ רעקטאַנגגאַל טריאַנגגאַל איז אַ טריאַנגגאַל אין וואָס איין ווינקל איז רעכט ווינקל אָדער זייטן פֿאָרמירן אַ ריכט-ווינגלדיק דרייַעק, אַנדערש איז דאָס פאַלש.געגעבן די לענג פון די דריי זייטן פון א דרייקעלע. צוריקקומען אמת אויב די דריי # >>> right_angle_triangle(3, 4, 5)
# TRUE
# >>> right_angle_triangle(1, 2, 3)
# FALSE
right_angle_triangle <- function(a, b, c) {","right_angle_triangle <- function(a, b, c) {
  # Sort the sides to easily compare the largest side
  sides <- sort(c(a, b, c))
  
  # Check if the sum of squares of the two smaller sides equals the square of the largest side
  return(sides[1]^2 + sides[2]^2 == sides[3]^2)
}","test_humaneval <- function() {
    candidate <- right_angle_triangle
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(10, 6, 8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(7, 24, 25), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(5, 12, 13), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(15, 8, 17), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(48, 55, 73), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), FALSE)))
}
test_humaneval()"
HumanEval_158,ydd_Hebr,r,"אותיות, צוריקקומען די וואָס קומט ערשטער אין לעקסיקאָגראַפיקאַל סדר. אויב קייפל סטרינגס האָבן מאַקסימום נומער פון די ליסטע כּולל פאַרשידענע ווערטער. צוריקקומען די וואָרט מיט מאַקסימום נומער שרײַבן אַ פֿונקציע וואָס אָננעמט אַ רשימה פון שטריכן. # >>> find_max(c('name', 'of', 'string'))
# 'string'
# >>> find_max(c('name', 'enam', 'game'))
# 'enam'
# >>> find_max(c('aaaaaaa', 'bb', 'cc'))
# 'aaaaaaa'
find_max <- function(words) {","find_max <- function(words) {
  max_unique_chars <- 0
  result <- """"
  
  for (word in words) {
    unique_chars_count <- length(unique(strsplit(word, NULL)[[1]]))
    
    if (unique_chars_count > max_unique_chars ||
       (unique_chars_count == max_unique_chars && word < result)) {
      max_unique_chars <- unique_chars_count
      result <- word
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- find_max
    stopifnot(isTRUE(all.equal(candidate(c('name', 'of', 'string')), 'string')))
    stopifnot(isTRUE(all.equal(candidate(c('name', 'enam', 'game')), 'enam')))
    stopifnot(isTRUE(all.equal(candidate(c('aaaaaaa', 'bb', 'cc')), 'aaaaaaa')))
    stopifnot(isTRUE(all.equal(candidate(c('abc', 'cba')), 'abc')))
    stopifnot(isTRUE(all.equal(candidate(c('play', 'this', 'game', 'of', 'footbott')), 'footbott')))
    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'gonna', 'rock')), 'gonna')))
    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'a', 'mad', 'nation')), 'nation')))
    stopifnot(isTRUE(all.equal(candidate(c('this', 'is', 'a', 'prrk')), 'this')))
    stopifnot(isTRUE(all.equal(candidate(c('b')), 'b')))
    stopifnot(isTRUE(all.equal(candidate(c('play', 'play', 'play')), 'play')))
}
test_humaneval()"
HumanEval_159,ydd_Hebr,r,"בייַשפּיל: אויב עס זענען נישט גענוג איבערגעבליבענע קעראַץ, וועט איר עסן אַלע איבערגעבליבענע קעראַץ, אָבער וועט נאָך זיין הונגעריק.די נומער פון קעראַץ לינקס נאָך דיין מילז ] איר זאָל צוריקקומען אַ וועקטאָר פון [ גאַנץ נומער פון געגעסן קעראַץ נאָך דיין מילז, אָבער איצט דאַרף איר עסן מער קעראַץ צו פאַרענדיקן די מאָלצייַט פֿאַר דעם טאָג.דו ביסט אַ הונגעריקע ראַבאַט, און דו האָסט שוין געגעסן אַ געוויסע צאָל קעראַץ,# >>> eat(5, 6, 10)
# c(11, 4)
# >>> eat(4, 8, 9)
# c(12, 1)
# >>> eat(1, 10, 10)
# c(11, 0)
# >>> eat(2, 11, 5)
# c(7, 0)
# Variables:
# @number : integer
#     the number of carrots that you have eaten.
# @need : integer
#     the number of carrots that you need to eat.
# @remaining : integer
#     the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
eat <- function(number, need, remaining) {","eat <- function(number, need, remaining) {
  total_eaten <- number + min(need, remaining)
  remaining_carrots <- max(0, remaining - need)
  return(c(total_eaten, remaining_carrots))
}","test_humaneval <- function() {
    candidate <- eat
    stopifnot(isTRUE(all.equal(candidate(5, 6, 10), c(11, 4))))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 9), c(12, 1))))
    stopifnot(isTRUE(all.equal(candidate(1, 10, 10), c(11, 0))))
    stopifnot(isTRUE(all.equal(candidate(2, 11, 5), c(7, 0))))
    stopifnot(isTRUE(all.equal(candidate(4, 5, 7), c(9, 2))))
    stopifnot(isTRUE(all.equal(candidate(4, 5, 1), c(5, 0))))
}
test_humaneval()"
HumanEval_160,ydd_Hebr,r,"אָפּעראַטאָר רשימה האט בייַ מינדסטער איין אָפּעראַטאָר, און אָפּעראַנד רשימה האט בייַ מינדסטער צוויי אָפּעראַנדז. אָפּעראַנד איז אַ רשימה פון ניט-נעגאַטיוו אינטעדזשערז.די לענג פון אָפּעראַטאָר רשימה איז גלייַך צו די לענג פון אָפּעראַנד רשימה מינוס איין. באַמערקונג: => רעזולטאַט = 9 דער רעזולטאַט איז 2 + 3 * 4 - 5 וועקטאָר = [2, 3, 4, 5] אָפּעראַטאָר['+', '*', '-'] בייַשפּיל: עקספּאָנענטאַטיאָן (**) שטאָק אָפּטיילונג ( // ) מאַלטאַפּליקאַטיאָן (*) אַראָפּרעכענען ( - ) אַדישאַן ( + ) די גרונט אַלגעבראַ אַפּעריישאַנז: אויסדרוק און צוריקקומען די אָפּשאַצונג פון דעם אויסדרוק. די צווייטע ליסטע איז א ליסטע פון אינטעדזשערס. נוצט די צוויי געגעבענע ליסטעס צו בויען די אלגעבריק די ערשטע ליסטע האט אלגעברע באזירטע אפעראציעס, און do_algebra <- function(operator, operand) {","do_algebra <- function(operator, operand) {
  if (length(operator) != length(operand) - 1) {
    stop(""The length of operator list must be equal to the length of operand list minus one."")
  }
  
  # Initialize the result with the first operand
  result <- operand[1]
  
  # Iterate through the operators and operands
  for (i in 1:length(operator)) {
    op <- operator[i]
    num <- operand[i + 1]
    
    # Apply the appropriate operation
    if (op == '+') {
      result <- result + num
    } else if (op == '-') {
      result <- result - num
    } else if (op == '*') {
      result <- result * num
    } else if (op == '//') {
      result <- result %/% num
    } else if (op == '**') {
      result <- result ^ num
    } else {
      stop(""Unsupported operation"")
    }
  }
  
  return(result)
}","test_humaneval <- function() {
    candidate <- do_algebra
    stopifnot(isTRUE(all.equal(candidate(c('**', '*', '+'), c(2, 3, 4, 5)), 37)))
    stopifnot(isTRUE(all.equal(candidate(c('+', '*', '-'), c(2, 3, 4, 5)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c('//', '*'), c(7, 3, 4)), 8)))
}
test_humaneval()"
HumanEval_161,ydd_Hebr,r,"ביישפילן די פונקציע זאָל צוריקקומען די ריזאַלטיד שטריקל. אויב די שטריקל כּולל קיין אותיות, פאַרקערט די שטריקל. אַנדערש לאָזן עס ווי עס איז. אויב s[i] איז אַ בריוו, פאַרקערט זיין פאַל פון נידעריקער צו אויבערשטער אָדער וויסע ווערסאַ, איר זענט געגעבן אַ שטריקל ס. # >>> solve('1234')
# '4321'
# >>> solve('ab')
# 'AB'
# >>> solve('#a@C')
# '#A@c'
solve <- function(s) {","solve <- function(s) {
  if (grepl(""[a-zA-Z]"", s)) {
    return(chartr(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"",
                  ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"", s))
  } else {
    return(intToUtf8(rev(utf8ToInt(s))))
  }
}","test_humaneval <- function() {
    candidate <- solve
    stopifnot(isTRUE(all.equal(candidate('AsDf'), 'aSdF')))
    stopifnot(isTRUE(all.equal(candidate('1234'), '4321')))
    stopifnot(isTRUE(all.equal(candidate('ab'), 'AB')))
    stopifnot(isTRUE(all.equal(candidate('#a@C'), '#A@c')))
    stopifnot(isTRUE(all.equal(candidate('#AsdfW^45'), '#aSDFw^45')))
    stopifnot(isTRUE(all.equal(candidate('#6@2'), '2@6#')))
    stopifnot(isTRUE(all.equal(candidate('#$a^D'), '#$A^d')))
    stopifnot(isTRUE(all.equal(candidate('#ccc'), '#CCC')))
}
test_humaneval()"
HumanEval_162,ydd_Hebr,r,"אויב 'טעקסט' איז אַ ליידיק שטריקל, צוריקקומען NULL. געגעבן אַ שטריקל 'טעקסט', צוריקקומען זייַן md5 האַש עקוויוואַלענט שטריקל. # >>> string_to_md5('Hello world')
# '3e25960a79dbc69b674cd4ec67a72c62'
string_to_md5 <- function(text) {","string_to_md5 <- function(text) {
  if (text == """") {
    return(NULL)
  } else {
    return(digest::digest(text, algo = ""md5"", serialize = FALSE))
  }
}

# Ensure the required library is loaded
if(!requireNamespace(""digest"", quietly = TRUE)) {
  install.packages(""digest"")
}

# Load the digest library
library(digest)","test_humaneval <- function() {
    candidate <- string_to_md5
    stopifnot(isTRUE(all.equal(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')))
    stopifnot(isTRUE(all.equal(candidate(''), NULL)))
    stopifnot(isTRUE(all.equal(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')))
    stopifnot(isTRUE(all.equal(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')))
}
test_humaneval()"
HumanEval_163,ydd_Hebr,r,"למשל: און ב, אין אַסינדענדינג סדר. געגעבן צוויי positive integers a און b, צוריקקומען די פּאַר דידזשיץ צווישן a # >>> generate_integers(2, 8)
# c(2, 4, 6, 8)
# >>> generate_integers(8, 2)
# c(2, 4, 6, 8)
# >>> generate_integers(10, 14)
# c()
generate_integers <- function(a, b) {","generate_integers <- function(a, b) {
  start <- min(a, b)
  end <- max(a, b)
  even_digits <- seq(start, end)[seq(start, end) %% 2 == 0 & seq(start, end) <= 8]
  return(even_digits)
}","test_humaneval <- function() {
    candidate <- generate_integers
    stopifnot(isTRUE(all.equal(candidate(2, 10), c(2, 4, 6, 8))))
    stopifnot(isTRUE(all.equal(candidate(10, 2), c(2, 4, 6, 8))))
    stopifnot(isTRUE(all.equal(candidate(132, 2), c(2, 4, 6, 8))))
    stopifnot(isTRUE(all.equal(candidate(17, 89), c())))
}
test_humaneval()"
