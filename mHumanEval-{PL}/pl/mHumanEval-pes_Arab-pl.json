[{"task_id":"HumanEval_0","nl":"pes_Arab","pl":"pl","prompt":"# # چک کنید که در آرایه داده شده از اعداد، هر دو عدد به یکدیگر نزدیک تر از  باشند.# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# \"\"\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# 1\nsub has_close_elements {\n    my($numbers, $threshold) = @_;\n","canonical_solution":"sub has_close_elements {\n    my($numbers, $threshold) = @_;\n    \n    for my $i (0 .. @$numbers - 2) {\n        for my $j ($i + 1 .. @$numbers - 1) {\n            if (abs($numbers->[$i] - $numbers->[$j]) < $threshold) {\n                return 1;\n            }\n        }\n    }\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&has_close_elements;\n        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_1","nl":"pes_Arab","pl":"pl","prompt":"# هر اسپیس در رشته ورودی را نادیده بگیرید.# گروه های جداگانه متعادل هستند (هر بند باز به درستی بسته شده است) و در درون یکدیگر قرار ندارند .# این گروه ها را به رشته های جداگانه جدا کنید و آرایه ی آن ها را برگردانید.# ورودی این تابع یک رشته است که شامل چند گروه از قوس های آشیانه ای است. هدف شما این است که # >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\nsub separate_paren_groups {\n    my($paren_string) = @_;\n","canonical_solution":"sub separate_paren_groups {\n    my ($paren_string) = @_;\n    $paren_string =~ s\/\\s+\/\/g;  # Remove all spaces\n    my @groups;\n    my $balance = 0;\n    my $current_group = \"\";\n    \n    foreach my $char (split \/\/, $paren_string) {\n        if ($char eq '(') {\n            $balance++;\n        }\n        if ($char eq ')') {\n            $balance--;\n        }\n        $current_group .= $char;\n        if ($balance == 0 && $current_group ne \"\") {\n            push @groups, $current_group;\n            $current_group = \"\";\n        }\n    }\n    \n    return \\@groups;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&separate_paren_groups;\n        if(eq_deeply($candidate->(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()(())((())))\"),[\"(()(())((())))\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_2","nl":"pes_Arab","pl":"pl","prompt":"# قسمت اعشاری از عدد را برگردانید.# (باقی مانده همیشه کمتر از 1 است)# و بخش عدد صحیح (بزرگترین عدد صحیح کوچکتر از عدد داده شده) و اعشار # با توجه به یک عدد مثبت پاییز شناور، می توان آن را به  تجزیه کرد.# >>> truncate_number(3.5)\n# 0.5\nsub truncate_number {\n    my($number) = @_;\n","canonical_solution":"sub truncate_number {\n    my($number) = @_;\n    my $integer_part = int($number);\n    my $decimal_part = $number - $integer_part;\n    return $decimal_part;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&truncate_number;\n        if(eq_deeply($candidate->(3.5),0.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1.25),0.25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(123.0),0.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_3","nl":"pes_Arab","pl":"pl","prompt":"# در این نقطه تابع باید 1 را برگرداند در غیر این صورت باید \" \" را برگرداند.# وظیفه شما این است که تشخیص دهید که آیا در هر نقطه ای، میزان حساب زیر صفر است و # شما یک سری از عملیات سپرده گذاری و برداشت را در یک حساب بانکی که با شروع می شود به شما داده می شود.# >>> below_zero([1, 2, 3])\n# \"\"\n# >>> below_zero([1, 2, -4, 5])\n# 1\nsub below_zero {\n    my($operations) = @_;\n","canonical_solution":"sub below_zero {\n    my ($operations) = @_;\n    my $balance = 0;\n    \n    for my $operation (@$operations) {\n        $balance += $operation;\n        if ($balance < 0) {\n            return 1;\n        }\n    }\n    \n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&below_zero;\n        if(eq_deeply($candidate->([]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, -3, 1, 2, -3]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, -4, 5, 6]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 2, -2, 5, -5, 4, -4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 2, -2, 5, -5, 4, -5]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -2, 2, -2, 5, -5, 4, -4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_4","nl":"pes_Arab","pl":"pl","prompt":"# MAD = متوسط. x - x_mean.# عنصر و نقطه مرکزی (در این مورد میانگین): # میانگین انحراف مطلق متوسط تفاوت مطلق بین هر # در حدود میانگین این مجموعه داده ها.# برای یک آرایه داده شده از اعداد ورودی، میانگین انحراف مطلق را محاسبه کنید.# >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n# 1.0\nsub mean_absolute_deviation {\n    my($numbers) = @_;\n","canonical_solution":"sub mean_absolute_deviation {\n    my ($numbers) = @_;\n    my $n = scalar @$numbers;\n    return 0 if $n == 0;\n\n    # Calculate mean\n    my $sum = 0;\n    $sum += $_ for @$numbers;\n    my $mean = $sum \/ $n;\n\n    # Calculate mean absolute deviation\n    my $total_deviation = 0;\n    $total_deviation += abs($_ - $mean) for @$numbers;\n    return $total_deviation \/ $n;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&mean_absolute_deviation;\n        if(eq_deeply($candidate->([1.0, 2.0]),0.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0]),1.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),1.2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_5","nl":"pes_Arab","pl":"pl","prompt":"# یک عدد \"تقاطع\" را بین هر دو عنصر متوالی آرایه ورودی وارد کنید `numbers' # >>> intersperse([], 4)\n# []\n# >>> intersperse([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\nsub intersperse {\n    my($numbers, $delimeter) = @_;\n","canonical_solution":"my @result;\n    for (my $i = 0; $i < @$numbers; $i++) {\n        push @result, $numbers->[$i];\n        push @result, $delimeter if $i < @$numbers - 1;\n    }\n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersperse;\n        if(eq_deeply($candidate->([], 7),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 2, 2], 2),[2, 2, 2, 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_6","nl":"pes_Arab","pl":"pl","prompt":"# به عنوان مثال (() (()) حداکثر دو سطح لانه سازی دارد در حالی که ((())) سه سطح دارد. # برای هر یک از گروه ها، عمیق ترین سطح قرار گیری قوس ها را وارد کنید.# ورودی این تابع یک رشته است که چندین گروه را برای قوس های آشیانه ای که با فضاها جدا شده اند نشان می دهد.# >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\nsub parse_nested_parens {\n    my($paren_string) = @_;\n","canonical_solution":"sub parse_nested_parens {\n    my($paren_string) = @_;\n    my @groups = split \/ \/, $paren_string;\n    my @depths;\n\n    foreach my $group (@groups) {\n        my $max_depth = 0;\n        my $current_depth = 0;\n        foreach my $char (split \/\/, $group) {\n            if ($char eq '(') {\n                $current_depth++;\n                if ($current_depth > $max_depth) {\n                    $max_depth = $current_depth;\n                }\n            } elsif ($char eq ')') {\n                $current_depth--;\n            }\n        }\n        push @depths, $max_depth;\n    }\n    \n    return \\@depths;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_nested_parens;\n        if(eq_deeply($candidate->(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"() (()) ((())) (((())))\"),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()(())((())))\"),[4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_7","nl":"pes_Arab","pl":"pl","prompt":"# فیلتر کردن یک آرایه ورودی از رشته ها فقط برای آنهایی که شامل زیر رشته داده شده است.# >>> filter_by_substring([], \"a\")\n# []\n# >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\nsub filter_by_substring {\n    my($strings, $substring) = @_;\n","canonical_solution":"sub filter_by_substring {\n    my ($strings, $substring) = @_;\n    my @filtered = grep { index($_, $substring) != -1 } @$strings;\n    return \\@filtered;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_by_substring;\n        if(eq_deeply($candidate->([], \"john\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"),[\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"),[\"grunt\", \"prune\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_8","nl":"pes_Arab","pl":"pl","prompt":"# جمع خالی باید برابر با 0 و حاصل خالی باید برابر با 1 باشد.# برای یک آرایه داده شده از اعداد صحیح، یک آرایه را که شامل جمع و حاصل از تمام اعداد صحیح در یک آرایه است، برگردانید.# >>> sum_product([])\n# [0, 1]\n# >>> sum_product([1, 2, 3, 4])\n# [10, 24]\nsub sum_product {\n    my($numbers) = @_;\n","canonical_solution":"sub sum_product {\n    my ($numbers) = @_;\n    my $sum = 0;\n    my $product = 1;\n    \n    foreach my $num (@$numbers) {\n        $sum += $num;\n        $product *= $num;\n    }\n    \n    return [$sum, $product];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_product;\n        if(eq_deeply($candidate->([]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1]),[3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, 0]),[100, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 7]),[15, 105])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10]),[10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_9","nl":"pes_Arab","pl":"pl","prompt":"# در توالی.# از یک آرایه داده شده از اعداد صحیح، یک آرایه از عناصر حداکثر رولینگ پیدا شده تا لحظه داده شده را تولید کنید.# >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\nsub rolling_max {\n    my($numbers) = @_;\n","canonical_solution":"sub rolling_max {\n    my ($numbers) = @_;\n    my @result;\n    my $max = $numbers->[0];\n    \n    for my $num (@$numbers) {\n        $max = $num if $num > $max;\n        push @result, $max;\n    }\n    \n    return \\@result;\n}\n\n# Example usage\nmy $result = rolling_max([1, 2, 3, 2, 3, 4, 2]);\nprint \"@$result\\n\";  # Outputs: 1 2 3 3 3 4 4","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rolling_max;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 1]),[4, 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_10","nl":"pes_Arab","pl":"pl","prompt":"# - به انتهای رشته ی متناوب یک پیشوند رشته ای اضافه کنید که قبل از پسوند پالندروم می آید.# - طولانی ترین پس فکس رشته ای که یک پالندروم است را پیدا کنید.# ایده الگوریتم ساده است:# کوتاه ترین پالندرم را پیدا کنید که با یک رشته شروع می شود.# >>> make_palindrome(\"\")\n# \"\"\n# >>> make_palindrome(\"cat\")\n# \"catac\"\n# >>> make_palindrome(\"cata\")\n# \"catac\"\nsub make_palindrome {\n    my($string) = @_;\n","canonical_solution":"sub make_palindrome {\n    my($string) = @_;\n\n    # Helper function to check if a substring is a palindrome\n    sub is_palindrome {\n        my ($sub) = @_;\n        return $sub eq reverse $sub;\n    }\n\n    # If the whole string is a palindrome, return it\n    if (is_palindrome($string)) {\n        return $string;\n    }\n\n    # Check for the longest palindromic suffix\n    my $length = length($string);\n    for (my $i = $length; $i >= 0; $i--) {\n        my $suffix = substr($string, $i);\n        if (is_palindrome($suffix)) {\n            my $prefix = substr($string, 0, $i);\n            return $string . reverse($prefix);\n        }\n    }\n\n    # If no palindromic suffix is found, append the reverse of entire string minus the first character\n    return $string . reverse(substr($string, 1));\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_palindrome;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),\"x\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyz\"),\"xyzyx\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyx\"),\"xyx\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"jerry\"),\"jerryrrej\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_11","nl":"pes_Arab","pl":"pl","prompt":"# با این ورودی ها XOR دوگانه را اجرا کنید و نتیجه را به عنوان یک رشته برگردانید.# ورودی دو رشته a و b است که فقط از 1 و 0 تشکیل شده است.# >>> string_xor(\"010\", \"110\")\n# \"100\"\nsub string_xor {\n    my($a, $b) = @_;\n","canonical_solution":"my @a_bits = split \/\/, $a;\n    my @b_bits = split \/\/, $b;\n    my $result = '';\n\n    for my $i (0 .. $#a_bits) {\n        $result .= $a_bits[$i] ^ $b_bits[$i];\n    }\n\n    return $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_xor;\n        if(eq_deeply($candidate->(\"111000\", \"101010\"),\"010010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\", \"1\"),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0101\", \"0000\"),\"0101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_12","nl":"pes_Arab","pl":"pl","prompt":"# رشته های با طول یکسان. اگر آرایه ورودی خالی باشد undef را باز می گرداند.# از میان رشته های آرایه، طولانی ترین رشته را برگردانید. در صورت چند رشته ، اولین رشته را برگردانید.# >>> longest([])\n# undef\n# >>> longest([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\nsub longest {\n    my($strings) = @_;\n","canonical_solution":"sub longest {\n    my ($strings) = @_;\n    return undef if !@$strings;\n\n    my $longest = $strings->[0];\n    foreach my $string (@$strings) {\n        if (length($string) > length($longest)) {\n            $longest = $string;\n        }\n    }\n    return $longest;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&longest;\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"z\"]),\"x\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_13","nl":"pes_Arab","pl":"pl","prompt":"# بزرگترين قسمت مشترک دو عدد a و b رو برميگردونيم# >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\nsub greatest_common_divisor {\n    my($a, $b) = @_;\n","canonical_solution":"sub greatest_common_divisor {\n    my ($a, $b) = @_;\n    while ($b != 0) {\n        my $t = $b;\n        $b = $a % $b;\n        $a = $t;\n    }\n    return $a;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&greatest_common_divisor;\n        if(eq_deeply($candidate->(3, 7),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 15),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49, 14),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(144, 60),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_14","nl":"pes_Arab","pl":"pl","prompt":"# آرایه ای از همه ی پیشوند ها از کوتاه ترین تا طولانی ترین رشته ی ورودی را برمی گرداند.# >>> all_prefixes(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\nsub all_prefixes {\n    my($string) = @_;\n","canonical_solution":"my($string) = @_;\n    my @prefixes;\n    for my $i (1 .. length($string)) {\n        push @prefixes, substr($string, 0, $i);\n    }\n    return @prefixes;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&all_prefixes;\n        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdfgh\"),[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"WWW\"),[\"W\", \"WW\", \"WWW\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_15","nl":"pes_Arab","pl":"pl","prompt":"# یک رشته حاوی اعداد با محدوده فضایی از 0 تا n را باز می گرداند. # >>> string_sequence(0)\n# \"0\"\n# >>> string_sequence(5)\n# \"0 1 2 3 4 5\"\nsub string_sequence {\n    my($n) = @_;\n","canonical_solution":"sub string_sequence {\n    my($n) = @_;\n    return join ' ', 0..$n;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_sequence;\n        if(eq_deeply($candidate->(0),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),\"0 1 2 3\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),\"0 1 2 3 4 5 6 7 8 9 10\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_16","nl":"pes_Arab","pl":"pl","prompt":"# با توجه به یک رشته، تعداد کاراکترهای متمایز (بغیر توجه به مورد) را پیدا کنید که از آن تشکیل شده است.# >>> count_distinct_characters(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters(\"Jerry\")\n# 4\nsub count_distinct_characters {\n    my($string) = @_;\n","canonical_solution":"sub count_distinct_characters {\n    my($string) = @_;\n    my %chars;\n    $string = lc $string;  # Convert the string to lowercase\n    $chars{$_} = 1 for split \/\/, $string;  # Add each character to the hash\n    return scalar keys %chars;  # Return the number of distinct keys\n}\n\n# Example usage:\nprint count_distinct_characters(\"xyzXYZ\"), \"\\n\";  # Output: 3\nprint count_distinct_characters(\"Jerry\"), \"\\n\";   # Output: 4","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_distinct_characters;\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcde\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdecadeCADE\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaaAAAAaaaa\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Jerry jERRY JeRRRY\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_17","nl":"pes_Arab","pl":"pl","prompt":"# \"جاش\" - نوتا چهارگانه، يک ضربه طول ميکشه# \"او\" چي ميگه؟ نصف نوت، دو تا ضربه طول ميکشه# \"او\" - تمام نوت، چهار ضربه طول ميکشه# اينم يه افسانه:# نه آخرين.# کار شما تجزیه کردن این رشته و بازگشت آرایه ای از اعداد صحیح است که با تعداد ضربات هر کدام مطابقت دارد.# ورودی این تابع یک رشته است که نماد نوت های موسیقی را در فرمت خاص ASCII نشان می دهد.# >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nsub parse_music {\n    my($music_string) = @_;\n","canonical_solution":"sub parse_music {\n    my ($music_string) = @_;\n    my @notes = split ' ', $music_string;\n    my @beats;\n\n    foreach my $note (@notes) {\n        if ($note eq 'o') {\n            push @beats, 4;\n        } elsif ($note eq 'o|') {\n            push @beats, 2;\n        } elsif ($note eq '.|') {\n            push @beats, 1;\n        }\n    }\n\n    return @beats;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_music;\n        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o o o o\"),[4, 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\".| .| .| .|\"),[1, 1, 1, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o| o| .| .| o o o o\"),[2, 2, 1, 1, 4, 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o| .| o| .| o o| o o|\"),[2, 1, 2, 1, 4, 2, 4, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_18","nl":"pes_Arab","pl":"pl","prompt":"# تعداد بار هایی که یک زیر رشته داده شده در رشته اصلی یافت می شود را پیدا کنید. موارد همپوشانی را بشمارید. # >>> how_many_times(\"\", \"a\")\n# 0\n# >>> how_many_times(\"aaa\", \"a\")\n# 3\n# >>> how_many_times(\"aaaa\", \"aa\")\n# 3\nsub how_many_times {\n    my($string, $substring) = @_;\n","canonical_solution":"sub how_many_times {\n    my ($string, $substring) = @_;\n    return 0 if $substring eq '';\n    my $count = 0;\n    while ($string =~ \/(?=$substring)\/g) {\n        $count++;\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&how_many_times;\n        if(eq_deeply($candidate->(\"\", \"x\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyxyxyx\", \"x\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"cacacacac\", \"cac\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"john doe\", \"john\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_19","nl":"pes_Arab","pl":"pl","prompt":"# رشته ای با اعداد مرتب شده از کوچک تا بزرگ را باز می گرداند# گزینه های معتبر عبارتند از \"صفر\"، \"یک\"، \"دو\"، \"سه\"، \"چهار\"، \"پنج\"، \"شش\"، \" هفت\"، \"هشت\" و \"نه\". # ورودی یک رشته ی عددی از صفر تا نه است.# >>> sort_numbers(\"three one five\")\n# \"one three five\"\nsub sort_numbers {\n    my($numbers) = @_;\n","canonical_solution":"sub sort_numbers {\n    my ($numbers) = @_;\n    my %word_to_num = (\n        'zero'  => 0,\n        'one'   => 1,\n        'two'   => 2,\n        'three' => 3,\n        'four'  => 4,\n        'five'  => 5,\n        'six'   => 6,\n        'seven' => 7,\n        'eight' => 8,\n        'nine'  => 9,\n    );\n    my %num_to_word = reverse %word_to_num;\n    my @sorted_numbers = \n        map { $num_to_word{$_} } \n        sort { $a <=> $b } \n        map { $word_to_num{$_} } \n        split ' ', $numbers;\n    return join ' ', @sorted_numbers;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_numbers;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"three\"),\"three\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"three five nine\"),\"three five nine\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"five zero four seven nine eight\"),\"zero four five seven eight nine\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"six five four three two one zero\"),\"zero one two three four five six\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_20","nl":"pes_Arab","pl":"pl","prompt":"# و به ترتیب (تعداد کمتر، تعداد بیشتر) برگردانید.# از یک آرایه داده شده از اعداد (با حداقل دو عدد طول) دو عدد که به هر یک از آنها نزدیک تر هستند را انتخاب کنید و برگردانید .# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\nsub find_closest_elements {\n    my($numbers) = @_;\n","canonical_solution":"sub find_closest_elements {\n    my ($numbers) = @_;\n    my @sorted_numbers = sort { $a <=> $b } @$numbers;\n    my $min_diff = undef;\n    my @closest_pair;\n\n    for my $i (0 .. $#sorted_numbers - 1) {\n        my $diff = $sorted_numbers[$i + 1] - $sorted_numbers[$i];\n        if (!defined($min_diff) || $diff < $min_diff) {\n            $min_diff = $diff;\n            @closest_pair = ($sorted_numbers[$i], $sorted_numbers[$i + 1]);\n        }\n    }\n\n    return @closest_pair;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_closest_elements;\n        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_21","nl":"pes_Arab","pl":"pl","prompt":"# به طوری که کوچکترین عدد به صفر و بزرگ ترین عدد به یک تبدیل شود.# با توجه به آرایه ای از اعداد (حداقل دو عنصر) ، یک تبدیل خطی را به آن آرایه اعمال کنید، # >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\nsub rescale_to_unit {\n    my($numbers) = @_;\n","canonical_solution":"sub rescale_to_unit {\n    my($numbers) = @_;\n    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my @rescaled = map { ($_ - $min) \/ ($max - $min) } @$numbers;\n    return \\@rescaled;\n}\n\nsub min {\n    my(@list) = @_;\n    my $min = $list[0];\n    foreach my $num (@list) {\n        if ($num < $min) {\n            $min = $num;\n        }\n    }\n    return $min;\n}\n\nsub max {\n    my(@list) = @_;\n    my $max = $list[0];\n    foreach my $num (@list) {\n        if ($num > $max) {\n            $max = $num;\n        }\n    }\n    return $max;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rescale_to_unit;\n        if(eq_deeply($candidate->([2.0, 49.9]),[0.0, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0, 49.9]),[1.0, 0.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_22","nl":"pes_Arab","pl":"pl","prompt":"# فیلتر کردن آرایه داده شده از هر مقدار پلتون فقط برای اعداد صحیح# >>> filter_integers([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\nsub filter_integers {\n    my($values) = @_;\n","canonical_solution":"sub filter_integers {\n    my ($values) = @_;\n    return [grep { \/^-?\\d+$\/ && !ref($_) } @$values];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_integers;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, {}, [], 23.2, 9, \"adasd\"]),[4, 9])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_23","nl":"pes_Arab","pl":"pl","prompt":"# طول بازگشت رشته داده شده# >>> strlen(\"\")\n# 0\n# >>> strlen(\"abc\")\n# 3\nsub strlen {\n    my($string) = @_;\n","canonical_solution":"sub strlen {\n    my($string) = @_;\n    return length($string);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strlen;\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdasnakj\"),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_24","nl":"pes_Arab","pl":"pl","prompt":"# برای یک عدد n، بزرگترین عدد را که n را به طور مساوی تقسیم می کند، کوچک تر از n را پیدا کنید.# >>> largest_divisor(15)\n# 5\nsub largest_divisor {\n    my($n) = @_;\n","canonical_solution":"sub largest_divisor {\n    my($n) = @_;\n    for (my $i = $n - 1; $i > 0; $i--) {\n        if ($n % $i == 0) {\n            return $i;\n        }\n    }\n    return undef; # In case n is 1, there is no divisor less than n\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_divisor;\n        if(eq_deeply($candidate->(3),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),50)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_25","nl":"pes_Arab","pl":"pl","prompt":"# عدد ورودی باید برابر با حاصل حاصل از همه عوامل باشد# هر یک از فاکتورها باید به تعداد دفعات که در فاکتورهای آنها ظاهر می شود، ارجاع داده شود.# آرایه ی عوامل اول یک عدد صحیح را از کوچک ترین به بزرگ ترین به ترتیب برگرداند.# >>> factorize(8)\n# [2, 2, 2]\n# >>> factorize(25)\n# [5, 5]\n# >>> factorize(70)\n# [2, 5, 7]\nsub factorize {\n    my($n) = @_;\n","canonical_solution":"sub factorize {\n    my ($n) = @_;\n    my @factors;\n    for my $i (2 .. int(sqrt($n))) {\n        while ($n % $i == 0) {\n            push @factors, $i;\n            $n \/= $i;\n        }\n    }\n    push @factors, $n if $n > 1;\n    return @factors;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&factorize;\n        if(eq_deeply($candidate->(2),[2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[2, 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(57),[3, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3249),[3, 3, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(185193),[3, 3, 3, 19, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(20577),[3, 19, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(18),[2, 3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_26","nl":"pes_Arab","pl":"pl","prompt":"# ترتیب عناصر را همان طور که در ورودی است نگه دارید.# از آرایه ای از اعداد صحیح، تمام عناصر را که بیش از یک بار رخ می دهند حذف کنید.# >>> remove_duplicates([1, 2, 3, 2, 4])\n# [1, 3, 4]\nsub remove_duplicates {\n    my($numbers) = @_;\n","canonical_solution":"sub remove_duplicates {\n    my ($numbers) = @_;\n    my %count;\n    $count{$_}++ for @$numbers;\n    return [grep { $count{$_} == 1 } @$numbers];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_duplicates;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_27","nl":"pes_Arab","pl":"pl","prompt":"# برای یک رشته داده شده، کاراکترهای کوچک را به بزرگ و بزرگ به کوچک تبدیل کنید.# >>> flip_case(\"Hello\")\n# \"hELLO\"\nsub flip_case {\n    my($string) = @_;\n","canonical_solution":"sub flip_case {\n    my($string) = @_;\n    $string =~ tr\/A-Za-z\/a-zA-Z\/;\n    return $string;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&flip_case;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello!\"),\"hELLO!\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_28","nl":"pes_Arab","pl":"pl","prompt":"# مجموعه ای از رشته ها رو به یک رشته تبدیل کنید# >>> concatenate([])\n# \"\"\n# >>> concatenate([\"a\", \"b\", \"c\"])\n# \"abc\"\nsub concatenate {\n    my($strings) = @_;\n","canonical_solution":"sub concatenate {\n    my($strings) = @_;\n    return join('', @$strings);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&concatenate;\n        if(eq_deeply($candidate->([]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"z\"]),\"xyz\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"z\", \"w\", \"k\"]),\"xyzwk\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_29","nl":"pes_Arab","pl":"pl","prompt":"# یک آرایه ورودی از رشته ها را فقط برای رشته هایی که با یک پیشوند داده شده شروع می شوند، فیلتر کنید.# >>> filter_by_prefix([], \"a\")\n# []\n# >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\nsub filter_by_prefix {\n    my($strings, $prefix) = @_;\n","canonical_solution":"sub filter_by_prefix {\n    my ($strings, $prefix) = @_;\n    return [grep { \/^\\Q$prefix\\E\/ } @$strings];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_by_prefix;\n        if(eq_deeply($candidate->([], \"john\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_30","nl":"pes_Arab","pl":"pl","prompt":"# فقط اعداد مثبت در آرایه را بازمی گرداند.# >>> get_positive([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\nsub get_positive {\n    my($l) = @_;\n","canonical_solution":"sub get_positive {\n    my($l) = @_;\n    my @positive_numbers = grep { $_ > 0 } @$l;\n    return \\@positive_numbers;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_positive;\n        if(eq_deeply($candidate->([-1, -2, 4, 5, 6]),[4, 5, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_31","nl":"pes_Arab","pl":"pl","prompt":"# اگر یک عدد اول داده شده باشد، صحیح را و در غیر این صورت غلط را باز می گرداند.# >>> is_prime(6)\n# \"\"\n# >>> is_prime(101)\n# 1\n# >>> is_prime(11)\n# 1\n# >>> is_prime(13441)\n# 1\n# >>> is_prime(61)\n# 1\n# >>> is_prime(4)\n# \"\"\n# >>> is_prime(1)\n# \"\"\nsub is_prime {\n    my($n) = @_;\n","canonical_solution":"sub is_prime {\n    my($n) = @_;\n    return \"\" if $n <= 1;\n    return 1 if $n == 2;\n    return \"\" if $n % 2 == 0;\n    for (my $i = 3; $i * $i <= $n; $i += 2) {\n        return \"\" if $n % $i == 0;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_prime;\n        if(eq_deeply($candidate->(6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13441),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(61),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(17),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(85),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(77),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(255379),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_33","nl":"pes_Arab","pl":"pl","prompt":"# به ارزش شاخص های مربوطه از l، اما مرتب شده است.# l' با l در شاخص هایی که به سه تقسیم نمی شوند یکسان است، در حالی که مقادیر آن در شاخص هایی که به سه تقسیم می شوند برابر است.# این تابع یک آرایه l می گیرد و یک آرایه l' را بازمی گرداند که # >>> sort_third([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\nsub sort_third {\n    my($l) = @_;\n","canonical_solution":"sub sort_third {\n    my ($l) = @_;\n    my @to_sort = map { $l->[$_] } grep { $_ % 3 == 0 } 0..$#$l;\n    @to_sort = sort { $a <=> $b } @to_sort;\n    my @result = @$l;\n    my $index = 0;\n\n    foreach my $i (0..$#{$l}) {\n        if ($i % 3 == 0) {\n            $result[$i] = $to_sort[$index++];\n        }\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_third;\n        if(eq_deeply($candidate->([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_34","nl":"pes_Arab","pl":"pl","prompt":"# عناصر منحصر به فرد مرتب شده در یک آرایه را باز می گرداند# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n","canonical_solution":"sub unique {\n    my ($l) = @_;\n    my %seen;\n    my @unique_sorted = sort { $a <=> $b } grep { !$seen{$_}++ } @$l;\n    return \\@unique_sorted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_35","nl":"pes_Arab","pl":"pl","prompt":"# حداکثر عنصر در آرایه را برمی گرداند.# >>> max_element([1, 2, 3])\n# 3\n# >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\nsub max_element {\n    my($l) = @_;\n","canonical_solution":"sub max_element {\n    my($l) = @_;\n    my $max = $l->[0];\n    foreach my $value (@$l) {\n        if ($value > $max) {\n            $max = $value;\n        }\n    }\n    return $max;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_element;\n        if(eq_deeply($candidate->([1, 2, 3]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_36","nl":"pes_Arab","pl":"pl","prompt":"# عدد 7 را در عدد های صحیح کمتر از n که قابل تقسیم بر 11 یا 13 هستند، برگردانید.# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n# 2\n# >>> fizz_buzz(79)\n# 3\nsub fizz_buzz {\n    my($n) = @_;\n","canonical_solution":"sub fizz_buzz {\n    my($n) = @_;\n    my $count = 0;\n    for my $i (1 .. $n-1) {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            $count++ if $i =~ \/7\/;\n        }\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fizz_buzz;\n        if(eq_deeply($candidate->(50),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(78),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(79),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(200),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4000),192)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10000),639)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100000),8026)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_37","nl":"pes_Arab","pl":"pl","prompt":"# به ارزش شاخص های جفت l، اما مرتب شده است.# l' با l در شاخص های عجیب یکسان است، در حالی که مقادیر آن در شاخص های جفت برابر است.# این تابع یک آرایه l می گیرد و یک آرایه l' را بازمی گرداند که # >>> sort_even([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even([5, 6, 3, 4])\n# [3, 6, 5, 4]\nsub sort_even {\n    my($l) = @_;\n","canonical_solution":"sub sort_even {\n    my($l) = @_;\n    my @even_indices;\n\n    for (my $i = 0; $i < @$l; $i += 2) {\n        push @even_indices, $l->[$i];\n    }\n\n    @even_indices = sort { $a <=> $b } @even_indices;\n\n    my @result = @$l;\n    \n    for (my $i = 0; $i < @even_indices; $i++) {\n        $result[$i * 2] = $even_indices[$i];\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_even;\n        if(eq_deeply($candidate->([1, 2, 3]),[1, 2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_39","nl":"pes_Arab","pl":"pl","prompt":"# prime_fib عدد n-م را که یک عدد فیبوناچی است و همچنین عدد اول است را برمی گرداند. # >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\nsub prime_fib {\n    my($n) = @_;\n","canonical_solution":"sub is_prime {\n    my($num) = @_;\n    return 0 if $num < 2;\n    for my $i (2 .. sqrt($num)) {\n        return 0 if $num % $i == 0;\n    }\n    return 1;\n}\n\nsub prime_fib {\n    my($n) = @_;\n    my ($a, $b) = (1, 1);\n    my $count = 0;\n\n    while (1) {\n        my $fib = $a + $b;\n        $a = $b;\n        $b = $fib;\n        if (is_prime($fib)) {\n            $count++;\n            return $fib if $count == $n;\n        }\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prime_fib;\n        if(eq_deeply($candidate->(1),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),13)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),89)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),233)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),1597)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),28657)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),514229)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),433494437)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_40","nl":"pes_Arab","pl":"pl","prompt":"# در غیر این صورت# اگر سه عنصر متمایز در آرایه وجود داشته باشد که # triple_sum_to_zero یک آرایه از اعداد صحیح را به عنوان ورودی می گیرد.# >>> triples_sum_to_zero([1, 3, 5, 0])\n# \"\"\n# >>> triples_sum_to_zero([1, 3, -2, 1])\n# 1\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# \"\"\n# >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n# 1\n# >>> triples_sum_to_zero([1])\n# \"\"\nsub triples_sum_to_zero {\n    my($l) = @_;\n","canonical_solution":"sub triples_sum_to_zero {\n    my($l) = @_;\n    my $n = scalar @$l;\n    for my $i (0 .. $n-3) {\n        for my $j ($i+1 .. $n-2) {\n            for my $k ($j+1 .. $n-1) {\n                if ($l->[$i] + $l->[$j] + $l->[$k] == 0) {\n                    return 1;\n                }\n            }\n        }\n    }\n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&triples_sum_to_zero;\n        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 5, -1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 5, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 9, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 5, -100]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, 3, 5, -100]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_41","nl":"pes_Arab","pl":"pl","prompt":"# این تابع تعداد چنین برخورد هایی را به صورت خروجی نشان می دهد.# در مسیر حرکتشان انگار که با هم برخورد نکرده باشند# با این حال، این ماشین ها به طور نامحدود محکم و قوی هستند؛ در نتیجه، آنها به حرکت ادامه می دهند.# وقتی که یه ماشین که از چپ به راست میره با یه ماشین که از راست به چپ میره برخورد کنه# همه ماشين ها با سرعت يکسان حرکت ميکنند.# دو تا از ماشين ها خيلي از هم دور شدن# n ماشین از چپ به راست رانندگی می کنند؛ همزمان، مجموعه ای متفاوت از n ماشین # تصور کنید که یک جاده کاملاً مستقیم و بی نهایت طولانی باشد.sub car_race_collision {\n    my($n) = @_;\n","canonical_solution":"sub car_race_collision {\n    my($n) = @_;\n    return $n;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&car_race_collision;\n        if(eq_deeply($candidate->(2),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),16)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),64)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),100)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_42","nl":"pes_Arab","pl":"pl","prompt":"# آرایه ای با عناصر افزایش یافته به 1 را باز می گرداند.# >>> incr_list([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\nsub incr_list {\n    my($l) = @_;\n","canonical_solution":"sub incr_list {\n    my($l) = @_;\n    return [map { $_ + 1 } @$l];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&incr_list;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1]),[4, 3, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_43","nl":"pes_Arab","pl":"pl","prompt":"# در غیر این صورت# اگر دو عنصر متمایز در آرایه وجود داشته باشد که # pairs_sum_to_zero یک آرایه از اعداد صحیح را به عنوان ورودی می گیرد.# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# \"\"\n# >>> pairs_sum_to_zero([1, 3, -2, 1])\n# \"\"\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# \"\"\n# >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n# 1\n# >>> pairs_sum_to_zero([1])\n# \"\"\nsub pairs_sum_to_zero {\n    my($l) = @_;\n","canonical_solution":"sub pairs_sum_to_zero {\n    my ($l) = @_;\n    my %seen;\n    for my $num (@$l) {\n        if ($seen{-1 * $num}) {\n            return 1;\n        }\n        $seen{$num} = 1;\n    }\n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pairs_sum_to_zero;\n        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 5, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 30]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 31]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 30]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 31]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_44","nl":"pes_Arab","pl":"pl","prompt":"# تعداد پایه ها کمتر از 10 است# پس از تبدیل، نمایش رشته را باز می گرداند.# پایه عددی عدد x ورودی را به پایه تغییر دهید.# >>> change_base(8, 3)\n# \"22\"\n# >>> change_base(8, 2)\n# \"1000\"\n# >>> change_base(7, 2)\n# \"111\"\nsub change_base {\n    my($x, $base) = @_;\n","canonical_solution":"sub change_base {\n    my ($x, $base) = @_;\n    my $result = '';\n    \n    if ($base < 2 || $base > 9) {\n        die \"Base must be between 2 and 9\";\n    }\n\n    while ($x > 0) {\n        my $remainder = $x % $base;\n        $result = $remainder . $result;\n        $x = int($x \/ $base);\n    }\n\n    return $result eq '' ? '0' : $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&change_base;\n        if(eq_deeply($candidate->(8, 3),\"22\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9, 3),\"100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(234, 2),\"11101010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(16, 2),\"10000\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8, 2),\"1000\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 2),\"111\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 3),\"2\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 4),\"3\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 5),\"4\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 6),\"5\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6, 7),\"6\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 8),\"7\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_45","nl":"pes_Arab","pl":"pl","prompt":"# طول یک طرف و مساحت بازگشت بالا برای یک مثلث را می دهیم.# >>> triangle_area(5, 3)\n# 7.5\nsub triangle_area {\n    my($a, $h) = @_;\n","canonical_solution":"sub triangle_area {\n    my ($a, $h) = @_; \n    return 0.5 * $a * $h;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&triangle_area;\n        if(eq_deeply($candidate->(5, 3),7.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2),2.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 8),40.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_46","nl":"pes_Arab","pl":"pl","prompt":"# لطفاً یک تابع برای محاسبه ی n-مین عنصر از دنباله ی اعداد fib4 بنویسید. از تکرار استفاده نکنید. # fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).# fib4(3) -> 0 # -بچه ها# fib4(1) -> 0 # fib4(0) -> 0 # دنباله ی اعداد فیبونیکی یک دنباله ی مشابه به دنباله ی فیبونیکی است که به شرح زیر تعریف شده است:# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\nsub fib4 {\n    my($n) = @_;\n","canonical_solution":"sub fib4 {\n    my ($n) = @_;\n    return 0 if $n == 0 || $n == 1 || $n == 3;\n    return 2 if $n == 2;\n    \n    my @fib4 = (0, 0, 2, 0);\n    \n    for my $i (4 .. $n) {\n        $fib4[$i] = $fib4[$i-1] + $fib4[$i-2] + $fib4[$i-3] + $fib4[$i-4];\n    }\n    \n    return $fib4[$n];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fib4;\n        if(eq_deeply($candidate->(5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),28)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),104)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),386)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_47","nl":"pes_Arab","pl":"pl","prompt":"# میانه عناصر در آرایه را برگردانید l. # >>> median([3, 1, 2, 4, 5])\n# 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\nsub median {\n    my($l) = @_;\n","canonical_solution":"sub median {\n    my($l) = @_;\n    my @sorted = sort { $a <=> $b } @$l;\n    my $len = @sorted;\n    if ($len % 2 == 1) {\n        return $sorted[int($len\/2)];\n    } else {\n        return ($sorted[$len\/2 - 1] + $sorted[$len\/2]) \/ 2;\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&median;\n        if(eq_deeply($candidate->([3, 1, 2, 4, 5]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10, 4, 6, 1000, 10, 20]),8.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 5]),5.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 1, 3, 9, 9, 2, 7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_48","nl":"pes_Arab","pl":"pl","prompt":"# چک می کنه که رشته ای که داده شده یک پالندروم باشه یا نه# >>> is_palindrome(\"\")\n# 1\n# >>> is_palindrome(\"aba\")\n# 1\n# >>> is_palindrome(\"aaaaa\")\n# 1\n# >>> is_palindrome(\"zbcd\")\n# \"\"\nsub is_palindrome {\n    my($text) = @_;\n","canonical_solution":"sub is_palindrome {\n    my ($text) = @_;\n    return $text eq reverse($text) ? 1 : \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_palindrome;\n        if(eq_deeply($candidate->(\"\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aba\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaaa\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"zbcd\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywyx\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywyz\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywzx\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_49","nl":"pes_Arab","pl":"pl","prompt":"# 2^n را در پ (به اعداد توجه کنید) برگردانید.# >>> modp(3, 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n","canonical_solution":"sub modp {\n    my($n, $p) = @_;\n    return (2 ** $n) % $p;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_51","nl":"pes_Arab","pl":"pl","prompt":"# remove_vowels یک تابع است که رشته را می گیرد و رشته بدون حرف های صوتی را باز می گرداند. # >>> remove_vowels(\"\")\n# \"\"\n# >>> remove_vowels(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels(\"aaaaa\")\n# \"\"\n# >>> remove_vowels(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels(\"zbcd\")\n# \"zbcd\"\nsub remove_vowels {\n    my($text) = @_;\n","canonical_solution":"sub remove_vowels {\n    my($text) = @_;\n    $text =~ s\/[aeiouAEIOU]\/\/g;\n    return $text;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_vowels;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\nghijklm\"),\"bcdf\nghjklm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"fedcba\"),\"fdcb\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"acBAA\"),\"cB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"EcBOO\"),\"cB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ybcd\"),\"ybcd\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_52","nl":"pes_Arab","pl":"pl","prompt":"# اگر تمام اعداد در آرایه l زیر آستانه t باشند 1 را باز می گرداند.# >>> below_threshold([1, 2, 4, 10], 100)\n# 1\n# >>> below_threshold([1, 20, 4, 10], 5)\n# \"\"\nsub below_threshold {\n    my($l, $t) = @_;\n","canonical_solution":"sub below_threshold {\n    my($l, $t) = @_;\n    foreach my $num (@$l) {\n        return \"\" if $num >= $t;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&below_threshold;\n        if(eq_deeply($candidate->([1, 2, 4, 10], 100),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10], 5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10], 21),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10], 22),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 8, 4, 10], 11),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 8, 4, 10], 10),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_53","nl":"pes_Arab","pl":"pl","prompt":"# دو عدد x و y رو جمع کن# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\nsub add {\n    my($x, $y) = @_;\n","canonical_solution":"return $x + $y;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add;\n        if(eq_deeply($candidate->(0, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 0),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 3),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 7),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 5),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_54","nl":"pes_Arab","pl":"pl","prompt":"# چک کنید که آیا دو کلمه دارای کاراکترهای مشابهی هستند.# >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# 1\n# >>> same_chars(\"abcd\", \"dddddddabc\")\n# 1\n# >>> same_chars(\"dddddddabc\", \"abcd\")\n# 1\n# >>> same_chars(\"eabcd\", \"dddddddabc\")\n# \"\"\n# >>> same_chars(\"abcd\", \"dddddddabce\")\n# \"\"\n# >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# \"\"\nsub same_chars {\n    my($s0, $s1) = @_;\n","canonical_solution":"sub same_chars {\n    my($s0, $s1) = @_;\n    \n    my %chars_s0 = map { $_ => 1 } split \/\/, $s0;\n    my %chars_s1 = map { $_ => 1 } split \/\/, $s1;\n\n    foreach my $char (keys %chars_s0) {\n        return \"\" unless exists $chars_s1{$char};\n    }\n\n    foreach my $char (keys %chars_s1) {\n        return \"\" unless exists $chars_s0{$char};\n    }\n\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&same_chars;\n        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dddddddabc\", \"abcd\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eabcd\", \"dddddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabcf\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\", \"aaccc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_55","nl":"pes_Arab","pl":"pl","prompt":"# عدد n-م فیبوناچی را برگردانید.# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\nsub fib {\n    my($n) = @_;\n","canonical_solution":"sub fib {\n    my ($n) = @_;\n    return $n if $n <= 1;\n    my ($a, $b) = (0, 1);\n    for (2..$n) {\n        ($a, $b) = ($b, $a + $b);\n    }\n    return $b;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fib;\n        if(eq_deeply($candidate->(10),55)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),21)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),89)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),144)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_56","nl":"pes_Arab","pl":"pl","prompt":"# اگر هر بند باز شده دارای بند بسته باشد، 1 را باز می کند.# در این حالت، \"<\" و \">\" در میان هر دو قوس است.# >>> correct_bracketing(\"<\")\n# \"\"\n# >>> correct_bracketing(\"<>\")\n# 1\n# >>> correct_bracketing(\"<<><>>\")\n# 1\n# >>> correct_bracketing(\"><<>\")\n# \"\"\nsub correct_bracketing {\n    my($brackets) = @_;\n","canonical_solution":"sub correct_bracketing {\n    my($brackets) = @_;\n    my $balance = 0;\n\n    foreach my $char (split \/\/, $brackets) {\n        if ($char eq '<') {\n            $balance++;\n        } elsif ($char eq '>') {\n            $balance--;\n            if ($balance < 0) {\n                return \"\";\n            }\n        }\n    }\n    \n    return $balance == 0 ? 1 : \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&correct_bracketing;\n        if(eq_deeply($candidate->(\"<>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<><>>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<><>><>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<<><><>><>><<><><<>>>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<<><>>>>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"><<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<<<\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\">\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<><>><>><<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<><>><>>><>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_57","nl":"pes_Arab","pl":"pl","prompt":"# بازگشت 1 این است که عناصر آرایه به طور یکنواخت افزایش یا کاهش می یابند.# >>> monotonic([1, 2, 4, 20])\n# 1\n# >>> monotonic([1, 20, 4, 10])\n# \"\"\n# >>> monotonic([4, 1, 0, -10])\n# 1\nsub monotonic {\n    my($l) = @_;\n","canonical_solution":"sub monotonic {\n    my($l) = @_;\n    return 1 if @$l <= 1;\n    \n    my $increasing = 1;\n    my $decreasing = 1;\n    \n    for my $i (1 .. $#$l) {\n        if ($l->[$i] > $l->[$i - 1]) {\n            $decreasing = 0;\n        } elsif ($l->[$i] < $l->[$i - 1]) {\n            $increasing = 0;\n        }\n    }\n    \n    return $increasing || $decreasing ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&monotonic;\n        if(eq_deeply($candidate->([1, 2, 4, 10]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 4, 20]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 1, 0, -10]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 1, 1, 0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 2, 5, 60]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 60]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 9, 9, 9]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_58","nl":"pes_Arab","pl":"pl","prompt":"# عناصر مشترک منحصر به فرد مرتب شده برای دو آرایه را باز می گرداند.# >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n","canonical_solution":"sub common {\n    my($l1, $l2) = @_;\n    my %count;\n    $count{$_}++ for @$l1;\n    $count{$_}++ for grep { exists $count{$_} } @$l2;\n    return [ sort { $a <=> $b } grep { $count{$_} > 1 } keys %count ];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_59","nl":"pes_Arab","pl":"pl","prompt":"# بزرگترین عامل اول n را برگردانید. فرض کنید n > 1 و یک عدد اول نیست. # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\nsub largest_prime_factor {\n    my($n) = @_;\n","canonical_solution":"sub largest_prime_factor {\n    my($n) = @_;\n    my $largest_factor = 1;\n    my $factor = 2;\n\n    while ($n > 1) {\n        if ($n % $factor == 0) {\n            $largest_factor = $factor;\n            $n \/= $factor;\n        } else {\n            $factor++;\n        }\n    }\n    \n    return $largest_factor;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_prime_factor;\n        if(eq_deeply($candidate->(15),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(27),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(63),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(330),11)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13195),29)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_60","nl":"pes_Arab","pl":"pl","prompt":"# sum_to_n یک تابع است که اعداد 1 تا n را جمع می کند. # >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\nsub sum_to_n {\n    my($n) = @_;\n","canonical_solution":"sub sum_to_n {\n    my ($n) = @_;\n    return $n * ($n + 1) \/ 2;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_to_n;\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),21)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),66)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30),465)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),5050)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_61","nl":"pes_Arab","pl":"pl","prompt":"# اگر هر بند باز شده دارای بند بسته باشد، 1 را باز می کند.# در این حالت، هر دو علامت ({} و {}) در میان یک رشته از کلمات ({} و {}) است.# >>> correct_bracketing(\"(\")\n# \"\"\n# >>> correct_bracketing(\"()\")\n# 1\n# >>> correct_bracketing(\"(()())\")\n# 1\n# >>> correct_bracketing(\")(()\")\n# \"\"\nsub correct_bracketing {\n    my($brackets) = @_;\n","canonical_solution":"sub correct_bracketing {\n    my ($brackets) = @_;\n    my $balance = 0;\n\n    foreach my $char (split \/\/, $brackets) {\n        if ($char eq '(') {\n            $balance++;\n        } elsif ($char eq ')') {\n            $balance--;\n        }\n        # If balance is negative, it means there's a closing bracket without a matching opening\n        if ($balance < 0) {\n            return '';\n        }\n    }\n\n    # If balance is zero, all brackets are correctly matched\n    return $balance == 0 ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&correct_bracketing;\n        if(eq_deeply($candidate->(\"()\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()())\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()(()())()\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()((()()())())(()()(()))\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"((()())))\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\")(()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"((((\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\")\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()(()())())(()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()(()())()))()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_62","nl":"pes_Arab","pl":"pl","prompt":"# مشتق این چندمجموعه را در همان شکل برگردانید.# xs[0] + xs[1] * x + xs[2] * x^2 + .... # xs معادل یک چندملی را نشان می دهد.# >>> derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n# [2, 6]\nsub derivative {\n    my($xs) = @_;\n","canonical_solution":"sub derivative {\n    my($xs) = @_;\n    my @derivative;\n    \n    for my $i (1 .. $#{$xs}) {\n        push @derivative, $xs->[$i] * $i;\n    }\n    \n    return \\@derivative;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&derivative;\n        if(eq_deeply($candidate->([3, 1, 2, 4, 5]),[1, 4, 12, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1]),[2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1, 0, 4]),[2, 2, 0, 16])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_63","nl":"pes_Arab","pl":"pl","prompt":"# لطفاً یک تابع برای محاسبه ی n-مین عنصر از دنباله ی اعداد fibfib بنویسید.# fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3).# [===]# [= 0 ]# 0 0# دنباله اعداد فیب فیب یک دنباله مشابه به دنباله فیبوناچی است که به شرح زیر تعریف شده است: # >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\nsub fibfib {\n    my($n) = @_;\n","canonical_solution":"sub fibfib {\n    my($n) = @_;\n    return 0 if $n == 0;\n    return 0 if $n == 1;\n    return 1 if $n == 2;\n\n    my @fibfib = (0, 0, 1);\n    for my $i (3..$n) {\n        $fibfib[$i] = $fibfib[$i-1] + $fibfib[$i-2] + $fibfib[$i-3];\n    }\n    return $fibfib[$n];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fibfib;\n        if(eq_deeply($candidate->(2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),24)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),81)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),274)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(14),927)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_64","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# حرف صوتی، اما فقط وقتی که در انتهای کلمه ای باشد.# حرف های صوتی در این مورد \"a\"، \"e\"، \"i\"، \"o\"، \"u\" هستند. در اینجا \"y\" نیز یک \"a\" است.# یک کلمه را به عنوان ورودی می گیرد و تعداد حروف صوتی موجود در رشته را باز می گرداند.# یک تابع vowels_count بنویسید که یک رشته را نشان می دهد.# >>> vowels_count(\"abcde\")\n# 2\n# >>> vowels_count(\"ACEDY\")\n# 3\nsub vowels_count {\n    my($s) = @_;\n","canonical_solution":"sub vowels_count {\n    my($s) = @_;\n    my $count = 0;\n    my @chars = split \/\/, lc $s;\n    my $length = scalar @chars;\n\n    for my $i (0..$#chars) {\n        if ($chars[$i] =~ \/[aeiou]\/ || ($chars[$i] eq 'y' && $i == $length - 1)) {\n            $count++;\n        }\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&vowels_count;\n        if(eq_deeply($candidate->(\"abcde\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Alone\"),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"key\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bye\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"keY\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bYe\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ACEDY\"),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_65","nl":"pes_Arab","pl":"pl","prompt":"# اگر shift > عدد ارقام باشد، ارقام برگشت معکوس شده است.# و نتیجه را به شکل یک رشته باز می گرداند.# و به صورت دایره ای، اعداد صحیح عدد x را به سمت راست حرکت دهید.# >>> circular_shift(12, 1)\n# \"21\"\n# >>> circular_shift(12, 2)\n# \"12\"\nsub circular_shift {\n    my($x, $shift) = @_;\n","canonical_solution":"sub circular_shift {\n    my($x, $shift) = @_;\n    my $digits = length($x);\n    \n    if ($shift > $digits) {\n        return reverse $x;\n    }\n    \n    $shift = $shift % $digits;\n    my $shifted = substr($x, -$shift) . substr($x, 0, $digits - $shift);\n    \n    return $shifted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&circular_shift;\n        if(eq_deeply($candidate->(100, 2),\"001\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 2),\"12\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(97, 8),\"79\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 1),\"21\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11, 101),\"11\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_66","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# کد های ASCII# یک تابع بنویسید که یک رشته را به عنوان ورودی می گیرد و تنها مجموع کاراکترهای بالا را باز می گرداند.# کار # >>> digitSum(\"\")\n# 0\n# >>> digitSum(\"abAB\")\n# 131\n# >>> digitSum(\"abcCd\")\n# 67\n# >>> digitSum(\"helloE\")\n# 69\n# >>> digitSum(\"woArBld\")\n# 131\n# >>> digitSum(\"aAaaaXa\")\n# 153\nsub digitSum {\n    my($s) = @_;\n","canonical_solution":"sub digitSum {\n    my($s) = @_;\n    my $sum = 0;\n    foreach my $char (split \/\/, $s) {\n        if ($char =~ \/[A-Z]\/) {\n            $sum += ord($char);\n        }\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&digitSum;\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abAB\"),131)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcCd\"),67)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"helloE\"),69)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"woArBld\"),131)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aAaaaXa\"),153)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\" How are yOu?\"),151)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"You arE Very Smart\"),327)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_67","nl":"pes_Arab","pl":"pl","prompt":"# برای examble: # در سبد عدد میوه های مانگو را در سبد برگردانید.# پرتقال و سیب و یک عدد صحیح که نشان دهنده تعداد کل میوه ها است # سیب، پرتقال و میوه های مانگو. با توجه به رشته ای که نشان دهنده تعداد کل # که در سبد میوه ای که در این سبد هست توزیع شده# در این کار، یک رشته به شما داده می شود که نشان دهنده تعداد سیب و پرتقال است.# >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n# 19\nsub fruit_distribution {\n    my($s, $n) = @_;\n","canonical_solution":"sub fruit_distribution {\n    my($s, $n) = @_;\n    \n    # Extract numbers from the input string\n    my ($apples, $oranges) = $s =~ \/(\\d+) apples and (\\d+) oranges\/;\n    \n    # Calculate total apples and oranges\n    my $total_apples_oranges = $apples + $oranges;\n    \n    # Calculate number of mangoes\n    my $mangoes = $n - $total_apples_oranges;\n    \n    return $mangoes;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fruit_distribution;\n        if(eq_deeply($candidate->(\"5 apples and 6 oranges\", 19),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5 apples and 6 oranges\", 21),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0 apples and 1 oranges\", 3),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1 apples and 0 oranges\", 3),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2 apples and 3 oranges\", 100),95)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2 apples and 3 oranges\", 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1 apples and 100 oranges\", 120),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_68","nl":"pes_Arab","pl":"pl","prompt":"# مثال 1:# اگر هیچ مقدار جفتی وجود نداشته باشد یا آرایه داده شده خالی باشد، return [] را برگردانید.# گره ی انتخاب شده باید در یک آرایه، [smallest_value، index آن]، # اگر چندین گره با کوچکترین مقدار جفت یافت شود گره ای را که کوچکترین شاخص دارد را بازگردانید. # گره ای که از آن می چسبد باید گره ای با کوچکترین مقدار جفت باشد.# کار شما اینه که یکی از گره ها رو از بین ببریم و برگردونیمش# \"در صورت داشتن یک آرایه که یک شاخه از یک درخت را نشان می دهد که دارای گره های عدد صحیح غیر منفی است # >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n","canonical_solution":"sub pluck {\n    my ($arr) = @_;\n    my $min_even_value = undef;\n    my $min_index = undef;\n\n    for my $i (0 .. @$arr - 1) {\n        my $value = $arr->[$i];\n        if ($value % 2 == 0) {\n            if (!defined($min_even_value) || $value < $min_even_value) {\n                $min_even_value = $value;\n                $min_index = $i;\n            }\n        }\n    }\n\n    return defined($min_even_value) ? [$min_even_value, $min_index] : [];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_69","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# اگر چنین ارزشی وجود نداشته باشد، -1 را بازگردانید.# فرکانس یک عدد صحیح، تعداد دفعات ظاهر شدن آن در آرایه است.# صفر، و فرکانس آن بیشتر از یا برابر با ارزش عدد صحیح است.# یک آرایه ی خالی از اعداد صحیح مثبت به شما داده شده است. بزرگترین عدد صحیح را که بزرگتر از  است، برگردانید.# >>> search([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search([5, 5, 4, 4, 4])\n# -1\nsub search {\n    my($lst) = @_;\n","canonical_solution":"sub search {\n    my($lst) = @_;\n    my %frequency;\n\n    foreach my $num (@$lst) {\n        $frequency{$num}++;\n    }\n\n    my $result = -1;\n    foreach my $num (keys %frequency) {\n        if ($num > 0 && $frequency{$num} >= $num) {\n            if ($num > $result) {\n                $result = $num;\n            }\n        }\n    }\n\n    return $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&search;\n        if(eq_deeply($candidate->([5, 5, 5, 5, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 1, 4, 1, 4, 4]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 3]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 8, 8, 8, 8, 8, 8, 8]),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 3, 3, 2, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 8, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 8, 3, 6, 5, 6, 4]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 9, 10, 1, 3]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 10, 10, 9, 2]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_70","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# بعد حداکثر عدد باقیمانده، بعد حداقل و غیره.# مرتب کردن عجیب، وقتی است که شما با حداقل مقدار شروع می کنید، # با توجه به آرایه ای از اعداد صحیح، آرایه را در ترتیب عجیب برگردانید.# >>> strange_sort_list([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list([])\n# []\nsub strange_sort_list {\n    my($lst) = @_;\n","canonical_solution":"sub strange_sort_list {\n    my($lst) = @_;\n    my @result;\n    my @sorted = sort {$a <=> $b} @$lst;\n    \n    while (@sorted) {\n        push @result, shift @sorted;\n        push @result, pop @sorted if @sorted;\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strange_sort_list;\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 4, 2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 5, 5, 5]),[5, 5, 5, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([111111]),[111111])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_71","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# از طرف سوم.# سه طرف مثلث درستي رو درست ميکنه وقتي که مجموع هر دو طرف بزرگتر باشه# در غیر این صورت -1 را برگردانید# مثلث به دو نقطه اعشار اگر سه طرف یک مثلث معتبر را تشکیل دهند.# با توجه به طول سه طرف مثلث، مساحت  را بر می گردانیم.# >>> triangle_area(3, 4, 5)\n# 6.0\n# >>> triangle_area(1, 2, 10)\n# -1\nsub triangle_area {\n    my($a, $b, $c) = @_;\n","canonical_solution":"sub triangle_area {\n    my($a, $b, $c) = @_;\n    \n    # Check if the sides form a valid triangle\n    unless ($a + $b > $c && $a + $c > $b && $b + $c > $a) {\n        return -1;\n    }\n    \n    # Calculate the semi-perimeter\n    my $s = ($a + $b + $c) \/ 2;\n    \n    # Calculate the area using Heron's formula\n    my $area = sqrt($s * ($s - $a) * ($s - $b) * ($s - $c));\n    \n    # Return the area rounded to 2 decimal points\n    return sprintf(\"%.2f\", $area);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&triangle_area;\n        if(eq_deeply($candidate->(3, 4, 5),6.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 10),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 8, 5),8.18)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 2),1.73)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 3),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 5, 7),16.25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 6, 3),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 1, 1),0.43)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 10),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_72","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# اگر شیء q متعادل باشد (این یک آرایه پالندروم است) و مجموع عناصر آن کمتر از یا برابر با حداکثر وزن ممکن w باشد، پرواز خواهد کرد.# یک تابع بنویسید که اگر شی q پرواز کند 1 را باز می گرداند و در غیر این صورت ' ' را.# >>> will_it_fly([1, 2], 5)\n# \"\"\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly([3, 2, 3], 1)\n# \"\"\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly([3, 2, 3], 9)\n# 1\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly([3], 5)\n# 1\n# # 3 is less than the maximum possible weight, and it's balanced.\nsub will_it_fly {\n    my($q, $w) = @_;\n","canonical_solution":"sub will_it_fly {\n    my($q, $w) = @_;\n    # Check if the array is palindromic\n    my @reversed = reverse @$q;\n    return '' unless \"@$q\" eq \"@reversed\";\n\n    # Check if the sum of elements is within weight limit\n    my $sum = 0;\n    $sum += $_ for @$q;\n    return $sum <= $w ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&will_it_fly;\n        if(eq_deeply($candidate->([3, 2, 3], 9),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2], 5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3], 5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 3], 1),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3], 6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5], 5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_73","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# در یک تغییر، شما می توانید یک عنصر را به هر عنصر دیگر تغییر دهید.# برای اینکه آرایه ای پالندروم باشد باید تغییر کند. یک آرایه پالندروم یک آرایه است که # با توجه به آرایه ای از اعداد صحیح، حداقل تعداد عناصر را پیدا کنید که # >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change([1, 2, 3, 2, 1])\n# 0\nsub smallest_change {\n    my($arr) = @_;\n","canonical_solution":"sub smallest_change {\n    my($arr) = @_;\n    my $count = 0;\n    my $n = scalar @$arr;\n    \n    for my $i (0 .. int($n \/ 2) - 1) {\n        if ($arr->[$i] != $arr->[$n - $i - 1]) {\n            $count++;\n        }\n    }\n    \n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&smallest_change;\n        if(eq_deeply($candidate->([1, 2, 3, 5, 4, 7, 9, 6]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 3, 2, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 4, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 2, 1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 1, 1, 3]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_74","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# اگر دو آرایه دارای تعداد کار مشابهی باشند، اولین آرایه را بازگردانید.# تعداد کل کار ها در تمام رشته های آرایه کمتر از آرایه دیگر است.# یک تابع بنویسید که دو آرایه از رشته ها را قبول کند و آرایه ای را که دارای # >>> total_match([], [])\n# []\n# >>> total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\nsub total_match {\n    my($lst1, $lst2) = @_;\n","canonical_solution":"sub total_match {\n    my ($lst1, $lst2) = @_;\n    \n    my $len1 = sum_chars($lst1);\n    my $len2 = sum_chars($lst2);\n\n    return $len1 <= $len2 ? $lst1 : $lst2;\n}\n\nsub sum_chars {\n    my ($array) = @_;\n    my $total = 0;\n    foreach my $string (@$array) {\n        $total += length($string);\n    }\n    return $total;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&total_match;\n        if(eq_deeply($candidate->([], []),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hi\", \"hi\"]),[\"hi\", \"hi\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]),[\"hi\", \"admin\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]),[\"4\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hI\", \"Hi\"]),[\"hI\", \"Hi\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]),[\"hI\", \"hi\", \"hi\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]),[\"hi\", \"admin\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([], [\"this\"]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"this\"], []),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_75","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# با دانستن اینکه a کمتر از 100 است.# و در غیر این صورت غلط است.# يک تابع بنویسيد که اگر عدد داده شده ضرب 3 عدد اول باشد، جوابش صحيح است.# >>> is_multiply_prime(30)\n# 1\n# 30 = 2 * 3 * 5\nsub is_multiply_prime {\n    my($a) = @_;\n","canonical_solution":"sub is_multiply_prime {\n    my($a) = @_;\n\n    return 0 if $a >= 100;\n\n    my @primes = grep { is_prime($_) } 2..int($a\/2);\n\n    for my $i (0..$#primes) {\n        for my $j ($i..$#primes) {\n            for my $k ($j..$#primes) {\n                if ($primes[$i] * $primes[$j] * $primes[$k] == $a) {\n                    return 1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nsub is_prime {\n    my($n) = @_;\n    return 0 if $n < 2;\n    for my $i (2..sqrt($n)) {\n        return 0 if $n % $i == 0;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_multiply_prime;\n        if(eq_deeply($candidate->(5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(125),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(105),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(126),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(729),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(891),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1001),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_76","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# x یک توان ساده از n است اگر n**int=x # توان n و در موارد دیگر غلط است.# کار شما اینه که یک تابع بنویسی که اگر عدد x یک عدد ساده باشه راست رو برگردونه# >>> is_simple_power(1, 4)\n# 1\n# >>> is_simple_power(2, 2)\n# 1\n# >>> is_simple_power(8, 2)\n# 1\n# >>> is_simple_power(3, 2)\n# \"\"\n# >>> is_simple_power(3, 1)\n# \"\"\n# >>> is_simple_power(5, 3)\n# \"\"\nsub is_simple_power {\n    my($x, $n) = @_;\n","canonical_solution":"sub is_simple_power {\n    my($x, $n) = @_;\n    \n    return 0 if $n <= 0;\n    return \"\" if $x < 1;\n    \n    if ($x == 1) {\n        return 1;\n    }\n\n    while ($x > 1) {\n        if ($x % $n != 0) {\n            return \"\";\n        }\n        $x \/= $n;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_simple_power;\n        if(eq_deeply($candidate->(16, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(143214, 16),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9, 3),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(16, 4),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(24, 2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(128, 4),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 12),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_77","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# توجه: شما ممکن است فرض کنید که ورودی همیشه معتبر است.# اگر این عدد یک عدد صحیح باشد.# يک تابع بنویسيد که يک عدد صحيح a را در نظر بگيرد و 1 را برگرداند# >>> iscube(1)\n# 1\n# >>> iscube(2)\n# \"\"\n# >>> iscube(-1)\n# 1\n# >>> iscube(64)\n# 1\n# >>> iscube(0)\n# 1\n# >>> iscube(180)\n# \"\"\nsub iscube {\n    my($a) = @_;\n","canonical_solution":"sub iscube {\n    my($a) = @_;\n    my $cube_root = int($a ** (1\/3));\n    return 1 if $cube_root ** 3 == $a;\n    return 1 if ($cube_root + 1) ** 3 == $a; # handle small floating-point errors\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&iscube;\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(64),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(180),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1729),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_78","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# و نمادها A,B,C,D,E,F همیشه بزرگ هستند.# توجه: شما ممکن است فرض کنید ورودی همیشه صحیح یا خالی است رشته، # B (= دهمی 11) ، D (= دهمی 13).# پس باید یکی از این اعداد را پیدا کنید: 2، 3، 5، 7، # اعداد اول 2، 3، 5، 7، 11، 13، 17، ...# ارقام هگزادسیمال: 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، A، B، C، D، E، F.# بزرگتر از 1 که حاصل حاصل دو عدد طبیعی کوچکتر نیست).# عددهایی که اعداد اول هستند (عدد اول یا عدد اول، یک عدد طبیعی است)# یک عدد هگزادسیمال به عنوان یک رشته و تعداد هگزادسیمال را می شمارد # شما مأموریت نوشتن تابع دریافت کننده را دارید# >>> hex_key(\"AB\")\n# 1\n# >>> hex_key(\"1077E\")\n# 2\n# >>> hex_key(\"ABED1A33\")\n# 4\n# >>> hex_key(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key(\"2020\")\n# 2\nsub hex_key {\n    my($num) = @_;\n","canonical_solution":"sub hex_key {\n    my($num) = @_;\n    my %prime_hex_digits = map { $_ => 1 } ('2', '3', '5', '7', 'B', 'D');\n    my $prime_count = 0;\n    \n    foreach my $char (split \/\/, $num) {\n        $prime_count++ if exists $prime_hex_digits{$char};\n    }\n    \n    return $prime_count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&hex_key;\n        if(eq_deeply($candidate->(\"AB\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1077E\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ABED1A33\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2020\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"123456789ABCDEF0\"),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"112233445566778899AABBCCDDEEFF00\"),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_79","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# کاراکترهای اضافی برای کمک به شکل بندی وجود دارند.# دو کاراکتر اضافی \"db\" در ابتدای و پایان رشته وجود خواهد داشت.# هر کاراکتر در رشته \"0\" یا \"1\" خواهد بود.# فرمت باینری. تابع باید یک رشته را برگرداند، که هر کاراکتر یک باینری را نشان می دهد.# به شما یک عدد در شکل اعشاری داده می شود و وظیفه شما این است که آن را به  تبدیل کنید.# >>> decimal_to_binary(15)\n# \"db1111db\"\n# >>> decimal_to_binary(32)\n# \"db100000db\"\nsub decimal_to_binary {\n    my($decimal) = @_;\n","canonical_solution":"sub decimal_to_binary {\n    my($decimal) = @_;\n    my $binary = sprintf(\"%b\", $decimal);\n    return \"db\" . $binary . \"db\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&decimal_to_binary;\n        if(eq_deeply($candidate->(0),\"db0db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(32),\"db100000db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(103),\"db1100111db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(15),\"db1111db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_80","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# یک رشته اگر حداقل 3 تا طول داشته باشه و هر 3 حرف متوالی متفاوت باشه خوشحال میشه# وظیفه شما اینه که چک کنید که رشته ها خوش شانس هستند یا نه# شما یک رشته داده شده است.# >>> is_happy(\"a\")\n# \"\"\n# >>> is_happy(\"aa\")\n# \"\"\n# >>> is_happy(\"abcd\")\n# 1\n# >>> is_happy(\"aabb\")\n# \"\"\n# >>> is_happy(\"adb\")\n# 1\n# >>> is_happy(\"xyy\")\n# \"\"\nsub is_happy {\n    my($s) = @_;\n","canonical_solution":"sub is_happy {\n    my($s) = @_;\n    return \"\" if length($s) < 3;\n    for my $i (0 .. length($s) - 3) {\n        my $substr = substr($s, $i, 3);\n        my %chars;\n        $chars{$_}++ for split \/\/, $substr;\n        return \"\" if keys(%chars) != 3;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_happy;\n        if(eq_deeply($candidate->(\"a\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aa\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"adb\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"iopaxpoi\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"iopaxioi\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_81","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# 0.0 E # > 0.0 D- # > 0.7 D # > 1.0 D+ # > 1.3 C- # > 1.7 درجه سانتی گراد# > 2.0 C+ # > 2.3 B- # > 2.7 B # > 3.0 B+ # > 3.3 A- # > 3.7 A # 4.0 A+ # نمره ی متوسط. نمره ی حرفی.# تابعی که می تواند با استفاده از جدول زیر، آرایه ای از درجه های حروف را به نمایش بگذارد: # اون برات يه سري از نمره هاي بعضي دانشجوها رو داده و تو بايد بنويسي# تنها مشکل اينه که اون رمزي که براي نمره دادن استفاده مي کرد رو گم کرده# معلم الگوریتم خودش را برای نمره دادن درست کرده است.# آخرين هفته ترم هست و معلم بايد نمره ها رو بده# >>> grade_equation([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nsub numerical_letter_grade {\n    my($grades) = @_;\n","canonical_solution":"sub numerical_letter_grade {\n    my ($gpas) = @_;\n    my @letters;\n\n    foreach my $gpa (@$gpas) {\n        if ($gpa == 4.0) {\n            push @letters, 'A+';\n        } elsif ($gpa > 3.7) {\n            push @letters, 'A';\n        } elsif ($gpa > 3.3) {\n            push @letters, 'A-';\n        } elsif ($gpa > 3.0) {\n            push @letters, 'B+';\n        } elsif ($gpa > 2.7) {\n            push @letters, 'B';\n        } elsif ($gpa > 2.3) {\n            push @letters, 'B-';\n        } elsif ($gpa > 2.0) {\n            push @letters, 'C+';\n        } elsif ($gpa > 1.7) {\n            push @letters, 'C';\n        } elsif ($gpa > 1.3) {\n            push @letters, 'C-';\n        } elsif ($gpa > 1.0) {\n            push @letters, 'D+';\n        } elsif ($gpa > 0.7) {\n            push @letters, 'D';\n        } elsif ($gpa > 0.0) {\n            push @letters, 'D-';\n        } else {\n            push @letters, 'E';\n        }\n    }\n\n    return \\@letters;\n}\n\nmy $gpas = [4.0, 3, 1.7, 2, 3.5];\nmy $letter_grades = numerical_letter_grade($gpas);\nprint join(\", \", @$letter_grades);","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&numerical_letter_grade;\n        if(eq_deeply($candidate->([4.0, 3, 1.7, 2, 3.5]),[\"A+\", \"B\", \"C-\", \"C\", \"A-\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.2]),[\"D+\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.5]),[\"D-\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0]),[\"E\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 0.3, 1.5, 2.8, 3.3]),[\"D\", \"D-\", \"C-\", \"B\", \"B+\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0, 0.7]),[\"E\", \"D-\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_82","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# طول یک عدد اول است یا \" ' در غیر این صورت # یک تابع بنویسید که یک رشته را می گیرد و 1 را بازمی گرداند اگر رشته # >>> prime_length(\"Hello\")\n# 1\n# >>> prime_length(\"abcdcba\")\n# 1\n# >>> prime_length(\"kittens\")\n# 1\n# >>> prime_length(\"orange\")\n# \"\"\nsub prime_length {\n    my($string) = @_;\n","canonical_solution":"sub prime_length {\n    my ($string) = @_;\n    my $length = length($string);\n\n    return '' if $length < 2;\n    for my $i (2 .. sqrt($length)) {\n        return '' if $length % $i == 0;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prime_length;\n        if(eq_deeply($candidate->(\"Hello\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdcba\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"kittens\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"orange\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"wow\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"world\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"MadaM\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Wow\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"HI\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"go\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"gogo\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaaaaaaaaaaaaa\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Madam\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"M\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_83","nl":"pes_Arab","pl":"pl","prompt":"# اعداد صحیح مثبت که با 1 شروع یا به پایان می رسند.# با توجه به یک عدد صحیح مثبت n، تعداد اعداد n-رقمی را برگردانید sub starts_one_ends {\n    my($n) = @_;\n","canonical_solution":"sub starts_one_ends {\n    my($n) = @_;\n    \n    # If n is 1, the numbers are 1, 2, 3, ..., 9 (single digit numbers starting\n    # or ending with 1), hence return 1 (only the number 1).\n    return 1 if $n == 1;\n\n    # Calculate the count of numbers starting with 1\n    # Numbers from 1..9 (n-1 zeros) give us 10^(n-1) choices\n    my $start_one_count = 10 ** ($n - 1);\n\n    # Calculate the count of numbers ending with 1\n    # Numbers from 10..10^(n-1) give us 10^(n-1) choices\n    my $end_one_count = 10 ** ($n - 1);\n\n    # However, numbers that both start and end with 1 (like 111...1)\n    # are counted twice so we need to add them in only once.\n    my $both_count = 1; # There's exactly one such number: 10^(n-1) + 1\n\n    # Total unique count\n    my $total_count = $start_one_count + $end_one_count - $both_count;\n\n    return $total_count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&starts_one_ends;\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2),18)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),180)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),1800)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),18000)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_84","nl":"pes_Arab","pl":"pl","prompt":"# مثال# با توجه به یک عدد صحیح مثبت N، مجموع رقم های آن را در دوگانه برگردانید. # >>> solve(1000)\n# \"1\"\n# >>> solve(150)\n# \"110\"\n# >>> solve(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\nsub solve {\n    my($N) = @_;\n","canonical_solution":"sub solve {\n    my($N) = @_;\n    my $sum = 0;\n    $sum += $_ for split \/\/, $N;\n    return sprintf(\"%b\", $sum);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n        if(eq_deeply($candidate->(1000),\"1\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(150),\"110\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(147),\"1100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(333),\"1001\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(963),\"10010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_85","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# با توجه به یک آرایه غیر خالی از اعداد صحیح اول، عناصر جفت را که در شاخص های عجیب هستند اضافه کنید.# >>> add([4, 2, 6, 7])\n# 2\nsub add {\n    my($lst) = @_;\n","canonical_solution":"sub add {\n    my ($lst) = @_;\n    my $sum = 0;\n\n    for (my $i = 1; $i < @$lst; $i += 2) {\n        $sum += $lst->[$i] if $lst->[$i] % 2 == 0;\n    }\n\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add;\n        if(eq_deeply($candidate->([4, 88]),88)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 5, 6, 7, 2, 122]),122)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 0, 6, 7]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 4, 6, 8]),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_86","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# توجه: باید ترتیب کلمات و فضاهای خالی را در جمله حفظ کنید.# به ترتیب رو به بالا بر اساس ارزش ASCII# با کلمه ای جدید جایگزین می شوند که در آن همه کاراکترها در # نسخه ی مرتب شده ی رشته، رشته ای است که در آن همه ی کلمات (با فاصله جدا شده) # یک تابع بنویسید که یک رشته را می گیرد و یک نسخه مرتب شده از آن را باز می گرداند.# >>> anti_shuffle(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\nsub anti_shuffle {\n    my($s) = @_;\n","canonical_solution":"sub anti_shuffle {\n    my($s) = @_;\n    $s =~ s\/(\\S+)\/join('', sort split \/\/, $1)\/ge;\n    return $s;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&anti_shuffle;\n        if(eq_deeply($candidate->(\"Hi\"),\"Hi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"hello\"),\"ehllo\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"number\"),\"bemnru\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\"),\"abcd\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello World!!!\"),\"Hello !!!Wdlor\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How aer ?ouy\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_87","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# همچنین، مختصات ردیف را به ترتیب ستون ها مرتب کنید.# مختصات را ابتدا به ترتیب بالا رفتن در ردیف ها مرتب کنید.# هر آرایه یک مختصات است (صف، ستون) ، با 0 شروع می شود.# و آرایه آرایه ها را برگردانید، [(x1، y1، (x2، y2) ...] به طوری که # با توجه به lst و عدد صحیح x، عدد صحیح x را در آرایه پیدا کنید، # هر ردیف ممکن است شامل تعداد ستون های متفاوت باشد.# که شبیه ماتریس است، اما برخلاف ماتریس ها،# شما یک داده دو بعدی به عنوان یک آرایه ی آشیانه ای دریافت می کنید،# >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row([], 1)\n# []\n# >>> get_row([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\nsub get_row {\n    my($lst, $x) = @_;\n","canonical_solution":"sub get_row {\n    my ($lst, $x) = @_;\n    my @result;\n\n    for my $i (0 .. @$lst - 1) {\n        my @row_result;\n        for my $j (0 .. @{$lst->[$i]} - 1) {\n            if ($lst->[$i][$j] == $x) {\n                push @row_result, [$i, $j];\n            }\n        }\n        # Sort the coordinates of the row by columns in descending order\n        @row_result = sort { $b->[1] <=> $a->[1] } @row_result;\n        push @result, @row_result;\n    }\n\n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_row;\n        if(eq_deeply($candidate->([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([], 1),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1]], 2),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[], [1], [1, 2, 3]], 3),[[2, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_88","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# * آرایه داده شده را تغییر ندهید. # توجه:# یا آن را به ترتیب رو به پایین مرتب کنید اگر مجموع ((قیمت شاخص اول، ارزش شاخص آخر) جفت باشد. # شما آرایه داده شده را به ترتیب رو به بالا مرتب خواهید کرد اگر مجموع ((قیمت شاخص اول، ارزش شاخص آخر) عجیب باشد، # با توجه به یک آرایه از اعداد صحیح غیر منفی، یک copl از آرایه داده شده را پس از مرتب سازی، # >>> sort_array([])\n# []\n# >>> sort_array([5])\n# [5]\n# >>> sort_array([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\nsub sort_array {\n    my($array) = @_;\n","canonical_solution":"sub sort_array {\n    my ($array) = @_;\n    return [] if !@$array;  # Return empty array if input is empty\n\n    my $first = $array->[0];\n    my $last = $array->[-1];\n    my $sum = $first + $last;\n\n    if ($sum % 2 == 0) {\n        # Sort in descending order if the sum is even\n        return [sort { $b <=> $a } @$array];\n    } else {\n        # Sort in ascending order if the sum is odd\n        return [sort { $a <=> $b } @$array];\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_array;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5]),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 1]),[1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([21, 14, 23, 11]),[23, 21, 14, 11])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_89","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# دو برابر دو تا جا عوض میشه# الفبا باید به گونه ای چرخش کند که حروف # یک رشته رمزگذاری شده با چرخش الفبا را باز می گرداند.# یک تابع رمزگذاری شده ایجاد کنید که یک رشته را به عنوان یک آرگومنت می گیرد و # >>> encrypt(\"hi\")\n# \"lm\"\n# >>> encrypt(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt(\"gf\")\n# \"kj\"\n# >>> encrypt(\"et\")\n# \"ix\"\nsub encrypt {\n    my($s) = @_;\n","canonical_solution":"sub encrypt {\n    my($s) = @_;\n    my $shift = 2 * 2;  # Alphabet shifted by two multiplied by two places (4 places)\n    $s =~ tr\/a-zA-Z\/n-za-mN-ZA-M\/;  # Perform a Caesar cipher with a shift of 13 places\n    return $s;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encrypt;\n        if(eq_deeply($candidate->(\"hi\"),\"lm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdfghjkl\"),\"ewhjklnop\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"gf\"),\"kj\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"et\"),\"ix\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"faewfawefaewg\"),\"jeiajeaijeiak\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"hellomyfriend\"),\"lippsqcjvmirh\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"),\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a\"),\"e\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_90","nl":"pes_Arab","pl":"pl","prompt":"# اگر چنین عنصری وجود نداشته باشد undef را برگردانید.# یک تابع next_smallest (() بنویسید که کوچکترین عنصر آرایه را باز می گرداند. # شما یک آرایه از اعداد صحیح داده شده اید.# >>> next_smallest([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest([])\n# undef\n# >>> next_smallest([1, 1])\n# undef\nsub next_smallest {\n    my($lst) = @_;\n","canonical_solution":"sub next_smallest {\n    my($lst) = @_;\n    \n    # Return undef if the list has less than two elements\n    return undef unless @$lst >= 2;\n    \n    # Sort the unique elements of the list\n    my @sorted_unique = sort { $a <=> $b } keys %{{ map { $_ => 1 } @$lst }};\n    \n    # If there is only one unique element, return undef, else return the second smallest\n    return @sorted_unique >= 2 ? $sorted_unique[1] : undef;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&next_smallest;\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 1, 4, 3, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1, 1, 0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-35, 34, 12, -45]),-35)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_91","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# جملات با \"\"، \"؟\" یا \"!\" جدا می شوند.# حوصله ی بی حوصله، جمله ای است که با کلمه ی \"من\" شروع می شود.# به شما یک رشته از کلمات داده می شود، و وظیفه شما این است که آن عدد را بشمارید.# >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\nsub is_bored {\n    my($S) = @_;\n","canonical_solution":"my($S) = @_;\n    my $count = 0;\n    my @sentences = split \/(?<=[.?!])\\s*\/, $S;\n    foreach my $sentence (@sentences) {\n        $sentence =~ s\/^\\s+|\\s+$\/\/g;\n        $count++ if $sentence =~ \/^I\\b\/i;\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_bored;\n        if(eq_deeply($candidate->(\"Hello world\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Is the sky blue?\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I love It !\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bIt\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I feel good today. I will be productive. will kill It\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"You and I are going for a walk\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_92","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# در هر مورد دیگر false را باز می گرداند.# اگر یکی از اعداد برابر با مجموع دو عدد دیگر باشد و همه اعداد اعداد صحیح باشند، درست را برمی گرداند.# یک تابع بساز که 3 عدد داشته باشه# >>> any_int(5, 2, 7)\n# 1\n# >>> any_int(3, 2, 2)\n# \"\"\n# >>> any_int(3, -2, 1)\n# 1\n# >>> any_int(3.6, -2.2, 2)\n# \"\"\nsub any_int {\n    my($x, $y, $z) = @_;\n","canonical_solution":"sub any_int {\n    my($x, $y, $z) = @_;\n    \n    # Check if all inputs are integers\n    return \"\" unless defined $x && defined $y && defined $z;\n    return \"\" unless $x =~ \/^-?\\d+$\/ && $y =~ \/^-?\\d+$\/ && $z =~ \/^-?\\d+$\/;\n    \n    # Check if any number is the sum of the other two\n    return 1 if $x == $y + $z;\n    return 1 if $y == $x + $z;\n    return 1 if $z == $x + $y;\n    \n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&any_int;\n        if(eq_deeply($candidate->(2, 3, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2.5, 2, 3),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1.5, 5, 3.5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 6, 2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 2, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2.2, 2.2, 2.2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-4, 6, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 1, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 4, 7),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3.0, 4, 7),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_93","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# فقط حرف ها رو فرض کن# حرفي در الفباي انگليسي# پيام با حريفي که دو جاي جلوتر از اون هست# به این ترتیب که همه حروف را عوض می کند و همه حروف صوتی را در  جایگزین می کند.# یک تابع بنویسید که یک پیام را دریافت کند و آن را در چنین # >>> encode(\"test\")\n# \"TGST\"\n# >>> encode(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\nsub encode {\n    my($message) = @_;\n","canonical_solution":"sub encode {\n    my($message) = @_;\n    $message =~ tr\/A-Za-z\/N-ZA-Mn-za-m\/;\n    $message =~ tr\/aeiouAEIOU\/cgkqwCGKQW\/;\n    return $message;\n}\n\n# Example usage\nprint encode(\"test\"), \"\\n\";       # Output: TGST\nprint encode(\"This is a message\"), \"\\n\"; # Output: tHKS KS C MGSSCGG","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encode;\n        if(eq_deeply($candidate->(\"TEST\"),\"tgst\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir\"),\"mWDCSKR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"YES\"),\"ygs\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"This is a message\"),\"tHKS KS C MGSSCGG\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT kNqW wHcT Tq wRkTg\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_94","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# باید بزرگترین مقدار اول را پیدا کنید و جمع ارقام آن را برگردانید.# شما یک آرایه از اعداد صحیح داده شده اید.# >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd([0, 8, 1, 2, 1, 7])\n# 7\nsub skjkasdkd {\n    my($lst) = @_;\n","canonical_solution":"sub skjkasdkd {\n    my ($lst) = @_;\n\n    # Helper function to determine if a number is prime\n    sub is_prime {\n        my ($num) = @_;\n        return 0 if $num < 2;\n        for my $i (2 .. sqrt($num)) {\n            return 0 if $num % $i == 0;\n        }\n        return 1;\n    }\n\n    # Find the largest prime in the array\n    my $largest_prime = -1;\n    foreach my $num (@$lst) {\n        if (is_prime($num)) {\n            $largest_prime = $num if $num > $largest_prime;\n        }\n    }\n\n    # Return the sum of the digits of the largest prime\n    if ($largest_prime > 0) {\n        my $sum_of_digits = 0;\n        $sum_of_digits += $_ for split \/\/, $largest_prime;\n        return $sum_of_digits;\n    }\n\n    return 0;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&skjkasdkd;\n        if(eq_deeply($candidate->([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 81, 12, 3, 1, 21]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 8, 1, 2, 1, 7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8191]),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8191, 123456, 127, 7]),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([127, 97, 8192]),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_95","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# تابع باید '' را برگرداند اگر هش داده شده خالی باشد.# case یا همه کلیدها رشته هایی با حرف بزرگ هستند، در غیر این صورت return ' ' را باز می گرداند.# با توجه به هش، 1 را برگردانید اگر تمام کلیدها رشته هایی در lower  باشند.# >>> check_dict_case({\"a\" => \"apple\", \"b\" => \"banana\"})\n# 1\n# >>> check_dict_case({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# \"\"\n# >>> check_dict_case({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# \"\"\n# >>> check_dict_case({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# \"\"\n# >>> check_dict_case({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# 1\nsub check_dict_case {\n    my($dict) = @_;\n","canonical_solution":"sub check_dict_case {\n    my($dict) = @_;\n    return '' unless %$dict;\n\n    my $all_lower = 1;\n    my $all_upper = 1;\n\n    for my $key (keys %$dict) {\n        if ($key !~ \/^[a-z]+$\/) {\n            $all_lower = 0;\n        }\n        if ($key !~ \/^[A-Z]+$\/) {\n            $all_upper = 0;\n        }\n    }\n    \n    return ($all_lower || $all_upper) ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_dict_case;\n        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"b\" => \"banana\"}),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_96","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# عدد تمام که اعداد اول هستند و کمتر از n هستند.# تابعی را اجرا کنید که یک عدد صحیح غیرمنفی را می گیرد و یک آرایه از اولین n را باز می گرداند .# >>> count_up_to(5)\n# [2, 3]\n# >>> count_up_to(11)\n# [2, 3, 5, 7]\n# >>> count_up_to(0)\n# []\n# >>> count_up_to(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to(1)\n# []\n# >>> count_up_to(18)\n# [2, 3, 5, 7, 11, 13, 17]\nsub count_up_to {\n    my($n) = @_;\n","canonical_solution":"sub count_up_to {\n    my($n) = @_;\n    my @primes;\n    for my $num (2 .. $n - 1) {\n        my $is_prime = 1;\n        for my $div (2 .. sqrt($num)) {\n            if ($num % $div == 0) {\n                $is_prime = 0;\n                last;\n            }\n        }\n        push @primes, $num if $is_prime;\n    }\n    return @primes;\n}\n\n# Example usage:\n# my @result = count_up_to(11);\n# print \"@result\\n\";  # Output: 2 3 5 7","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_up_to;\n        if(eq_deeply($candidate->(5),[2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),[2, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[2, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),[2, 3, 5, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(22),[2, 3, 5, 7, 11, 13, 17, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(18),[2, 3, 5, 7, 11, 13, 17])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_97","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# فرض کنید که ورودی همیشه معتبر است.# حاصل حاصل از ارقام واحد آنها.# تابع را که دو عدد صحیح را می گیرد تکمیل کنید و  را برگردانید.# >>> multiply(148, 412)\n# 16\n# >>> multiply(19, 28)\n# 72\n# >>> multiply(2020, 1851)\n# 0\n# >>> multiply(14, -15)\n# 20\nsub multiply {\n    my($a, $b) = @_;\n","canonical_solution":"sub multiply {\n    my($a, $b) = @_;\n    my $unit_digit_a = abs($a) % 10;\n    my $unit_digit_b = abs($b) % 10;\n    return $unit_digit_a * $unit_digit_b;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&multiply;\n        if(eq_deeply($candidate->(148, 412),16)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(19, 28),72)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2020, 1851),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(14, -15),20)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(76, 67),42)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(17, 27),49)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0, 1),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0, 0),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_98","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# با توجه به یک رشته s، تعداد حروف بلند بزرگ را در شاخص های جفت محاسبه کنید.# >>> count_upper(\"aBCdEf\")\n# 1\n# >>> count_upper(\"abcdefg\")\n# 0\n# >>> count_upper(\"dBBE\")\n# 0\nsub count_upper {\n    my($s) = @_;\n","canonical_solution":"sub count_upper {\n    my($s) = @_;\n    my $count = 0;\n    my @chars = split \/\/, $s;\n    \n    for (my $i = 0; $i < @chars; $i += 2) {\n        if ($chars[$i] =~ \/[AEIOU]\/) {\n            $count++;\n        }\n    }\n    \n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_upper;\n        if(eq_deeply($candidate->(\"aBCdEf\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdefg\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dBBE\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"B\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"U\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"EEEE\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_99","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# از دو عدد صحیح، دور از صفر گرد کنیم.# و نزدیک ترین عدد صحیح را به آن باز می گرداند. اگر عدد به هم فاصله باشد # یک تابع ایجاد کنید که یک مقدار (سلسله) را که یک عدد را نشان می دهد را می گیرد.# >>> closest_integer(\"10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\nsub closest_integer {\n    my($value) = @_;\n","canonical_solution":"sub closest_integer {\n    my($value) = @_;\n    \n    # Convert the string value to a number\n    my $number = 0 + $value;\n    \n    # Compute the floor and ceiling of the number\n    my $floor = int($number);\n    my $ceiling = $number > $floor ? $floor + 1 : $floor;\n    \n    # Determine the integer to round to\n    if ($number < 0) {\n        # For negative numbers, closer to zero means returning the lower number\n        return ($number - $floor <= $ceiling - $number) ? $floor : $ceiling;\n    } else {\n        # For positive numbers, closer to zero means returning the lower number\n        return ($ceiling - $number <= $number - $floor) ? $ceiling : $floor;\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&closest_integer;\n        if(eq_deeply($candidate->(\"10\"),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"14.5\"),15)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"-15.5\"),-16)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"15.3\"),15)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_100","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# i نشان دهنده تعداد سنگ ها در سطح (i+1) است.# تعداد سنگ ها را در هر سطح در یک آرایه برگرداند، که در آن عنصر در شاخص # - اگر n جفت باشد، عدد جفت بعدی است.# - اگر n عدد جفتی باشد عدد جفت بعدی است.# تعداد سنگ ها در سطح بعد اينه:# سطح اول دارای n سنگ است.# با توجه به یک عدد صحیح مثبت n، شما باید یک توده از n سطح از سنگ ها را بسازید.# >>> make_a_pile(3)\n# [3, 5, 7]\nsub make_a_pile {\n    my($n) = @_;\n","canonical_solution":"sub make_a_pile {\n    my ($n) = @_;\n    my @pile;\n    my $current_stones = $n;\n    \n    for my $level (1..$n) {\n        push @pile, $current_stones;\n        if ($n % 2 == 0) {\n            $current_stones += 2;  # Increment by next even number\n        } else {\n            $current_stones += 2;  # Increment by next odd number (which is also +2)\n        }\n    }\n    \n    return @pile;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_a_pile;\n        if(eq_deeply($candidate->(3),[3, 5, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[4, 6, 8, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[5, 7, 9, 11, 13])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),[6, 8, 10, 12, 14, 16])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[8, 10, 12, 14, 16, 18, 20, 22])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_101","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# برای تقسیم رشته به کلمات و بازگشت یک آرایه از کلمات.# شما یک رشته از کلمات به شما داده خواهد شد که با کمیک یا فاصله جدا شده اند.# >>> words_string(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nsub words_string {\n    my($s) = @_;\n","canonical_solution":"sub words_string {\n    my ($s) = @_;\n    my @words = split \/[,\\s]+\/, $s;\n    return \\@words;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&words_string;\n        if(eq_deeply($candidate->(\"Hi, my name is John\"),[\"Hi\", \"my\", \"name\", \"is\", \"John\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"One, two, three, four, five, six\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hi, my name\"),[\"Hi\", \"my\", \"name\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"One,, two, three, four, five, six,\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ahmed     , gamal\"),[\"ahmed\", \"gamal\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_102","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.# بزرگترین عدد صحیح جفتی که در محدوده [x، y] شامل است. اگر # این تابع دو عدد مثبت x و y را می گیرد و  را بازمی گرداند.# >>> choose_num(12, 15)\n# 14\n# >>> choose_num(13, 12)\n# -1\nsub choose_num {\n    my($x, $y) = @_;\n","canonical_solution":"sub choose_num {\n    my($x, $y) = @_;\n    return -1 if $x > $y;\n    \n    # Swap x and y if x is greater than y\n    ($x, $y) = ($y, $x) if $x > $y;\n    \n    for (my $i = $y; $i >= $x; $i--) {\n        return $i if $i % 2 == 0;\n    }\n    return -1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&choose_num;\n        if(eq_deeply($candidate->(12, 15),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13, 12),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(33, 12354),12354)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5234, 5233),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6, 29),28)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(27, 10),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 7),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(546, 546),546)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_103","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# اگر n بزرگتر از m باشد، -1 را برگردانید.# جواب رو به نزدیکترین عدد صحیح گردون بزنید و آن را به عدد دوتایی تبدیل کنید.# میانگین اعداد صحیح از n تا m (از جمله n و m)# شما دو عدد صحیح مثبت n و m دارید، و وظیفه شما محاسبه # >>> rounded_avg(1, 5)\n# \"0b11\"\n# >>> rounded_avg(7, 5)\n# -1\n# >>> rounded_avg(10, 20)\n# \"0b1111\"\n# >>> rounded_avg(20, 33)\n# \"0b11010\"\nsub rounded_avg {\n    my($n, $m) = @_;\n","canonical_solution":"sub rounded_avg {\n    my ($n, $m) = @_;\n    \n    return -1 if $n > $m;\n    \n    my $sum = 0;\n    my $count = $m - $n + 1;\n    \n    for my $i ($n .. $m) {\n        $sum += $i;\n    }\n    \n    my $average = int(($sum \/ $count) + 0.5);\n    return sprintf(\"0b%b\", $average);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rounded_avg;\n        if(eq_deeply($candidate->(1, 5),\"0b11\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 13),\"0b1010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(964, 977),\"0b1111001010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(996, 997),\"0b1111100100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(560, 851),\"0b1011000010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(185, 546),\"0b101101110\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(362, 496),\"0b110101101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(350, 902),\"0b1001110010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(197, 233),\"0b11010111\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 5),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 1),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 5),\"0b101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_104","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# توجه: آرایه ی بازگردانده شده باید به ترتیب افزایش یافته مرتب شود.# عناصر که هیچ عددی جفتی ندارند.# با توجه به آرایه ای از اعداد صحیح مثبت x. یک آرایه مرتب شده از همه  را برگردانید.# >>> unique_digits([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits([152, 323, 1422, 10])\n# []\nsub unique_digits {\n    my($x) = @_;\n","canonical_solution":"sub unique_digits {\n    my ($x) = @_;\n    my @result;\n\n    foreach my $num (@$x) {\n        if ($num !~ \/[02468]\/) {\n            push @result, $num;\n        }\n    }\n    \n    return sort { $a <=> $b } @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique_digits;\n        if(eq_deeply($candidate->([15, 33, 1422, 1]),[1, 15, 33])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([152, 323, 1422, 10]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12345, 2033, 111, 151]),[111, 151])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([135, 103, 31]),[31, 135])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_105","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# يک، دو، سه، چهار، پنج، شش، هفت، هشت، نه# آرایه حاصل را معکوس کنید، و سپس هر رقم را با نام مربوطه اش از  جایگزین کنید.# با توجه به آرایه ای از اعداد صحیح، اعداد صحیح را که بین 1 تا 9 هستند مرتب کنید، # >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length([1, -1, 55])\n# [\"One\"]\nsub by_length {\n    my($arr) = @_;\n","canonical_solution":"sub by_length {\n    my ($arr) = @_;\n    my @names = qw(Zero One Two Three Four Five Six Seven Eight Nine);\n    \n    my @filtered_sorted_reversed = reverse sort { $a <=> $b } grep { $_ >= 1 && $_ <= 9 } @$arr;\n    my @result = map { $names[$_] } @filtered_sorted_reversed;\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&by_length;\n        if(eq_deeply($candidate->([2, 1, 1, 4, 5, 8, 2, 3]),[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 55]),[\"One\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 3, 2]),[\"Three\", \"Two\", \"One\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 4, 8]),[\"Nine\", \"Eight\", \"Four\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_106","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# فاکتورال i ضرب اعداد 1 تا i است (1 * 2 * ... * i).# من از 1 شروع مي کنم# یا مجموع اعداد از 1 تا i در غیر این صورت.# و یک آرایه ی اندازه ی n را برمی گرداند، به طوری که ارزش عنصر در شاخص i فاکتور i باشد اگر i جفت باشد.# تابع f را اجرا کنید که n را به عنوان پارامتر می گیرد، # >>> f(5)\n# [1, 2, 6, 24, 15]\nsub f {\n    my($n) = @_;\n","canonical_solution":"sub f {\n    my($n) = @_;\n    my @result;\n\n    for my $i (1..$n) {\n        if ($i % 2 == 0) {\n            my $factorial = 1;\n            $factorial *= $_ for 1..$i;\n            push @result, $factorial;\n        } else {\n            my $sum = 0;\n            $sum += $_ for 1..$i;\n            push @result, $sum;\n        }\n    }\n    \n    return @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&f;\n        if(eq_deeply($candidate->(5),[1, 2, 6, 24, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[1, 2, 6, 24, 15, 720, 28])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),[1, 2, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_107","nl":"pes_Arab","pl":"pl","prompt":"# مثال 1:# palindromes عدد صحیح که در محدوده ((۱، n) قرار دارند.# با توجه به یک عدد صحیح مثبت n، یک آرایه را که تعداد اعداد جفت و عجیب را دارد، برگردانید.# >>> even_odd_palindrome(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\nsub even_odd_palindrome {\n    my($n) = @_;\n","canonical_solution":"sub even_odd_palindrome {\n    my($n) = @_;\n    my $even_count = 0;\n    my $odd_count = 0;\n    for my $i (1..$n) {\n        if ($i == reverse $i) {\n            if ($i % 2 == 0) {\n                $even_count++;\n            } else {\n                $odd_count++;\n            }\n        }\n    }\n    return [$even_count, $odd_count];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&even_odd_palindrome;\n        if(eq_deeply($candidate->(123),[8, 13])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),[4, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),[1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(63),[6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(25),[5, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(19),[4, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),[4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_108","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال -123 دارای علامت های -1, 2 و 3 است.# اگر یک عدد منفی باشد، اولین رقم امضا شده اش منفی خواهد بود: # تعداد عناصر که مجموع رقم های آن > 0 است. # تابع count_nums را بنویسید که یک آرایه از اعداد صحیح را می گیرد و  را باز می گرداند.# >>> count_nums([])\n# 0\n# >>> count_nums([-1, 11, -11])\n# 1\n# >>> count_nums([1, 1, 2])\n# 3\nsub count_nums {\n    my($arr) = @_;\n","canonical_solution":"sub count_nums {\n    my($arr) = @_;\n    my $count = 0;\n\n    foreach my $num (@$arr) {\n        my $sum_of_digits = 0;\n        my @digits = split \/\/, $num;\n        $sum_of_digits += shift @digits; # add the signed digit\n        $sum_of_digits += $_ for @digits;\n        $count++ if $sum_of_digits > 0;\n    }\n\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_nums;\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, 0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 2, -2, 3, 4, 5]),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 6, 9, -6, 0, 1, 5]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 100, 98, -7, 1, -1]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12, 23, 34, -45, -56, 0]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_109","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# توجه: آرایه داده شده تضمین شده است که عناصر منحصر به فرد داشته باشد.# اگر آرایه خالی باشد، 1 را برگردانید.# سپس 1 را برگردانید و سپس ' را برگردانید.# اگر امکان دارد که آرایه مرتب شده را با انجام عملیات فوق بدست آوریم # موقعیت اولیه در آرایه یعنی شاخص صفر.# آخرین عنصر آرایه به سمت  منتقل خواهد شد.# یک عملیات شیفت راست به معنی تغییر همه عناصر آرایه به یک است.# شما اجازه دارید که هر چند بار هم که می خواهید حرکت سمت راست را انجام دهید.# عملیات زیر روی آرایه داده شده: # این امکان وجود دارد که یک آرایه را به ترتیب غیر کاهش یافته با انجام # اعداد در آرایه به صورت تصادفی ترتیب داده می شوند. وظیفه شما این است که تعیین کنید که آیا# ما یک آرایه \"arr\" از N عدد صحیح arr[1], arr[2]، ..., arr[N] داریم.# >>> move_one_ball([3, 4, 5, 1, 2])\n# 1\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball([3, 5, 4, 1, 2])\n# \"\"\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\nsub move_one_ball {\n    my($arr) = @_;\n","canonical_solution":"sub move_one_ball {\n    my ($arr) = @_;\n    my $n = scalar @$arr;\n    return 1 if $n == 0;\n\n    for my $i (0 .. $n - 1) {\n        my @shifted = (@$arr[$i .. $n - 1], @$arr[0 .. $i - 1]);\n        if (is_sorted(\\@shifted)) {\n            return 1;\n        }\n    }\n    return '';\n}\n\nsub is_sorted {\n    my ($arr) = @_;\n    for my $i (0 .. $#$arr - 1) {\n        return 0 if $arr->[$i] > $arr->[$i + 1];\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&move_one_ball;\n        if(eq_deeply($candidate->([3, 4, 5, 1, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 10, 1, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 1, 2]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 4, 1, 2]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_110","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# در غیر این صورت، \"نه\" را برگردانید.# تمام عناصر lst1 را جفت کنید، \"YES\" را برگردانید.# اگه امکان مبادله عناصر بين lst1 و lst2 وجود داشته باشه# هیچ محدودیتی برای تعداد عناصر مبادله شده بین lst1 و lst2 وجود ندارد.# بین آنها برای ایجاد یک آرایه از اعداد جفت.# و مشخص می کند که آیا امکان انجام مبادله عناصر وجود دارد یا نه.# در این مسئله، شما یک تابع را اجرا خواهید کرد که دو آرایه از اعداد را می گیرد، # >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\nsub exchange {\n    my($lst1, $lst2) = @_;\n","canonical_solution":"sub exchange {\n    my ($lst1, $lst2) = @_;\n    \n    # Check if lst1 is already all-even\n    my $all_even = 1;\n    foreach my $num (@$lst1) {\n        if ($num % 2 != 0) {\n            $all_even = 0;\n            last;\n        }\n    }\n    return \"YES\" if $all_even;\n\n    # Check if there is at least one even number in lst2\n    my $can_exchange = 0;\n    foreach my $num (@$lst2) {\n        if ($num % 2 == 0) {\n            $can_exchange = 1;\n            last;\n        }\n    }\n\n    # Calculate the count of odd numbers in lst1\n    my $odd_count_lst1 = 0;\n    foreach my $num (@$lst1) {\n        $odd_count_lst1++ if ($num % 2 != 0);\n    }\n\n    # If there are even numbers in lst2 and odd numbers in lst1, we can exchange\n    if ($can_exchange && $odd_count_lst1 > 0) {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&exchange;\n        if(eq_deeply($candidate->([1, 2, 3, 4], [1, 2, 3, 4]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4], [1, 5, 3, 4]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4], [2, 1, 4, 3]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 7, 3], [2, 6, 4]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 7, 3], [2, 6, 3]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, 200], [200, 200]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_111","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# اگر چندین حرف با هم مشابه باشند، همه آنها را برگردانید.# از نامه ای که بیشترین تکرار را دارد و تعداد مربوطه را دارد.# با توجه به یک رشته که نشان دهنده یک حروف کوچک جدا شده با فضای است، یک هش را بازگردانید.# >>> histogram(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram(\"\")\n# {}\nsub histogram {\n    my($test) = @_;\n","canonical_solution":"sub histogram {\n    my ($test) = @_;\n    my %count;\n\n    # Split the input string by spaces and count occurrences of each letter\n    $count{$_}++ for split ' ', $test;\n\n    # Determine the maximum count\n    my $max_count = 0;\n    $max_count = $count{$_} > $max_count ? $count{$_} : $max_count for keys %count;\n\n    # Collect all letters with the maximum count\n    my %result = map { $_ => $count{$_} } grep { $count{$_} == $max_count } keys %count;\n\n    return \\%result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&histogram;\n        if(eq_deeply($candidate->(\"a b b a\"),{\"a\" => 2, \"b\" => 2})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c a b\"),{\"a\" => 2, \"b\" => 2})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c d g\"),{\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"r t g\"),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"b b b b a\"),{\"b\" => 4})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"r t g\"),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),{})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a\"),{\"a\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_112","nl":"pes_Arab","pl":"pl","prompt":"# مثال# شما باید یک آرایه را که شامل رشته نتیجه و 1\/' برای چک است، برگردانید.# یک رشته به اصطلاح پالندروم نامیده می شود اگر به همان اندازه که به جلو خوانده می شود به عقب نیز خوانده شود.# سپس بررسی کنید که رشته ی نتیجه ای پالندرم است یا نه. # ما دو رشته s و c داریم، شما باید تمام کاراکترهای s را که با هر کاراکتر c برابر است حذف کنید.# کار # >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\", \"\"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n","canonical_solution":"sub reverse_delete {\n    my($s, $c) = @_;\n    \n    # Create a hash of characters to be deleted for quick lookup\n    my %chars_to_delete = map { $_ => 1 } split \/\/, $c;\n    \n    # Remove characters that need to be deleted\n    $s =~ s\/[$c]\/\/g;\n    \n    # Check if the resulting string is a palindrome\n    my $is_palindrome = ($s eq reverse $s) ? 1 : '';\n\n    # Return the resulting string and palindrome check\n    return [$s, $is_palindrome];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_113","nl":"pes_Arab","pl":"pl","prompt":"# از اعداد عجیب در رشته i'th از ورودی. # string i از ورودی. \" که در آن همه i باید با عدد  جایگزین شود.# هر عنصر i از خروجی باید \"تعداد عناصر عجیب در # با توجه به یک آرایه از رشته ها، که هر رشته فقط از ارقام تشکیل شده است، یک آرایه را بازگردانید.# >>> odd_count([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nsub odd_count {\n    my($lst) = @_;\n","canonical_solution":"sub odd_count {\n    my ($lst) = @_;\n    my @output;\n    foreach my $str (@$lst) {\n        my $odd_count = 0;\n        $odd_count++ while $str =~ \/[13579]\/g;\n        push @output, \"the number of odd elements ${odd_count}n the str${odd_count}ng ${odd_count} of the ${odd_count}nput.\";\n    }\n    return \\@output;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&odd_count;\n        if(eq_deeply($candidate->([\"1234567\"]),[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"3\", \"11111111\"]),[\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"271\", \"137\", \"314\"]),[\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_114","nl":"pes_Arab","pl":"pl","prompt":"# مثال# از اعداد# با توجه به یک آرایه از اعداد صحیح n، حداقل مجموع هر زیر آرایه غیر خالی را پیدا کنید.# >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum([-1, -2, -3])\n# -6\nsub minSubArraySum {\n    my($nums) = @_;\n","canonical_solution":"sub minSubArraySum {\n    my($nums) = @_;\n    my $minSum = $nums->[0];\n    my $currentSum = 0;\n    \n    foreach my $num (@$nums) {\n        $currentSum += $num;\n        if ($currentSum < $minSum) {\n            $minSum = $currentSum;\n        }\n        if ($currentSum > 0) {\n            $currentSum = 0;\n        }\n    }\n    \n    return $minSum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&minSubArraySum;\n        if(eq_deeply($candidate->([2, 3, 4, 1, 2, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, -3]),-6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, -3, 2, -10]),-14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-9999999999999999]),-9999999999999999)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 10, 20, 1000000]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, -3, 10, -5]),-6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, -1, -2, -3, 10, -5]),-6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10, 11, 13, 8, 3, 4]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, -33, 32, -1, 0, -2]),-33)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10]),-10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_115","nl":"pes_Arab","pl":"pl","prompt":"# مثال 1:# تعداد دفعاتي که براي پايين آوردن سطل ها نياز داريد را وارد کنيد.# کار شما اينه که از سطل ها استفاده کنيد تا چاه ها رو خالي کنيد# و همه سطل ها ظرفیت یکسانی دارند.# هر چاه يه سطل مناسب داره که ميتونه براي استخراج آب ازش استفاده بشه# و هر 1 در یک ردیف نشان دهنده یک واحد آب است.# شما یک شبکه مستطیل از چاه ها دارید. هر ردیف یک چاه را نشان می دهد.# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n    my($grid, $capacity) = @_;\n","canonical_solution":"sub max_fill {\n    my($grid, $capacity) = @_;\n    my $total_water_units = 0;\n    \n    for my $row (@$grid) {\n        for my $unit (@$row) {\n            $total_water_units += $unit;\n        }\n    }\n    \n    my $bucket_uses = int(($total_water_units + $capacity - 1) \/ $capacity);\n    return $bucket_uses;\n}\n\n# Examples\nprint max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) . \"\\n\"; # 6\nprint max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) . \"\\n\"; # 5\nprint max_fill([[0, 0, 0], [0, 0, 0]], 5) . \"\\n\"; # 0","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_116","nl":"pes_Arab","pl":"pl","prompt":"# بايد اينطوري اجرا بشه:# برای تعداد مشابه یک ها، بر اساس مقدار اعشاری مرتب کنید.# تعداد اعداد در نمایش دوگانه آنها به ترتیب رو به افزایش.# در این کاتا، شما باید یک آرایه از اعداد صحیح غیرمنفی را بر اساس # >>> sort_array([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\nsub sort_array {\n    my($arr) = @_;\n","canonical_solution":"sub sort_array {\n    my($arr) = @_;\n    return [sort { sprintf(\"%b\", $a) =~ tr\/1\/\/ <=> sprintf(\"%b\", $b) =~ tr\/1\/\/ || $a <=> $b } @$arr];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_array;\n        if(eq_deeply($candidate->([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_117","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# توجه: شما ممکن است فرض کنید که رشته ورودی فقط شامل حروف و فضاها است.# اگر رشته s خالی باشد، تابع باید یک آرایه خالی را برگرداند.# n ضمائر، به ترتیب این کلمات در رشته s ظاهر می شوند. # تابعی که یک آرایه از تمام کلمات را از رشته s که دقیقا شامل  هستند، باز می گرداند.# با توجه به یک رشته s و یک عدد طبیعی n، شما وظیفه دارید که # >>> select_words(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words(\"simple white space\", 2)\n# []\n# >>> select_words(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words(\"Uncle sam\", 3)\n# [\"Uncle\"]\nsub select_words {\n    my($s, $n) = @_;\n","canonical_solution":"sub select_words {\n    my($s, $n) = @_;\n    return [] if $s eq '';\n    \n    my @words = split(\/\\s+\/, $s);\n    my @result;\n    \n    foreach my $word (@words) {\n        my $consonant_count = () = $word =~ \/[^aeiouAEIOU]\/g;\n        push @result, $word if $consonant_count == $n;\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&select_words;\n        if(eq_deeply($candidate->(\"Mary had a little lamb\", 4),[\"little\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mary had a little lamb\", 3),[\"Mary\", \"lamb\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"simple white space\", 2),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello world\", 4),[\"world\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Uncle sam\", 3),[\"Uncle\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\", 4),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c d e f\", 1),[\"b\", \"c\", \"d\", \"f\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_118","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# شما ممکن است فرض کنید که رشته داده شده شامل حرف انگلیسی تنها.# هر حرف صوتی را که شرایط بالا را برآورده کند پیدا کنید.# حرفهای صوتی در آغاز و پایان شمارش نمی شوند. اگر این کار را نکرده اید، یک رشته خالی را برگردانید.# دو تا از سمت راست کلمه (حساس از حروف کوچک و بزرگ)# به شما یک کلمه داده شده. وظیفه شما این است که نزدیک ترین حرف صوتی را که بین آن قرار دارد پیدا کنید.# >>> get_closest_vowel(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel(\"quick\")\n# \"\"\n# >>> get_closest_vowel(\"ab\")\n# \"\"\nsub get_closest_vowel {\n    my($word) = @_;\n","canonical_solution":"sub get_closest_vowel {\n    my($word) = @_;\n    my @chars = split \/\/, $word;\n    my $vowel = '';\n    my @vowels = qw(a e i o u A E I O U);\n    my %vowel_hash = map { $_ => 1 } @vowels;\n\n    for (my $i = $#chars - 1; $i > 0; $i--) {\n        if ($vowel_hash{$chars[$i]} && !$vowel_hash{$chars[$i - 1]} && !$vowel_hash{$chars[$i + 1]}) {\n            $vowel = $chars[$i];\n            last;\n        }\n    }\n\n    return $vowel;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_closest_vowel;\n        if(eq_deeply($candidate->(\"yogurt\"),\"u\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"full\"),\"u\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"easy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eAsy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ali\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bad\"),\"a\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"most\"),\"o\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ab\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ba\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"quick\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"anime\"),\"i\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Asia\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Above\"),\"o\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_119","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# اگر راهی برای ساختن یک رشته خوب وجود داشته باشد، \"بله\" را برگردانید و در غیر این صورت \"نه\" را برگردانید.# \" (()) \" نیست.# برای مثال: رشته \"((((() \" خوب است، در حالی که رشته # یک رشته S خوب است اگر و تنها اگر همه ی دایره ها در S # بعضی از دستورات، که رشته ی حاصل خوب خواهد بود.# کار شما اینه که چک کنید که میشه دو رشته رو به هم وصل کرد یا نه# فقط در قوس های \" ((\" یا قوس های نزدیک \")) \"# شما یک آرایه از دو رشته داده شده است، هر دو رشته شامل باز است.# >>> match_parens([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens([\")\", \")\"])\n# \"No\"\nsub match_parens {\n    my($lst) = @_;\n","canonical_solution":"sub match_parens {\n    my($lst) = @_;\n    my ($a, $b) = @$lst;\n    \n    # Helper to check if a string is good (i.e., parentheses balanced)\n    sub is_good {\n        my ($str) = @_;\n        my $balance = 0;\n        for my $ch (split \/\/, $str) {\n            $balance++ if $ch eq '(';\n            $balance-- if $ch eq ')';\n            return 0 if $balance < 0; # Too many closing parens\n        }\n        return $balance == 0; # Balanced if zero\n    }\n    \n    # Check both combinations\n    return \"Yes\" if is_good($a . $b) || is_good($b . $a);\n    return \"No\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&match_parens;\n        if(eq_deeply($candidate->([\"()(\", \")\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")\", \")\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(()(())\", \"())())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")())\", \"(()()(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(())))\", \"(()())((\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"()\", \"())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(()(\", \"()))()\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"((((\", \"((())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")(()\", \"(()(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")(\", \")(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(\", \")\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")\", \"(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_120","nl":"pes_Arab","pl":"pl","prompt":"# مثال 1:# با حداکثر تعداد k عدد در arr.# با توجه به یک آرایه ی آر آر از اعداد صحیح و یک عدد صحیح مثبت k، یک آرایه ی مرتب شده را برگردانید # >>> maximum([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\nsub maximum {\n    my($arr, $k) = @_;\n","canonical_solution":"sub maximum {\n    my($arr, $k) = @_;\n    my @sorted = sort { $b <=> $a } @$arr;  # Sort in descending order\n    my @result = sort { $a <=> $b } @sorted[0..$k-1];  # Take first k elements and sort them\n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&maximum;\n        if(eq_deeply($candidate->([-3, -4, 5], 3),[-4, -3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, -4, 4], 2),[4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 2, 1, 2, -1, -2, 1], 1),[2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 0, 2, 5, 3, -10], 2),[3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 5, -7], 1),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, -4], 2),[-4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10, 10], 2),[-10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, -23, 243, -400, 0], 0),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_121","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# با توجه به یک آرایه غیر خالی از اعداد صحیح، جمع تمام عناصر عجیب و غریب را که در موقعیت های جفت هستند، برگردانید.# >>> solution([5, 8, 7, 1])\n# 12\n# >>> solution([3, 3, 3, 3, 3])\n# 9\n# >>> solution([30, 13, 24, 321])\n# 0\nsub solution {\n    my($lst) = @_;\n","canonical_solution":"sub solution {\n    my($lst) = @_;\n    my $sum = 0;\n    for (my $i = 0; $i < @$lst; $i += 2) {\n        $sum += $lst->[$i] if $lst->[$i] % 2 != 0;\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solution;\n        if(eq_deeply($candidate->([5, 8, 7, 1]),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 3, 3, 3, 3]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([30, 13, 24, 321]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 9]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 8]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([30, 13, 23, 32]),23)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 13, 2, 9]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_122","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# جمع عناصر با حداکثر دو رقم از k عنصر اول arr است. # با توجه به یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، return # >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\nsub add_elements {\n    my($arr, $k) = @_;\n","canonical_solution":"sub add_elements {\n    my ($arr, $k) = @_;\n    my $sum = 0;\n    for my $i (0..$k-1) {\n        $sum += $arr->[$i] if $arr->[$i] >= -99 && $arr->[$i] <= 99;\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add_elements;\n        if(eq_deeply($candidate->([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([111, 121, 3, 4000, 5, 6], 2),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1], 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_123","nl":"pes_Arab","pl":"pl","prompt":"# get_odd_collatz(5) [1, 5] را باز می گرداند # دنباله collatz برای 5 [5, 16, 8, 4, 2, 1] است، بنابراین اعداد عجیب تنها 1 و 5 هستند. # برای مثال:# 2. آرایه ی برگشت شده را به ترتیب افزایش یافته مرتب کنید.# 1. Collatz ((1) [1] است.# توجه:# این حدس این است که مهم نیست که مقدار n چقدر باشد، دنباله همیشه به 1 خواهد رسید.# اگر عبارت قبلی عجیب باشد، عبارت بعدی 3 برابر عبارت قبلی خواهد بود.# اصطلاح قبلی به صورت زیر: اگر اصطلاح قبلی جفت باشد، اصطلاح بعدی نصف  است.# به شرح زیر: با هر عدد صحیح مثبت n شروع کنید. سپس هر اصطلاح از  بدست می آید.# حدس کولاتز یک حدس در ریاضیات است که مربوط به یک دنباله تعریف شده است.# با توجه به یک عدد صحیح مثبت n، یک آرایه مرتب شده را که دارای اعداد عجیب در دنباله collatz است، برگردانید. # >>> get_odd_collatz(5)\n# [1, 5]\nsub get_odd_collatz {\n    my($n) = @_;\n","canonical_solution":"sub get_odd_collatz {\n    my ($n) = @_;\n    my %odd_numbers;\n    \n    while ($n != 1) {\n        $odd_numbers{$n} = 1 if $n % 2 != 0;\n        if ($n % 2 == 0) {\n            $n = $n \/ 2;\n        } else {\n            $n = 3 * $n + 1;\n        }\n    }\n    $odd_numbers{1} = 1;\n    \n    return sort { $a <=> $b } keys %odd_numbers;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_odd_collatz;\n        if(eq_deeply($candidate->(14),[1, 5, 7, 11, 13, 17])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[1, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),[1, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_124","nl":"pes_Arab","pl":"pl","prompt":"# ۴- تاریخ باید در قالب: mm-dd-yyyy باشد.# 3. ماه ها نباید کمتر از 1 یا بیشتر از 12 باشد.# تعداد روزهای ماه 1، 3، 5، 7، 8، 10، 12 کمتر از 1 یا بیشتر از 31 روز نیست و تعداد روزهای ماه 4، 6، 9، 11 کمتر از 1 یا بیشتر از 30 روز نیست و تعداد روزهای ماه 2 کمتر از 1 یا بیشتر از 29 روز نیست.# 1. رشته تاریخ خالی نیست.# این تاریخ در صورتی معتبر است که تمام قواعد زیر رعایت شده باشد:# اگر تاریخ معتبر باشد 1 را باز می گرداند در غیر این صورت \"\".# شما باید یک تابع بنویسید که یک رشته تاریخ داده شده را تایید کند و # >>> valid_date(\"03-11-2000\")\n# 1\n# >>> valid_date(\"15-01-2012\")\n# \"\"\n# >>> valid_date(\"04-0-2040\")\n# \"\"\n# >>> valid_date(\"06-04-2020\")\n# 1\n# >>> valid_date(\"06\/04\/2020\")\n# \"\"\nsub valid_date {\n    my($date) = @_;\n","canonical_solution":"sub valid_date {\n    my ($date) = @_;\n    \n    # Check if date is empty\n    return '' if !$date;\n    \n    # Date pattern for mm-dd-yyyy\n    if ($date =~ \/^(\\d{2})-(\\d{2})-(\\d{4})$\/) {\n        my ($month, $day, $year) = ($1, $2, $3);\n        \n        # Check month validity\n        return '' if $month < 1 || $month > 12;\n        \n        # Check day validity based on the month\n        my %days_in_month = (\n            1 => 31, 2 => 29, 3 => 31, 4 => 30,\n            5 => 31, 6 => 30, 7 => 31, 8 => 31,\n            9 => 30, 10 => 31, 11 => 30, 12 => 31\n        );\n        \n        return '' if $day < 1 || $day > $days_in_month{$month};\n        \n        # If all conditions are satisfied, return 1\n        return 1;\n    }\n    \n    # If date does not match the pattern, return ''\n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&valid_date;\n        if(eq_deeply($candidate->(\"03-11-2000\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"15-01-2012\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-0-2040\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"06-04-2020\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"01-01-2007\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"03-32-2011\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-31-3000\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"06-06-2005\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"21-31-2000\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-12-2003\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04122003\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"20030412\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2003-04\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2003-04-12\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-2003\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_125","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# الفبا، ord ((('a') = 0، ord ((('b') = 1، ... ord ((('z') = 25# باید با کمیک تقسیم شود ',' اگر هیچ کمیک وجود نداشته باشد باید تعداد حروف کوچک را با ترتیب عجیب در # با توجه به یک رشته کلمات، یک آرایه از کلمات تقسیم شده بر روی فضای خالی را برگردانید، اگر هیچ فضای خالی در متن شما وجود نداشته باشد.# >>> split_words(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words(\"abcdef\")\n# 3\nsub split_words {\n    my($txt) = @_;\n","canonical_solution":"sub split_words {\n    my($txt) = @_;\n    \n    # Check if whitespace exists in the string\n    if ($txt =~ \/\\s\/) {\n        my @words = split(\/\\s+\/, $txt);\n        return \\@words;\n    }\n    # If no whitespace, check for commas\n    elsif ($txt =~ \/,\/) {\n        my @words = split(\/,\/, $txt);\n        return \\@words;\n    }\n    # If neither whitespace nor commas exist, calculate odd ordered lowercase letters\n    else {\n        my @chars = split(\/\/, $txt);\n        my $count = 0;\n        foreach my $char (@chars) {\n            if ($char ge 'a' && $char le 'z' && (ord($char) - ord('a')) % 2 == 0) {\n                $count++;\n            }\n        }\n        return $count;\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&split_words;\n        if(eq_deeply($candidate->(\"Hello world!\"),[\"Hello\", \"world!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello,world!\"),[\"Hello\", \"world!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello world,!\"),[\"Hello\", \"world,!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello,Hello,world !\"),[\"Hello,Hello,world\", \"!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\"),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaabb\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaBb\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_126","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# عدد، \" را برگردانید. فرض کنید که هیچ عدد منفی و فقط اعداد صحیح وجود ندارد.# اگر آرایه بیش از یک نسخه از همان آرایه داشته باشد# با توجه به یک آرایه از اعداد، آنها را مرتب کنید یا نه.# >>> is_sorted([5])\n# 1\n# >>> is_sorted([1, 2, 3, 4, 5])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5])\n# \"\"\n# >>> is_sorted([1, 2, 3, 4, 5, 6])\n# 1\n# >>> is_sorted([1, 2, 3, 4, 5, 6, 7])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n# \"\"\n# >>> is_sorted([1, 2, 2, 3, 3, 4])\n# 1\n# >>> is_sorted([1, 2, 2, 2, 3, 4])\n# \"\"\nsub is_sorted {\n    my($lst) = @_;\n","canonical_solution":"sub is_sorted {\n    my($lst) = @_;\n    my %count;\n    \n    for (my $i = 0; $i < @$lst; $i++) {\n        $count{$lst->[$i]}++;\n        \n        # Check for more than one duplicate\n        if ($count{$lst->[$i]} > 2) {\n            return '';\n        }\n        \n        # Check if the array is not sorted\n        if ($i > 0 && $lst->[$i] < $lst->[$i - 1]) {\n            return '';\n        }\n    }\n    \n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_sorted;\n        if(eq_deeply($candidate->([5]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 2, 2, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 3, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 2, 3, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_127","nl":"pes_Arab","pl":"pl","prompt":"# نمونه های [ ورودی\/ خروجی ]: # اگر دو فاصله با هم برخورد نکنند، \"نه\" را برگردانید.# در غیر این صورت \"نه\" را برگردانید.# اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید.# که طولش 1 است، که یک عدد اول نیست.# مثال، تقاطع فواصل (1, 3), (2, 4) (2, 3) است.# فاصله ها یک عدد اوله# کار شما اینه که طول تقاطع این دو رو مشخص کنید# برای هر فاصله زمانی مشخص شده، فرض می شود که شروع آن کمتر از یا برابر با پایان آن است.# شامل شروع و پایان هر دو است.# فاصله های داده شده بسته هستند که به این معنی است که فاصله (آغاز، پایان) # که هر فاصله یک جفت عدد صحیح است. برای مثال، فاصله = (آغاز، پایان) = (1, 2).# دو تا فاصله وقت به شما داده شده# >>> intersection([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection([-3, -1], [-5, 5])\n# \"YES\"\nsub intersection {\n    my($interval1, $interval2) = @_;\n","canonical_solution":"sub is_prime {\n    my $num = shift;\n    return 0 if $num <= 1;\n    for my $i (2 .. sqrt($num)) {\n        return 0 if $num % $i == 0;\n    }\n    return 1;\n}\n\nsub intersection {\n    my ($interval1, $interval2) = @_;\n\n    my $start1 = $interval1->[0];\n    my $end1 = $interval1->[1];\n    my $start2 = $interval2->[0];\n    my $end2 = $interval2->[1];\n\n    my $intersection_start = ($start1 > $start2) ? $start1 : $start2;\n    my $intersection_end = ($end1 < $end2) ? $end1 : $end2;\n\n    if ($intersection_start <= $intersection_end) {\n        my $intersection_length = $intersection_end - $intersection_start;\n        return is_prime($intersection_length) ? \"YES\" : \"NO\";\n    }\n\n    return \"NO\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersection;\n        if(eq_deeply($candidate->([1, 2], [2, 3]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1], [0, 4]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, -1], [-5, 5]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2, 2], [-4, 0]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-11, 2], [-1, -1]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2], [3, 5]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2], [1, 2]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2, -2], [-3, -2]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_128","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# توجه: undef را برای آرر خالی برگردانید.# از هر عدد در آرایه، به صورت 1، -1 یا 0 نشان داده شده است.# جمع مقادیر اعداد صحیح ضرب حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل# شما یک آرایه ی آر آر از اعداد صحیح داده شده و باید آن را برگردانید.# >>> prod_signs([1, 2, 2, -4])\n# 9\n# >>> prod_signs([0, 1])\n# 0\n# >>> prod_signs([])\n# undef\nsub prod_signs {\n    my($arr) = @_;\n","canonical_solution":"sub prod_signs {\n    my($arr) = @_;\n    return undef if scalar(@$arr) == 0;\n\n    my $sum_magnitudes = 0;\n    my $product_signs = 1;\n\n    for my $num (@$arr) {\n        $sum_magnitudes += abs($num);\n        \n        if ($num > 0) {\n            $product_signs *= 1;\n        } elsif ($num < 0) {\n            $product_signs *= -1;\n        } else {\n            $product_signs *= 0;\n        }\n    }\n\n    return $sum_magnitudes * $product_signs;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prod_signs;\n        if(eq_deeply($candidate->([1, 2, 2, -4]),-9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1, 2, 3, -1, 1]),-10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 1, 2, -1, -1, 9]),20)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1, -1, 1]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1, 1, 1]),-4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1, 1, 0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_129","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# یک آرایه مرتب شده از مقادیر سلول هایی را که حداقل مسیر از طریق آن عبور می کند، باز می گرداند.# تضمین می شود که پاسخ منحصر به فرد است.# lst_A[j] = lst_B[j].# به طوری که lst_A[i] < lst_B[i] و برای هر j (1 <= j < i) ما # به عبارت دیگر، یک شاخص عدد صحیح وجود دارد که i (1 <= i <= k) # از طریق (بگذارید آنها را lst_A و lst_B بنامیم) ، lst_A از نظر لغت شناسی کمتر است.# بعد از اینکه آرایه های مرتب شده از مقادیر را روی سلول های A و B قرار دادیم# یک مسیر A (با طول k) کمتر از مسیر B (با طول k) در نظر گرفته می شود اگر # نمیتونی از شبکه خارج بشی# لازم نیست که متفاوت باشد).# لطفاً توجه داشته باشید که یک مسیر با طول k به معنای بازدید از دقیقاً k سلول است (نه # # به عبارت دیگر، شما می توانید به سلول هایی که یک لبه با شما در حال حاضر به اشتراک بگذارید بروید.# از هر سلول، و در هر مرحله شما می توانید به هر یک از سلول های همسایه حرکت، # شما باید حداقل مسیر طول k را در شبکه پیدا کنید. شما می توانید شروع کنید.# شامل یک بار در سلول های شبکه ظاهر می شود.# هر سلول شبکه حاوی یک مقدار است. هر عدد صحیح در محدوده [1, N * N] # با توجه به یک شبکه با N ردیف و N ستون (N >= 2) و یک عدد صحیح مثبت k، # >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\nsub minPath {\n    my($grid, $k) = @_;\n","canonical_solution":"sub minPath {\n    my ($grid, $k) = @_;\n    my $n = scalar @$grid;\n\n    # Create direction vectors for up, down, left, right moves\n    my @directions = ([0, 1], [1, 0], [0, -1], [-1, 0]);\n\n    # Priority queue to store paths using a lexicographically ordered array\n    my @queue;\n    for my $i (0..$n-1) {\n        for my $j (0..$n-1) {\n            push @queue, [[$grid->[$i][$j]], $i, $j];\n        }\n    }\n\n    # Sort the initial cells based on their values to start with minimum paths\n    @queue = sort { $a->[0][0] <=> $b->[0][0] } @queue;\n\n    # Implement a breadth-first search that continues until we have a path of length k\n    while (@queue) {\n        my $current = shift @queue;\n        my ($path, $x, $y) = @$current;\n\n        # Return the first path of length k since paths are checked in lexicographical order\n        return @$path if scalar @$path == $k;\n\n        # Explore neighboring cells\n        for my $direction (@directions) {\n            my ($dx, $dy) = @$direction;\n            my ($nx, ny) = ($x + $dx, $y + $dy);\n            \n            # Check for valid cell\n            if ($nx >= 0 && $nx < $n && $ny >= 0 && $ny < $n) {\n                my @new_path = (@$path, $grid->[$nx][$ny]);\n                push @queue, [\\@new_path, $nx, $ny];\n            }\n        }\n        # Keep the queue ordered by lexicographical order of paths\n        @queue = sort { \n            my ($a_path, $b_path) = ($a->[0], $b->[0]);\n            for my $i (0..$#$a_path) {\n                return $a_path->[$i] <=> $b_path->[$i] if $a_path->[$i] != $b_path->[$i];\n            }\n        } @queue;\n    }\n}\n\n# Example usage:\n#print join(\", \", minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)), \"\\n\";  # [1, 2, 1]\n#print join(\", \", minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)), \"\\n\";  # [1]","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&minPath;\n        if(eq_deeply($candidate->([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_130","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# اولین n+1 عدد دنباله تریبوناکسی# شما یک عدد صحیح غیر منفی n دارید، شما باید یک آرایه از  را برگردانید.# = 2 + 3 + 3 = 8 # سه بعدی (۳) = سه بعدی (۲) + سه بعدی (۱) + سه بعدی (۴)# tri ((4) = 3 # tri(2) = 1 + (2 \/ 2) = 2 # برای مثال:# اگر n یک عدد عجیب باشد، tri (n) = tri (n-1) + tri (n-2) + tri (n+1) است.# tri ((n) = 1 + n \/ 2، اگر n جفت باشد. # tri(1) = 3 # توالی تریبوناکسی با تکرار تعریف می شود:# با این حال، چیزی که مردم نمی دانند دنباله تریبوناکچی است.# همه دنباله فیبوناچی را می شناسند، این دنباله توسط ریاضیدانان در سال ۱۹۵۰ به طور عمیق مورد مطالعه قرار گرفت.# >>> tri(3)\n# [1, 3, 2, 8]\nsub tri {\n    my($n) = @_;\n","canonical_solution":"sub tri {\n    my ($n) = @_;\n    my @sequence = (3);  # starting with tri(1) = 3\n\n    for my $i (1 .. $n) {\n        if ($i % 2 == 0) {\n            push @sequence, 1 + $i \/ 2;\n        } else {\n            my $val = $sequence[$i - 1] + $sequence[$i - 2] + ($i + 1 <= $n ? (1 + ($i + 1) \/ 2) : 0);\n            push @sequence, $val;\n        }\n    }\n\n    return @sequence;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&tri;\n        if(eq_deeply($candidate->(3),[1, 3, 2, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[1, 3, 2, 8, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[1, 3, 2, 8, 3, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),[1, 3, 2, 8, 3, 15, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[1, 3, 2, 8, 3, 15, 4, 24])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[1, 3, 2, 8, 3, 15, 4, 24, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_131","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# اگر همه اعداد جفت باشند 0 را باز می گرداند.# با توجه به یک عدد صحیح مثبت n، حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل# >>> digits(1)\n# 1\n# >>> digits(4)\n# 0\n# >>> digits(235)\n# 15\nsub digits {\n    my($n) = @_;\n","canonical_solution":"my @digits = split \/\/, $n;\n    my $product = 1;\n    my $has_odd = 0;\n\n    foreach my $digit (@digits) {\n        if ($digit % 2 != 0) {\n            $product *= $digit;\n            $has_odd = 1;\n        }\n    }\n\n    return $has_odd ? $product : 0;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&digits;\n        if(eq_deeply($candidate->(5),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(54),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(120),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5014),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(98765),315)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5576543),2625)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2468),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_132","nl":"pes_Arab","pl":"pl","prompt":"# که حداقل یک براکت در زیرسلسل قرار دارد.# تابع باید 1 را برگرداند اگر و تنها اگر یک زیرنویس معتبر از براکت ها وجود داشته باشد.# یک تابع ایجاد کنید که یک رشته را به عنوان ورودی بگیرد که فقط شامل براکت های مربع است.# >>> is_nested(\"[[]]\")\n# 1\n# >>> is_nested(\"[]]]]]]][[[[[]\")\n# \"\"\n# >>> is_nested(\"[][]\")\n# \"\"\n# >>> is_nested(\"[]\")\n# \"\"\n# >>> is_nested(\"[[][]]\")\n# 1\n# >>> is_nested(\"[[]][[\")\n# 1\nsub is_nested {\n    my($string) = @_;\n","canonical_solution":"sub is_nested {\n    my ($string) = @_;\n    my @stack;\n\n    for my $char (split \/\/, $string) {\n        if ($char eq '[') {\n            push @stack, $char;\n        } elsif ($char eq ']') {\n            if (@stack && $stack[-1] eq '[') {\n                pop @stack;\n                return 1 if @stack; # Check for nesting\n            } else {\n                return \"\"; # Unbalanced brackets\n            }\n        }\n    }\n\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_nested;\n        if(eq_deeply($candidate->(\"[[]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]]]]]]][[[[[]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[][]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[[[]]]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]]]]]]]]]]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[][][[]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[]][[\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[][]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[[[[[[[\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"]]]]]]]]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_133","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# هر عنصر در آرایه را به سمت بالا جمع کنید.# شما باید مجموع اعداد مربع در آرایه داده شده را برگردانید، # شما یک آرایه از اعداد داده شده است.# >>> lst([1.0, 2.0, 3.0])\n# 14\n# >>> lst([1.0, 4.0, 9.0])\n# 98\n# >>> lst([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst([1.4, 4.2, 0.0])\n# 29\n# >>> lst([-2.4, 1.0, 1.0])\n# 6\nsub sum_squares {\n    my($lst) = @_;\n","canonical_solution":"sub sum_squares {\n    my($lst) = @_;\n    my $sum = 0;\n    foreach my $num (@$lst) {\n        my $ceil_num = int($num) + ($num > int($num) ? 1 : 0);\n        $sum += $ceil_num ** 2;\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_squares;\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 3.0, 5.0, 7.0]),84)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.4, 4.2, 0.0]),29)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2.4, 1.0, 1.0]),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0, 1.0, 15.0, 2.0]),10230)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10000.0, 10000.0]),200000000)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.4, 4.6, 6.3]),75)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.4, 17.9, 18.9, 19.9]),1086)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0, 1.0, 0.0]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_134","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# توجه: \"کلمه\" یک گروه از کاراکترها است که با یک فضای خالی از هم جدا شده اند.# و \" ' در غیر این صورت.# از یک رشته داده شده یک کاراکتر الفبایی است و  نیست.# تابعي بسازيد که اگر آخرين کاراکتر  باشد 1 را برميگرداند# >>> check_if_last_char_is_a_letter(\"apple pie\")\n# \"\"\n# >>> check_if_last_char_is_a_letter(\"apple pi e\")\n# 1\n# >>> check_if_last_char_is_a_letter(\"apple pi e \")\n# \"\"\n# >>> check_if_last_char_is_a_letter(\"\")\n# \"\"\nsub check_if_last_char_is_a_letter {\n    my($txt) = @_;\n","canonical_solution":"sub check_if_last_char_is_a_letter {\n    my ($txt) = @_;\n    $txt =~ s\/\\s+$\/\/; # Trim trailing spaces\n    return '' if $txt eq ''; \n\n    if ($txt =~ \/([^a-zA-Z])([a-zA-Z])$\/ && $1 eq ' ') {\n        return 1;\n    }\n    \n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_if_last_char_is_a_letter;\n        if(eq_deeply($candidate->(\"apple\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pi e\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"A\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Pumpkin pie \"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Pumpkin pie 1\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee e \"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pie\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pi e \"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_135","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# ارزش های تکراری# اگر چنین عنصری وجود نداشته باشد، -1 را باز می گرداند. آرایه داده شده شامل  نخواهد شد.# بزرگتر یا برابر با عنصر بلافاصله قبل از آن نیست. اگر # یک تابع ایجاد کنید که بزرگترین شاخص یک عنصر را که # >>> can_arrange([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange([1, 2, 3])\n# -1\nsub can_arrange {\n    my($arr) = @_;\n","canonical_solution":"sub can_arrange {\n    my ($arr) = @_;\n    for my $i (1 .. $#$arr) {\n        if ($arr->[$i] < $arr->[$i - 1]) {\n            return $i;\n        }\n    }\n    return -1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&can_arrange;\n        if(eq_deeply($candidate->([1, 2, 4, 3, 5]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 4, 5]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 2, 5, 6, 7, 8, 9, 10]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 8, 5, 7, 3]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_136","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# اگر عدد منفی یا مثبت وجود نداشته باشد، آن ها را به صورت undef بازگردانید.# از اعداد صحیح مثبت در یک آرایه.# بزرگتر از تمام اعداد منفی، و b کوچک ترین عدد # یک تابع ایجاد کنید که یک آرایه (a، b) را باز می گرداند، که در آن \"a\"  است.# >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n# [undef, 1]\n# >>> largest_smallest_integers([])\n# [undef, undef]\n# >>> largest_smallest_integers([0])\n# [undef, undef]\nsub largest_smallest_integers {\n    my($lst) = @_;\n","canonical_solution":"sub largest_smallest_integers {\n    my ($lst) = @_;\n    my ($largest_neg, $smallest_pos);\n\n    foreach my $num (@$lst) {\n        if ($num < 0) {\n            $largest_neg = $num if !defined($largest_neg) || $num > $largest_neg;\n        } elsif ($num > 0) {\n            $smallest_pos = $num if !defined($smallest_pos) || $num < $smallest_pos;\n        }\n    }\n    \n    return ($largest_neg, $smallest_pos);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_smallest_integers;\n        if(eq_deeply($candidate->([2, 4, 1, 3, 5, 7]),[undef, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 1, 3, 5, 7, 0]),[undef, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, -2]),[-2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 5, 3, 6, 2, 7, -7]),[-7, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[undef, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0]),[undef, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, -5, -6]),[-1, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, -5, -6, 0]),[-1, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-6, -4, -4, -3, 1]),[-3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-6, -4, -4, -3, -100, 1]),[-3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_137","nl":"pes_Arab","pl":"pl","prompt":"# توجه: اگر یک عدد واقعی به عنوان یک رشته نمایش داده شود، نقطه شناور ممکن است . یا ،  باشد.# اگر مقادیر مساوی باشند undef را باز می گرداند.# اعداد واقعی، و متغیر بزرگتر را در نوع متغیر داده شده اش باز می گرداند. # یک تابع ایجاد کنید که اعداد صحیح، floats یا رشته هایی را که  را نشان می دهند را می گیرد.# >>> compare_one(1, 2.5)\n# 2.5\n# >>> compare_one(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one(\"1\", 1)\n# undef\nsub compare_one {\n    my($a, $b) = @_;\n","canonical_solution":"sub compare_one {\n    my ($a, $b) = @_;\n\n    # Convert potential string numbers with ',' into float representation\n    $a =~ s\/,\/.\/g if $a =~ \/,\/;\n    $b =~ s\/,\/.\/g if $b =~ \/,\/;\n\n    # Auto-detect type by checking if string has non-numeric parts\n    my $a_is_num = $a =~ \/^\\d+(\\.\\d+)?$\/;\n    my $b_is_num = $b =~ \/^\\d+(\\.\\d+)?$\/;\n\n    if ($a_is_num && $b_is_num) {\n        # Compare as numbers\n        if ($a < $b) {\n            return $b;\n        } elsif ($a > $b) {\n            return $a;\n        } else {\n            return undef;\n        }\n    } else {\n        # Compare as strings\n        if ($a lt $b) {\n            return $b;\n        } elsif ($a gt $b) {\n            return $a;\n        } else {\n            return undef;\n        }\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&compare_one;\n        if(eq_deeply($candidate->(1, 2),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2.5),2.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 3),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 6),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, \"2,3\"),\"2,3\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5,1\", \"6\"),\"6\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\", \"2\"),\"2\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\", 1),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_138","nl":"pes_Arab","pl":"pl","prompt":"# مثال# ارزیابی کنید که آیا عدد n را می توان به صورت مجموع 4 عدد جفت مثبت نوشت.# >>> is_equal_to_sum_even(4)\n# \"\"\n# >>> is_equal_to_sum_even(6)\n# \"\"\n# >>> is_equal_to_sum_even(8)\n# 1\nsub is_equal_to_sum_even {\n    my($n) = @_;\n","canonical_solution":"sub is_equal_to_sum_even {\n    my($n) = @_;\n\n    # A number can be expressed as the sum of four positive even numbers\n    # if and only if it is greater than or equal to 8 and is even\n    if ($n >= 8 && $n % 2 == 0) {\n        return 1;\n    } else {\n        return \"\";\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_equal_to_sum_even;\n        if(eq_deeply($candidate->(4),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(16),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_139","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# که در آن n > 0 # برازیلی_فاکتورال ((n) = n! * (n-1)! * (n-2)! * ... * 1! # فاکتورال برزیلی به شکل زیر تعریف می شود: # >>> special_factorial(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\nsub special_factorial {\n    my($n) = @_;\n","canonical_solution":"sub special_factorial {\n    my($n) = @_;\n    my $result = 1;\n    \n    for my $i (1 .. $n) {\n        $result *= factorial($i);\n    }\n    \n    return $result;\n}\n\nsub factorial {\n    my($num) = @_;\n    my $fact = 1;\n\n    for my $i (1 .. $num) {\n        $fact *= $i;\n    }\n\n    return $fact;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&special_factorial;\n        if(eq_deeply($candidate->(4),288)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),34560)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),125411328000)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_140","nl":"pes_Arab","pl":"pl","prompt":"# بعد همه فضاهاي پي در پي رو با -  تعويض کنيد# و اگر یک رشته بیش از 2 فضای متوالی داشته باشد، # با توجه به یک رشته متن، تمام فضاهای آن را با زیرنویس ها جایگزین کنید، # >>> fix_spaces(\" Example\")\n# \"Example\"\n# >>> fix_spaces(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces(\" Example 3\")\n# \"_Example-3\"\nsub fix_spaces {\n    my($text) = @_;\n","canonical_solution":"sub fix_spaces {\n    my($text) = @_;\n    $text =~ s\/ {3,}\/-\/g;   # Replace 3 or more spaces with a hyphen\n    $text =~ s\/ \/_\/g;       # Replace remaining spaces with underscores\n    return $text;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fix_spaces;\n        if(eq_deeply($candidate->(\"Example\"),\"Example\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir Hanif \"),\"Mudasir_Hanif_\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Yellow Yellow  Dirty  Fellow\"),\"Yellow_Yellow__Dirty__Fellow\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Exa   mple\"),\"Exa-mple\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"   Exa 1 2 2 mple\"),\"-Exa_1_2_2_mple\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_141","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# - رشته زیر بعد از نقطه باید یکی از اینها باشه: ['txt', 'exe', 'dll'] # الفبای لاتین (a-z و A-Z)# - رشته زیر قبل از نقطه نباید خالی باشه و با حرف شروع میشه# -اسم پرونده دقیقاً یه نقطه داره# - نام پرونده نباید بیش از سه عدد باشد ('0'-'9')# برآورده شده اند:# نام یک فایل معتبر در صورتی و تنها در صورتی است که تمام شرایط زیر را برآورده کند.# \"بله\" اگر نام فایل معتبر باشد و در غیر این صورت \"نه\" را باز می گرداند.# یک تابع ایجاد کنید که یک رشته را که نام یک فایل را نشان می دهد، می گیرد و باز می گرداند.# >>> file_name_check(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check(\"1example.dll\")\n# \"No\"\nsub file_name_check {\n    my($file_name) = @_;\n","canonical_solution":"sub file_name_check {\n    my($file_name) = @_;\n    \n    # Check if there's exactly one dot and split the string\n    my @parts = split(\/\\.\/, $file_name);\n    return 'No' unless scalar(@parts) == 2;\n\n    # Extract the name and the extension\n    my ($name, $extension) = @parts;\n\n    # Check if the extension is valid\n    return 'No' unless $extension =~ \/^(txt|exe|dll)$\/;\n\n    # Check if the name starts with a letter\n    return 'No' unless $name =~ \/^[a-zA-Z]\/;\n\n    # Check the number of digits in the name\n    my $digit_count = () = $name =~ \/[0-9]\/g;\n    return 'No' if $digit_count > 3;\n\n    # If all conditions are met, return 'Yes'\n    return 'Yes';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&file_name_check;\n        if(eq_deeply($candidate->(\"example.txt\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1example.dll\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"s1sdf3.asd\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"K.dll\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"MY16FILE3.exe\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"His12FILE94.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"_Y.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"?aREYA.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\/this_is_valid.dll\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.wow\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.txt\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.txtexe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#this2_i4s_5valid.ten\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"@this1_is6_valid.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_12valid.6exe4.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"all.exe.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I563_No.exe\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Is3youfault.txt\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"no_one#knows.dll\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1I563_Yes3.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I563_Yes3.txtt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"final..txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"final132\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"_f4indsartal132.\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\".txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"s.\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_142","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# در آرایه ی داده ها که شاخص های آنها چند برابر 3 یا 4 نیست را تغییر دهید. تابع سپس مجموع همه ی داده ها را باز می گرداند.# چند برابر 3 و اگر شاخص آن چند برابر 4 باشد و چند برابر 3 نباشد، ورودی عدد صحیح را مکعب خواهد کرد.# این تابع یک آرایه از اعداد صحیح را می گیرد. برای همه ی ورودی های آرایه، تابع باید ورودی عدد صحیح را مربع کند اگر شاخص آن a باشد.# \" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\nsub sum_squares {\n    my($lst) = @_;\n","canonical_solution":"sub sum_squares {\n    my ($lst) = @_;\n    my $sum = 0;\n\n    for my $i (0 .. @$lst - 1) {\n        if ($i % 3 == 0) {\n            $sum += $lst->[$i] ** 2;\n        } elsif ($i % 4 == 0) {\n            $sum += $lst->[$i] ** 3;\n        } else {\n            $sum += $lst->[$i];\n        }\n    }\n\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_squares;\n        if(eq_deeply($candidate->([1, 2, 3]),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 9]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1, 1, 1, 1, 1, 1, 1]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -5, 2, -1, -5]),-126)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-56, -99, 1, 0, -2]),3030)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_143","nl":"pes_Arab","pl":"pl","prompt":"# مثال 1:# ترتيب کلمات در رشته جدید بايد مثل رشته اولي باشه# که طولش اعداد اوله، # و شما باید یک رشته را که شامل کلمات از جمله اصلی، # جمله شامل چند کلمه است که با یک فضای خالی از هم جدا شده اند.# شما یک رشته ای دارید که یک جمله را نشان می دهد، # >>> words_in_sentence(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\nsub words_in_sentence {\n    my($sentence) = @_;\n","canonical_solution":"sub words_in_sentence {\n    my($sentence) = @_;\n    \n    # Function to check if a number is prime\n    sub is_prime {\n        my $num = shift;\n        return 0 if $num < 2;\n        for (my $i = 2; $i * $i <= $num; ++$i) {\n            return 0 if $num % $i == 0;\n        }\n        return 1;\n    }\n    \n    my @words = split(' ', $sentence);\n    my @prime_length_words;\n    \n    foreach my $word (@words) {\n        my $length = length($word);\n        if (is_prime($length)) {\n            push(@prime_length_words, $word);\n        }\n    }\n    \n    return join(' ', @prime_length_words);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&words_in_sentence;\n        if(eq_deeply($candidate->(\"This is a test\"),\"is\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"lets go for swimming\"),\"go for\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"there is no place available here\"),\"there is no place\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hi I am Hussein\"),\"Hi am Hussein\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"go for it\"),\"go for it\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"here\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"here is\"),\"is\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_144","nl":"pes_Arab","pl":"pl","prompt":"# شما می توانید فرض کنید که x و n کسری صحیح هستند و صفر به عنوان ممیز ندارند.# <شماره>\/<نشان> که هم شماره و هم ممیز اعداد صحیح مثبت هستند.# در غیر این صورت، هر دو x و n، نمایش رشته ای از کسری هستند و فرمت زیر دارند، # x * n. اگر x * n به یک عدد کامل و ' '  تبدیل شود، تابع 1 را باز می گرداند.# کار شما اینه که یه تابع اجرا کنید که بیان رو ساده کنه# >>> simplify(\"1\/5\", \"5\/1\")\n# 1\n# >>> simplify(\"1\/6\", \"2\/1\")\n# \"\"\n# >>> simplify(\"7\/10\", \"10\/2\")\n# \"\"\nsub simplify {\n    my($x, $n) = @_;\n","canonical_solution":"sub simplify {\n    my ($x, $n) = @_;\n    \n    # Parse the fractions\n    my ($x_num, $x_den) = split('\/', $x);\n    my ($n_num, $n_den) = split('\/', $n);\n    \n    # Cross-multiply to find the product of the fractions\n    # x * n = (x_num * n_num) \/ (x_den * n_den)\n    my $prod_num = $x_num * $n_num;\n    my $prod_den = $x_den * $n_den;\n    \n    # Check if the product is a whole number\n    return ($prod_num % $prod_den == 0) ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&simplify;\n        if(eq_deeply($candidate->(\"1\/5\", \"5\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\/6\", \"2\/1\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5\/1\", \"3\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"7\/10\", \"10\/2\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/10\", \"50\/10\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"7\/2\", \"4\/2\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"11\/6\", \"6\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/3\", \"5\/2\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5\/2\", \"3\/5\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/4\", \"8\/4\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/4\", \"4\/2\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\/5\", \"5\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\/5\", \"1\/5\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_145","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# آنها را بر اساس شاخص در آرایه اصلی مرتب کنید.# توجه: اگر چندین آیتم با مجموع مشابه ارقام آنها وجود داشته باشد، # به ترتیب رو به بالا بر اساس جمع ارقام آنها.# يک تابع بنویسيد که آرایه اعداد کامل را مرتب کند# >>> order_by_points([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points([])\n# []\nsub order_by_points {\n    my($nums) = @_;\n","canonical_solution":"sub order_by_points {\n    my ($nums) = @_;\n    \n    # Function to calculate the sum of the digits of a number\n    sub digit_sum {\n        my $num = shift;\n        my $sum = 0;\n        $sum += $_ for split \/\/, abs($num);\n        return $sum;\n    }\n\n    # Sort the array first by sum of digits, then by index for ties\n    my @sorted = sort {\n        digit_sum($a) <=> digit_sum($b) ||\n        $a <=> $b\n    } @$nums;\n\n    return \\@sorted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&order_by_points;\n        if(eq_deeply($candidate->([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_146","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# اول و آخر یک عدد عددی عجیب است (۱، ۳، ۵، ۷، ۹).# تعداد عناصر در آرایه که بزرگتر از 10 و هر دو # يک تابع بنویسيد که يک آرري از اعداد را به عنوان ورودي و بازده پذيرد# >>> specialFilter([15, -73, 14, -15])\n# 1\n# >>> specialFilter([33, -2, -3, 45, 21, 109])\n# 2\nsub specialFilter {\n    my($nums) = @_;\n","canonical_solution":"sub specialFilter {\n    my($nums) = @_;\n    my $count = 0;\n    foreach my $num (@$nums) {\n        if ($num > 10) {\n            my $str_num = abs($num) . \"\";\n            my $first_digit = substr($str_num, 0, 1);\n            my $last_digit = substr($str_num, -1, 1);\n            if ($first_digit % 2 != 0 && $last_digit % 2 != 0) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&specialFilter;\n        if(eq_deeply($candidate->([5, -2, 1, -5]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([15, -73, 14, -15]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([33, -2, -3, 45, 21, 109]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([43, -12, 93, 125, 121, 109]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([71, -2, -33, 75, 21, 19]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_147","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# و a[i] + a[j] + a[k] یک چند برابر 3 است.# تعداد سه گانه (a[i]، a[j]، a[k]) از a را که در آن i < j < k، # برای هر i (1 ≤ i ≤ n) ، ارزش a[i] = i * i - i + 1 است. # شما یک عدد صحیح مثبت n دارید. شما باید یک آرایه عدد صحیح a با طول n ایجاد کنید.# >>> get_max_triples(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\nsub get_max_triples {\n    my($n) = @_;\n","canonical_solution":"sub get_max_triples {\n    my($n) = @_;\n    my @a;\n    \n    # Generate the array a\n    for my $i (1..$n) {\n        $a[$i - 1] = $i * $i - $i + 1;\n    }\n    \n    my $count = 0;\n    \n    # Check all triples (a[i], a[j], a[k]) where i < j < k\n    for my $i (0..$n-3) {\n        for my $j ($i+1..$n-2) {\n            for my $k ($j+1..$n-1) {\n                if (($a[$i] + $a[$j] + $a[$k]) % 3 == 0) {\n                    $count++;\n                }\n            }\n        }\n    }\n    \n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_max_triples;\n        if(eq_deeply($candidate->(5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),36)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),53361)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_148","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# اسم هاي سياره ها درست نيست# تابع باید یک آرایه خالی را برگرداند اگر planet1 یا planet2 # نزديکي به خورشيد# که بین مدار سیاره 1 و مدار سیاره 2 قرار دارد، مرتب شده توسط # تابع باید یک آرایه را برگرداند که شامل تمام سیاره هایی است که مدارشان # یک تابع بنویسید که دو نام سیاره را به عنوان رشته های planet1 و planet2 می گیرد.# اورانوس، نپتون# عطارد، بعدي زهره، بعد زمين، مريخ، مشتري، زحل،# هشت سیاره در منظومه شمسی ما وجود داره که به خورشید نزدیک ترند# >>> bf(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nsub bf {\n    my($planet1, $planet2) = @_;\n","canonical_solution":"sub bf {\n    my ($planet1, $planet2) = @_;\n    my @planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune');\n\n    my %planet_indices = map { $planets[$_] => $_ } (0..$#planets);\n\n    return [] unless exists $planet_indices{$planet1} && exists $planet_indices{$planet2};\n\n    my ($start, $end) = ($planet_indices{$planet1}, $planet_indices{$planet2});\n\n    ($start, $end) = ($end, $start) if $start > $end;\n\n    return [@planets[$start+1 .. $end-1]];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&bf;\n        if(eq_deeply($candidate->(\"Jupiter\", \"Neptune\"),[\"Saturn\", \"Uranus\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Earth\", \"Mercury\"),[\"Venus\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mercury\", \"Uranus\"),[\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Neptune\", \"Venus\"),[\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Earth\", \"Earth\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mars\", \"Earth\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Jupiter\", \"Makemake\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_149","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# شما ممکن است فرض کنید که همه کلمات طول یکسانی دارند.# تابع باید یک آرایه از رشته ها را در ترتیب مرتب برگرداند.# اگر دو کلمه طول یکسانی داشته باشند، آرایه را به ترتیب الفبا مرتب کنید.# باید آرایه ای را که با این قاعده مرتب شده است، بازگردانده شود.# ترتيب آرایه بايد با طول هر کلمه بالا رود، و شما# و ممکن است شامل نسخه های تکراری باشد.# آرایه همیشه یک آرایه از رشته ها است و هرگز یک آرایه از اعداد نیست.# و آرایه ی حاصل را با یک ترتیب مرتب باز می گرداند، # رشته هایی که طولشان جفت است را از آن حذف می کند، # یک تابع بنویسید که یک آرایه از رشته ها را به عنوان پارامتر قبول کند، # >>> list_sort([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\nsub sorted_list_sum {\n    my($lst) = @_;\n","canonical_solution":"sub list_sort {\n    my ($lst) = @_;\n\n    # Filter out strings with odd length\n    my @filtered = grep { length($_) % 2 == 0 } @$lst;\n\n    # Sort strings first by length, then alphabetically\n    my @sorted = sort { length($a) <=> length($b) || $a cmp $b } @filtered;\n\n    return \\@sorted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sorted_list_sum;\n        if(eq_deeply($candidate->([\"aa\", \"a\", \"aaa\"]),[\"aa\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"school\", \"AI\", \"asdf\", \"b\"]),[\"AI\", \"asdf\", \"school\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"d\", \"b\", \"c\", \"a\"]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"d\", \"dcba\", \"abcd\", \"a\"]),[\"abcd\", \"dcba\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"AI\", \"ai\", \"au\"]),[\"AI\", \"ai\", \"au\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),[\"cc\", \"dd\", \"aaaa\", \"bbbb\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_150","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# یک عدد اول است و باید مقدار y را در غیر این صورت بازگردانده باشد.# یک برنامه ساده که باید مقدار x را برگرداند اگر n  باشد.# >>> x_or_y(7, 34, 12)\n# 34\n# >>> x_or_y(15, 8, 5)\n# 5\nsub x_or_y {\n    my($n, $x, $y) = @_;\n","canonical_solution":"sub is_prime {\n    my $num = shift;\n    return 0 if $num < 2;\n    for (my $i = 2; $i * $i <= $num; $i++) {\n        return 0 if $num % $i == 0;\n    }\n    return 1;\n}\n\nsub x_or_y {\n    my ($n, $x, $y) = @_;\n    return is_prime($n) ? $x : $y;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&x_or_y;\n        if(eq_deeply($candidate->(7, 34, 12),34)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(15, 8, 5),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 33, 5212),33)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1259, 3, 52),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7919, -1, 12),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3609, 1245, 583),583)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(91, 56, 129),129)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6, 34, 1234),1234)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 0),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 0),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_151","nl":"pes_Arab","pl":"pl","prompt":"# اعداد غیرنمرین را در آرایه حذف کنید. اعداد منفی یا غیر عدد صحیح را نادیده بگیرید.# با توجه به یک آرایه از اعداد، جمع مربع اعداد را برگردانید.# >>> double_the_difference([1, 3, 2, 0])\n# 10\n# >>> double_the_difference([-1, -2, 0])\n# 0\n# >>> double_the_difference([9, -2])\n# 81\n# >>> double_the_difference([0])\n# 0\n# If the input array is empty, return 0.\nsub double_the_difference {\n    my($lst) = @_;\n","canonical_solution":"sub double_the_difference {\n    my ($lst) = @_;\n    my $sum = 0;\n\n    foreach my $num (@$lst) {\n        if ($num =~ \/^\\d+$\/ && $num % 2 != 0) {\n            $sum += $num ** 2;\n        }\n    }\n    \n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&double_the_difference;\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5.0, 4.0]),25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.1, 0.2, 0.3]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10.0, -20.0, -30.0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0, -2.0, 8.0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.2, 3.0, 5.0]),34)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_152","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# مقدار 0 است و اگر نه، مقدار تفاوت مطلق بین حدس و امتیاز است.# یک آرایه با همان طول را برگردانید که نشان می دهد هر حدس چقدر دور است. اگر آنها درست حدس زده اند، # شما دو آرایه از نمرات و حدس های با طول یکسان داده می شوید، که هر شاخص یک مطابقت را نشان می دهد.# وظیفه شما اینه که مشخص کنید که آیا یک نفر نتایج یک سری بازی ها رو درست حدس زده یا نه.# قطعاً ارزش ثبت کردن و مقایسه کردن رو داره# و در نهایت اتفاقات و افکار شما در آن لحظه مشخص می شود.# فکر کنم همه ما اون حس رو به خاطر مياريم وقتي که نتيجه ي يک اتفاقي که مدتها منتظرش بود# >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\nsub compare {\n    my($game, $guess) = @_;\n","canonical_solution":"sub compare {\n    my($game, $guess) = @_;\n    my @result;\n    \n    for my $i (0..$#$game) {\n        my $difference = abs($game->[$i] - $guess->[$i]);\n        push @result, $difference;\n    }\n    \n    return @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&compare;\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3], [-1, -2, -3]),[2, 4, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_153","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# (قدرتش -1)# به عنوان \"Slices.SERVINGSliCes\" برگردانید، زیرا \"SERVINGSliCes\" قوی ترین افزونه است.# پس باید این کار رو بکنی# برای مثال، اگر به شما \"Slices\" به عنوان کلاس و یک آرایه از  داده شود.# هر کدام از این ها را در آرایه اول انتخاب کنید.# اگر دو یا چند تمدید با همان قدرت وجود دارد، باید# فرمت: ClassName.StrongestExtensionName. # باید قوی ترین افزونه را پیدا کنید و یک رشته در این # در نام این افزونه، قدرت با کسر CAP - SM مشخص می شود.# حروف در نام افزونه و SM عدد حروف کوچک باشد # قدرت این افزونه به شرح زیر است: CAP را به عنوان عدد بزرگ # افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند.# شما یک نام کلاس (یک رشته) و یک آرایه از افزونه ها خواهید داشت.# >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\nsub Strongest_Extension {\n    my($class_name, $extensions) = @_;\n","canonical_solution":"sub Strongest_Extension {\n    my ($class_name, $extensions) = @_;\n    my $strongest = '';\n    my $max_strength = -1e9;\n\n    foreach my $extension (@$extensions) {\n        my $cap = 0;\n        my $sm = 0;\n\n        foreach my $char (split \/\/, $extension) {\n            if ($char =~ \/[A-Z]\/) {\n                $cap++;\n            } elsif ($char =~ \/[a-z]\/) {\n                $sm++;\n            }\n        }\n\n        my $strength = $cap - $sm;\n        \n        if ($strength > $max_strength) {\n            $max_strength = $strength;\n            $strongest = $extension;\n        }\n    }\n\n    return \"$class_name.$strongest\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&Strongest_Extension;\n        if(eq_deeply($candidate->(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\"finNNalLLly.WoW\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"_\", [\"Bb\", \"91245\"]),\"_.Bb\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_154","nl":"pes_Arab","pl":"pl","prompt":"# شما دو کلمه داده شده است. شما نیاز به بازگشت 1 اگر کلمه دوم و یا هر یک از چرخش آن یک زیر رشته در کلمه اول است.# >>> cycpattern_check(\"abcd\", \"abd\")\n# \"\"\n# >>> cycpattern_check(\"hello\", \"ell\")\n# 1\n# >>> cycpattern_check(\"whassup\", \"psus\")\n# \"\"\n# >>> cycpattern_check(\"abab\", \"baa\")\n# 1\n# >>> cycpattern_check(\"efef\", \"eeff\")\n# \"\"\n# >>> cycpattern_check(\"himenss\", \"simen\")\n# 1\nsub cycpattern_check {\n    my($a, $b) = @_;\n","canonical_solution":"sub cycpattern_check {\n    my($a, $b) = @_;\n    my $len = length($b);\n\n    for my $i (0 .. $len - 1) {\n        my $rotation = substr($b, $i) . substr($b, 0, $i);\n        return 1 if index($a, $rotation) != -1;\n    }\n\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&cycpattern_check;\n        if(eq_deeply($candidate->(\"xyzw\", \"xyw\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"yello\", \"ell\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"whattup\", \"ptut\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"efef\", \"fee\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abab\", \"aabb\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"winemtt\", \"tinem\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_155","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# با توجه به یک عدد صحیح، یک آرایه را که به ترتیب دارای عدد اعداد جفت و عجیب است، باز می گرداند.# >>> even_odd_count(-12)\n# [1, 1]\n# >>> even_odd_count(123)\n# [1, 2]\nsub even_odd_count {\n    my($num) = @_;\n","canonical_solution":"my $evens = 0;\n    my $odds = 0;\n    $num = abs($num); # Handle negative numbers\n    foreach my $digit (split \/\/, $num) {\n        if ($digit % 2 == 0) {\n            $evens++;\n        } else {\n            $odds++;\n        }\n    }\n    return [$evens, $odds];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&even_odd_count;\n        if(eq_deeply($candidate->(7),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-78),[1, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3452),[2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(346211),[3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-345821),[3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-2),[1, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-45347),[2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[1, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_156","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها:# محدودیت ها: 1 <= num <= 1000 # و با حروف کوچک برگردونش# با توجه به یک عدد صحیح مثبت، معادل آن را به شکل یک رشته در اعداد رومی بدست آورید، # >>> int_to_mini_roman(19)\n# \"xix\"\n# >>> int_to_mini_roman(152)\n# \"clii\"\n# >>> int_to_mini_roman(426)\n# \"cdxxvi\"\nsub int_to_mini_roman {\n    my($number) = @_;\n","canonical_solution":"my @roman_numerals = (\n        [1000, 'm'],\n        [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i'],\n    );\n\n    my $result = '';\n\n    for my $pair (@roman_numerals) {\n        my ($value, $roman) = @$pair;\n        while ($number >= $value) {\n            $result .= $roman;\n            $number -= $value;\n        }\n    }\n\n    return $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&int_to_mini_roman;\n        if(eq_deeply($candidate->(19),\"xix\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(152),\"clii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(251),\"ccli\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(426),\"cdxxvi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(500),\"d\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"i\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"iv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(43),\"xliii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(90),\"xc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(94),\"xciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(532),\"dxxxii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(900),\"cm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(994),\"cmxciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),\"m\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_157","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# 90 درجه# مثلث با زاويه راست مثلثي است که در آن يک زاويه زاويه راست است يا# در غیر این صورت،# طول سه طرف مثلث را داده است. اگر سه # >>> right_angle_triangle(3, 4, 5)\n# 1\n# >>> right_angle_triangle(1, 2, 3)\n# \"\"\nsub right_angle_triangle {\n    my($a, $b, $c) = @_;\n","canonical_solution":"sub right_angle_triangle {\n    my($a, $b, $c) = @_;\n    # Sort the sides to identify the potential hypotenuse\n    my @sides = sort { $a <=> $b } ($a, $b, $c);\n    # Check if the triangle satisfies Pythagorean theorem\n    return ($sides[0] ** 2 + $sides[1] ** 2 == $sides[2] ** 2) ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&right_angle_triangle;\n        if(eq_deeply($candidate->(3, 4, 5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 3),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 6, 8),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 24, 25),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 5, 7),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 12, 13),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(15, 8, 17),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(48, 55, 73),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 1, 1),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 10),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_158","nl":"pes_Arab","pl":"pl","prompt":"# حروف، حروف اول را در ترتیب لغت شناسی برگردانید.# اگر چند رشته ی تک حرفی حداکثر تعداد تک حرفی را داشته باشند# آرایه شامل کلمات مختلف است. کلمه ای را با حداکثر تعداد  برگردانید.# یک تابع بنویسید که یک آرایه از رشته ها را قبول کند.# >>> find_max([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\nsub find_max {\n    my($words) = @_;\n","canonical_solution":"sub find_max {\n    my ($words) = @_;\n    my $max_word = '';\n    my $max_unique_chars = 0;\n    \n    foreach my $word (@$words) {\n        my %unique_chars = map { $_ => 1 } split \/\/, $word;\n        my $unique_count = keys %unique_chars;\n        \n        if ($unique_count > $max_unique_chars || ($unique_count == $max_unique_chars && $word lt $max_word)) {\n            $max_word = $word;\n            $max_unique_chars = $unique_count;\n        }\n    }\n    \n    return $max_word;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_max;\n        if(eq_deeply($candidate->([\"name\", \"of\", \"string\"]),\"string\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"name\", \"enam\", \"game\"]),\"enam\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"aaaaaaa\", \"bb\", \"cc\"]),\"aaaaaaa\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"abc\", \"cba\"]),\"abc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"we\", \"are\", \"gonna\", \"rock\"]),\"gonna\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"we\", \"are\", \"a\", \"mad\", \"nation\"]),\"nation\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"this\", \"is\", \"a\", \"prrk\"]),\"this\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"b\"]),\"b\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"play\", \"play\", \"play\"]),\"play\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_159","nl":"pes_Arab","pl":"pl","prompt":"# مثال:# اگر به اندازه کافی هویج باقی نمانده باشد، شما تمام هویج باقی مانده را می خورید، اما هنوز هم گرسنه خواهید بود.# تعداد هویج های بعد از غذا خوردن# شما باید یک سری از [ تعداد کل هویج خورده بعد از غذا خوردن، # اما حالا بايد گُزر بيشتري بخوري تا غذاي روزانه ات کامل بشه# تو يه خرگوش گرسنه اي و قبلا يه مقدار گُزر خورده اي# >>> eat(5, 6, 10)\n# [11, 4]\n# >>> eat(4, 8, 9)\n# [12, 1]\n# >>> eat(1, 10, 10)\n# [11, 0]\n# >>> eat(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\nsub eat {\n    my($number, $need, $remaining) = @_;\n","canonical_solution":"sub eat {\n    my($number, $need, $remaining) = @_;\n    my $total_eaten = $number + $need;\n    if ($remaining >= $need) {\n        $remaining -= $need;\n    } else {\n        $total_eaten = $number + $remaining;\n        $remaining = 0;\n    }\n    return [$total_eaten, $remaining];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&eat;\n        if(eq_deeply($candidate->(5, 6, 10),[11, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 8, 9),[12, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 10, 10),[11, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 11, 5),[7, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 5, 7),[9, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 5, 1),[5, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_160","nl":"pes_Arab","pl":"pl","prompt":"# آرایه ی عامل حداقل یک عامل دارد و آرایه ی عامل حداقل دو عامل دارد.# آپراند یک آرایه از اعداد صحیح غیرمنفی است.# طول آرایه ی عامل برابر با طول آرایه ی اپراند ماینوس یک است.# توجه:# => نتیجه = 9 # نتیجه = 2 + 3 * 4 - 5 # آرایه = [2, 3, 4, 5] # ['+'، '*'، '-']# مثال:# نمره گذاری (**)# طبقه تقسیم ( \/\/ ) # ضرب (*) # کسر ( - ) # اضافه کردن (+) # عملیات جبر پایه:# و به ما می گوید که این عبارت را ارزیابی کنیم.# آرایه دوم آرایه ای از اعداد صحیح است. از دو آرایه داده شده برای ساختن الجبر استفاده کنید.# با توجه به دو عامل آرایه و اپراند، آرایه اول دارای عملیات الجبر پایه است، و sub do_algebra {\n    my($operator, $operand) = @_;\n","canonical_solution":"sub do_algebra {\n    my ($operator, $operand) = @_;\n    my $expression = $operand->[0];\n    \n    for my $i (0 .. $#$operator) {\n        my $op = $operator->[$i];\n        my $num = $operand->[$i + 1];\n        \n        if ($op eq '\/\/') {\n            $expression = \"int($expression \/ $num)\";\n        } else {\n            $expression .= \" $op $num\";\n        }\n    }\n    \n    return eval $expression;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&do_algebra;\n        if(eq_deeply($candidate->([\"**\", \"*\", \"+\"], [2, 3, 4, 5]),37)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"+\", \"*\", \"-\"], [2, 3, 4, 5]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\/\/\", \"*\"], [7, 3, 4]),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_161","nl":"pes_Arab","pl":"pl","prompt":"# مثال ها# تابع باید رشته ی حاصل را برگرداند.# اگر رشته ای شامل هیچ حرفی نباشد، رشته را معکوس کنید.# در غیر این صورت همونطور که هست نگهش دار# اگر s[i] یک حرف باشد، حالت آن را از پایین به بالا یا برعکس، # شما یک رشته داده شده است.# >>> solve(\"1234\")\n# \"4321\"\n# >>> solve(\"ab\")\n# \"AB\"\n# >>> solve(\"#a@C\")\n# \"#A@c\"\nsub solve {\n    my($s) = @_;\n","canonical_solution":"sub solve {\n    my($s) = @_;\n    if ($s =~ \/[a-zA-Z]\/) {\n        $s =~ s\/([a-z])|([A-Z])\/defined $1 ? uc($1) : lc($2)\/ge;\n    } else {\n        $s = reverse($s);\n    }\n    return $s;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n        if(eq_deeply($candidate->(\"AsDf\"),\"aSdF\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1234\"),\"4321\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ab\"),\"AB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#a@C\"),\"#A@c\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#AsdfW^45\"),\"#aSDFw^45\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#6@2\"),\"2@6#\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#$a^D\"),\"#$A^d\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#ccc\"),\"#CCC\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_162","nl":"pes_Arab","pl":"pl","prompt":"# اگر 'text' یک رشته خالی باشد، undef را بازگردانید.# با توجه به یک رشته 'text' ، رشته معادل هش md5 آن را برگردانید. # >>> string_to_md5(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\nsub string_to_md5 {\n    my($text) = @_;\n","canonical_solution":"use Digest::MD5 qw(md5_hex);\n\n    if ($text eq '') {\n        return undef;\n    }\n\n    return md5_hex($text);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_to_md5;\n        if(eq_deeply($candidate->(\"Hello world\"),\"3e25960a79dbc69b674cd4ec67a72c62\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_163","nl":"pes_Arab","pl":"pl","prompt":"# برای مثال:# و ب، به ترتیب رو به افزایش.# با توجه به دو عدد صحیح مثبت a و b، اعداد جفت بین a را برگردانید # >>> generate_integers(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers(10, 14)\n# []\nsub generate_integers {\n    my($a, $b) = @_;\n","canonical_solution":"sub generate_integers {\n    my($a, $b) = @_;\n    my @result;\n    my ($start, $end) = $a < $b ? ($a, $b) : ($b, $a);\n    \n    for my $i ($start..$end) {\n        push @result, $i if $i % 2 == 0;\n    }\n    \n    return @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&generate_integers;\n        if(eq_deeply($candidate->(2, 10),[2, 4, 6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 2),[2, 4, 6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(132, 2),[2, 4, 6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(17, 89),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"}]