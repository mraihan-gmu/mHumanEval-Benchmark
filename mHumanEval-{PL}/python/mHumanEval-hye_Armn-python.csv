task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,hye_Armn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Ստուգեք, թե թվերի տվյալ ցուցակում, արդյոք երկու թվեր են միմյանց ավելի մոտ, քան տրված շեմը: Օրինակ: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,hye_Armn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Այս ֆունկցիայի մուտքագրումը մի շարք է, որը պարունակում է վարդավորված կլորների բազմաթիվ խմբեր: Ձեր նպատակն է այդ խմբերը առանձնացնել առանձին շարքերի մեջ եւ վերադարձնել դրանց ցուցակը: Անհատ խմբերը հավասարակշռված են (յուրաքանչյուր բաց կլոր պատշաճ կերպով փակված է) եւ չեն վարդավորված միմյանց մեջ: Անտեսեք մուտքագրման շարքի ցանկացած տարածություն: Օրինակ. >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ] ['() ', '((()) ', '((() ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,hye_Armn,python,"

def truncate_number(number: float) -> float:
    """"""Տվյալ դրական շարժական կետով թիվը, այն կարող է բաժանվել եւ ամբողջական մասի (առավել մեծ ամբողջական թիվը փոքր է տրված թվից) եւ տասնորդականների (մնացած մասը միշտ փոքր է, քան 1) ։ Վերադարձեք թվի տասնորդական մասը: Օրինակ: >>> truncate_number(3.5) 0.5 """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,hye_Armn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Ձեզ տրվում է բանկային հաշիվի ավանդների եւ դուրսբերումների ցուցակ, որը սկսվում է զրոյական հաշվեկշռով: Ձեր խնդիրն է հայտնաբերել, թե արդյոք որեւէ պահի հաշիվի հաշվեկշռը ցածր է զրոյից, եւ այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False: Օրինակ: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,hye_Armn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Տվյալ մուտքագրման թվերի ցանկի համար հաշվարկեք միջին բացարձակ շեղումը տվյալների այս հավաքածուի միջինի շուրջ: Միջին բացարձակ շեղումը յուրաքանչյուր տարրի եւ կենտրոնի միջեւ միջին բացարձակ տարբերությունն է (սույն դեպքում միջին): MAD = միջին: x - x_միան: Օրինակ: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,hye_Armn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Ներդրեք ""մերձակայող"" թիվ մուտքագրման ցուցակի յուրաքանչյուր երկու հաջորդական տարրերի միջեւ `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,hye_Armn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Այս ֆունկցիայի մուտքագրումը մի շարք է, որը ներկայացված է բազմաթիվ խմբերով՝ միջակայքով բաժանված վարդավորված կլորների համար: Յուրաքանչյուր խմբի համար արտադրի վարդավորման ամենախոր մակարդակը: Օրինակ, (() (()) ունի առավելագույնը երկու մակարդակ, իսկ ((())) ունի երեքը: >>> parse_nested_parens('((())) ((())) () (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,hye_Armn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Ֆիլտրել մուտքագրվող տողերի ցանկը միայն այն տողերի համար, որոնք պարունակում են տրված ենթատող >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,hye_Armn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Ամբողջ թվերի տրված ցուցակի համար վերադարձրեք տուպլ, որը բաղկացած է ցուցակի բոլոր ամբողջ թվերի գումարից եւ արտադրվածքից: Ամբողջ թվերի դատարկ գումարը պետք է հավասար լինի 0-ին, իսկ դատարկ արտադրյալը պետք է հավասար լինի 1-ին: >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,hye_Armn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Լրիվ թվերի տրված ցուցակից ստեղծեք հաջորդականության մեջ գտնվող մինչեւ տրված պահը գտնված առավելագույն տարրի ցուցակը: >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,hye_Armn,python,"

def is_palindrome(string: str) -> bool:
    """"""Գտեք ամենակարճ պալինդրոմը, որը սկսվում է մատակարարված տողով: Ալգորիթմի գաղափարը պարզ է. - Գտեք մատակարարված տողի ամենաերկար պոստֆիքսը, որը պալինդրոմ է: - Տողի վերջում ավելացրեք տողային նախադասի հակառակ կողմը, որը գալիս է պալինդրոմային վերջույթից առաջ: >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Թեստ, եթե տրված տողը պալինդրոմ է:""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,hye_Armn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Տվյալները երկու տողեր են a եւ b, որոնք բաղկացած են միայն 1 եւ 0 թվերից: Կատարեք երկակի XOR այս մուտքագրումների վրա եւ արդյունքը վերադարձեք նաեւ որպես տող: >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,hye_Armn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Տարածվածքային ցուցակից վերադարձնել ամենաերկարը: Տարածել առաջինը, եթե նույն երկարության բազմաթիվ տողեր կան: Ոչ մի տող վերադարձնել, եթե մուտքային ցուցակը դատարկ է: >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,hye_Armn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Վերադարձնում է a եւ b երկու ամբողջ թվերի ամենամեծ ընդհանուր բաժանարարը >>> ամենամեծ_համընդհանուր_բաժանորդը ({3, 5) 1 >>> ամենամեծ_համընդհանուր_բաժանորդը ({25, 15) 5)""""""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,hye_Armn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Վերադարձնում է մուտքագրման տողերի բոլոր նախադաշարների ցուցակը՝ ամենակարճից մինչեւ ամենաերկարը >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,hye_Armn,python,"

def string_sequence(n: int) -> str:
    """"""Վերադարձնում է տող, որը պարունակում է տարածությամբ սահմանված թվեր՝ սկսած 0-ից մինչեւ n ներառյալ: >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,hye_Armn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Տված տողից պարզեք, թե քանի տարբերակիչ նիշ ունի այն (անկախ մեծամասնականից) >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,hye_Armn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Այս ֆունկցիայի մուտքագրումը երաժշտական նոտաներ ներկայացնող սյուն է հատուկ ASCII ձեւաչափով: Ձեր խնդիրն է վերլուծել ամբողջական սյունների ցանկը, որը համապատասխանում է շատ հարվածներին: Ահա մի լեգենդ. 'o' նոտա, վերջին չորս հարվածները 'o' - կես նոտա, վերջին երկու հարվածները 'o' - քառորդ նոտա, վերջին մեկ հարվածը >>> parse_music 'o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' [4, 2, 1, 2, 2, 1, 1, 1, 4, 4]""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,hye_Armn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Գտեք, թե քանի անգամ է տրված ենթաշարը կարելի գտնել սկզբնական շղթայում: Հաշվեք ծածկվող դեպքերը: >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,hye_Armn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Ներդնում է ""զրո""-ից ""նոյին"" թվային թվերի տող, որը սահմանված է տարածքով: Ճիշտ ընտրությունները ""զրո"", ""մեկ"", ""երկու"", ""երեք"", ""չորս"", ""հինգ"", ""վեց"", ""յոթ"", ""ութ"" եւ ""նոյին"" են: Վերադարձնում է տողը թվերով, որոնք դասավորված են ամենափոքրից մինչեւ ամենամեծը >>> sort_numbers (('three one five') 'one three five' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,hye_Armn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Տրամադրված թվերի ցուցակից (առնվազն երկուսը) ընտրեք եւ վերադարձրեք երկուսը, որոնք միմյանցից ամենամոտ են եւ վերադարձրեք դրանք հաջորդականությամբ (փոքր թիվ, մեծ թիվ): >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0)) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,hye_Armn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Տվյալ թվերի ցանկը (առնվազն երկու տարրից), կիրառեք գծային վերափոխում այդ ցուցակի վրա, այնպես որ ամենափոքր թիվը դառնա 0 եւ ամենամեծը դառնա 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,hye_Armn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Ֆիլտրում է ցանկացած Python արժեքների ցուցակը միայն ամբողջ թվերի համար >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,hye_Armn,python,"

def strlen(string: str) -> int:
    """"""Տվյալ տողերի վերադարձի երկարությունը >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,hye_Armn,python,"

def largest_divisor(n: int) -> int:
    """"""Տվյալ n թվին համար գտեք ամենամեծ թիվը, որը հավասարապես բաժանում է n-ը, փոքր է n-ից >>> ամենամեծ_բաժանորդը ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,hye_Armn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Տվյալ ամբողջ թվերի առաջնային գործոնների ցուցակը վերադարձնում է փոքրից մինչեւ մեծ կարգով: Յուրաքանչյուր գործոն պետք է թվարկվի այն թվով, որը համապատասխանում է այն թվին, որով այն հայտնվում է գործոնավորման մեջ: Մուտքային թիվը պետք է հավասար լինի բոլոր գործոնների արտադրյալին: >>> գործոնավորեք ((8) [2, 2, 2] >>> գործոնավորեք ((25) [5, 5] >>> գործոնավորեք ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,hye_Armn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Ամբողջ թվերի ցուցակից հեռացրեք բոլոր տարրերը, որոնք հանդիպում են ավելի քան մեկ անգամ: Մնացրեք տարրերի հաջորդականությունը նույնը, ինչպես մուտքագրման մեջ: >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,hye_Armn,python,"

def flip_case(string: str) -> str:
    """"""Տվյալ տողերի համար փոքր տառերը վերափոխեք մեծ տառերի եւ մեծ տառերը փոքր տառերի: >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,hye_Armn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Կոնկատենատի շարքերի ցանկը մեկ շարքի մեջ >>> կոնկատենատի (([]) '' >>> կոնկատենատի ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,hye_Armn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Ֆիլտրում է տողերի մուտքագրման ցուցակը միայն այն տողերի համար, որոնք սկսվում են տրված նախադասությամբ: >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,hye_Armn,python,"

def get_positive(l: list):
    """"""Վերադարձնում է միայն դրական թվերը ցուցակում: >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,hye_Armn,python,"

def is_prime(n):
    """"""Վերադարձնում է true, եթե տրված թիվը պարզ է, եւ false այլ կերպ: >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,hye_Armn,python,"import math


def poly(xs: list, x: float):
    """"""x-ները բազմանունի գործակիցներ են: find_zero find x-ը, որի համար poly ((x) = 0: find_zero-ն վերադարձնում է միայն միայն զրոյական կետը, նույնիսկ եթե շատ են: Ավելին, find_zero-ն վերցնում է միայն x-ների ցուցակը, որոնք ունեն նույնիսկ գործակիցների քանակ եւ ամենամեծ ոչ զրոյական գործակից, քանի որ դա երաշխավորում է լուծում: >>> round ((find_zero[(1, 2]), 2) # f ((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Գնահատում է բազմանունը xs գործակիցներով x կետում: վերադարձ xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,hye_Armn,python,"

def sort_third(l: list):
    """"""Այս ֆունկցիան վերցնում է l ցուցակը եւ վերադարձնում է l' ցուցակը, այնպես որ l' նույնական է l-ի հետ այն ցուցանիշներում, որոնք չեն բաժանվում երեքով, մինչդեռ դրա արժեքները երեքով բաժանվող ցուցանիշներում հավասար են l-ի համապատասխան ցուցանիշների արժեքներին, բայց կարգավորված են: >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,hye_Armn,python,"

def unique(l: list):
    """"""Վերադարձնում է դասավորված եզակի տարրեր ցուցակում >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,hye_Armn,python,"

def max_element(l: list):
    """"""Վերադարձնում է ցուցակի առավելագույն տարրը: >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,hye_Armn,python,"

def fizz_buzz(n: int):
    """"""Վերադարձնում է այն թվանշանների թիվը, որոնցում 7 թվանշանը հայտնվում է n-ից փոքր ամբողջ թվերի մեջ, որոնք բաժանվում են 11 կամ 13-ի: >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,hye_Armn,python,"

def sort_even(l: list):
    """"""Այս ֆունկցիան վերցնում է l ցուցակը եւ վերադարձնում է l' ցուցակը, այնպես որ l' նույնական է l-ի հետ անհավասար ցուցանիշներում, մինչդեռ նրա արժեքները զույգ ցուցանիշներում հավասար են l-ի զույգ ցուցանիշների արժեքներին, բայց կարգավորված են: >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,hye_Armn,python,"

def encode_cyclic(s: str):
    """"""որպես մուտքային տող է ընդունում encode_cyclic ֆունկցիայի միջոցով կոդավորված տող: Վերադարձնում է կոդավորված տող: """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""վերադարձնում է կոդավորված տողեր երեք նիշի ցիկլային խմբերով:""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,hye_Armn,python,"

def prime_fib(n: int):
    """"""prime_fib վերադարձնում է n-րդ թիվը, որը Ֆիբոնաչիի թիվ է եւ այն նաեւ պարզ թիվ է: >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,hye_Armn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero-ն ընդունում է ամբողջ թվերի ցուցակը որպես մուտք. այն True է վերադարձնում, եթե ցուցակում կան երեք տարբեր տարր, որոնք գումարվում են զրոյին, եւ False այլ կերպ: >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,hye_Armn,python,"

def car_race_collision(n: int):
    """"""Պատկերացրեք մի ճանապարհ, որը կատարյալ ուղիղ է, անվերջ երկար գիծ: n մեքենաներ ձախից աջ են գնում, միաժամանակ n մեքենաների այլ հավաքածու է աջից ձախ: Մեքենաների երկու հավաքածուները սկսում են միմյանցից շատ հեռու: Բոլոր մեքենաները շարժվում են նույն արագությամբ: Երկու մեքենաներ բախվում են, երբ ձախից աջ շարժվող մեքենան բախվում է աջից ձախ շարժվող մեքենային: Սակայն մեքենաները անվերջ ամուր են եւ ուժեղ: Արդյունքում, նրանք շարունակում են շարժվել իրենց հետագծով, կարծես թե չեն բախվել: Այս գործառույթը արտադրի նման բախումների թիվը:""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,hye_Armn,python,"

def incr_list(l: list):
    """"""Վերադարձում է ցուցակ, որի տարրերը ավելացվում են 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,hye_Armn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero-ն ընդունում է ամբողջ թվերի ցուցակը որպես մուտք. այն True է վերադարձնում, եթե ցուցակում կան երկու տարբեր տարրեր, որոնք գումարվում են զրոյին, եւ False այլ կերպ: >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,hye_Armn,python,"

def change_base(x: int, base: int):
    """"""Փոխեք մուտքագրված x թվային բազան բազա: Վերադարձեք տողերի ներկայացումը փոխարկումից հետո: բազային թվերը 10-ից պակաս են: >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,hye_Armn,python,"

def triangle_area(a, h):
    """"""Տված կողմի երկարությունը եւ եռանկյունի բարձր վերադարձի մակերեսը: >>> եռանկյուն_տարածքը (5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,hye_Armn,python,"

def fib4(n: int):
    """"""Fib4 թվային հաջորդականությունը նման է Ֆիբոնաչիի հաջորդականությանը, որը սահմանվում է հետեւյալ կերպ. fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Խնդրում ենք գրել ֆունկցիա, որը արդյունավետ հաշվարկում է fib4 թվային հաջորդականության n-րդ տարրը: Մի օգտագործեք ռեկուրսիան: >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,hye_Armn,python,"

def median(l: list):
    """"""Վերադարձի միջին ցուցակի տարրերի l. >>> միջին (([3, 1, 2, 4, 5]) 3 >>> միջին (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,hye_Armn,python,"

def is_palindrome(text: str):
    """"""Ստուգում է, թե տվյալ տողը պալինդրոմ է >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,hye_Armn,python,"

def modp(n: int, p: int):
    """"""Վերադարձնում է 2^n մոդուլ p (հիշեք թվային թվերը): >>> մոդուլ p (հաշվի 3, 5) 3 >>> մոդուլ p (հաշվի 1101, 101) 2 >>> մոդուլ p (հաշվի 0, 101) 1 >>> մոդուլ p (հաշվի 3, 11) 8 >>> մոդուլ p (հաշվի 100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,hye_Armn,python,"

def encode_shift(s: str):
    """"""որպես մուտքային տող է ընդունում encode_shift ֆունկցիայի միջոցով կոդավորված տող: Վերադարձնում է կոդավորված տող: """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""Վերադարձնում է կոդավորված տող՝ այբուբենի յուրաքանչյուր նիշը 5ով տեղափոխելով:""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,hye_Armn,python,"

def remove_vowels(text):
    """"""remove_vowels ֆունկցիան ստանձնում է տողեր եւ վերադարձնում առանց վոկալների տողեր: >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') ' '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd'""""""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,hye_Armn,python,"

def below_threshold(l: list, t: int):
    """"""Վերադարձնում է True, եթե l ցուցակի բոլոր թվերը t սահմանագծից ցածր են: >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,hye_Armn,python,"

def add(x: int, y: int):
    """"""Ավելացնել երկու թվեր x եւ y, ավելացնել 2 , 3 , 5 , ավելացնել 5 , 7 , 12""""""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,hye_Armn,python,"

def same_chars(s0: str, s1: str):
    """"""Ստուգեք, թե արդյոք երկու բառերն ունեն նույն նիշերը: >>> same_chars (('eabcdzzzz', 'dddzzzzzzzddeddabc') True >>> same_chars (('abcd', 'dddddddabc') True >>> same_chars (('dddddddabc', 'abcd') True >>> same_chars (('eabcd', 'dddddddabc') False >>> same_chars (('abcd', 'dddddddabce') False >>> same_chars (('eabcdzzzz', 'dddzzzzdddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,hye_Armn,python,"

def fib(n: int):
    """"""Վերադարձնում է n-րդ Ֆիբոնաչիի թիվը: >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,hye_Armn,python,"

def correct_bracketing(brackets: str):
    """"""brackets-ը ""<"" եւ "">"" շարքի շարքն է: return True, եթե յուրաքանչյուր բացման կոտորակ ունի համապատասխան փակման կոտորակ: >>> correct_bracketing ((""<"") False >>> correct_bracketing ((""<>"") True >>> correct_bracketing ((""<><>>"") True >>> correct_bracketing ((""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,hye_Armn,python,"

def monotonic(l: list):
    """"""Վերադարձնում է True, եթե ցուցակի տարրերը մոնոտոնորեն աճում կամ նվազում են: >>> մոնոտոնական (([1, 2, 4, 20]) True >>> մոնոտոնական (([1, 20, 4, 10]) False >>> մոնոտոնական (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,hye_Armn,python,"

def common(l1: list, l2: list):
    """"""Վերադարձնում է երկու ցուցակների համար դասավորված եզակի ընդհանուր տարրեր: >>> ընդհանուր (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> ընդհանուր (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,hye_Armn,python,"

def largest_prime_factor(n: int):
    """"""Վերադարձնում է n-ի ամենամեծ առաջնային գործոնը: Ենթադրենք, որ n > 1 եւ առաջնային չէ: >>> ամենամեծ_ առաջնային_ գործոն ((13195) 29 >>> ամենամեծ_ առաջնային_ գործոն ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,hye_Armn,python,"

def sum_to_n(n: int):
    """"""sum_to_n ֆունկցիա է, որը գումարում է 1-ից n թվերը: >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,hye_Armn,python,"

def correct_bracketing(brackets: str):
    """"""brackets-ը ""("" եւ """") շարքի շարքն է: return True, եթե յուրաքանչյուր բացման կոտորակ ունի համապատասխան փակման կոտորակ: >>> correct_bracketing (((""("") False >>> correct_bracketing ((("")) True >>> correct_bracketing (((() True >>> correct_bracketing ((((()) False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,hye_Armn,python,"

def derivative(xs: list):
    """"""xs-ը բազմանունի գործակիցներն են: xs[0] + xs[1] * x + xs[2] * x^2 + .... Վերադարձեք այս բազմանունի ածանցյալը նույն ձեւով: >>> ածանցյալ (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> ածանցյալ[(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,hye_Armn,python,"

def fibfib(n: int):
    """"""Ֆիբբոնաչիի թվային հաջորդականությունը նման է Ֆիբոնաչիի հաջորդականությանը, որը սահմանվում է հետեւյալ կերպ. fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Խնդրում ենք գրել ֆունկցիա, որը արդյունավետ հաշվարկում է ֆիբբոնաչի թվային հաջորդականության n-րդ տարրը: >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,hye_Armn,python,"
FIX = """"""Գրեք ֆունկցիա vowels_count, որը որպես մուտք է ընդունում բառը ներկայացնող տող եւ վերադարձնում է տողում եղած ձայնավորների թիվը: Այս դեպքում ձայնավորները 'a', 'e', 'i', 'o', 'u' են: Այստեղ 'y' նույնպես ձայնավոր է, բայց միայն այն դեպքում, երբ այն տրված բառի վերջում է: Օրինակ: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Ավելացնել փորձարկման դեպքեր:""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,hye_Armn,python,"
def circular_shift(x, shift):
    """"""Շրջանաձեւ տեղափոխեք x ամբողջ թվերի թվանշանները, տեղափոխեք թվանշանները աջով եւ վերադարձրեք արդյունքը որպես տող: Եթե shift > թվանշանների թիվը, վերադարձրեք թվանշանները հակառակ ուղղությամբ: >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,hye_Armn,python,"
def digitSum(s):
    """"""Գրել ֆունկցիա, որը ստանձնում է տող որպես մուտք եւ վերադարձնում է միայն վերին նիշերի գումարը ASCII կոդեր: Օրինակներ: digitSum ((("""") => 0 digitSum (((""abAB"") => 131 digitSum (((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum (((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,hye_Armn,python,"
def fruit_distribution(s,n):
    """"""Այս առաջադրանքի համար ձեզ տրվում է տող, որը ներկայացնում է խնձորների եւ նարնջի թիվը, որոնք բաշխվում են մրգերի զամբյուղում: Այս զամբյուղը պարունակում է խնձորներ, նարնջեր եւ մանգո պտուղներ: Տված տող, որը ներկայացնում է նարնջի եւ խնձորների ընդհանուր թիվը եւ ամբողջ թիվ, որը ներկայացնում է զամբյուղում մրգերի ընդհանուր թիվը, վերադարձրեք զամբյուղում մանգոյի պտուղների թիվը: օրինակ ՝ fruit_distribution ""5 ((( խնձորներ եւ 6 նարնջի "", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 խնձորներ եւ 1 նարնջի "", 3) -> 3 - 0 - 1 = 2 fruit_distribution""2 խնձորներ եւ 3 նարնջի "", 100) -> 100 - 2 - 3 = 95 fruit_distribution"" 100 խնձոր եւ 120) "", 1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,hye_Armn,python,"
def pluck(arr):
    """"""""Տվյալ շարքը, որը ներկայացնում է ծառի ճյուղ, որը ունի ոչ բացասական ամբողջական հանգույցներ ձեր խնդիրն է վերցնել հանգույցներից մեկը եւ վերադարձնել այն: Հաշված հանգույցը պետք է լինի հանգույցը, որն ունի ամենափոքր նույնիսկ արժեքը: Եթե հայտնաբերվել են մի քանի հանգույցներ, որոնք ունեն նույն փոքրագույն նույնիսկ արժեքը, վերադարձնել հանգույցը, որն ունի ամենափոքր ինդեքսը: Հաշված հանգույցը պետք է վերադարձվի ցուցակում, [smallest_value, իր ինդեքսը ], Եթե չկան նույնիսկ արժեքներ կամ տրված շարքը դատարկ է, վերադարձնել []. Օրինակ. 1: Մուտք: [4,2,3] Արտադրանք: [2, 1] Հստակեցում. 2 ունի ամենափոքր նույնիսկ արժեքը, եւ 2 ունի ամենափոքր ինդեքսը: Օրինակ. 2: Մուտք. [1,2,3] Արտադրանք. [2, 1] Հստակեցում. 2 ունի ամենափոքր արժեքը, եւ 2 ունի ամենափոքր նույնիսկ ինդեքսը: Օրինակ. 3: Մուտք. [] Արտադրանք. [4:] Մուտք. [5, 3, 4] Մուտք. [0, 2] Արտադրանք. 1 Նշրջանցք. 0: Ամենափոքր հանգույցը, որն ունի ամենափոքր ինդեքսը, բայց կա երկու արժեքը: * 0: Օրինակ. Մուտք. Մուտք.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,hye_Armn,python,"
def search(lst):
    '''Ձեզ տրված է դրական ամբողջ թվերի ոչ դատարկ ցուցակ: Վերադարձեք ամենամեծ ամբողջ թիվը, որը մեծ է զրոյից եւ ունի հաճախականություն, որը մեծ է կամ հավասար է ամբողջ թվերի արժեքին: Ամբողջ թվերի հաճախականությունը ցուցակում հայտնվելու անգամների քանակն է: Եթե նման արժեք գոյություն չունի, վերադարձեք -1. Օրինակներ. որոնում: [4, 1, 2, 2, 3, 1]) == 2 որոնում: [1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3 որոնում: [5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,hye_Armn,python,"
def strange_sort_list(lst):
    '''Տվյալ ամբողջ թվերի ցուցակը, վերադարձնում է ցուցակը տարօրինակ կարգով: Տարօրինակ կարգավորում, երբ սկսում եք նվազագույն արժեքից, ապա մնացած ամբողջ թվերի առավելագույնից, ապա նվազագույնից եւ այլն: Օրինակներ: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,hye_Armn,python,"
def triangle_area(a, b, c):
    '''Տվյալ են եռանկյան երեք կողմերի երկարությունները: Վերադարձեք եռանկյան մակերեսը, որը կլորացված է 2 տասնորդական կետի վրա, եթե երեք կողմերը կազմում են վավեր եռանկյուն: Հակառակ դեպքում վերադարձեք -1 Երեք կողմերը վավեր եռանկյուն են կազմում, երբ ցանկացած երկու կողմերի գումարն ավելի մեծ է, քան երրորդ կողմը: Օրինակ: եռանկյուն_տարածքը ((3, 4, 5) == 6.00 եռանկյուն_տարածքը ((1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,hye_Armn,python,"
def will_it_fly(q,w):
    '''Գրեք ֆունկցիա, որը կվերադարձնի True, եթե q օբյեկտը թռչի, եւ False այլ կերպ: Q օբյեկտը թռչելու է, եթե այն հավասարակշռված է (դա պալինդրոմային ցուցակ է) եւ դրա տարրերի գումարը պակաս է կամ հավասար է հնարավոր առավելագույն քաշին w: Օրինակ: will_it_fly (([1, 2], 5) â -> False # 1+2 -ը պակաս է հնարավոր առավելագույն քաշից, բայց անհավասարակշռված է: will_it_fly (([3, 2, 3], 1) â -> False # հավասարակշռված է, բայց 3+2+3 -ը ավելի է հնարավոր առավելագույն քաշից: will_it_fly (([3, 2, 3], 9) â -> True # 3+2 -ը պակաս է հնարավոր առավելագույն քաշից եւ հավասարակշռված է: will_it_fly ((([3], 5) â -> True # 3 -ը պակաս է հնարավոր առավելագույն քաշից եւ հավասարակշռված է: '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,hye_Armn,python,"
def smallest_change(arr):
    """"""Տված ամբողջ թվերի շարքը, գտեք տարրերի նվազագույն թիվը, որոնք պետք է փոխվեն, որպեսզի շարքը պալինդրոմ լինի: Պալինդրոմ շարքը մի շարք է, որը կարդում է նույնը առաջ եւ ետ: Մեկ փոփոխության ընթացքում կարող եք փոխել մեկ տարր ցանկացած այլ տարրով: Օրինակ ՝ smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,hye_Armn,python,"
def total_match(lst1, lst2):
    '''Գրեք ֆունկցիա, որը ընդունում է երկու շարքի ցուցակ եւ վերադարձնում է այն ցուցակը, որի բոլոր շարքերում թվանշանների ընդհանուր թիվը մյուսից պակաս է: Եթե երկու ցուցակները ունեն նույն թվով թվանշաններ, վերադարձրեք առաջին ցուցակը: Օրինակներ total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi'], 'hi'_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,hye_Armn,python,"
def is_multiply_prime(a):
    """"""Գրեք ֆունկցիա, որը կվերադառնա true, եթե տրված թիվը 3 պարզ թվերի բազմապատկումն է, եւ false, եթե ոչ: Գիտելով, որ a-ն ավելի քիչ է, քան 100: Օրինակ: is_multiply_prime(30) == True 30 = 2 * 3 * 5 """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,hye_Armn,python,"
def is_simple_power(x, n):
    """"""Ձեր խնդիրն է գրել ֆունկցիա, որը կվերադառնա true, եթե x թիվը n-ի պարզ ուժգնություն է, իսկ false այլ դեպքերում: x-ը n-ի պարզ ուժգնություն է, եթե n**int=x Օրինակ՝ is_simple_power ((1, 4) => true is_simple_power ((2, 2) => true is_simple_power ((8, 2) => true is_simple_power ((3, 2) => false is_simple_power ((3, 1) => false is_simple_power ((5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,hye_Armn,python,"
def iscube(a):
    '''Գրեք ֆունկցիա, որը ընդունում է ամբողջ թիվ a եւ վերադարձնում է True, եթե այդ ingeger- ը ամբողջ թվերի խորանարդ է: Նշում. Դուք կարող եք ենթադրել, որ մուտքագրումը միշտ վավեր է: Օրինակներ: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,hye_Armn,python,"
def hex_key(num):
    """"""Ձեզ տրվել է ֆունկցիա գրել, որը ստանում է վեցանասանորդական թիվ որպես տող եւ հաշվում է վեցանասանորդական թվերի քանակը, որոնք պարզ թվեր են (հիմնական թիվը կամ պարզ թիվը 1-ից մեծ բնական թիվ է, որը երկու փոքր բնական թվերի արդյունք չէ): Վեցանասանորդական թվերը 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F: Հիմնական թվերը 2, 3, 5, 7, 11, 13, 17,...: Այսպիսով, դուք պետք է որոշեք հետեւյալ թվերից մի շարք: 2, 3, 5, 7, B (= տասնորդական 11), D (= տասնորդական 13): Նշում. Դուք կարող եք ենթադրել, որ մուտքը միշտ ճիշտ է կամ դատարկ տող, եւ A, B, C, D, E, F խորհրդանիշները միշտ մեծամասային են: Օրինակներ. ""Ամ"" համարը = AB, արտադրանքը պետք է լինի 1. ""Ամ"" համար = 1077E, արտադրանքը պետք է լինի 2. ""Ամ"" համար = AB331ED, արտադրանքը պետք է լինի 4. ""Ամ"" համար = 6.01289B, ""Ամ"" համար = 6.045D ""2020EF"" արտադրանքը պետք է լինի 2.""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,hye_Armn,python,"
def decimal_to_binary(decimal):
    """"""Ձեզ տրվում է տասնորդական թվային ձեւով եւ ձեր խնդիրն է այն փոխարկել երկակի ձեւով: Ֆունկցիան պետք է վերադարձնի տող, որտեղ յուրաքանչյուր նիշ ներկայացնում է երկակի թվային ձեւ: Տողում յուրաքանչյուր նիշ կլինի '0' կամ '1': Տողի սկզբում եւ վերջում կլինի 'db' ավելորդ մի քանի նիշ: Ավելորդ նիշերը այնտեղ են, որպեսզի օգնեն ձեւաչափին: Օրինակներ: decimal_to_binary ((15) # վերադարձնում է ""db1111db"" decimal_to_binary32) # վերադարձնում է ""db100000db""""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,hye_Armn,python,"
def is_happy(s):
    """"""Ձեզ տրվում է string s. Ձեր խնդիրն է ստուգել, թե արդյոք string-ը happy է, թե ոչ: String-ը happy է, եթե դրա երկարությունը առնվազն 3 է, եւ յուրաքանչյուր 3 հաջորդական տառերը տարբեր են: Օրինակ ՝ is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,hye_Armn,python,"
def numerical_letter_grade(grades):
    """"""Սա սեմեստերի վերջին շաբաթն է, եւ ուսուցիչը պետք է գնահատականներ տա աշակերտներին: Ուսուցիչը գնահատականների համար իր սեփական ալգորիթմն է ստեղծել: Միակ խնդիրը այն է, որ նա կորցրել է գնահատականների համար օգտագործված կոդը: Նա ձեզ տվել է որոշ ուսանողների միջին գնահատականների ցուցակ, եւ դուք պետք է ֆունկցիա գրեք, որը կարող է արտադրանք տալ նամակային գնահատականների ցուցակը 'օգտագործելով հետեւյալ աղյուսակը.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,hye_Armn,python,"
def prime_length(string):
    """"""Գրեք ֆունկցիա, որը վերցնում է տող եւ վերադարձնում է True, եթե տողի երկարությունը պարզ թիվ է կամ False այլապես Օրինակներ prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,hye_Armn,python,"
def starts_one_ends(n):
    """"""Տված դրական n ամբողջ թիվը, վերադարձնում է n-անիշ դրական ամբողջ թվերի թվերը, որոնք սկսվում կամ ավարտվում են 1-ով:""""""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,hye_Armn,python,"
def solve(N):
    """"""Տված N դրական ամբողջ թիվը, վերադարձրեք դրա թվանշանների ընդհանուր գումարը երկակի թվով: Օրինակ N = 1000-ի համար թվանշանների գումարը կլինի 1, արտադրանքը պետք է լինի ""1"": N = 150-ի համար թվանշանների գումարը կլինի 6, արտադրանքը պետք է լինի ""110"": N = 147-ի համար թվանշանների գումարը կլինի 12, արտադրանքը պետք է լինի ""1100"": Փոփոխականներ: @N ամբողջ թիվ Սահմանափակումներ: 0 â‰¤ N â‰¤ 10000. Արտադրանքը ՝ երկակի թվերի շարք:""""""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,hye_Armn,python,"
def add(lst):
    """"""Տված ամբողջ թվերի ոչ դատարկ ցուցակը, նախ ավելացրեք զույգ տարրերը, որոնք զույգ ցուցանիշներ են: Օրինակներ: ավելացնել (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,hye_Armn,python,"
def anti_shuffle(s):
    """"""Գրեք ֆունկցիա, որը վերցնում է տող եւ վերադարձնում է դրա կարգավորված տարբերակը: Տողի կարգավորված տարբերակը, այն տողն է, որտեղ բոլոր բառերը (տարբերվում են տարածությամբ) փոխարինվում են նոր բառով, որտեղ բոլոր նիշերը դասավորված են աճող կարգով ՝ հիմնված ASCII արժեքի վրա: Նշում. Դուք պետք է պահեք բառերի եւ դատարկ տարածությունների կարգը նախադասությունում: Օրինակ ՝ anti_shuffle ((('Hi ') վերադարձնում է' Hi 'anti_shuffle ((('hello '), վերադարձնում է' ehllo 'anti_shuffle (('Hello World !!!') վերադարձնում է' Hello !!!Wdlor ' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,hye_Armn,python,"
def get_row(lst, x):
    """"""Տվյալները տրվում են որպես 2 չափման տվյալներ, որպես տեղադրված ցուցակներ, որոնք նման են մետրիկային, սակայն, ի տարբերություն մետրիկների, յուրաքանչյուր շարքը կարող է պարունակել տարբեր թվով սյունակներ: Տվյալների lst եւ ամբողջական x, գտեք ամբողջական x- ը ցուցակում եւ վերադարձեք տուպլերի ցուցակը, [(x1, y1), (x2, y2) ...] այնպես, որ յուրաքանչյուր տուպլը համակարգիչ է - (հորիզոնական, սյունակներ), սկսած 0-ից: Սկզբում համակարգիչները դասավորեք շարքերի կողմից ՝ իջող կարգով: Նաեւ, դասավորեք շարքի համակարգիչները սյունակների կողմից ՝ իջող կարգով: Օրինակներ: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1] ], 1) == [0, 0, 0, 0, 1, 4], 0 (2, 5), (2, 0, 0] get_(1), [] == [[հորիզոնական, 1, 2, 3]], [2, 2]]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,hye_Armn,python,"
def sort_array(array):
    """"""Տվյալ ամբողջ թվերի շարքը, դասակարգելուց հետո վերադարձեք տվյալ շարքի պատճենը, եթե գումարը ((առաջին ինդեքսային արժեքը, վերջին ինդեքսային արժեքը) անհավասար է, ապա դասակարգեք տվյալ շարքը աճող կարգով, կամ դասակարգեք այն իջնող կարգով, եթե գումարը ((առաջին ինդեքսային արժեքը, վերջին ինդեքսային արժեքը) զույգ է: Նշում: * չփոխեք տրված շարքը: Օրինակներ: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,hye_Armn,python,"
def encrypt(s):
    """"""Ստեղծեք encrypt ֆունկցիա, որը տողն է վերցնում որպես փաստարկ եւ վերադարձնում է կոդավորված տող՝ այբուբենի պտտման ժամանակ: Այբուբենը պետք է պտտվի այնպես, որ տառերը տեղափոխվեն ներքեւ՝ երկու անգամ երկու տեղով: Օրինակ՝ encrypt (('hi') վերադարձնում է 'lm' encrypt (('asdfghjkl') վերադարձնում է 'ewhjklnop' encrypt (('gf') վերադարձնում է 'kj' encrypt (('et') վերադարձնում է 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,hye_Armn,python,"
def next_smallest(lst):
    """"""Ձեզ տրված է ամբողջ թվերի ցուցակ: Գրեք next_smallest () ֆունկցիա, որը վերադարձնում է ցուցակի 2-րդ ամենափոքր տարրը: Վերադարձնում է None, եթե չկա նման տարր: next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == None next_smallest () [1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,hye_Armn,python,"
def is_bored(S):
    """"""""I"" բառը նշանակում է ""I"" բառը: Բառերը սահմանվում են ""I"", ""I"" կամ ""I"" տառերով: Օրինակ՝ >>> is_bored (բժշկված) ""Hello world"" (Բարեւ աշխարհ) 0 >>> is_bored (բժշկված) ""The sky is blue (Արեւը կապույտ է) "" I love this weather (Ես սիրում եմ այս եղանակը) 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,hye_Armn,python,"
def any_int(x, y, z):
    '''Ստեղծեք ֆունկցիա, որը ընդունում է 3 թվեր: Վերադարձնում է true, եթե թվերից մեկը հավասար է մյուս երկուսի գումարին, եւ բոլոր թվերը ամբողջ թվեր են: Վերադարձնում է false ցանկացած այլ դեպքում: Օրինակներ any_int{5, 2, 7}: -> True any_int{3, 2, 2}: -> False any_int{3, -2, 1): -> True any_int{3.6, -2.2, 2): -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,hye_Armn,python,"
def encode(message):
    """"""Գրեք ֆունկցիա, որը վերցնում է հաղորդագրություն եւ կոդավորում է այնպես, որ փոխի բոլոր տառերի քանակը, փոխարինի հաղորդագրության բոլոր վոկալները այն տառով, որը հայտնվում է անգլերեն այբուբենի այդ վոկալից 2 տեղ առաջ: Ենթադրեք միայն տառեր: Օրինակներ. >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,hye_Armn,python,"

def skjkasdkd(lst):
    """"""Դուք պետք է գտնեք ամենամեծ պարզ արժեքը եւ վերադարձնեք դրա թվանշանների գումարը: Օրինակներ: Lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] արտադրանքը պետք է լինի 10 Lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] արտադրանքը պետք է լինի 25 Lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] արտադրանքը պետք է լինի 13 Lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] արտադրանքը պետք է լինի 11 Lst = [0,81,12,3,21,1] արտադրանքը պետք է լինի 3 Lst = [0,1,8,1,2,1,7] արտադրանքը պետք է լինի 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,hye_Armn,python,"
def check_dict_case(dict):
    """"""Տված բառարան, վերադարձնում True եթե բոլոր ստեղները տողեր են փոքր տառերով կամ բոլոր ստեղները տողեր են մեծ տառերով, այլապես վերադարձնում False: Ֆունկցիան պետք է վերադարձնի False, եթե տրված բառարանը դատարկ է: Օրինակներ: check_dict_case{""a"":""apple"", ""b"":""banana""}) պետք է վերադարձնի True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) պետք է վերադարձնի False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) պետք է վերադարձնի False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) False պետք է վերադարձնի check.dict_case{""NC"":""STATE"", ""Z"":""IP""12345 }) պետք է վերադարձնի True:""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,hye_Armn,python,"
def count_up_to(n):
    """"""Կիրառել ֆունկցիա, որը վերցնում է ոչ բացասական ամբողջ թիվ եւ վերադարձնում է առաջին n ամբողջ թվերի շարքը, որոնք պարզ թվեր են եւ փոքր են n-ից: օրինակ ՝ count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,hye_Armn,python,"
def multiply(a, b):
    """"""Լրացրեք ֆունկցիան, որը վերցնում է երկու ամբողջ թվեր եւ վերադարձնում է դրանց միավորի թվանշանների արտադրյալը: Ենթադրենք, որ մուտքագրումը միշտ վավեր է: Օրինակներ. բազմապատկել 148, 412) պետք է վերադարձնի 16, բազմապատկել 19 , 28 պետք է վերադարձնի 72, բազմապատկել 2020 , 1851 պետք է վերադարձնի 0 , բազմապատկել 14 , 15 պետք է վերադարձնի 20:""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,hye_Armn,python,"
def count_upper(s):
    """"""Տված s շարքը, հաշվել մեծ տառերով հնչող ձայնավորների քանակը զույգ ցուցանիշներով: Օրինակ ՝ count_upper (('aBCdEf ') վերադարձնում է 1 count_upper (('abcdefg ') վերադարձնում է 0 count_upper (('dBBE ') վերադարձնում է 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,hye_Armn,python,"
def closest_integer(value):
    '''Ստեղծեք ֆունկցիա, որը վերցնում է արժեք (հղի), որը ներկայացնում է թիվը եւ վերադարձնում է դրան ամենամոտ ամբողջական թիվը: Եթե թիվը հավասար հեռավորության վրա է երկու ամբողջական թվերից, ապա այն կլորացրեք զրոյից հեռու: Օրինակներ >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Նշում. Կլորացումից հեռու զրոյից նշանակում է, որ եթե տրված թիվը հավասար հեռավորության վրա է երկու ամբողջական թվերից, ապա այն պետք է վերադարձվի, որը ամենաբարձր հեռավորությունն է զրոյից: Օրինակ, closest_integer "" ((14.5"") պետք է վերադարձնի 15, իսկ closest_integer "" ((-14.5"") պետք է վերադարձնի -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,hye_Armn,python,"
def make_a_pile(n):
    """"""Տված դրական ամբողջ թիվ n, դուք պետք է պատրաստեք n մակարդակի քարերի կուտակ: Առաջին մակարդակը ունի n քար: Քարերի թիվը հաջորդ մակարդակում հետեւյալն է. - հաջորդ անհավասար թիվը, եթե n-ը անհավասար է: - հաջորդ զույգ թիվը, եթե n-ը զույգ է: Վերադարձեք յուրաքանչյուր մակարդակի քարերի թիվը ցուցակում, որտեղ i ցուցանիշի տարրը ներկայացնում է մակարդակի քարերի թիվը (i + 1). Օրինակներ: >>> make_a_pile (i) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,hye_Armn,python,"
def words_string(s):
    """"""Ձեզ տրվում է բառերի շարք, որոնք բաժանվում են կոմայի կամ տարածության միջոցով: Ձեր խնդիրն է բաժանել շարքը բառերի եւ վերադարձնել բառերի շարքը: Օրինակ ՝ words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,hye_Armn,python,"
def choose_num(x, y):
    """"""Այս ֆունկցիան վերցնում է երկու դրական թվեր x եւ y եւ վերադարձնում է ամենամեծ զույգ ամբողջ թիվը, որը գտնվում է [x, y] ներառյալ տիրույթում: Եթե նման թիվ չկա, ապա ֆունկցիան պետք է վերադարձնի -1: Օրինակ ՝ choose_num(12, 15) = 14 choose_num(13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,hye_Armn,python,"
def rounded_avg(n, m):
    """"""Ձեզ տրված են երկու դրական ամբողջ թվեր՝ n եւ m, եւ ձեր խնդիրն է հաշվարկել n-ից մինչեւ m ամբողջ թվերի միջին թիվը (ներառյալ n եւ m): Կլորացրեք պատասխանը մինչեւ մոտակա ամբողջ թիվը եւ այն փոխարկեք երկակի թվին: Եթե n-ը մեծ է, վերադարձրեք -1: Օրինակ՝ rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b11"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,hye_Armn,python,"
def unique_digits(x):
    """"""Տվյալ դրական ամբողջ թվերի ցուցակ x. վերադարձնել բոլոր տարրերի դասավորված ցուցակ, որը չունի զույգ թվանշան: Նշում. Վերադարձված ցուցակը պետք է դասավորվի աճող կարգով: Օրինակ ՝ >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,hye_Armn,python,"
def by_length(arr):
    """"""Տված ամբողջ թվերի շարքը, դասակարգեք ամբողջ թվերը, որոնք 1-ից 9-ի միջեւ են, հակադարձեք արդյունքային շարքը, եւ ապա փոխարինեք յուրաքանչյուր թվանշան իր համապատասխան անունով ""Մեկ"", ""Երկու"", ""Երեք"", ""Չորս"", ""Հինգ"", ""Վեց"", ""Յոթ"", ""Ութ"", ""Նաը"": Օրինակ ՝ arr = [2, 1, 1, 4, 5, 8, 2, 3] -> դասակարգեք arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> հակադարձ arr -> [8, 5, 4, 3, 2, 2, 1, 1] վերադարձ [""Ութ"", ""Չորս"", ""Երեք"", ""Երկու"", ""Երկու"", ""Մեկ"", ""Մեկ""] Եթե շարքը դատարկ է, վերադարձեք մի ամբողջ թվ: arr = [] վերադարձեք շարքը [] Եթե շարքը ունի որեւէ տարօրինակ թիվ, անտեսեք այն: arr = [1, -1 , 55] -> arr -> [1, 55] -> arr -> [55, 1] - վերադարձեք մեկ ']""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,hye_Armn,python,"
def f(n):
    """"""Կիրառել ֆունկցիան f, որը n-ը վերցնում է որպես պարամետր եւ վերադարձնում է n չափի ցուցակ, այնպես, որ i ինդեքսում գտնվող տարրի արժեքը i-ի գործակիցն է, եթե i-ն զույգ է կամ 1-ից i-ի թվերի գումարն է: i-ն սկսվում է 1-ից: i-ի գործակիցը 1-ից i-ի թվերի բազմապատկումն է (1 * 2 * ... * i): Օրինակ: f ((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,hye_Armn,python,"
def even_odd_palindrome(n):
    """"""Տված դրական ամբողջ թիվ n, վերադարձնել մի տուփլ, որը ունի զույգ եւ անհավասար ամբողջ թվերի պալինդրոմների թիվը, որոնք ընկնում են տիրույթում ((1, n), ներառյալ: Օրինակ1: Մուտք: 3 Արտադրանք: (1, 2) Հստակեցում: Ամբողջ թվերի պալինդրոմները 1, 2, 3. դրանցից մեկը զույգ է, իսկ երկուսը զույգ են: Օրինակ2: Մուտք: 12 Արտադրանք: (4, 6) Հստակեցում: Ամբողջ թվերի պալինդրոմները 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. նրանցից չորսը զույգ են, իսկ 6-ը զույգ են: Նշում. 1. 1 <= n <= 10 ^ 3 2. Տուփլը վերադարձրել է համապատասխանաբար զույգ եւ զույգ ամբողջ թվերի պալինդրոմների թիվը: """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,hye_Armn,python,"
def count_nums(arr):
    """"""Գրեք count_nums ֆունկցիա, որը վերցնում է ամբողջ թվերի շարք եւ վերադարձնում է տարրերի թիվը, որի թվանշանների գումարը > 0 է: Եթե թիվը բացասական է, ապա դրա առաջին ստորագրված թվանշանը կլինի բացասական. օրինակ ՝ -123 -ը ստորագրված թվանշաններ ունի -1, 2 եւ 3: >>> count_nums (([]) == 0 >>> count_nums ([-1, 11, -11]) == 1 >>> count_nums ([1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,hye_Armn,python,"
def move_one_ball(arr):
    """"""Մենք ունենք array 'arr' N ամբողջ թվերից arr[1], arr[2], ..., arr[N]։ Թվերը շարքում պատահականորեն կարգավորվելու են։ Ձեր խնդիրն է որոշել, թե արդյոք հնարավոր է array-ը կարգավորել ոչ նվազող կարգով՝ կատարելով հետեւյալ գործողությունը տվյալ շարքում. Ձեզ թույլատրվում է կատարել աջ տեղաշարժի գործողություն ցանկացած քանակությամբ անգամ։ Մեկ աջ տեղաշարժի գործողություն նշանակում է, որ շարքի բոլոր տարրերը մեկ դիրքով տեղափոխվում են աջ ուղղությամբ։ Զանգվածի վերջին տարրը տեղափոխվում է շարքի մեկնարկային դիրք, այսինքն՝ 0-րդ ցուցանիշը։ Եթե հնարավոր է ստանալ կարգավորված շարքը վերոնշյալ գործողությունը կատարելով, ապա վերադարձեք True, այլ դեպքում վերադարձեք False։ Եթե տրված շարքը դատարկ է, ապա վերադարձեք True։ Նշում. Տվյալ ցուցակը երաշխավորված է, որ կունենա եզակի տարրեր։ Օրինակ՝ move_one_(ball[3, 4, 5, 2]։ Ճիշտ բացատրություն. Տվյալ շարքի համար հնարավոր է իրականացնել ոչ նվազող կարգով array-ի կարգավորումը՝ կատարելով հետեւյալ գործողությունները։ Դուք կարող եք կատարել աջ տեղաշարժման գործողություն ցանկացած քանակությամբ։ Մեկ աջ տեղաշարժի գործողություն նշանակում է array-ի բոլոր տարրերը մեկ դիրքով ճիշտ ուղղությամբ, այսինքն՝ 0-ից, 0-րդ ցուցանիշը, ապա վերոնշարժում է, եթե հնարավոր է ստանալ վերոնշված շարքի սկզբնական դիրք, ապա True, ապա True, True, True, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, etc.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,hye_Armn,python,"
def exchange(lst1, lst2):
    """"""Այս խնդրի համար դուք կկիրառեք մի ֆունկցիա, որը վերցնում է թվերի երկու ցուցակ եւ որոշում է, թե արդյոք հնարավոր է դրանց միջեւ տարրերի փոխանակում կատարել, որպեսզի lst1-ը լինի միայն զույգ թվերի ցուցակ: Չկա սահմանափակում lst1-ի եւ lst2-ի միջեւ փոխանակվող տարրերի քանակի վրա: Եթե հնարավոր է փոխանակել տարրեր lst1-ի եւ lst2-ի միջեւ, որպեսզի lst1-ի բոլոր տարրերը զույգ լինեն, վերադարձրեք ""YES"": Այլ դեպքում վերադարձրեք ""NO"": Օրինակ ՝ փոխանակում [(1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" փոխանակում [(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Ենթադրվում է, որ մուտքագրված ցուցակները կլինեն ոչ դատարկ: """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,hye_Armn,python,"
def histogram(test):
    """"""Տվյալ տող, որը ներկայացնում է տարածություն բաժանված փոքր տառեր, վերադարձնում է ամենաշատ կրկնվող տառերի բառարան եւ պարունակում է համապատասխան թվաքանակը: Եթե մի քանի տառեր ունեն նույն դեպքը, վերադարձնում է բոլորին: Օրինակ ՝ հիստոգրամը:""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,hye_Armn,python,"
def reverse_delete(s,c):
    """"""Խնդիր Մենք տրված ենք երկու տողեր s եւ c, դուք պետք է ջնջեք բոլոր նիշերը s, որոնք հավասար են ցանկացած նիշի c ապա ստուգել, եթե արդյունքը տող palindrome. A տող է կոչվում palindrome, եթե այն կարդում նույն ետ, ինչպես առաջ. Դուք պետք է վերադարձնել մի tuple պարունակող արդյունքի տող եւ True/False համար ստուգման. Օրինակ, s = ""abcde"", c = ""ae"", արդյունքը պետք է լինի ('bcd', False) համար s = ""abcdef"", c = ""b"" արդյունքը պետք է լինի ('acdef', False) համար s = ""abcdedcba"", c = ""ab"", արդյունքը պետք է լինի ('cdedc', True) """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,hye_Armn,python,"
def odd_count(lst):
    """"""Տվյալ շարքերի ցանկ, որտեղ յուրաքանչյուր շարքը բաղկացած է միայն թվանշաններից, վերադարձնում է ցուցակ: Արտադրանքի յուրաքանչյուր i տարր պետք է լինի ""ներդրման i շարքի տարօրինակ տարրերի թիվը"": որտեղ բոլոր i-ները պետք է փոխարինվեն մուտքի i-րդ շարքի տարօրինակ թվանշանների թվով: >>> odd_count['1234567']) [""odd_elements 4n the str4ng 4 of the 4nput.""] >>> odd_count['3',""111111""]) [""odd_elements 1n the str1ng 1 of the 1nput."", ""odd elements 8n the str8ng 8 of the 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,hye_Armn,python,"
def minSubArraySum(nums):
    """"""Տված ամբողջ թվերի զանգված, գտեք n-ի ոչ դատարկ ենթաշարերի նվազագույն գումարը: Օրինակ minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,hye_Armn,python,"
def max_fill(grid, capacity):
    import math
    """"""Ձեզ տրված է հորիզոնականների ուղղանկյուն ցանց: Յուրաքանչյուր շարքը ներկայացնում է մեկ հորիզոնական, եւ յուրաքանչյուր շարքում 1-ը ներկայացնում է մեկ միավոր ջուր: Յուրաքանչյուր հորիզոնական ունի համապատասխան բուկետ, որը կարող է օգտագործվել ջուր հանելու համար, եւ բոլոր բուկետները նույն հզորությամբ են: Ձեր խնդիրն է օգտագործել բուկետները հորիզոնականները դատարկելու համար: Արտադրի այն քանակը, որը անհրաժեշտ է իջեցնել բուկետները: Օրինակ 1: Մուտք: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Արտադրիչ: Օրինակ 6: Մուտք: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Արտադրիչ: 5 Օրինակ 3: Մուտք: [[0,0,0], [0,0,0]] bucket_capacity: 5 Արտադրիչ: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,hye_Armn,python,"
def sort_array(arr):
    """"""Այս կատայում պետք է դասակարգել ոչ բացասական ամբողջ թվերի շարքը ըստ դրանց երկակի ներկայացման մեջ 1-ի թվի՝ բարձրանող կարգով: Նման թվերի համար դասակարգեք տասնորդական արժեքի հիման վրա: Այն պետք է իրականացվի հետեւյալ կերպ. >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,hye_Armn,python,"
def select_words(s, n):
    """"""Տվյալ տող s եւ բնական թիվ n, ձեզ տրվել է գործառույթ, որը վերադարձնում է բոլոր բառերի ցուցակը տող s-ից, որոնք պարունակում են ճիշտ n համահեղինակներ, որպեսզի այդ բառերը հայտնվեն տող s-ում: Եթե տող s-ը դատարկ է, ապա գործառույթը պետք է վերադարձնի դատարկ ցուցակ: Նշում. Դուք կարող եք ենթադրել, որ մուտքագրված տողը պարունակում է միայն տառեր եւ տարածություններ: Օրինակներ. select_words ""Մարիամը փոքրիկ գառան ուներ"", 4) ==> [""little""] select_words ""Մարիամը փոքրիկ գառան ուներ"", 3) ==> [""Մարիամը"", ""գառան""] select_words ""պարզ սպիտակ տարածություն"", 2) ==> [] select_words ""Բարեւ ձեզ"", 4) ==> [""world""] select_words ""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,hye_Armn,python,"
def get_closest_vowel(word):
    """"""Ձեզ տրվում է բառ: Ձեր խնդիրն է գտնել ամենահամ մոտ ձայնականը, որը գտնվում է բառի աջ կողմում գտնվող երկու ձայնականների միջեւ (համակարգային) ։ Սկզբում եւ վերջում գտնվող ձայնականները չեն հաշվարկվում: Վերադարձեք դատարկ տող, եթե չեք գտել վերը նշված պայմանը: Կարող եք ենթադրել, որ տրված տողը պարունակում է միայն անգլերեն տառեր: Օրինակ: get_closest_vowel ((""yogurt"") ==> ""u"" get_closest_vowel ((""F"") ==> ""UULL"" get_closest_vowel ((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,hye_Armn,python,"
def match_parens(lst):
    '''Ձեզ տրվում է երկու տողերի ցուցակ, երկու տողերն էլ բաղկացած են միայն բաց կոճակներից '(' կամ փակ կոճակներից ') ': Ձեր աշխատանքը ստուգելն է, թե արդյոք հնարավոր է երկու տողերը միացնել որոշակի կարգով, որ արդյունքում ստացվող տողը լավ լինի: S տողը լավ է համարվում, եթե եւ միայն եթե S- ի բոլոր կոճակները հավասարակշռված են: Օրինակ ՝ '((()) ' տողը լավ է, իսկ '()) ' տողը '()) ' չէ: Վերադարձեք 'Այո', եթե կա լավ տող պատրաստելու միջոց, եւ այլապես վերադարձեք 'Ոչ': Օրինակներ. match_parens [('() ', ') ']) == 'Այո' match_parens [(') ', ') ']) == 'Ոչ' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,hye_Armn,python,"
def maximum(arr, k):
    """"""Տված ամբողջ թվերի եւ k դրական ամբողջ թվերի շարքը, վերադարձեք k երկարության դասավորված ցուցակը arr- ի առավելագույն k թվերով: Օրինակ1: Մուտք: arr = [-3, -4, 5], k = 3 Արտադրանք: [-4, -3, 5] Օրինակ2: Մուտք: arr = [4, -4, 4], k = 2 Արտադրանք: [4, 4] Օրինակ3: Մուտք: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Արտադրանք: [2] Նշում. 1. Արի երկարությունը կլինի [1, 1000] միջակայքում: 2. Արի տարրերը կլինեն [-1000, 1000] միջակայքում: 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,hye_Armn,python,"
def solution(lst):
    """"""Տված ամբողջ թվերի ոչ դատարկ ցուցակը, վերադարձնում է բոլոր զույգ տարրերի գումարը, որոնք զույգ դիրքերում են: Օրինակներ լուծում (([5, 8, 7, 1]) ==> 12 լուծում (([3, 3, 3, 3, 3]) ==> 9 լուծում (([30, 13, 24, 321]) ==> 0 """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,hye_Armn,python,"
def add_elements(arr, k):
    """"""Տվյալ է ամբողջ թվերի ոչ դատարկ զանգված arr եւ ամբողջ թվ k, վերադարձնել տարրերի գումարը, որոնք ունեն առավելագույնը երկու թվանշան arr- ի առաջին k տարրերից: Օրինակ: Մուտք: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Արտադրանք: 24 # 21 + 3 գումարը Սահմանափակումներ: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,hye_Armn,python,"
def get_odd_collatz(n):
    """"""Տված դրական n ամբողջ թիվը, վերադարձնել կարգավորված ցուցակ, որը պարունակում է տարօրինակ թվերը կոլլազ հաջորդականությամբ: Կոլլազի ենթադրությունը մաթեմատիկայի ենթադրություն է, որը վերաբերում է հաջորդականությանը, որը սահմանված է հետեւյալ կերպ. սկսեք ցանկացած դրական n ամբողջ թվով: Այնուհետեւ յուրաքանչյուր տերմին ստացվում է նախորդ տերմինից հետեւյալ կերպ. եթե նախորդ տերմինը զույգ է, հաջորդ տերմինը նախորդ տերմինի կեսն է: Եթե նախորդ տերմինը զույգ է, հաջորդ տերմինը նախորդ տերմինի 3 անգամն է գումարած 1: Ենթադրությունը այն է, որ անկախ n-ի արժեքից, հաջորդականությունը միշտ կհասնի 1: Նշում. 1. Collatz ((1) [1]: 2. վերադարձված ցուցակը կարգավորված է աճող կարգով: Օրինակ: get_odd_collatz ((5) վերադարձնում է [1, 5] # 5 համար կոլլազի հաջորդականությունը [5, 8, 16, 4, 2, 1], այնպես որ զույգ թվերը միայն 1, եւ 5 են: """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,hye_Armn,python,"
def valid_date(date):
    """"""Դուք պետք է գրեք ֆունկցիա, որը վավերացնում է տրված ամսաթվի տող եւ վերադարձնում է True, եթե ամսաթիվը վավեր է, հակառակ դեպքում False: Տողն վավեր է, եթե բավարարված են հետեւյալ բոլոր կանոնները. 1. Տարվա տողը դատարկ չէ: 2. Օրերի թիվը ոչ պակաս է 1-ից կամ ավելի քան 31 օր ամսվա համար 1,3,5,7,8,10,12: Եվ օրերի թիվը ոչ պակաս է 1-ից կամ ավելի քան 30 օր ամսվա համար 4,6,9,11: Եվ օրերի թիվը ոչ պակաս է 1-ից կամ ավելի քան 29-ից ամսվա համար 2. 3. Ամիսները չպետք է լինեն 1-ից պակաս կամ ավելի քան 12. 4. Տարվա ձեւաչափը պետք է լինի mm-dd-yyyy օրինակ ՝ valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-04-2040') => False_valid_date (('06-04-2020') => True_valid_date (('06/04/2020') => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,hye_Armn,python,"
def split_words(txt):
    '''Տված բառերի շարքը, վերադարձնում է բառերի ցուցակը, որոնք բաժանված են սպիտակ տարածքի վրա, եթե տեքստում սպիտակ տարածք չկա, ապա պետք է բաժանվի վիկտոմայի վրա ',' եթե վիկտոմա չկա, ապա պետք է վերադարձնի այբուբենի փոքր տառերի քանակը զույգ կարգով, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 Օրինակներ split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words))'''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,hye_Armn,python,"
def is_sorted(lst):
    '''Տվյալ թվերի ցուցակ, վերադարձնել, թե արդյոք դրանք դասակարգված են աճող կարգով: Եթե ցուցակը ունի ավելի քան 1 կրկնօրինակ նույն թվից, վերադարձնել False: Ենթադրեք, որ ոչ մի բացասական թվեր եւ միայն ամբողջ թվեր: Օրինակներ is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 3, 2, 4, 5, 6, 7]) -> False is_sorted (([1, 2, 2, 3, 3, 4]) -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,hye_Armn,python,"
def intersection(interval1, interval2):
    """"""Տվյալ միջակայքը փակ է, ինչը նշանակում է, որ միջակայքը (սկսում, ավարտ) ներառում է եւ՛ սկիզբը, եւ՛ վերջը: Յուրաքանչյուր միջակայքի համար ենթադրվում է, որ դրա սկիզբը պակաս է կամ հավասար է վերջին: Ձեր խնդիրն է որոշել, թե արդյոք այս երկու միջակայքների հատման երկարությունը պարզ թիվ է: Օրինակ, միջակայքի հատման երկարությունը (1, 3), (2, 4) է (2, 3), որի երկարությունը 1, որը պարզ թիվ չէ: Եթե հատման երկարությունը պարզ թիվ է, վերադարձրեք ""Այո"", հակառակ դեպքում վերադարձրեք ""ՈՉ"": Եթե երկու միջակայքները չեն հատվում, վերադարձրեք ""ՈՉ"": [ներք / ելք] նմուշներ: հատում:""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,hye_Armn,python,"
def prod_signs(arr):
    """"""Ձեզ տրված է ամբողջ թվերի շարք եւ դուք պետք է վերադարձնեք ամբողջ թվերի մեծությունների գումարը, որը բազմապատկված է շարքի յուրաքանչյուր թվի բոլոր նշանների արտադրյալով, որը ներկայացված է 1, -1 կամ 0-ով: Նշում. վերադարձեք Ոչ մեկը դատարկ շարքի համար: Օրինակ ՝ >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Ոչ մեկը""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,hye_Armn,python,"
def minPath(grid, k):
    """"""Նշենք, որ k երկարության ուղին նշանակում է այցելել ճիշտ k բջիջներ (ոչ պարտադիր տարբեր): Դուք ՉԻ կարող դուրս գալ ցանցից: A ուղին (k երկարության) համարվում է ավելի փոքր, քան B ուղին (k երկարության), եթե A եւ B բջիջների արժեքների կարգավորված ցուցակները կազմելուց հետո (կոչենք դրանք lA_st եւ lA_st), lA_st-ը բառաբանորեն ավելի փոքր է, քան lA_st-ը: Այլ կերպ ասած, k1 = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_st = 1 , j[A_1 , j[A_1 , j[A_1, j[A_1, j[A_1, j[A_1, j[A_1, j[A_1, j[A_1, j[A_1, j[A_1, j[A_2, j_A_A_1, j[4, j_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,hye_Armn,python,"
def tri(n):
    """"""Բոլորը գիտեն Ֆիբոնաչիի հաջորդականությունը, այն խորը ուսումնասիրվել է մաթեմատիկոսների կողմից վերջին մի քանի դարերի ընթացքում: Այնուամենայնիվ, այն, ինչ մարդիկ չգիտեն, դա Տրիբոնաչիի հաջորդականությունն է: Տրիբոնաչիի հաջորդականությունը սահմանվում է կրկնվողությամբ. tri(1) = 3 tri(n) = 1 + n / 2, եթե n-ը զույգ է: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), եթե n-ը զույգ է: Օրինակ ՝ tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Ձեզ տրվում է ոչ բացասական ամբողջ թիվ n, դուք պետք է վերադարձնեք Տրիբոնաչի հաջորդականության առաջին n + 1 թվերի ցուցակը: Օրինակներ: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,hye_Armn,python,"
def digits(n):
    """"""Տված դրական ամբողջ թիվ n, վերադարձնում է տարօրինակ թվանշանների արտադրյալը: Վերադարձնում է 0 եթե բոլոր թվանշանները զույգ են: Օրինակ ՝ թվանշանները:""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,hye_Armn,python,"
def is_nested(string):
    '''Ստեղծեք ֆունկցիա, որը որպես մուտք է ընդունում տող, որը պարունակում է միայն քառակուսի կլորակներով: Ֆունկցիան պետք է վերադարձնի True, եթե եւ միայն եթե կա կլորակներով վավեր ենթախմբ, որտեղ առնվազն մեկ կլորակ է տեղադրված: is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]') â -> False is_nested '[[][]]') â -> True is_nested '[[]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,hye_Armn,python,"

def sum_squares(lst):
    """"""Ձեզ տրվում է թվերի ցուցակ: Ձեզ անհրաժեշտ է վերադարձնել տրված ցուցակի քառակուսի թվերի գումարը, նախ կլորացնել ցուցակի յուրաքանչյուր տարրը մինչեւ վերին int ((Սահմանափակ): Օրինակներ: Lst = [1,2,3] համար արտադրանքը պետք է լինի 14 Lst = [1,4,9] համար արտադրանքը պետք է լինի 98 Lst = [1,3,5,7] համար արտադրանքը պետք է լինի 84 Lst = [1.4,4.2,0] համար արտադրանքը պետք է լինի 29 Lst = [-2.4,1,1] համար արտադրանքը պետք է լինի 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,hye_Armn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Ստեղծեք ֆունկցիա, որը կվերադարձնի True, եթե տվյալ տողերի վերջին նիշը այբուբենական նիշ է եւ բառի մաս չէ, եւ False այլ կերպ: Նշում. ""Word"" -ը նիշերի խումբ է, որոնք բաժանված են տարածությամբ: Օրինակներ. check_if_last_char_is_a_letter (((""apple pie"") â -> False check_if_last_char_is_a_letter (((""apple pi e"") â -> True check_if_last_char_is_a_letter (((""apple pi e "") â -> False check_if_last_char_is_a_letter"" ((("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,hye_Armn,python,"
def can_arrange(arr):
    """"""Ստեղծել ֆունկցիա, որը վերադարձնում է տարրի ամենամեծ ինդեքսը, որը մեծ չէ կամ հավասար է անմիջապես նախորդող տարրի: Եթե նման տարր գոյություն չունի, ապա վերադարձնում է -1. Տվյալ շարքը չի պարունակում կրկնօրինակ արժեքներ: Օրինակներ: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,hye_Armn,python,"
def largest_smallest_integers(lst):
    '''Ստեղծել ֆունկցիա, որը վերադարձնում է տուպլ (a, b), որտեղ 'a' -ը բացասական ամբողջ թվերից ամենամեծն է, իսկ 'b' -ը ցուցակի դրական ամբողջ թվերից ամենափոքրը: Եթե բացասական կամ դրական ամբողջ թվեր չկան, վերադարձրեք դրանք որպես None: Օրինակներ: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,hye_Armn,python,"
def compare_one(a, b):
    """"""Ստեղծել ֆունկցիա, որը ընդունում է ամբողջական թվեր, floats կամ string-ներ, որոնք ներկայացնում են իրական թվեր, եւ վերադարձնում է ավելի մեծ փոփոխականը իր տրված փոփոխական տիպի մեջ: Վերադարձնում է None, եթե արժեքները հավասար են: Նշում. Եթե իրական թիվը ներկայացված է որպես string, ապա շարժական կետը կարող է լինել . կամ , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,hye_Armn,python,"
def is_equal_to_sum_even(n):
    """"""Գնահատեք, թե արդյոք տրված թիվը n-ը կարող է գրվել որպես ճիշտ 4 դրական զույգ թվերի գումար: Օրինակ is_equal_to_sum_even ((4) == False is_equal_to_sum_even ((6) == False is_equal_to_sum_even ((8) == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,hye_Armn,python,"
def special_factorial(n):
    """"""Բրազիլական ֆակտորիալը սահմանվում է հետեւյալ կերպ. brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! որտեղ n > 0 Օրինակ՝ >>> special_factorial(4) 288 Ֆունկցիան ամբողջական թիվ է ստանա որպես մուտք եւ պետք է վերադարձնի այդ ամբողջականի հատուկ ֆակտորիալը: """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,hye_Armn,python,"
def fix_spaces(text):
    """"""_Ներկայացում-3ստը, փոխարինեք բոլոր տարածքները ստորագրություններով, եւ եթե տողն ունի ավելի քան 2 հաջորդական տարածքներ, ապա փոխարինեք բոլոր հաջորդական տարածքները - fix_spaces ((""Օրինակ"") == ""Օրինակ"" fix_spaces ((""Օրինակ1"") == ""Օրինակ_1"" fix_spaces (((""Օրինակ2"") == ""_Օրինակ_2"" fix_spaces ((""Օրինակ 3"") == ""_Օրինակ-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,hye_Armn,python,"
def file_name_check(file_name):
    """"""Ստեղծեք ֆունկցիա, որը վերցնում է ֆայլի անվան ներկայացնող տող եւ վերադարձնում է ""Այո"", եթե ֆայլի անունը վավեր է, եւ վերադարձնում է ""Ոչ"", եթե այլապես: Ֆայլի անունը համարվում է վավեր, եթե եւ միայն եթե բավարարված են հետեւյալ բոլոր պայմանները: - Ֆայլի անվանումը չպետք է ունենա ավելի քան երեք թվանշան ('0'-'9 '): - Ֆայլի անվանումը պարունակում է ճիշտ մեկ կետ ': - Տեղի նախորդ ենթատողը չպետք է դատարկ լինի, եւ այն սկսվում է լատինական այբուբենի տառով ('a'-'z' եւ 'A'Z '): - Տեղի հաջորդ ենթատողը պետք է լինի հետեւյալներից մեկը: [' txt', 'exe', 'll' ] Օրինակներ: file_name_check""{example.txt.t"") # => 'Այո' file_name_check""{example.dll1} # => 'Ոչ' (անունը պետք է սկսվի լատինական այբուբուբենի տառով)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,hye_Armn,python,"


def sum_squares(lst):
    """""""" Այս ֆունկցիան կվերցնի ամբողջ թվերի ցուցակ: Ցուցակի բոլոր մուտքերի համար ֆունկցիան պետք է քառակուսի ամբողջ թվային մուտքը, եթե դրա ինդեքսը 3-ի բազմապատիկ է, եւ կկուբի ամբողջ թվային մուտքը, եթե դրա ինդեքսը 4-ի բազմապատիկ է, այլ ոչ թե 3-ի բազմապատիկ: Ֆունկցիան չի փոխի ցուցակի այն մուտքերը, որոնց ինդեքսները 3-ի կամ 4-ի բազմապատիկ չեն: Ֆունկցիան ապա կվերադարձնի բոլոր մուտքերի գումարը: Օրինակներ. lst = [1,2,3] համար արտադրանքը պետք է լինի 6 For lst = [] համար արտադրանքը պետք է լինի 0 For lst = [-1,-5,2,-1,-5] համար արտադրանքը պետք է լինի -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,hye_Armn,python,"
def words_in_sentence(sentence):
    """"""Ձեզ տրվում է նախադասություն ներկայացնող տող, նախադասությունը պարունակում է որոշ բառեր, որոնք բաժանված են ընդմիջումով, եւ դուք պետք է վերադարձնեք մի տող, որը պարունակում է սկզբնական նախադասության բառերը, որոնց երկարությունը պարզ թվեր են, նոր տողում բառերի կարգը պետք է նույնը լինի, ինչ սկզբնականը: Օրինակ1: Մուտք: նախադասություն = ""Սա փորձ է"" Արտադրանք: ""is"" Օրինակ2: Մուտք: նախադասություն = ""թող գնա լողալու"" Արտադրանք: ""go for"" Սահմանափակումներ: * 1 <= len(sentence) <= 100 * նախադասությունը պարունակում է միայն տառեր """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,hye_Armn,python,"
def simplify(x, n):
    """"""Ձեր խնդիրն է իրականացնել ֆունկցիա, որը պարզեցնելու է x * n արտահայտությունը: Ֆունկցիան կվերադարձնի True, եթե x * n-ը գնահատվում է ամբողջ թվով, եւ False այլ կերպ: X-ը եւ n-ը կոտորակի շարային ներկայացում են եւ ունեն հետեւյալ ձեւաչափը, <numerator>/<denominator>, որտեղ թվանշանը եւ անվանիչը դրական ամբողջ թվեր են: Դուք կարող եք ենթադրել, որ x-ը եւ n-ը վավեր կոտորակներ են, եւ անվանիչը զրո չէ: պարզեցնել "" 1/5 "", ""5/1"") = True պարզեցնել "" 1/6 "", ""2/1"") = False պարզեցնել "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,hye_Armn,python,"
def order_by_points(nums):
    """"""Գրեք ֆունկցիա, որը ամբողջ թվերի ցուցակը դասակարգում է աճող կարգով ըստ թվանշանների գումարների: Նշում. եթե կան մի քանի կետեր, որոնց թվանշանների գումարը նման է, դրանք կարգավորեք ըստ իրենց ինդեքսի սկզբնական ցուցակում: Օրինակ ՝ >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,hye_Armn,python,"
def specialFilter(nums):
    """"""Գրեք ֆունկցիա, որը որպես մուտք է ընդունում թվերի շարքը եւ վերադարձնում է շարքի տարրերի թիվը, որոնք մեծ են 10-ից եւ թվերի առաջին եւ վերջին թվանշանները զույգ են (1, 3, 5, 7, 9) ։ Օրինակ ՝ specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,hye_Armn,python,"
def get_max_triples(n):
    """"""Ձեզ տրված է դրական ամբողջ թիվ n: Դուք պետք է ստեղծեք ամբողջ թվերի շարք a երկարությամբ n: Յուրաքանչյուր i (1 ‰¤ i ‰¤ n) համար a[i] = i * i - i + 1-ի արժեքը: Վերադարձեք a-ի եռապատիկների թիվը (a[i], a[j], a[k]) որտեղ i < j < k, եւ a[i] + a[j] + a[k] -ը 3-ի բազմապատիկն է: Օրինակ: Մուտք: n = 5 Արտադրանք: 1 Հասցում: a = [1, 3, 7, 13, 21] Միակ վավեր եռապատիկն է (1, 7, 13) """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,hye_Armn,python,"
def bf(planet1, planet2):
    '''Մեր Արեգակնային համակարգում կա ութ մոլորակ. Արեգակին ամենամոտը Մերկուրին է, հաջորդը Վեներան է, ապա Երկիրը, Մարսը, Հուպիտերը, Սատուրնը, Ուրանոսը, Նեպտունը: Գրեք ֆունկցիա, որը երկու մոլորակների անուններ է վերցնում որպես տողեր՝ planet1 եւ planet2. Ֆունկցիան պետք է վերադարձնի տուփլ, որը պարունակում է բոլոր մոլորակները, որոնց ուղեծրերը գտնվում են planet1 ուղեծրի եւ planet2 ուղեծրի միջեւ, դասավորված արեւի մերձակայության հիման վրա: Ֆունկցիան պետք է վերադարձնի դատարկ տուփլ, եթե planet1 կամ planet2 մոլորակների անունները ճիշտ չեն: Օրինակներ bf ""(Ջուպիտեր"", ""Նեպտուն"") ==> (""Սատուրն"", ""Ուրանոս"") bf (((""Երկիր"", ""Մերկուրի"") ==> (""Վեներա"", ""Երկիր"", ""Մարս"", ""Ջուպիտեր"", ""Սատուրն"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,hye_Armn,python,"
def sorted_list_sum(lst):
    """"""Գրեք ֆունկցիա, որը ընդունում է տողերի ցանկը որպես պարամետր, ջնջում է տողերը, որոնք ունեն զույգ երկարություններ, եւ վերադարձնում արդյունքային ցուցակը կարգավորված կարգով: Ցանկը միշտ տողերի ցուցակ է, եւ երբեք թվերի շարք, եւ այն կարող է պարունակել կրկնօրինակներ: Ցանկի կարգը պետք է լինի բարձրանող յուրաքանչյուր բառի երկարությամբ, եւ դուք պետք է վերադարձնեք այդ կանոնով կարգավորված ցուցակը: Եթե երկու բառ նույն երկարությամբ են, ապա դասավորեք ցուցակը այբբետական կարգով: Ֆունկցիան պետք է վերադարձնի տողերի ցուցակը կարգավորված կարգով: Դուք կարող եք ենթադրել, որ բոլոր բառերը կունենան նույն երկարությունը: Օրինակ ՝ assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""aaaa"", ""aaa"", ""cd"" => ""cd ab"")""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,hye_Armn,python,"
def x_or_y(n, x, y):
    """"""Պարզ ծրագիր, որը պետք է վերադարձնի x-ի արժեքը, եթե n-ը պարզ թիվ է, եւ պետք է վերադարձնի y-ի արժեքը, եթե ոչ: Օրինակներ: x_or_y{7, 34, 12) == 34 x_or_y{15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,hye_Armn,python,"
def double_the_difference(lst):
    '''Տվյալ թվերի ցուցակ, վերադարձնում է թվերի քառակուսիների գումարները ցուցակում, որոնք զույգ են: Անտեսեք այն թվերը, որոնք բացասական են կամ ամբողջ թվեր չեն: double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Եթե մուտքագրված ցուցակը դատարկ է, վերադարձնում է 0: '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,hye_Armn,python,"
def compare(game,guess):
    """"""Կարծում եմ, որ բոլորս էլ հիշում ենք այդ զգացողությունը, երբ վերջապես հայտնի է երկար սպասված իրադարձության արդյունքը: Այդ պահին ձեր ունեցած զգացմունքներն ու մտքերը, անշուշտ, արժե նշել եւ համեմատել: Ձեր խնդիրն է որոշել, թե արդյոք մարդը ճիշտ է գուշակել մի շարք համընկնումների արդյունքները: Ձեզ տրվում է միեւնույն երկարության մի քանի ցուցանիշներ եւ գուշակություններ, որտեղ յուրաքանչյուր ցուցիչ ցույց է տալիս համընկնում: Վերադարձեք նույն երկարության մի շարք, որը ցույց է տալիս, թե որքան հեռու է յուրաքանչյուր գուշակությունը: Եթե նրանք ճիշտ են գուշակել, արժեքը 0 է, եւ եթե ոչ, արժեքը գուշակության եւ արդյունքի միջեւ բացարձակ տարբերությունն է: օրինակ: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] համեմատել [0,5,0,4],[0,4,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,hye_Armn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Դուք կստանաք դասի անվանումը (հղում) եւ ընդլայնումների ցուցակ: Ընդլայնումները պետք է օգտագործվեն դասին լրացուցիչ դասեր ներբեռնելու համար: Ընդլայնման ուժը հետեւյալն է. Թող CAP- ը լինի ընդլայնման անվանումի մեծ տառերի թիվը, եւ թող SM- ը լինի ընդլայնման անվանումի փոքր տառերի թիվը, ուժը տրվում է CAP- SM կոտորակի միջոցով: Դուք պետք է գտնեք ամենաուժեղ ընդլայնումը եւ վերադարձնեք տող այս ձեւաչափով. ClassName.StrongestExtensionName: Եթե նույն ուժով երկու կամ ավելի ընդլայնումներ կան, դուք պետք է ընտրեք այն, որը առաջինն է ցուցակում: Օրինակ, եթե ձեզ տրվում է ""Slices"" որպես դաս եւ ընդլայնումների ցուցակ. ['SEviviRNGSliCes', 'Cheese', 'StuFfed'], ապա դուք պետք է վերադարձնեք 'Slices.SEviRNGSliCes' 'SviRNGSliCes' (mySviRNGSliCes'), ուժեղագույնը (օրինակ 'AA_Be'), քանի որ ընդլայնումը 'Class_MySliClass' է: Strongest' ():""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,hye_Armn,python,"
def cycpattern_check(a , b):
    """"""Ձեզ տրված է 2 բառ: Դուք պետք է վերադարձնեք True, եթե երկրորդ բառը կամ դրա ցանկացած պտույտ առաջին բառի ենթաշարն է cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,hye_Armn,python,"
def even_odd_count(num):
    """"""Տված ամբողջական թիվը, վերադարձնում է տուպլ, որը պարունակում է համապատասխանաբար զույգ եւ անհավասար թվանշաններ: Օրինակ: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,hye_Armn,python,"
def int_to_mini_roman(number):
    """"""Տված դրական ամբողջ թիվը, ստացեք դրա հռոմեական թվային հավասարումը որպես տող եւ վերադարձրեք այն փոքր տառերով: Սահմանափակումներ: 1 <= num <= 1000 Օրինակներ: >>> int_to_mini_roman{19} == 'xix' >>> int_to_mini_roman{152} == 'clii' >>> int_to_mini_roman{426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,hye_Armn,python,"
def right_angle_triangle(a, b, c):
    '''Տված են եռանկյան երեք կողմերի երկարությունները: Վերադարձնում է True, եթե երեք կողմերը ձեւավորում են ուղղանկյուն եռանկյուն, այլապես False: Ուղիղանկյուն եռանկյունը եռանկյուն է, որի մեկ անկյունը ուղիղ անկյուն է կամ 90 աստիճան: Օրինակ: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,hye_Armn,python,"
def find_max(words):
    """"""Գրեք ֆունկցիա, որը ընդունում է տողերի ցուցակ: Ցուցակը պարունակում է տարբեր բառեր: Վերադարձեք բառը, որն ունի առավելագույն թվով եզակի նիշեր: Եթե բազմաթիվ տողեր ունեն առավելագույն թվով եզակի նիշեր, վերադարձեք այն, որը առաջինն է բառաբանական կարգով:""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,hye_Armn,python,"
def eat(number, need, remaining):
    """"""Դուք սոված նապաստակ եք, եւ դուք արդեն կերել եք որոշակի քանակությամբ գազարներ, բայց այժմ ձեզ հարկավոր է ավելի շատ գազարներ ուտել օրվա սնունդը ավարտելու համար: դուք պետք է վերադարձնեք մի շարք [համարած գազարների ընդհանուր թիվը ուտելուց հետո, գազարների քանակը, որոնք մնացել են ձեր սննդից հետո ] եթե բավարար քանակությամբ մնացած գազարներ չկան, դուք կուտեք մնացած բոլոր գազարները, բայց դեռեւս սոված կլինեք: Օրինակ: * ուտել ((5, 6, 10) -> [11, 4] * ուտել ((4, 8, 9) -> [12, 1] * ուտել ((1, 10, 10) -> [11, 0] * ուտել ((2, 11, 5) -> [7, 0] Փոփոխվողները: @number: ամբողջ թիվը գազարների քանակն է, որոնք դուք կերել եք: @need: ամբողջ թիվը գազարների քանակն է, որոնք դուք պետք է ուտեք: @remaining: ամբողջ թիվը մնացած գազարների քանակն է, որոնք գոյություն ունեն: Constrain: * 0 = <= 0 * 1000 <= 0 * 0 = <= 1000:""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,hye_Armn,python,"
def do_algebra(operator, operand):
    """"""Տված երկու ցուցակներում օպերատորն ու օպերանդը: Առաջին ցուցակում կան հիմնական ալգեբրային գործողություններ, իսկ երկրորդ ցուցակը ամբողջ թվերի ցուցակ է: Օգտագործեք երկու տրված ցուցակները ՝ ալգեբրիկ արտահայտություն կառուցելու եւ այս արտահայտության գնահատումը վերադարձնելու համար: Հիմնական ալգեբրային գործողությունները. Բարձրացում (+) Հակադարձում (-)) Հաճախում ( *) Բաժանում ( //) Բարձրացում ( **) Օրինակ: Օպերատոր['+', '*', '-'] շարքը = [2, 3, 4, 5] արդյունքը = 2 + 3 * 4 - 5 => արդյունքը = 9 Նշում. Օպերատորների ցուցակի երկարությունը հավասար է օպերատորների ցուցակի երկարությանը ՝ մեկի բացասական: Օպերատորը ոչ բացասական ամբողջ թվերի ցուցակ է: Օպերատորը ունի առնվազն մեկ օպերատոր, իսկ օպերատորը ունի առնվազն երկու օպերատոր: """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,hye_Armn,python,"
def solve(s):
    """"""Ձեզ տրվում է string s. եթե s[i]-ը տառ է, ապա փոխեք դրա case-ը ստորինից վեր կամ հակառակը, հակառակ դեպքում թողեք այն, ինչպես կա: Եթե string-ը պարունակում է ոչ մի տառ, փոխեք string-ը: Ֆունկցիան պետք է վերադարձնի արդյունքային string-ը: Օրինակներ solve(""1234"") = ""4321"" solve(""ab"") = ""AB"" solve(""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,hye_Armn,python,"
def string_to_md5(text):
    """"""Տվյալ տող 'text', վերադարձնել md5 hash հավասարազոր տողը: Եթե 'text' դատարկ տող է, վերադարձնել None: >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,hye_Armn,python,"
def generate_integers(a, b):
    """"""Տված երկու դրական ամբողջ թվեր a եւ b, վերադարձնել զույգ թվերը a եւ b-ի միջեւ, աճող կարգով: Օրինակ ՝ generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
