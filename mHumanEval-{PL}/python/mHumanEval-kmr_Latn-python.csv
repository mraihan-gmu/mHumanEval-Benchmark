task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,kmr_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Check eger di lîsteya dane ji hejmarên, e ku her du hejmarên nêzîkî hevdu ji danîn sînor.""""""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,kmr_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Input ji bo vê fonksiyonê a string ku tê de komên multiple ji parenteses nested e. armanca te ew e ku ji wan komên nav strings cuda cuda û vegera lîsteya wan. komên cuda bi hevseng (her brace vekirî bi awayekî baş girtî ye) û ne nested di nav hevdu de. ti spaces di string input bêpar e.""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,kmr_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Hejmarek hêla pozîtîf a hêla pozîtîf, dikare li ser beşek û hêla tam (hejmara herî mezin a ji hejmarê danî biçûktir) û deşmenan (beşa mayî her dem ji 1 biçûktir) were dabeşkirin.""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,kmr_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Tu lîsteya depozît û vekişandina operasyonên li ser hesabê bankê ku bi balance sifir dest pê dike. karê te ye ku ji bo tespîtkirina eger di ti xala balansa hesabê di bin sifir, û di wê xala function divê rast vegere. eger ne divê ew False vegere.""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,kmr_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Ji bo lîsteya daneya hejmarên têketinê, Mean Absolute Deviation li dora navenda vê datasetê hesab bikin. Mean Absolute Deviation di navbera her element û navenda navendê de cudahiya navîn a navîn e (di vê rewşê de navîn): MAD = average ̋ x - x_mean ̋ Mînak: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,kmr_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Di navbera her du hêmanên li hevdu yên lîsteya input de hejmarek 'delimeter' têxe `numbers' >>> intersperse (([], 4) [] >>> intersperse (([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,kmr_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Input ji bo vê fonksiyonê a string nûnertiya komên multiple bo parenteses nested veqetandin bi cih. Ji bo her yek ji komê, encam asta herî kûr ji nesting ji parenteses. mînak (() (()) heye herî zêde du asta nesting dema ku ((())) heye sê. >>> parse_nested_parens (('((()) ((())) (((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,kmr_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filter a lîsteya input ji strings tenê ji bo yên ku dihewînin dane substring >>> filter_by_substring (([], 'a') [] >>> filter_by_substring ((['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,kmr_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Ji bo lîsteya dane ya integers, tuple a ku ji jimar û hilberê hemû integers di lîsteyê de pêk tê vegerîne. Sum Empty divê wekhev be 0 û hilberê vala divê wekhev be 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,kmr_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Ji lîsteya dane ya hêmanên temam, lîsteya herî zêde ya rolling ya ku heta dema danîn di rêzê de hatiye dîtin. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,kmr_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Find palindrome herî kurt ku bi string dabîn dest pê dike. fikrê Algorithm sade ye: - Find postfix herî dirêj ji string dabîn ku palindrome e. - Add to dawiya string berovajî ji prefix string ku li ber suffix palindromic tê. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Test eger string dayîn palindrome e """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,kmr_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Input du string a û b ku tenê ji 1 û 0 pêk tê. XOR binary li ser van input û encamê jî wek string vegerînin. >>> string_xor (('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,kmr_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Ji lîsteya string, herî dirêj vegerîne. Yekemîn vegerîne di bûyera ku ji gelek stringên heman dirêjahiya. No vegerîne di bûyera ku lîsteya input vala ye. >>> herî dirêj (([]) >>> herî dirêj ((['a', 'b', 'c']) 'a' >>> herî dirêj ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,kmr_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Bigihîne mezintirîn parvekirina hevbeş a du hejmarên temam a û b >>> mezintirîn_parvekirina hevbeş ((3, 5) 1 >>> mezintirîn_parvekirina hevbeş ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,kmr_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Lîsteya hemû pêşî ji herî kurt heta herî dirêj ya string input >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,kmr_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Stranek ku hejmarên space-sînorkirî ji 0 heta n dest pê dikin. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,kmr_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Stranek dayî, bizanin ka çend karakterên cuda (ji her halî) ew ji >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 pêk tê.""""""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,kmr_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input to vê fonksiyonê a string nûnertiya notên muzîkê di formateke ASCII taybet e. karê te ye ji bo parse lîsteya string ya integer li gor gelek beats ne lihevhatî parse: 'o' note, lasts çar beats 'o, û' - nîv note, lasts du beats 'o, û - quater note, lasts yek beat >>> parse_music '. 'o . o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û o, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û, û,""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,kmr_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Çend caran bibînin ku substringek dane dikare di string orjînal de were dîtin. Dozên ser hevdû binirxînin. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,kmr_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Input a string space-sînorî yên numerals ji 'sê' ji bo 'nine'. hilbijartina Valid in 'sê', 'yek', 'du', 'three', 'çar', 'pênc', 'şê', 'heft', 'heşt' û 'nine'. string bi hejmarên ji biçûktirîn ji bo mezintirîn rêzkirî vegerîne >>> sort_numbers (('three one five') 'one three five' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,kmr_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Ji lîsteya hejmarên ku têne peyda kirin (ji dirêjahiya herî kêm du) du hilbijêre û vegerîne ku ji hev re nêzîktir in û wan bi rêzê vegerînin (hejmara piçûktir, hejmara mezin). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,kmr_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Lîsteya hejmarên (ji herî kêm du hêmanên) dane, veguherîna xetî li wê lîsteyê pêk bînin, wekî ku hejmara herî biçûk bibe 0 û ya herî mezin bibe 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,kmr_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter lîsteya dane ya ti nirxên python tenê ji bo integer >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,kmr_Latn,python,"

def strlen(string: str) -> int:
    """"""Dirêjahiya vegera string dayîn >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,kmr_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Ji bo hejmareke n, hejmara herî mezin ku n bi awayekî wekhev parçe bike, ji n piçûktir bibîne >>> largest_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,kmr_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Lîsteya faktorên sereke yên hejmareke tam ji biçûktirîn heta mezintirîn. Her faktorek divê hejmarên caran ku li gorî çend caran di faktorîzekirinê de xuya dibe, were lîstin. Hejmara têketinê divê wekhev be bi hilberîna hemû faktoran >>> faktorîze bike ((8) [2, 2, 2] >>> faktorîze bike ((25) [5, 5] >>> faktorîze bike ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,kmr_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Ji lîsteya hejmarên tam, hemû hêmanên ku zêdetir ji carekê pêk tên, jêbirin. Rêzika hêmanên çepê wek di nav xelekê de bihêlin. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,kmr_Latn,python,"

def flip_case(string: str) -> str:
    """"""Ji bo string danîn, karekterên piçûk biguherîne mezin û mezin biguherîne piçûk. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,kmr_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Concatenate lîsteya ji string nav string yek >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,kmr_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filter a lîsteya input ji string tenê ji bo yên ku bi prefix dayîn dest pê bike. >>> filter_by_prefix (([], 'a') [] >>> filter_by_prefix ((['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,kmr_Latn,python,"

def get_positive(l: list):
    """"""Bi tenê hejmarên erênî li lîsteyê vegerînin. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,kmr_Latn,python,"

def is_prime(n):
    """"""Ger hejmarek dane ye, rast e û eger ne rast e. >>> is_prime ((6) False >>> is_prime ((101) True >>> is_prime ((11) True >>> is_prime ((13441) True >>> is_prime ((61) True >>> is_prime ((4) False >>> is_prime ((1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,kmr_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs koefîsanên polinomê ne. find_zero find x wusa ku poly ((x) = 0. find_zero tenê tenê nuqteya sifir vedigere, her çiqas gelek hene jî. Ji bilî vê, find_zero tenê lîsteya xs digire ku hejmara koefîsan û herî mezin a koefîsan a ne sifir heye, ji ber ku ew çareseriyek garantî dide. >>> round ((find_zero[1, 2]), 2) # f ((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Polinomiyalê bi koefîsan xs li xala x nirxîne. vegerîne xs[0] + xs [1] * x + xs [1] * x ^ 2 + .... xs [n] * x ^ n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,kmr_Latn,python,"

def sort_third(l: list):
    """"""Ev function l lîsteyek digire û l l' vegerîne, wekî ku l' di lîsteyên ku bi sê re ne digihîje, di heman demê de nirxên wê li lîsteyên ku bi sê re digihîje, bi nirxên lîsteyên lihevhatî yên l re wekhev in, lê rêzkirin. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,kmr_Latn,python,"

def unique(l: list):
    """"""Elemên yekane yên rêzkirî li lîsteyê vegerînin >>> yekane (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,kmr_Latn,python,"

def max_element(l: list):
    """"""Di lîsteyê de herî zêde element vegerîne. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,kmr_Latn,python,"

def fizz_buzz(n: int):
    """"""Hejmara carên ku hêjmara 7 di hêjmara tam de kêmtir ji n ku ji 11 an 13 ve dabeş dibe vegerîne. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,kmr_Latn,python,"

def sort_even(l: list):
    """"""Ev function l lîsteyek digire û l l 'di l' lîsteyek wisa vedigere ku l' di lîsteyên neyeksan de wekhev e, di dema ku nirxên wê li lîsteyên hêjî wek nirxên l lîsteyên hêjî yên l in, lê rêzkirin. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,kmr_Latn,python,"

def encode_cyclic(s: str):
    """"""digire wek string input encoded bi encode_cyclic function. string decoded vedigere. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""vegerîne string encoded ji aliyê komên cycle ji sê karakterên. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,kmr_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib hejmarê n-an vedigere ku hejmarek Fibonacci ye û ew jî sereke ye. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,kmr_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero lîsteya hêjmaran wek input digire. ew rast vedigere eger sê hêmanên cuda di lîsteyê de hebin ku jimara xwe ji sifir re, û False din. >>> triples_sum_to_zero (([1, 3, 5, 0]) False >>> triples_sum_to_zero (([1, 3, -2, 1]) True >>> triples_sum_to_zero (([1, 2, 3, 7]) False >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero [1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,kmr_Latn,python,"

def car_race_collision(n: int):
    """"""Di rêya ku rêyeke bêdawî dirêj e, bi temamî rast bifikirin. n otomobîl ji çepê ve ber bi rastê ve diçin; di heman demê de, komeke n otomobîlên din ji rastê ve ber bi çepê ve diçin. Her du komên otomobîlên ku ji hev dûr in. Hemî otomobîl bi heman leza ve diçin. Du otomobîl dibêjin ku dema ku otomobîlek ku ji çepê ve ber bi rastê ve diçe otomobîleke ku ji rastê ve ber bi çepê ve diçe, li hev dikevin. Lê belê, otomobîl bêdawî xurt û xurt in; di encamê de, ew di rêya xwe de her diçin wekî ku ew li hev neketin. Ev fonksiyon hejmara van hevdîtinên wisa derdixe. """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,kmr_Latn,python,"

def incr_list(l: list):
    """"""Lîsteya vegerandinê bi hêmanên ku bi 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,kmr_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero lîsteya hêjmaran wek input digire. ew rast vedigere eger du hêmanên cuda di lîsteyê de hebin ku jimara xwe ji sifir re, û False din. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,kmr_Latn,python,"

def change_base(x: int, base: int):
    """"""Guherandina base hejmarî ya hejmara x input to base. nûnertiya string vegerandin piştî veguhastina. hejmarên base kêmtir ji 10 in. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,kmr_Latn,python,"

def triangle_area(a, h):
    """"""Bi dirêjîya aliyekî û herêma vegera bilind ya sêgoşekê. >>> sêgoşek_herêma ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,kmr_Latn,python,"

def fib4(n: int):
    """"""The Fib4 hejmar rêz a rêz e ku ji bo Fibbonacci sequence ku wek jêr hatiye diyarkirin: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Ji kerema xwe ve function ji bo bi bandor hesabkirina element n-emîn ji rêza hejmar fib4. recursion bi kar neynin. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,kmr_Latn,python,"

def median(l: list):
    """"""Mediana vegera hêmanên lîsteyê l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,kmr_Latn,python,"

def is_palindrome(text: str):
    """"""Kontrol dike ka eger string dane palindrome >>> is_palindrome (('') rast e >>> is_palindrome (('aba') rast e >>> is_palindrome (('aaaaa') rast e >>> is_palindrome (('zbcd') derew e """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,kmr_Latn,python,"

def modp(n: int, p: int):
    """"""Vegere 2 ^ n modulo p (bi hejmaran agahdar be). >>> modp ((3, 5) 3 >>> modp ((1101, 101) 2 >>> modp ((0, 101) 1 >>> modp ((3, 11) 8 >>> modp ((100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,kmr_Latn,python,"

def encode_shift(s: str):
    """"""digire wek string input encoded bi encode_shift function. string Decoded vedigere. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""vegerîne string encoded bi guherandina her karakterê ji aliyê 5 di alfabeyê de.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,kmr_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels fonksiyoneke ku string digire û string bê deng vedigere. >>> remove_vowels ((('') ' ' >>> remove_vowels ((""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels (('abcdef') 'bcdf' >>> remove_vowels (('aaaaa') ' ' >>> remove_vowels (('aaBAA') 'B' >>> remove_vowels (('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,kmr_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Return True eger hemû hejmarên li lîsteyê l bin sînorê t in. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,kmr_Latn,python,"

def add(x: int, y: int):
    """"""Add du hejmarên x û y >>> add(2, 3) 5 >>> add(5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,kmr_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Çap bike ka du peyvan heman karakter hene. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Rast >>> same_chars (('abcd', 'dddddddabc') Rast >>> same_chars (('dddddddabc', 'abcd') Rast >>> same_chars (('eabcd', 'dddddddabc') Derew >>> same_chars (('eabcd', 'dddddddabc') Derew >>> same_chars (('abcdzzzz', 'dddddddddabce') Derew >>> same_chars (('eabcdzzzz', 'dddzzzzzzdddabc') Derew """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,kmr_Latn,python,"

def fib(n: int):
    """"""Hejmara Fibonacci ya n-an vegerîne. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,kmr_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets string of ""<"" û "">"". return True eger her bracket vekirinê heye bracket girtina hevpeyman. >>> correct_bracketing ((""<"") False >>> correct_bracketing ((""<>"") True >>> correct_bracketing ((""<><>>"") True >>> correct_bracketing ((""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,kmr_Latn,python,"

def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,kmr_Latn,python,"

def common(l1: list, l2: list):
    """"""Return elementên hevbeş yekane ji bo du lîsteyên rêz kirin. >>> hevbeş (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> hevbeş (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,kmr_Latn,python,"

def largest_prime_factor(n: int):
    """"""Encama herî mezin ya n vegerîne. Bifikirin n > 1 û ne hêjmara sereke ye. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,kmr_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n fonksiyonek e ku jimarên ji 1 heta n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,kmr_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets string of ""("" and "")"". return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() "") True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,kmr_Latn,python,"

def derivative(xs: list):
    """"""xs koefîsanên polinomê nîşan dide. xs[0] + xs[1] * x + xs[2] * x^2 + .... Derivên vê polinomê di heman formê de vegerîne. >>> derivatif (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivatif (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,kmr_Latn,python,"

def fibfib(n: int):
    """"""The FibFib hejmar rêzika a rêzika wekhev ji bo Fibbonacci sequence ku bi vî awayî hatiye diyarkirin e: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Ji kerema xwe re function ji bo bi bandor hesabkirina element n-emîn ji rêzika hejmar fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,kmr_Latn,python,"
FIX = """"""Nivîseke function vowels_count ku string wek input û vedigere hejmara vowels li string. Vowels di vê rewşê de ne 'a', 'e', 'i', 'o', 'u'. li vir, 'y' jî wek vokal e, lê tenê dema ku ew di dawiya peyva dayîn e. nimûne: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Zêde bûyerên testê zêde bikin. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,kmr_Latn,python,"
def circular_shift(x, shift):
    """"""Çavê çapa çapa x, çapa çapa rastê bi çapa ve vegerînin û encamê wekî string vegerînin. Eger çapa > hejmara çapa, çapa vegerandin vegerandin. >>> circular_shift ((12, 1) ""21"" >>> circular_shift ((12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,kmr_Latn,python,"
def digitSum(s):
    """"""Task Nivîsa function ku string wek input û vegerandina sum of the characters upper tenê ' ASCII codes. mînakên: digitSum ((("""") => 0 digitSum ((""abAB"") => 131 digitSum ((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum ((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,kmr_Latn,python,"
def fruit_distribution(s,n):
    """"""Di vê wezîfeyê de, hûn dê ji bo string ku nîşan dide hejmareke apples û orange ku di basket fêkî belavkirin ev basket dihewîne apples, orange, û fêkî mango. Given string ku nîşan dide hejmara giştî ya orange û apples û integer ku hejmara giştî ya fêkî di basket vegerînin hejmara fêkî mango di basket. ji bo examble: fruit_distribution""5(apples û 6 orange"", 19) ->19 - 5 - 6 = 8 fruit_distribution""0 apples û 1 orange"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 apples û 3 orange"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 apples û 120) "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,kmr_Latn,python,"
def pluck(arr):
    """"""""Gotin array a nûnertiya şaxeke ji darek ku xwedî non-negative nodes integer karê te ye ji bo ku yek ji nodes bişkînin û vegere. The node bişkînin divê bi nirxa herî biçûk jî be. Eger multiple nodes bi heman nirxa herî biçûk jî bişkînin, wê li node ku xwedî herî biçûk index vegere. The node bişkînin divê li lîsteyê, [smallest_value, endeksa wê ], eger nirxên jî tune ne an array dane vala ye, vegere []. Mînak 1: Input: [4,2,3] Output: [2, 1] Explanation: 2 herî biçûk jî nirxê, û 2 herî biçûk index. Mînak 2: Input: [1,2,3] Output: [2, 1] Explanation: 2 herî biçûk nirxê, û 2 herî biçûk jî endeksa. Mînak 3: Input: [] Output: [4:] Input: [5, 3, 4, 2] Output: [0, 0] Output: 1 node herî biçûk jî, ku nirxa herî biçûk e, lê em dê hilbijêrin: Constraints yekem: * 10000 * nirxê zero, lê nirxê wê kêmtir e.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,kmr_Latn,python,"
def search(lst):
    '''Ji bo ku hûn li ser lîsteya hejmarên rastîn ên ne vala ne. Hejmara herî mezin a ku ji sifir mezintir e, vegerîne û bi rêjeya ku ji nirxê hejmara rastîn mezintir e an jî wekhev e. Rêjeya hejmarê rastîn hejmara caran e ku ew di lîsteyê de xuya dibe. Eger nirxek wiha tune be, vegerîne -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,kmr_Latn,python,"
def strange_sort_list(lst):
    '''Di lîsteya hejmarên tam de, lîsteya vegerandinê bi rêza ecêb. rêxistinkirina ecêb, dema ku hûn bi nirxa herî kêm dest pê dikin, paşê herî zêde ji hejmarên hêjmarên mayîn, paşê herî kêm û hwd. Mînak: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,kmr_Latn,python,"
def triangle_area(a, b, c):
    '''Bi dirêjahiya sê aliyên sêgoşeyekê. Eger sê aliyên sêgoşeyekê rast bikin, rûbera sêgoşeya ku ji 2 xalên desimalî re hatiye dorpêçkirin vegerînin. Wekî din vegerînin -1 Sê aliyên sêgoşeya rast dikin dema ku jimara her du aliyan ji aliyê sêyemîn mezintir e. Mînak: sêgoşe_areya ((3, 4, 5) == 6.00 sêgoşe_areya ((1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,kmr_Latn,python,"
def will_it_fly(q,w):
    '''Fonksiyonek binivîse ku rast e eger ku object q dê bifirîne, û False din. The object q dê bifirîne eger ku ew balance (e ku lîsteya palindromic) û jimara ji elementên xwe kêmtir e ji an wekhev e herî zêde weight pêkan w. Mînak: will_it_fly (([1, 2], 5) â -> False # 1+2 kêmtir e ji herî zêde weight pêkan e, lê ew unbalanced e. will_it_fly (([3, 2, 3], 1) â -> False # ew balance, lê 3+2+3 zêdetir e ji herî zêde weight pêkan e. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 kêmtir e ji herî zêde weight pêkan e, û ew balance. will_it_fly ((([3], â 5) -> True # 3 kêmtir e ji herî zêde weight pêkan e, û ew balance '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,kmr_Latn,python,"
def smallest_change(arr):
    """"""Di nav arrayê de hejmarên tam, hejmara herî kêm ya hêmanên ku divê bên guhertin bibînin da ku array palindromîk be. arrayek palindromîk a ku li paş û pêş eynî tê xwendin e. Di guhertinekê de, hûn dikarin elementek ji bo her elementek din biguherînin.""""""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,kmr_Latn,python,"
def total_match(lst1, lst2):
    '''Nivîseke function ku du lîsteyên ji strings qebûl û lîsteya ku hejmara giştî ya chars di hemû strings ji lîsteya kêmtir ji lîsteya din. eger her du lîsteyên bi heman hejmara chars, vegere lîsteya yekem. nimûne total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,kmr_Latn,python,"
def is_multiply_prime(a):
    """"""Fonksiyonek binivîse ku eger hejmara ku hatiye dayîn, pirsa 3 hejmarên sereke ye û bi awayekî din derew e.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,kmr_Latn,python,"
def is_simple_power(x, n):
    """"""Karê te ew e ku fonksiyonek binivîse ku rast e eger hejmarek x hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza hêza)""""""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,kmr_Latn,python,"
def iscube(a):
    '''Fonksiyonek binivîse ku hejmarek a digire û rast vedigere eger ev ingeger kûpeke hejmarek tam be. Têbînî: hûn dikarin texmîn bikin ku têgihiştin herdem rast e. Mînak: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,kmr_Latn,python,"
def hex_key(num):
    """"""Hûn hatine erkdar kirin ku fonksiyonek binivîsin ku hejmarek hexadecimal wek string bistîne û hejmara hejmarên hexadecimal ku sereke ne (hejmara sereke, an jî sereke, hejmarek xwezayî ye ku ji 1 mezintir e ku ne hilberîna du hejmarên xwezayî yên biçûktir e). Hejmarên hexadecimal 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F in. Hejmarên sereke 2, 3, 5, 7, 11, 13, 17 in,... Ji ber vê yekê hûn divê hejmarek ji van hejmarên jêrîn diyar bikin: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13). Têbînî: hûn dikarin texmîn bikin ku têketin her tim rast e an vala ye, û sembolên A,B,C,D,E,F her tim mezin in. Mînak: Ji bo num ""AB"" divê encam num = 1. Ji bo num ""1077E"" encam divê 2. Ji bo num ""AB"" divê num = 1.33AED be 4. Ji bo num = ""ABC"" divê num = 6.01234567D. Ji bo num ""A"" divê encam be 2.2020 EF""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,kmr_Latn,python,"
def decimal_to_binary(decimal):
    """"""Ev function divê ji bo veguhertina a string, bi her karakterê ku nûnertiya a number binary. Her karakterê di string dê '0' an '1 '. wê bibe a extra du karakterên 'db' li destpêkê û di dawiya string. karakterên extra li wir in ji bo alîkarîya bi format.""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,kmr_Latn,python,"
def is_happy(s):
    """"""We string s dan. Erka we ew e ku hûn kontrol bikin ka string kêfxweş e an na. Stran kêfxweş e eger dirêjahiya wê herî kêm 3 e û her 3 tîpên li pey hev cuda ne.""""""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,kmr_Latn,python,"
def numerical_letter_grade(grades):
    """"""Ev e hefteya dawî ya semestrê û mamosteyê heye ji bo ku notên ji bo xwendekaran. mamosteyê hatiye ku algoritma xwe ji bo grading. bi tenê pirsgirêka ew e, ku ew ji kodê ku ew ji bo grading bikaranîn winda kiriye. ew ji we re lîsteya GPA ji bo hin xwendekarên da û hûn ji bo nivîsandina function ku dikare lîsteya notên nameyê bi bikaranîna li jêr table encam dane: GPA. grade Letter 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,kmr_Latn,python,"
def prime_length(string):
    """"""Fonksiyonek binivîse ku stringekê digire û rast vedigere eger dirêjahiya string hejmarek sereke be an jî derew be.""""""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,kmr_Latn,python,"
def starts_one_ends(n):
    """"""Given a integer erênî n, vegerandina hejmara hejmara integer erênî n-digit ku dest pê bike an dawî bi 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,kmr_Latn,python,"
def solve(N):
    """"""Ji bo hejmareke tam pozîtîf N, jimara giştî ya dîjîtan xwe di binary de vegerîne. Mînak Ji bo N = 1000, jimara dîjîtan wê bibe 1 encam divê ""1"". Ji bo N = 150, jimara dîjîtan wê bibe 6 encam divê ""110"". Ji bo N = 147, jimara dîjîtan wê bibe 12 encam divê ""1100"". Variables: @N integer Constraints: 0 â‰¤ N â‰¤ 10000. Output: a string of binary number """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,kmr_Latn,python,"
def add(lst):
    """"""Ji lîsteya ne-çerxa ya hejmarên temam lst. hêmanên hê jî ku di endeksên neyênî de ne.""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,kmr_Latn,python,"
def anti_shuffle(s):
    """"""Nivîsa function ku string digire û vegerîne a guhertoya rêzkirî ji wê. guhertoya rêzkirî ji string, a string ku hemû peyvên (bi cihê veqetandî) bi peyvek nû ku hemû karakterên bi rêzê bilind li ser bingeha ascii nirxa bi cih tên. Note: Divê hûn rêzê ji peyv û space vala di hevoka. ji bo nimûne: anti_shuffle ((('Hi') vegerîne 'Hi' anti_shuffle (('hello') vegerîne 'ehllo' anti_shuffle (('Hello World!!!') vegerîne 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,kmr_Latn,python,"
def get_row(lst, x):
    """"""Tu bi daneyên 2 dimensional, wek lîsteyên nested, ku mîna matrix, lê belê, berevajî matris, her rêz dikare hejmareke cuda yên columns. lst, û integer x dayîn, li lîsteyê de, û lîsteya vegera tuples, [(x1, y1), (x2, y2) ...) dîtina integer x, wek ku her tuple a koordinatên - (row, columns), dest bi 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,kmr_Latn,python,"
def sort_array(array):
    """"""Di nav array a hejmarên ne-negatîf de, kopiyek ji arrayê dayîn vegerîne piştî rêzkirinê, hûn ê arrayê dayîn bi rêza bilindbûnê rêzkirin, eger jimara (( nirxa endeksê ya yekem, nirxa endeksê ya dawî) neyek e, an jî rêzkirinê bi rêza dakêşandinê rêzkirin, eger jimara (( nirxa endeksê ya yekem, nirxa endeksê ya dawî) jî e. Têbînî: * arrayê dayîn neguhere. Mînak: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 6]  0""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,kmr_Latn,python,"
def encrypt(s):
    """"""Create a function encrypt that takes a string as an argument and returns a string encrypted with the alphabet being rotated. Alphabet divê bi awayekî ku tîpên bi du bi du cihên biherike. ji bo nimûne: encrypt (('hi') vegerîne 'lm' encrypt (('asdfghjkl') vegerîne 'ewhjklnop' encrypt (('gf') vegerîne 'kj' encrypt (('et') vegerîne 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,kmr_Latn,python,"
def next_smallest(lst):
    """"""Hûn lîsteya hejmarên tam tê dayîn. Fonksiyonek next_smallest binivîse ku hêmana duyemîn a lîsteyê vedigere. Eger hêmanek wiha tune be, None vedigere. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,kmr_Latn,python,"
def is_bored(S):
    """"""We dê rêzek peyvan bide, û erkê we ew e ku hejmara bêzarbûnê bihesibînin. Bêzarbûn hevokek e ku bi peyva ""I"" dest pê dike. hevok bi '.', '?' an '! ' têne sînorkirin. Mînak: >>> is_bored ((""hello world"") 0 >>> is_bored ((""Ezman şîn e. Roj diherike. Ez hez ji vê hewayê dikim"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,kmr_Latn,python,"
def any_int(x, y, z):
    '''Fonksiyonek ku 3 hejmarên digire biafirîne. Ger ku yek ji hejmarên wekhev be bi jimara du yên din, û hemû hejmarên tam in. Di her rewşeke din de derew vedigere. Mînakên her_int ((5, 2, 7) â -> True her_int ((3, 2, 2) â -> False her_int ((3, -2, 1) â -> True her_int ((3.6, -2.2, 2) â -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,kmr_Latn,python,"
def encode(message):
    """"""Nivîseke ku function take a message, û encodes bi awayekî ku ew swaps case ji hemû tîpan, şûna hemû vokalên di peyamê bi tîpa ku xuya 2 cîhên li pêş ku vokal di alfabeya english. tenê tîpan de bifikirin. mînak: >>> encode (('test') 'TGST' >>> encode (('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,kmr_Latn,python,"

def skjkasdkd(lst):
    """"""Ji bo lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] encam divê 10 ji bo lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] encam divê 25 ji bo lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] encam divê 13 ji bo lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] encam divê 11 ji bo lst = [0,81,12,31,21] encam divê 3 ji bo lst = [1,8,1,2,1,7] encam divê 7 ji bo lst = [1,8,1,2,7] encam divê 7 ji bo lst = [1,1,2,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,kmr_Latn,python,"
def check_dict_case(dict):
    """"""Ji ber ku ferhengek, eger hemû kilîtan di nav tîpên biçûk de bin an hemû kilîtan di nav tîpên mezin de bin, eger ne wisa be, vegerîne False. Fonksiyon divê vegerîne False eger ferhengê dayî vala be. Mînak: check_dict_case{""a"":""apple"", ""b"":""banana""}) divê vegerîne True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) divê vegerîne False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) divê vegerîne False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) False divê vegerîne. check_dict_case{""NC"":""STATE"", ""Z"":""IP""12345}) divê vegerîne True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,kmr_Latn,python,"
def count_up_to(n):
    """"""Fonksiyonek pêk bîne ku hejmarek ne-negatîf digire û arrayek ji n hejmarên pêşîn ên ku hejmarên sereke ne û kêmtir ji n vegerîne. wek nimûne: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,kmr_Latn,python,"
def multiply(a, b):
    """"""Function ku du integers digire û berhemê ji sifrên yekîneya xwe vedigere. Misoger input her dem derbasdar e. Mînak: multiply ((148, 412) divê 16. multiply ((19, 28) divê 72. multiply ((2020, 1851) divê 0. multiply ((14,-15) divê 20. vegere.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,kmr_Latn,python,"
def count_upper(s):
    """"""Ji bo string s, hejmara dengên mezin ên dengên mezin li endeksên jî. Mînak: count_upper (('aBCdEf') vedigere 1 count_upper (('abcdefg') vedigere 0 count_upper (('dBBE') vedigere 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,kmr_Latn,python,"
def closest_integer(value):
    '''Create a function that takes a value (string) representing a number and returns the closest integer to it. Eger hejmar e equidistant ji du integer, ew dûr ji zero. Mînakên >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Nîşe: Rounding dûr ji zero tê wateya ku eger hejmara dayîn e equidistant ji du integer, yê ku divê hûn vegerin e ku ew e ku dûr ji zero. Ji bo Exampleclose_integer "" ((14.5"") divê 15 vegere û closest_integer "" ((-14.5"") divê -15. vegere. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,kmr_Latn,python,"
def make_a_pile(n):
    """"""Ji bo ku hejmarek pozîtîf n, divê hûn pileya n astên keviran çêbikin. Asta yekem n kevir hene. Hejmara keviran di asta din de ev e: - hejmara bêhempa ya pêşîn eger n nehempa be. - hejmara hevaheng ya pêşîn eger n hevaheng be. Hejmara keviran li her astekê di lîsteyê de vegerîne, ku element li endeks i hejmara keviran di asta (i + 1) de nîşan dide. Mînak: >>> make_a_pile ((3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,kmr_Latn,python,"
def words_string(s):
    """"""Tu dê ji bo string peyvên bi commas an space veqetandin dayîn. erkê te ye ji bo parvekirina string nav peyvên û vegera array ji peyvên. ji bo nimûne: words_string ((""Hi, navê min John e"") == [""Hi"", ""min"", ""name"", ""e"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,kmr_Latn,python,"
def choose_num(x, y):
    """"""Ev function digire du hejmarên erênî x û y û vegerîne herî mezin jî integer hejmara ku di range [x, y] tevlî ye. Eger ku hejmareke wiha tune ye, hingê function divê vegere -1.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,kmr_Latn,python,"
def rounded_avg(n, m):
    """"""Ji bo ku hûn ji hêla n ve bi rêjeya n ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya n ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m ve bi rêjeya m bi rêjeya m ve bi rêjeya m bi rêjeya m bi rêjeya m.""""""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,kmr_Latn,python,"
def unique_digits(x):
    """"""Ji ber ku lîsteya hejmarên pozîtîf x. lîsteya rêzkirinê ya hemû hêmanên ku tu hêmanên hêman tune ne. Têbînî: Lîsteya vegerandî divê bi rêza bilindbûnê were rêzkirin. Mînak: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,kmr_Latn,python,"
def by_length(arr):
    """"""Di nav array of integer, rêzkirina integerên ku di navbera 1 û 9 de ne, rêza encamê vegerînin, û piştre her hejmar bi navê xwe ya li ser ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"" ve vegerînin. Ji bo nimûne: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> rêzê li arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> rêzê li arr -> [8, 5, 4, 3, 2, 2, 1, 1] vegerînin [""Eight"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""] Heke rêzê vala be, rêzê vegerînin: arr = [] vegerînin [] Heke rêzê hejmarek ecêb hebe, wê bêdeng bikin: arr = [1, -1 , 55] -> arr -> [1, 1], 55 -> arr -> [55, 1] - vegerînin ['One'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,kmr_Latn,python,"
def f(n):
    """"""Fonksiyona f ku n wek parameter digire, pêk bîne û lîsteya mezinbûna n vedigere, wekî ku nirxa hêmana li endeksê i faktoriyê i ye eger i jî an jî jimara hejmarên ji 1 heta i be. i ji 1. factoriyê i ji 1 heta i (1 * 2 * ... * i) pirkirî ye. Mînak: f ((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,kmr_Latn,python,"
def even_odd_palindrome(n):
    """"""Ji ber ku hejmarek pozîtîf n, tupleyek vegerîne ku hejmara palindromên hê û hêjî yên hêjî yên ku di nav rêza ((1, n) de ne. Mînak1: Input: 3 Output: (1, 2) Agahdarî: Palindromên hêjî 1, 2, 3. yek ji wan hêj e, û du ji wan hêj in. Mînak2: Input: 12 Output: (4, 6) Agahdarî: Palindromên hêjî 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. çar ji wan hêj in, û 6 ji wan hêj in. Têbînî: 1. 1 <= n <= 10 ^ 3 2. tuple hejmara palindromên hêjî û hêjî vegerand. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,kmr_Latn,python,"
def count_nums(arr):
    """"""Nivîseke function count_nums ku array of integer digire û hejmara hêmanên ku sum of digits > 0 e vedigere. Eger hejmarek neyînî be, wê demê yekemîn dîjîta wê ya îmzeyê dê neyînî be: mînak -123 xwedî dîjîta îmzeyê -1, 2, û 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,kmr_Latn,python,"
def move_one_ball(arr):
    """"""Em xwedî array 'arr' ji N integer arr[1], arr[2], ..., arr[N].Hejmarên di array dê bi awayekî rastîn rêz kirin. karê te ye ku bizanin ka gelo ew mimkun e ku array bi rêza ne-kêmkirinê bi rêya pêkanîna operasyona jêrîn li ser arrayê dayîn: Hûn dikarin operasyona guhastina rastê bikin. Operasyona guhastina rastê yek tê wateya guhastina hemû hêmanên arrayê bi yek helwestê di rêza rastê de. Heke hêmana dawî ya arrayê dê ji bo helwesta destpêkê di arrayê de were veguhestin ango 0th. Heke ku mimkun e ku arrayê rêz kirin bi pêkanîna operasyona jorîn vegere True wê demê din vegere False. Heke ku arrayê dayîn vala be wê demê vegere True. Têbînî: Lîsteya dayîn garantî ye ku hêmanên yekane hene. Ji bo nimûne: move_one_(ball[3, 4, 5, 2== 1, 2>>>) Çavdêriya rast: Bi perforasyon: Bi 2 min operasyonên rastê, rêza ne-kêmkirinê dikare ji bo arrayê were bidestandin. [3, 4,===== 1, 2, 5, ===> Ji bo operasyonên guhastandinê ne mimkun e ji bo pêkan e ku rêza guhastê ji bo operasyonên rêzêve vegere.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,kmr_Latn,python,"
def exchange(lst1, lst2):
    """"""Di vê pirsgirêkê de, hûn dê fonksiyonek pêk bînin ku du lîsteyên hejmarên digire, û diyar dike ka gelo pêkan e ku di navbera wan de guhertinên hêman pêk bînin da ku lst1 lîsteya tenê hejmarên hêman be. Li ser hejmara hêmanên di navbera lst1 û lst2 de tên guhertin sînor tune ye. Heke pêkan e ku di navbera lst1 û lst2 de hêmanên guhertin bikin da ku hemû hêmanên lst1 hêman bin, vegerin ""Erê"". Wekî din, vegerin ""Na"". Mînak: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""Erê"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""Na"" Tê texmîn kirin ku lîsteyên têketinê dê ne vala bin. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,kmr_Latn,python,"
def histogram(test):
    """"""Ji bo ku string a ku ji hêla xeta veqetandî ya xeta piçûk ve têne veqetandin, vegerînin peyvek ji tîpa ku bi piraniya dubareyê ve têne vegerandin û hejmara têkildar. Eger çend tîpên heman carê hebin, hemî wan vegerînin. Mînak: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a b') == {'b 4}: histogram ' ((') == {} } """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,kmr_Latn,python,"
def reverse_delete(s,c):
    """"""Ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku ji bo ku tu ji bo ku tu ji bo ku tu ji bo ku ji bo ku tu ji bo ku tu ji bo ku ji bo ku tu ji bo ku ji bo ku tu ji bo ku ji bo ku tu ji bo ku ji bo ku ji bo ku tu ji bo ku ji bo ku ji bo ku tu ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku tu ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji bo ku ji""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,kmr_Latn,python,"
def odd_count(lst):
    """"""Di lîsteya string, ku her string ji tenê hejmarên pêk tê, lîsteyek vegerîne. Her element i ji encam divê ""hejmara hêmanên bêhempa di string i ji input. "" ku hemû i's divê bi hejmara hêmanên bêhempa di string i'th ji input. >>> odd_count['1234567']) [""hejmara hêmanên bêhempa 4n str4ng 4 ji 4nput.""] >>> odd_count['3',""111111""]) [""hejmara hêmanên bêhempa 1n str1ng 1 ji 1nput. "", ""hejmara hêmanên bêhempa 8n str8ng 8 ji 8nput. ""]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,kmr_Latn,python,"
def minSubArraySum(nums):
    """"""Bi dîtina array of integer nums, jimara herî kêm ya her sub-array non-empty of nums bibîne. Mînak minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,kmr_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Tu bi awayekî rastgoyî grid ji wells dayîn. Her rêz yek wells nûnertiya, û her 1 di rêz de yek yekîneyeke avê nûnertiya. Her wells heye bucket hevbeş ku dikare ji bo avê ji wê derxistin, û hemû buckets xwedî kapasîteya heman. karê te ye ku bi kar buckets bo vala buckets. Output hejmara caran ku hûn hewce ne ji bo kêmkirina buckets.""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,kmr_Latn,python,"
def sort_array(arr):
    """"""Di vê Kata de, divê hûn rêjeya hejmarên ne-negatîf li gor hejmara yekên di nûnertiya binary wan de bi rêjeya bilindbûnê rêz bikin. Ji bo hejmara yekên wekhev, rêjeya li gorî nirxa dehane. Divê wiha bê pêkanîn: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,kmr_Latn,python,"
def select_words(s, n):
    """"""Ji ber string s û hejmareke xwezayî n, we bi kar anîn ku fonksiyonek ku lîsteya hemû peyvên ji string s ku tê de tam n hevokên, da ku van peyvan di string s xuya bike. Eger string s vala ye, wê demê fonksiyonê divê lîsteya vala vegere. Têbînî: hûn dikarin texmîn bikin ku string input tenê tîp û cihên. Mînak: select_words ((""Mary hebû lamb biçûk"", 4) ==> [""çûk""] select_words ((""Mary hebû lamb biçûk"", 3) ==> [""Mary"", ""lamb""] select_words"" (((simple space spî"", 2) ==> [] select_words ((""hello world"", 4) ==> [""world""] select_words ((""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,kmr_Latn,python,"
def get_closest_vowel(word):
    """"""Tu bi peyvekê. erkê te ye ku ji bo dîtina herî nêzîk vocal ku di navbera du hevokên ji aliyê rastê ji peyvê (case hesas) radiweste. vocal li destpêkê û dawiya ne. Return string vala eger tu ti vocal li gor şertê li jor dîtin. Hûn dikarin bawer bikin ku string dayîn tenê tîpa English heye.""""""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,kmr_Latn,python,"
def match_parens(lst):
    '''Ji bo ku hûn li ser lîsteya du stringên ku ji parênseyên vekirî '(' an parênseyên girtî ') ' pêk tê. Karê we ew e ku hûn bibînin ku eger ew her du stringên bi rêbazekê ve girêdayî be, ku string encam dê baş be. Stranek S tê hesibandin ku eger û tenê eger hemû parênseyên di S de hevseng bin. Mînak: string '((()) ' baş e, lê string '()) ' ne. Eger rêbazek baş çêbikin, vegerin 'Erê' û eger ne wisa be, vegerin 'Na'. Mînak: match_parens[('() ', ') ']) == 'Erê' match_parens[(') ', ') ']) == 'Na' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,kmr_Latn,python,"
def maximum(arr, k):
    """"""Given a array of integer û a integer k erênî, vegerîne a lîsteya rêzkirinê ya length k bi herî zêde k hejmarên li arr. Example1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Example2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Example3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Note: 1. length of the array will be in the range of [1, 1000]. 2. the elements in the array will be in the range of [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,kmr_Latn,python,"
def solution(lst):
    """"""Ji ber ku lîsteya ne-çerxa ya hêmanên tam, jimara hemî hêmanên neyeksan vegerîne ku di helwesta hevpar de ne.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,kmr_Latn,python,"
def add_elements(arr, k):
    """"""Bi dîtina array non-biçûk ji integer arr û integer k, vegerîne sum of the elements with at most two digits from the first k elements of arr. Mînak: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,kmr_Latn,python,"
def get_odd_collatz(n):
    """"""Bi hejmara pozîtîf n, lîsteya rêzkirinê ya ku hejmara neyênî di rêza collatz de heye, vegerîne. Têbînîya Collatz têbînîyek di matematîkê de ye ku têkildarî rêzeyek wiha tê diyarkirin: bi her hejmara neyênî ya n dest pê bike. Hingê her term ji termê berê wiha tê wergirtin: eger termê berê jî hevseng be, termê din nîvê termê berê ye. Heke termê berê jî neyênî be, termê din 3 carî termê berê ye plus 1. Têbînî ye ku çiqas nirxê n be jî, rêze her tim dê bigihêje 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,kmr_Latn,python,"
def valid_date(date):
    """"""Tu xwedî ku function ku validates a string date dan û vegerîne True eger ku date derbasdar e, eger ne wisa False. The date derbasdar e, eger ku hemû yên ji rêzikên jêrîn têr: 1. string date ne vala ye. 2. hejmara rojên ne kêmtir ji 1 an jî zêdetir ji 31 rojan ji bo mehên 1,3,5,7,8,10,12. û hejmara rojên ne kêmtir ji 1 an jî zêdetir ji 30 rojan ji bo mehên 4,6,9,11. û, hejmara rojên ne kêmtir ji 1 an jî zêdetir ji 29 ji bo mehê 2. 3. mehên divê ne kêmtir ji 1 an jî zêdetir ji 12. 4. date divê di format: mm-dd-yyyy be ji bo nimûne: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-02040') => False_valid_date (('06-04-2020') => True_valid_date (('06/04/2020') => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,kmr_Latn,python,"
def split_words(txt):
    '''Given a string of words, return a list of words split on whitespace, eger tu whitespaces di text de heye divê hûn li ser commas ',' eger tu commas heye divê hûn li ser hejmara tîpên biçûk-case bi rêzê odd di alfabeyê, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 nimûneyan vegerînin split_words ((""hello world!"") â -> [""hello"", ""world!""] split_words ((""hello,world!"") â -> [""hello"", ""world!"" split_words"" ((abcdef"")) == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,kmr_Latn,python,"
def is_sorted(lst):
    '''Lîsteya hejmarên ku tê dayîn, vegerin ka ew bi rêzê ve tên rêzkirin an na. Heke lîsteyê ji 1 dubleya heman hejmarê zêdetir hebe, vegerin False. Bêjimarên neyînî û tenê hêjmaran. Mînakên is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,kmr_Latn,python,"
def intersection(interval1, interval2):
    """"""Du demên ku her dem parek ji hêjmaran e. Mînak, demên = (destpêk, dawiya) = (1, 2). demên dayîn girtî ne ku tê wateya ku demên (destpêk, dawiya) hem dest û hem dawiya. Ji bo her demên dayîn, tê texmînkirin ku destpêka wê kêmtir e an jî wekhev e dawiya xwe. erkê te ye ku diyar bike ka dirêjbûna hevçerxa wan du demên hejmareke sereke ye. Mînak, hevçerxa demên (1, 3), (2, 4) (2, 3) e ku dirêjahiya wê 1, ku hejmareke sereke ne. Eger dirêjahiya hevçerxa hejmarek sereke ye, vegerîne ""Erê"", eger ne, vegerîne ""Na"". Eger her du demên ne hevçerxa, vegerîne ""Na"". [input / output] nimûneyên: hevçerxa (((1, 2), (2, 3) ==> ""<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,kmr_Latn,python,"
def prod_signs(arr):
    """"""Tu bi array arr ji integer dan û hûn divê ji bo vegera sum of mezintirî yên integer bi berhemên ji hemû nîşanên her hejmarê di array, bi 1, -1 an 0. Nûnertiya: vegera None ji bo arr vala.""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,kmr_Latn,python,"
def minPath(grid, k):
    """"""Ji ber ku grid bi rêzên N û kolanên N (N > = 2) û k a integer pozîtîf, her hucreya gridê nirxek dihewîne. Her integer di rêza [1, N * N] de yekser yekser li hucreyên gridê xuya dibe. Hûn divê rêya herî kêm a dirêjahiya k di gridê de bibînin. Hûn dikarin ji her hucreyekê dest pê bikin, û di her gavê de hûn dikarin ji bo hucreyên cîran vegerin, bi gotineke din, hûn dikarin ji hucreyên ku bi hucreya niha re li ser xêzeke hev re parve bikin. Ji kerema xwe ve têbînî bikin ku rêya dirêjahiya k tê wateya serdana k hucreyan (ne hewce ne ku cuda be). Hûn nikarin ji gridê derkevin. A rêya A (ji dirêjahiya k) ji rêya B (ji dirêjahiya k) kêmtir tê hesibandin, eger piştî çêkirina lîsteyên rêkûpêk ên nirxên li hucreyên ku A û B derbas dikin (em wan bi lA_st û lA_st bibêrin), lA_st_st_B), lA_st_A ye lexically kêmtir ji l_st_B_B_, bi gotineke din, di l_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A_A""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,kmr_Latn,python,"
def tri(n):
    """"""Her kes dizane ku rêzika Fibonacci, ew di nav çend sedsalên dawî de ji aliyê matematîkvanan ve bi kûrî hat xwendin. Lê belê, tiştê ku mirov nizane rêzika Tribonacci ye. Rêzika Tribonacci bi dûbarebûna: tri(1) = 3 tri(n) = 1 + n / 2, eger n jî e. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), eger n jî neyek e. Bo nimûne: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Hûn hejmarek ne-negatîf n dane, hûn divê lîsteya yekem n + 1 hejmarên rêzika Tribonacci vegerînin. Mînak: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,kmr_Latn,python,"
def digits(n):
    """"""Ji bo hejmarek pozîtîf n, hilberê hêjmara hêjmaran vegerîne. 0 vegerîne eger hemû hêjmaran jî hevbeş bin. Mînak: hêjmaran ((1) == 1 hêjmaran ((4) == 0 hêjmaran ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,kmr_Latn,python,"
def is_nested(string):
    '''Create a function that takes a string as input which contains only square brackets. The function should return True if and only if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested. is_nested'[[]]') â -> True is_nested'[[]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]'[[]]]]]] â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,kmr_Latn,python,"

def sum_squares(lst):
    """"""Tu lîsteya hejmarên. Tu divê ji bo vegera sum of hejmarên square li lîsteya dayîn, li ser her element li lîsteyê de li ser bilindtirîn int ((Ceiling) pêşî. mînakên: Ji bo lst = [1,2,3] encam divê 14 Ji bo lst = [1,4,9] encam divê 98 Ji bo lst = [1,3,5,7] encam divê 84 Ji bo lst = [1.4,4.2,0] encam divê 29 Ji bo lst = [-2.4,1,1] encam divê 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,kmr_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Fonksiyonek biafirîne ku rast vegerîne eger tîpa dawî ya stringek dane tîpa alfabeyê ye û beşek ji peyvekê ne, û bi awayekî din derew e. Têbînî: ""peyv"" komek tîpan e ku bi cihê veqetandî ye. Mînak: check_if_last_char_is_a_letter ((""piê apple"") â -> False check_if_last_char_is_a_letter ((""apple pi e"") â -> True check_if_last_char_is_a_letter ((""apple pi e "") â -> False check_if_last_char_is_a_letter"" (("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,kmr_Latn,python,"
def can_arrange(arr):
    """"""Create a function ku herî mezin index ji element ku ne mezintir e ji an jî wekhev bi element rasterast berî wê ye. Eger elementeke wiha tune ye, paşê vegere -1. array dayîn dê nirxên dubare ne. nimûne: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,kmr_Latn,python,"
def largest_smallest_integers(lst):
    '''Fonksiyonek ku tuple (a, b) vedigere biafirîne, ku 'a' mezintirîn hejmara tevahî ya neyînî ye, û 'b' hejmara herî biçûk ya tevahî ya erênî ye di lîsteyê de. Heke hejmara tevahî ya neyînî an erênî tune be, ew wek None vedigerin. Mînak: mezintirîn_tehtirîn_tehtirîn[2, 4, 1, 3, 5, 7]) == (None, 1) mezintirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtirîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn_tehtîn) == (None, None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,kmr_Latn,python,"
def compare_one(a, b):
    """"""Fonksiyonek çêbikin ku hejmarên rastîn, floats, an stringên nûnertiya hejmarên rastîn digire û guherbarên mezintir li type guherbarên xwe yên dayîn vedigere. Eger nirxên wekhev bin, None vedigere. Têbînî: Eger hejmarek rastîn wek stringek tê nîşandan, xala guherbar dikare bibe . an jî , compare_one ((1, 2.5) â -> 2.5 compare_one ((1, ""2,3"") â -> ""2,3"" compare_one ((5,1"", ""6"") â -> ""6"" compare_one ((1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,kmr_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Nirxîne ka hejmara n dikare wekî jimara 4 hejmarên pozîtîf ên rastîn were nivîsandin. Mînak is_equal_to_sum_even ((4) == False is_equal_to_sum_even ((6) == False is_equal_to_sum_even ((8) == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,kmr_Latn,python,"
def special_factorial(n):
    """"""The factorial Brazilian wek hatiye diyarkirin: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! ku n > 0 Bo nimûne: >>> special_factorial ((4) 288 The function dê wek input integer bistînin û divê factorial taybet ji vê integer vegere. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,kmr_Latn,python,"
def fix_spaces(text):
    """"""_Mînak-3tring, hemû cihên di wê bi undercores, û eger string zêdetir ji 2 cihên li pey hev, hingê hemû cihên li pey hev bi - fix_spaces ((""Mînak"") == ""Mînak"" fix_spaces ((""Mînak1"") == ""Mînak_1"" fix_spaces ((""Mînak2"") == ""_Mînak_2"" fix_spaces ((""Mînak 3"") == ""_Mînak-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,kmr_Latn,python,"
def file_name_check(file_name):
    """"""Create a function ku string nûnertiya name a file ya digire, û vegerîne 'Erê' eger navê file ya derbasdar e, û vegerîne 'Na' din. name a file ya tê hesibandin ku derbasdar be, eger û tenê eger hemû şertên jêrîn li hev tên: - Divê ne zêdetir ji sê sifrên ('0'-'9') di navê file ya hene. - Navê file ya dihewîne tam yek dot '.' - The substring berî dot divê vala ne be, û ew bi tîpeke ji alphabet latin dest pê dike ('a'-'z' û 'A'Z'). - The substring piştî dot divê yek ji van be: ['txt', 'exe', 'll'] Mînak: file_name_check""(example.txt"") # => 'Erê' file_name_check""(example.dll1"") => 'Na' (navê divê bi tîpeke alfabet latin dest pê bike)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,kmr_Latn,python,"


def sum_squares(lst):
    """""""" Ev fonksiyon dê lîsteya hejmarên temam bigire. Ji bo hemû têketinên di lîsteyê de, fonksiyonê divê square têketina integer eger endeksa wê piralî ya 3 e û dê cube têketina integer eger endeksa wê piralî ya 4 e û ne piralî ya 3. fonksiyonê dê têketinên di lîsteyê de ku endeksên ne piralî ya 3 an 4. fonksiyonê wê demê dê jimara hemû têketinan vegerîne. Mînak: Ji bo lst = [1,2,3] encam divê 6 Ji bo lst = [] encam divê 0 Ji bo lst = [-1,-5,2,-1,-5] encam divê -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,kmr_Latn,python,"
def words_in_sentence(sentence):
    """"""Tu string yek hevokê de tê dayîn, ev hevokê de hinek peyvên bi space veqetandin, û tu ji bo vegerandina string ku peyvên ji hevoka orjînal de, ku dirêjahiya wan hejmarên sereke, rêzê ji peyvên di string nû divê wek yek original be.""""""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,kmr_Latn,python,"
def simplify(x, n):
    """"""Xebatê we ew e ku hûn fonksiyonek pêk bînin ku dê îfadeya x * n hêsan bike. Fonksiyon eger x * n ji hejmarek tam û derew derdixe. Hem x û n, nûnertiya string a perçeyek in, û xwedî formata jêrîn in, <numerator> / <denominator> ku hem numerator û denominator hejmarên tevayî yên erênî ne. Hûn dikarin texmîn bikin ku x, û n perçeyên rast in, û wekî denominatorê re zer tune ne. hêsan bike (((""1/5"", ""5/1"") = Rast (h) hêsan bike ((1/6"", ""2/1"") = False (h) hêsan bike (((""7/10"", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,kmr_Latn,python,"
def order_by_points(nums):
    """"""Fonksiyonek binivîse ku lîsteya dane ya hejmarên temam li gor jimara wan hejmarên xwe di rêza bilind de rêz bike. Têbînî: eger çend tiştên bi jimara wekhev a hejmarên wan hebin, ew li gor endeksa wan di lîsteya eslî de rêz bikin. Mînak: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points []) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,kmr_Latn,python,"
def specialFilter(nums):
    """"""Nivîseke function ku array of hejmarên wek input û hejmara hêmanên di array ku mezintir ji 10 û hem yekem û dawî digits ji hejmareke ne wekhev in, vegerîne.""""""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,kmr_Latn,python,"
def get_max_triples(n):
    """"""Tu bi integer erênî n. Tu ji bo afirandina array integer a ji length n. Ji bo her i (1 â‰¤ i â‰¤ n), nirxa a [i] = i * i - i + 1. Returns hejmara sê caran (a [i], a [j], a [k]) ji a ku i < j < k, û a [i] + a [j] + a [k] e multiple ji 3.""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,kmr_Latn,python,"
def bf(planet1, planet2):
    '''Di sîstema me ya solar de heşt gerdûn hene: ya herî nêzîkî rojê Merkur e, ya din Venus e, piştre Erd, Mars, Jupiter, Saturn, Uranus, Neptune. Fonksiyonek binivîse ku du navên gerdûnê wekî stringên planet1 û planet2 digire. Fonksiyon divê tupleyek vegerîne ku hemû gerdûnên ku orbitên wan di navbera orbitên planet1 û orbitên planet2 de ne, li gorî nêzîkbûna rojê. Fonksiyon divê tupleyek vala vegerîne eger planet1 an planet2 navên gerdûnê ne rast in. Mînakên bf ""(Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"") bf ((""Earth"", ""Mercury"") ==> (""Venus"") bf ((""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,kmr_Latn,python,"
def sorted_list_sum(lst):
    """"""Nivîsa function ku lîsteya string wek parametre qebûl bike, ji strings ku lengths odd ji wê deşta, û lîsteya encam bi rêzikeke rêzkirin, lîsteya her tim lîsteya string û tu caran array ji hejmarên, û ew dikare dubare. The rêzê ji lîsteya divê bi dirêjahiya her peyvekê bilind dibe, û tu divê lîsteya rêzkirin bi vê rêzê vegere. Eger du peyvên bi heman dirêjahiya, rêzkirinê lîsteya alphabetically. function divê lîsteya string di rêza rêzkirinê vegere. Hûn dikarin bawer bikin ku hemû peyvên wê bi heman dirêjahiya. Ji bo nimûne: assert list_sort [""aa"", ""a"", ""aaa""]) => assert list_sort [""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,kmr_Latn,python,"
def x_or_y(n, x, y):
    """"""Programek hêsan ku divê nirxa x vegerîne eger n hejmarek sereke ye û divê nirxa y vegerîne. Mînak: ji bo x_or_y(7, 34, 12) == 34 ji bo x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,kmr_Latn,python,"
def double_the_difference(lst):
    '''Lîsteya hejmarên ku tê dayîn, jimara çargoşeya hejmarên lîsteyê vegerînin ku neyênî ne. Hejmarên ku neyênî ne an ne hêjmaran ne. duble_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 duble_the_difference (([-1, -2, 0]) == 0 duble_the_difference (([9, -2]) == 81 duble_the_difference (([0]) == 0 Eger lîsteya ketinê vala be, vegerînin 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,kmr_Latn,python,"
def compare(game,guess):
    """"""Di vê navberê de, eger tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bifikirin ku tu bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî rast bi awayekî bi awayekî rast bi awayekî bi awayekî bi awayekî bi awayekî bi awayekî bi awayê bi awayekî bi awayekî bi awayê bi awayekî bi awayê bi awayekî bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayê bi awayî bi awayê bi awayê bi awayê bi awayê bi awayê bi awayî""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,kmr_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Tu dê navê class (a string) û lîsteya ji extensionên dayîn. The extensionên ji bo barkirina dersên din ji bo class bikaranîn. Hêza ji extension e wek li jêr: Bila CAP hejmara tîpên uppercase di navê extension ya be, û bila SM hejmara tîpên biçûk di navê extension ya be, hêza bi fraction CAP - SM dayîn. Tu divê ji bo dîtina extension herî xurt û vegera string di vê formatê de: ClassName.StrongestExtensionName. Eger du an zêdetir ji extensionên bi heman hêza hene, divê hûn ji yek ku yekemîn di lîsteyê de tê hilbijêre. Bo nimûne, eger tu bi ""Slices"" wek class û lîsteya ji extensionên dayîn: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] hingê divê hûn vegerin 'Slices.SEviRNGSliCes' ji ber ku 'SviRNGSliCes' 'mySviRNGSliCes' (mySliCes') hêza herî xurt e: 'AA' (example: 'Beast_class'), ji bo 'AA' hêza herî xurt e.""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,kmr_Latn,python,"
def cycpattern_check(a , b):
    """"""Tu 2 peyvên. Tu divê ku vegere True eger peyva duyemîn an jî her yek ji rotations xwe a substring di peyva yekemîn cycpattern_check ((""abcd"",""abd"") => False cycpattern_check ((""hello"",""ell"") => True cycpattern_check ((""whassup"",""psus"") => False cycpattern_check ((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,kmr_Latn,python,"
def even_odd_count(num):
    """"""Given a integer. tuple ku hejmara hê û hê digits respectively. Example: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,kmr_Latn,python,"
def int_to_mini_roman(number):
    """"""Bi hejmara pozîtîf, wekheviya wê ya hejmarên romî wek string bistînin, û ew bi tîpên biçûk vegerînin.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,kmr_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Bi dirêjahiya sê aliyên sêgoşekê. Ger sê aliyên sêgoşek rastgoş çêbikin, rast vegerînin, eger ne wisa be. Sêgoşek rastgoş sêgoşek e ku yek hêla wê rastgoşe an 90 derece ye. Mînak: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,kmr_Latn,python,"
def find_max(words):
    """"""Fonksiyonek binivîse ku lîsteya stringan qebûl bike. Lîste peyvên cuda dihewîne. Peyv bi hejmara herî zêde ya karakterên yekane vegerîne. Eger çend string hejmara herî zêde ya karakterên yekane hebin, peyvê ku di rêza leksîkoografîk de yekemîn tê vegerîne. find_max (([""name"", ""of"", ""string""]) == ""string"" find_max (([""name"", ""enam"", ""game""]) == ""enam"" find_max (([""aaaaaaa"", ""bb"" , ""cc""]) == """"aaaaaaa"" """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,kmr_Latn,python,"
def eat(number, need, remaining):
    """"""Tu rabîyek birçî, û tu ji berê de hejmareke hinek ji kerançî xwarin, lê niha tu pêdivî bi xwarinê zêdetir kerançî ji bo temamkirina xwarinên rojê. tu divê array ji [hejmara total ji kerançî xwarin piştî xwarinên xwe, hejmara kerançî li pey xwarinên xwe ] eger ne bes kerançî mayî hene, hûn dê hemû kerançî mayî xwin, lê dîsa jî dê birçî be. nimûne: * xwin ((5, 6, 10) -> [11, 4] * xwin ((4, 8, 9) -> [12, 1] * xwin ((1, 10, 10) -> [11, 0] * xwin ((2, 11, 5) -> [7, 0] Variables: @number: integer hejmara kerançî ku we xwarin. @need: integer hejmara kerançî ku divê hûn xwin. @remaining: integer hejmara kerançî mayî ya ku di stokê de hene: Constrain: * 0 = <= 1000 * 0 = <= 1000 * 0 = <= 1000: <= 1000 = <= 1000 = 1000 = <= 1000 = fun""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,kmr_Latn,python,"
def do_algebra(operator, operand):
    """"""Operasyonên algebrê yên bingehîn: Addition (+) Subtraction ( - ) Multiplication ( *) Floor division ( //) Exponentiation ( **) Example: operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 Têbînî: Dirêjahiya lîsteya operator eynî ye ku dirêjahiya lîsteya operand minus yek. Operand lîsteya hejmarên ne-negatîf e. Operator lîsteya herî kêm yek operator e, û lîsteya operand herî kêm du operand hene.""""""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,kmr_Latn,python,"
def solve(s):
    """"""Tu string s. eger s[i] a letter, rewşa xwe ji nizmî heta jor an vise versa, din jî ew wek ku ew e. Eger string tu tîpên, rewşa string. function divê string encam vegere dayîn. mînakên çareser bike ((""1234"") = ""4321"" çareser bike ((""ab"") = ""AB"" çareser bike ((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,kmr_Latn,python,"
def string_to_md5(text):
    """"""Ji ber ku string 'text', string hevbeş ya hevseng ya md5 vegerîne. Eger 'text' stringek vala be, None vegerîne. >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,kmr_Latn,python,"
def generate_integers(a, b):
    """"""Bi du hejmarên a û b, hejmarên a û b, bi rêza bilindbûnê vegerînin.""""""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
