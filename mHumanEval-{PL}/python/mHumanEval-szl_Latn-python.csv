task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,szl_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Przekōnejcie, eli we podanyj liście numerōw sōm jakijś dwie liczby bliżyj siebie aniżeli dany prōg. Przikłod: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,szl_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Wkludzŏ sie sztrōng, co zawiyro mocka grup prōmiyn zakrziwiōnych. Twojim cylym je ôddzielynie tych grup na ôsobne sztrōngy i zwrocanie jejich wykazu. Ôsobne grupy sōm zrównoważōne (kożdy ôtwarty ôkres je prawidłowo zawarty) i niy sōm zakrziwiōne w postrzodku siebie. Ignoruj wszyske przestrzyństwa w sztrōngie wejściowym. Przikłod: >>> separate_paren_groups' ((( ) (() (()))))) ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,szl_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Z powtōrkym liczby z dodatnim zmiynnym pōnktym, idzie jōm rozłożyć na tajla cołkości (nojwiynkszo liczba cołkości myńszo ôd danej liczby) i dziesiyntne (leftover part dycki myńszo ôd 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,szl_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Twoje zadanie to wykryć, eli w jakimś mōmyncie saldo kōnta spadŏ pod nulã, a w tym mōmyncie funkcyjŏ powinna zwrōcić Wiarygodne. W przeciwnym razie powinna zwrōcić Fałszywe. Przikłŏd: >>> below_zero([1, 2, 3]) Fałszywe >>> below_zero([1, 2, -4, 5]) Wiarygodne """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,szl_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Do podanyj listy liczb wejściowych, wylicz przeciętne ôdchylenie ôbrymbowe ô strzedniości tego zestawu danych. Średnie ôdchylenie ôbrymbowe to strzednio absolutno rōżnica miyndzy kożdym elymyntym a pōnktym postrzodkowym (strzedniość w tym przipodku): MAD = strzedniość. x - x_miana. Przikłod: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,szl_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Wkludzŏ sie liczba ""delimiter"" miyndzy kożdym dwōm kolejnymi elymyntami wkludzōnyj listy `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,szl_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Włōncz do tyj funkcyje strōnã reprezyntowanõ wielokrotnymi grupami dlŏ zagnieżdżōnych ôkłŏdkōw ôddzielōnych przestrzyniami. Dla kożdego z grup wydaj nojgłymbszy poziōm zagnieżdżōnych ôkłŏdkōw. Np. (() (()) mo maksymalnie dwa poziōmy zagnieżdżōnych, w czasie kej ((())) mo trzi. >>> parse_nested_parens (('((()) ((())) () (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,szl_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtruj listã wkludzōnych sztrōngōw ino na te, co zawiyrajōm dany podsztrōng >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,szl_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""W danym zbiorze liczb cołkowitych, zwroć tupla skłŏdajōncŏ sie z sumy i iloczynio wszyjskich liczb cołkowitych na zbiorze.""""""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,szl_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Z podanyj listy liczb cołkowitych wygeneruje sie lista nojsrogszych elymyntōw znojdzōnych do danego momentu w sekwyncyji. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,szl_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Dowiydź nojkrōtszy palindrom, co sie zaczyno ôd podanyj strōny. Idyjo algorytmu je ajnfachowo: - Dowiydź nojwiynkszy postfix podanyj strōny, co je palindromym. - Dodaj do kōńca strōny ôdwrotny przedrostek strōny, co przidzie przed sufiksem palindromicznym. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('catac') ' >>> make_palindrome ((('catac') ' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Prōbowanie, eli dany sztrōng je palindrōm.""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,szl_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Wkludzōne sōm dwa strōny a i b skłŏdajōnce sie ino z 1 i 0. Wykōńcz binarny XOR na tych wejściach i wydaj wynik tyż jako strōng. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,szl_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Z listy strōn, zwroć nojwiynkszy. Wrōć piyrszy w przipadku mocka strōn jednakowyj dugości. Wrōć żodyn w przipadku, jak lista wkludzōnych je prōzna. >>> nojwiynkszy (([]) >>> nojwiynkszy ((['a', 'b', 'c']) 'a' >>> nojwiynkszy ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,szl_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Zwrōć nojwiynkszy spōlny dzielnik dwōch liczb cołkowitych a i b >>> nojwiynkszy_spōlny_dzieliciel ((3, 5) 1 >>> nojwiynkszy_spōlny_dzieliciel ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,szl_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Wykaz zwrotny wszyjskich przedrostek ôd nojsrogszego do nojsrogszego z wiersza wejściowego >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,szl_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Zwrōć kōmyntorz zawiyrajōncy liczby ôgraniczōne przestrzyństwym ôd 0 do n włącznie. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,szl_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""W podanym wierszu, znojść, wiela ôsobnych znakōw (bez wzglyndu na przipadek) skłodo sie z: >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,szl_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Wkludzŏcie strōnã reprezyntujōncŏ nuty muzyczne we formie ASCII. Waszym zadaniym je rozszrajbniyncie listy strōn cołkowitych ôdpednich mocce beatōw. Tu je legenda: 'o' - notatka, ôstatnie sztyry beaty 'o' - połowa noty, ôstatnie dwa beaty 'o' - sztyry noty, ôstatnie jedyn beat >>> parse_music. 'o o' .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,szl_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Znojść, wiela razy dany podżōnzek idzie znojś we ôryginalnym danym danym. Zbiyrōmy przipadki pokrywajōnce sie. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,szl_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Wkludzŏ sie przestrzyń ôgraniczōny przestrzyniōm liczb ôd ""nul"" do ""dziewiyńciu"". Wartne ôbiory to ""nul"", ""jedyn"", ""dwa"", ""trzi"", ""cztery"", ""piyńć"", ""sześ"", ""siedym"", ""ôsmy"" i ""dziewiyńć"". Zwrōćōm wiersz z liczbami sortowanymi ôd nojmyńszego do nojsrogszego >>> sort_numbers (('trzy jedyn piyńć') 'jedyn trzi piyńć' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,szl_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Z podanyj listy numerōw (o dugości co nojmynij dwōch) ôbier i zwōń dwa, co sōm nojbliższe do siebie i zwōń je w porzōndku (myńszo liczba, srogszŏ liczba). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,szl_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Dano lista liczb (co nojmynij ze dwōch elymyntōw), zastosować linijowo transformacyjo do tyj listy, tak, coby nojmyńszo liczba stała sie 0, a nojsrogszo 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,szl_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filtruj dany wykoz kożdych wertōw pythōnu ino dlo liczb cołkowitych >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,szl_Latn,python,"

def strlen(string: str) -> int:
    """"""Dugość zwrotu danego strōmu >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,szl_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Do danej liczby n, znajdź nojwiynkszo liczba, co dzieli n rōwno, myńszo aniżeli n >>> najwiynkszy_dzielicznik ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,szl_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Wrōć lista czynnikōw piyrszych danej liczby cołkowitej w porzōndku ôd nojmyńszego do nojsrogszego. Kożdy z czynnikōw musi być wypisany liczba razy ôdpednio liczbie razy, co sie pokozuje w faktoryzacyji. Liczba wejściowo musi być rōwno iloczynowi wszyjskich czynnikōw >>> faktoryzować(8) [2, 2, 2] >>> faktoryzować(25) [5, 5] >>> faktoryzować(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,szl_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Z listy liczb cołkowitych usuniyncie wszyskich elymyntōw, co wystympujōm wiyncyj jak roz. Utrzimy porzōndek elymyntōw ôstawiōnych taki sōm jak we wkludzōnym. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,szl_Latn,python,"

def flip_case(string: str) -> str:
    """"""W danym sznōrku, przewrōć małe znaki na duże i duże na małe. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,szl_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Zwiōnzać listã strōn w jedyn strōnã >>> zwiōnzać([]) '' >>> zwiōnzać(['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,szl_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtruj listã z wkludzōnych sztrōngōw ino na te, co zaczōm sie ôd dŏwanego przedrostka. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,szl_Latn,python,"

def get_positive(l: list):
    """"""Wrōć ino liczby dodatnie z listy. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,szl_Latn,python,"

def is_prime(n):
    """"""Zwrōć prawe, jeźli dany numer je piyrszy, a fałszywe, jeźli niy. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,szl_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs to spōłczynniki wielōmianu. find_zero find x taki, iże poly ((x) = 0. find_zero zwraco ino ino punkt zero, nawet jeźli je ich moc. Co wiyncyj, find_zero bierŏ ino listã xs, co mŏ liczba rōwnych spōłczynnikōw i nojsrogszy niynulŏwy spōłczynnik, jak gwarantuje rozwiōnzanie. >>> round (((find_zero[1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Ôcyni wielōmian z spōłczynnikami xs w pōnktie x. zwrōci xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,szl_Latn,python,"

def sort_third(l: list):
    """"""Ta funkcyjo bierŏ listã l i zwroco listã l', tak, iże l' je idyntyczne z l w indeksach, co niy sōm tajlowane na trzi, w czasie kej jeji wartości w indeksach, co sōm tajlowane na trzi, sōm rōwne wartościōm ôdpednich indeksach l, ale sortowane. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,szl_Latn,python,"

def unique(l: list):
    """"""Zwrōć sortowane niyôbyczajne elymynta we wykazie >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,szl_Latn,python,"

def max_element(l: list):
    """"""Wrōć maksymalny elymynt we wykazie. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,szl_Latn,python,"

def fizz_buzz(n: int):
    """"""Wrōć liczba razy, w kerych cyfra 7 wystympuje we liczbach cołkowitych myńszych aniżeli n, kere sōm tajlowane bez 11 abo 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,szl_Latn,python,"

def sort_even(l: list):
    """"""Ta funkcyjo bierŏ listã l i zwroco listã l', tak, iże l' je idyntyczne z l w niyparzystych indeksach, w czasie kej jeji wartości w parzystych indeksach sōm rōwne wartościōm parzystych indeksach l, ale sortowane. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,szl_Latn,python,"

def encode_cyclic(s: str):
    """"""bierze za wkludzōny sznur zakodowany funkcyjōm encode_cyclic. Wycofo dekodowany sznur. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""zwraca zakodowany wiersz po cyklicznych grupach trzech znakōw. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,szl_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib zwraco n-to liczba, co je liczbōm Fibonacciego i je tyż piyrszo. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,szl_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero bierŏ za wejście lista liczb cołkowitych. Wrŏca Wiary, jeźli sōm trzi ôsobne elymynta na liście, co sumujōm do zera, a Falsze w inkszych przipadkach. >>> triples_sum_to_zero([1, 3, 5, 0]) Falsze >>> triples_sum_to_zero[(1, 3, -2, 1]) Wiary >>> triples_sum_to_zero([1, 2, 3, 7]) Falsze >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) Wiary >>> triples_sum_to_zero[1]) Falsze """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,szl_Latn,python,"

def car_race_collision(n: int):
    """"""Wyobraźmy sobie drōga, kero je perfekt prosto, nieskończenie dugo. n aut jeździ z lewyj na prawo; rōwnoczesnie inkszy zestaw n aut jeździ z prawyj na lewo. Te dwa zestawy aut zaczynajōm sie fest daleko ôd siebie. Wszystke auta poruszajōm sie z ta sama wartkość. Dwa auta trefiajōm sie, kej auto, co je na lewyj na prawyj strzimie auto, co je na prawyj na lewyj. Jednak auta sōm nieskońcnie sztywne i mocne; w rezultacie, poruszajōm sie na swojij trajektoryji, jak keby sie niy trefiły. Ta funkcyjo wycowuje liczba takich zderzyń.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,szl_Latn,python,"

def incr_list(l: list):
    """"""Wykaz zwrotny z elymyntami przerobiōnymi o 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,szl_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero bierŏ za wejście lista liczb cołkowitych. Wrŏca True, jeźli sōm dwa ôsobne elymynta na liście, co sumujōm do zera, a False inakszyj. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,szl_Latn,python,"

def change_base(x: int, base: int):
    """"""Zmiyń liczbowo podstawa wejściowyj liczby x na podstawa. Zwrōć reprezyntacyjo struny po kōnwersyji. Liczby podstawy sōm myńsze aniżeli 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,szl_Latn,python,"

def triangle_area(a, h):
    """"""Dano dugość strōny i wysoki ôbszar ôdwrotu trziōnkła. >>> trziōnklo_obszar""""""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,szl_Latn,python,"

def fib4(n: int):
    """"""Sekwyncyjŏ liczb Fib4 to sekwyncyjŏ podobnŏ do sekwyncyje Fibbonacciego, ôkryślŏ sie tak: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Napisz funkcyjõ, coby efektywnie obliczyć n-ty elymynt sekwyncyje liczb fib4. Niy używaj rekuryncyje. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,szl_Latn,python,"

def median(l: list):
    """"""Mediana ôdpisu elymyntōw z listy l. >>> mediana (([3, 1, 2, 4, 5]) 3 >>> mediana (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,szl_Latn,python,"

def is_palindrome(text: str):
    """"""Wykŏzuje, eli dany sznur je palindrōm >>> is_palindromem (('') True >>> is_palindromem (('aba') True >>> is_palindromem (('aaaaa') True >>> is_palindromem (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,szl_Latn,python,"

def modp(n: int, p: int):
    """"""Wrōć 2^n modulo p (boj sie liczbōw). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,szl_Latn,python,"

def encode_shift(s: str):
    """"""bierze za wkludzōny sznur zakodowany funkcyjōm encode_shift. Wycofo dekodowany sznur. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""zwraca zakodowany wiersz, posuwajōnc kożdy znak ô 5 w alfabety.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,szl_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels to funkcyjo, kero bierŏ strōnã i zwraco strōnã bez samogłosek. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') ' ' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,szl_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Wrōć Wiarygodne, jeźli wszyjske liczby we wykazie l sōm pod progym t. >>> below_threshold (([1, 2, 4, 10], 100) Wiarygodne >>> below_threshold (([1, 20, 4, 10], 5) Falsze """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,szl_Latn,python,"

def add(x: int, y: int):
    """"""Dodajymy dwie liczby x i y, dodajymy... (x, y) 2, 3 5 dodajymy... (x, y) 5, 7 dodajymy... 12""""""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,szl_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Wrōć do Kategoryje:Pōnkniyntŏ strōna. Wrōć do Kategoryje:Pōnkniyntŏ strōna.""""""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,szl_Latn,python,"

def fib(n: int):
    """"""Wrōć n-tōm liczbōm Fibonacciego. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,szl_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets to je ciąg ""<"" i "">"". return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,szl_Latn,python,"

def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing. >>> monotoniczne (([1, 2, 4, 20]) True >>> monotoniczne (([1, 20, 4, 10]) False >>> monotoniczne (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,szl_Latn,python,"

def common(l1: list, l2: list):
    """"""Wrōć sortowane niyôbyczajne spōlne elymynta dlŏ dwōch list. >>> spōlne (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> spōlne (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,szl_Latn,python,"

def largest_prime_factor(n: int):
    """"""Wrōć nojsrogszy piyrszy czynnik ôd n. Załōżmy, iże n > 1 i niyma piyrszym. >>> nojsrogszy_przyrszy_czynnik ((13195) 29 >>> nojsrogszy_przyrszy_czynnik ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,szl_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n je funkcyjōm, co sumuje liczby ôd 1 do n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,szl_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets to je ciąg ""("" i "")"". return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() "") True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,szl_Latn,python,"

def derivative(xs: list):
    """"""xs reprezyntujōm spōłczynniki wielōmianu. xs[0] + xs[1] * x + xs[2] * x^2 + .... Zwrōć pochodnikowo tego wielōmianu we tyj samyj formie. >>> pochodnikowo (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> pochodnikowo (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,szl_Latn,python,"

def fibfib(n: int):
    """"""Sekwyncyjŏ liczb FibFib to sekwyncyjŏ podobno do sekwyncyje Fibbonacci, ôkryślōnyj tak: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).""""""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,szl_Latn,python,"
FIX = """"""Napisz funkcyjõ vowels_count, co bierŏ strōng słownika za wejścióng i zwraco liczba samogłosek we strōngie. Samogłoski w tym przipodku to a, e, i, o, u. W tym przipodku y je tyż samogłoskōm, ale ino kej je na kōńcu danego słowa. Przikłod: >>> vowels_count (a) (b) (c) 2 >>> vowels_count (a) (d) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e)""""""

def vowels_count(s):
    """"""Dodaj wiyncyj przipadkōw testowych.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,szl_Latn,python,"
def circular_shift(x, shift):
    """"""Krziżowŏ przesuniyńć cyfr liczby cołkowitej x, przesuniyńcie cyfr na prawo i wycofanie wyniku jako strzyngu. Jeźli przesuniyńcie > liczba cyfr, wycofywanie cyfr ôdwrōcōne. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,szl_Latn,python,"
def digitSum(s):
    """"""Zadanie Napisz funkcyjõ, co bierze jako wejścióng strōng i zwraco sumã ino gōrszych znakōw kodōw ASCII. Przikłady: digitSum ((("""") => 0 digitSum (((""abAB"") => 131 digitSum (((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum (((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,szl_Latn,python,"
def fruit_distribution(s,n):
    """"""W tym zadaniu dostaniesz sznur, co reprezyntuje liczba jabłek i pomarańczow, co sōm rozkludzōne w koszyku ôwocōw, co zawiyro jabłka, pomarańcze i mango. Z potajlowaniym sznurōw, co reprezyntujōm cołko liczba pomarańczow i jabłek, i liczby cołkości, co reprezyntujōm cołko liczba ôwocōw w koszyku, wydaj liczba ôwocōw mango w koszyku. Na przikłod: fruit_distribution""5(jabłka i 6 pomarańczow"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 jabłka i 1 pomarańczow"", 3) -> 3 - 0 - 1 = 2 fruit_distribution""2 jabłka i 3 pomarańczow"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 jabłkōw i 1 pomarańczow"", 1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,szl_Latn,python,"
def pluck(arr):
    """"""""Jeźli mŏsz maszyna, co reprezyntuje gałynziŏ drzewa, co mŏ niynegatywne szczylne wōzły, twojim zadaniym je wyłōnczyć jedyn z wōzłōw i go zwrōcić. Wyłōnczōny szpil bydzie szpilym z nojmyńszōm parznōm wertym. Jeźli znŏdniynte je mocka wōzłōw z ta samyj nojmyńszōm parznōm wertym, zwrōć szpil, co mŏ nojmyńszy indeks. Wyłōnczōny szpil bydzie zwrōcōny we wykazie, [smallest_value, jego indeks]. Jeźli niy ma parznōch wartości abo dany maszyna je prōzna, zwrōć []. Przikłod 1: Wklod: [4,2,3] Wylot: [2, 1] Wyjaśniynie: 2 mŏ nojmyńszõ parznō wartość, a 2 mŏ nojmyńszy indeks. Przikłod 2: Wklod: [1,2,3] Wylot: [2, 1] Wyjaśniynie: 2 mŏ nojmyńszõ parznō wartość, a 2 mŏszõ parznōść. Przikłod 3: Wklod: [3,4] Wylot wyłŏ: [5, 3], [5, 4,] Wyja: [5, [0,] Wyj: [0,] Wyj: 1 mŏ: 0 Wyj: 0 Wylot: nojmyj szpil mŏ szpil, co mŏ mŏ mŏ mŏ nojmyńszo indeks mŏ je nojmyj niskŏ, ale je 0; przikłŏ je przikłŏ, bez przikłŏ, bez przikłŏ, bez przikłŏ, bez przikłŏ, bez przikłŏ, bez przikłŏ, bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez bez""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,szl_Latn,python,"
def search(lst):
    '''Wrōć nojwiynkszo liczba cołkowito, co je srogszŏ aniżeli nula i mo czynstość srogszõ aniżeli abo rōwno wartości samej liczby cołkowitej. Częstość liczby cołkowitej to je liczba razy, co sie pokozuje we wykazie. Jeźli niy ma takigo wyniku, wrōć -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,szl_Latn,python,"
def strange_sort_list(lst):
    '''Zŏbrane liczby cołkowite, zwrōć listã we dziwnyj porzōndku. Dziwny sortowanie, to je, kej zacznij ôd minimalnyj wartości, potym maksymalnyj ôstŏwajōncyj liczby cołkowityj, potym minimalnyj i tak dalij. Przikłady: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,szl_Latn,python,"
def triangle_area(a, b, c):
    '''Pozdrŏwŏ powiyrchnia trōjkōnca zaokrōlōno do 2 kōncek po dziesiōntkowym, jeźli trzi krawy tworzōm prawidłowy trōjkōnc. Inaczyj ôdnŏwŏ -1 Trzi krawy tworzōm prawidłowy trōjkōnc, jeźli suma jakichkolwiek dwōch krawōw je srogszŏ aniżeli trzeci kraw. Przikłŏd: trōjkōnc_powierzchnia{\displaystyle {\displaystyle {\displaystyle {\mathbf {r}}_{\displaystyle {\mathbf {r}}_{\mathbf {r}}{\mathbf {r}}{\mathbf {r}}}}{\mathbf {r}}{\mathbf {r}}{\mathbf {r}}}}}}}}'''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,szl_Latn,python,"
def will_it_fly(q,w):
    '''Napisz funkcyjõ, co zwrōci True, jeźli ôbiekt q bydzie latać, a False, jeźli niy. Ôbiekt q bydzie latać, jeźli je zrównoważōny (to je lista palindrōmiczno) i suma jego elymyntōw je myńszo abo rōwno maksymalnyj możliwyj srogości w. Przikłod: will_it_fly (([1, 2], 5) â -> False # 1+2 je myńszo ôd maksymalnyj możliwyj srogości, ale je niyzrównoważōny. will_it_fly (([3, 2, 3], 1) â -> False # je zrównoważōny, ale 3+2+3 je wiyncyj aniżeli maksymalno możliwo srogość. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 je myńsze aniżeli maksymalno możliwo srogość, i je zrównoważōny. will_it_fly ((([3], â 5) -> True # 3 je myńszo aniżeli maksymalno możliwyj srogości, a je zrównoważōny. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,szl_Latn,python,"
def smallest_change(arr):
    """"""W przipadku ôkryślyniŏ liczby cołkowitych liczb we zbiorze, znajdź minimalnŏ liczba elymyntōw, kere trza zmiynić, coby zbiorz bōł palyndrōmiczny. Zbiorz palyndrōmiczny to zbiorz, co je czytany tak samo do przodu jak i do zadku. W jednyj zmianie idzie zmiynić jedyn elymynt na kożdy inkszy elymynt. Na przikłŏd: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,szl_Latn,python,"
def total_match(lst1, lst2):
    '''Napisz funkcyjõ, co akceptuje dwie listy strōn i zwraco listã, co mŏ w cołkij liczbie znakōw we wszyjskich strōnach listy mynij niż ta drugŏ. Jeźli dwie listy majōm ta sama liczba znakōw, zwracaj piyrszõ listã. Przikłady total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hi', 'hi', 'hi']) â -> ['hi', 'hi'], total_match ((['hi'4', ['1', '2', '3', '4', '5', '4]) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,szl_Latn,python,"
def is_multiply_prime(a):
    """"""Napisz funkcyjo, co wrōci prawe, jeźli dany numer je mnożyniym 3 liczb piyrszych, a fałszywe, jeźli niy.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,szl_Latn,python,"
def is_simple_power(x, n):
    """"""Twoje zadanie to je napisanie funkcyje, co wrōci prawe, jeźli liczba x je prostōm potyncyjōm n, a fałszywe w inkszych przipadkach. x je prostōm potyncyjōm n, jeźli n**int=x Na przikłod: is_simple_power ((1, 4) => true is_simple_power ((2, 2) => true is_simple_power ((8, 2) => true is_simple_power ((3, 2) => false is_simple_power ((3, 1) => false is_simple_power ((5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,szl_Latn,python,"
def iscube(a):
    '''Napisz funkcyjõ, co bierze liczba cołkowita a i zwraco wiarygodno, jeźli ta liczba je sześcianōm liczby cołkowitego.'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,szl_Latn,python,"
def hex_key(num):
    """"""Zadanie do pisanio funkcyje, co dostŏwŏ liczby szesnostkowe za strōng i rachowuje liczba szesnostkowych cyfr, co sōm liczbami piyrszymi (numer piyrszy, abo liczba piyrszo, to liczba naturalno srogszo ôd 1 i niyma iloczynym dwōch myńszych liczb naturalnych). Cyfry szesnostkowe to 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Cyfry piyrsze to 2, 3, 5, 7, 11, 13, 17,... No to trza ôkryślić liczba z nastympliwych cyfrōw: 2, 3, 5, 7, B (= szesnostkowy), D (= szesnostkowy). Uwaga: idzie założyć, iże wejście je dycki poprawne abo puste, a symbole A,B,C,D,E,F sōm dycki duże. Przikłady: dlo numera ""AB"" wyjście powinno być 1. dlo numera ""1077E"" wyjście powinno być 2. dlo numera ""AB"" powinno być 1.33ABC = 4.123ABC = 6.067D. dlo numera wyjściowego ""2020"" powinno być 2.045EF.""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,szl_Latn,python,"
def decimal_to_binary(decimal):
    """"""Zoboczymy, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak sie to robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to sie robi, jak to, jak to sie robi, jak to, jak to, jak to, jak to, jak to, jak to, jak to, jak to, jak to, jak to, jak to, jak to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to, to,""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,szl_Latn,python,"
def is_happy(s):
    """"""Je to strōnka, co mo co nojmynij 3 litery, a kożde 3 je inksze. Na przikłod: is_happy (a) => False is_happy (a) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,szl_Latn,python,"
def numerical_letter_grade(grades):
    """"""Je ôstatni tydziyń semestru i nauczycielka musi dać stopnie uczniōm. Nauczycielka stworziła swojã włŏsno algorytm do ôcyny. Jedyny problym je to, że straciła kod, co go używała do ôcyny. Dała ci lista GPA dlo niykerych uczniōw i musisz napisać funkcyjo, co może wypuścić lista stopni liter za pōmocōm tabeli: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,szl_Latn,python,"
def prime_length(string):
    """"""Napisz funkcyjo, co bierŏ sznur i zwraco Wiary, jeźli dugość sznurka je liczbōm piyrszōm abo Fałszywym, jeźli niy. Przikłady prime_length{""Hello"") == True prime_length{""abcdcba"") == True prime_length{""kittens"") == True prime_length{""orange"") == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,szl_Latn,python,"
def starts_one_ends(n):
    """"""Dołōnc liczba cołkowito dodatnio n, wycofaj liczba liczb cołkowitych dodatnich n-cyfer, co zaczynajōm sie abo kōńczōm na 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,szl_Latn,python,"
def solve(N):
    """"""Zbiyrŏ sie liczba cołkowito dodatnŏ N, ôdnŏjōm cołkowity ôbiekt liczb liczbowych w krojcu binarnym. Przikłŏd W przipadku N = 1000, suma cyfr bydzie 1 wyjście bydzie ""1"". W przipadku N = 150, suma cyfr bydzie 6 wyjście bydzie ""110"". W przipadku N = 147, suma cyfr bydzie 12 wyjście bydzie ""1100"". Zmiynne: @N liczba cołkowito Użycie: 0 â‰¤ N â‰¤ 10000. Wyjście: wiersz liczb binarnych """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,szl_Latn,python,"
def add(lst):
    """"""Dodajmy tyż elymynta, co sōm we niyporzōndnych indeksach. Przikłady: przidźyć ([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,szl_Latn,python,"
def anti_shuffle(s):
    """"""Napisz funkcyjõ, co bierze strōng i zwraco jego porzōndkowanõ wersyjõ. Porzōndkowanŏ wersyjŏ strunga to strōng, co w nim wszyjske słowa (rozdziaływane przestrzyniōm) sōm zastōmpiōne nowym słowym, co w nim wszyjske znaki sōm ułożōne we wzrōstajōncym porzōndku podle wartości ASCII. Uwaga: Trza zachować porzōndek słōw i blankōw w zdaniach. Na przikłŏd: anti_shuffle ((('Hi') zwraco ""Hi' anti_shuffle (('hello') zwraco ""ehllo' anti_shuffle (('Hello World!!!') zwraco ""Hello !!!Wdlor"" """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,szl_Latn,python,"
def get_row(lst, x):
    """"""Zdo sie, iże kożdy wiersz mŏ inkszõ liczbã kolōmn. Zdo sie, iże lst i liczba cołkowita x, znajdź liczby cołkowite x w liście, a zwrōć listã tupli, [(x1, y1), (x2, y2) ...] tak, iże kożdy tupel je spōłrzyndnym - (rōw, kolōmny), zaczōncŏ ôd 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,szl_Latn,python,"
def sort_array(array):
    """"""Po podaniu tabulki niynegatywnych liczb cołkowitych, zwrōć kopijo danej tabulki po sortowaniu, sortuj podano tabulka we wzrōstajōncym porzōndku, jeźli suma (co piyrszo wert indeksu, co ôstatnio wert indeksu) je niyparzōnco, abo sortuj je w redukojōncym porzōndku, jeźli suma (co piyrszo wert indeksu, co ôstatnio wert indeksu) je pora. Uwaga: * niy zmiyń podano tabulka. Przikłady: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,szl_Latn,python,"
def encrypt(s):
    """"""Stworz funkcyjo encrypt, co bierŏ strōng za argumynt i zwraco strōng zaszyfrowany z ôbwrōcōnym alfabetym. Alfabet musi być ôbwrōcōny tak, coby litery ôdkludzały sie do dómu, mnożōne bez dwa, na dwa placu. Na przikłŏd: encrypt ((hi) zwraco ""lm"" encrypt ((asdfghjkl)) zwraco ""ewhjklnop"" encrypt ((gf)) zwraco ""kj"" encrypt ((et)) zwraco ""ix"" """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,szl_Latn,python,"
def next_smallest(lst):
    """"""Jeźli niy ma takigo elymentu, wrōci sie żŏdny. next_smallest([1, 2, 3, 4, 5]) == 2 next_smallest([5, 1, 4, 3, 2]) == 2 next_smallest([]) == Żŏdny next_smallest([1, 1]) == Żŏdny """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,szl_Latn,python,"
def is_bored(S):
    """"""Zdanie zaczyna sie od słowa ""I"". Zdania ôgraniczŏ sie """", ""?"" abo ""! "" Na przikłŏd: >>> is_bored (zdrowaś światu) 0 >>> is_bored (niebo je modre. Słōńce świyci. Lubiã ta pogoda) 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,szl_Latn,python,"
def any_int(x, y, z):
    '''Stworz funkcyjo, co bierŏ 3 liczby. Wrŏcŏ ""true"", jeźli jedna z liczb je rōwno sumie inkszych dwōch, a wszyske liczby sōm cołkowite. Wrŏcŏ ""false"" w inkszych przipadkach. Przikłady any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,szl_Latn,python,"
def encode(message):
    """"""Napisz funkcyjõ, co bierze wiadōmość i kodowuje tak, iże wymiynŏ wszyjske litery, zastympuje wszyjske samogłoski w wiadōmości literōm, co wystympuje 2 placami przed samogłoskōm w angelskim alfabetze.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,szl_Latn,python,"

def skjkasdkd(lst):
    """"""Jeźli mŏsz listã liczb cołkowitych, musisz znojś nojsrogszõ wartość piyrszõ i zwrōcić suma jejich cyfr. Przikłady: dlŏ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] wynik bydzie 10 dlŏ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] wynik bydzie 25 dlŏ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] wynik bydzie 13 dlŏ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] wynik bydzie 11 dlŏ lst = [0,81,12,31,21] wynik bydzie 3 dlŏ lst = [0,1,8,1,2,7] wynik bydzie 7 dlŏ lst = [1,8,1,2,7] wynik bydzie 7 dlŏ lst = [1,8,1,2,7] wynik bydzie 7 dlŏ lst = [0,8,1,2,7]""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,szl_Latn,python,"
def check_dict_case(dict):
    """"""W danym słowniku, zwrocić Wiary, jeźli wszyjske klawiszōw sōm strōny w małych literach abo wszyjske klawiszōw sōm strōny w wielkich literach, w inkszym wypadku zwrocić Niyprawdziwy. Funkcyjo powinna zwrocić Niyprawdziwy jeźli dany słownik je pusty. Przikłady: check_dict_case{""a"":""apple"", ""b"":""banana""}) powinna zwrocić Wiary. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) powinna zwrocić Niyprawdziwy. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) powinna zwrocić Niyprawdziwy. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) Niyprawdziwy powinna zwrocić Niyprawdziwy. check_dict_case{""NC""STATE:""STATE"", ""Z""IP:""45""}) powinna zwrocić Niyprawdziwy.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,szl_Latn,python,"
def count_up_to(n):
    """"""Wykōnować funkcyjo, co bierze liczba cołkowito niynegatywna i zwroco matryc piyrszych n liczb cołkowitych, co sōm liczbami piyrszymi i myńszymi aniżeli n. na przikłod: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,szl_Latn,python,"
def multiply(a, b):
    """"""Zbiyrōmy funkcyjõ, co bierŏ dwie liczby cołkowite i zwraco wynik iloczyn jejich jednostkowych cyfr. Załōżmy, iże wejście je dycki ważne. Przikłady: mnożynie 148, 412) powinno zwracać 16, mnożynie 19 28, 72 mnożynie 2020, 1851 powinno zwracać 0, mnożynie 14-15 powinno zwracać 20.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,szl_Latn,python,"
def count_upper(s):
    """"""Na przikłŏd: count_upper{\displaystyle \mathbb {a} }""""""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,szl_Latn,python,"
def closest_integer(value):
    '''Stworz funkcyjo, co bierŏ wert (string) reprezyntujōncy liczba i zwroco nojbliższõ liczba cołkowitŏ. Jeźli liczba je rōwnoodległa ôd dwōch liczb cołkowitych, zaokrōl je ôd zera. Przikłady >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Uwaga: Zaokrōlynie ôd zera ôznaczo, iże jeźli dany numer je rōwnoodległy ôd dwōch liczb cołkowitych, to ta, co trza zwrocić, je ta, co je nojdalij ôd zera. We przikładzie closest_integer "" ((14.5"") winno zwrocić 15, a closest_integer "" ((-14.5"") winno zwrocić -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,szl_Latn,python,"
def make_a_pile(n):
    """"""Pozytywny liczba cołkości n, trza zrobić kupka n poziōmōw kamiyńōw. Piyrszy poziōm mŏ n kamiyńōw. Liczba kamiyńōw na dalszym poziōmie to: - dalszo niyparzōno liczba, jeźli n je niyparzōno. - dalszo liczba parzōno, jeźli n je parzōno. Zwrōć liczba kamiyńōw na kożdym poziōmie na liście, kaj elymynt we indeksie i reprezyntuje liczba kamiyńōw na poziōmie (i+1). Przikłady: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,szl_Latn,python,"
def words_string(s):
    """"""Zostanie ci ôddany sznur słōw ôddzielōnych pōmnikami abo przestrzyniami. Twojim zadaniym je potajlować sznur na słowa i zwrōcić tabela słōw. Na przikłŏd: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,szl_Latn,python,"
def choose_num(x, y):
    """"""Ta funkcyjo bierŏ dwie dodatnie liczby x i y i zwraco nojwiynkszo liczba cołkowita, co je we przestrzyństwie [x, y] włącznie.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,szl_Latn,python,"
def rounded_avg(n, m):
    """"""Jeźli n je srogsze ôd m, wycofaj -1. Przikłod: rounded_avg{1, 5} => ""0b11"" rounded_avg{7, 5} => -1 rounded_avg{10, 20} => ""0b1111"" rounded_avg{20, 33} => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,szl_Latn,python,"
def unique_digits(x):
    """"""Podajymy listã liczb cołkowitych dodatnich x. Wycofujymy zortowanõ listã wszyjskich elymyntōw, co niy majōm żodnyj cyfry. Uwaga: Wycofane listy winny być sortowane we wzrōstajōncym porzōndku. Przikłŏd: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,szl_Latn,python,"
def by_length(arr):
    """"""Na przikłŏd: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sortować arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> ôdrōbić arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""One"", ""One""] Jeźli ta matryca je prōzna, zwrōć ôdrōbić: arr = [] return [] Jeźli ta matryca mo jakŏś dziwŏ liczba, niy dŏwaj sie do tego: arr = [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 1], arr -> [1, 2], arr -> [1, 2], arr -> [1, 3], arr -> [1, 2], arr -> [1, 3], arr -> [1, 5], arr -> [1, 5], return - [1, 1] return [' 'One' ].""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,szl_Latn,python,"
def f(n):
    """"""Wykōńcz funkcyjo f, co bierze n za parametr i zwraco listã ô srogości n, tak, iże wert elymentu na indeksie i je faktorylatym i, jeźli i je parne, abo sumōm liczb ôd 1 do i w inkszym przipadku. i zaczyna sie ôd 1. faktorylatym i je mnożynie liczb ôd 1 do i (1 * 2 * ... * i). Przikłod: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,szl_Latn,python,"
def even_odd_palindrome(n):
    """"""Pozytywny liczba cołkowito n, zwroci tuple, co mŏ liczba cołkowitych palindromōw parzōnych i niyparzōnych, co sōm we ôbrozku ((1, n), w tym. Przikłod1: Wkludzynie: 3 Wyjście: (1, 2) Wyjaśniynie: cołkowity palindrom to 1, 2, 3. jedyn z nich je parzōny, a dwa z nich sōm parzōne. Przikłod2: Wkludzynie: (4, 6) Wyjaśniynie: cołkowity palindrom to 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. sztyry z nich sōm parzōne, a 6 z nich sōm parzōne. Uwaga: 1. 1 <= n <= 10^3 2. tuple zwrociła liczba cołkowitych palindromōw parzōnych i niyparzōnych. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,szl_Latn,python,"
def count_nums(arr):
    """"""Napisz funkcyjo count_nums, co bierŏ macierz liczb cołkowitych i zwraco liczba elymyntōw, co mŏ suma cyfr > 0. Jeźli liczba je ujymno, to jeji piyrszo cyfra bydzie ujymno: bez przikłod -123 mŏ cyfry -1, 2 i 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,szl_Latn,python,"
def move_one_ball(arr):
    """"""Jeźli je to możliwe, coby zortowane masło ôstało zwrōcōne, to je to prowda, a jeźli je to niyprawdopodobne, to je prowda. Na przikłŏd: przesuń_kłodka_ ([3, 4, 5, 2]) Po wykōnowaniu ôperacyji zwrot_kłodki_ ([3, 4, 5, 2]) idzie ôsiōngnōńć porzōndek zwrot_kłodki bez przesuwanie do prawyj, bez przesuwanie do prawyj liczby ôperacyji zwrot_kłodki.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,szl_Latn,python,"
def exchange(lst1, lst2):
    """"""W tym problymie, bydymy wciepować funkcyjo, co bierŏ dwie listy liczb i ôkryślo, eli idzie wykōnać wymiana elymyntōw miyndzy niymi, coby lst1 była listōm ino liczb parzi. Niy ma ôgraniczyniŏ na liczba wymianowanych elymyntōw miyndzy lst1 a lst2. Jeźli idzie wymiana elymyntōw miyndzy lst1 a lst2 coby wszyjske elymynta lst1 były parzne, wycofaj ""YES"". W inkszym razie wycofaj ""NO"". Na przikłŏd: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Zakłodo sie, iże wkludzōne listy bydōm niypróżne. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,szl_Latn,python,"
def histogram(test):
    """"""Przikłŏd: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4}: histogram '(') == {'b 4}""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,szl_Latn,python,"
def reverse_delete(s,c):
    """"""Zadanie Dostalimy dwa strōny s i c, trza wykluczyć wszyjske znaki w s, co sōm rōwne jakimś znakiym w c, a potym zweryfikować, eli wynik strōny je palyndrōm. Strōng je nazywany palyndrōm, jeźli czyto sie tak samo do tyłu, jak do przodu. Trza zwrōcić tupla, co zawiyro wynik strōny i Prawda/Fałsz do sprawdzanio. Przikłod dlŏ s = ""abcde"", c = ""ae"", wynik mŏg być ('bcd', Fałsz) dlŏ s = ""abcdef"", c = ""b"" wynik mŏg być ('acdef', Fałsz) dlŏ s = ""abcdedcba"", c = ""ab"", wynik mŏg być ('cdedc', Prawda)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,szl_Latn,python,"
def odd_count(lst):
    """"""Po podaniu listy sztrōngōw, kaj kożdy sztrōng skłodo sie ino z cyfr, zwroć listã. Kożdy elymynt i wyjściowy musi być ""liczbōm niyparzistych elymyntōw we sztrōngie i wejściowego"". kaj wszyjske i powinny być zastōmpiōne liczbōm niyparzistych cyfr we i'tym sztrōngie wejściowym. >>> odd_count['1234567']) [""liczba niyparzistych elymyntōw 4n str4ng 4 z 4nput.""] >>> odd_count['3',""111111""]) [""liczba niyparzistych elymyntōw 1n str1ng 1 z 1nput."", ""liczba niyparzistych elymyntōw 8n str8ng 8 z 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,szl_Latn,python,"
def minSubArraySum(nums):
    """"""Przikłŏd minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,szl_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Wszyjske rynce majōm jednakowo moc, tōż kożdy rynce mo ôdpednio wiadro, co z niego wyciōngŏ wodã, a wszyjske wiadra majōm jednakowo moc. Twoje zadanie to użyć wiader do wypuśniyńcio wiader. Wydaj liczba razy, co musisz ôpuścić wiadra. Przikłod 1: Wkludzynie: rynka: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] wiadro_mjyntość: 1 Wkludzynie: 6 Przikłod 2: Wkludzynie: rynka: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] wiadro_mjyntość: 2 Wkludzynie: 5 Przikłod 3: Wkludzynie: [[0,0,0], [0,0,0]] wiadro_mjyntość: 5 Wkludzynie: 0 * Wkludzynie: 1 * Wkludzynie: 1 * Wkludzynie: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * Wkludz: 1 * * Wkludz""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,szl_Latn,python,"
def sort_array(arr):
    """"""W tym Kata, trza sortować tabula niynegatywnych liczb cołkowitych podle liczby jedynōw w jejich binarnym ôbrazu we wzrōstajōncym porzōndku.""""""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,szl_Latn,python,"
def select_words(s, n):
    """"""Jeźli wiersz s je pusty, to funkcyjo powinna zwrōcić pusty list. Uwaga: idzie założyć, iże wiersz wejściowy zawiyro ino litery i przestrzyństwa. Przikłady: select_words ""Mary miała jagniynto"", 4) ==> [""jagniynto""] select_words ""Mary miała jagniynto"", 3) ==> [""Mary"", ""jagniynto""] select_words ""proste przestrzyństwo"", 2) ==> [] select_words ""Hello world"", 4) ==> [""world""] select_words ""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,szl_Latn,python,"
def get_closest_vowel(word):
    """"""Jeźli niy znŏjdziesz żŏdnego samogłoska, to wrōć pusty sznur. Możecie założyć, iże dany sznur mŏ ino angelske litery. Przikłŏd: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,szl_Latn,python,"
def match_parens(lst):
    '''Jeźli używŏsz strōny, to musisz sprawdzić, eli je możliwe połōnczyniŏ tych strōn w jakigoś porzōndku, coby wynik bōł dobry. Sztyng S je dobry, jeźli i ino jeźli wszyjske ôkryślōne na S sōm zrównoważōne. Na przikłŏd: strōng '((()) ' je dobry, a strōng '()) ' niy. Wrōć 'Yes', jeźli je jakiś spōsōb, coby stworzić dobry strōng, a w inkszym razie 'No'.'''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,szl_Latn,python,"
def maximum(arr, k):
    """"""Przikłŏd1: Wkludzynie: arr = [-3, -4, 5], k = 3 Wyjście: [-4, -3, 5] Przikłŏd2: Wkludzynie: arr = [4, -4, 4], k = 2 Wyjście: [4, 4] Przikłŏd3: Wkludzynie: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Wyjście: [2] Uwaga: 1. Długość zbioru bydzie we przedziale [1, 1000]. 2. Elymynta zbioru bydōm we przedziale [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,szl_Latn,python,"
def solution(lst):
    """"""Wrōć suma wszyjskich niyporzōndnych elymyntōw, co sōm we parzōnych placach.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,szl_Latn,python,"
def add_elements(arr, k):
    """"""Dodajymy sumã elymyntōw, co majōm nojwyżyj dwie cyfry z piyrszych k elymyntōw arr. Przikłod: Wkludzynie: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Wyludzynie: 24 # sumy 21 + 3 Uwarunkowania: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,szl_Latn,python,"
def get_odd_collatz(n):
    """"""Zgadzańy Collatza to zgadzańy w matymatyce, co tykajōm sie sekwyncyje zdefiniowanyj tak: zacznij ôd kożdyj dodatnij liczby cołkowitej n. Kożdy kōncek je ôbjynty z poprzedniego kōncka tak: jeźli poprzedni kōncek je parny, dalszy kōncek je połowa poprzedniego kōncka. Jeźli poprzedni kōncek je niyparny, dalszy kōncek je 3 razy piyrszy kōncek plus 1. Zgadzańy je taki, iże niy ważne jakŏ wert n, sekwyncyjo dycki ôsiōngnie 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,szl_Latn,python,"
def valid_date(date):
    """"""Trza napisać funkcyjo, co weryfikuje dany wiersz daty i zwroci Wiary, jeźli data je wiarygodno, w przeciwnym razie Fałszywy. Dato je wiarygodno, jeźli spełniōne sōm wszyjske nastympujōnce prawidła: 1. Wiersz daty niyma pusty. 2. Liczba dni niy ma myńszo ani wyższo aniżeli 1 w miesiōncach 1,3,5,7,8,10,12 i liczba dni niy ma myńszo aniżeli 1 i wyższo aniżeli 30 w miesiōncach 4,6,9,11 i liczba dni niy ma myńszo aniżeli 1 i wyższo aniżeli 29 w miesiōncu 2. 3. Miesiōnce niy mogōm być myńsze aniżeli 1 i wyższe aniżeli 12. 4. Dato musi być we formatacie: mm-dd-yyyy, na przikłŏd: valid_date (('03-11-2000') => True_date (valid_date) '15-01-2012') => False valid_date (valid_date) '04-01-2040 => False_date (valid_date) '06-04-2020 => True => valid_date (valid) '06/04/04/2020 => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,szl_Latn,python,"
def split_words(txt):
    '''Na podstawie sztrōmu słōw, zwracaj listã słōw potajlowanych na przestrzyństwie, jeźli żodne przestrzyństwa niy sōm w tekście, to powinieneś potajlować na przeczołgach ',' jeźli żodne przeczołgi niy sōm, to powinieneś zwracać liczba małych liter z niyporzōndkowym porzōndkiem w alfabety, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 Przikłady split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,szl_Latn,python,"
def is_sorted(lst):
    '''Wrōć, eli liczby sōm zortowane we wzrōstajōncyj kolejności, eli niy. Jeźli lista mo wiyncyj jak 1 duplikat tyj samyj liczby, wrōć False. Zakłŏdajymy, iże niy ma liczb ujymnych, a ino liczby cołkowite. Przikłady to is_sorted (zortyzowane) [1]: â -> True to is_sorted (zortyzowane) [1, 2, 3, 4, 5, 5]) â -> True to is_sorted (zortyzowane) [1, 2, 3, 4, 5, 6]) â -> False to is_sorted (zortyzowane) [1, 2, 3, 4, 5, 6, 7]) â -> True to is_sorted (zortyzowane) [1, 3, 2, 4, 5, 6, 7]) â -> False to is_sorted (zortyzowane) [1, 2, 2, 3, 3, 4] â -> True to is_sortyzowane [1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,szl_Latn,python,"
def intersection(interval1, interval2):
    """"""Jeźli interwał je liczbōm piyrszōm, to ôdnŏjdź ""TAK"", jeźli niy, to ôdnŏjdź ""NIE"". Jeźli te dwa interwały sie niy przeciyżōm, ôdnŏjdź ""NIE"". [input/output] przikłady: przeciyń ""((1, 2), (2, 3) ==>""prziciyń ""-1, ""(1), 4) ==>""prziciyń "" (0, ""), ""NO"" ==>"" - "" ("", 5 "", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", ""), ""), "" ("", ""), "" ("", ""), "" ("", ""), "" ("", """"""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,szl_Latn,python,"
def prod_signs(arr):
    """"""Dowo sie zbiōr liczb cołkowitych, co musi być zwrōcōny bez iloczyn liczb cołkowitych, co je mnożōny bez produkt wszyskich znakōw kożdyj liczby we zbiōrce, reprezyntowany bez 1, -1 abo 0.""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,szl_Latn,python,"
def minPath(grid, k):
    """"""W kōmōrce, co mŏ N rŏzōw i N kolōmn (N >= 2) i kōmōrka z liczbōm cołkowōm k, kożdo kōmōrka mŏ wartość. Kożdo liczba cołkowŏ w zakresie [1, N * N] włącznie pojawia sie akuratnie raz na kōmōrkach kōmōrki. Trza znojś minimalnŏ drōga ô dugości k w kōmōrce. Możesz zaczōńć ôd kożdyj kōmōrki, a na kożdym kroku możesz przejść do kożdej sōmsiedzkij kōmōrki, inakszyj, możesz przejść do kōmōrek, co majōm rōm z twojōm terŏźnōm kōmōrkōm. Uwaga: drōga ô dugości k ôznaczo ôdwiedzy na k kōmōrkach (niy musi być ôdrōżni). NIE MOŻEś wyjść z kōmōrki. Drōga A (długości k) je uznŏwano za myńszõ ôd drōgi B (długości k), jeźe po zrobiyniu uporzōndzōnych list wartości na kōmōrkach A i B (powołujmy je l_st A i l_st_st_l_l_l_l_l_l_l_l_l), l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,szl_Latn,python,"
def tri(n):
    """"""Kożdy zna sekwyncyjo Fibonacciego, była głymboko sztudiyrowano ôd matymatykow w ôstatnich dwōch stoleciach. Jednak to, czego ludzie niy wiedzōm, to sekwyncyjo Tribonacciego. Sekwyncyjo Tribonaccigo je zdefiniowano bez powtorzanie: tri(1) = 3 tri(n) = 1 + n / 2, jeźli n je pora. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jeźli n je niyparzyste. Na przikłod: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Dowo sie ci liczba cołkowita n, musisz zwrócić lista piyrszych liczb n + 1 sekwyncyje Tribonaccigo. Przikłody: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,szl_Latn,python,"
def digits(n):
    """"""Z powtōrkym n, zwrōć iloczyn liczb niyparzistych. Zwrōć 0 jeźli wszyjske cyfry sōm parzne. Na przikłŏd: cyfry ((1) == 1 cyfry ((4) == 0 cyfry ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,szl_Latn,python,"
def is_nested(string):
    '''Stworz funkcyjo, co bierŏ za wejście strōnã, co zawiyro ino ôkresy kwadratowe. Funkcyjo powinna zwracać Wiary, jeźli i ino jeźli je prawidłowo podsekwyncyjo ôkresy, co w nij je wkludzōny co nojmynij jedyn ôkres. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]]]]]] â -> True is_nested'[[]]]]]]]] â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,szl_Latn,python,"

def sum_squares(lst):
    """"""Zŏbrŏsz listã liczb. Trza zwrōcić sumã liczb kwadratowych z podanyj listy, zaokrōlnij kożdy elymynt na wiyrchu. Przikłady: Dla lst = [1,2,3] wyjście powinno być 14, Dla lst = [1,4,9] wyjście powinno być 98, Dla lst = [1,3,5,7] wyjście powinno być 84, Dla lst = [1.4,4.2,0] wyjście powinno być 29, Dla lst = [-2.4,1,1] wyjście powinno być 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,szl_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Stworz funkcyjo, co zwrōci Wiary, jeźli ôstatni znak danygo sztrōmu je znakym alfabetycznym i niyma tajlōm słowa, a Falsz w inkszym wypadku. Uwaga: ""słowo"" to grupa znakōw ôddzielōnych przestrzyniōm. Przikłady: check_if_last_char_is_a_letter""{""apple pie"") â -> False check_if_last_char_is_a_letter""{""apple pi e"") â -> True check_if_last_char_is_a_letter""{""apple pi e"") â -> False check_if_last_char_is_a_letter""{""}""{""false check_if_last_char_is_a_letter""}""{""apple pi e"") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,szl_Latn,python,"
def can_arrange(arr):
    """"""Stworz funkcyjo, co zwrōci nojwiynkszy indeks elymentu, co niy je srogszy ani rōwny elymentowi, co je bezpostrzednio przed nim. Jeźli taki elymynt niy istniyje, zwrōć -1. Dano maszyna niy bydzie zawiyrać duplikowanych wertōw. Przikłady: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,szl_Latn,python,"
def largest_smallest_integers(lst):
    '''Stworz funkcyjo, co zwrōci tupla (a, b), kaj ""a"" je nojsrogszōm liczbōm cołkowōm ujemnōm, a ""b"" nojsrogszōm liczbōm cołkowōm dodatnōm na liście. Jeźli niy ma liczb cołkowitych ujemnych abo dodatnich, zwrōć je jako None. Przikłady: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,szl_Latn,python,"
def compare_one(a, b):
    """"""Stworz funkcyjo, co bierŏ liczby cołkowite, zmiynne abo strōny reprezyntujōnce liczby rzeczywiste i zwroco srogszõ zmiynno we danym typie zmiynnych. Wrōć żŏdnŏ, jeźli wartości sōm rōwne. Uwaga: Jeźli liczba rzeczywistŏ je reprezyntowano za strōnã, zmiynny pōnkt może być . abo , porōwnuj_jedyn, 2.5) â -> 2.5 porōwnuj_jedyn, ""2,3"") â -> ""2,3"" porōwnuj_jedyn, ""5,1"", ""6"") â -> ""6"" porōwnuj_jedyn, ""1"", 1) â -> Żŏdnŏ """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,szl_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Ôcyniŏć, eli dany numer n może być zapisane za suma akuratnie 4 dodatnich liczb parzōnych Przikłŏd is_equal_to_sum_even ((4) == False is_equal_to_sum_even ((6) == False is_equal_to_sum_even ((8) == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,szl_Latn,python,"
def special_factorial(n):
    """"""Brazilskŏ faktoryjnŏ je zdefiniowanŏ jako: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! kaj n > 0 Na przikłŏd: >>> special_factorial ((4) 288 Funkcyjŏ dostanie liczba cołkowita za wejście i powinna zwrōcić ekstra faktoryjnŏ tyj liczby cołkowyj. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,szl_Latn,python,"
def fix_spaces(text):
    """"""_Przikłod-3ske przestrzyństwa we tekście strōny zaznaczōm podkreślyniami, a jeźli strōnka mo wiyncyj jak 2 kolejne przestrzyństwa, to zastōńcz wszyjske kolejne przestrzyństwa - fix_spaces ((""Przikłod"") == ""Przikłod"" fix_spaces ((""Przikłod1"") == ""Przikłod_1"" fix_spaces (((""Przikłod2"") == ""_Przikłod_2"" fix_spaces ((""Przikłod 3"") == ""_Przikłod-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,szl_Latn,python,"
def file_name_check(file_name):
    """"""Stworz funkcyjo, co weźnie sznōrka reprezyntujōncŏ miano ôd failu, a zwrōci ""Tak"", jeźli miano ôd failu je ważne, a zwrōci ""Niy"", jeźli niy. Miano ôd failu je uznane za ważne, jeźli i ino jeźli spełniōne sōm wszyjske nastympne warōnki: - Miano ôd failu niy może mieć wiyncyj jak trzi cyfry ('0'-'9') w mianie ôd failu. - Miano ôd failu zawiyro akuratnie jedna pōnktka '.' - Podsznōrka przed pōnktkym niy może być pustŏ, a zaczyno sie ôd litery łacinyjŏwyj alfapy ('a'-'z' i 'A'-Z'). - Podsznōrka po pōnktce powinna być jedna z tych: ['txt', 'exe', 'lld'] Przikłady: file_name_check""{example.txt.t"") # => 'Tak'miano ôd failu_check""{example.tll1} => 'Niyjŏ' (miano ôd miana ôd failu winno zaczno sie ôd łacinyjŏ litera)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,szl_Latn,python,"


def sum_squares(lst):
    """""""" Ta funkcyjo weźnie lista liczb cołkowitych. Do wszyskich wpisōw na liście, funkcyjo musi umocnić na kwadrat wpis cołkowity, jeźli jego indeks je wielokrotność 3 i bydzie przibliżać do sześcianu wpis cołkowity, jeźli jego indeks je wielokrotność 4 a niy wielokrotność 3. Funkcyjo niy zmiyni wpisōw na liście, kerych indeksy niy sōm wielokrotności 3 abo 4. Funkcyjo musi potym zmiynić suma wszyskich wpisōw. Przikłady: dlŏ lst = [1,2,3] wyjście powinno być 6 dlŏ lst = [] wyjście powinno być 0 dlŏ lst = [-1,-5,2,-1,-5] wyjście powinno być -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,szl_Latn,python,"
def words_in_sentence(sentence):
    """"""Dostaniesz sznur, co reprezyntuje zdanie, zdanie zawiyro pora słōw ôddzielōnych przestrzyniōm, a musisz zwrócić sznur, co zawiyro słowa z oryginalnego zdania, kerych dugości sōm liczbami piyrsze, porzōndek słōw w nowym sznurze musi być taki sōm jak w oryginalnym. Przikłod1: Wkludzynie: zdanie = ""to je test"" Wkludzynie: ""to je"" Przikłod2: Wkludzynie: zdanie = ""dŏwajymy sie pływać"" Wkludzynie: ""go for"" Ugraniczynia: * 1 <= len(zdanie) <= 100 * Zdanie zawiyro ino litery """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,szl_Latn,python,"
def simplify(x, n):
    """"""Twoje zadanie to je wdrożyni funkcyje, co uprości wyrażynie x * n. Funkcyjo zwroci Wiary, jeźli x * n wynikŏ na liczba cołko, a Falsz, jeźli niy. Ôba x i n sōm reprezyntacyjōm liczb ułōmnych, i majōm ta zorta, <licznik>/<mianownik>, kaj ôba mianownik i mianownik sōm dodatniōm liczbami cołkimi. Możesz założyć, iże x i n sōm prawidłowymi ułōmkami i niy majōm nule za mianownik.""""""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,szl_Latn,python,"
def order_by_points(nums):
    """"""Napisz funkcyjõ, co zorganizuje danyŏ lista liczb cołkowitych we wzrōstajōncym porzōndku podle sumy jejich cyfr. Uwaga: jeźli je pŏrã elymyntōw ze podobnōm sumōm jejich cyfr, porzōndkuj je podle jejich indeksu we ôryginalnyj listie. Na przikłŏd: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,szl_Latn,python,"
def specialFilter(nums):
    """"""Napisz funkcyjõ, co bierze za wejściówka maszyna liczb i zwraco liczba elymyntōw we maszyńdzie, co je srogsze aniżeli 10 i co piyrsze jak i ôstatnie cyfry liczby sōm niyparzyste (1, 3, 5, 7, 9). Na przikłŏd: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,szl_Latn,python,"
def get_max_triples(n):
    """"""Dodajymy liczba trzi razy (a[i], a[j], a[k]) a, kaj i < j < k, a a[i] + a[j] + a[k] je wielokrotność 3. Przikłod: wejście: n = 5 wyjście: 1 Wyjaśniynie: a = [1, 3, 7, 13, 21] Jedyne ważne trzi razy to (1, 7, 13).""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,szl_Latn,python,"
def bf(planet1, planet2):
    '''W naszym Układzie Słōnecznym je ôziym planet: nojbliższŏ do Słōńca to Merkury, nastympno to Wenus, potym Ziymia, Mars, Jowisz, Saturn, Uran, Neptun. Napisz funkcyjõ, co bierze dwa miana planet za sztrōny planet1 i planet2. Funkcyjŏ powinna zwrōcić tupla, co zawiyro wszyjske planety, kere sōm na ôrbitach miyndzy ôrbitōm planety1 a ôrbitōm planety2, sortowane podle bliskości do Słōńca. Funkcyjŏ powinna zwrōcić pusty tupla, jeźli planeta1 abo planeta2 niy sōm poprawnymi mianami planet. Przikłady bf""{\displaystyle bf} , ""Jupiter"", ""Neptun"") ==> (""Saturn"", ""Uran"") bf{\displaystyle bf} , ""Earth"", ""Mercury"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Sn"") }}'''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,szl_Latn,python,"
def sorted_list_sum(lst):
    """"""Napisz funkcyjõ, co akceptuje listã strōn za parymetry, usuwa strōny, co majōm niyporzōndno dugość, i zwraco wynik listy z porzōndkowanym porzōndkiem. Lista je dycki listōm strōn, a niy ma matrycym liczb, a może zawiyrać duplikatōw. Porzōndek listy musi być wznoszōncy sie podle dugości kożdego słowa, a ty powiniynś zwracać listã sortowanõ podle tyj reguły. Jeźli dwa słowa majōm ta sama dugość, sortuj listã alfabetycznie. Funkcyjŏ powinna zwracać listã strōn w porzōndku sortowanym. Możesz założyć, iże wszyjske słowa bydōm mieć ta sama dugość. Na przikłŏd: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd"")""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,szl_Latn,python,"
def x_or_y(n, x, y):
    """"""Prosty program, co musi zwrocić wert x jeźli n je liczbōm piyrszo, a w inkszym wypadku wartość y. Przikłady: dlŏ x_abo_y{\displaystyle x_or_y{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}{\displaystyle x_or_y}}""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,szl_Latn,python,"
def double_the_difference(lst):
    '''Zbiyrŏ sie lista liczb, ôdnŏwŏ sumã kwadratōw liczb niyporzōndnych z listy. Niy bierŏ sie pod uwagę liczb, co sōm ujymne abo niy sōm cołkowite. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Jeźli lista je prōzna, ôdnŏwŏ sie 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,szl_Latn,python,"
def compare(game,guess):
    """"""Mysle, ze wszyscy pamietamy to uczucie, kiedy wynik jakiegoś dlugo oczekiwanego zdarzynio w koncu sie dowiaduje. Uczucia i myśli, ktore masz w tamtym momencie, zdecydowanie warto zapisac i porównac. Twoim zadaniem jest ustalenie, czy osoba poprawnie zgadywala wyniki wielu meczy. Dowo sie dwa tabele wyników i zgadywań o równej dlugości, gdzie kazdy indeks pokazuje dopasowanie. Zwracaj tabele o tej samej dlugości, ktore wskazuja jak daleko od siebie byl kazdy zgadywal. jesli zgadywali sie poprawnie, wartość to 0, a jesli nie, wartość to absolutna roznica miedzy zgadywaniem i wynikiem. prziklad: ((([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3] compare ((([0,5,0,0,4],[4,1,0,-2]) -> [4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,szl_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Znojdziecie miano klasy (kōnsek) i listã rozszyrzyń. Rozszyrzyń bydōm używane do załadowanio ekstra klas do klasy. Moc rozszyrzyń je takŏ: CAP je liczbōm wielkich liter w mianie rozszyrzyniŏ, a SM je liczbōm małych liter w mianie rozszyrzyniŏ, moc je danŏ ôd ułōmka CAP - SM. Trza znojś najsilniyjsze rozszyrzyniŏ i zwrōcić kōmynto we takim formie: ClassName.StrongestExtensionName. Jeźli sōm dwa abo wiyncyj rozszyrzyń ô tym samym mocie, trza ôbrać tyn, co je piyrszy na liście. Na przikłŏd, jeźli dostŏwŏcie ""Slices"" za klasa i listã rozszyrzyń: ['SEviviRNGliSCes', 'Cheese', 'StuFfed'], to trza zwrōcić 'Slices.SEviRNGliSliCes' bo 'SEviRNGliCes' je nojmocniyjsze', przikłŏdnie jak rozszyrzyń: 'AA' (przikłŏd: 'AA_Beast_class'), tōż trza zwrōcić 'AA' za nojlepszy', przikłŏ moc 'AA' (przikłŏd: 'AA'_class' = Strongest_Extension_')""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,szl_Latn,python,"
def cycpattern_check(a , b):
    """"""Dowo sie dwa słowa. Trza zwrōcić True, jeźli drugie słowo abo kożdy z jego ôbtoczyń je podkōmōrōm w piyrszym słowie cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,szl_Latn,python,"
def even_odd_count(num):
    """"""Zŏbrane liczba cołko, zwraca tupla, co mŏ liczba liczb parzōnych i niyparzōnych. Przikłod: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,szl_Latn,python,"
def int_to_mini_roman(number):
    """"""Podajōnc dodatnŏ liczba cołkowito, dostŏwcie rōwnoważny jij rōmana jako strōng i wrōćcie go małymi literami.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,szl_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Podajōm dugości trzech strōn trōjkōntu. Zwrōć Trześć, jeźli te trzi strōny tworzōm trōjkōnk prostokōntny, Wartŏ w inkszym wypadku. Trōjkōnk prostokōntny to trōjkōnk, w kerym jedyn szrōt je prostokōntny abo 90°. Przikłod: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,szl_Latn,python,"
def find_max(words):
    """"""Napisz funkcyjõ, co akceptuje listã strōn. Lista zawiyro roztōmajte słowa. Zwrōć słowo z maksymalnōm liczbōm niyôbyczajnych znakōw. Jeźli mocka strōn mo maksymalnŏ liczba niyôbyczajnych znakōw, zwrōć to, co je piyrsze w lyksykograficznym porzōndku.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,szl_Latn,python,"
def eat(number, need, remaining):
    """"""Je żeś głodnym krōlikym, a już żeś zjodł pewnõ liczba marchwi, ale terŏzki musisz zjeść wiyncyj marchwi, coby skōńczyć dziynne posiłki. Trza zwrōcić tabula [wŏżno liczba zjodziōnych marchwi po posiłku, liczba marchwi ôstałych po posiłku] jeźli niy ma dostãpnŏ liczby ôstałych marchwi, zjesz wszyjske ôstałe marchwi, ale bydziesz durch głodny. Przikłŏd: * zjodź(5, 6, 10) -> [11, 4] * zjodź(4, 8, 9) -> [12, 1] * zjodź(1, 10, 10) -> [11, 0] * zjodź(2, 11, 5) -> [7, 0] Zmiynne: @number: liczba cołkowita marchwi, co żeś jōł. @need: liczba cołkowita marchwi, co musisz zjeść. @remaining: liczba cołkowita marchwi, co ôstały w magazynie. Constrain: *0== <= 0 * 0 = <= 1000 * 0 = <= 1000 * 0 = <= 1000 = 0 = 1000""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,szl_Latn,python,"
def do_algebra(operator, operand):
    """"""Podane dwie listy ôperacyje i ôperanda. Piyrszy list mŏ bazowe ôperacyje algebry, a drugi list je listōm liczb cołkowitych. Użyj tych dwōch list do zbudowanio wyrażyniŏ algebrycznego i zwrōć ôcyna tego wyrażyniŏ. Bazowe ôperacyje algebry: przidowanie (+) ôdyjmowanie (-)) mnożynie (*) dzielynie podłōżne (//) eksponyncja (**) Przikłod: ôperacyjŏ['+', '*', '-'] maszyna = [2, 3, 4, 5] wynik = 2 + 3 * 4 - 5 => wynik = 9 Uwaga: Dłōżka listy ôperacyje je rōwno dugości listy ôperanda minus jedna. Ôperanda to lista liczb cołkowitych niynegatywnych. Ôperacyjŏ mŏ co nojmynij jednego ôperacjowego, a lista ôperanda co nojmynij dwōch ôperandōw. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,szl_Latn,python,"
def solve(s):
    """"""Jeźli s[i] je literōm, to ôdwrōć jego przipadek z dolnego na gōry abo na ôpaczny, w inkszym razie zachowaj go tak, jak je. Jeźli string niy mŏ żŏdnych liter, ôdwrōć string. Funkcyjŏ powinna zwrōcić wynik sztringu. Przikłady solve{""1234"") = ""4321""{""ab"") = ""AB""{""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,szl_Latn,python,"
def string_to_md5(text):
    """"""Wrōć ôdpednio wielość 'text', jeźli to je pusty wielość, to wrōć None.""""""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,szl_Latn,python,"
def generate_integers(a, b):
    """"""Zdŏwane dwie dodatnie liczby cołkowite a i b, zwracajōm cyfry parzne miyndzy a i b, w porzōndku wzrōstajōncym. Na przikłŏd: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
