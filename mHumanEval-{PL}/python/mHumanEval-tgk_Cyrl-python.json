[
    {
        "task_id": "HumanEval/0",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Санҷед, ки оё дар рӯйхати рақамҳои додашуда, ягон ду рақам аз ҳадди додашуда ба ҳам наздиктар аст. Мисол: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Ин функсия як сатрро, ки дорои гурӯҳҳои зиёди дубора басташударо дар бар мегирад, дохил мекунад. Мақсади шумо ҷудо кардани ин гурӯҳҳо ба сатрҳои алоҳида ва баргардонидани рӯйхати онҳо мебошад. Гурӯҳҳои алоҳида мувозинат доранд (ҳар як дубора кушода дуруст баста мешавад) ва дар дохили якдигар ҷойгир нашудаанд.\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Бо назардошти рақами мусбати нуқтаи шинокунанда, он метавонад ба қисми адад ва қисми адад (бузургтарин адад аз адади додашуда хурдтар) ва даҳҳо (қисми боқимонда ҳамеша аз 1 хурдтар) ҷудо карда шавад. Қисми даҳҳоӣ аз ададро баргардонед. Мисол: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Шумо рӯйхати амалиёти пасандоз ва бозпас гирифтани суратҳисоби бонкиро, ки бо тавозуни сифр оғоз меёбад, ба шумо дода мешавад. Вазифаи шумо ин аст, ки дар ягон нуқта тавозуни суратҳисоб аз сифр поёнтар шавад ва дар он нуқта функсия бояд True -ро баргардонад. Дар акси ҳол он бояд False -ро баргардонад. Мисол: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Барои рӯйхати додашудаи рақамҳои вуруд, Тафовути мутлақи миёнаро дар атрофи миёнаи ин маҷмӯи маълумот ҳисоб кунед. Тафовути мутлақи миёна фарқи миёнаи мутлақи байни ҳар як унсур ва нуқтаи марказӣ (миёна дар ин ҳолат): MAD = миёна. x - x_mean. Мисол: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Миёни ҳар ду унсури пайдарпайи рӯйхати вуруд рақами \"делимтер\" ворид кунед `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Ба ин функсия як сатр ворид карда мешавад, ки гурӯҳҳои сершумори скопҳои дар байни худ ҷойгиршударо бо фосилаҳо ҷудо мекунад. Барои ҳар як гурӯҳ, сатҳи амиқи скопҳои скопҳоро бароред. Масалан (() (()) дорои ҳадди аксар ду сатҳи скопҳо мебошад, дар ҳоле ки ((())) дорои се. >>> parse_nested_parens (('((()) ((())) () (((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Рӯйхати вуруди сатрҳоро танҳо барои онҳое, ки дорои зерсатри додашуда мебошанд, филтр кунед >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Барои рӯйхати додашудаи ададҳои бутун, як tuple-ро, ки аз ҷамъ ва ҳосили ҳамаи ададҳои бутун дар рӯйхат иборат аст, баргардонед. Ҷамъи холӣ бояд ба 0 баробар бошад ва ҳосили холӣ бояд ба 1 баробар бошад. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Аз рӯйхати додашудаи ададҳои бутун, рӯйхати унсури максимуми доимии то лаҳзаи додашуда дар пайдарпаӣ пайдо кунед. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Кӯтоҳтарин палиндромеро, ки бо сатри додашуда оғоз меёбад, ёбед. Фикри алгоритм оддӣ аст: - Дарозтарин пас аз сатри додашударо, ки палиндром аст, ёбед. - Ба охири сатр пешоянди сатри пеш аз пасванди палиндромӣ илова кунед. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Санҷиш, агар сатри додашуда палиндром бошад \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Вуруди ду сатр a ва b, ки танҳо аз 1 ва 0 иборат аст. XOR дуӣ дар ин вурудҳо иҷро кунед ва натиҷаро ҳамчун сатр баргардонед. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Аз рӯйхати сатрҳо, дарозтаринро баргардонед. Дар сурати зиёда аз як сатри дарозии якхела, аввалинро баргардонед. Дар сурати рӯйхати вуруд холӣ будан, ҳеҷ чизро баргардонед. >>> дарозтарин (([]) >>> дарозтарин ((['a', 'b', 'c']) 'a' >>> дарозтарин ((['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Буридани бузургтарин тақсимкунандаи умумии ду адади a ва b >>> бузургтарин_ тақсимкунандаи умумии ((3, 5) 1 >>> бузургтарин_ тақсимкунандаи умумии ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Рӯйхати ҳамаи префиксҳоро аз кӯтоҳтарин то дарозтарин сатри вуруд >>> all_prefixes (('abc') ['a', 'ab', 'abc']  баргардонад\"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"Силсилаи дорои рақамҳои дорои фазоро аз 0 то n дохил мекунад. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Дар сатри додашуда, бифаҳмед, ки аз чанд аломати ҷудогона (беэътибор аз калима) иборат аст >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Ин функсияро ба як сатр ворид кунед, ки дар формати ASCII муаррифӣ шудааст. Вазифаи шумо ин аст, ки рӯйхати сатрҳои сатрҳои мукаммали мутобиқ ба бисёр зарбаҳоро таҳлил кунед. Ин ҷо як оят аст: 'o' - нота, охирин зарбаҳо 'o' - чор зарбаҳо 'node' - ним нота, охирин ду зарба 'node' - чортарафаи нота, охирин зарбаҳо >>> parse_music '. 'o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Бифаҳмед, ки чанд маротиба як зерсанҷи додашударо дар сатри аслӣ пайдо кардан мумкин аст. Ҳолатҳои барҳамдиҳиро ҳисоб кунед. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Вуруди сатри рақамҳои аз 'сафара' то 'наво' аст. Интихобҳои дуруст 'сафара', 'як', 'ду', 'се', 'чор', 'панҷ', 'шаш', 'ҳафт', 'ҳашт' ва 'наво' мебошанд. Силсилаи рақамҳоро аз хурдтарин то калонтарин >>> sort_numbers (('се як панҷ') 'як се панҷ' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"Аз рӯйхати рақамҳои пешниҳодшуда (дарозии ҳадди аққал ду) ду рақамро интихоб кунед ва ду рақамро, ки ба ҳам наздиктаранд, баргардонед ва онҳоро бо тартиб баргардонед (рақами хурдтар, рақами калонтар). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Рӯйхати рақамҳоро (аз ҳадди аққал ду унсур) дода, ба ин рӯйхат табдилдиҳии хаттиро татбиқ кунед, то ки шумораи хурдтарин 0 ва калонтарин 1 шавад >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Филтр рӯйхати додашудаи ҳама гуна арзишҳои Python танҳо барои ададҳои куллӣ >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"Дарозии бозгашти сатри додашуда >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Барои адади додашуда n, бузургтарин ададро, ки n-ро баробар тақсим мекунад, ё хурдтар аз n >>> бузургтарин_ тақсимкунандаро пайдо кунед ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Рӯйхати омилҳои аввалини адади мукаммали додашударо аз хурдтарин то калонтарин баргардонед. Ҳар як омил бояд ба шумораи маротибаҳо мувофиқ бошад, ки ба чанд маротиба дар омилҳо пайдо мешавад. Шумораи вуруд бояд ба ҳосили ҳамаи омилҳо баробар бошад >>> омилгузорӣ ((8) [2, 2, 2] >>> омилгузорӣ ((25) [5, 5] >>> омилгузорӣ ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Аз рӯйхати ададҳои бутун, ҳамаи унсурҳоро, ки зиёда аз як маротиба пайдо мешаванд, хориҷ кунед. Тартиби унсурҳои боқимондаро ҳамон тавре ки дар вуруд нигоҳ доред. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Барои сатри додашуда, аломатҳои хурд ба калон ва калон ба хурд иваз кунед. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Рӯйхати сатрҳои пайвастшуда ба як сатри ягона >>> пайвастшуда (([]) '' >>> пайвастшуда ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Рӯйхати вуруди сатрҳоро танҳо барои онҳое, ки бо префикси додашуда сар мешаванд, филтр кунед. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Танҳо рақамҳои мусбатро дар рӯйхат баргардонед. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"Агар рақами додашуда рақами аввалия бошад, дуруст ва дар акси ҳол дурӯғро баргардонед. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs коэффитсиентҳои бисёрсоҳа мебошанд. find_zero x -ро пайдо кунед, ки poly ((x) = 0. find_zero танҳо нуқтаи сифрро бармегардонад, ҳатто агар бисёре бошанд. Ғайр аз он, find_zero танҳо рӯйхати xs -ро бо шумораи коэффитсиентҳо ва бузургтарин коэффитсиенти ғайри сифр мегирад, зеро он ҳалли худро кафолат медиҳад. >>> round (((find_zero[1, 2]), 2) # f ((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6^2 + x^3  1.0 \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"Бо коэффисиентҳои xs дар нуқтаи x. баргардонидани xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Ин функсия рӯйхати l-ро мегирад ва рӯйхати l'-ро бармегардонад, ки l' бо l дар индексҳое, ки бо се тақсим намешаванд, якхела аст, дар ҳоле ки арзишҳои он дар индексҳое, ки бо се тақсим мешаванд, ба арзишҳои индексҳои мувофиқи l баробар аст, аммо тартиб дода шудааст. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"Элементҳои ягонаи тартибдодашударо дар рӯйхат бозмегардонад >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Элементи ҳадди аксарро дар рӯйхат баргардонед. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Шумораи маротибаҳои пайдошавии рақами 7 дар ададҳои бутун, ки аз n камтар ва бо 11 ё 13 тақсимшавандаанд, баргардонда шавад. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Ин функсия рӯйхати l-ро мегирад ва рӯйхати l'-ро бармегардонад, ки l' бо l дар индексҳои нобарор баробар аст, дар ҳоле ки арзишҳои он дар индексҳои ҷуфт ба арзишҳои индексҳои ҷуфт баробар аст, аммо тартиб дода шудааст. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"ҳамчун сатри вуруди рамзгузорӣшударо бо функсияи encode_cyclic мегирад. Сатри рамзшудаи рамзшударо бармегардонад. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"сатри рамзгузорӣшударо аз рӯи гурӯҳҳои даврагирифтаи се аломат бармегардонад. \"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib рақами n-умро, ки рақами Фибоначчи аст, баргардонад ва он ҳам рақами аввалин аст. >>> prime_fib ((1) 2 >>> prime_fib ((2) 3 >>> prime_fib ((3) 5 >>> prime_fib ((4) 13 >>> prime_fib ((5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero рӯйхати ададҳои пурраро ҳамчун вуруд мегирад. он ҳақиқӣ бармегардонад, агар дар рӯйхат се унсури алоҳида мавҷуд бошанд, ки ба сифр ҷамъ шаванд ва дар акси ҳол дурӯғ аст. >>> triples_sum_to_zero (([1, 3, 5, 0]) дурӯғ аст >>> triples_sum_to_zero (([1, 3, -2, 1]) рост >>> triples_sum_to_zero (([1, 2, 3, 7]) дурӯғ аст >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) рост >>> triples_sum_to_zero [1]) дурӯғ \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Тасаввур кунед, ки дар роҳ як хатти беохир дароз аст. n мошин аз чап ба рост ҳаракат мекунанд; ҳамзамон, як қатор мошинҳои n ба рост ба чап ҳаракат мекунанд. Ду қатор мошинҳо аз ҳамдигар хеле дур мебошанд. Ҳамаи мошинҳо бо суръати якхела ҳаракат мекунанд. Ду мошин ҳангоми бархӯрд бо мошини аз чап ба рост ҳаракаткунанда ба мошини аз рост ба чап ҳаракаткунанда бархӯрдан мегӯянд. Аммо, мошинҳо беохир устувор ва қавӣ мебошанд; дар натиҷа, онҳо дар траекторияи худ ҳаракат мекунанд, гӯё ки бархӯрд накардаанд. Ин функсия шумораи чунин бархӯрдҳоро бароварда мекунад. \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Рӯйхати баргардонидашуда бо унсурҳои бо 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero рӯйхати ададҳои пурраро ҳамчун вуруд мегирад. он ҳақиқӣ бармегардонад, агар дар рӯйхат ду унсури мухталиф мавҷуд бошанд, ки ба сифр ҷамъ шаванд ва дар акси ҳол дурӯғ аст. >>> pairs_sum_to_zero (([1, 3, 5, 0]) дурӯғ аст >>> pairs_sum_to_zero (([1, 3, -2, 1]) дурӯғ аст >>> pairs_sum_to_zero (([1, 2, 3, 7]) дурӯғ аст >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) рост >>> pairs_sum_to_zero (([1]) дурӯғ аст \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Тағйир додани асоси рақамии рақами вуруди x ба асос. пас аз табдилдиҳӣ намояндагии сатрро баргардонед. рақамҳои асос камтар аз 10 мебошанд. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Бо назардошти дарозии канори ва майдони баланд баргардонидани сегона. >>> сегона_миқёси ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Силсилаи рақамҳои Fib4 як силсилаи монанд ба силсилаи Фибоначчи мебошад, ки чунин муайян карда шудааст: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Лутфан функсияеро нависед, ки унсури n-умро аз силсилаи рақамҳои fib4 самаранок ҳисоб кунад. Рекурсияро истифода набаред. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"Миёнагии баргардонидани унсурҳои рӯйхат l. >>> миёна (([3, 1, 2, 4, 5]) 3 >>> миёна (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Санҷиш мекунад, ки оё сатри додашуда палиндром аст >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Бозгашти 2 ^ n модули p (ба рақамҳо огоҳ бошед). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"ҳамчун сатри вуруди рамзгузорӣшударо бо функсияи encode_shift мегирад. Сатри рамзшудаи рамзшударо бармегардонад. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"string-и рамзгузорӣшударо бо гузаронидани ҳар як аломат дар алифбо бо 5 бармегардонад.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels функсияест, ки сатрро мегирад ва сатрро бе овозҳо бармегардонад. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Агар ҳамаи рақамҳои рӯйхат дар зери ҳадди t бошанд, ростро баргардонед. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Ду адад x ва y илова кунед >>> илова кунед ((2, 3) 5 >>> илова кунед ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"Санҷед, ки оё ду калима аломатҳои якхела доранд. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Рост >>> same_chars (('abcd', 'dddddddddabc') Рост >>> same_chars (('dddddddabc', 'abcd') Рост >>> same_chars (('eabcd', 'dddddddddabc') Дурӯғ >>> same_chars ((('abcd', 'dddddddabddce') Дурӯғ >>> same_chars' (((abcdzzzz', 'dddzzzzzzdddabc') Дурӯғ \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"Шумораи n-уми Фибоначчиро баргардонед. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets як сатри \"<\" ва \">\". баргардонад Рост аст, агар ҳар як дастгоҳи кушодашавӣ дорои дастгоҳи пӯшидашавӣ бошад. >>> correct_bracketing (((\"<\") False >>> correct_bracketing ((\"<>\") True >>> correct_bracketing ((\"<><>>\") True >>> correct_bracketing (((\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Бозгашти ҳақиқӣ ин аст, ки унсурҳои рӯйхат якранг афзоиш ё коҳиш меёбанд. >>> якранг (([1, 2, 4, 20]) True >>> якранг (([1, 20, 4, 10]) False >>> якранг (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Элементҳои ягонаи муштараки ҷудошудаи ду рӯйхатро бармегардонад. >>> умумӣ (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> умумӣ (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Бузургтарин омили аввалияи n-ро баргардонед. Фарз кунед, ки n > 1 ва омили аввалия нест. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n функсияест, ки ададҳои аз 1 то n-ро ҷамъ мекунад. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets як сатри \"(\" ва \")\". баргардонад Рост аст, агар ҳар як дастгоҳи кушодашавӣ дорои дастгоҳи пӯшидашавӣ бошад. >>> correct_bracketing (((\"(\") False >>> correct_bracketing (((\")) True >>> correct_bracketing (((()) True >>> correct_bracketing (((()) False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs коэффитсиентҳои бисёршаклиро ифода мекунад. xs[0] + xs[1] * x + xs[2] * x^2 + .... Деривати ин бисёршаклиро дар ҳамон шакл баргардонед. >>> derivative (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivative[(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Силсилаи рақами FibFib як силсилаи монанд ба силсилаи Fibbonacci мебошад, ки чунин муайян карда шудааст: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Лутфан функсияеро нависед, ки унсури n-уми силсилаи рақами fibfib-ро самаранок ҳисоб кунад. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"Функсияи vowels_count нависед, ки сатри ифодакунандаи калимаро ҳамчун вуруд мегирад ва шумораи овозҳоро дар сатр бармегардонад. Овозҳо дар ин ҳолат 'a', 'e', 'i', 'o', 'u' мебошанд. Дар ин ҷо, 'y' низ овоз аст, аммо танҳо вақте ки он дар охири калимаи додашуда аст. Мисол: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"Илова кардани ҳолатҳои озмоишӣ. \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Даврача рақамҳои адади x-ро ба тарафи рост гузаронед ва натиҷаро ҳамчун сатр баргардонед. Агар shift > шумораи рақамҳо бошад, рақамҳои баръакс баргардонед. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"Вазифа Функсияе нависед, ки сатрро ҳамчун вуруд қабул мекунад ва танҳо ҷамъбасти аломатҳои болоӣ ASCII-ро бармегардонад. Мисолҳо: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"Дар ин вазифа, ба шумо сатр дода мешавад, ки шумораи себ ва зардолуро дар сабади меваҳо тақсим мекунад. Ин сабад дорои себ, зардолу ва меваҳои манго мебошад. Бо назардошти сатр, ки шумораи умумии зардолу ва себ ва адади мукаммалеро, ки шумораи умумии меваҳоро дар сабад ифода мекунад, шумораи меваҳои мангоро дар сабад баргардонед. барои мисол: fruit_distribution\"5(себ ва 6 зардолу\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 себ ва 1 зардолу\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 себ ва 3 зардолу\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 себ ва 120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"Барои массиви намояндаи шохаи дарахте, ки дорои гиреҳҳои адади мукаммали манфӣ аст, вазифаи шумо ин аст, ки яке аз гиреҳҳоро кашида гиред ва онро баргардонед. Гиреҳи кашидашуда бояд гиреҳи бо арзиши хурдтарини ҳам бошад. Агар гиреҳҳои сершумор бо арзиши хурдтарини ҳам пайдо шаванд, гиреҳи бо индекси хурдтарин баргардонед. Гиреҳи кашидашуда бояд дар рӯйхат баргардонида шавад, [smallest_value, index] Агар арзишҳои ҳам набошанд ё массиви додашуда холӣ бошад, баргардонед []. Мисол: 1: Воридот: [4,2,3] Маҳсулот: [2, 1] Шарҳ: 2 арзиши хурдтарини ҳам дорад ва 2 индекси хурдтарин дорад. Мисол 2: Воридот: [1,2,3] Маҳсулот: [2, 1] Шарҳ: 2 арзиши хурдтарин дорад ва 2 индекси хурдтарин дорад. Мисол 3: Воридот: [] Маҳсулот: [] Воридот: [4: [5, 3, 4, 2] Воридот: [0, 0] Маҳсули кашидашуда: 1 гиреҳ, ки дорои индекси хурдтарин аст, аммо ду нуқ дорад. Мисол: * Мисол: * дугул: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол: * мисол:\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''Шумо рӯйхати холӣ набудани ададҳои мусбатро мегиред. Бузургтарин адади мусбатро баргардонед, ки аз сифр бузургтар аст ва доираи он аз арзиши худи адад зиёдтар ё баробар аст. Дараҷаи адади мусбате шумораи маротибае аст, ки дар рӯйхат пайдо мешавад. Агар чунин арзиш вуҷуд надошта бошад, баргардонед -1. Мисолҳо: ҷустуҷӯ (([4, 1, 2, 2, 3, 1]) == 2 ҷустуҷӯ ([1, 2, 2, 3, 3, 3, 4, 4]) == 3 ҷустуҷӯ ([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''Рӯйхати ададҳои пурраи додашуда, рӯйхати баргардонидашударо бо тартиби аҷиб. Ҷамъбасти аҷиб он аст, ки шумо бо арзиши ҳадди ақал оғоз мекунед, пас аз ҳадди аксар ададҳои боқимонда, пас аз ҳадди ақал ва ғайра. Мисолҳо: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''Бо назардошти дарозии се тарафи секунҷа. Агар се тараф секунҷаи дуруст ташкил кунанд, майдони секунҷаро ба 2 нуқтаи даҳякӣ мудаввар кунед. Дар акси ҳол, -1 баргардонед Се тараф секунҷаи дуруст ташкил мекунанд, вақте ки суммаи ҳар ду тараф аз тарафи сеюм калонтар аст. Мисол: triangle_area (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), ( (), (), (), (), ( (), ( (), ( (), (), (), ( (), ( (), (), (), ( ( (), ( (), (), (), ( (), ( (), ( (), (), ( ( (), ( (), (), ( (), (), ( ( (), (), ( (), ( (), (), ( (), ( (), (), ( (), ( (), (), ( (), ( (), (), ( (), ( (), ( (), (), (), (), (), ( (), ( (), (), ( (), ( (), ( (), ( ( (), (), (), ( (), (), (), ( (), (), ( (), (), ( (), (), ( (), ( (), (), ( ( ( (), (), (), ( (), ( ( (), (), (), ( ( (), (), (), ( (), (), (), ( ( (), (), ( (), ( (), ( (), (), (), ( ( ('''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''Функсияе нависед, ки агар объекти q парвоз кунад ва дар акси ҳол дурӯғ бошад, дуруст аст. Объект q парвоз мекунад, агар он мувозинат дошта бошад (ин рӯйхати палиндромӣ аст) ва ҷамъи унсурҳои он аз вазни максималии имконпазир камтар ё баробар бошад w. Мисол: will_it_fly (([1, 2], 5) â -> False # 1+2 аз вазни максималии имконпазир камтар аст, аммо он номувозинат аст. will_it_fly (([3, 2, 3], 1) â -> False # он мувозинат дорад, аммо 3+2+3 аз вазни максималии имконпазир зиёдтар аст. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 аз вазни максималии имконпазир камтар аст ва он мувозинат аст. will_it_fly ((([3], â 5) -> True # 3 аз вазни максималии имконпазир камтар аст ва он мувозинат аст. '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"Дар массиви arr ададҳои пурра дода шуда, шумораи камтарини унсурҳоро, ки барои тағйир додани массив palindromic лозим аст, ёбед. Массиви palindromic массивест, ки ба қафо ва пеш ҳамон чизро мехонад. Дар як тағирот, шумо метавонед як унсурро ба ягон унсури дигар тағир диҳед. Масалан: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''Функсияе нависед, ки ду рӯйхати сатрҳоро қабул кунад ва рӯйхати дорои шумораи умумии аломатҳоро дар ҳамаи сатрҳои рӯйхат камтар аз рӯйхати дигар баргардонад. агар ду рӯйхат шумораи умумии аломатҳоро дошта бошанд, рӯйхати аввалро баргардонед. Мисолҳо total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi'], 'hi'_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Функсияе нависед, ки агар рақами додашуда зарбаи 3 адади якум бошад ва дар акси ҳол дурӯғ бошад. Донистани он, ки (а) камтар аз 100 аст. Мисол: is_multiply_prime(30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Вазифаи шумо ин навиштани функсияест, ки агар рақами x қудрати оддии n бошад ва дар ҳолатҳои дигар дурӯғ бошад. x қудрати оддии n аст, агар n**int=x Масалан: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''Функсияе нависед, ки адади a-ро мегирад ва агар ин адад куби ягон адади рост бошад, дуруст бармегардонад. Эзоҳ: шумо метавонед воридотро ҳамеша дуруст ҳисоб кунед. Мисолҳо: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"Шумо вазифадор карда шудаед, ки функсияеро нависед, ки рақами шашдаҳгонаро ҳамчун сатр қабул мекунад ва шумораи рақамҳои шашдаҳгонаро, ки рақамҳои аввалия мебошанд, ҳисоб мекунад (рақами аввалия ё рақами аввалия рақами табиӣ аст, ки аз 1 бузургтар аст, ки маҳсули ду рақами табиии хурдтар нест). Рақамҳои шашдаҳгонаи 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F мебошанд. Рақамҳои аввалия 2, 3, 5, 7, 11, 13, 17 ... мебошанд. Пас, шумо бояд шумораи рақамҳои зеринро муайян кунед: 2, 3, 5, 7, B (= даҳгонаи 11), D (= даҳгонаи 13). Эзоҳ: шумо метавонед гумон кунед, ки вуруд ҳамеша дуруст ё холӣ аст сатр, ва рамзҳои A, B, C, D, E, F ҳамеша калон мебошанд. Мисолҳо: Барои num = AB, баромади он бояд num = 1. Барои num = 1077E, баромади он бояд 2. Барои num = \"AB\" бояд num = 1.331 бошад. Барои num = \"AB\" бояд num = 4. \"ABC\" = 6.06712345 \"A\" барои \"DEF\" бояд 6.0\" бошад. Барои \"2020\" баромади он бояд 2.0 бошад\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Шумо як рақами даҳӣ дода мешавед ва вазифаи шумо ин аст, ки онро ба формати дуӣ табдил диҳед. Функсия бояд сатрро баргардонад, ки ҳар як аломат рақами дуӣ мебошад. Ҳар як аломати сатр '0' ё '1' хоҳад буд. Дар ибтидо ва охири сатр як ҷуфти аломатҳои иловагӣ 'db' хоҳад буд. Аломатҳои иловагӣ барои кӯмак ба формат мавҷуданд. Мисолҳо: decimal_to_binary ((15) # \"db1111db\" -ро баргардонад decimal_to_binary32) # \"db100000db\" -ро баргардонад\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"Ба шумо сатр s дода мешавад. Вазифаи шумо санҷидани он аст, ки оё сатр хушбахт аст ё не. Сатр хушбахт аст, агар дарозии он ҳадди аққал 3 адад бошад ва ҳар 3 ҳарфи пайдарпай фарқ кунанд Масалан: is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Ин ҳафтаи охирини семестр аст ва муаллим бояд ба донишҷӯён баҳо диҳад. Муаллим алгоритми худро барои баҳогузорӣ сохтааст. Ягона мушкил ин аст, ки вай рамзи барои баҳогузорӣ истифодашударо гум кардааст. Вай ба шумо рӯйхати GPA-ро барои баъзе донишҷӯён додааст ва шумо бояд функсияе нависед, ки метавонад рӯйхати баҳоҳои номаро бо истифода аз ҷадвали зерин барорад: GPA.\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"Функсияе нависед, ки сатрро мегирад ва агар дарозии сатр рақами якум бошад, дуруст ё хато баргардонад Мисолҳо prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Бо назардошти як адади мусбати n, шумораи ададҳои мусбати n-рақамиро, ки бо 1 оғоз ё ба охир мерасанд, баргардонед. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"Барои n = 1000, суммаи рақамҳо 1 хоҳад буд, баромади он бояд \"1\" бошад. Барои n = 150, суммаи рақамҳо 6 хоҳад буд, баромади он бояд \"110\" бошад. Барои n = 147, суммаи рақамҳо 12 хоҳад буд, баромади он бояд \"1100\" бошад. Тағйирёбандаҳо: @N number Constraints: 0 â‰¤ N â‰¤ 10000. Output: a string of binary number \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"Бо назардошти рӯйхати холӣ набудани ададҳои бутун lst. унсурҳои ҷуфтро, ки дар индексҳои нобаробар ҳастанд, илова кунед .. Мисолҳо: илова кунед (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Функсияе нависед, ки сатрро мегирад ва версияи тартибдодаи онро бармегардонад. Версияи тартибдодаи сатр, сатрест, ки дар он ҳамаи калимаҳо (бо фосила ҷудо карда шудаанд) бо калимаи нав иваз карда мешаванд, ки дар он ҳамаи аломатҳо дар тартиби афзоянда дар асоси арзиши ascii тартиб дода шудаанд. Эзоҳ: Шумо бояд тартиби калимаҳо ва фазои холиро дар ҷумла нигоҳ доред. Масалан: anti_shuffle ((('Hi') бармегардонад 'Hi' anti_shuffle ((('hello') бармегардонад 'ehllo' anti_shuffle (('Hello World!!!') бармегардонад 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"Шумо маълумоти 2-асъӣ, ҳамчун рӯйхати нишебшуда, ки ба матритса монанд аст, аммо, ба фарқ аз матритсаҳо, ҳар сатр метавонад шумораи гуногуни сутунҳоро дар бар гирад. Бо назардошти lst ва адади бутун x, ададҳои бутун x -ро дар рӯйхат пайдо кунед ва рӯйхати tuples -ро баргардонед, [(x1, y1), (x2, y2) ...] чунон ки ҳар як тупл координата - (сатр, сутунҳо), сар аз 0.\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"Дар массиви ададҳои мукаммали ғайриманфии додашуда, пас аз танзимкунӣ нусхаи массиви додашударо баргардонед, шумо массиви додашударо бо тартиби болоравӣ тартиб медиҳед, агар сумма ((баҳои индекси аввал, арзиши индекси охирин) нобарор бошад, ё онро бо тартиби поёнравӣ тартиб диҳед, агар сумма ((баҳои индекси аввал, арзиши индекси охирин) ҷуфт бошад. Эзоҳ: * массиви додашударо тағир надиҳед. Мисолҳо: * sort_array[(]) => [] * sort_array([5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 6]  0\"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"Функсияи encrypt эҷод кунед, ки сатрро ҳамчун аргумент қабул кунад ва сатри рамзшударо бо гардиши алифбо баргардонад. Алифбо бояд ба тавре гардонида шавад, ки ҳарфҳо ба ду ҷой дучанд карда шаванд. Масалан: encrypt (('hi') 'lm' encrypt (('asdfghjkl') 'ewhjklnop' encrypt (('gf') 'kj' encrypt (('et') 'ix' -ро бармегардонад.\"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"Шумо рӯйхати ададҳои куллӣ додаед. Функсияи next_smallest () нависед, ки унсури 2-и хурдтарини рӯйхатро бармегардонад. Агар чунин унсур вуҷуд надошта бошад, ҳеҷ чизро барнагардонад. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == Ҳеҷ чиз next_smallest () [1, 1]) == Ҳеҷ чиз \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"Шумо як қатор калимаҳо дода мешавед ва вазифаи шумо шумораи дилгиршавиро ҳисоб кардан аст. дилгиршавӣ ҷумлаест, ки бо калимаи \"I\" оғоз меёбад. Ҷумлаҳо бо '.', '?' ё '! 'муайян карда мешаванд. Масалан: >>>_ дилгир аст (((\"Салом ҷаҳон\") 0 >>>_ дилгир аст ((\"Осмони кабуд аст. Офтоб дурахшон аст. Ман ин обу ҳаворо дӯст медорам\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''Функсияе эҷод кунед, ки 3 ададро мегирад. Агар яке аз рақамҳо ба ҷамъи ду рақами дигар баробар бошад ва ҳамаи рақамҳо ададҳои пурра бошанд, дуруст бармегардонад. Дар ҳама ҳолатҳои дигар дурӯғ бармегардонад. Мисолҳо any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) â -> True any_int{3.6, -2.2, 2) â -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"Функсияе нависед, ки паёмеро мегирад ва ба тавре рамзгузорӣ мекунад, ки он ҳарфҳои ҳарфро иваз мекунад, ҳамаи овозҳоро дар паём бо ҳарфе, ки дар алфавити англисӣ 2 ҷой пеш аз он овоз пайдо мешавад, иваз мекунад. Танҳо ҳарфҳоро қабул кунед. Мисолҳо: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Шумо бояд арзиши аввалини калонтаринро пайдо кунед ва ҷамъбасти рақамҳои онро баргардонед. Мисолҳо: Барои lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] натиҷа бояд 10 бошад Барои lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] натиҷа бояд 25 бошад Барои lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] натиҷа бояд 13 бошад Барои lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] натиҷа бояд 11 бошад Барои lst = [0,81,12,3,21,1] натиҷа бояд 3 бошад Барои lst = [1,8,2,1,7] натиҷа бояд 7 бошад\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Агар дар луғат ҳамаи калидҳо сатрҳои хурд бошанд ё ҳамаи калидҳо сатрҳои калон бошанд, пас баргардонидани False. Функсия бояд баргардонад False, агар луғати додашуда холӣ бошад. Мисолҳо: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) бояд баргардонад True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) бояд баргардонад False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) бояд баргардонад False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) бояд баргардонад False. check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"12345}) бояд баргардонад True.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"Функсияеро татбиқ кунед, ки як адади мукаммали ғайри манфӣ мегирад ва массиви n адади аввалини мукаммалеро, ки рақамҳои аввалин ва камтар аз n мебошанд, бармегардонад. Масалан: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"Функсияи ду ададро пур кунед, ки ду ададро мегирад ва маҳсули рақамҳои воҳиди онҳоро бармегардонад. Фарз мекунем, ки вуруд ҳамеша дуруст аст. Мисолҳо: афзоиш ((148, 412) бояд 16 баргардонад афзоиш ((19, 28) бояд 72. афзоиш ((2020, 1851) бояд 0 баргардонад афзоиш ((14,-15) бояд 20 баргардонад. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"Бо назардошти сатр s, шумораи овозҳои калонро дар индексҳои ҷуфт ҳисоб кунед. Масалан: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 медиҳад \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''Функсияе эҷод кунед, ки арзиши (санҷ) -и муаррифӣкунандаи ададро мегирад ва ба он наздиктарин адади куллро бармегардонад. Агар адад аз ду адади кулл баробар бошад, онро аз сифр давр занед. Мисолҳо >>> наздиктарин_самар (((\"10\") 10 >>> наздиктарин_самар (((\"15.3\") 15 Эзоҳ: Даврзании дур аз сифр маънои онро дорад, ки агар адади додашуда аз ду адади кулл баробар бошад, он чизеро, ки шумо бояд баргардонед, он чизест, ки аз сифр дуртар аст. Барои мисол, наздиктарин_самар \" ((14.5\") бояд 15 баргардонад ва наздиктарин_самар \" ((-14.5\") бояд -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"Бо назардошти як адади мусбати n, шумо бояд як қатор сангҳои n сатҳро созед. Дар сатҳи аввал n санг мавҷуд аст. Шумораи сангҳо дар сатҳи навбатӣ чунин аст: - шумораи навбатии ҷуфт, агар n ҷуфт бошад. - шумораи навбатии ҷуфт, агар n ҷуфт бошад. Шумораи сангҳоро дар ҳар як сатҳ дар рӯйхат баргардонед, ки дар он унсур дар индекси i шумораи сангҳоро дар сатҳ (i + 1) ифода мекунад. Мисолҳо: >>> make_a_pile ((3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"Шумо як сатри калимаҳо бо калимаҳо ё фосилаҳо ҷудо карда мешавед. Вазифаи шумо тақсим кардани сатр ба калимаҳо ва баргардонидани массиви калимаҳо мебошад. Масалан: words_string ((\"Салом, номи ман Ҷон аст\") == [\"Салом\", \"ман\", \"номи\", \"он\", \"Ҷон\"] words_string ((\"Як, ду, се, чор, панҷ, шаш\") == [\"Як\", \"ду\", \"се\", \"чор\", \"панҷ\", \"шаш\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"Ин функсия ду адади мусбатро x ва y мегирад ва бузургтарин адади мутлақи ҷуфтро, ки дар доираи [x, y] дохил карда шудааст, бармегардонад. Агар чунин адад вуҷуд надошта бошад, пас функсия бояд -1-ро баргардонад. Масалан: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Шумо ду адади мусбати n ва m дода шуда, вазифаи шумо ҳисоб кардани миёнаи ададҳои мусбатро аз n то m (аз ҷумла n ва m) мебошад. Ҷавобро ба адади мукаммал тақсим кунед ва онро ба дуӣ табдил диҳед. Агар n аз m калонтар бошад, баргардонед -1. Мисол: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"Рӯйхати ададҳои мусбати мусбатро дода, x. рӯйхати тартибдодашудаи ҳамаи унсурҳоро, ки рақами ҷуфт надоранд, баргардонед. Эзоҳ: Рӯйхати баргардонидашуда бояд бо тартиби афзоянда тартиб дода шавад. Масалан: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"Дар массиви ададҳои бутун, ададҳои бутунро, ки аз 1 то 9 дохил мешаванд, ҷудо кунед, массиви натиҷаро баръакс кунед ва пас ҳар як рақамро бо номи мувофиқи он аз \"Як\", \"Ду\", \"Се\", \"Чор\", \"Панҷ\", \"Шаш\", \"Ҳафт\", \"Ҳашт\", \"Нӯҳ\" иваз кунед. Масалан: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"Ҳашт\", \"Панҷ\", \"Се\", \"Ду\", \"Ду\", \"Як\", \"Як\"] Агар массив холӣ бошад, массиви холӣ баргардонед: arr = [] return [] Агар массив рақами ношинос дошта бошад, онро нодида гиред: arr = [1, -1 , 55] -> arr -> [1, 55] -> reverse arr = [55,1] return ['One' 1] ].\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"Функсияи f -ро иҷро кунед, ки n -ро ҳамчун параметр мегирад ва рӯйхати андозаи n -ро бармегардонад, ба тавре ки арзиши унсур дар индекси i омили i бошад, агар i ҷуфт бошад ё ҷамъбасти рақамҳои аз 1 то i бошад. i аз 1 оғоз меёбад. омили i зарбаҳои рақамҳои аз 1 то i (1 * 2 * ... * i) мебошад. Мисол: f ((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"Бо назардошти як адади мусбати n, як тупплро баргардонед, ки шумораи palindromes-и ҳам ва ҳам номутаносиб дорад, ки дар доираи ((1, n), аз ҷумла. Мисол1: Воридот: 3 Натиҷа: (1, 2) Шарҳ: Palindrome-и ҳам ва ҳам ва дуи онҳо номутаносиб аст. Мисол2: Воридот: 12 Натиҷа: (4, 6) Шарҳ: Palindrome-и ҳам ва дуи онҳо номутаносиб аст. Шарҳ: Palindrome-и ҳам ва дуи онҳо номутаносиб аст. Эзоҳ: 1. 1 <= n <= 10 ^ 3 2. тупл шумораи palindromes-и ҳам ва номутаносибро баргардонд. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"Функсияи count_nums нависед, ки массиви ададҳои куллро мегирад ва шумораи унсурҳоро, ки ҷамъи рақамҳои > 0 дорад, бармегардонад. Агар рақам манфӣ бошад, пас рақами аввалини имзошуда манфӣ хоҳад буд: масалан, -123 рақамҳои -1, 2 ва 3 -ро дорад. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Мо массиви 'arr' аз N ададҳои мукаммали arr[1], arr[2], ..., arr[N] дорем. Рақамҳои массив ба таври тасодуфӣ тартиб дода мешаванд. Вазифаи шумо муайян кардани он аст, ки оё имкон дорад, ки массивро бо тартиби камнашаванда тартиб диҳед. Бо иҷрои амалиёти зерин дар массиви додашуда: Ба шумо иҷозат дода шудааст, ки амалиёти ҳаракати ростро ҳар чанд маротиба иҷро кунед. Як амалиёти ҳаракати рост маънои онро дорад, ки ҳамаи унсурҳои массивро бо як мавқеъ дар самти рост ҳаракат кунед. Унсури охирини массив ба мавқеи ибтидоӣ дар массив ҳаракат мекунад, яъне 0th. Агар имконпазир бошад, ки массиви тартибдодашударо бо иҷрои амалиёти дар боло овардашуда баргардонем, пас True бозгардонед, пас False бозгардонед. Эзони: Рӯйхати додашуда кафолат дода мешавад, ки унсурҳои беназир дошта бошад. Масалан: move_one_(ball_[3, 4, 5, 4, 5, 1]============================================================================================================================================================================================================================================\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Дар ин масъала, шумо функсияеро иҷро мекунед, ки ду рӯйхати рақамҳоро мегирад ва муайян мекунад, ки оё табодули унсурҳо байни онҳо имконпазир аст, то lst1 рӯйхати танҳо рақамҳои ҷуфт бошад. Дар шумораи унсурҳои табодул байни lst1 ва lst2 маҳдудият вуҷуд надорад. Агар имконпазир бошад, ки унсурҳои байни lst1 ва lst2 табодул карда шаванд, то ҳамаи унсурҳои lst1 ҷуфт бошанд, \"ҲА\" -ро баргардонед. Дар акси дигар, \"НЕ\" -ро баргардонед. Масалан: табодул[(1, 2, 3, 4], [1, 2, 3, 4]) => \"ҲА\" табодул[[(1, 2, 3, 4], [1, 5, 3, 4]) => \"НЕ\" Фарз карда мешавад, ки рӯйхатҳои вурудӣ холӣ нахоҳанд буд. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"Агар ба шумо як сатр дода шавад, ки ҳарфҳои хурд бо ҷойҳои ҷудошударо ифода мекунад, луғати ҳарфро бо такрори зиёдтар ва дорои шумораи мувофиқ баргардонед. Агар якчанд ҳарфҳо якхела бошанд, ҳамаи онҳоро баргардонед. Мисол: гистограмма ((('a b c') == {'a': 1, 'b': 1, 'c': 1} гистограмма ((('a b b a') == {'a': 2, 'b': 2} гистограмма ((('a b c a b') == {'a': 2, 'b': 2} гистограмма ((('b b a') == {'b 4}': гистограмма (((')) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Вазифа Ба мо ду сатр s ва c дода шудааст, шумо бояд ҳамаи аломатҳои s-ро, ки ба ҳар як аломати c баробар аст, нест кунед, пас санҷед, ки оё сатри натиҷа палиндром аст. Сатр палиндром номида мешавад, агар он ба қафо ва пеш баробар хонда шавад. Шумо бояд як тупелро бо сатри натиҷа ва True / False барои санҷиш баргардонед. Мисол Барои s = \"abcde\", c = \"ae\", натиҷа бояд ('bcd', False) Барои s = \"abcdef\", c = \"b\" натиҷа бояд ('acdef', False) Барои s = \"abcdedcba\", c = \"ab\", натиҷа бояд ('cdedc', True) бошад.\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"Бо назардошти рӯйхати сатрҳо, ки ҳар сатр танҳо аз рақамҳо иборат аст, рӯйхатро баргардонед. Ҳар як унсури i баромад бояд \"шумораи унсурҳои нодир дар сатри i вуруд бошад. \" ки дар он ҷо ҳамаи i-ҳо бояд бо шумораи рақамҳои нодир дар сатри i'th вуруд иваз карда шаванд. >>> odd_count['1234567']) [\"шумораи унсурҳои нодир 4n str4ng 4 аз 4nput.\"] >>> odd_count['3',\"111111\"]) [\"шумораи унсурҳои нодир 1n str1ng 1 аз 1nput. \", \"шумораи унсурҳои нодир 8n str8ng 8 аз 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Бо назардошти массиви ададҳои n, миқдори ҳадди ақали ҳар як зермассиви ададҳои n-ро ёбед. Мисол minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Шумо як шабакаи росткунҷаи чоҳҳо дода мешавад. Ҳар як сатр як чоҳро ифода мекунад ва ҳар як 1 дар сатр як воҳиди обро ифода мекунад. Ҳар як чоҳ дорои як косаи мувофиқ аст, ки метавонад барои истихроҷи об истифода шавад ва ҳамаи косаиҳо дорои ҳамон иқтидор мебошанд. Вазифаи шумо истифодаи косаиҳоро барои холӣ кардани чоҳҳо истифода кардан аст. Шумораи маротибае, ки шумо бояд косаиҳоро поён кунед, бароред. Мисол 1: Воридот: шабака: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 баромад: 6 Мисол 2: Воридот: шабака: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 баромад: 5 Мисол 3: Воридот: [[:0,0,0], [0,0,0]] bucket_capacity: 5 баромад: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"Дар ин Ката, шумо бояд массиви ададҳои мукаммали ғайри манфӣро мувофиқи шумораи онҳо дар намоиши дуӣ дар тартиби афзоянда тартиб диҳед. Барои шумораи монанд, дар асоси арзиши даҳӣ тартиб диҳед. Он бояд чунин амалӣ карда шавад: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"Агар string s холӣ бошад, пас функсия бояд рӯйхати холӣ баргардонад. Эзоҳ: шумо метавонед фикр кунед, ки сатри вуруд танҳо ҳарфҳо ва фосилаҳоро дар бар мегирад. Мисолҳо: select_words (((\"Мэри як гӯсфандчаи хурд дошт\", 4) ==> [\"little\"] select_words (((\"Мэри як гӯсфандчаи хурд дошт\", 3) ==> [\"Mary\", \"lamb\"] select_words\" (((ҷойи сафед оддӣ\", 2) ==> [] select_words (((\"Салом ҷаҳон\", 4) ==> [\"world\"] select_words (((\"Акаи Сэм\", 3) ==> [\"Акаи\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Шумо як калима дода мешавад. Вазифаи шумо ин аст, ки наздиктарин овозро, ки дар байни ду садонок аз тарафи рости калима (ҳаҷми ҳассос) ҷойгир аст, пайдо кунед. Овозҳо дар ибтидо ва охири он ҳисоб карда намешаванд. Агар шумо ягон овозро дар шароити боло пайдо накарда бошед, сатри холӣ баргардонед. Шумо метавонед тахмин кунед, ки сатри додашуда танҳо ҳарфи англисиро дар бар мегирад. Мисол: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''Шумо рӯйхати ду сатрро мегиред, ҳарду сатр танҳо аз қафасҳои кушода '(' ё қафасҳои пӯшида ') ' иборат аст. Вазифаи шумо санҷидан аст, ки оё пайваст кардани ду сатр бо тартиби муайян имконпазир аст, ки сатри натиҷа хуб хоҳад буд. Сатр S хуб ҳисобида мешавад, агар ва танҳо агар ҳамаи қафасҳо дар S мувозинат дошта бошанд. Масалан: сатри '((())' хуб аст, дар ҳоле ки сатри '()) ' не. Агар роҳи сохтани сатри хуб вуҷуд дошта бошад, 'Бале' баргардонед ва дар акси ҳол 'Не' баргардонед. Мисолҳо: match_parens[('() ', ') ']) == 'Бале' match_parens[(') ', ') ']) == 'Не' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"Бо назардошти массиви arr аз ададҳои бутун ва адади мусбии k, рӯйхати тартибдодашудаи дарозии k бо шумораи максималии k дар arr баргардонед. Мисол1: Воридот: arr = [-3, -4, 5], k = 3 Натиҷа: [-4, -3, 5] Мисол2: Воридот: arr = [4, -4, 4], k = 2 Натиҷа: [4, 4] Мисол3: Воридот: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Натиҷа: [2] Эзоҳ: 1. Дарозии массив дар доираи [1, 1000] хоҳад буд. 2. Элементҳои массив дар доираи [-1000, 1000] хоҳанд буд. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"Бо назардошти рӯйхати пурраи ададҳои холӣ, ҷамъбасти ҳамаи унсурҳои нобаробарро, ки дар ҷойҳои ҳатто ҳастанд, баргардонед.\"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Бо назардошти массиви холӣ набудани ададҳои бутун arr ва адади бутун k, ҷамъбасти унсурҳоро бо на бештар аз ду рақам аз унсурҳои аввалини k arr баргардонед. Мисол: Воридот: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Натиҷа: 24 # ҷамъбасти 21 + 3 Маҳдудиятҳо: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"Бо назардошти як адади мусбати n, рӯйхати тартибдодашударо, ки шумораи номатлубро дар пайдарпаии коллатз дорад, баргардонед. Тахминҳои Коллатз тахминҳо дар математика мебошанд, ки ба пайдарпаии чунин муайяншуда дахл доранд: бо ҳар як адади мусбати n оғоз кунед. Пас ҳар як мӯҳлат аз мӯҳлати қаблӣ чунин ба даст оварда мешавад: агар мӯҳлати қаблӣ ҷуфт бошад, мӯҳлати навбатӣ нисфи мӯҳлати қаблӣ аст. Агар мӯҳлати қаблӣ номатлуб бошад, мӯҳлати навбатӣ 3 маротиба мӯҳлати қаблӣ плюс 1 аст. Тахмин ин аст, ки новобаста аз он ки арзиши n чӣ гуна аст, пайдарпаӣ ҳамеша ба 1 мерасад. Эзоҳ: 1. Collatz (((1) [1] аст. 2. Рӯйхати баргардонидашуда бо тартиби афзоянда тартиб дода мешавад. Масалан: get_odd_collatz ((5) баргардонад [1, 5] # Пайдарпаии коллатз барои 5 [5, 8, 16, 4, 2, 1], аз ин рӯ рақамҳои номатҳо танҳо 1, ва 5 мебошанд. \"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"Шумо бояд функсияе нависед, ки сатри санаи додашударо тасдиқ мекунад ва агар сана дуруст бошад, дуруст бармегардонад ва агар ҳамаи қоидаҳои зерин риоя карда шаванд, хато аст. Сана дуруст аст: 1. Сатри сана холӣ нест. 2. Шумораи рӯзҳо на камтар аз 1 ё бештар аз 31 рӯз барои моҳҳои 1,3,5,7,8,10,12 аст. Ва шумораи рӯзҳо на камтар аз 1 ё бештар аз 30 рӯз барои моҳҳои 4,6,9,11 аст. Ва шумораи рӯзҳо на камтар аз 1 ё бештар аз 29 барои моҳ 2. 3. Моҳҳо набояд камтар аз 1 ё бештар аз 12 бошанд. Сана бояд дар формати: mm-dd-yyyy бошад, масалан: valid_date (('03-11-2000') => True_date (саҳеҳ) => False valid_date (саҳеҳ) => '04-01-2040') => False_date (саҳеҳ) => '06-04-2020' => True_date (саҳеҳ) => '06/04/2020' => False\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''Бо назардошти сатри калимаҳо, рӯйхати калимаҳоро бо фосила тақсим кунед, агар дар матн ягон фосила мавҷуд набошад, шумо бояд бо холис тақсим кунед ',' агар холис мавҷуд набошад, шумо бояд шумораи ҳарфҳои хурд бо тартиби номутаносибро дар алифбо баргардонед, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 Мисолҳо split_words ((\"Салом ҷаҳон!\") â -> [\"Салом\", \"ҷаҳон!\"] split_words ((\"Салом, ҷаҳон!\") â -> [\"Салом\", \"ҷаҳон!\"] split_words ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''Рӯйхати рақамҳоро дода, баргардонед, ки оё онҳо дар тартиби афзоянда тартиб дода шудаанд ё не. Агар рӯйхат зиёда аз 1 нусхаи ҳамон рақамро дошта бошад, баргардонед Дурӯғ. Ҳеҷ рақами манфӣ ва танҳо ададҳои пурраро қабул накунед. Мисолҳо is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Шумо ду фосила дода мешавад, ки ҳар фосила як ҷуфти ададҳои мукаммал аст. Масалан, фосила = (оғоз, хотима) = (1, 2). фосилаҳои додашуда бастаанд, ки маънои онро дорад, ки фосила (оғоз, хотима) ҳам оғози ва ҳам хотимаро дар бар мегирад. Барои ҳар фосилаи додашуда, фарз карда мешавад, ки оғози он камтар ё баробар ба охири он аст. Вазифаи шумо муайян кардани он аст, ки оё дарозии буриши ин ду фосила рақами аввалия аст. Мисол, буриши фосилаҳо (1, 3), (2, 4) (2, 3) аст, ки дарозии он 1 аст, ки рақами аввалия нест. Агар дарозии буриши рақами аввалия бошад, \"ҲА\" баргардонед, дар акси ҳол \"НЕ\" баргардонед. Агар ду фосила буришинанд, \"НЕ\" баргардонед. [input/output] намунаҳо: intersection (((1, 2), (2, 3) ==> \"intersection ((1, 1) \"NO\" =====0, 4) \"intersection (NO) ===\", - (((1, 5), \" (YES (-3, 5) \"))\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"Шумо массиви arr ададҳои пурра дода шуда, шумо бояд ҷамъбасти бузургии ададҳои пурраро, ки бо маҳсули ҳамаи аломатҳои ҳар як рақами массив, ки бо 1, -1 ё 0 ифода карда мешавад, баргардонед. Эзоҳ: барои arr холӣ ҳеҷ чизро баргардонед. Мисол: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Ҳеҷ чиз\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"Агар дар шабакае бо N сатр ва N сутун (N >= 2) ва як адади мусбати k бошад, ҳар як ҳуҷайраи шабака арзише дорад. Ҳар як адади мусбате дар доираи [1, N * N] ба таври дақиқ дар ҳуҷайраҳои шабака пайдо мешавад. Шумо бояд роҳи ҳадди аққали дарозии k-ро дар шабака пайдо кунед. Шумо метавонед аз ҳар як ҳуҷайра оғоз кунед ва дар ҳар як қадам шумо метавонед ба ҳар як ҳуҷайраҳои ҳамсоя ҳаракат кунед, ба ибораи дигар, шумо метавонед ба ҳуҷайраҳое, ки бо шумо як канори ҳуҷайраи ҳозираро мубодила кунед. Лутфан қайд кунед, ки роҳи дарозии k маънои ташриф овардан ба маҳз k ҳуҷайраҳо (нажоман фарқ нест). Шумо НЕ КОНЕДед аз шабака берун равед. Роҳи A (дарозии k) аз роҳи B (дарозии k) камтар ҳисобида мешавад, агар пас аз сохтани рӯйхати тартибшудаи арзишҳо дар ҳуҷайраҳои A ва B (бояд онҳоро l_st ва l_stA ва l_stB) номида шавад), l_stA аз ҷиҳати lexically камтар аз l_stA аст, аз ҷиҳати ақалли ақалли ақал аз l_stA_st_B, аз ҷиҳати ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақалли ақал, инӣ, инӣ, инӣ, инӣ, ин, ин, ин, ин, ин, ин, ин, ин, ин, ин, ин, ин, ин,\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"Ҳама пайдарпаии Фибоначчиро медонанд, онро математикҳо дар ду асри охир амиқ омӯхтанд. Аммо, он чизе, ки мардум намедонанд, пайдарпаии Трибоначчи аст. Пайдарпаии Трибоначчи бо такроршавӣ муайян карда мешавад: tri(1) = 3 tri(n) = 1 + n / 2, агар n ҷуфт бошад. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), агар n ҷуфт бошад. Масалан: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Ба шумо адади мукаммали ғайриманқул дода мешавад, шумо бояд рӯйхати аввалин n + 1 ададҳои пайдарпаии Трибоначчиро баргардонед. Мисолҳо: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"Агар n адади мусбат бошад, пас натиҷаи ҳосили рақамҳои нобаробарро баргардонед. Агар ҳамаи рақамҳо ҷуфт бошанд, пас натиҷаи 0-ро баргардонед. Масалан: рақамҳо ((1) == 1 рақам ((4) == 0 рақам ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''Функсияе эҷод кунед, ки ҳамчун вуруди сатр, ки танҳо камарбанди мураббаъро дар бар мегирад, қабул кунад. Функсия бояд дуруст баргардонад, агар ва танҳо агар як пайдарпаии дурусти камарбандиҳо вуҷуд дошта бошад, ки ҳадди аққал як камарбанди он дар пайдарпаӣ ҷойгир аст. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[[]]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]]') â -> True is_nested'[[]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Шумо рӯйхати рақамҳоро ба шумо додаед. Шумо бояд ҷамъбасти рақамҳои квадратиро дар рӯйхати додашуда баргардонед, ҳар як унсури рӯйхатро ба int болоии он давр занед. Мисолҳо: Барои lst = [1,2,3] баромади он бояд 14 бошад Барои lst = [1,4,9] баромади он бояд 98 бошад Барои lst = [1,3,5,7] баромади он бояд 84 бошад Барои lst = [1.4,4.2,0] баромади он бояд 29 бошад Барои lst = [-2.4,1,1] баромади он бояд 6 бошад \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''Функсияе эҷод кунед, ки агар аломати охирини сатри додашуда аломати алифбоӣ бошад ва қисми калима набошад ва дар акси ҳол дурӯғ бошад. Эзоҳ: \"калима\" як гурӯҳи аломатҳоест, ки бо фосила ҷудо карда шудаанд. Мисолҳо: check_if_last_char_is_a_letter ((\"Apple pie\") â -> False check_if_last_char_is_a_letter ((\"apple pi e\") â -> True check_if_last_char_is_a_letter ((\"apple pi e\") â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"Функсияе эҷод кунед, ки бузургтарин индекси унсуреро, ки аз унсури бевосита пешинааш калонтар ё баробар нест, баргардонад. Агар чунин унсур вуҷуд надошта бошад, пас -1-ро баргардонед. Массиви додашуда арзишҳои такрорӣ надорад. Мисолҳо: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''Функсияе эҷод кунед, ки як tuple (a, b) -ро бармегардонад, ки дар он 'a' бузургтарин ададҳои мусбати мусбат аст ва 'b' хурдтарин ададҳои мусбати мусбат дар рӯйхат аст. Агар ададҳои мусбат ё манфӣ набошанд, онҳоро ҳамчун None баргардонед. Мисолҳо: калонтарин_сари хурдтарин_сари[2, 4, 1, 3, 5, 7]) == (Ҳеҷ, 1) калонтарин_сари хурдтарин_сари[]) == (Ҳеҷ, Ҳеҷ) калонтарин_сари[0]) == (Ҳеҷ, Ҳеҷ) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"Функсияе эҷод кунед, ки ададҳои пурра, парвозкунанда ё сатрҳоро, ки ададҳои воқеиро ифода мекунанд, мегирад ва тағйирёбандаи калонтарро дар навъи тағйирёбандаи додашуда бармегардонад. Агар арзишҳо баробар бошанд, ҳеҷ чизро барнагардонад. Эзоҳ: Агар адади воқеӣ ҳамчун сатр ифода карда шавад, нуқтаи парвозкунанда метавонад . ё , compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> Ҳеҷ чиз \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Арзёбӣ кунед, ки оё рақами додашуда n метавонад ҳамчун ҷамъи 4 адади мусбати мусбат навишта шавад. Мисол: is_equal_to_sum_even (изоҳ: 4) == False is_equal_to_sum_even (изоҳ: 6) == False is_equal_to_sum_even (изоҳ: 8) == True \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"Факториали Бразилия чунин муайян карда мешавад: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! дар он ҷо n > 0 Масалан: >>> special_factorial ((4) 288 Функсия як адади куллро ҳамчун вуруд мегирад ва бояд факториали махсуси ин ададро баргардонад. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_Намунаи-3тни сатр, ҳамаи ҷойҳои онро бо аломатҳои зерин иваз кунед ва агар сатр зиёда аз 2 ҷойҳои пайдарпай дошта бошад, пас ҳамаи ҷойҳои пайдарпайро бо - fix_spaces ((\"Намуна\") == \"Намуна\" fix_spaces ((\"Намуна1\") == \"Намуна_1\" fix_spaces (((\"Намуна2\") == \"_Намуна_2\" fix_spaces ((\"Намуна 3\") == \"_Намуна-3\"  иваз кунед\"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Функсияе эҷод кунед, ки сатри намояндаи номи файлро мегирад ва агар номи файл дуруст бошад, \"Бале\" ва дар акси ҳол \"Не\" -ро бармегардонад. Номи файл танҳо дар сурате дуруст ҳисобида мешавад, ки ҳамаи шартҳои зерин иҷро карда шаванд: - Дар номи файл набояд зиёда аз се рақам ('0'-'9') бошад. - Номи файл бояд дақиқан як нуқтаи ' ' дошта бошад. - Субсатри пеш аз нуқта набояд холӣ бошад ва он бояд бо ҳарфи алифбои латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии латинии ла\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" Ин функсия рӯйхати ададҳои куллро мегирад. Барои ҳамаи воридшавии рӯйхат, функсия воридшавии адади куллро, агар индекси он якчанд 3 бошад, ба қабати дуюм баробар мекунад ва воридшавии адади куллро, агар индекси он якчанд 4 бошад, на якчанд 3 кунад. Функсия воридшавии рӯйхатро, ки индексҳои он якчанд 3 ё 4 нестанд, тағир намедиҳад. Функсия пас маҷмӯи ҳамаи воридшавиҳоро бармегардонад. Мисолҳо: Барои lst = [1,2,3] баромади он бояд 6 бошад Барои lst = [] баромади он бояд 0 бошад Барои lst = [-1,-5,2,-1,-5] баромади он бояд -126 бошад \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Шумо як сатри намояндаи ҷумла дода мешавад, дар ҷумла баъзе калимаҳо бо фосила ҷудо карда шудаанд ва шумо бояд сатри дорои калимаҳои ҷумлаи аслӣ, ки дарозии онҳо рақамҳои аввалия мебошанд, баргардонед, тартиби калимаҳо дар сатри нав бояд ҳамон тавре ки дар аввал бошад. Мисол1: Воридот: ҷумла = \"Ин санҷиш аст\" Натиҷа: \"ин аст\" Мисол2: Воридот: ҷумла = \"мегузорад, ки барои шино кардан равем\" Натиҷа: \"барои\" Маҳдудиятҳо: * 1 <= len(sentence) <= 100 * ҷумла танҳо ҳарфҳоро дар бар мегирад \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"Вазифаи шумо ин аст, ки функсияеро амалӣ кунед, ки ифодаи x * n -ро содда мекунад. Функсия агар x * n ба як адади куллӣ ва дар акси ҳол дурӯғ баргардонад. Ҳам x ва n, намояндагии сатрии хароб мебошанд ва формати зерин доранд, <шумордиҳанда> / <шахс>, ки дар он ҳам адад ва ҳам номбар ададҳои мусбати мусбат мебошанд. Шумо метавонед тахмин кунед, ки x ва n харобаҳои дуруст мебошанд ва сифр ҳамчун номбар надоранд. содда кунед \"1/ 5\", \"5/1\") = True содда кунед \"1/ 6\", \"2/1\") = False содда кунед \"7/ 10\", \"10/2\") = False \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"Функсияе нависед, ки рӯйхати додашудаи ададҳои куллро мувофиқи ҷамъбасти рақамҳои онҳо бо тартиби афзоянда тартиб диҳад. Эзоҳ: агар якчанд ашё бо ҷамъбасти рақамҳои худ мавҷуд бошанд, онҳоро дар асоси индекси худ дар рӯйхати аслӣ тартиб диҳед. Масалан: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"Функсияе нависед, ки массиви рақамҳоро ҳамчун вуруд қабул кунад ва шумораи унсурҳои массивро, ки аз 10 зиёдтар аст ва ҳарду рақами аввал ва охирини рақамҳо ҷуфт (1, 3, 5, 7, 9) мебошанд, баргардонад. Масалан: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"Шумо ба шумо як адади мусбати n дода мешавад. Шумо бояд массиви адади мусбатро бо дарозии n эҷод кунед. Барои ҳар i (1 ‰¤ i ‰¤ n), арзиши a[i] = i * i - i + 1. Шумораи сегона (a[i], a[j], a[k]) -и a-ро, ки i < j < k аст, ва a[i] + a[j] + a[k] як боркунии 3 аст, баргардонед. Мисол: Вуруд: n = 5 Маҳсулот: 1 Шарҳ: a = [1, 3, 7, 13, 21] Ягона сегона (1, 7, 13) аст. \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''Дар системаи офтобии мо ҳашт сайёра мавҷуданд: наздиктарин ба Офтоб Меркурий, навбатӣ Венера, сипас Замин, Марс, Юпитер, Сатурн, Уран, Нептун. Функсияе нависед, ки ду номи сайёраро ҳамчун сатрҳои сайёра1 ва сайёра2 мегирад. Функсия бояд як туппелеро баргардонад, ки ҳамаи сайёраҳоеро, ки масирҳои онҳо дар байни масири сайёра1 ва масири сайёра2 ҷойгир шудаанд, аз рӯи наздикӣ ба Офтоб ҷудо карда мешаванд. Функсия бояд як туппели холӣ баргардонад, агар сайёра1 ё сайёра2 номҳои дурусти сайёраҳо набошанд. Мисолҳо bf \"(Юпитер\", \"Нептун\") ==> (\"Сатурн\", \"Уран\") bf \"(Замин\", \"Меркурий\") ==> (\"Венера\", \"Замин\", \"Марс\", \"Юпитер\", \"Сн\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Функсияе нависед, ки рӯйхати сатрҳоро ҳамчун параметр қабул кунад, сатрҳои дарозии нобаробарро нест кунад ва рӯйхати натиҷаро бо тартиби тартибдодашуда баргардонад. Рӯйхат ҳамеша рӯйхати сатрҳост ва ҳеҷ гоҳ массиви рақамҳо нест ва он метавонад дубора дошта бошад. Тартиби рӯйхат бояд аз рӯи дарозии ҳар як калима боло равад ва шумо бояд рӯйхати бо ин қоида тартибдодашударо баргардонед. Агар ду калима дарозии якхела дошта бошанд, рӯйхатро бо тартиби алифбоӣ тартиб диҳед. Функсия бояд рӯйхати сатрҳоро бо тартиби тартибдодашуда баргардонад. Шумо метавонед тахмин кунед, ки ҳамаи калимаҳо дарозии якхела доранд. Масалан: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => \"cd ])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Барномаи оддӣ, ки бояд арзиши x-ро баргардонад, агар n адади аввалия бошад ва дар акси ҳол арзиши y-ро баргардонад. Мисолҳо: барои x_or_y(7, 34, 12) == 34 барои x_or_y(15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''Рӯйхати рақамҳоро дода, ҷамъбасти квадрати рақамҳои нобаробарро дар рӯйхат баргардонед. Рақамҳои манфӣ ё ададҳои пурраро сарфи назар кунед. дучанд_тафовут (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 дучанд_тафовут (([-1, -2, 0]) == 0 дучанд_тафовут (([9, -2]) == 81 дучанд_тафовут (([0]) == 0 Агар рӯйхати вуруд холӣ бошад, 0 -ро баргардонед. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"Ман фикр мекунам, ки ҳамаи мо он эҳсосотро дар ёд дорем, вақте ки натиҷаи ягон ҳодисаи тӯлонӣ интизорӣ ниҳоят маълум аст. Эҳсосот ва фикрҳое, ки шумо дар он лаҳза доред, бешубҳа ба қайд гирифтани онҳо ва муқоиса кардан бамаврид аст. Вазифаи шумо муайян кардани он аст, ки оё шахс натиҷаҳои як қатор мувофиқатҳоро дуруст тахмин кардааст. Ба шумо ду массиви холҳо ва тахминҳои дарозии баробар дода мешавад, ки дар он ҳар як индекс мувофиқатро нишон медиҳад. Массиви дарозии баробарро баргардонед, ки нишон медиҳад, ки ҳар як тахмин то чӣ андоза дур аст. Агар онҳо дуруст тахмин карда бошанд, арзиши он 0 аст ва агар не, арзиши он фарқияти мутлақ байни тахмин ва хол аст. мисол: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare (([0,5,0,0,4,0,1,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Ба шумо номи синф (санҷ) ва рӯйхати васеъшавӣ дода мешавад. Васеъшавӣ барои бор кардани синфҳои иловагӣ ба синф истифода мешавад. Қувваи васеъшавӣ чунин аст: Бигзор CAP шумораи ҳарфҳои калон дар номи васеъшавӣ бошад ва бигзор SM шумораи ҳарфҳои хурд дар номи васеъшавӣ бошад, қувваи он бо ҳиссаи CAP - SM дода мешавад. Шумо бояд пурзӯртарин васеъшавиро пайдо кунед ва сатрро дар ин формат баргардонед: ClassName.StrongestExtensionName. Агар ду ё зиёда васеъшави бо ҳамон қувват мавҷуд бошанд, шумо бояд он чизеро интихоб кунед, ки дар рӯйхат аввал меояд. Масалан, агар ба шумо \"Slices\" ҳамчун синф ва рӯйхати васеъшавиҳо дода шавад: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] пас шумо бояд 'Slices.SviRNGSliCes' 'SviRNGSliCes' 'mySviRNGSliCes' (бо ман) аст, қувваи он бо тақсираи CAP - SM. Шумо бояд пурзӯтарин васеъшавиро пайдо кунед ва сатрро дар ин формат баргардонед: ClassName.StrongestExtensionName.StrongestExtensionName.StrongestExtensionName.\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Шумо 2 калима додаед. Шумо бояд баргардонед Ҳақиқат агар калимаи дуюм ё ягон гардиши он як зерсанҷ дар калимаи аввал бошад cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"Бо назардошти як адади мукаммал. як туплро баргардонед, ки шумораи рақамҳои ҳам ва ҳамсара дорад. Мисол: ҳатто_нобаробар_шумори(-12) ==> (1, 1) ҳатто_нобаробар_шумори(123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"Бо назардошти як адади мусбат, муодили рақами румиро ҳамчун сатр ба даст оред ва онро бо ҳарфи хурд баргардонед. Маҳдудиятҳо: 1 <= num <= 1000 Мисолҳо: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''Дарозии се тарафи секунҷаро ба назар гирифта, агар се тарафи секунҷаи росткунҷаро ташкил диҳанд, ҳақиқӣ баргардонед, дар акси ҳол, дурӯғ аст. Секунҷаи росткунҷа секунҷаест, ки дар он як кунҷ кунҷи рост ё 90 дараҷа аст. Мисол: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"Функсияе нависед, ки рӯйхати сатрҳоро қабул кунад. Рӯйхат калимаҳои гуногунро дар бар мегирад. Калимаро бо шумораи максималии аломатҳои беназир баргардонед. Агар сатрҳои сершумор шумораи максималии аломатҳои беназир дошта бошанд, он калимаро, ки дар тартиби луғавӣ аввал меояд, баргардонед.\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Шумо як харгӯши гурусна ҳастед ва шумо аллакай шумораи муайяни моркро хӯрдед, аммо ҳоло шумо бояд барои пур кардани хӯрокҳои рӯз бештар моркро бихӯред. шумо бояд массиви [ шумораи умумии моркро пас аз хӯрокхӯрӣ, шумораи моркро пас аз хӯрокхӯрӣ баргардонед ] агар шумораи кофӣ моркро нахӯред, шумо тамоми моркро хӯред, аммо ҳанӯз гурусна хоҳед буд. Мисол: * хӯрокхӯрӣ ((5, 6, 10) -> [11, 4] * хӯрокхӯрӣ ((4, 8, 9) -> [12, 1] * хӯрокхӯрӣ ((1, 10, 10) -> [11, 0] * хӯрокхӯрӣ ((2, 11, 5) -> [7, 0] Тағйирёбандаҳо: @ шумораи: шумораи моркро, ки шумо хӯрдед, пур кунед. @ ниёз ба шумораи моркро, ки шумо бояд бихӯред. @ боқимондаи шумораи моркро, ки дар захира мавҷуданд: * шумораи боқимондаи моркро <= 0 = 0 * 1000 * 0 = 1000 * 0 = 1000 <= 1000 <= 1000 = 1000 = 0 = 1000 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"Дар рӯйхати аввал амалиёти алгебраи асосӣ ва дар рӯйхати дуюм рӯйхати ададҳои мутлақ мавҷуданд. Барои сохтани ифодаи алгебраӣ ва баргардонидани арзёбии ин ифода аз ду рӯйхати додашуда истифода баред. Амалиёти асосии алгебра: Илова (+) Кашидан (-)) Баландшавӣ (*) Бахши ошёна ( //) Баландшавӣ (**) Мисол: оператор['+', '*', '-'] массив = [2, 3, 4, 5] натиҷа = 2 + 3 * 4 - 5 => натиҷа = 9 Эзоҳ: Дарозии рӯйхати оператор ба дарозии рӯйхати операнда камтар аз як баробар аст. Операнда рӯйхати ададҳои мутлақ мебошад. Оператор ҳадди аққал як оператор дорад ва operand рӯйхат ҳадди ақал ду операнда дорад. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"Агар s[i] ҳарф бошад, пас аз поён ба боло ё баръакс, дар акси ҳол онро ҳамон тавр нигоҳ доред. Агар сатр ҳарфҳо надошта бошад, сатрро баръакс кунед. Функсия бояд сатри натиҷаро баргардонад. Мисолҳо ҳал кунед ((\"1234\") = \"4321\" ҳал кунед ((\"ab\") = \"AB\" ҳал кунед ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"Агар string 'text' бошад, string-и муодили md5-и хешро баргардонед. Агар 'text' string холӣ бошад, None-ро баргардонед. >>> string_to_md5 (('Салом ҷаҳон') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "tgk_Cyrl",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"Бо назардошти ду адади мусбати а ва b, рақамҳои ҷуфтро дар байни а ва b, бо тартиби афзоянда баргардонед. Масалан: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]