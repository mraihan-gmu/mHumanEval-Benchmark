task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,srd_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Iscontrai si in sa lista de nùmeros dada, bi sunt duos nùmeros prus a curtzu s'unu de s'àteru de sa lìmites de su valore de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nùmeru de su nù de su nù de su nù de su nù de su nù de su nù de su nù""""""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,srd_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Intro de custa funtzione b'at una cadena chi cuntenet grupos múltiples de parentesi annidadas. S'obietivu tuo est de separare cussos grupos in cadenas separadas e torrare sa lista de cussas. Is grupos separados sunt equilibrados (cada parentesi aberta est serrada in manera curreta) e non annidados in intro de s'àteru Ignorare calesisiat ispàtziu in sa cadena de intrada. Esempru: >>> separate_paren_groups' ((( ) (() ((( ) )') ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,srd_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Dadu unu nùmeru de puntu flutuante positivu, si podet decomponner in una parte intreos (su nùmeru intreu prus mannu prus minore de su nùmeru dadu) e decimales (sa parte de prus a manca semper prus minore de 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,srd_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""A s'ispissu, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de banca, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de depòsitu e de ritirada, si bi sunt is contos de depòsitu e si bi sunt is contos de depòsitu, si bi sunt is contos de depòsitu, si bi sunt is contos de depòsitu.""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,srd_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Pro una lista dada de nùmeros de intrada, càrculas s'Eviatzione Assoluta Mèdia a inghìriu de sa mèdia de custu grupu de datos. S'Eviatzione Assoluta Mèdia est sa diferèntzia mèdia assoluta intre cada elementu e unu puntu tzentrale (mèdia in custu casu): MAD = mèdia  x - x_mèdia  Esèmpiu: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,srd_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Intrada de unu nùmeru ""delimitadore"" intre ogni duos elementos cunseguentes de sa lista de intrada `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,srd_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Intro de custa funtzione est una cadena rapresentada dae grupos múltiples pro parèntesis annidadas partzidas dae ispàtzios. Pro cada unu de sos grupos, bogada su livellu prus profundu de annidamentu de parèntesis. Es.: (() (()) tenet unu màssimu de duos livellos de annidamentu mentras ((())) tenet tres.""""""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,srd_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtrare una lista de intrada de cadenas petzi pro cussas chi cuntenent una sotzostringa dada >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,srd_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Pro una lista dada de intreos, torrat una tupla chi cunsistet in una summa e unu produtu de totu sos intreos in una lista.""""""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,srd_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Dae una lista dada de intreos, generare una lista de elementos màssimos de rolare agatados finas a unu momentu determinadu in sa secuèntzia. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,srd_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Trova su palindromu prus curtzu chi cumintzat cun una cadena fornida. S'idea de s'algoritmu est simpre: - Trova su postfix prus longu de sa cadena fornida chi est unu palindromu. - Agregare a sa fine de sa cadena su reversu de unu prefissu de cadena chi benit in antis de su suffissu palindròmicu. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Proa si sa cadena dada est unu palindromu""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,srd_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Input sunt duas cadenas a e b chi cunsistent solu in 1 e 0. Esecutare XOR binàriu in custos input e torrare su resurtadu fintzas comente a una cadena.""""""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,srd_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""In sa lista de sas cadenas, torrat sa prus longa. Torrat sa prima in casu de cadenas medas de sa matessi longària. Torrat None in casu de sa lista de intrada siat bòida. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,srd_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Torrat unu màssimu cumunu divisore de duos intreos a e b >>> màssimu_cumunu_divisore ((3, 5) 1 >>> màssimu_comunu_divisore ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,srd_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Torrat sa lista de totu sos prefissos dae su prus curtzu a su prus longu de sa cadena de intrada >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,srd_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Torrat una cadena chi cuntenet nùmeros delimitados dae s'ispàtziu chi cumintzant dae 0 finas a n.""""""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,srd_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Dadu unu nùmeru de carateres, iscobèrrere cantu caràteres distintos (in manera indipendente dae sa cassa) tenet: >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,srd_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input to this function is a string representing musical notes in a special ASCII format. Your is to parse string list of integers corresponding to many beats does. Here is a legend: 'o' note, lasts four beats 'o 112' - half note, lasts two beats 'o 112' - quater note, lasts one beat >>> parse_music. 'o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,srd_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Iscoberta de cantu bortas una determinada suta-serra podet èssere agatada in sa cadena originale. Contare sos casos chi si sutastant. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,srd_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Input est una cadena de numerales delimitada dae s'ispàtziu dae 'zero' a 'nono'. S'eletziones vàlidas sunt 'zero', 'unu', 'duos', 'tres', 'bator', 'chimbe', 'ses', 'sete', 'ochos' e 'nono'. Torrat sa cadena cun nùmeros ordinados dae su prus minore a su prus mannu >>> sort_numbers (('tres unu chimbe') 'unu tres chimbe' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,srd_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Dae una lista fornida de nùmeros (de longària de a su mancu duos) seletzionat e torrat duos chi sunt prus a curtzu a s'unu e los torrat in òrdine (nùmeru prus minore, nùmeru prus mannu). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,srd_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Data una lista de nùmeros (de a su mancu duos elementos), aplicare una trasformada lineare a cussa lista, de manera chi su nùmeru prus minore at a devènnere 0 e su prus mannu at a devènnere 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,srd_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filtru lista dada de calesisiat balores de Python solu pro sos intreos >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,srd_Latn,python,"

def strlen(string: str) -> int:
    """"""Torrat sa longària de sa cadena dada >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,srd_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Pro unu nùmeru dadu n, agatade su nùmeru prus mannu chi partzit n in manera uguale, prus minore de n >>> prus mannu_dividore ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,srd_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Torrat sa lista de sos fatores primos de unu nùmeru intreu dadu in òrdine dae su prus minore a su prus mannu. Ogni de sos fatores diat dèpere èssere elencadu su nùmeru de bortas chi currispondet a cantu bortas aparit in sa fatorizatzione. Su nùmeru de intrada diat dèpere èssere uguale a su produtu de totu sos fatores >>> fatorizare(8) [2, 2, 2] >>> fatorizare(25) [5, 5] >>> fatorizare(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,srd_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Dae una lista de intreos, bogare totu sos elementos chi si presentant prus de una borta. Mantenere s'òrdine de sos elementos lassados uguale a su de s'intrada. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,srd_Latn,python,"

def flip_case(string: str) -> str:
    """"""Pro una cadena dada, incarchia sos caràteres minores in minores e minores in minores. >>> flip_case ((('Hello)) 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,srd_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Lista de cadenas cuncatenadas in una sola cadena >>> cuncatenada (([]) '' >>> cuncatenada ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,srd_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtrare una lista de intradas de cadenas solu pro cussas chi cumintzant cun unu prefissu dadu. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,srd_Latn,python,"

def get_positive(l: list):
    """"""Torrat solu sos nùmeros positivos in sa lista. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,srd_Latn,python,"

def is_prime(n):
    """"""Torrat beru si unu nùmeru dadu est primu, e falsu si no est beru. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,srd_Latn,python,"import math


def poly(xs: list, x: float):
    """"""sa lista de sos coefitzientes est una lista de sos coefitzientes de sos polinòmios. sa lista de sos coefitzientes est una lista de sos coefitzientes de sos polinòmios.""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Avalutat su polinòmiu cun sos coefitzientes xs in su puntu x. torrat xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,srd_Latn,python,"

def sort_third(l: list):
    """"""Custa funtzione pigat una lista l e torrat una lista l' de manera chi l' siat idèntica a l in sos inditzios chi non sunt divisìbiles pro tres, mentras sos balores suos in sos inditzios chi sunt divisìbiles pro tres sunt uguales a sos balores de sos inditzios currispondentes de l, ma ordinados. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,srd_Latn,python,"

def unique(l: list):
    """"""Torrat elementos ùnicos ordinados in una lista >>> ùnica (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,srd_Latn,python,"

def max_element(l: list):
    """"""Torrat s'elementu màssimu in sa lista. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,srd_Latn,python,"

def fizz_buzz(n: int):
    """"""Torrat su nùmeru de bortas chi sa tzifra 7 aparesset in intreos prus minores de n chi sunt divisìbiles pro 11 o 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,srd_Latn,python,"

def sort_even(l: list):
    """"""Custa funtzione pigat una lista l e torrat una lista l' de manera chi l' siat idèntica a l in sos indices dispari, mentras sos balores suos in sos indices paris sunt uguales a sos balores de sos indices paris de l, ma ordinados. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,srd_Latn,python,"

def encode_cyclic(s: str):
    """"""pigat comente input sa cadena codificada cun sa funtzione encode_cyclic. Torrat sa cadena decodificada. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""torrat sa cadena codificada dae grupos ciclàbiles de tres caràteres.""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,srd_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib torrat su nùmeru n chi est unu nùmeru de Fibonacci e est puru primu. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,srd_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero pigat una lista de intreos comente input. Torrat True si b'at tres elementos distintos in sa lista chi sumant a zero, e False in casu contràriu. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,srd_Latn,python,"

def car_race_collision(n: int):
    """"""Imaginade una bia chi est una lìnia perfetamente dereta infinida. n màchinas sunt andende dae manca a dereta; in su matessi tempus, un'impastu diferente de n màchinas sunt andende dae dereta a manca. Is duas mannas de màchinas incumentzant a èssere meda a tesu s'una dae s'àtera. Totas sas màchinas si movent a sa matessi lestresa. Si narat chi duas màchinas si cumbantant cando una màchina chi si movet dae manca a dereta cumbat una màchina chi si movet dae dereta a manca. Nointames, sas màchinas sunt infinidas e fortes; comente resurtadu, sighint a si mòvere in sa trataietrìa issoro comente si no si fiant cumbantadas. Custa funtzione bogat su nùmeru de cussas collisiones.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,srd_Latn,python,"

def incr_list(l: list):
    """"""Torrat lista cun elementos incrementados dae 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,srd_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero pigat una lista de intreos comente input. Torrat True si b'at duos elementos distintos in sa lista chi sumant a zero, e False in casu contràriu. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,srd_Latn,python,"

def change_base(x: int, base: int):
    """"""Cambia sa base numèrica de su nùmeru de intrada x a base. torrat sa rapresentatzione de sa cadena a pustis de sa cunversione. sos nùmeros de base sunt prus pagu de 10. >>> cambiare_base(8, 3) '22' >>> cambiare_base(8, 2) '1000' >>> cambiare_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,srd_Latn,python,"

def triangle_area(a, h):
    """"""Dada sa longària de unu costadu e s'àrea de retòrgiu prus arta pro unu triàngulu. >>> triàngulu_àrea""""""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,srd_Latn,python,"

def fib4(n: int):
    """"""Sa secuèntzia de nùmeros Fib4 est una secuèntzia sìmile a sa secuèntzia de Fibbonacci chi est definida comente a sighit: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).""""""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,srd_Latn,python,"

def median(l: list):
    """"""Torra mediana de sos elementos in sa lista l. >>> mediana (([3, 1, 2, 4, 5]) 3 >>> mediana (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,srd_Latn,python,"

def is_palindrome(text: str):
    """"""Controlat si sa cadena dada est unu palindromu >>> is_palindromu (('') Fatu >>> is_palindromu (('aba') Fatu >>> is_palindromu (('aaaaa') Fatu >>> is_palindromu (('zbcd') Fatu """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,srd_Latn,python,"

def modp(n: int, p: int):
    """"""Torrat 2^n modulo p (siat atentu a sos nùmeros). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,srd_Latn,python,"

def encode_shift(s: str):
    """"""pigat comente intrada sa cadena codificada cun sa funtzione encode_shift. Torrat sa cadena decodificada. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""torrat sa cadena codificada ispostende ogni caràtere de 5 in s'alfabetu.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,srd_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels est una funtzione chi pigat sa cadena e torrat sa cadena sena vocales. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,srd_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Torrat True si totu sos nùmeros in s'elencu l sunt a suta de sa làcana t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,srd_Latn,python,"

def add(x: int, y: int):
    """"""Agregare duos nùmeros x e y >>> agiunghere ((2, 3) 5 >>> agiunghere ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,srd_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Controllare si duas paràulas tenent sos matessi caràteres. >>> same_chars ((('eabcdzzzz', 'dddzzzzzzzddeddabc') Veru >>> same_chars ((('abcd', 'dddddddddabc') Veru >>> same_chars ((('dddddddabc', 'abcd') Veru >>> same_chars ((('eabcd', 'dddddddddabc') Falsu >>> same_chars ((('abcd', 'dddddddabddce') Falsu >>> same_chars (((abcdzzzz', 'dddzzzzzzzddabddc') Falsu """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,srd_Latn,python,"

def fib(n: int):
    """"""Torrat su nùmeru de Fibonacci n-esimu. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,srd_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets est una cadena de ""<"" e "">"". return True si cada bracket de abertura tenet unu bracket de serrada currispondente. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,srd_Latn,python,"

def monotonic(l: list):
    """"""Torrat Fatu si sos elementos de s'elencu sunt creschende o diminuende in manera monotònica. >>> monotònica (([1, 2, 4, 20]) Fatu >>> monotònica (([1, 20, 4, 10]) Fatu >>> monotònica (([4, 1, 0, -10]) Fatu """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,srd_Latn,python,"

def common(l1: list, l2: list):
    """"""Torrat elementos ùnicos ordinados comunes pro duas listas. >>> comunes (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> comunes (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,srd_Latn,python,"

def largest_prime_factor(n: int):
    """"""Torrat su prus mannu fatore primu de n. Assumet chi n > 1 e non est unu primu. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,srd_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n est una funtzione chi summat nùmeros dae 1 a n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,srd_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets est una cadena de ""("" e "")"". return True si cada bracket de abertura tenet unu bracket de serrada currispondente. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() "") True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,srd_Latn,python,"

def derivative(xs: list):
    """"""xs rapresentant sos coeficientes de unu polinòmiu. xs[0] + xs[1] * x + xs[2] * x^2 + .... Torrat sa derivada de custu polinòmiu in sa matessi forma. >>> derivada (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivada (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,srd_Latn,python,"

def fibfib(n: int):
    """"""Sa secuèntzia de nùmeros FibFib est una secuèntzia sìmile a sa secuèntzia de Fibbonacci chi est definida comente a sighit: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).""""""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,srd_Latn,python,"
FIX = """"""Iscritzione de una funtzione vowels_count chi pigat una cadena chi rapresentat una paràula comente input e torrat su nùmeru de vocales in sa cadena. Vocales in custu casu sunt 'a', 'e', 'i', 'o', 'u'. Inoghe, 'y' est fintzas una vocale, ma solu cando est a sa fine de sa paràula dada. Esempru: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Agregare prus casos de proa. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,srd_Latn,python,"
def circular_shift(x, shift):
    """"""Si su nùmeru de sas tzirculare est > nùmeru de tzirculare, torrat sas tzirculare a s'imbesse.""""""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,srd_Latn,python,"
def digitSum(s):
    """"""Esempru: digitSum{""}"" => 0 digitSum{""abAB"") => 131 digitSum{""abcCd"") => 67 digitSum{""helloE"") => 69 digitSum{""woArBld"") => 131 digitSum{""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,srd_Latn,python,"
def fruit_distribution(s,n):
    """"""In custa tarea, ti ant a dare una cadena chi rapresentat unu nùmeru de manzanas e naranzas chi sunt distribuidas in unu càsciu de frutas custu càsciu cuntenet manzanas, naranzas e frutos de manga. Data sa cadena chi rapresentat su nùmeru totale de naranzas e manzanas e unu nùmeru intreu chi rapresentat su nùmeru totale de frutos in su càsciu torrat su nùmeru de frutos de manga in su càsciu. pro esèmpiu: fruit_distribution""5(manzanas e 6 naranzas"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 manzanas e 1 naranzas"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 manzanas e 3 naranzas"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 manzanas e 1 naranzas"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,srd_Latn,python,"
def pluck(arr):
    """"""""Given an array representing a branch of a tree that has non-negative integer nodes your task is to pluck one of the nodes and return it. Su noddu pighidu diat dèpere èssere su noddu cun su prus piticu balore paris. Si sunt agatados nodos prus piticos cun su matessi balore paris, torrat su noddu chi tenet s'indice prus piticu. Su noddu pighidu diat dèpere èssere torradu in un'elencu, [smallest_value, su suo indice], Si non b'at balores paris o s'arràbiu dadu est bòidu, torrat []. Esèmpiu 1: Input: [4,2,3] Output: [2, 1] Espiegatzione: 2 tenet su balore paris prus piticu, e 2 tenet s'indice prus piticu. Esempiu 2: Input: [1,2,3] Output: [2, 1] Espiegatzione: 2 tenet su balore prus piticu, e 2 tenet s'indice paris prus piticu. Esempiu 3: Input: [] Output: [4: [5, 3, 4] Input: [0, 2] Output: 1 Output: 0; esempio: su noddu prus piticu tenet su balore paris, ma su balore prus piticu est zero. *contu: su primu est zero, duncas est su primu.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,srd_Latn,python,"
def search(lst):
    '''Si ti est dadu una lista de nùmeros intreos positivos. Torrat su nùmeru intreu prus mannu chi est prus mannu de zero, e tenet una frecuèntzia prus manna de o uguale a su balore de su nùmeru intreu matessi. Sa frecuèntzia de unu nùmeru intreu est su nùmeru de bortas chi aparesset in sa lista. Si non esistit unu balore de custa genia, torrat -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,srd_Latn,python,"
def strange_sort_list(lst):
    '''A sa fine de sa lista, torrat sa lista in òrdine istranu. Sortamentu istranu, est cando si cumintzat cun su balore mìnimu, a pustis su màssimu de sos intreos abarrados, a pustis su mìnimu e gasi sighende. Esèmpios: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,srd_Latn,python,"
def triangle_area(a, b, c):
    '''Dadas sas longas de sos tres lados de unu triàngulu. Torrat s'àrea de su triàngulu arrotondada a 2 puntos detzimales si sos tres lados formant unu triàngulu bàlidu. In casu contràriu torrat -1 Tres lados faghent unu triàngulu bàlidu cando sa summa de duos lados est prus manna de su de tres lados. Esempru: triàngulu_àrea{3, 4, 5} == 6.00 triàngulu_àrea{1, 2, 10} == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,srd_Latn,python,"
def will_it_fly(q,w):
    '''Iscriet una funtzione chi torrat True si s'ogetu q at a bolare, e False in casu contràriu. S'ogetu q at a bolare si est equilibradu (est una lista palindromica) e sa summa de sos elementos suos est minore o uguale a su pesu màssimu possìbile w. Esempru: will_it_fly (([1, 2], 5) â -> False # 1+2 est minore de su pesu màssimu possìbile, ma est sbalanciadu. will_it_fly (([3, 2, 3], 1) â -> False # est equilibradu, ma 3+2+3 est prus de su pesu màssimu possìbile. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 est prus pagu de su pesu màssimu possìbile, e est equilibradu. will_it_fly ((([3], â 5) -> True # 3 est prus pagu de su pesu màssimu possìbile, e est equilibradu. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,srd_Latn,python,"
def smallest_change(arr):
    """"""Pro una matrice de nùmeros intreos, agatade su nùmeru mìnimu de elementos chi depent èssere cambiados pro fàghere chi sa matrice siat palindroma. Una matrice palindroma est una matrice chi est lèghida sa matessi manera a dae segus e a dae in antis. In unu càmbiu, si podet cambiare un'elementu a un'àteru elementu.""""""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,srd_Latn,python,"
def total_match(lst1, lst2):
    '''Iscritu una funtzione chi atzetat duas listas de cadenas e torrat sa lista chi tenet su nùmeru totale de caràteres in totu sas cadenas de sa lista prus pagu de s'àtera lista. si sas duas listas tenent su matessi nùmeru de caràteres, torrat sa prima lista. Esèmpios total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4', ['1', '2', '3', '4', '5', '4]) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,srd_Latn,python,"
def is_multiply_prime(a):
    """"""Iscriere una funtzione chi torrat tretu si su nùmeru dadu est sa multiplicatzione de 3 nùmeros primos e falsu in casu contràriu.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,srd_Latn,python,"
def is_simple_power(x, n):
    """"""Sa tarea tua est de iscrìere una funtzione chi torrat trista si unu nùmeru x est una potèntzia simpre de n e falsa in àteros casos. x est una potèntzia simpre de n si n**int=x Pro esempru: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,srd_Latn,python,"
def iscube(a):
    '''Iscriere una funtzione chi pigat unu nùmeru intreu a e torrat True si custu ingeger est unu cubu de carchi nùmeru intreu. Nota: si podet assumere chi s'intrada est semper vàlida. Esèmpios: iscube(1) ==> True iscube(2) ==> False iscube(-1) ==> True iscube(64) ==> True iscube(0) ==> True iscube(180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,srd_Latn,python,"
def hex_key(num):
    """"""Si ti at dadu sa tarea de iscrìere una funtzione chi retzit unu nùmeru esadecimale comente a una cadena e contat su nùmeru de tzifras esadecimales chi sunt primos (númeru primu, o unu primu, est unu nùmeru naturale prus mannu de 1 chi non est unu produtu de duos nùmeros naturales prus minores). Is tzifras esadecimales sunt 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Is nùmeros primos sunt 2, 3, 5, 7, 11, 13, 17,... Tando depes determinare unu nùmeru de is tzifras sighentes: 2, 3, 5, 7, B (=decimale 11), D (=decimale 13). Nota: si podet assumere chi s'intrada siat semper curreta o bòida, e sos sìmbulos A,B,C,D,E,F sunt semper majusculas. Esèmpios: Pro num = AB s'essida depet èssere num = 1. Pro num = 1077E sa essida depet èssere 2. Pro num = AB331EDA su num depet èssere 4.BC = 6.089123DEF pro su num = 6.045 "" 2020 """"""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,srd_Latn,python,"
def decimal_to_binary(decimal):
    """"""Sa funtzione depet torrare una cadena, cun cada caràtere chi rapresentat unu nùmeru binàriu. Cada caràtere in sa cadena at a èssere '0' o '1'. At a èssere unu paru de caràteres extra 'db' a s'incumintzu e a sa fine de sa cadena. Is caràteres extra sunt in cue pro agiudare cun su formadu. Esèmpios: decimal_to_binary (d) # torrat ""db1111db"" decimal_to_binary (d) # torrat ""db100000db""""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,srd_Latn,python,"
def is_happy(s):
    """"""A s'ispissu, si bi sunt tres lìteras in unu, s'iscritu est s'iscritu de s'ispissu.""""""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,srd_Latn,python,"
def numerical_letter_grade(grades):
    """"""Est s'ùrtima chida de su semestre e s'istrutore depet dare sos balores a sos istudiantes. S'istrutore at fatu s'algoritmu suo pro sa graduatzione. S'ùnicu problema est chi at pèrdidu su còdighe chi impreat pro sa graduatzione. T'at dadu una lista de GPA pro carchi istudiante e depes iscrìere una funtzione chi podet publicare una lista de balores de lìtera impreende sa tàula chi sighit: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,srd_Latn,python,"
def prime_length(string):
    """"""Iscriere una funtzione chi pigat una cadena e torrat Vera si sa longària de sa cadena est unu nùmeru primu o Falsa in casu contràriu Esempros prime_length{'Hello') == True prime_length{'abcdcba') == True prime_length{'kittens') == True prime_length{'orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,srd_Latn,python,"
def starts_one_ends(n):
    """"""Dadu unu nùmeru intreu positivu n, torrat su nùmeru de sos nùmeros intreos positivos de n-tzifras chi comintzant o finint cun 1.""""""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,srd_Latn,python,"
def solve(N):
    """"""Dadu unu nùmeru intreu positivu N, torrat sa summa totale de sas tzifras suas in binàriu. Esempru Pro N = 1000, sa summa de sas tzifras at a èssere 1 s'output diat dèpere èssere ""1"". Pro N = 150, sa summa de sas tzifras at a èssere 6 s'output diat dèpere èssere ""110"". Pro N = 147, sa summa de sas tzifras at a èssere 12 s'output diat dèpere èssere ""1100"". Variabiles: @N nùmeru intreu Contraintziones: 0 â‰¤ N â‰¤ 10000. Output: una cadena de nùmeros binàrios """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,srd_Latn,python,"
def add(lst):
    """"""Dadu una lista de intreos non bòida, addòngiat sos elementos paris chi sunt in indicos dispàrios. Esèmpios: addòngiat[4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,srd_Latn,python,"
def anti_shuffle(s):
    """"""Iscrit una funtzione chi pigat una cadena e torrat una versione ordinada de sa matessi. Versione ordinada de cadena, est una cadena in ue totu sas paràulas (separadas dae unu ispàtziu) sunt remplasadas dae una paràula noa in ue totu sos caràteres sunt dispostos in òrdine creschente basadu subra de su balore ascii. Nota: Depet mantènnere s'òrdine de sas paràulas e sos ispàtzios lìberos in sa frase. Pro esempru: anti_shuffle ((('Hi') torrat 'Hi' anti_shuffle ((('hello') torrat 'ehllo' anti_shuffle (('Hello World!!!') torrat 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,srd_Latn,python,"
def get_row(lst, x):
    """"""Si ti danus unu datu bidimensionali, che una lista annusada, chi est simil a sa matrix, ma, a diferèntzia de is matrixis, cada fila podit cuntènnere unu nùmeru diferente de colunnas. Si donat lst, e nùmeru intreu x, agatai intgeris x in sa lista, e torrai lista de tupulas, [(x1, y1), (x2, y2) ...] de manera chi cada tupla siat una coordinada - (reda, colunnas), incumentendi cun 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,srd_Latn,python,"
def sort_array(array):
    """"""Si b'at una matrice de intreos non negativos, torrat una còpia de sa matrice a pustis de s'ordinamentu, si la ponet in òrdine creschente si sa summa (primmu valore de s'indice, ùrtimu valore de s'indice) est dispare, o si la ponet in òrdine decrescente si sa summa (primmu valore de s'indice, ùrtimu valore de s'indice) est paris. Nota: * non mudare sa matrice dada. Esèmpios: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,srd_Latn,python,"
def encrypt(s):
    """"""Creare una funtzione encrypt chi pigat una cadena comente a argumentu e torrat una cadena chi est codificada cun s'alfabetu giradu. S'alfabetu depet èssere giradu in manera chi sas lìteras si mòviant a suta pro duos multiplicadas pro duos logos.""""""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,srd_Latn,python,"
def next_smallest(lst):
    """"""Si ti est dada una lista de intreos. Iscries una funtzione next_smallest (de su prus piticu) chi torrat su segundu elementu prus piticu de sa lista. Torrat None si non b'at un'elementu de custu tipu. next_smallest (de su prus piticu) ([1, 2, 3, 4, 5]) == 2 next_smallest (de su prus piticu) ([5, 1, 4, 3, 2]) == 2 next_smallest (de su prus piticu) ([]) == None next_smallest (de su prus piticu) ([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,srd_Latn,python,"
def is_bored(S):
    """"""A s'ispissu, si ti dat una cadena de paràulas, e su traballu tuo est de contare su nùmeru de sos nojos. Unu noju est una frase chi cumintzat cun sa paràula ""I"". Sas frases sunt delimitadas dae '.', '?' o '!'.""""""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,srd_Latn,python,"
def any_int(x, y, z):
    '''Creare una funtzione chi pigat 3 nùmeros. Torrat beru si unu de sos nùmeros est uguale a sa summa de sos àteros duos, e totu sos nùmeros sunt intreos. Torrat falsu in àteros casos. Esempros any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,srd_Latn,python,"
def encode(message):
    """"""Iscriere una funtzione chi pigat unu messàgiu, e codificat in manera chi càmbiat sa cassa de totu sas lìteras, sostituit totu sas vocales in su messàgiu cun sa lìtera chi aparit 2 postos in antis de cussa vocale in s'alfabetu inglesu.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,srd_Latn,python,"

def skjkasdkd(lst):
    """"""Si ti dan una lista de nùmeros intreos. Deves agatare su balore primu prus mannu e torrare sa summa de sas tzifras suas. Esèmpios: Pro lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] s'output diat dèpere èssere 10 Pro lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] s'output diat dèpere èssere 25 Pro lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] s'output diat dèpere èssere 13 Pro lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] s'output diat dèpere èssere 11 Pro lst = [0,81,12,31,21] s'output diat dèpere èssere 3 Pro lst = [0,1,8,2,1,7] s'output diat dèpere èssere 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,srd_Latn,python,"
def check_dict_case(dict):
    """"""Dadu unu ditzionàriu, torrat True si totu sas teclas sunt cadenas in lìteras minores o totu sas teclas sunt cadenas in lìteras majores, si nono torrat False. Sa funtzione depet torrar False si su ditzionàriu dadu est bòidu. Esèmpios: check_dict_case{""a"":""apple"", ""b"":""banana""}) depet torrar True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) depet torrar False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) depet torrar False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) depet torrar check.dict_case{""NC"":""STATE"", ""ZIP"":""12345""}) depet torrar True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,srd_Latn,python,"
def count_up_to(n):
    """"""Impregnare una funtzione chi pigat un'intreu non negativu e torrat un'arrèdu de sos primos n intègros chi sunt nùmeros primos e prus piticos de n. pro esèmpiu: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,srd_Latn,python,"
def multiply(a, b):
    """"""Ispiegat sa funtzione chi pigat duos intreos e torrat su produtu de sas tzifras de s'unidade issoro.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,srd_Latn,python,"
def count_upper(s):
    """"""A sa data de una cadena s, contade su nùmeru de vocales maiusculas in indicos paris.""""""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,srd_Latn,python,"
def closest_integer(value):
    '''Creare una funtzione chi pigat unu balore (stringa) chi rapresentat unu nùmeru e torrat s'intreu prus a curtzu a issu. Si su nùmeru est a distàntzia uguale dae duos intègros, arrotondat dae zero. Esèmpios >>> closest_integer (((""10"") 10 >>> closest_integer (((""15.3"") 15 Nota: arrotondare dae zero cheret nàrrere chi si su nùmeru dadu est a distàntzia uguale dae duos intègros, su chi si depet torrare est su prus a curtzu dae zero. Pro esèmpiu closest_integer "" ((14.5"") depet torrare 15 e closest_integer "" ((-14.5"") depet torrare -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,srd_Latn,python,"
def make_a_pile(n):
    """"""Si tenes unu nùmeru intreu positivu n, depes fàghere una pila de n livellos de pedras. Su primu livellu tenet n pedras. Su nùmeru de pedras in su livellu imbeniente est: - su nùmeru imparis imbeniente si n est impares. - su nùmeru paris imbeniente si n est paris. Torrat su nùmeru de pedras in cada livellu in una lista, in ue s'elementu a s'inditze i rapresentat su nùmeru de pedras in su livellu (i+1). Esèmpios: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,srd_Latn,python,"
def words_string(s):
    """""""" 'Cumplimentu "" ' est unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare pro inditare unu nùmene, unu nùmene chi si podet impreare, unu nùmene chi si podet impreare, unu nùmene chi si podet inditare, unu nùmene, unu nùmene chi si podet impreare, unu nùmene, unu nùmene si podet inditare, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu nùmene, unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu unu""""""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,srd_Latn,python,"
def choose_num(x, y):
    """"""Custa funtzione pigat duos nùmeros positivos x e y e torrat su nùmeru intreu paris prus mannu chi est in su rangu [x, y] inclùdidu. Si non b'at unu nùmeru gasi, tando sa funtzione diat dèpere torrare -1.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,srd_Latn,python,"
def rounded_avg(n, m):
    """"""Si ti ant dadu duos intreos positivos n e m, e su traballu tuo est de compudare sa mèdia de sos intreos dae n a m (incluinde n e m). Arroncada sa risposta a s'intreu prus a curtzu e cunvertire a binàriu. Si n est prus mannu de m, torra -1. Esempru: arrotondadu_avg ((1, 5) => ""0b11"" arrotondadu_avg ((7, 5) => -1 arrotondadu_avg ((10, 20) => ""0b1111"" arrotondadu_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,srd_Latn,python,"
def unique_digits(x):
    """"""Data una lista de intreos positivos x. torrat una lista ordinada de totu sos elementos chi non tenent nudda de pari. Nota: sa lista torrada diat dèpere èssere ordinada in òrdine creschente.""""""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,srd_Latn,python,"
def by_length(arr):
    """"""Dadu unu filu de nùmeros intreos, ordinare sos nùmeros intreos chi sunt intre 1 e 9 inclùdidos, invertire s'arrangiu chi resurtat, e tando sostituire cada tzifra cun su nùmene currispondente suo dae ""Unu"", ""Dos"", ""Tres"", ""Catòr"", ""Cìncu"", ""Sessos"", ""Sètos"", ""Otto"", ""Noe"".""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,srd_Latn,python,"
def f(n):
    """"""Implementare sa funtzione f chi pigat n comente a paràmetru, e torrat una lista de mannària n, de manera chi su balore de s'elementu in s'inditzu i siat su fatòriu de i si i est paris o sa summa de sos nùmeros dae 1 a i in casu contràriu. i cumintzat dae 1. su fatòriu de i est sa multiplicatzione de sos nùmeros dae 1 a i (1 * 2 * ... * i). Esempru: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,srd_Latn,python,"
def even_odd_palindrome(n):
    """"""A pustis de àere dadu unu nùmeru intreu positivu n, torrat unu tupla chi tenet su nùmeru de palindromos intreos paris e dispari chi s'agatant in su rangu ((1, n), inclùdidu. Esèmpiu1: Intrada: 3 Funtzione: (1, 2) Ispiegatzione: sos palindromos intreos sunt 1, 2, 3. unu de issos est paris, e duos de issos sunt dispari. Esèmpiu2: Intrada: 12 Funtzione: (4, 6) Ispiegatzione: sos palindromos intreos sunt 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. bator de issos sunt paris, e 6 de issos sunt dispari. Nota: 1. 1 <= n <= 10^3 2. su tupla at torradu su nùmeru de sos palindromos intreos paris e dispari rispetivamente. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,srd_Latn,python,"
def count_nums(arr):
    """"""Iscriere una funtzione count_nums chi pigat una matrice de intreos e torrat su nùmeru de elementos chi tenet sa summa de tzifras > 0. Si unu nùmeru est negativu, tando sa prima tzifra firmada sua at a èssere negativa: es. -123 at firmadu tzifras -1, 2 e 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,srd_Latn,python,"
def move_one_ball(arr):
    """"""Si est possìbile a otènnere s'arrangiu ordinadu pro fàghere s'operatzione subra, tando torrat True, si nono torrat False. Si s'arrangiu est bòidu torrat True. Sa lista dada est garantita de tènnere elementos ùnicos. Pro esempru: move_one_(ball[3, 4, 5, 2]=True Explanation: By performin 2 right operations, non-decreasing order can be achieved for the given array. [move_one_{}=4, 5, 2}=False Explanation: It is not possible to perform any number of right shifting operations for the given array.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,srd_Latn,python,"
def exchange(lst1, lst2):
    """"""In custu problema, si at a implementare una funtzione chi pigat duas listas de nùmeros, e determinat si est possìbile a fàghere un'iscàmbiu de elementos intre issos pro fàghere de lst1 una lista de nùmeros paris isceti. Non b'at perìgulu in su nùmeru de elementos iscàmbiados intre lst1 e lst2. Si est possìbile a iscàmbiare elementos intre s'lst1 e s'lst2 pro fàghere de totu sos elementos de s'lst1 pares, torrat ""SI"". In casu contràriu, torrat ""NO"". Esempru: iscàmbiu[(1, 2, 3, 4], [1, 2, 3, 4]) => ""SÌS"" iscàmbiu[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Si suponet chi is listas de intrada non siant a èssere bòidas. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,srd_Latn,python,"
def histogram(test):
    """"""Si b'at una cadena chi rapresentat unu nùmeru de lìteras minores separadas dae unu ispàtziu, torrat unu ditzionàriu de sa lìtera cun sa prus repitidura e chi cuntenet su nùmeru currispondente. Si medas lìteras tenent sa matessi aparitzione, torrat totu. Esèmpiu: istògramu:""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,srd_Latn,python,"
def reverse_delete(s,c):
    """"""Sa tarea est de eliminare totu sos caràteres de s chi sunt uguales a calesisiat caràtere de c e controllare si su resurtadu est palindromu. Una cadena est narada palindroma si est sa matessi de antis e de a pustis.""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,srd_Latn,python,"
def odd_count(lst):
    """"""""Cada elementu i de s'output depet èssere ""su nùmeru de elementos disparios in sa cadena i de s'intrada"". ue totu sos i depent èssere remplasados dae su nùmeru de dígitos disparios in sa i'a cadena de s'intrada. >>> odd_count['1234567']) [""su nùmeru de elementos disparios 4n sa str4ng 4 de sa 4nput.""] >>> odd_count['3',""111111""]) [""su nùmeru de elementos disparios 1n sa str1ng 1 de sa 1nput."", ""su nùmeru de elementos disparios 8n sa str8ng 8 de sa 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,srd_Latn,python,"
def minSubArraySum(nums):
    """"""Dadu unu filu de intreos n, agatade sa summa mìnima de cale si siat sub-filu de nùmeros non bòidu. Esèmpiu minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,srd_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Si ti donat una retza de putzos. Ogni riga rapresentat una sola, e cada 1 in una riga rapresentat una sola unidade de abba. Cada putzu tenet unu bidru chi si podet impreare pro nde bogare abba, e totu sos bidros tenent sa matessi capatzidade. Su traballu tuo est de impreare sos bidros pro bogare sos putzos. Iscrie su nùmeru de bortas chi bi cheres pro abbassare sos bidros. Esèmpiu 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Output: 62: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Output: 53: Input: [[:0,0,0], [0,0,0]] bucket_capacity: 5 * 0 * 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 1 * 2 * 2 * 2 * 2 * 3 * 2 * 4 * 5 * 6 * 1 * 1 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 5 * 6 * 6 * 7 * 7 * 8 * 9 * 9 * 9 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,srd_Latn,python,"
def sort_array(arr):
    """"""In custu kata, depes ordinare una matrice de intreos no negativos segundu su nùmeru de unos in sa rapresentatzione binària issoro in òrdine creschente. Pro nùmeru sìmile de unos, ordinare basadu in su balore detzimale.""""""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,srd_Latn,python,"
def select_words(s, n):
    """"""Si sa stringa s est bòida, sa funtzione depet torrare una lista bòida. Nota: si podet pensare chi sa stringa de intrada cuntenet petzi lìteras e ispàtzios. Esèmpios: select_words (""Mary had a little lamb"", 4) ==> [""little""] select_words (""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words ""simple white space"", 2) ==> [] select_words (""Hello world"", 4) ==> [""world""] select_words (""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,srd_Latn,python,"
def get_closest_vowel(word):
    """"""Si ti est dada una paràula. Su compitu tuo est de agatare sa vocale prus a curtzu chi s'agatat intre duas cunsonantes dae su ladu deretu de sa paràula (sensìbile a sa cassa). Sas vocales in s'incumintzu e in sa fine non contant. Torra sa cadena bòida si no as agatadu peruna vocale cunfirmada sa cunditzione de subra. Si podet assumere chi sa cadena dada cuntenet petzi lìtera inglesa. Esempru: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,srd_Latn,python,"
def match_parens(lst):
    '''Si ti dan una lista de duas cadenas, ambas sunt costituidas de parèntesis abertas '(' o parèntesis serradas ') '. Su traballu tuo est de controllare si est possìbile a cuncadenare sas duas cadenas in carchi òrdine, chi sa cadena resultante at a èssere bona. Una cadena S est cunsiderada bona si e solu si totu sas parèntesis in S sunt equilibradas. Pro esempru: sa cadena '((())) ' est bona, mentras sa cadena '()) ' no est. Torra 'Yes' si b'at unu modu pro fàghere una cadena bona, e torra 'No' in casu contràriu. Esèmpios: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,srd_Latn,python,"
def maximum(arr, k):
    """"""Dadu unu filu arr de intreos e unu nùmeru intreu positivu k, torrat una lista ordinada de longària k cun sos nùmeros màssimos k in arr. Esèmpiu1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Esèmpiu2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Esèmpiu3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Nota: 1. Sa longària de s'arrègiu at a èssere in su rangu de [1, 1000]. 2. Sos elementos de s'arrègiu ant a èssere in su rangu de [-1000, 1000]. 3. 0 <= k <= len (arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,srd_Latn,python,"
def solution(lst):
    """"""Dadu una lista de intreos, torrat sa summa de totu sos elementos dispari chi sunt in positziones paris.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,srd_Latn,python,"
def add_elements(arr, k):
    """"""Dadu unu filu de nùmeros intreos arr e unu nùmeru intreu k, torrat sa summa de sos elementos cun prus de duas tzifras dae sos primos k elementos de arr. Esèmpiu: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # summa de 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,srd_Latn,python,"
def get_odd_collatz(n):
    """"""Sa congetura de Collatz est una congetura in matemàtica chi pertocat una secuèntzia definida in custa manera: cumintzare cun cale si siat nùmeru intreu positivu n. A pustis cada tèrmine est otentu dae su tèrmine pretzedente in custa manera: si su tèrmine pretzedente est paris, su tèrmine imbeniente est sa metade de su tèrmine pretzedente. Si su tèrmine pretzedente est dispare, su tèrmine imbeniente est 3 bortas su tèrmine pretzedente prus 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,srd_Latn,python,"
def valid_date(date):
    """"""Sa data est vàlida si totu sas règulas chi sighint sunt satisfatas: 1. sa data no est bòida. 2. su nùmeru de dies no est prus pagu de 1 o prus de 31 dies pro sos meses 1,3,5,7,8,10,12. e su nùmeru de dies no est prus pagu de 1 o prus de 30 dies pro sos meses 4,6,9,11. e su nùmeru de dies no est prus pagu de 1 o prus de 29 pro su mese 2. 3. sos meses non depent èssere prus pagu de 1 o prus de 12. 4. sa data depet èssere in su formadu: mm-dd-yyyy pro esèmpiu: valid_date (s'03-11-2000') => true_date (s'03-11-2012) => false valid_date (s'04- 2040') => false_date (s'06- 04-2020) => true (s'06- 04/2020) => false (s'06- 04/2020)""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,srd_Latn,python,"
def split_words(txt):
    '''A pustis de una filera de paràulas, torrat una lista de paràulas partzidas in ispetàculos, si no esistent ispetàculos in su testu si depet partzire in cummas ',' si non esistent cummas si depet torrare su nùmeru de lìteras minores cun òrdine dispare in s'alfabetu, ord (('a') = 0, ord ((b') = 1, ... ord ((('z') = 25 Esèmpios split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words)) == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,srd_Latn,python,"
def is_sorted(lst):
    '''A pustis de àere agatadu una lista de nùmeros, torrat si sunt o no ordinados in òrdine creschente. Si sa lista tenet prus de 1 duplicadu de su matessi nùmeru, torrat False. Assumet chi non bi siant nùmeros negativos e solu intreos. Esèmpios is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,srd_Latn,python,"
def intersection(interval1, interval2):
    """"""Si ti dan duos intervalles, in ue cada intervalu est una pariga de intreos. Pro esèmpiu, intervalu = (incumintzu, fine) = (1, 2). Is intervalles dados sunt serrados chi cheret nàrrere chi s'intervalu (incumintzu, fine) cumprendet siat s'incumintzu siat s'acabu. Pro cada intervalu dadu, si suponet chi s'incumintzu suo est minore o uguale a s'acabu suo. Su traballu tuo est de determinare si sa longària de s'intersezione de custos duos intervalles est unu nùmeru primu. Esempru, s'intersezione de is intervalles (1, 3), (2, 4) est (2, 3) chi sa longària sua est 1, chi no est unu nùmeru primu. Si sa longària de s'intersezione est unu nùmeru primu, torrat ""SI"", in casu contràriu, torrat ""NO"". Si is duos intervalles non s'intersecant, torrat ""NO"".""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,srd_Latn,python,"
def prod_signs(arr):
    """"""Si ti donat unu filu arr de nùmeros intreos e depes torrare sa summa de sas magnitudes de sos nùmeros intreos multiplicada pro su produtu de totu sos signos de cada nùmeru in s'arr, rapresentadu dae 1, -1 o 0. Nota: torrare None pro su filu arr bòidu. Esempru: >>> prod_signs([1, 2, 2, -4]) == -9 >>> prod_signs([0, 1]) == 0 >>> prod_signs([]) == None """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,srd_Latn,python,"
def minPath(grid, k):
    """"""Si si tenet una retza cun N lìnias e N colunnas (N >= 2) e una tzella positiva k, cada tzella de sa retza cuntenet unu balore. Onzi nùmeru intreu in su rangu [1, N * N] inclusu aparesset unu borta in sas tzellos de sa retza. Depeus agatai su caminu mìnimu de longària k in sa retza. Si podet incumentzare dae cale si siat tzella, e in cada passu si podet andare a cale si siat tzella a curtzu, in àteras paràulas, si podet andare a tzellos chi cumpartzint un'oru cun sa tzella atuale. Si cheret ammentare chi unu caminu de longària k cheret nàrrere bisitare pròpiu k tzèllulas (no netzessariamente distintas). Non si podet andare foras de sa retza. Unu caminu A (de longària k) est cunsideradu prus pagu longu de unu caminu B (de longària k) si, a pustis de fàghere sas listas ordinadas de sos balores in sas tzèllulas chi passat A e B (chamemus a las narreras l_st e l_st_A), l_st_B), l_st_A est lexicamente prus pagu mannu de l_st_B, in unas àteras paràulas, unu nùmeru intreu intreu est in sa retza. Si podet incumentare dae cale si siat tzella, in cale si siat, in àteras paràulas, si podet andare a tzèllula a cale si siat, si cheret una de sa retza de longària de longària de longària k (non netzessore) de sa retza est pròpiu de k (non netzessore).""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,srd_Latn,python,"
def tri(n):
    """"""Sa secuèntzia de Fibonacci est definida dae sa recurrèntzia: tri(1) = 3 tri(n) = 1 + n / 2, si n est pari. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est dispare. Pro esèmpiu: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Si ti est dadu unu nùmeru intreu non negativu n, depes torrare una lista de sos primos nùmeros n + 1 de sa secuèntzia de Tribonacci. Esèmpios: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,srd_Latn,python,"
def digits(n):
    """"""Dadu unu nùmeru intreu positivu n, torrat su produtu de sas tzifras disparias. Torrat 0 si totu sas tzifras sunt paris.""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,srd_Latn,python,"
def is_nested(string):
    '''Creare una funtzione chi pigat comente input una cadena chi cuntenet petzos cuadrados. Sa funtzione depet torrare True si e solu si b'at una sutasegèntzia vàlida de petzos in ue a su mancu unu petzu in sa sutasegèntzia est imbastadu. is_imbastadu '[[]]') â -> True is_imbastadu '[[]]]]]]]]] [[[[[[]') â -> False is_imbastadu '[][]') â -> False is_imbastadu '[]') â -> False is_imbastadu '[[]]') â -> True is_imbastadu '[[]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,srd_Latn,python,"

def sum_squares(lst):
    """"""Si ti dan una lista de nùmeros, depes torrare sa summa de sos nùmeros cuadrados in sa lista, arrotondare ogni elementu in sa lista a su primu. Esèmpios: Pro lst = [1,2,3] s'output diat dèpere èssere 14 Pro lst = [1,4,9] s'output diat dèpere èssere 98 Pro lst = [1,3,5,7] s'output diat dèpere èssere 84 Pro lst = [1.4,4.2,0] s'output diat dèpere èssere 29 Pro lst = [-2.4,1,1] s'output diat dèpere èssere 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,srd_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Creare una funtzione chi torrat True si s'ùrtimu caràtere de una cadena dada est unu caràtere alfabèticu e non est una parte de una paràula, e False in casu contràriu. Nota: ""paràula"" est unu grupu de caràteres separados dae unu ispàtziu. Esèmpios: check_if_last_char_is_a_letter (((""apple pie"") â -> False check_if_last_char_is_a_letter (((apple pi e"") â -> True check_if_last_char_is_a_letter (((apple pi e "") â -> False check_if_last_char_is_a_letter"" ((("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,srd_Latn,python,"
def can_arrange(arr):
    """"""Creare una funtzione chi torrat s'inditze prus mannu de un'elementu chi non est prus mannu de o uguale a s'elementu chi dd'agatat in antis. Si no esistit un'elementu de custu tipu torrat -1.""""""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,srd_Latn,python,"
def largest_smallest_integers(lst):
    '''Creare una funtzione chi torrat unu tupla (a, b), in ue 'a' est su prus mannu de sos intreos negativos, e 'b' est su prus minore de sos intreos positivos in una lista. Si non b'at intreos negativos o positivos, torrat comente None. Esèmpios: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,srd_Latn,python,"
def compare_one(a, b):
    """"""Creare una funtzione chi pigat intreos, floats, o cadenas chi rapresentant nùmeros reales, e torrat sa variàbile prus manna in su tipu de variàbile dadu. Torrat None si sos balores sunt uguales. Nota: Si unu nùmeru reale est rapresentadu comente una cadena, su puntu flutuante diat pòdere èssere . o , compare_one(1, 2.5) â -> 2.5 compare_one(1, ""2,3"") â -> ""2,3"" compare_one(""5,1"", ""6"") â -> ""6"" compare_one(""1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,srd_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Avalorare si su nùmeru dadu n podet èssere iscritu comente a sa summa de 4 nùmeros paris positivos esémpiu is_equal_to_sum_even (a) == Falsu is_equal_to_sum_even (b) == Falsu is_equal_to_sum_even (c) == Fatu """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,srd_Latn,python,"
def special_factorial(n):
    """"""Su fatòriu brasilianu est definidu comente: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! ue n > 0 Pro esèmpiu: >>> special_factorial ((4) 288 Sa funtzione at a retzire un'intreu comente input e diat dèpere torrare su fatòriu ispetziale de custu intreu. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,srd_Latn,python,"
def fix_spaces(text):
    """"""_Esèmpiu-3u de cadena, remplasade totu sos ispàtzios cun sos sutascritos, e si una cadena tenet prus de 2 ispàtzios cunseguentes, remplasade totu sos ispàtzios cun - fix_spaces ((""Esèmpiu"") == ""Esèmpiu"" fix_spaces ((""Esèmpiu1"") == ""Esèmpiu1"" fix_spaces ((""Esèmpiu2"") == ""_Esèmpiu2"" fix_spaces ((""Esèmpiu 3"") == ""_Esèmpiu-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,srd_Latn,python,"
def file_name_check(file_name):
    """"""Creare una funtzione chi pigat una cadena chi rapresentat su nùmene de unu documentu, e torrat ""Sì"" si su nùmene de su documentu est bàlidu, e torrat ""No"" si no. Unu nùmene de documentu est cunsideradu bàlidu si e solu si totu sas cunditziones sighentes sunt cumpiladas: - Non b'ant a èssere prus de tres tzifras ('0'-'9') in su nùmene de su documentu. - Su nùmene de su documentu cuntenet unu puntu '.' - Sa suta-cadena in antis de su puntu non diat dèpere èssere bòida, e diat dèpere incumentzare cun una lìtera de s'alfabetu latinu ('a'-'z' e 'A'-Z'). - Sa suta-cadena a pustis de su puntu diat dèpere èssere una de custas: ['txt', 'exe', 'lld'] Esèmpios: file_name_check""{example.txt"") # => 'Sì' file_name_check""{example.txt1} => 'No' (su nùmene diat dèpere incumentzare cun una lìtera de s'alfabetu latinu) #""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,srd_Latn,python,"


def sum_squares(lst):
    """"""""Custa funtzione at a pigare una lista de intreos. Pro totu sas intradas in sa lista, sa funtzione at a cuadrare s'intrada intreu si s'inditze suo est unu mùltiple de 3 e at a cuare s'intrada intreu si s'inditze suo est unu mùltiple de 4 e non unu mùltiple de 3. Sa funtzione no at a cambiare sas intradas in sa lista chi sos inditzes no sunt unu mùltiple de 3 o 4. Sa funtzione at a torrare sa summa de totu sas intradas. Esèmpios: Pro lst = [1,2,3] s'uscita diat dèpere èssere 6 Pro lst = [] s'uscita diat dèpere èssere 0 Pro lst = [-1,-5,2,-1,-5] s'uscita diat dèpere èssere -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,srd_Latn,python,"
def words_in_sentence(sentence):
    """"""A ti est dadu unu filu chi rapresentat una frase, sa frase cuntenet carchi paràula separada dae unu ispàtziu, e depes torrare una cadena chi cuntenet sas paràulas de sa frase originale, chi sunt nùmeros primos, s'òrdine de sas paràulas in sa cadena noa depet èssere su matessi de s'originale. Esèmpiu1: Intrada: frase = ""Custa est una proa"" Esèmpiu2: Intrada: frase = ""lassat andare pro nadare"" Esèmpiu: ""go for"" Limites: * 1 <= len(sentence) <= 100 * sa frase cuntenet petzi lìteras """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,srd_Latn,python,"
def simplify(x, n):
    """"""Sa funtzione torrat True si x * n est unu nùmeru intreu e False si est unu nùmeru intreu. Siat x siat n sunt una rapresentatzione de cadena de una fratzione, e tenent su formadu chi sighit, <numerator>/<denominator>, in ue su numeratore e su denominadore sunt nùmeros intesos positivos. Si podet assumere chi x e n sunt fratziones vàlidas e non tenent zeru comente denominadore. simplificare "" 1/5 "", ""5/1"") = True simplificare "" 1/6 "", ""2/1"") = False simplificare "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,srd_Latn,python,"
def order_by_points(nums):
    """"""Iscrie una funtzione chi ordinat sa lista de sos intreos in òrdine creschente segundu sa summa de sas tzifras issoro. Nota: si b'at medas elementos cun summa sìmile de sas tzifras issoro, ordinaseles in base a s'inditze issoro in sa lista originale.""""""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,srd_Latn,python,"
def specialFilter(nums):
    """"""Iscriere una funtzione chi pigat una matrice de nùmeros comente input e torrat su nùmeru de elementos in sa matrice chi sunt prus mannos de 10 e siat sa prima siat s'ùrtima tzifra de unu nùmeru sunt dispàngios (1, 3, 5, 7, 9).""""""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,srd_Latn,python,"
def get_max_triples(n):
    """"""Si ti donat unu nùmeru intreu positivu n. Deves creare un'arràbiu de nùmeros intzeros a de longària n. Pro cada i (1 ‰¤ i ‰¤ n), su balore de a[i] = i * i - i + 1. Ritorna su nùmeru de triplicados (a[i], a[j], a[k]) de a ue i < j < k, e a[i] + a[j] + a[k] est unu mùltiple de 3. Esèmpiu: Input: n = 5 Output: 1 Ispiegatzione: a = [1, 3, 7, 13, 21] S'ùnicu triplo vàlidu est (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,srd_Latn,python,"
def bf(planet1, planet2):
    '''In su sistema solare nostru bi sunt oto pianetas: su prus a curtzu a su Sole est Mercuriu, su de sighida est Venere, a pustis Terra, Marte, Giove, Saturnu, Uranu, Nettunu. Iscriet una funtzione chi pigat duos nùmenes de pianetas comente a cadenas pianeta1 e pianeta2. Sa funtzione diat dèpere torrare una tupla chi cuntenet totu sos pianetas chi sas òrbitas issoro s'agatant intre s'òrbita de su pianeta1 e s'òrbita de su pianeta2, ordinadas pro sa prossimidade a su sole. Sa funtzione diat dèpere torrare una tupla bòida si su pianeta1 o su pianeta2 non sunt nùmenes de pianetas correctos. Esèmpios bf ""(Giove"", ""Nettuno"") ==> (""Saturno"", ""Uranu"") bf ((""Terra"", ""Mercuriu"") ==> (""Venere"", ""Terra"", ""Marte"", ""Giove"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,srd_Latn,python,"
def sorted_list_sum(lst):
    """"""Iscriere una funtzione chi atzetat una lista de cadenas comente a paràmetru, iscarrigat sas cadenas chi tenent longasas disparias e torrat sa lista resultante cun un'òrdine ordinadu. Sa lista est semper una lista de cadenas e mai un'arrègiu de nùmeros, e podet cuntènnere duplicados. S'òrdine de sa lista diat dèpere èssere ascendente pro longària de cada paràula, e si diat dèpere torrare sa lista ordinada cun cussa règula. Si duas paràulas tenent sa matessi longària, ordinare sa lista in manera alfabètica. Sa funtzione diat dèpere torrare una lista de cadenas in òrdine ordinadu. Si podet pensare chi totu sas paràulas tèngiant sa matessi longària. Pro esèmpiu: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,srd_Latn,python,"
def x_or_y(n, x, y):
    """"""Unu programma simpre chi diat dèpere torrare su balore de x si n est unu nùmeru primu e diat dèpere torrare su balore de y in casu contràriu.""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,srd_Latn,python,"
def double_the_difference(lst):
    '''Si b'at una lista de nùmeros, torrat sa summa de sos cuadrados de sos nùmeros in sa lista chi sunt dispari. Ignorare sos nùmeros chi sunt negativos o non intreos.'''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,srd_Latn,python,"
def compare(game,guess):
    """"""Creo chi totus nos ammentamus de cussa sentida cando su resurtadu de carchi eventu de longa ispera est a sa fine connotu. Is sentimentos e pensamentos chi tenimus in cussu momentu sunt de seguru de annotare e cunfrontare. Su traballu nostru est de determinare si una persone at indovinadu in manera curreta sos resurtados de unu nùmeru de partzidas. Ti sunt dados duos grupos de puntuaziones e indovinadas de longària uguale, in ue cada indice mustrat una partzida. Torra una sèrie de sa matessi longària chi denotat cantu est lontana cada indovinada. Si ant indovinadu in manera curreta, su balore est 0, e si nono, su balore est sa diferèntzia assoluta intre s'indovinada e su puntuazione. esèmpiu: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,1], -0,]) -> [4,4,0,1,0,6] """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,srd_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Sa fortza de s'estensione est sa chi sighit: CAP est su nùmeru de sas lìteras majusculas in su nùmene de s'estensione, e SM est su nùmeru de sas lìteras minúsculas in su nùmene de s'estensione, sa fortza est dada dae sa fratzione CAP - SM. Depeus agatare s'estensione prus forte e torrare una cadena in custu formadu: ClassName.StrongestExtensionName. Si b'at duas o prus estensiones cun sa matessi fortza, depet seberare sa chi benit prima in sa lista. Pro esempru, si ti est dadu ""Slices"" comente a sa classe e una lista de sas estensiones: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] tando depes torrare 'Slices.SEviRNGSliCes' ca 'SviRNGSliCes' est s'estensione prus forte', (esèmpiu: 'AA_Beats' est sa fortza de s'estensione prus forte', pro 'AA_Class').""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,srd_Latn,python,"
def cycpattern_check(a , b):
    """"""Ti sunt dados 2 paràulas. Deves torrare True si sa segunda paràula o una de sas rotatziones suas est una sutastàngiu in sa prima paràula cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,srd_Latn,python,"
def even_odd_count(num):
    """"""Dadu unu nùmeru intreu, torrat unu tupla chi tenet su nùmeru de tzifras paris e disparias rispettivamente. Esèmpiu: puru_podd_count(-12) ==> (1, 1) puru_podd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,srd_Latn,python,"
def int_to_mini_roman(number):
    """"""Dadu unu nùmeru intreu positivu, otenet s'ecuivalente numerale romanu suo comente a una cadena, e ddu torrat in lìteras minores.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,srd_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Dadu sas longas de sos tres lados de unu triàngulu. Torrat Fatu si sos tres lados formant unu triàngulu retanguladu, Falsu in casu contràriu. Unu triàngulu retanguladu est unu triàngulu in ue un'àngulu est retratu o 90 grados. Esèmpiu: triàngulu retanguladu (rectangle)'''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,srd_Latn,python,"
def find_max(words):
    """"""Iscriere una funtzione chi atzetat una lista de cadenas. Sa lista cuntenet paràulas diferentes. Torrat sa paràula cun su nùmeru màssimu de caràteres ùnicos. Si prus cadenas tenent su nùmeru màssimu de caràteres ùnicos, torrat su chi benit a primu in òrdine lessicogràficu.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,srd_Latn,python,"
def eat(number, need, remaining):
    """"""Si ses unu conìgliu famidu, e as giai papadu unu tzertu nùmeru de zigarros, ma como ti bisòngiat de papare prus zigarros pro cumpletare sos pranos de sa die. depes torrare un'arrèdditu de [ nùmeru totale de zigarros papados a pustis de sas merendas tuas, su nùmeru de zigarros abarrados a pustis de sas merendas tuas ] si non b'at su mancu de zigarros abarrados, ti at a papare totu sas zigarros abarrados, ma ti diat èssere semper famidu. Esempru: * papare (eater), 6, 10) -> [11, 4] * papare (eater), 8, 9) -> [12, 1] * papare (eater, 10, 10) -> [11, 0] * papare (eater, 11, 5) -> [7, 0] Variables: @number: nùmeru intreu: nùmeru de zigarros chi as papadu. @need: nùmeru intreu de zigarros chi bi cheres papare. @remaining: nùmeru intreu de zigarros abarrados in s'istant in s'istàcua: * constrin = 0 = <= 0 * restante: <= 1000 <= 0 * restante = <= 1000 <= 0 = restante = 1000 <= 1000 = 1000 <= 0 = 1000 = 1000 = 0 = 1000 = divertidu = 1000 = 1000 = divertidu""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,srd_Latn,python,"
def do_algebra(operator, operand):
    """"""Sa prima lista tenet operatziones de base de àlgebra, e sa segunda lista est una lista de intreos. Utilizade sas duas listas donadas pro fraigare s'espressione algèbrica e torrai s'avaloramentu de custa espressione. Sas operatziones de base de àlgebra: Addition (+) Subtraction ( - ) Multiplication ( *) Floor division ( // ) Exponentiation ( ** Example): operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 Nota: Sa longària de sa lista de operatores est uguale a sa longària de sa lista de operandos minus unu. S'operand est una lista de intreos non negativos. S'operador tenet a su nessi unu operadore, e sa lista de operandos tenet a su nessi duos operandos. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,srd_Latn,python,"
def solve(s):
    """"""Si ti est dada una stringa s. si s[i] est una lìtera, torra a invertire sa cassa sua dae bassu a artu o a s'invèrsia, si nono la mantenes comente est. Si sa stringa no cuntenet lìteras, torra a invertire sa stringa. Sa funtzione depet torrare sa stringa resultante. Esempros solve{""1234"") = ""4321""{""ab"") = ""AB""{""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,srd_Latn,python,"
def string_to_md5(text):
    """"""Si b'at una cadena 'text', torrat sa cadena ecuivalente a su hash md5. Si 'text' est una cadena bòida, torrat None. >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,srd_Latn,python,"
def generate_integers(a, b):
    """"""Dadu duos intreos positivos a e b, torrat sas tzifras paris intre a e b, in òrdine creschente.""""""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
