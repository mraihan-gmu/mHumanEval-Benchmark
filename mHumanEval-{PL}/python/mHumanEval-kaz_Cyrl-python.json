[
    {
        "task_id": "HumanEval/0",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Берілген сандар тізімінде берілген шекті мәннен бір-біріне жақын екі сан бар ма, жоқ па, тексеріңіз. Мысал: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) Жалған >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) Дұрыс \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Бұл функцияға енген - бірнеше топтағы тіркесімдерді қамтитын тізбе. Сіздің мақсатыңыз - сол топтарды жеке тізбелерге бөлу және олардың тізімін қайтару. Жеке топтар теңдестірілген (әрбір ашық тірек дұрыс жабылады) және бір-біріне тіркесілген емес. Кіріс тізбегіндегі кез келген бос орындарды елемеңіз. Мысал: >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ' ['() ', '(()) ', '(() ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Оң жылжымалы нүктелі санды берілген кезде оны бүтін сандар бөлігіне (ерекше берілген саннан кіші) және ондықтарға (өте қалған бөлігі әрқашан 1 -ден кіші) бөлшектеуге болады. Санның ондық бөлігін қайтарады. Мысал: >>> truncate_number(3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Сізге банктік шоттағы нөлдік баланстан басталатын депозиттік және ақша алу операцияларының тізімі беріледі. Сіздің міндетіңіз - кез келген уақытта шоттың балансы нөлден төмен түсіп қалса, оны анықтау және сол кезде функция True қайтаруы керек. Әйтпесе False қайтаруы керек. Мысал: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Берілген кіріс сандарының тізімі үшін осы деректер жиынтығының орта мәнінің айналасындағы орташа абсолюттік ауытқуды есептеңіз. Орташа абсолюттік ауытқу - әрбір элемент пен орта нүкте арасындағы орташа абсолюттік айырмашылық (осы жағдайда орташа): MAD = орташа █ x - x_орталық █ Мысал: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Кіріс тізімінің әрбір екі бірізді элементінің арасында \"алыс\" санын енгізіңіз `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Бұл функцияға енетін қатарға аралықпен бөлінген тіркесімдерді ендіру үшін бірнеше топтар бейнеленген. Әр топ үшін тіркесімдердің ең терең тіркесім деңгейін шығару. Мысалы (() (()) тіркесімнің ең көп екі деңгейі бар, ал ((())) үш. >>> parse_nested_parens (('((()) ((())) (((()) ((((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Кіріс тізіміндегі тек қана берілген ішкі тізбекті қамтитын тізбектерді сүзгілеу >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Берілген бүтін сандар тізімі үшін тізімдегі барлық бүтін сандардың қосындысы мен көбейтіндісінен тұратын топтаманы қайтарамыз. Бос жиынтық 0-ге тең, ал бос көбейтінді 1-ге тең болуы керек. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Берілген бүтін сандар тізімінен, тізбектегі берілген сәтке дейін табылған ең жоғары элементтердің тізімін жасаңыз. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Берілген тізбектен басталатын ең қысқа палиндромды табыңыз. Алгоритм идеясы қарапайым: - Берілген тізбектің палиндромдық ең ұзақ постфиксін табыңыз. - Палиндромдық жұрнақтың алдында келетін тізбектің префиксі тізбектің аяғына кері қосыңыз. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Берілген тізбе палиндромды тексеріп көру .\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Кірісі - бұл a және b екі тізбегі, олар тек 1 және 0-ден тұрады. Бұл кірулерге екілік XOR орындаңыз және нәтижеді тізбе ретінде қайтарып беріңіз. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Тізімдегі тізбелер ішінен ең ұзынды қайтарамыз. Бірдей ұзындығы бар бірнеше тізбе болған жағдайда біріншісін қайтарамыз. Кіріс тізімі бос болған жағдайда Жоқ-ты қайтарамыз. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"a және b екі бүтін сандарының ең үлкен ортақ бөлгішіне >>> ең үлкен_ ортақ_ бөлгішіне ((3, 5) 1 >>> ең үлкен_ ортақ_ бөлгішіне ((25, 15) 5  қайтарылады .\"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Кіріс тізбегінің ең қысқасынан ең ұзынасына дейінгі барлық префикстердің тізімін қайтарады >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"0-ден бастап n-ге дейінгі сандарды қамтитын сандар тізбесін қайтарады. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Берілген жолды таңдап, оның қанша түрлі таңбадан тұратындығын анықтаңыз (кейсеге қарамастан) >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Бұл функцияға арнайы ASCII форматында музыкалық ноталарды білдіретін ішекті енгізу. Сіздің тапсырмаңыз - көптеген соққыларға сәйкес келетін бүтіндердің ішекті тізімін талдау: 'o' нотасы, соңғы төрт соққы 'o' - No - жарты нота, соңғы екі соққы 'o' - Quater нота, соңғы бір соққы >>> parse_music '. 'o' o .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Берілген ішкі тізбекті бастапқы тізбекте қанша рет табуға болатынын табыңыз. Қайталанған жағдайларды санаңыз. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Кірістіру - \"нөлден\" \"тоғызға\" дейінгі сандар сандарының кеңістігімен шектелген тізбегі. Дұрыс таңдаулар: \"нөл\", \"бір\", \"екі\", \"үш\", \"төрт\", \"бес\", \"алты\", \"жеті\", \"сегіз\" және \"тоғыз\". Кішіден үлкенге қарай сұрыпталған сандар тізбегін қайтарады >>> sort_numbers ((('үш бір бес') 'бір үш бес' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"Берілген сандар тізімінен (ең аз дегенде екі ұзындығы бар) бір-біріне ең жақын екі санды таңдап, оларды ретпен қайтарады (кіші сан, үлкен сан). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Сандар тізімін (кем дегенде екі элементтен) берілген кезде, сол тізімге сызықтық түрлендіруді қолданыңыз, ең кіші сан 0 болады, ал ең үлкені 1 болады >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Тек бүтін сандар үшін кез келген Python мәндерінің берілген тізімін сүзгілеу >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"Берілген string-тің қайтарым ұзындығы >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Берілген n саны үшін n-ден кіші, n-ді тең бөліп беретін ең үлкен санды табыңыз >>> largest_divisor ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Берілген бүтін санның алғашқы көбейткіштерінің тізімін кішісінен үлкеніне дейін реттеп қайтарады. Әр фактордың көбейткіштерінің саны оның факторлауда қанша рет пайда болуына сәйкес болуы керек. Кіріс саны барлық факторлардың көбейтіндісіне тең болуы керек >>> факторлау ((8) [2, 2, 2] >>> факторлау ((25) [5, 5] >>> факторлау ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Бүкіл сандар тізімінен бірден артық кездесетін барлық элементтерді алып тастаңыз. Элементтердің реті кірістегідей қалдырыңыз. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Берілген тізбе үшін кіші әріптерді үлкен әріпке, үлкен әріптерді кіші әріпке ауыстырыңыз. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Бір қатардағы тізбелерді тізбелеу тізімі >>> тізбелеу (([]) '' >>> тізбелеу ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Тек берілген префикспен басталатын string тізімдерін сүзгілеу. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Тізімдегі тек оң сандарды қайтарады. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"Егер берілген сан алғашқы болса, true қайтарады, ал басқа жағдайда false қайтарады. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs - полиномиалдың коэффициенттері. find_zero x-ді табу үшін, poly(x) = 0. find_zero тек қана нөлдік нүкте, тіпті көп болса да қайтарады. Сонымен қатар, find_zero тек қана x-ді тізімге алады, ол тіпті коэффициенттер саны мен ең үлкен нөлдік емес коэффициентке ие, өйткені ол шешімді кепілдендіреді. >>> round (((find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"Х нүктесінде xs коэффициенттері бар көпмүшенді бағалайды. xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n  қайтарыңыз\"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Бұл функция l тізімін алады және l' үшке бөлінбейтін индекстердегі l-ге ұқсас, ал үшке бөлінбейтін индекстердегі оның мәндері l-дің сәйкес индекстерінің мәндеріне тең, бірақ сұрыпталған. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"Сұрыпталған бірегей элементтерді тізімде қайтарады >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Тізімдегі ең үлкен элементті қайтарады. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"11 немесе 13-ке бөлінетін n-ден кіші бүтін сандардағы 7 санының санын қайтарады. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Бұл функция l тізімін алады және l' тізімін қайтарады, сондықтан l' - жұп индекстердегі l-мен бірдей, ал оның жұп индекстердегі мәндері l-дің жұп индекстерінің мәндеріне тең, бірақ сұрыпталған. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"кіретін коды ретінде encode_cyclic функциясымен кодталған жолды алады. Декодталған жолды қайтарады. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"кодталған тізбекті үш таңбадан тұратын циклдік топтар арқылы қайтарады.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib n-ші санды қайтарады, ол Фибоначчи саны және ол да бірінші сан. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero кіріс ретінде бүтін сандар тізімін қабылдайды. Егер тізімде нөлге тең болатын үш ерекше элемент болса, ол True қайтарады, ал басқа жағдайда False. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Бұл функция екі машинаның бір-бірінен өте алыс жүріп бастағанын көрсетеді. Барлық машиналар бірдей жылдамдықпен қозғалады. Екі машина солдан оңға қарай қозғалатын машина оңдан солға қарай қозғалатын машинаны соққылағанда соқтығысады. Алайда, машиналар шексіз берік және күшті; нәтижесінде, олар өз траекториясында соқтығыспағандай қозғала береді. Бұл функция осындай соққылардың санын шығарады.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"элементтері 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124]) арқылы көбейтілген элементтермен қайтару тізімі.\"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero кіріс ретінде бүтін сандар тізімін алады. Егер тізімде нөлге тең екі элемент болса, ол True қайтарады, ал басқа жағдайда False. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Кіріс саны x сандық негізін негізге ауыстыру. Қайта түрлендіруден кейін тізбекті көрсету. негіздер саны 10-нан аз. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Үшбұрыштың бүйірінің ұзындығы мен жоғары қайту ауданы берілген. >>> үшбұрыштың ауданы ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4 сандар тізбегі - Фибоначчи тізбегіне ұқсас тізбе, ол келесідей анықталады: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4 сандар тізбегінің n-ші элементін тиімді есептеу үшін функция жазыңыз. Рекурсияны пайдаланбаңыз. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"Тізімдегі элементтердің қайтару медианы l. >>> медианы (([3, 1, 2, 4, 5]) 3 >>> медианы (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Берілген тізбекті палиндромның >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False екенін тексереді.\"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2^n модулі p-ді қайтарамыз (сандық белгілерді ескеріңіз). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"кіретін код ретінде encode_shift функциясымен кодталған жолды алады. Декодталған жолды қайтарады. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"әр таңбаны әліпбидегі 5 арқылы ауыстырып кодталған тізбекті қайтарады.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels - бұл сөз тізбегін алып, дауыстыларсыз сөз тізбегін қайтаратын функция. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd'\"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Егер l тізіміндегі барлық сандар t шегінен төмен болса, True қайтарады. >>> below_threshold([1, 2, 4, 10], 100) True >>> below_threshold([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"x және y екі санын қосу >>> қосу ((2, 3) 5 >>> қосу ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"Екі сөздің бірдей таңбалары бар ма, жоқ па, тексеріңіз. >>> same_chars ((('eabcdzzzz', 'dddzzzzzzzddeddabc') Дұрыс >>> same_chars ((('abcd', 'dddddddddabc') Дұрыс >>> same_chars ((('dddddddabc', 'abcd') Дұрыс >>> same_chars ((('eabcd', 'dddddddddabc') Жалған >>> same_chars ((('abcdd', 'dddddddabddce') Жалған >>> same_chars (((abcdzzzz', 'dddzzzzzzzddabc') Жалған \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-ші Фибоначчи санын қайтарады. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets - \"<\" және \">\" саптары. return True, егер әрбір ашылу жақшасында сәйкес келетін жабылу жақшасы болса. >>> correct_bracketing ((\"<\") False >>> correct_bracketing ((\"<>\") True >>> correct_bracketing ((\"<><>>\") True >>> correct_bracketing ((\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Қайтару True тізім элементтері монотонды түрде өсіп немесе азайып барады. >>> монотонды (([1, 2, 4, 20]) True >>> монотонды (([1, 20, 4, 10]) False >>> монотонды (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Екі тізім үшін реттелген бірегей ортақ элементтерді қайтарады. >>> ортақ (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> ортақ (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"n-дің ең үлкен жай көбейткішін қайтарамыз. n > 1 деп қабылдайық және ол жай көбейткіш емес. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n - 1 мен n аралығындағы сандарды қосқан функция. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets - \"(\" және \"\") дегендер. return True, егер әрбір ашылатын жақшада сәйкес келетін жабылатын жақшасы болса. >>> correct_bracketing (((\"(\") False >>> correct_bracketing (((\")) True >>> correct_bracketing (((()) True >>> correct_bracketing (((()) False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs - полиномияның коэффициенттері. xs[0] + xs[1] * x + xs[2] * x^2 + .... Бұл полиномияның туындысын сол формада қайтарады. >>> туындысы (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> туындысы[(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"FibFib сандар тізбегі - Фиббоначчи тізбегіне ұқсас тізбе, ол келесідей анықталады: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). fibfib сандар тізбегінің n-ші элементін тиімді есептеу үшін функция жазыңыз. >>> fibfib(1) 0 >>> fib fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"Vowels_count () функциясы сөзді білдіретін сөз тізбегін кіріс ретінде алып, оның дауыстыларының санын қайтарады. Бұл жағдайда дауыстылар 'a', 'e', 'i', 'o', 'u' болады. Бұл жерде 'y' да дауысты болады, бірақ тек берілген сөздің соңында болған кезде ғана. Мысал: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"Сынақ жағдайларын қосу. \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Кругтік x бүтін санның цифрларын жылжыту, цифрларды оңға жылжыту және нәтижені тізбе ретінде қайтару. Егер shift > цифрлар саны болса, цифрларды кері қайтару. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"Тапсырма Кіріспе ретінде тізбекті алып, ASCII кодтарының тек жоғарғы таңбаларының қосындысын қайтаратын функция жазу. Мысалдар: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"Бұл тапсырмада сізге алмалар мен апельсиндер санынан тұратын, жеміс себетіне орналастырылған, алмалар, апельсиндер және манго жемістерінен тұратын, санды көрсететін, тізбек беріледі. Жеміс себетіндегі алмалар мен апельсиндердің жалпы санын көрсететін, санды көрсететін бүтін санды келтірсек, себеттегі манго жемістерінің санын қайтарамыз. мысалы: fruit_distribution\"5(алма және 6 апельсин\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 алма және 1 апельсин\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 алма және 3 апельсин\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 алма және 120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"Бір массивтің тармағын көрсететін массивке теріс емес бүтін сандық түйіндер бар, сіздің міндетіңіз түйіндердің бірін алып, оны қайтару. Алған түйін ең кіші жұп мәні бар түйін болуы керек. Егер ең кіші жұп мәні бар бірнеше түйіндер табылса, ең кіші индексі бар түйінді қайтару керек. Алған түйін тізімде қайтарылуы керек, [smallest_value, оның индексі ], Егер жұп мәндер болмаса немесе берілген массив бос болса, қайтару []. Мысал: 1: Кіріс: [4,2,3] Шығыс: [2, 1] Түсініктеме: 2 ең кіші жұп мәні бар, ал 2 ең кіші индексі бар. Мысал: Кіріс: [1,2,3] Шығыс: [2, 1] Түсініктеме: 2 ең кіші мәні бар, ал 2 ең кіші жұп индексі бар. Мысал: Кіріс: [3,4] Шығыс: [5, 3, 4] Шығыс: 1 0, Шығыс: ең кіші индексі бар түйінді қайтару керек, бірақ ең кіші мәні бар. Мысал: * екі нөлден кем емес, ең кіші түйінді таңдаймыз.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''Сізге оң бүтін сандардың бос емес тізімі беріледі. Нөлден үлкен және бүтін санның өзіндік мәнінен үлкен немесе оған тең жиілікті ең үлкен бүтін санды қайтарады. Бүкіл санның жиілігі тізімде пайда болатын сандар саны. Егер мұндай мән болмаса, -1 қайтарады. Мысалдар: іздеу: (([4, 1, 2, 2, 3, 1]) == 2 іздеу: (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 іздеу: (([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''Бүкіл сандар тізімі берілген кезде, тізімді таңғажайып тәртіппен қайтарамыз. Қате сұрыптау - ең төменгі мәннен басталғанда, қалған бүтін сандардың ең көпінен кейін, содан кейін ең аз және т.б. Мысалдар: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''Үшбұрыштың үш бүйірінің ұзындығы берілген. Үш бүйір жарамды үшбұрышты құраса, үшбұрыштың ауданы 2 ондық нүктеге дейін дөңгеленген. Әйтпесе -1 қайтарылады. Үш бүйір кез келген екі бүйірдің қосындысы үшінші бүйірден үлкен болса, жарамды үшбұрышты жасайды. Мысал: triangle_area ((3, 4, 5) == 6.00 triangle_area ((1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''Егер q объектісі ұшса, True қайтаратын функция жазыңыз, ал басқа жағдайда False. Q объектісі ұшса, егер ол теңдестірілген болса (бұл палиндромдық тізім) және оның элементтерінің қосындысы w ең жоғары мүмкін салмақтан кем немесе оған тең болса. Мысал: will_it_fly (([1, 2], 5) â -> False # 1+2 ең жоғары мүмкін салмақтан аз, бірақ теңгерімсіз. will_it_fly (([3, 2, 3], 1) â -> False # теңгерімделген, бірақ 3+2+3 ең жоғары мүмкін салмақтан артық. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 ең жоғары мүмкін салмақтан аз, және ол теңгерімделген. will_it_fly ((([3], 5) â -> True # 3 ең жоғары мүмкін салмақтан аз, және ол теңгерімсіз.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"Сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің элементтерінің саны сандық массивтің саны сандық массивтің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерінің саны сандық элементтерімен тең элементтерінің санымен тең элементтерінің санымен тең элементтерінің санымен тең элементтерінің санымен тең элементтерінің санымен тең элементтерімен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен тең элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем кем элементтермен кем элементтермен кем кем кем кем кем кем кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем элементтермен кем кем элементтермен кем\"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''Екі тізімді қабылдап, тізімдегі барлық тізбелердегі таңбалардың жалпы саны екінші тізімнен аз болатын тізімді қайтаратын функция жазыңыз. Егер екі тізімде таңбалардың саны бірдей болса, бірінші тізімді қайтарамыз. Мысалдар total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Егер берілген сан 3 жай санның көбейтілуі болса, қайтаратыны true функциясын жазыңыз. (a) 100-ден аз екенін білгенде. Мысал: is_multiply_prime(30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Сіздің міндетіңіз - x саны n-дің қарапайым дәрежесі болса, дұрыс, ал басқа жағдайларда жалған функция жазу. x n-дің қарапайым дәрежесі болса, x = x Мысалы: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) => false is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''a бүтін санын алып, True қайтаратын функция жазыңыз, егер бұл integer - бүтін санның кубы болса. Ескерту: кіріс әрқашан жарамды деп есептеуге болады. Мысалдар: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"Сізге он алтылық санды тізбек ретінде қабылдайтын және он алтылық санның алғашқы сандарының санын есептейтін функция жазу тапсырылды (төп сан немесе алғашқы сан - бұл екі кіші табиғи санның көбейтіндісі емес, 1-ден үлкен табиғи сан). Он алтылық сандар 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Түп сандар 2, 3, 5, 7, 11, 13, 17,... Сонымен, сіз келесі сандардың санын анықтауыңыз керек: 2, 3, 5, 7, B (= ондық 11), D (= ондық 13). Ескерту: Сіз кіріс әрқашан дұрыс немесе бос деп есептеуге болады, ал символдар A,B,C,D,E,F әрқашан үлкен әріптер. Мысалдар: \"АБ\" үшін шығыс 1. болуы керек \"АБ\" үшін шығыс 2. болуы керек \"1077E\" үшін шығыс 2. болуы керек \"АБ\" үшін \"АБ\" үшін \"АБ\" үшін \"АБ\" болуы керек 4.89. \"АБ\" үшін \"АБ\" үшін \"А\" болуы керек 6.01234567.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Сізге ондық форматтағы сан беріледі және сіздің міндетіңіз оны екілік пішімге аудару. Функция әр таңбасы екілік санды білдіретін жолды қайтару керек. Жолдағы әрбір таңба '0' немесе '1' болады. Жолдың басында және соңында 'db' қосымша таңбалар болады. Қосымша таңбалар пішімге көмектеседі. Мысал: decimal_to_binary(15) # қайтарады \"db1111db\" decimal_to_binary32) # қайтарады \"db100000db\"\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"Сізге s деген жол беріледі. Сіздің міндетіңіз - оның бақытты немесе емес екенін тексеру. Егер оның ұзындығы кем дегенде 3 болса және әрбір 3 бірізді әріп ерекше болса, онда жол бақытты. Мысалы: is_happy (a) => False is_happy (a) => False is_happy (a) => False is_happy (b) => True is_happy (a) => False is_happy (a) => False is_happy (b) => True is_happy (x) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Бұл семестрдің соңғы аптасы және мұғалім студенттерге баға беруі керек. Мұғалім өз алгоритмін жасап отыр. Бір ғана мәселе, ол баға беру үшін қолданған кодты жоғалтты. Ол сізге кейбір студенттердің GPA тізіміне берді және сіз келесі кесте арқылы әріп бағаларының тізімін шығаратын функция жазуыңыз керек: GPA. Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E мысал: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"Сызық алып, оның ұзындығы жай сан болса, True немесе басқа жағдайда False қайтаратын функция жазыңыз Мысалдар prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Қосымша n санды беріп, 1-ден басталатын немесе 1-мен аяқталатын n-санды оң бүтін сандардың санын қайтарамыз.\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"N = 1000 үшін цифрлар қосындысы 1 болады, шығыс \"1\" болуы керек. N = 150 үшін цифрлар қосындысы 6 болады, шығыс \"110\" болуы керек. N = 147 үшін цифрлар қосындысы 12 болады, шығыс \"1100\" болуы керек. Өзгергіштер: @N бүтін сандар шектеулері: 0 â‰¤ N â‰¤ 10000. Шығыс: екілік сандар тізбегі \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"Бос емес бүтін сандар тізімін келтірсек, lst. жұп элементтерді жұп индекстермен қосу. Мысал: add (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Сызықтарды алып, олардың реттелген нұсқасын қайтаратын функция жазу. Сызықтың реттелген нұсқасы - бұл барлық сөздер (аралықпен бөлінген) ASCII мәнінің негізінде жоғарылайтын тәртіппен орналастырылған жаңа сөзбен ауыстырылатын, барлық таңбалар орналасқан, сөз тізбегі. Ескерту: Сөздердің және бос орынның реті сөйлемде сақталуы керек. Мысалы: anti_shuffle ((('Hi') қайтарады 'Hi' anti_shuffle ((('hello') қайтарады 'ehllo' anti_shuffle (('Hello World!!!') қайтарады 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"Сізге 2 өлшемді деректер беріледі, ұялы тізім ретінде, бұл матрицаға ұқсас, бірақ матрицалардан айырмашылығы, әр жолда бағандардың саны әртүрлі болуы мүмкін. lst және x бүтін сандарын ескере отырып, тізімде x бүтін сандарын тауып, тізімді қайтарамыз, және тізімді қайтарамыз, [(x1, y1), (x2, y2) ...] әр тупель координаты - (жол, бағандар), 0-ден басталады. Бастапқыда координаттарды жолақтар бойынша көтерілу тәртібімен сұрыптаңыз. Сондай-ақ, қатардың координаттарын бағандар бойынша төмендеу тәртібімен сұрыптаңыз. Мысалдар: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (2, 5), (2, 0) get_(], 1) [] == [[, 1, 2, 3, 2]]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"Негізгі элементтердің жиынтығы (бірінші индекс, соңғы индекс) тақ болса, онда массивті жоғарылайтын тәртіппен сұрыптаймыз, ал егер жиынтығы (бірінші индекс, соңғы индекс) жұп болса, онда төмендейді.\"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"Encrypt функциясын құру, ол аргумент ретінде тізбекті алады және әліпбиді айналдыра отырып, шифрланған тізбекті қайтарады. Әліпби екі орынға екі есе көбейтіліп төмен қарай ауысатын түрде айналдырылуы керек. Мысалы: encrypt (('hi') қайтарады 'lm' encrypt (('asdfghjkl') қайтарады 'ewhjklnop' encrypt (('gf') қайтарады 'kj' encrypt (('et') қайтарады 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"Сізге бүтін сандар тізімі берілген. Тізімдегі ең кіші элементтің екіншісін қайтаратын next_smallest () функциясы жазыңыз. Егер мұндай элемент болмаса, None () функциясы қайтарылады. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == Next_smallest () == None\"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"Сізге сөз тізбегі беріледі, ал сіздің міндетіңіз - шаршаулардың санын санау. Шаршау - бұл \"Мен\" сөзімен басталатын сөйлем. Сөйлемдер \"\", \"?\" немесе \"! \" арқылы шектеледі. Мысалы: >>> шаршады. \"Әлемге сәлем\") 0 >>> шаршады. \"Аспан көк. Күн жарқырап тұр. Мен осы ауа райын жақсы көремін\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''3 санды қабылдайтын функция құру. Сандардың бірі қалған екеуінің қосындысына тең болса, және барлық сандар бүтін сандар болса, қайтарады. Басқа жағдайларда жалған қайтарады. Мысалдар any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"Хатты алып, барлық әріптердің кейсін ауыстырып, хабарламадағы барлық дауыстыларды ағылшын алфавиті бойынша дауыстыдан 2 орын алдыда тұрған әріппен алмастыратын функция жазыңыз. Тек әріптерді ғана алыңыз. Мысалдар: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Сізге бүтін сандар тізімі берілген. Сізге ең үлкен алғашқы мәнді тауып, оның цифрларының қосындысын қайтару керек. Мысалдар: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] шығыс 10 болуы керек lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] шығыс 25 болуы керек lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] шығыс 13 болуы керек lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] шығыс 11 болуы керек lst = [0,81,12,3,21,1] шығыс 3 болуы керек lst = [0,1,8,1,2,7] шығыс 7 болуы керек \"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Сөздік берілген жағдайда, егер барлық пернелер кіші әріптердегі тізбектер болса, True қайтарады, әйтпесе False қайтарады. Функция False қайтаруы керек, егер берілген сөздік бос болса. Мысалдар: check_dict_case{\"a\":\"Apple\", \"b\":\"Banana\"}) True қайтаруы керек. check_dict_case{\"a\":\"Apple\", \"A\":\"Banana\", \"B\":\"Banana\"}) False қайтаруы керек. check_dict_case{\"a\":\"Apple\", 8:\"Banana\", \"a\":\"Apple\"}) False қайтаруы керек. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False қайтаруы керек. check_dict_case{\"NC\":\"STATE\", \"ZIP\":\"45\") True қайтаруы керек.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"Теріс емес бүтін санды алып, n-ден кіші, алғашқы n бүтін саннан тұратын массивті қайтаратын функцияны іске асыру. Мысалы: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"Екі бүтін санды алып, олардың бірлік цифрларының көбейтіндісін қайтаратын функцияны толтырыңыз. Кіріс әрқашан жарамды деп есептеңіз. Мысалдар: көбейту ((148, 412) қайтару керек 16. көбейту ((19, 28) қайтару керек 72. көбейту ((2020, 1851) қайтару керек 0. көбейту ((14,-15) қайтару керек 20. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"S деген жолды келтірсек, жұп индекстердегі бас әріпті дауыстылардың санын санап шығамыз. Мысалы: count_upper (('aBCdEf') қайтаратыны 1 count_upper (('abcdefg') қайтаратыны 0 count_upper (('dBBE') қайтаратыны 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''Санды білдіретін мәнді (тізбекті) алып, оған ең жақын бүтін санды қайтаратын функция жасаңыз. Егер сан екі бүтін саннан тең қашықтықта болса, оны нөлден алыстатыңыз. Мысалдар >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 Ескерту: Нөлден алыстату дегеніміз, егер берілген сан екі бүтін саннан тең қашықтықта болса, сіз қайтарылатын сан нөлден ең алыс сан болуы керек. Мысал үшін closest_integer \" ((14.5\") 15 қайтаруы керек, ал closest_integer \" ((-14.5\") -15 қайтаруы керек. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"n оң бүтін санды беру үшін n деңгейлі тастардан үйме жасау керек. Бірінші деңгейде n тастар бар. Келесі деңгейдегі тастардың саны: - n - тақ сан болса, келесі тақ сан. - n - жұп сан болса, келесі жұп сан. Әр деңгейдегі тастардың санын тізімде қайтарамыз, мұнда индекс i элементі деңгейдегі тастардың санын білдіреді (i+1). Мысалдар: >>> make_a_pile(3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"Сізге үтірмен немесе бос орынмен бөлінген сөз тізбегі беріледі. Сіздің міндетіңіз - сөз тізбегін сөздерге бөліп, сөздердің массивін қайтару. Мысалы: words_string ((\"Сау болыңыз, менің атым Джон\") == [\"Сау болыңыз\", \"Менің\", \"Аты\", \"Бұл\", \"Джон\"] words_string ((\"Бір, екі, үш, төрт, бес, алты\") == [\"Бір\", \"Екі\", \"Үш\", \"Төрт\", \"Бес\", \"Алты\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"Бұл функция екі оң санды x және y алады және [x, y] аралығында ең үлкен жұп бүтін санды қайтарады. Егер мұндай сан болмаса, онда функция -1 қайтарады. Мысалы: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Сізге n және m деген екі оң бүтін сандар беріледі, ал сіздің міндетіңіз n-ден m-ге дейінгі бүтін сандардың орташасын есептеу (n және m-ді қоса алғанда). Жауапты ең жақын бүтін санға дөңгелектеп, оны екілік санға айналдырыңыз. Егер n-ден үлкен болса, -1-ді қайтарамыз. Мысал: rounded_avg(1, 5) => \"0b11\" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => \"0b1111\" rounded_avg(20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"Қосымша сандар тізімі берілген x. жұп сандары жоқ барлық элементтердің сұрыпталған тізімін қайтарады. Ескерту: Қайтарылған тізім өсу тәртібімен сұрыпталуы керек. Мысалы: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"Бүкіл сандар массиві берілген кезде, 1 мен 9 арасындағы бүтін сандарды сұрыптап, алынған массивті кері бұрамыз, содан кейін әрбір цифрды \"Бір\", \"Екі\", \"Үш\", \"Төрт\", \"Бес\", \"Алты\", \"Жеті\", \"Сегіз\", \"Тоғыз\" дегеннен тиісті атымен ауыстырамыз. Мысалы: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> сұрыптау arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> кері arr -> [8, 5, 4, 3, 2, 2, 1, 1] қайтару [\"Сегіз\", \"Төрт\", \"Үш\", \"Екі\", \"Екі\", \"Бір\", \"Бір\"] Егер массив бос болса, бос массив қайтарады: arr = [] қайтару [] Егер массивте таңғалар саны болса, оны елемеңіз: arr = [1, -1 , 55] -> сұрыптау -> [1, 55] -> кері arr = [55,1] - қайтару ['1,'] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"n параметрі ретінде f функциясын іске асырыңыз және n өлшемді тізімді қайтарады, егер i индексіндағы элементтің мәні i-дің факториалы болса, егер i жұп болса немесе 1 мен i арасындағы сандардың қосындысы болса. i 1-ден басталады. i-нің факториалы 1 мен i арасындағы сандардың көбейтуі (1 * 2 * ... * i). мысал: f ((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"Қосымша n санды келтірсек, оның ішінде ((1, n) аралығында келетін жұп және тақ бүтін палиндромдар саны бар топтаманы қайтарамыз. Мысал1: Кіріс: 3 Шығыс: (1, 2) Түсініктеме: бүтін палиндромдар 1, 2, 3. олардың бірі жұп, екеуі тақ. Мысал2: Кіріс: 12 Шығыс: (4, 6) Түсініктеме: бүтін палиндромдар 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. олардың төртеуі жұп, ал 6-ы тақ. Ескерту: 1. 1 <= n <= 10^3 2. топтамада жұп және тақ бүтін палиндромдар саны қайтарылды. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"Санның сандық қосындысы > 0 элементтер санын қайтаратын count_nums функциясын жазыңыз. Егер сан теріс болса, онда оның бірінші қол қойылған цифрлары теріс болады: мысалы, -123 -1, 2 және 3 сандары бар: >>> count_nums (([]) == 0 >>> count_nums ([-1, 11, -11]) == 1 >>> count_nums ([(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Бізде N бүтін сандардан тұратын 'arr' массиві бар arr[1], arr[2], ..., arr[N]. Массивтегі сандар кездейсоқ реттелген болады. Сіздің міндетіңіз - берілген массивте келесі операцияны орындау арқылы кемімейтін тәртіппен реттелген массивті алу мүмкіндігін анықтау: Сізге оңға ауысу операциясын кез келген санда орындау рұқсат етіледі. Бір оңға ауысу операциясы массивтің барлық элементтерін оң бағытта бір орынға ауыстыруды білдіреді. Массивтің соңғы элементі массивтің бастапқы орнына, яғни 0-шы индекске ауыстырылады. Егер жоғарыда көрсетілген операцияны орындау арқылы реттелген массивті алу мүмкін болса, онда қайтару True, басқасы False. Егер берілген массив бос болса, қайтару True. Ескерту: Берілген тізімде бірегей элементтер болуына кепілдік беріледі. Мысалы: move_one_(ball[3, 4, 5, 2>========================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Бұл мәселеде сіз сандардың екі тізімін алатын және lst1 тек жұп сандардың тізіміне айналдыру үшін олардың арасындағы элементтерді алмастыру мүмкіндігін анықтайтын функцияны іске асырады. lst1 және lst2 арасындағы алмастырылған элементтердің санына шектеу жоқ. lst1 және lst2 арасындағы элементтерді алмастыру мүмкін болса, lst1 элементтерінің барлығы жұп болсын деп, \"Иә\" деп қайтарасыз. Әйтпесе, \"ЖОҚ\" деп қайтарасыз. Мысалы: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"Иә\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"ЖОҚ\" Кіріс тізімдері бос болмайды деп болжанады. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"Ауыспен бөлінген кіші әріптерді білдіретін тізбек берілген болса, ең көп қайталанатын және тиісті санына сәйкес келетін әріптің сөздігін қайтарамыз. Егер бірнеше әріп бірдей кездессе, олардың бәрін қайтарамыз. Мысал: гистограмма ((('a b c') == {'a': 1, 'b': 1, 'c': 1} гистограмма ((('a b b a') == {'a': 2, 'b': 2} гистограмма ((('a b c a b') == {'a': 2, 'b': 2} гистограмма ((('b b a') == {'b 4}: гистограмма (((')) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Тапсырма Бізге s және c екі тізбегі берілген, s-дегі кез келген c таңбасына тең барлық таңбаларды өшіру керек, содан кейін нәтижелі тізбектің палиндром екенін тексеріңіз. Егер ол алдыңғы және артқа қарай бірдей оқылса, онда тізбекті палиндром деп атайды. Сіз нәтижелі тізбекті және True / False-ді қамтитын тупельді қайтаруыңыз керек. Мысал үшін s = \"abcde\", c = \"ae\", нәтиже ('bcd', False) болуы керек s = \"abcdef\", c = \"b\" нәтижесі ('acdef', False) болуы керек s = \"abcdedcba\", c = \"ab\", нәтиже ('cdedc', True) болуы керек.\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"Әр жол тек сандардан тұратын тізімді беріп, тізімді қайтарамыз. Шығыстың әр элементі i \"ішінгі i жолдағы тақ элементтердің саны\" болуы керек. мұнда барлық i-лер кірістің i-ші жолдағы тақ сандардың санына ауыстырылуы керек. >>> odd_count['1234567']) [\"4n str4ng 4 of the 4nput.\"] >>> odd_count['3',\"111111\"]) [\"1n str1ng 1 of the 1nput.\", \"8n str8ng 8 of the 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Сандар массивін келтірсек, сандардың бос емес қосалқы массивінің ең аз қосындысын табыңыз. Мысал minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Сізге құдықтардың тікбұрышты торлары беріледі. Әр қатар бір құдықты білдіреді, ал әрбір 1 қатарда бір бірлік суды білдіреді. Әр құдықтың одан су алуға қолданылатын сәйкес келетін бөгеті бар, және барлық бөгеттердің сыйымдылығы бірдей. Сіздің міндетіңіз - бөгеттерді құдықтарды босатқанда пайдалану. Бөгеттерді төмендету үшін қанша рет қажет екенін шығару. Мысал 1: Кіріс: тор: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] бөгеттің сыйымдылығы: 1 Шығысы: 6 Мысал 2: Кіріс: тор: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] бөгеттің сыйымдылығы: 2 Шығысы: 5 Мысал 3: Кіріс: [[0,0,0], [0,0,0]] бөгеттің сыйымдылығы: 5 * 0 * 1 * * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * * * 10 * 10 * 10 * * * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * * * * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"Бұл катада сіз теріс емес бүтін сандар массивін олардың бинарлық бейнелеуіндегі бірліктердің саны бойынша көтерілу тәртібімен сұрыптауыңыз керек. Бірліктердің ұқсас саны үшін ондық мәнге негізделген сұрыптау. Оны былай іске асыру керек: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"S сабы мен n натуралды санды ескере отырып, сізге s сабындағы барлық сөздердің тізімімен қайтаратын функцияны іске асыру тапсырылды, бұл сөздер s сабында пайда болуы үшін дәл n ымсыздарды қамтиды. Егер s сабы бос болса, онда функция бос тізімді қайтарады. Ескерту: кіріс тізбесінде тек әріптер мен бос орындар бар деп есептеуге болады. Мысалдар: select_words (\"Марияның кішкентай тоқтысы бар еді\") 3) ==> [\"Марияның кішкентай тоқтысы бар еді\"] select_words (\"әдемі бос орын\"), 2) ==> [] select_words (\"Сәлем, әлем\") 4) ==> [\"Әлем\"] select_words (\"Сам аға\", 3) ==> [\"Аға\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Сізге сөз беріледі. Сіздің міндетіңіз сөздің оң жағындағы екі дауыссыз арасында тұрған ең жақын дауыстыны табу (кезеңдік). Басында және соңында дауыстылар есептелмейді. Жоғарыда көрсетілген шартты орындаған дауыстыны таппасаңыз, бос жолды қайтарасыз. Берілген жол тек ағылшын әріптерін ғана қамтиды деп болжауға болады. Мысал: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''Сізге екі тізбе берілген, екі тізбе де тек '(' ашық жақшалардан немесе ') ' жабық жақшалардан тұрады. Сіздің жұмысыңыз екі тізбекті белгілі бір тәртіппен біріктіру мүмкін екенін тексеру, нәтижесінде тізбегі жақсы болатынын тексеру. S тізбегі S-дегі барлық жақшалар теңгерімде болса ғана жақсы деп саналады. Мысалы: '((())' тізбегі жақсы, ал '())' тізбегі жақсы емес. Егер жақсы тізбекті жасаудың жолы болса, 'Иә' деп қайтарып, 'Жоқ' деп қайтарып беріңіз. Мысалдар: match_parens[('() ', ') ']) == 'Иә' match_parens[(') ', ') ']) == 'Жоқ' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"Бүкіл сандар мен k оң бүтін саннан тұратын arr массиві берілген, k ұзындығындағы реттелген тізімді arr-дағы ең көп k сандармен қайтарамыз. Мысал1: Кіріс: arr = [-3, -4, 5], k = 3 Шығыс: [-4, -3, 5] Мысал2: Кіріс: arr = [4, -4, 4], k = 2 Шығыс: [4, 4] Мысал3: Кіріс: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Шығыс: [2] Ескерту: 1. Массивтің ұзындығы [1, 1000] аралығында болады. 2. Массивтегі элементтер [-1000, 1000] аралығында болады. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"Бос емес бүтін сандар тізімінен алынған, жұп орындағы барлық тақ элементтердің қосындысын қайтарады. Мысалдар шешімі (([5, 8, 7, 1]) ==> 12 шешімі (([3, 3, 3, 3, 3]) ==> 9 шешімі (([30, 13, 24, 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Бос емес arr және k бүтін сандар массиві берілген, arr элементтерінің алғашқы k элементтерінен ең көп дегенде екі цифрлы элементтердің қосындысын қайтарады. Мысал: Кіріс: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Шығыс: 24 # 21 + 3 жиынтығы Шектеулер: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"Қосымша n санды келтірсек, Collatz тізіміне көбейіп отыратын реттелген тізімді қайтарамыз. Collatz болжамы - математикадағы келесідей анықталатын тізбеге қатысты болжама: кез келген оң бүтін n саннан бастаңыз. Содан кейін әр термин алдыңғы терминнен келесідей алынады: егер алдыңғы термин жұп болса, келесі термин алдыңғы терминнің жартысы болады. Егер алдыңғы термин тақ болса, келесі термин алдыңғы терминнің 3 еселіге қосылады. n-дің қандай мәніне қарамастан, тізбе әрқашан 1-ге жетеді. Ескерту: 1. Collatz (((1) [1] 2. Қайтарылған тізім өсу тәртібімен реттелген. Мысалы: get_odd_collatz (((5) қайтарады [1, 5] # 5 үшін Collatz тізбегі [5, 8, 16, 4, 2, 1], сондықтан тек тақ сандар 1 және 5 \"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"Сіз берілген күн тізбегін растайтын функция жазуыңыз керек және егер күн жарамды болса, шынды қайтарады, әйтпесе жалған. Егер келесі ережелердің бәрі орындалса, күн жарамды: 1. Күн тізбегі бос емес. 2. Күн саны 1,3,5,7,8,10,12 айларда 1 күннен кем емес немесе 31 күннен артық емес. 4,6,9,11 айларда күн саны 1 күннен кем емес немесе 30 күннен артық емес. 2. Айлар 1 күннен кем емес немесе 12 күннен артық болмауы керек. 4. Күн форматында болуы керек: mm-dd-yyyy мысалы: valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-02040') => false_date (('06-04-2020') => true_date (('06/04/2020') => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''Сөздер тізбегін келтірсек, бос орынға бөлінген сөздердің тізімін қайтарамыз, егер мәтінде бос орын болмаса, онда тырнақпен бөлінеді ',' егер тырнақ болмаса, онда алфавиттегі таңбалар ретімен таңбалардың санын қайтарамыз, ord (('a') = 0, ord (('b') = 1, ... ord ((('z') = 25 Мысалдар split_words ((\"Hello world!\") â -> [\"Hello\", \"world!\"] split_words ((\"Hello,world!\") â -> [\"Hello\", \"world!\" split_words ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''Сандар тізімі берілген болса, олардың өсу тәртібімен сұрыпталуы немесе жоқ екендігі қайтарылады. Егер тізімде бірдей санның 1 -ден астам қайталануы болса, Жалған қайтарылады. Теріс сандар жоқ және тек бүтін сандар ғана. Мысалдар: is_sorted (,) -> True is_sorted (,) [1, 2, 3, 4, 5]) -> True is_sorted (,) [1, 2, 3, 4, 5, 6]) -> True is_sorted (,) [1, 2, 3, 4, 5, 6, 7]) -> True is_sorted (,) [1, 3, 2, 4, 5, 6, 7]) -> False is_sorted (,) [1, 2, 2, 3, 3, 4 (]) -> True is_sorted (,) [1, 2, 2, 2, 3, 4 (,) -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Сізге екі интервал беріледі, онда әр интервал бүтін сандар жұбы. Мысалы, интервал = (бастау, аяқтау) = (1, 2). Берілген интервалдар жабық, яғни интервал (бастау, аяқтау) бастау мен аяқтауды қамтиды. Әр берілген интервал үшін оның басталуы оның аяғына тең немесе одан аз деп есептеледі. Сіздің міндетіңіз осы екі интервалдың қиылысу ұзындығы алғашқы сан екенін анықтау. Мысалы, интервалдардың қиылысу ұзындығы (1, 3), (2, 4) (2, 3) болып табылады, оның ұзындығы 1 және алғашқы сан емес. Егер қиылысу ұзындығы алғашқы сан болса, \"ИӘЙ\" деп қайтарыңыз, әйтпесе \"ЖОҚ\" деп қайтарыңыз. Егер екі интервал қиылыспаса, \"ЖОҚ\" деп қайтарыңыз. [ішкі / шығыс] мысалдар: қиылысу: ((((1, 2), (2, 3) ==> \"ҚЫРЫСЫРЫСЫРЫРЫСЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫРЫР\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"Сізге бүтін сандар массиві беріледі және сіз массивтегі әр санның барлық белгілерінің көбейтіндісімен көбейтілген бүтін сандардың шамаларының қосындысын қайтаруыңыз керек, ол 1, -1 немесе 0 арқылы бейнеленеді. Ескерту: бос arr үшін ештеңе қайтарылмайды. Мысал: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Ешқайсысы жоқ\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"N қатарлы және N бағанды (N >= 2) және k оң бүтін санды құрайтын торды ескере отырып, тордың әрбір ұяшығында мән болады. [1, N * N] аралығындағы әрбір бүтін сан тордың ұяшықтарында дәл бір рет пайда болады. Сіз тордағы k ұзындығының ең аз жолын табуыңыз керек. Сіз кез келген тордан бастай аласыз, және әрбір қадамда сіз көрші ұяшықтардан кез келгеніне көшуіңізге болады, басқаша айтқанда, сіз қазіргі тормен жиегін бөлісетін ұяшықтардан кез келгеніне бара аласыз. K ұзындығындағы жол дәл k ұяшықты (қажет емес) аралауды білдіретінін ескеріңіз. Сіз тордан шықпаңыз. A жолы (k ұзындығы) B жолынан (k ұзындығы) кіші деп саналады, егер A және B ұяшықтарындағы мәндердің реттелген тізімдерін жасағаннан кейін (оларды l_st және l_stA деп атаймыз), l_stA лексикалық жағынан l_stB ұяшығынан кем болса, басқаша айтқанда, k ұяшықтағы бар ұяшыққа ауыса аласыз.\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"Фибоначчи тізбесін бәрі біледі, оны соңғы екі ғасырда математиктер терең зерттеді. Алайда, адамдардың білмейтіндері Трибоначчи тізбесін біледі. Трибоначчи тізбесін қайталану арқылы анықталады: tri(1) = 3 tri(n) = 1 + n / 2, егер n жұп болса. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), егер n тақ болса. Мысалы: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Сізге n теріс емес бүтін сандар берілген, сізге Трибоначчи тізбесінің алғашқы n + 1 сандарының тізімін қайтару керек. Мысал: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"Қосымша n санды келтірсек, онда тақ сандардың көбейтіндісін қайтарамыз. Егер барлық сандар жұп болса, 0 қайтарамыз. Мысалы: сандар ((1) == 1 сан ((4) == 0 сан ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''Тек квадратты жақшаларды қамтитын тізбекті енгізу ретінде алатын функция құру. Егер және тек қана егер жақшалардың кем дегенде бір жақшасы тіркесілген дұрыс тізбегі болса, функция True қайтаруы керек. is_nested'[[]]') â -> True is_nested'[[]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[[]') â -> False is_nested'[[]]') â -> True is_nested'[[]]]]') â -> True'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Сізге сандар тізімі беріледі. Сізге берілген тізімдегі сандардың квадратының қосындысын қайтару керек, алдымен тізімдегі әрбір элементті жоғарғы int ((Жоғары) дейін дөңгелетіңіз. Мысалдар: lst = [1,2,3] шығысы 14 болуы керек lst = [1,4,9] шығысы 98 болуы керек lst = [1,3,5,7] шығысы 84 болуы керек lst = [1.4,4.2,0] шығысы 29 болуы керек lst = [-2.4,1,1] шығысы 6 болуы керек \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''Берілген тізбектегі соңғы таңба әріптік таңба болса, және сөздің бөлігі болмаса, ЖАЛҒЫ қайтаратын функция құру. Ескерту: \"сөз\" - бос орынмен бөлінген таңбалар тобы. Мысалдар: check_if_last_char_is_a_letter ((\"Apple pie\") â -> False check_if_last_char_is_a_letter (((\"apple pi e\") â -> True check_if_last_char_is_a_letter ((\"apple pi e\") â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"Егер элемент болмаса, -1 қайтарамыз. Берілген массивде қайталанған мәндер болмайды. Мысал: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''Функцияны құру, ол tuple (a, b) қайтарады, мұнда 'a' - теріс бүтін сандардың ең үлкені, ал 'b' - тізімдегі оң бүтін сандардың ең кішісі. Егер теріс немесе оң бүтін сандар болмаса, оларды Жоқ деп қайтарамыз. Мысалдар: ең үлкен_ең кіші_ бүтін сандар[2, 4, 1, 3, 5, 7]) == (Жоқ, 1) ең үлкен_ең кіші_ бүтін сандар (([]) == (Жоқ, Жоқ) ең үлкен_ең кіші_ бүтін сандар ((0]) == (Жоқ, Жоқ) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"Нақты сандарды бейнелейтін бүтін сандарды, float сандарды немесе string сандарды қабылдайтын функция құру және берілген түрдегі үлкен ауыспалы санды қайтару. Құндылықтар тең болса, None санды қайтару. Ескерту: Нақты санды string сан ретінде көрсеткен жағдайда, жылжымалы нүктесі . немесе , compare_one(1, 2.5) â -> 2.5 compare_one(1, \"2,3\") â -> \"2,3\" compare_one(\"5,1\", \"6\") â -> \"6\" compare_one(\"1\", 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Берілген n санды дәл 4 оң жұп санның қосындысы ретінде жазуға болатынын бағалау Мысал: is_equal_to_sum_even ((4) == Жалған is_equal_to_sum_even ((6) == Жалған is_equal_to_sum_even ((8) == Дұрыс \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"Бразилиялық факториал келесідей анықталады: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! мұндағы n > 0 Мысалы: >>> special_factorial(4) 288 Функция кіріс ретінде бүтін сан алады және осы бүтін санның арнайы факториалын қайтарады. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_Мысал-3н алынған мәтіннің барлық бос орындарын сызғыштармен алмастырыңыз, ал егер тізбекте 2 -ден астам бірізді бос орындар болса, онда барлық бірізді бос орындарды - fix_spaces ((\"Мысал\") == \"Мысал\" fix_spaces (((\"Мысал1\") == \"Мысал_1\" fix_spaces (((\"Мысал2\") == \"_Мысал_2\" fix_spaces (((\"Мысал 3\") == \"_Мысал-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Файл атауының атауында үш цифрдан ('0'-'9') артық болмауы керек. - Файл атауында дәл бір нүкте '.' болуы керек. - нүкте алдындағы ішкі жол бос болмауы керек, және ол латын алфавиті әріптерінен басталуы керек ('a'-'z' және 'A'Z'). - нүктеден кейінгі ішкі жол мыналардың бірі болуы керек: ['txt', 'exe', 'lld'] Мысал: file_name_check\"(example.txt\") # => 'Yes' file_name_check\"(example.dll1\") => 'No' # (атауы латын алфавиті әріптерінен басталуы керек)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" Бұл функция бүтін сандар тізімін алады. Тізімдегі барлық жазулар үшін, егер индексі 3 еселі болса, функция бүтін санды квадратына көтереді және индексі 3 еселі болмаса, 4 еселі болса, бүтін санды квадратына көтереді. Функция индексі 3 немесе 4 еселі емес тізімдегі жазуларды өзгертпейді. Функция барлық жазулардың қосындысын қайтарады. Мысалдар: lst = [1,2,3] үшін шығыс 6 болуы керек lst = [] үшін шығыс 0 болуы керек lst = [-1,-5,2,-1,-5] үшін шығыс -126 болуы керек \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Сізге сөйлемді білдіретін тізбе берілген, сөйлемде бос орынмен бөлінген бірнеше сөз бар, және сіз ұзындығы пропорционалды сандар болатын бастапқы сөйлемдегі сөздерді қамтитын тізбе қайтаруыңыз керек, жаңа тізбедегі сөздердің реті бастапқымен бірдей болуы керек. Мысал1: Кірісі: сөйлем = \"Бұл тест\" Шығысы: \"is\" Мысал2: Кірісі: сөйлем = \"let go for swimming\" Шығысы: \"go for\" Шектеулер: * 1 <= len(sentence) <= 100 * сөйлем тек әріптерді қамтиды \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"Сіздің міндетіңіз x * n өрнегін оңайлату функциясы. Егер x * n бүтін санға бағаланса, функциясы True қайтарады, ал басқа жағдайда False. x және n екеуі де сынықтардың тізбекті бейнелеуі болып табылады және келесі пішімге ие, <numerator>/<denominator> , мұнда сан мен атаушы оң бүтін сандар. x және n жарамды сынықтар деп болжауға болады және олардың атаушысында нөл жоқ. оңайлату: (((\"1/5\", \"5/1\") = True (салыстыру: \"1/6\", \"2/1\") = False (салыстыру: \"7/10\", \"10/2\") = False \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"Бөлшек сандар тізімін цифрларының қосындысына қарай жоғарылау тәртібімен сұрыптайтын функция жазыңыз. Ескерту: егер цифрларының қосындысы ұқсас бірнеше элементтер болса, оларды бастапқы тізімдегі индексіне сәйкес реттеп алыңыз. Мысалы: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"Сандар массивін кіріс ретінде алып, массивтегі элементтердің саны 10-нан үлкен және санның бірінші және соңғы цифрлары тақ (1, 3, 5, 7, 9) сандар болып табылатын функцияны жазыңыз. Мысалы: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"Сізге оң бүтін сан n беріледі. Сіз ұзындығы n бүтін сандар массивін құруыңыз керек. Әр i (1 ‰¤ i ‰¤ n) үшін a[i] = i * i - i + 1 мәнін қайтарамыз. a-ның үш еселік саны (a[i], a[j], a[k]) қайтарыңыз, мұнда i < j < k, ал a[i] + a[j] + a[k] - 3-тің көбейтіндісі. Мысал: Кіріс: n = 5 Шығыс: 1 Түсіндірме: a = [1, 3, 7, 13, 21] Жалғыз жарамды үш еселік (1, 7, 13).\"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''Күн жүйесінде сегіз планета бар: Күнге ең жақын Меркурий, келесісі Венера, одан кейін Жер, Марс, Юпитер, Сатурн, Уран, Нептун. Функция планета1 және планета2 саптары ретінде екі планета атын алатын функцияны жазыңыз. Функция планета1 және планета2 орбиталары арасындағы орбиталары бар барлық планеталарды қамтитын, күнге жақындық бойынша сұрыпталған тупельді қайтарады. Егер планета1 немесе планета2 планеталардың дұрыс аттары болмаса, функция бос тупельді қайтарады. Мысалдар bf \"(Юпитер\", \"Нептун\") ==> (\"Сатурн\", \"Уран\") bf (((\"Жер\", \"Меркурий\") ==> (\"Венера\") bf (\"Меркурий\", \"Уран\") ==> (\"Венера\", \"Жер\", \"Марс\", \"Юпитер\", \"Сан\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Параметр ретінде тізбектер тізімін қабылдайтын, одан тақ ұзындығы бар тізбектерді өшіріп, нәтижелі тізімді сұрыпталған тәртіппен қайтаратын функция жазыңыз. Тізім әрқашан тізбектер тізімі, ешқашан сандар массиві емес, және онда қайталанғандар болуы мүмкін. Тізімнің тәртібі әр сөздің ұзындығы бойынша көтерілуі керек, және сіз осы ереже бойынша сұрыпталған тізімді қайтаруыңыз керек. Егер екі сөздің ұзындығы бірдей болса, тізімді әліппелік тәртіппен сұрыптаңыз. Функция сұрыпталған тәртіппен тізбектер тізімін қайтаруы керек. Сіз барлық сөздер бірдей ұзындықтықты ие болады деп болжауыңыз мүмкін. Мысалы: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"aaaa\", \"cd\" => \"ab\", \"cd ])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Егер n - алғашқы сан болса, x мәнін қайтаратын, ал басқа жағдайда y мәнін қайтаратын қарапайым бағдарлама. Мысалдар: x_or_y(7, 34, 12) == 34 x_or_y(15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''Сандар тізімінен алынған сандардың квадраттарының қосындысын қайтарамыз. Теріс сандарды немесе бүтін сандар емес сандарды елемеңіз. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference ((([0]) == 0 Егер кіріс тізімі бос болса, 0 қайтарамыз. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"Менің ойымша, біз бәріміз бұл сезімді есімізде сақтаймыз, өйткені ұзақ күткен оқиғаның нәтижесі белгілі болады. Сол сәттегі сезімдер мен ойлар, әрине, есте сақталып, салыстыруға тұрарлық. Сіздің міндетіңіз - адамның бірнеше матчтың нәтижелерін дұрыс болжағанын анықтау. Сізге екі ұзындықтағы ұпайлар мен болжаулар массиві беріледі, онда әр индекс сәйкестікті көрсетеді. Әр болжаудың қаншалықты алыс екенін білдіретін бірдей ұзындықтағы массивті қайтарамыз. Егер олар дұрыс болжаған болса, мән 0 болады, ал егер болмаса, мән болжау мен ұпай арасындағы абсолюттік айырмашылық. мысал: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,4]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Сізге кластың атауы (жол) және кеңейтулер тізімі беріледі. Кеңейтулер класқа қосымша кластарды жүктеу үшін пайдаланылады. Кеңейтудің беріктігі былай болады: CAP кеңейту атауындағы үлкен әріптердің саны болсын, ал SM кеңейту атауындағы кіші әріптердің саны болсын, беріктігі CAP - SM бөлшегі арқылы беріледі. Сіз ең берік кеңейтуді тауып, мына пішімде бір жолды қайтаруыңыз керек: ClassName.StrongestExtensionName. Егер бірдей беріктігі бар екі немесе одан да көп кеңейтулер болса, тізімде бірінші келетінін таңдауыңыз керек. Мысалы, егер сізге \"Slices\" класы мен кеңейтулер тізімі ретінде берілген болса: ['SEvirNGliSCes', 'Cheese', 'StuFfed'] онда сіз 'Slices.SvirNGliS'Ces' 'SvirNGliS'Ces'mySvirNGliS'Ces']) беріктігі берік болғандықтан 'Slices.SvirNGliS'Ces' қайтаруыңыз керек (мысалы: 'AA_Beats' StrongestExtension', өйткені 'AA_Class' - 'Class' Strongest', (<strong>'_{Class}') - (<strong>{{Class_class_AA_}}) ', мысалтауымындай: Strongest_class_class}}\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Сізге 2 сөз беріледі. Егер екінші сөз немесе оның кез келген айналуы бірінші сөздің кіші жиегі болса, Сіз True қайтаруыңыз керек cycpattern_check(\"abcd\",\"abd\") => False cycpattern_check(\"hello\",\"ell\") => True cycpattern_check(\"whassup\",\"psus\") => False cycpattern_check\"abab\",\"baa\") => True cycpattern_check\"(\"efef\",\"eeff\") => False cycpattern_check\"(hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"Берілген бүтін сан. тиісінше жұп және тақ сандар саны бар тупельді қайтарады. Мысал: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"Оң бүтін санды келтірсек, оның римдік сандардағы баламасын тізбек түрінде алып, кіші әріппен қайтарамыз.\"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''Үшбұрыштың үш бүйірінің ұзындығы берілген. Егер үш бүйір тік бұрышты үшбұрышты құраса, дұрыс қайтарылады, әйтпесе жалған. Тік бұрышты үшбұрыш - бұл үшбұрыштың бір бұрышы тік бұрышты немесе 90 градусты құрайды. Мысал: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"Тақырыптар тізіміне кіретін функция жазу. Тізімде әртүрлі сөздер бар. Бірегей таңбалардың ең көп саны бар сөзді қайтарамыз. Егер бірнеше тақырыптар бірегей таңбалардың ең көп саны болса, лексикографиялық ретімен бірінші келетінін қайтарамыз. find_max ((([\"аты\", \"of\", \"string\"]) == \"string\" find_max (([\"аты\", \"enam\", \"ойын\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Сіз ашыққан қоянсыз, сіз белгілі бір мөлшерде сәбіз жедіңіз, бірақ енді күніне тамақ жеу үшін көбірек сәбіз жеуіңіз керек. Сіз [естен кейін желген сәбіздің жалпы саны, тамақтан кейін қалған сәбіз саны] массивін қайтаруыңыз керек, егер жеткілікті сәбіз болмаса, қалған сәбіздің бәрін жейсіз, бірақ әлі де аш боласыз. Мысал: * жеңіз ((5, 6, 10) -> [11, 4] * жеңіз ((4, 8, 9) -> [12, 1] * жеңіз ((1, 10, 10) -> [11, 0] * жеңіз ((2, 11, 5) -> [7, 0] Айнымалылар: @number: сіз жеген сәбіздің санын бүтін санға келтіру. @need:: сіз жеуіңіз керек сәбіздің санын бүтін санға келтіру. @remaining: қалған сәбіздің санын бүтін санға келтіру.\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"Екі тізім операторы мен операнда. Бірінші тізімде алгебралық негізгі операциялар бар, ал екінші тізім - бүтін сандар тізімі. Алгебралық өрнекті құру үшін берілген екі тізімді пайдаланыңыз және осы өрнектің бағасын қайтарыңыз. Негізгі алгебралық операциялар: Қосу (+) Алу (-)) Көбейту (*) Қабатты бөлу (//) Экспоненциалау (**) Мысал: оператор['+', '*', '-'] массив = [2, 3, 4, 5] нәтиже = 2 + 3 * 4 - 5 => нәтиже = 9 Ескерту: Оператор тізімінің ұзындығы оператор тізімінің ұзындығына тең. Оператор - теріс емес бүтін сандар тізімі. Оператордың тізіміне кем дегенде бір оператор, ал оператордың тізіміне кем дегенде екі операндар бар. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"Сізге s. s[i] - әріп болса, оның үлкенін төменгіден жоғарғыға немесе керісінше, әйтпесе оны сол күйінде қалдырыңыз. Егер тізбекте әріптер болмаса, тізбекті кері бұрыңыз. Функция алынған тізбекті қайтарады. Мысалдар solve ((\"1234\") = \"4321\" solve ((\"ab\") = \"AB\" solve ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"'text' string берілген болса, оның md5 хэш эквивалентті string қайтарамыз. Егер 'text' бос болса, None қайтарамыз. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "kaz_Cyrl",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"Екі оң бүтін сан a және b берілген жағдайда, a және b арасындағы жұп сандарды жоғарылайтын тәртіппен қайтарамыз. Мысалы: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]