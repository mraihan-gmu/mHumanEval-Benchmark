task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,slk_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Skontrolujte, či sú v danom zozname čísel nejaké dve čísla bližšie k sebe ako daný prah. Príklad: >>> má_blízke_prvky (([1.0, 2.0, 3.0], 0.5) Falošné >>> má_blízke_prvky (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) Pravdivé """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,slk_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Vstupom tejto funkcie je reťazec obsahujúci viacero skupín vnorených zátvorok. Vaším cieľom je oddeliť tieto skupiny do samostatných reťazcov a vrátiť zoznam týchto. Oddelené skupiny sú vyvážené (každá otvorená zátvorka je správne uzavretá) a nie vnorené navzájom Ignorujte všetky medzery v vstupnom reťazci. Príklad: >>> separate_paren_groups' ((( ) (() ((( ) ) "") ['() ', '(()) ', '(() ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,slk_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Pri pozitívnom čísle s pohyblivou čiarou sa môže rozložiť na celkové číslo (najväčšie celé číslo menšie ako dané číslo) a desatinné čísla (zvyšná časť vždy menšia ako 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,slk_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Máte zoznam vkladov a výberov na bankovom účte, ktorý začína nulovým zostatkom. Vašou úlohou je zistiť, či v ktoromkoľvek bode zostane zostatok účtu pod nulou, a v tomto bode by mala funkcia vrátiť True. V opačnom prípade by mala vrátiť False.""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,slk_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Pre daný zoznam vstupných čísel vypočítajte priemernú absolútnu odchýlku okolo priemeru tohto súboru údajov.""""""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,slk_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Vložte číslo ""delimiter"" medzi každé dva po sebe nasledujúce prvky vstupného zoznamu `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,slk_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Vstupom do tejto funkcie je reťazec reprezentovaný viacerými skupinami pre vnútorné zátvorky oddelené medzerami. Pre každú skupinu vyberte najhlbšiu úroveň vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútorného vnútvrtého vnútvého vnútvého vnútvého vnútvého vnútvéhovnútvnút""""""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,slk_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtrovať vstupný zoznam reťazcov iba pre tie, ktoré obsahujú daný podreťazca >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,slk_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Vráti tuple, ktorý pozostáva zo súčtu a násobku všetkých čísel v zozname. Prázdny súčet by mal byť rovný 0 a prázdny produkt by mal byť rovný 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,slk_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Z daného zoznamu čísel vygenerovať zoznam prvkov s maximálnou hodnotou, ktoré sa našli do daného momentu v sekvencii. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,slk_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Nájdite najkratší palindróm, ktorý začína poskytnutým reťazcom. Myšlienka algoritmu je jednoduchá: - Nájdite najdlhší postfix poskytnutého reťazca, ktorý je palindróm. - Pridajte na koniec reťazca opačný prefix reťazca, ktorý prichádza pred palindrómovou sufiksou. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Test , či je daný reťazec palindróm .""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,slk_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Vstupné sú dva reťazce a a b, ktoré pozostávajú len z 1 a 0. Vykonajte binárne XOR na týchto vstupoch a vráťte výsledok tiež ako reťazec.""""""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,slk_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Zo zoznamu reťazcov vráti najdlhšiu. Vráti prvú, ak existuje viac reťazcov rovnakej dĺžky. Vráti Nula, ak je vstupný zoznam prázdny. >>> najdlhšia([]) >>> najdlhšia(['a', 'b', 'c']) 'a' >>> najdlhšia(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,slk_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Vráti najväčší spoločný deliteľ dvoch celých čísel a a b >>> najväčší_spoločný_deliteľ ({3, 5) 1 >>> najväčší_spoločný_deliteľ ({25, 15) 5) """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,slk_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Zoznam všetkých predponíkov od najkratšej po najdlhšiu z vstupného reťazca >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,slk_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Vráti reťazec obsahujúci číselné znaky s vymedzeným priestorom od 0 do n vrátane. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,slk_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Pri danom reťazci zistite, koľko odlišných znakov (bez ohľadu na veľkosť) sa skladá z >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,slk_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Vstup do tejto funkcie je reťazec reprezentujúci hudobné noty v špeciálnom formáte ASCII. Vašou úlohou je analyzovať reťazecový zoznam celých čísel zodpovedajúcich mnohým úderom. Tu je legenda: 'o' note, lasts beats 'o' , 'abo' - polovica noty, lasts two beats 'abo' - quater note, lasts one beat >>> parse_music. 'o' o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,slk_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Zistite, koľkokrát sa daný podstránok nachádza v pôvodnom strune. Spočítajte prekrývajúce sa prípady. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,slk_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Vstup je priestorovo vymedzený reťazec číslic od ""nula"" do ""deväť"". Platné voľby sú ""nula"", ""jedna"", ""dve"", ""tri"", ""štyri"", ""päť"", ""šesť"", ""sedem"", ""osem"" a ""deväť"". Vráti reťazec s číslami zoradenými od najmenšieho po najväčší >>> sort_numbers (('tri jeden päť') 'jeden tri päť' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,slk_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Z poskytnutého zoznamu čísel (dĺžky najmenej dvoch) vyberte a vráťte dve, ktoré sú navzájom najbližšie, a vráťte ich v poradí (menšie číslo, väčšie číslo). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,slk_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Pri danom zozname čísel (aspoň dvoch prvkov) aplikovať lineárnu transformáciu na tento zoznam, tak, že najmenšie číslo sa stane 0, a najväčšie sa stane 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,slk_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter daný zoznam všetkých hodnôt pythonu iba pre celé čísla >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,slk_Latn,python,"

def strlen(string: str) -> int:
    """"""Vrátenie dĺžky daného reťazca >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,slk_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Pre daný počet n, nájdite najväčšie číslo, ktoré delí n rovnomerne, menšie ako n >>> najväčší_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,slk_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Vráti zoznam prvočísel daného celého čísla v poradí od najmenšieho po najväčší. Každý z faktorov by mal byť uvedený počet krát zodpovedajúci tomu, koľkokrát sa objaví v rozčlenení na faktory. Vstupné číslo by malo byť rovné súčinu všetkých faktorov >>> rozčleniť(8) [2, 2, 2] >>> rozčleniť(25) [5, 5] >>> rozčleniť(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,slk_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Z zoznamu čísel vymažte všetky prvky, ktoré sa vyskytujú viac ako raz. Udržujte poradie prvkov rovnaký ako v vstupnom. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,slk_Latn,python,"

def flip_case(string: str) -> str:
    """"""Pre daný reťazec obráťte malé písmená na veľké a veľké na malé. >>> flip_case (('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,slk_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Zlučovať zoznam reťazcov do jedného reťazca >>> zlučovať (([]) '' >>> zlučovať ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,slk_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtrovať vstupný zoznam reťazcov iba pre tie, ktoré začínajú danou prefixom. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,slk_Latn,python,"

def get_positive(l: list):
    """"""Vráti iba kladné čísla zo zoznamu. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,slk_Latn,python,"

def is_prime(n):
    """"""Vráti hodnotu true, ak je dané číslo prvočíslo, a false inak. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,slk_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs sú koeficienty polynómu. find_zero find x tak, že poly(x) = 0. find_zero vráti len len nulový bod, aj keď je ich veľa. Okrem toho, find_zero berie len zoznam xs s párnym počtom koeficientov a najväčším ne-nulovým koeficientom, pretože zaručuje riešenie. >>> round ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Vyhodnocuje polynóm s koeficientmi xs v bode x. vráti xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,slk_Latn,python,"

def sort_third(l: list):
    """"""Táto funkcia berie zoznam l a vráti zoznam l' tak, že l' je totožné s l v indexoch, ktoré nie sú deliteľné tromi, zatiaľ čo jeho hodnoty v indexoch, ktoré sú deliteľné tromi, sú rovnaké ako hodnoty zodpovedajúcich indexov l, ale zoradené. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,slk_Latn,python,"

def unique(l: list):
    """"""Vráti zoradené jedinečné prvky v zozname >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,slk_Latn,python,"

def max_element(l: list):
    """"""Vráti maximálny prvok zo zoznamu. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,slk_Latn,python,"

def fizz_buzz(n: int):
    """"""Vráti počet krát, kedy sa číslica 7 objaví v celých číslach menších ako n, ktoré sú deliteľné 11 alebo 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,slk_Latn,python,"

def sort_even(l: list):
    """"""Táto funkcia berie zoznam l a vráti zoznam l' tak, že l' je identický s l v nepárnych indexoch, zatiaľ čo jeho hodnoty v párnych indexoch sú rovnaké ako hodnoty párnych indexoch l, ale zoradené. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,slk_Latn,python,"

def encode_cyclic(s: str):
    """"""berie ako vstupnú reťaz zakódovanú funkciou encode_cyclic. Vráti dekódovanú reťaz. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""vráti kódovaný reťazec cyklickými skupinami troch znakov. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,slk_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib vráti n-té číslo, ktoré je Fibonacciho číslo a je tiež prvočíslo. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,slk_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero berie ako vstup zoznam celých čísel. Vráti True, ak sú v zozname tri odlišné prvky, ktoré sú súčty k nule, a False inak. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,slk_Latn,python,"

def car_race_collision(n: int):
    """"""Predstavte si cestu, ktorá je úplne rovná nekonečne dlhá línia. n áut jazdí zľava doprava; súčasne, iná skupina n áut jazdí zľava doprava. Dve skupiny áut začínajú byť veľmi ďaleko od seba. Všetky autá sa pohybujú rovnakou rýchlosťou. Dva autá sa zrážajú, keď sa auto, ktoré sa pohybuje zľava doprava, zrazuje auto, ktoré sa pohybuje zľava doprava. Avšak autá sú nekonečne pevné a silné; v dôsledku toho sa naďalej pohybujú vo svojej trajektórii, ako keby sa nezrážali. Táto funkcia vypustí počet takýchto kolízií. """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,slk_Latn,python,"

def incr_list(l: list):
    """"""Vráti zoznam s prvkami zvýšenými o 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,slk_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero berie ako vstup zoznam celých čísel. Vráti True, ak sú v zozname dva odlišné prvky, ktoré sú súčty k nule, a False inak. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,slk_Latn,python,"

def change_base(x: int, base: int):
    """"""Zmeniť číselnú základňu vstupného čísla x na základňu. Po konverzii vráti reprezentáciu reťazca. Počty základní sú menšie ako 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,slk_Latn,python,"

def triangle_area(a, h):
    """"""Pri určovaní dĺžky strany a veľkosti povrchu návratu trojuholníka. >>> triangle_area(5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,slk_Latn,python,"

def fib4(n: int):
    """"""Fib4 je sekvencia podobná Fibbonacciho sekvencii, ktorá je definovaná takto: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Napíšte funkciu, ktorá efektívne vypočíta n-ty prvok fib4 sekvencie čísel. Nepoužívajte rekurziu. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,slk_Latn,python,"

def median(l: list):
    """"""Medián vrátenia prvkov v zozname l. >>> medián (([3, 1, 2, 4, 5]) 3 >>> medián (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,slk_Latn,python,"

def is_palindrome(text: str):
    """"""Skontroluje, či je daný reťazec palindróm >>> is_palindróm (('') Pravda >>> is_palindróm (('aba') Pravda >>> is_palindróm (('aaaaa') Pravda >>> is_palindróm (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,slk_Latn,python,"

def modp(n: int, p: int):
    """"""Vráti 2^n modulo p (pozor na číselné znaky). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,slk_Latn,python,"

def encode_shift(s: str):
    """"""berie ako vstupný reťazec zakódovaný funkciou encode_shift. Vráti dekódovaný reťazec. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""vráti kódovaný reťazec posunom každého znaku v abecede o 5.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,slk_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels je funkcia, ktorá berie reťazec a vráti reťazec bez samohlásk. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,slk_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Vráti hodnotu True, ak sú všetky čísla v zozname l pod prahom t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,slk_Latn,python,"

def add(x: int, y: int):
    """"""Pridajte dve čísla x a y >>> pridajte ((2, 3) 5 >>> pridajte ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,slk_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Skontrolujte, či majú dve slová rovnaké znaky. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Pravda >>> same_chars (('abcd', 'dddddddabc') Pravda >>> same_chars (('dddddddabc', 'abcd') Pravda >>> same_chars (('eabcd', 'dddddddddabc') False >>> same_chars ((('abcd', 'dddddddabddce') False >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,slk_Latn,python,"

def fib(n: int):
    """"""Vráti n-té číslo Fibonacciho. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,slk_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets je reťazec ""<"" a "">"". return True, ak každá otváracia zátvorka má zodpovedajúcu uzatváraciu zátvorku. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,slk_Latn,python,"

def monotonic(l: list):
    """"""Vráti True, ak sú prvky zoznamu monotónne rastúce alebo klesajúce. >>> monotónne (([1, 2, 4, 20]) True >>> monotónne (([1, 20, 4, 10]) False >>> monotónne (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,slk_Latn,python,"

def common(l1: list, l2: list):
    """"""Vráti zoradené jedinečné spoločné prvky pre dva zoznamy. >>> common (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> common (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,slk_Latn,python,"

def largest_prime_factor(n: int):
    """"""Vráti najväčší prvočíselný deliteľ n. Predpokladajme, že n > 1 a nie je prvočíselné. >>> najväčší_prvný_deliteľ{13195) 29 >>> najväčší_prvný_deliteľ{2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,slk_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n je funkcia, ktorá sumuje čísla od 1 do n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,slk_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets je reťazec ""("" a "")"". return True, ak každá otváracia zátvorka má zodpovedajúcu uzatváraciu zátvorku. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,slk_Latn,python,"

def derivative(xs: list):
    """"""xs predstavujú koeficienty polynómu. xs[0] + xs[1] * x + xs[2] * x^2 + .... Vráti deriváciu tohto polynómu v rovnakom tvare. >>> derivácia (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivácia (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,slk_Latn,python,"

def fibfib(n: int):
    """"""FibFib je sekvencia podobná Fibbonacciho sekvencii, ktorá je definovaná takto: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Napíšte funkciu, ktorá efektívne vypočíta n-ty prvok sekvencie čísel fibfib. >>> fibfib(1) 0 >>> fib fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,slk_Latn,python,"
FIX = """"""Napíšte funkciu vowels_count, ktorá vezme reťazec reprezentujúci slovo ako vstup a vráti počet samohlások v reťazi. Samohlásky v tomto prípade sú 'a', 'e', 'i', 'o', 'u'. Tu je 'y' tiež samohláska, ale len vtedy, keď je na konci daného slova. Príklad: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Pridajte viac testovacích prípadov. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,slk_Latn,python,"
def circular_shift(x, shift):
    """"""Okolný posun číslic celkovej čísla x, posun číslic doprava posunom a vráti výsledok ako reťazec. Ak je posun > počet číslic, vráti sa obrátené číslice. >>> cirkulárny_posun{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\displaystyle cirkul_shift}{\shift}}{\shift}}{\shift}}{\shift}}{\shift}}{\shift}}{12}}{\shift}}{12}}{\shift}}{12}}{\shift}}{\shift}}{\shift}}{12}}}""""""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,slk_Latn,python,"
def digitSum(s):
    """"""Úloha Napísať funkciu, ktorá berie reťazec ako vstup a vráti súčet len horných znakov ASCII kódov. Príklady: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,slk_Latn,python,"
def fruit_distribution(s,n):
    """"""V tejto úlohe dostanete reťazec, ktorý predstavuje počet jabĺk a pomarančov, ktoré sú rozdelené v koši s ovocím tento košík obsahuje jablká, pomaranče a ovocie manga. Vzhľadom na reťazec, ktorý predstavuje celkový počet pomarančov a jablká a celé číslo, ktoré predstavuje celkový počet ovocia v koši vráťte počet ovocia manga v koši. napríklad: fruit_distribution""5(jablká a 6 pomarančov"", 19) -> 19 - 5 - 6 = 8 ovocia_distribution""0 jablká a 1 pomaranč"",3) -> 3 - 0 - 1 = 2 ovocia_distribution""2 jablká a 3 pomaranče"", 100) -> 100 - 2 - 3 = 95 ovocia_distribution""100 jablká a 1 pomaranč"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,slk_Latn,python,"
def pluck(arr):
    """"""""Ak je v riadku, ktorý predstavuje vetvu stromu, ktoré má ne-negatívne celé uzly, vaša úloha je vyberte jeden z uzlov a vráťte ho. Vyberaný uzol by mal byť uzlom s najmenšou párnou hodnotou. Ak sa nájde viac uzlov s rovnakou najmenšou párnou hodnotou, vráťte uzol, ktorý má najmenší index. Vyberaný uzol by sa mal vrátiť v zozname, [smallest_value, jeho index]. Ak nie sú žiadne párne hodnoty alebo je daný rad prázdny, vráťte []. Príklad 1: Vstup: [4,2,3] Výstup: [2, 1] Vysvetlenie: 2 má najmenšiu párnu hodnotu a 2 má najmenší index. Príklad 2: Vstup: [1,2,3] Výstup: [2, 1] Vysvetlenie: 2 má najmenšiu párnu hodnotu a 2 má najmenší párny index. Príklad 3: Vstup: [] Výstup: [4:] Vstup: [5, 3, 4] Výstup: [0, 1] Výstup: 1 má najmenšiu párnu hodnotu, ale index je nulový. Príklad: * vybereme prvý uzol, ktorý má najmenšiu hodnotu, ale sú tam dve nulové hodnoty.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,slk_Latn,python,"
def search(lst):
    '''Vráti najväčšie celé číslo, ktoré je väčšie ako nula a má frekvenciu väčšú alebo rovnú hodnote samotného čísla. Frekvencia celého čísla je počet krát, ako sa objaví v zozname. Ak takáto hodnota neexistuje, vráti sa -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,slk_Latn,python,"
def strange_sort_list(lst):
    '''Pri zadávaní zoznamu celých čísel sa zoznam vráti v podivnom poradí. Podivné triedenie je, keď začnete s minimálnou hodnotou, potom maximálnou z zostávajúcich celých čísel, potom minimálnou a tak ďalej. Príklady: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,slk_Latn,python,"
def triangle_area(a, b, c):
    '''Vráti plochu trojuholníka zaokrúhlenú na 2 desatinné body, ak tri strany tvoria platný trojuholník. V opačnom prípade vráti -1 Tri strany tvoria platný trojuholník, ak súčet akýchkoľvek dvoch strán je väčší ako tretia strana. Príklad: triangle_area ({3, 4, 5) == 6.00 triangle_area ({1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,slk_Latn,python,"
def will_it_fly(q,w):
    '''Napíšte funkciu, ktorá vráti True, ak objekt q bude lietať, a False inak. Objekt q bude lietať, ak je vyvážený (je to palindrómny zoznam) a súčet jeho prvkov je menší alebo rovný maximálnej možnej hmotnosti w. Príklad: will_it_fly (([1, 2], 5) â -> False # 1+2 je menšia ako maximálna možná hmotnosť, ale je nevyvážená. will_it_fly (([3, 2, 3], 1) â -> False # je vyvážený, ale 3+2+3 je viac ako maximálna možná hmotnosť. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 je menšia ako maximálna možná hmotnosť a je vyvážená. will_it_fly ((([3], â 5) -> True # 3 je menšia ako maximálna možná hmotnosť a je vyvážená. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,slk_Latn,python,"
def smallest_change(arr):
    """"""Pri úprave sa môže zmeniť jeden prvok na akýkoľvek iný. Napríklad: smallest_change ([1,2,3,5,4,7,9,6]) == 4 smallest_change ([1,2,3,4,3,2,2]) == 1 smallest_change ([1,2,3,3,2,1,2,1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,slk_Latn,python,"
def total_match(lst1, lst2):
    '''Napíšte funkciu, ktorá prijíma dva zoznamy reťazcov a vráti zoznam, ktorý má celkový počet znakov vo všetkých reťazcoch zoznamu menší ako v druhom zozname. ak majú oba zoznamy rovnaký počet znakov, vráťte prvý zoznam. Príklady total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi]) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'', '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,slk_Latn,python,"
def is_multiply_prime(a):
    """"""Napíšte funkciu, ktorá vráti hodnotu true, ak je dané číslo násobením 3 prvočísel a false inak.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,slk_Latn,python,"
def is_simple_power(x, n):
    """"""Vaša úloha je napísať funkciu, ktorá vráti hodnotu true, ak je číslo x jednoduchá mocnosť n a false v ostatných prípadoch. x je jednoduchá mocnosť n, ak n**int=x Napríklad: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,slk_Latn,python,"
def iscube(a):
    '''Napíšte funkciu, ktorá vezme celé číslo a vráti hodnotu True, ak je toto číslo kubickým číslom nejakého celého čísla. Poznámka: môžete predpokladať, že vstup je vždy platný. Príklady: iscube (a) ==> True (b) ==> False (c) ==> True (d) ==> True (e) ==> True (f) ==> True (g) ==> True (g) ==> True (g) ==> True (g) ==> False (d) ==> False (g) ==> False (d) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) ==> False (g) === false'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,slk_Latn,python,"
def hex_key(num):
    """"""Máte napísať funkciu, ktorá prijíma hexadecimálne čísla ako reťazec a počíta počet hexadecimálnych číslic, ktoré sú prvočíslami (prímové číslo je prirodzené číslo väčšie ako 1, ktoré nie je výsledkom dvoch menších prirodzených čísel). Hexadecimálne číslice sú 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prímové čísla sú 2, 3, 5, 7, 11, 13, 17,... Takže musíte určiť počet z nasledujúcich číslic: 2, 3, 5, 7, B (= desatinné číslo 11), D (= desatinné číslo 13). Poznámka: môžete predpokladať, že vstup je vždy správny alebo prázdny reťazec a symboly A,B,C,D,E,F sú vždy veľkými písmenami. Príklady: pre num ""AB"" výstup by mal byť num = 1. pre num ""1077E"" výstup by mal byť 2. pre num ""AB"" by mal byť num = 1.331EDA ""byť num = 4. ""BC"" by mal byť num = 6.067D12345 A ""EF"" by mal byť num = 2.02020""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,slk_Latn,python,"
def decimal_to_binary(decimal):
    """"""Funkcia by mala vrátiť reťazec, pričom každý znak bude reprezentovať binárne číslo. Každý znak v reťazi bude ""0"" alebo ""1"". Na začiatku a na konci reťaze bude extra pár znakov ""db"". Tieto extra znaky sú tu na pomoc s formátom. Príklad: decimal_to_binary(15) # vráti ""db1111db"" decimal_to_binary32) # vráti ""db100000db"" """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,slk_Latn,python,"
def is_happy(s):
    """"""Máte reťazec s. Vašou úlohou je skontrolovať, či je reťazec šťastný alebo nie. Reťazec je šťastný, ak jeho dĺžka je aspoň 3 a každé 3 po sebe idúce písmená sú odlišné. Napríklad: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,slk_Latn,python,"
def numerical_letter_grade(grades):
    """"""Je to posledný týždeň semestra a učiteľka musí dať študentom známky. Učiteľka si vytvorila vlastný algoritmus hodnotenia. Jediný problém je, že stratila kód, ktorý používala na hodnotenie. Dala vám zoznam GPA pre niektorých študentov a vy musíte napísať funkciu, ktorá môže vydať zoznam písmenových známok pomocou nasledujúcej tabuľky: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,slk_Latn,python,"
def prime_length(string):
    """"""Napíšte funkciu, ktorá vezme reťazec a vráti True, ak je dĺžka reťaze prvočíslo alebo False inak Príklady prime_length{""Hello"") == True prime_length{""abcdcba"") == True prime_length{""kittens"") == True prime_length{""orange"") == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,slk_Latn,python,"
def starts_one_ends(n):
    """"""Vráti počet n-miestnych kladných čísel, ktoré začínajú alebo končia číslom 1.""""""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,slk_Latn,python,"
def solve(N):
    """"""Pri pozitívnom čísle N, vráti sa celkový súčet jeho číslic v binárnom kóde. Príklad Pre N = 1000, súčet číslic bude 1, výstup by mal byť ""1"". Pre N = 150, súčet číslic bude 6, výstup by mal byť ""110"". Pre N = 147, súčet číslic bude 12, výstup by mal byť ""1100"". Premenný: @N celé číslo Obmedzenia: 0 â‰¤ N â‰¤ 10000. Výstup: reťazec binárnych čísel """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,slk_Latn,python,"
def add(lst):
    """"""Dátom neprázdnym zozname celých čísel pridajte párne prvky, ktoré sú v nepárnych indexoch.""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,slk_Latn,python,"
def anti_shuffle(s):
    """"""Napíšte funkciu, ktorá vezme reťazec a vráti jeho usporiadanú verziu. Usporiadaná verzia reťaze je reťazec, kde sú všetky slová (oddelené medzníkom) nahradené novým slovom, kde sú všetky znaky usporiadané v vzostupnom poradí na základe hodnoty ascii. Poznámka: Mali by ste zachovať poradie slov a prázdnych medzín v vete. Napríklad: anti_shuffle ((('Hi') vracia ""Hi"" anti_shuffle (('hello') vracia ""ehllo"" anti_shuffle (('Hello World!!!') vracia ""Hello !!!Wdlor"" """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,slk_Latn,python,"
def get_row(lst, x):
    """"""Máte 2 dimenzionálne údaje, ako vnústrovené zoznamy, ktoré sú podobné matici, avšak na rozdiel od matic môže každý riadok obsahovať iný počet stĺpcov. V prípade, že je lst a celé číslo x, nájdite celé čísla x v zozname a vráťte zoznam tuplov, [(x1, y1), (x2, y2) ...] tak, že každý tuple je súradnica - (riadok, stĺpci), začínajúca číslom 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,slk_Latn,python,"
def sort_array(array):
    """"""Ak je daný súbor ne-negatívnych celých čísel, po zoradení vráťte kópiu daného radu, zoradíte daný súbor v vzostupnom poradí, ak je suma (prvá indexová hodnota, posledná indexová hodnota) nepárna, alebo ho zoradíte v zostupnom poradí, ak je suma (prvá indexová hodnota, posledná indexová hodnota) párna. Poznámka: * nezmeňte daný súbor. Príklady: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,slk_Latn,python,"
def encrypt(s):
    """"""Vytvorte funkciu encrypt, ktorá vezme reťazec ako argument a vráti reťazec šifrovaný s otočenou abecedou. Abecedy by mali byť otočené takým spôsobom, aby sa písmená posunuli o dve násobené na dve miesta. Napríklad: encrypt('hi') vracia 'lm' encrypt('asdfghjkl') vracia 'ewhjklnop' encrypt('gf') vracia 'kj' encrypt('et') vracia 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,slk_Latn,python,"
def next_smallest(lst):
    """"""Máte zoznam celých čísel. Napíšte funkciu next_smallest{\displaystyle next_smallest{\displaystyle next_smallest{\displaystyle next_smallest{\displaystyle next_smallest{\displaystyle next_smallest{\text{{s}}}}) ktorá vráti druhý najmenší prvok zo zoznamu. Vráti hodnotu None, ak takýto prvok neexistuje. next_smallest{\displaystyle next_smallest{\text{[1, 2, 3, 4, 5]) == 2 next_smallest{\text{[5, 1, 4, 3, 2]) == 2 next_smallest{\text{[5, 1, 4, 3, 2]) == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==""""""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,slk_Latn,python,"
def is_bored(S):
    """"""Zodpovednosť je výrok, ktorý začína slovom ""I"". Vyrovnanie je ohraničené '.', '?' alebo '!'. Napríklad: >>> je_odporný (zdravo svet) 0 >>> je_odporný (nebo je modrá. Slnko svieti. Milujem toto počasie) 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,slk_Latn,python,"
def any_int(x, y, z):
    '''Vytvorte funkciu, ktorá prijíma 3 čísla. Vráti hodnotu true, ak je jedno číslo rovné súčtu ostatných dvoch a všetky čísla sú celé. Vráti hodnotu false v iných prípadoch. Príklady any_int{5, 2, 7} â -> True any_int{3, 2, 2} â -> False any_int{3, -2, 1) â -> True any_int{3.6, -2.2, 2) â -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,slk_Latn,python,"
def encode(message):
    """"""Napíšte funkciu, ktorá prijíma správu a kóduje takým spôsobom, že vymení prípad všetkých písmen, nahradí všetky samohlásky v správe písmenom, ktoré sa objavujú 2 miesta pred touto samohláskou v anglickej abecede. Predpokladajme len písmená. Príklad: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,slk_Latn,python,"

def skjkasdkd(lst):
    """"""Je to zoznam celých čísel. Musíte nájsť najväčšiu prvočíselnú hodnotu a vrátiť súčet jej číslic. Príklady: Pre lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] výstup by mal byť 10 Pre lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] výstup by mal byť 25 Pre lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] výstup by mal byť 13 Pre lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] výstup by mal byť 11 Pre lst = [0,81,12,31,21] výstup by mal byť 3 Pre lst = [0,8,1,2,1,7] výstup by mal byť """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,slk_Latn,python,"
def check_dict_case(dict):
    """"""Ak je daný slovník, vráti True, ak sú všetky kľúče riadkami v malých písmenách alebo všetky kľúče sú riadkami v veľkých písmenách, inak vráti False. Funkcia by mala vrátiť False, ak je daný slovník prázdny. Príklady: check_dict_case{""a"":""apple"", ""b"":""banana""}) by mala vrátiť True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) by mala vrátiť False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) by mala vrátiť False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) False by mala vrátiť check.dict_case{""NC"":""STATE"", ""Z"":""IP""}) by mala vrátiť True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,slk_Latn,python,"
def count_up_to(n):
    """"""Implementovať funkciu, ktorá berie ne-negatívne celé číslo a vráti pole prvých n čísel, ktoré sú prvočíslami a menšie ako n. napríklad: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,slk_Latn,python,"
def multiply(a, b):
    """"""Vyplňte funkciu, ktorá berie dve celé čísla a vráti násobok ich jednotkových číslic. Predpokladajme, že vstup je vždy platný. Príklady: násobenie 148, 412 by malo vrátiť 16, násobenie 19 28, 72 násobenie 2020, 1851 by malo vrátiť 0, násobenie 14-15 by malo vrátiť 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,slk_Latn,python,"
def count_upper(s):
    """"""Pri danom reťazci s, spočítajte počet veľkých samohlások v párnych indexoch. Napríklad: count_upper{\displaystyle \mathbb {a} } vráti 1 count_upper{\displaystyle \mathbb {a} } } vráti 0 count_upper{\displaystyle \mathbb {a} } } vráti 0 count_upper{\displaystyle \mathbb {a} } } vráti 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,slk_Latn,python,"
def closest_integer(value):
    '''Vytvorte funkciu, ktorá vezme hodnotu (string) reprezentujúcu číslo a vráti k nemu najbližšie celé číslo. Ak je číslo rovnomerne vzdialené od dvoch celých čísel, zaokrúhlite ho od nuly. Príklady >>> closest_integer{""10"") 10 >>> closest_integer{""15.3"") 15 Poznámka: Zaokrúhliť od nuly znamená, že ak je dané číslo rovnomerne vzdialené od dvoch celých čísel, vráti sa číslo, ktoré je najďalej od nuly. V prípade príkladu closest_integer{""14.5"") by malo vrátiť 15 a closest_integer{""14.5"") by malo vrátiť -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,slk_Latn,python,"
def make_a_pile(n):
    """"""Pri pozitívnom čísle n, musíte vytvoriť hromadu n úrovní kameňov. Prvá úroveň má n kameňov. Počet kameňov v ďalšej úrovni je: - ďalšie nepárne číslo, ak je n nepárne. - ďalšie párne číslo, ak je n párne. Vráti počet kameňov v každej úrovni v zozname, kde prvok v indexe i predstavuje počet kameňov v úrovni (i+1). Príklady: >>> make_a_pile (i+1) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,slk_Latn,python,"
def words_string(s):
    """"""Váš úkol je rozdeliť reťazec na slová a vrátiť súbor slov. Napríklad: words_string ""Dobrý deň, volám sa John"") == [""Dobrý deň"", ""môj"", ""meno"", ""je"", ""John""] words_string ""Jeden, dva, tri, štyri, päť, šesť"") == [""Jeden"", ""dva"", ""tri"", ""štyri"", ""päť"", ""šesť""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,slk_Latn,python,"
def choose_num(x, y):
    """"""Táto funkcia berie dve kladné čísla x a y a vráti najväčšie párne celé číslo, ktoré je v rozsahu [x, y] vrátane. Ak také číslo neexistuje, potom by funkcia mala vrátiť -1.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,slk_Latn,python,"
def rounded_avg(n, m):
    """"""Máte dve kladné celé čísla n a m a vašou úlohou je vypočítať priemer celých čísel od n do m (vrátane n a m). Zaokrúhlite odpoveď na najbližšie celé číslo a konvertovať ho na binárne. Ak je n väčšie ako m, vráťte -1.""""""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,slk_Latn,python,"
def unique_digits(x):
    """"""Vráti zoradený zoznam všetkých prvkov, ktoré nemajú ani jednu párnu číslicu. Poznámka: Vrátený zoznam by mal byť zoradený v narastajúcom poradí. Napríklad: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,slk_Latn,python,"
def by_length(arr):
    """"""V prípade, že je súbor celých čísel, zoradzujte celé čísla, ktoré sú medzi 1 a 9 vrátane, obráťte výsledný súbor a potom nahradite každú číslicu jej zodpovedajúcim menom z ""Jeden"", ""Dva"", ""Tri"", ""Štyri"", ""Piatky"", ""Šesť"", ""Sedem"", ""Osem"", ""Deväť"". Napríklad: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> zoradzujte arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> obráťte arr -> [8, 5, 4, 3, 2, 2, 1, 1] vráťte [""Osem"", ""Štyri"", ""Dva"", ""Dva"", ""Dva"", ""Dva"", ""Jeden"", ""Jeden""] Ak je súbor prázdny, vráťte súbor: arr = [] vráťte [] Ak má súbor nejaké cudzie číslo, ignorujte ho: arr = [1, 1 , 55] -> arr -> [1, 1], 55 -> arr -> [55, 1] - vráťte ['One'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,slk_Latn,python,"
def f(n):
    """"""Implementovať funkciu f, ktorá berie n ako parameter a vráti zoznam veľkosti n, tak, že hodnota prvku v indexe i je faktoriál i, ak je i párne, alebo súčet čísel od 1 do i inak. i začína od 1. faktoriál i je násobenie čísel od 1 do i (1 * 2 * ... * i).""""""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,slk_Latn,python,"
def even_odd_palindrome(n):
    """"""Pri pozitívnom celkom čísle n vráti tupl, ktorý má počet párnych a nepárnych palindrómov, ktoré patria do rozsahu {1, n), vrátane. Príklad1: Vstup: 3 Výstup: (1, 2) Vysvetlenie: Celkové palindrómy sú 1, 2, 3. jeden z nich je párny a dva z nich sú nepárne. Príklad2: Vstup: 12 Výstup: (4, 6) Vysvetlenie: Celkové palindrómy sú 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. štyri z nich sú párne a 6 z nich sú nepárne. Poznámka: 1. 1 <= n <= 10^3 2. tupl vrátil počet párnych a nepárnych palindrómov. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,slk_Latn,python,"
def count_nums(arr):
    """"""Napíšte funkciu count_nums, ktorá berie súbor celých čísel a vráti počet prvkov, ktorých súčet číslic je > 0. Ak je číslo záporné, potom jeho prvá podpísaná číslica bude záporná: napr. -123 má podpísané číslice -1, 2 a 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,slk_Latn,python,"
def move_one_ball(arr):
    """"""Máme pole 'arr' N čísiel arr[1], arr[2], ..., arr[N].Čísla v pole budú náhodne usporiadané. Vašou úlohou je určiť, či je možné zoradiť pole v nezmenšujúcom poradí vykonaním nasledujúcej operácie na danom poli: Máte povolenie vykonať operáciu posunu doprava ľubovoľný počet krát. Jedna operácia posunu doprava znamená posun všetkých prvkov pole o jednu pozíciu v pravom smere. Posledný prvok pole sa presunie do počiatočnej pozície v poli, t. j. 0th index. Ak je možné získať zoradené pole vykonaním vyššie uvedenej operácie, potom vráťte True, inak vráťte False. Ak je dané pole prázdne, potom vráťte True. Poznámka: Uvedený zoznam má zaručené jedinečné prvky. Napríklad: move_one_{\displaystyle _{\displaystyle _{\displaystyle _{\displaystyle _{\displaystyle _{\}}{\displaystyle _{\displaystyle _{\displaystyle _{\frac}}},==one_{one_{\displaystyle _{\displaystyle _{\ball_{\ball_{\right_{one_}}},{\displaystyle _{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\right_{4}}},{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\ball_{\ball}}}4,5,}}}}}}}}}}}}}}}}}} 2}, 2}, 2>{\ball_{\ball}}}}}}}}""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,slk_Latn,python,"
def exchange(lst1, lst2):
    """"""V tomto probléme, implementujete funkciu, ktorá berie dva zoznamy čísel a určuje, či je možné vykonať výmenu prvkov medzi nimi, aby lst1 bol zoznamom iba párnych čísel. Nie je obmedzený počet vymenených prvkov medzi lst1 a lst2. Ak je možné vymeniť prvky medzi lst1 a lst2 tak, aby všetky prvky lst1 boli párne, vráťte ""ÁNO"". V opačnom prípade vráťte ""NIE"". Napríklad: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""ÁNO"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NIE"" Predpokladá sa, že vstupné zoznamy budú neprázdne. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,slk_Latn,python,"
def histogram(test):
    """"""Ak je daný reťazec, ktorý predstavuje malé písmená oddelené medzerami, vráti slovník písmena s najväčším počtom opakovaní a obsahujúci zodpovedajúci počet. Ak sa niekoľko písmen vyskytuje rovnako, vráti všetky. Príklad: histogram{""a b c"") == {'a"": 1, ""b"": 1, ""c"": 1} histogram{""a b b a"") == {'a"": 2, ""b"": 2} histogram{""a b c a b"") == {'a': 2, ""b"": 2} histogram{""b b a b"") == {'b 4}: histogram{""a b"") == {} {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,slk_Latn,python,"
def reverse_delete(s,c):
    """"""Úloha Máme dve reťazce s a c, musíte odstrániť všetky znaky v s, ktoré sa rovnajú ľubovoľnému znakovi v c a potom skontrolovať, či je výsledný reťazec palindróm. Reťazec sa nazýva palindróm, ak sa číta rovnako dozadu ako dopredu. Mali by ste vrátiť tupl obsahujúci výsledný reťazec a True/False pre kontrolu. Príklad pre s = ""abcde"", c = ""ae"", výsledok by mal byť ('bcd', False) pre s = ""abcdef"", c = ""b"" výsledok by mal byť ('acdef', False) pre s = ""abcdedcba"", c = ""ab"", výsledok by mal byť ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,slk_Latn,python,"
def odd_count(lst):
    """"""Ak je daný zoznam reťazcov, kde každý reťazec pozostáva len z číslic, vráti zoznam. Každý prvok i výstupu by mal byť ""počet nepárnych prvkov v reťazi i vstupného"". kde všetky i by mali byť nahradené počtom nepárnych číslic v i'teho reťaze vstupného. >>> odd_count['1234567']) [""počet nepárnych prvkov 4n str4ng 4 4n input.""] >>> odd_count['3',""111111""]) [""počet nepárnych prvkov 1n str1ng 1 1n input."", ""počet nepárnych prvkov 8n str8ng 8 8n input.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,slk_Latn,python,"
def minSubArraySum(nums):
    """"""Pri dávke súboru celých čísel n, nájdite minimálnu sumu akéhokoľvek neprázdneho podsúboru čísel. Príklad minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,slk_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Máte pravouhlú mriežku studní. Každý riadok predstavuje jednu studňu a každá 1 v rade predstavuje jednu jednotku vody. Každá studňa má zodpovedajúci vedro, ktoré sa môže použiť na extrakciu vody z nej a všetky vedra majú rovnakú kapacitu. Vašou úlohou je použiť vedra na vyprázdnenie studní. Vystúpte počet krát, ktoré potrebujete na zníženie vedra. Príklad 1: Vstup: mriežka: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Výstup: 6 Príklad 2: Vstup: mriežka: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Výstup: 5 Príklad 3: Vstup: [[:0,0,0], [0,0]] bucket_capacity: 5 Výstup: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,slk_Latn,python,"
def sort_array(arr):
    """"""V tejto Kata, musíte zoradiť pole ne-negatívnych celých čísel podľa počtu jedincov v ich binárnej reprezentácii vo vzostupnom poradí. Pre podobný počet jedincov, zoradiť na základe desatinných hodnôt. Musí byť implementovaný takto: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,slk_Latn,python,"
def select_words(s, n):
    """"""Ak je reťazec s prázdny, funkcia by mala vrátiť prázdny zoznam. Poznámka: môžete predpokladať, že vstupný reťazec obsahuje len písmená a medzery. Príklady: select_words ""Mary mala malé jahňatko"", 4) ==> [""malé""] select_words ""Mary mala malé jahňatko"", 3) ==> [""Mary"", ""lamb""] select_words ""jednoduché biele miesto"", 2) ==> [] select_words ""Dobrý deň"", 4) ==> [""svet""] select_words ""Strýko Sam"", 3) ==> [""Strýko""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,slk_Latn,python,"
def get_closest_vowel(word):
    """"""Máte slovo. Vašou úlohou je nájsť najbližšiu samohlásky, ktorá stojí medzi dvoma sponzormi z pravej strany slova (citlivá na veľkosť). Samohlásky na začiatku a na konci sa nepočítajú. Vráťte prázdny reťazec, ak ste nenašli žiadnu samohlásky splnil vyššie uvedenú podmienku. Môžete predpokladať, že daný reťazec obsahuje len anglické písmeno. Príklad: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,slk_Latn,python,"
def match_parens(lst):
    '''Máte zoznam dvoch reťazcov, oba reťazce pozostávajú len z otvorených zátvorok '(' alebo z uzavretých zátvorok ') '. Vašou úlohou je skontrolovať, či je možné prepojiť tieto dve reťazce v určitom poradí, aby výsledný reťazec bol dobrý. Reťazec S sa považuje za dobrý, ak a len ak sú všetky zátvorky v S vyvážené. Napríklad: reťazec '((()) ' je dobrý, zatiaľ čo reťazec '()) ' nie je. Vráti 'Áno', ak existuje spôsob, ako vytvoriť dobrý reťazec, a vracia 'Nie' inak. Príklady: match_parens[('() ', ') ']) == 'Áno' match_parens[(') ', ') ']) == 'Nie' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,slk_Latn,python,"
def maximum(arr, k):
    """"""Vzor 1: Vstup: arr = [-3, -4, 5], k = 3 Výstup: [-4, -3, 5] Vzor 2: Vstup: arr = [4, -4, 4], k = 2 Výstup: [4, 4] Vzor 3: Vstup: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Výstup: [2] Poznámka: 1. Dĺžka pole bude v rozsahu [1, 1000]. 2. Prvky v poli budú v rozsahu [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,slk_Latn,python,"
def solution(lst):
    """"""V prípade, že je daný neprázdny zoznam celých čísel, vráti sa súčet všetkých nepárnych prvkov, ktoré sú v párnom polohe.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,slk_Latn,python,"
def add_elements(arr, k):
    """"""V prípade, že je daný neprázdny súbor celých čísel arr a celého čísla k, vráti sa súčet prvkov s najviac dvoma číslicami prvých k prvkov arr. Príklad: Vstup: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Výstup: 24 # súčet 21 + 3 Obmedzenia: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,slk_Latn,python,"
def get_odd_collatz(n):
    """"""Collatzova domnienka je matematická domnienka, ktorá sa týka sekvencie definovanej takto: začnite s akýmkoľvek kladným celým číslom n. Potom sa každý člen získa z predchádzajúceho člena takto: ak je predchádzajúci člen párny, ďalší člen je polovicou predchádzajúceho člena. Ak je predchádzajúci člen neštyľý, ďalší člen je 3 krát predchádzajúci člen plus 1. Domnienka je, že bez ohľadu na to, akú hodnotu n, postupnosť vždy dosiahne 1. Poznámka: 1. Collatz(1) je [1]. 2.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,slk_Latn,python,"
def valid_date(date):
    """"""Musíte napísať funkciu, ktorá overí daný reťazec dátumov a vráti hodnotu True, ak je dátum platný, inak False. Dátum je platný, ak sú splnené všetky nasledujúce pravidlá: 1. Reťazec dátumov nie je prázdny. 2. Počet dní nie je menší ako 1 alebo vyšší ako 31 dní pre mesiace 1,3,5,7,8,10,12. A počet dní nie je menší ako 1 alebo vyšší ako 30 dní pre mesiace 4,6,9,11. A počet dní nie je menší ako 1 alebo vyšší ako 29 dní pre mesiac 2. 3. Mesiace by nemali byť menšie ako 1 alebo vyššie ako 12. 4. Dátum by mal byť vo formáte: mm-dd-yyyy napríklad: valid_date ({'03-11-2000') => True_valid_date ({'15-01-2012') => False valid_date ({'04-01-2040') => False_valid_date ({'06-04-2020') => True_valid ({'06/04/2020')  => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,slk_Latn,python,"
def split_words(txt):
    '''Ak je daný reťazec slov, vráti zoznam slov rozdelených na biely priestor, ak v texte neexistujú žiadne biely priestor, mali by ste ich rozdeliť na čiarky ',' ak neexistujú čiarky, mali by ste vrátiť počet malých písmen v nepárnom poradí v abecede, ord('a') = 0, ord'(b') = 1, ... ord('z') = 25 Príklady split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,slk_Latn,python,"
def is_sorted(lst):
    '''V prípade, že je zoznam čísel, vráti sa, či sú zoradené v stúpajúcom poradí. Ak je zoznam viac ako 1 duplikátom toho istého čísla, vráti sa False. Predpokladajme, že nie sú žiadne záporné čísla a len celé čísla. Príklady is_sorted ({1,2,3,4,5}) â -> True is_sorted ({1,3,2,3,4,5,6}) â -> False is_sorted ({1,2,3,4,5,6,7}) â -> True is_sorted ({1,2,3,4,5,6,7}) â -> False is_sorted ({1,3,2,4,5,6,7}) â -> False is_sorted ({1,1,2,2,3,3,4,4}) â -> True is_sorted ({1,2,2,2,3,4,4}) â '''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,slk_Latn,python,"
def intersection(interval1, interval2):
    """"""V tomto prípade je časový interval (časový interval) krát časový interval (časový interval) alebo časový interval (časový interval) krát časový interval (časový interval). Máte dve intervaly, kde každý interval je párom čísel. Napríklad interval = (začiatok, koniec) = (1, 2). Dáté intervaly sú uzavreté, čo znamená, že interval (začiatok, koniec) zahŕňa začiatok aj koniec. Pre každý daný interval sa predpokladá, že jeho začiatok je menší alebo rovný jeho koncu. Vašou úlohou je určiť, či dĺžka priesečku týchto dvoch intervalov je prvočíslo. Napríklad priesečie intervalov (1, 3), (2, 4) je (2, 3) ktorého dĺžka je 1, čo nie je prvočíslo. Ak je dĺžka priesečku prvočíslo, vráťte ""ÁNO"", inak vráťte ""NIE"". Ak sa tieto dva intervaly nestretnú, vráťte ""NIE"". [input/output] vzorky: priesečie""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,slk_Latn,python,"
def prod_signs(arr):
    """"""Máte zornicu arr celých čísel a musíte vrátiť súčet veľkostí celých čísel vynásobených vynásobením všetkých znakov každého čísla v zornici, reprezentovaných číslicami 1, -1 alebo 0. Poznámka: vráti sa NULL pre prázdne zornice. Príklad: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == NULL""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,slk_Latn,python,"
def minPath(grid, k):
    """"""V prípade mriežky s N riadkami a N stĺpcami (N >= 2) a s kladným celým číslom k, každá bunka mriežky obsahuje hodnotu. Každá celá hodnota v rozsahu [1, N * N] vrátane sa objaví presne raz v bunkách mriežky. Musíte nájsť minimálnu cestu dĺžky k v mriežke. Môžete začať z akejkoľvek bunky a v každom kroku sa môžete presunúť do ktorejkoľvek susednej bunky, inými slovami, môžete ísť do buniek, ktoré zdieľajú okraj s vašou súčasnou bunkou. Všimnite si, že cesta dĺžky k znamená návštevu presne k buniek (nie nevyhnutne odlišných). NEMOŽE sa dostať mimo mriežky. Cesta A (dĺžky k) sa považuje za menšiu ako cesta B (dĺžky k), ak po vytvorení usporiadaných zoznamov hodnôt na bunkách, ktoré prechádzajú A a B (pozrime sa na ne ako l_stA a l_stB), je lexikálne menšia ako l_stA, inak povedané, v mriežky s celou dĺžky k môžete ísť do ktorejkoľvek susednej bunky, inými slovami, môžete ísť do buniek, ktoré majú rovnakú okraj s vami súčasnú bunku.""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,slk_Latn,python,"
def tri(n):
    """"""Každý pozná Fibonacciho sekvenciu, ktorú hlboko študovali matematici v posledných dvoch storočiach. Avšak to, čo ľudia nevedia, je Tribonacciho sekvencia. Tribonacciho sekvencia je definovaná opakovaním: tri(1) = 3 tri(n) = 1 + n / 2, ak je n párné. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ak je n nepárové. Napríklad: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Máte ne-negatívne celé číslo n, musíte vrátiť zoznam prvých n + 1 čísel Tribonacciho sekvencie. Príklady: tri(3) = [1, 3, 2, 8] """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,slk_Latn,python,"
def digits(n):
    """"""Vráti hodnotu 0 ak sú všetky číslice párne. Napríklad: číslice""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,slk_Latn,python,"
def is_nested(string):
    '''Vytvorte funkciu, ktorá ako vstup prijíma reťazec, ktorý obsahuje iba hranaté zátvorky. Funkcia by mala vrátiť True, ak a len ak existuje platná podsekvencia zátvorok, kde je aspoň jedna zátvorka v podsekvencii v hniezdku. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]] â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,slk_Latn,python,"

def sum_squares(lst):
    """"""V tomto prípade je potrebné, aby ste sa obrátili na číslo, ktoré je v zozname, a potom zaokrúhlili každý prvok zoznamu na hornú hodnotu.""""""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,slk_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Vytvorte funkciu, ktorá vráti True, ak je posledný znak daného reťazca abecedným znakom a nie je súčasťou slova, a False inak. Poznámka: ""slov"" je skupina znakov oddelených medzníkom. Príklady: check_if_last_char_is_a_letter""{""apple pie"") â -> False check_if_last_char_is_a_letter""{""apple pi e"") â -> True check_if_last_char_is_a_letter""{""apple pi e"") â -> False check_if_last_char_is_a_letter""{""}""{""}""{""}'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,slk_Latn,python,"
def can_arrange(arr):
    """"""Vytvorte funkciu, ktorá vráti najväčší index prvku, ktorý nie je väčší alebo rovný prvku, ktorý je bezprostredne pred ním. Ak takýto prvok neexistuje, vráti sa -1. Uvedený súbor nebude obsahovať duplicitné hodnoty. Príklad: can_arrange ({1,2,4,3,5]) = 3 can_arrange ({1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,slk_Latn,python,"
def largest_smallest_integers(lst):
    '''Vytvorte funkciu, ktorá vráti tupl (a, b), kde 'a' je najväčšie z negatívnych celých čísel a 'b' je najmenšie z pozitívnych celých čísel v zozname. Ak nie sú žiadne negatívne alebo pozitívne celé čísla, vráťte ich ako None. Príklady: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,slk_Latn,python,"
def compare_one(a, b):
    """"""Vytvorte funkciu, ktorá prijíma celé čísla, plávajúce čísla alebo reťazce reprezentujúce reálne čísla a vráti väčšiu premennú v danom type premenných. Vráti nulú, ak sú hodnoty rovnaké. Poznámka: Ak je reálne číslo reprezentované ako reťazec, pohyblivý bod môže byť . alebo , porovnať_jeden, 2,5) â -> 2,5 porovnať_jeden, ""2,3"") â -> ""2,3"" porovnať_jeden, ""5,1"", ""6"") â -> ""6"" porovnať_jeden, ""1"", 1) â -> žiadna """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,slk_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Vyhodnoťte, či sa daný počet n dá zapísať ako súčet presne 4 kladných párnych čísel. Príklad is_equal_to_sum_even ({4) } == False is_equal_to_sum_even ({6) } == False is_equal_to_sum_even ({8) } == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,slk_Latn,python,"
def special_factorial(n):
    """"""Brazílsky faktoriál je definovaný ako: brazilian_factorial{n} = n! * (n-1)! * (n-2)! * ... * 1! kde n > 0 Napríklad: >>> special_factorial{4) 288 Funkcia dostane celé číslo ako vstup a mala by vrátiť špeciálny faktoriál tohto čísla. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,slk_Latn,python,"
def fix_spaces(text):
    """"""_Príklad-3vý reťazec, všetky medzery v ňom nahradite podčiarkami a ak reťazec má viac ako 2 po sebe nasledujúce medzery, potom všetky po sebe nasledujúce medzery nahradite - fix_spaces ((""Príklad"") == ""Príklad"" fix_spaces ((""Príklad1"") == ""Príklad_1"" fix_spaces (((""Príklad2"") == ""_Príklad_2"" fix_spaces ((""Príklad 3"") == ""_Príklad-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,slk_Latn,python,"
def file_name_check(file_name):
    """"""Vytvorte funkciu, ktorá vezme reťazec reprezentujúci názov súboru a vráti 'Áno', ak je názov súboru platný, a vráti 'Nie', ak nie. Názov súboru sa považuje za platný, ak a len ak sú splnené všetky tieto podmienky: - V názve súboru by nemali byť viac ako tri číslice ('0'-'9') - Názov súboru obsahuje presne jednu bodku '.' - Podreťazec pred bodkou by nemal byť prázdny a mal by sa začať písmenom latinského alphabetu ('a'-'z' a 'A'Z'). - Podreťazec po bode by mal byť jedným z týchto: ['txt', 'exe', 'lld'] Príklady: file_name_check""{example.txt.txt} # => 'Áno' => 'názov_súboru_check""{example.dll.1} # => 'Nie' (názov by mal začať latinským písmenom alphabetu)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,slk_Latn,python,"


def sum_squares(lst):
    """""""" Táto funkcia vyberie zoznam celých čísel. Pre všetky položky v zozname funkcia umocní na druhou celú položku, ak je jej index násobok 3 a na trojicu celú položku, ak je jej index násobok 4 a nie násobok 3. Funkcia nezmení položky v zozname, ktorých indexy nie sú násobkom 3 alebo 4. Funkcia potom vráti súčet všetkých položok. Príklad: Pre lst = [1,2,3] výstup by mal byť 6 Pre lst = [] výstup by mal byť 0 Pre lst = [-1,-5,2,-1,-5] výstup by mal byť -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,slk_Latn,python,"
def words_in_sentence(sentence):
    """"""Máte reťazec, ktorý predstavuje vetu, veta obsahuje niektoré slová oddelené medzníkom a musíte vrátiť reťazec, ktorý obsahuje slová z pôvodnej vety, ktorých dĺžky sú prvočísla, poradie slov v novej reťazi by malo byť rovnaké ako v pôvodnej. Príklad1: Vstup: veta = ""Toto je test"" Výstup: ""je"" Príklad2: Vstup: veta = ""nech ide na plávanie"" Výstup: ""choď na"" Obmedzenia: * 1 <= len(reťazec) <= 100 * veta obsahuje iba písmená """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,slk_Latn,python,"
def simplify(x, n):
    """"""Vaša úloha je implementovať funkciu, ktorá zjednoduší výraz x * n. Funkcia vráti True, ak sa x * n vyhodnocuje na celé číslo a False inak. Obaja x a n sú reťazcovými reprezentáciami zlomku a majú nasledujúci formát, <čítateľ>/<menovateľ>, kde sú čitateľ aj menovateľ kladné celé čísla. Môžete predpokladať, že x a n sú platné zlomky a nemajú nulovú hodnotu ako menovateľ. zjednodušiť ""1/5"", ""5/1"") = True zjednodušiť ""1/6"", ""2/1"") = False zjednodušiť ""7/10"", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,slk_Latn,python,"
def order_by_points(nums):
    """"""Napíšte funkciu, ktorá zoradí daný zoznam celých čísel v vzostupnom poradí podľa súčtu ich číslic. Poznámka: ak existuje niekoľko položiek s podobným súčtom ich číslic, zoradite ich podľa ich indexu v pôvodnom zozname. Napríklad: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,slk_Latn,python,"
def specialFilter(nums):
    """"""Napíšte funkciu, ktorá vezme súbor čísel ako vstup a vráti počet prvkov v poli, ktoré sú väčšie ako 10 a obe prvej a poslednej číslice čísla sú nepárne (1, 3, 5, 7, 9).""""""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,slk_Latn,python,"
def get_max_triples(n):
    """"""Máte kladné celé číslo n. Musíte vytvoriť celé číslo array a dĺžky n. Pre každé i (1 ‰¤ i ‰¤ n) hodnota a[i] = i * i - i + 1. Vráti počet trojnásobkov (a[i], a[j], a[k]) a kde i < j < k, a a[i] + a[j] + a[k] je násobok 3. Príklad: Vstup: n = 5 Výstup: 1 Vysvetlenie: a = [1, 3, 7, 13, 21] Jediný platný trojnásobok je (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,slk_Latn,python,"
def bf(planet1, planet2):
    '''V našej slnečnej sústave je osem planét: najbližšia k Slnku je Merkur, ďalšia je Venuša, potom Zem, Mars, Jupiter, Saturn, Uran, Neptún. Napíšte funkciu, ktorá berie dva názvy planét ako reťazce planéta1 a planéta2. Funkcia by mala vrátiť tupl obsahujúci všetky planéty, ktorých obežné dráhy sa nachádzajú medzi obežnou dráhou planéty1 a obežnou dráhou planéty2, zoradené podľa blízkosti k Slnku. Funkcia by mala vrátiť prázdny tupl, ak planéta1 alebo planéta2 nie sú správne názvy planét. Príklad bf ""(Jupiter"", ""Neptún"") ==> (""Saturn"", ""Uran"") bf (((""Zem"", ""Merkur"") ==> (""Venuša"") bf (((""Merkur"", ""Uran"") ==> (""Venuša"", ""Zem"", ""Mars"", ""Jupiter"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,slk_Latn,python,"
def sorted_list_sum(lst):
    """"""Napíšte funkciu, ktorá akceptuje zoznam reťazcov ako parameter, vymaže reťazce, ktoré majú nepárnu dĺžku, a vráti výsledný zoznam so zoradeným poradením. Zoznam je vždy zoznam reťazcov a nikdy nie je súborom čísel a môže obsahovať duplikáty. Poradie zoznamu by malo byť stúpajúce podľa dĺžky každého slova a mali by ste vrátiť zoznam zoradený podľa tohto pravidla. Ak majú dve slová rovnakú dĺžku, zoradite zoznam abecedne. Funkcia by mala vrátiť zoznam reťazcov v zoradenom poradí. Môžete predpokladať, že všetky slová budú mať rovnakú dĺžku. Napríklad: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => [""ab"", ""cd""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,slk_Latn,python,"
def x_or_y(n, x, y):
    """"""Jednoduchý program, ktorý by mal vrátiť hodnotu x, ak je n prvočíslo a v opačnom prípade by mal vrátiť hodnotu y. Príklad: pre x_or_y{7, 34, 12) == 34 pre x_or_y{15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,slk_Latn,python,"
def double_the_difference(lst):
    '''V prípade zoznamu čísel vráti sa súčet štvorcov čísel na zozname, ktoré sú nepárne. Ignorujte čísla, ktoré sú záporné alebo nie sú celé čísla. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Ak je vstupný zoznam prázdny, vráti sa 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,slk_Latn,python,"
def compare(game,guess):
    """"""Myslím, že si všetci pamätáme ten pocit, keď je konečne známy výsledok nejakého dlho očakávaného udalosti. Pocity a myšlienky, ktoré máte v tom momente, určite stojí za to si zapísať a porovnať. Vašou úlohou je určiť, či osoba správne uhádla výsledky viacerých zápasov. Máte dve súpravy skóre a hádaní rovnakej dĺžky, kde každý index ukazuje zápas. Vráťte súpravu rovnakej dĺžky, ktorá označuje, ako ďaleko od každého hádania bola. Ak uhádli správne, hodnota je 0, a ak nie, hodnota je absolútny rozdiel medzi odhadom a skóre.""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,slk_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Zobrazí sa vám názov triedy (strun) a zoznam rozšírení. Rozšírenia sa majú použiť na načítanie ďalších tried do triedy. Výška rozšírenia je nasledovná: CAP je počet veľkých písmen v názve rozšírenia a SM je počet malých písmen v názve rozšírenia, výška je daná zlomkom CAP - SM. Mali by ste nájsť najsilnejšie rozšírenie a vrátiť reťazec v tomto formáte: ClassName.StrongestExtensionName. Ak sú dva alebo viac rozšírení s rovnakou výškou, mali by ste vybrať to, ktoré je v zozname na prvom mieste. Napríklad, ak máte ako triedu ""Slices"" a zoznam rozšírení: ['SEvirNGliSCes', 'Cheese', 'StuFfed'], mali by ste vrátiť 'Slices.SEvirNGliCes' pretože 'SvirNGliCes' je silné (extension: 'AA_Beats'), napríklad 'AA_Beats' je najvýznamnejšia výška (extension: 'AA_Beats'), ['Strongest_Class'], 'AA_Extension' = 'Strongest_Class'""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,slk_Latn,python,"
def cycpattern_check(a , b):
    """"""Máte 2 slová. Musíte vrátiť True, ak druhé slovo alebo niektorý z jeho otáčok je podstránka v prvom slove cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,slk_Latn,python,"
def even_odd_count(num):
    """"""Vráti tupl, ktorý má počet párnych a nepárnych číslic. Príklad: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,slk_Latn,python,"
def int_to_mini_roman(number):
    """"""Pri pozitívnom číslice vyberte jeho rímsky ekvivalent ako reťazec a vráťte ho malým písmenom. Obmedzenia: 1 <= num <= 1000 Príklady: >>> int_to_mini_roman{19} == 'xix' >>> int_to_mini_roman{152} == 'clii' >>> int_to_mini_roman{426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,slk_Latn,python,"
def right_angle_triangle(a, b, c):
    '''V prípade pravouhlého trojuholníka je pravouhlý trojuholník trojuholník, v ktorom je jeden uhol pravouhlý alebo 90 stupňov.'''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,slk_Latn,python,"
def find_max(words):
    """"""Napíšte funkciu, ktorá akceptuje zoznam reťazcov. Zoznam obsahuje rôzne slová. Vráti slovo s maximálnym počtom jedinečných znakov. Ak viac reťazcov má maximálny počet jedinečných znakov, vráti to, ktoré je prvé v lexikografickom poradí.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,slk_Latn,python,"
def eat(number, need, remaining):
    """"""Ste hladný králik a už ste zjedli určitý počet mrkvy, ale teraz potrebujete zjesť viac mrkvy, aby ste dokončili denné jedlá. mali by ste vrátiť súbor [celkový počet jedených mrkvy po jedle, počet mrkvy zostávajúce po jedle ] ak nie je dostatok zostávajúcich mrkvy, budete jesť všetky zostávajúce mrkvy, ale stále budete hladní. Príklad: * jesť(5, 6, 10) -> [11, 4] * jesť(4, 8, 9) -> [12, 1] * jesť(1, 10, 10) -> [11, 0] * jesť(2, 11, 5) -> [7, 0] Variable: @number: celé číslo počtu mrkvy, ktoré ste zjedli. @need: celé číslo počtu mrkvy, ktoré potrebujete zjesť. @remaining: celé číslo zostávajúcich mrkvy, ktoré existujú v zásobách. Obmedzenie: * 0= <= 0 * 1000 <= 0 * 0 = <= 1000 Zvyšná hodnota:""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,slk_Latn,python,"
def do_algebra(operator, operand):
    """"""Dátom dvoch zoznamov operátora a operanda. Prvý zoznam má základné algebraické operácie a druhý zoznam je zoznamom celých čísel. Použite dva uvedené zoznamy na vytvorenie algebraického výrazu a vráťte vyhodnotenie tohto výrazu. Základné algebraické operácie: Pridávanie (+) Odčítanie ( -) Množenie ( *) Podlažné delenie ( //) Exponenciálne ( **) Príklad: operátor['+', '*', '-'] pole = [2, 3, 4, 5] výsledok = 2 + 3 * 4 - 5 => výsledok = 9 Poznámka: Dĺžka zoznamu operátora sa rovná dĺžke zoznamu operandov mínus jeden. Operand je zoznamom ne-negatívnych celých čísel. Operátor má aspoň jeden zoznam operátora a zoznam operandov má aspoň dva operandy. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,slk_Latn,python,"
def solve(s):
    """"""Ak je s[i] písmeno, obráťte jeho veľkosť z dolnej na hornú alebo opačne, inak ho ponechajte tak, ako je. Ak reťazec neobsahuje žiadne písmená, obráťte reťazec. Funkcia by mala vrátiť výsledný reťazec. Príklady solve{""1234"") = ""4321""{""ab"") = ""AB""{""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,slk_Latn,python,"
def string_to_md5(text):
    """"""Ak je daný reťazec 'text', vráťte jeho md5 hash ekvivalentný reťazec. Ak je 'text' prázdny reťazec, vráťte None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,slk_Latn,python,"
def generate_integers(a, b):
    """"""V prípade dvoch kladných celých čísel a a b, vráťte párne číslice medzi a a b v vzostupnom poradí. Napríklad: generate_integers{2, 8) => [2, 4, 6, 8] generate_integers{8, 2) => [2, 4, 6, 8] generate_integers{10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
