task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,lit_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Patikrinkite, ar du skaičiai yra arčiau vienas kito nei nurodyta riba. Pavyzdys: >>> turi_artimiausius_elementus (([1.0, 2.0, 3.0], 0.5) Neteisingas >>> turi_artimiausius_elementus (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) Teisingas """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,lit_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Įvesties funkcija yra eilutė, kurioje yra kelios įklojuotų stulpelių grupės. Jūsų tikslas yra atskirti šias grupes į atskiras eilutes ir grąžinti jų sąrašą. Atskiros grupės yra subalansuotos (kiekviena atvira stulpelių yra tinkamai uždaryta) ir nėra įklojuotos viena į kitą Ignoruokite visus erdves įvesties eilutėje. Pavyzdys: >>> separate_paren_groups' ((( ) (() ((( ) ) "") ['() ', '(()) ', '(() ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,lit_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Jei skaičius yra teigiamas, jis gali būti suskaidytas į abiejų skaičių dalį (didžiausias skaičius mažesnis už duotą skaičių) ir dešimtines dalis (išlikusi dalis visada mažesnė nei 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,lit_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Jums pateikiamas banko sąskaitos indėlių ir išieškojimo operacijų sąrašas, kuris prasideda nuo nulinio likučio. Jūsų užduotis - aptikti, ar bet kuriuo metu sąskaitos balansas sumažėja žemiau nulio, ir tuo metu funkcija turėtų grąžinti ""True"". Priešingu atveju ji turėtų grąžinti ""False"".""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,lit_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Duoto įvesties skaičių sąrašo vidutinis absoliutus nuokrypis apskaičiuojamas aplink šio duomenų rinkinio vidurkį. Vidutinis absoliutus nuokrypis yra vidutinis absoliutus skirtumas tarp kiekvieno elemento ir centro taško (šiuo atveju vidutinis): MAD = vidutinis. x - x_vidutinis.""""""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,lit_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Įterpti skaičių ""atlyginimo"" tarp kiekvieno dviejų iš eilės esančių įvesties sąrašo elementų `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,lit_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Ši funkcija įvedia virvę, kurioje yra daug grupių, skirtų įkūrtiems užkyrams, atskirtams tarpomis. Kiekvienai grupei išvesti giliausias užkyrų įkūrimo lygis. Pavyzdžiui, (() (()) turi ne daugiau kaip du įkūrimo lygius, o ((())) turi tris. >>> parse_nested_parens('((()) ((())) () ((()) ((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,lit_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtruoti įvesties eilutės sąrašus tik tiems, kurie turi tam tikrą substring >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,lit_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Duoto sveikiųjų skaičių sąrašo atveju grąžinkite tupelį, kurį sudaro visų sąraše esančių sveikiųjų skaičių suma ir išvestis. Tuščias suma turėtų būti lygi 0, o tuščias išvestis turėtų būti lygus 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,lit_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Iš nustatyto sveikiųjų skaičių sąrašo generuokite iki nustatyto momento sekos metu rastų didžiausių elementų sąrašą. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,lit_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Rasti trumpiausią palindromą, kuris prasideda pateikta eilutė. Algoritmo idėja yra paprasta: - Rasti ilgiausią pateiktos eilutės postfixą, kuris yra palindromas. - Prijungti prie eilutės pabaigos priešingą eilutės prefiksą, kuris ateina prieš palindrominį sufiksą. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Bandymas, ar duota eilutė yra palindromas""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,lit_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Įvesties yra dvi eilutės a ir b, sudarytos tik iš 1 ir 0 eilutės. Įvesties atliekamas dvejetainis XOR ir rezultatas taip pat grąžinamas kaip eilutė. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,lit_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Iš eilutės sąrašo grąžinkite ilgiausią. Grąžinkite pirmąją, jei yra kelių tos pačios ilgio eilutės. Grąžinkite Nėra, jei įvesties sąrašas tuščias. >>> ilgiausias (([]) >>> ilgiausias ((['a', 'b', 'c']) 'a' >>> ilgiausias ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,lit_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Grąžina didžiausią bendrą dviejų vienetų a ir b dalintoją >>> didžiausią_vienetą_dalintoją ((3, 5) 1 >>> didžiausią_vienetą_dalintoją ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,lit_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Grąžina visų įvesties eilutės prefiksų sąrašą nuo trumpiausio iki ilgiausio >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,lit_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Grąžina eilutę, kurioje yra erdvėje apibrėžtų skaičių, pradedant nuo 0 iki n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,lit_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Duota eilutė, išsiaiškinkite, kiek skirtingų simbolių (nepriklausomai nuo balų) ji susideda iš >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,lit_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Įvesti šią funkciją yra virvė, atstovaujanti muzikos pastabų specialiu ASCII formatu. Jūsų užduotis yra išanalizuoti virvės sąrašą iš ištisų lygių daugelį smūgių ne. Čia yra legenda: 'o' - pastaba, paskutiniai smūgiai keturi 'o' - pusė pastaba, paskutiniai du smūgiai - ketvirčio pastaba, paskutiniai vienas smūgis >>> parse_music. 'o o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,lit_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Rasti, kiek kartų tam tikra substringa gali būti rasta originalioje eilutėje. Skaičiuoti sutampa atvejus. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,lit_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Įvesti numeris yra erdvėje apibrėžta eilutė, sudaryta iš skaičių nuo ""nullio"" iki ""devynių"". Galimi pasirinkimai yra ""nullio"", ""vienos"", ""dviejų"", ""trys"", ""keturių"", ""penkių"", ""šešių"", ""septynių"", ""aštunų"" ir ""devynių"". Grąžina eilutę su skaičiais, surūšiuotais nuo mažiausio iki didžiausio >>> sort_numbers (('trys vienas penkias') 'vienas trys penkias' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,lit_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Iš pateikto skaičių sąrašo (ne mažiau kaip dviejų ilgis) pasirinkite ir grąžinkite du, kurie yra arčiausiai vienas kito, ir grąžinkite juos pagal eilę (mažesnis skaičius, didesnis skaičius). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,lit_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Duotas skaičių sąrašas (iš bent dviejų elementų), pritaikyti linijinį transformavimą į tą sąrašą, kad mažiausias skaičius taps 0 ir didžiausias taps 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,lit_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filtras: duotas bet kokių Python verčių sąrašas tik ištisų skaičių >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,lit_Latn,python,"

def strlen(string: str) -> int:
    """"""Duotos eilutės grąžinimo ilgis >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,lit_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Nustatykite didžiausią skaičių, kuris padalina n tolygiai, mažesnį nei n >>> didžiausia_dalintoja ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,lit_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Grąžina duoto sveiko skaičiaus pirminių veiksnių sąrašą nuo mažiausio iki didžiausio. Kiekvienas veiksnys turi būti išvardytas taip, kad jis būtų dauginamas. Įvesties skaičius turi būti lygus visų veiksnių padažnui >>> faktorizuoti ((8) [2, 2, 2] >>> faktorizuoti ((25) [5, 5] >>> faktorizuoti ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,lit_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Iš viso skaičiaus sąrašo pašalinkite visus elementus, kurie yra daugiau nei vieną kartą. Palikite elementų eilę tokia pati, kaip įvesties. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,lit_Latn,python,"

def flip_case(string: str) -> str:
    """"""Duotos eilutės mažųjų raidžių raidės perkelti į dideles ir dideles raidės į mažas. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,lit_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Konkateniruoti eilutės į vieną eilutę >>> konkateniruoti([]) '' >>> konkateniruoti(['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,lit_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtruoti įvesties eilutės sąrašas tik tiems, kurie prasideda su tam tikru prefiksu. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,lit_Latn,python,"

def get_positive(l: list):
    """"""Grąžina tik teigiamus skaičius sąraše. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,lit_Latn,python,"

def is_prime(n):
    """"""Grąžina teisingą, jei nurodytas skaičius yra pirminis, ir klaidingą, jei ne. >>> yra_pirminis (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime (angl. is_prime) (angl. is_prime) (angl. is_prime (angl. is_prime) (angl. is_prime (angl. is_prime) (angl. is_prime) (angl. is_prime (angl. is_prime) (angl. is_prime) (angl. is_prime) (angl. is_prime)""""""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,lit_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs yra polinomių koeficientai. find_zero find x taip, kad poly(x) = 0. find_zero grąžina tik tik nulinį tašką, net jei jų yra daug. Be to, find_zero tik naudoja xs sąrašą, turintį net ir koeficientų skaičių ir didžiausią ne nulinį koeficientą, nes tai garantuoja sprendimą. >>> apvalka >>> find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> apvalka >>> find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Vertina polinomą su koeficientais xs taške x. grąžina xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,lit_Latn,python,"

def sort_third(l: list):
    """"""Ši funkcija imasi sąrašo l ir grąžina sąrašą l' taip, kad l' būtų identiškas l indeksuose, kurie nėra dalijami iš trijų, o jo vertės indeksuose, kurie yra dalijami iš trijų, yra lygios atitinkamų l indekso vertybių, bet surūšiuotos. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,lit_Latn,python,"

def unique(l: list):
    """"""Grąžina rūšiuotus unikalius elementus sąraše >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,lit_Latn,python,"

def max_element(l: list):
    """"""Grąžina didžiausią elementą sąraše. >>> max_element([1, 2, 3]) 3 >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,lit_Latn,python,"

def fizz_buzz(n: int):
    """"""Grąžina skaičių, kiek kartų skaitmenys 7 yra mažesniame nei n skaičiuje, dalinamame iš 11 ar 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,lit_Latn,python,"

def sort_even(l: list):
    """"""Ši funkcija imasi sąrašo l ir grąžina sąrašą l' taip, kad l' būtų identiškas l netolygiais indeksais, o jo vertės netolygiais indeksais būtų lygios l netolygiai indeksais, bet surūšiuotos. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,lit_Latn,python,"

def encode_cyclic(s: str):
    """"""                                                        """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""grąžina užkoduotą eilutę pagal trijų simbolių ciklines grupes. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,lit_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib grąžina n-ąjį skaičių, kuris yra Fibonaččio skaičius ir jis taip pat yra pirminis. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,lit_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero imasi vienų vienetų sąrašo kaip įvesties. Jis grąžina True, jei sąraše yra trys atskiri elementai, kurių suma yra nulinė, ir False, jei nėra. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,lit_Latn,python,"

def car_race_collision(n: int):
    """"""Įsivaizduokite kelią, kuris yra visiškai tiesus, begalybe ilgas. n automobilių važiuoja iš kairės į dešinę; tuo pačiu metu, skirtingas n automobilių rinkinys važiuoja iš dešinės į kairę. Abi automobilių rinkiniai prasideda labai toli vienas nuo kito. Visi automobiliai juda tuo pačiu greičiu. Du automobiliai susiduria, kai automobilis, judantis iš kairės į dešinę, susiduria su automobiliu, judančiu iš dešinės į kairę. Tačiau automobiliai yra begalybe tvirtūs ir stiprūs; todėl jie toliau juda savo trajektorijoje, tarsi nebūtų susidūrę. Ši funkcija išleidžia tokių susidūrimų skaičių.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,lit_Latn,python,"

def incr_list(l: list):
    """"""Grąžina sąrašą su elementais, padidintais 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,lit_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero įvedia visą skaičių sąrašą. Jis grąžina True, jei sąraše yra du skirtingi elementai, kurių suma yra nulinė, ir False kitaip. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,lit_Latn,python,"

def change_base(x: int, base: int):
    """"""Pakeisti įvesties x numerio skaitmeninę bazę bazė. Grąžinti virvės reprezentaciją po konversijos. Baziniai skaičiai yra mažesni nei 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,lit_Latn,python,"

def triangle_area(a, h):
    """"""Duotas šonų ilgis ir aukštas trikampio grąžinimas. >>> trikampio_plotas ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,lit_Latn,python,"

def fib4(n: int):
    """"""Fib4 skaičių seka yra Fibbonacci eilės, kuri yra apibrėžta taip: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Rašykite funkciją, kuri efektyviai apskaičiuotų fib4 skaičių eilės n-ąjį elementą.""""""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,lit_Latn,python,"

def median(l: list):
    """"""Listo elementų grąžinimo mediana l. >>> mediana (([3, 1, 2, 4, 5]) 3 >>> mediana (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,lit_Latn,python,"

def is_palindrome(text: str):
    """"""Patikrina, ar pateikta eilutė yra palindromas >>> is_palindromas (('') Tinka >>> is_palindromas (('aba') Tinka >>> is_palindromas (('aaaaa') Tinka >>> is_palindromas (('zbcd') Neteisinga """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,lit_Latn,python,"

def modp(n: int, p: int):
    """"""Grąžinkite 2^n modulo p (atsiminkite skaičių). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,lit_Latn,python,"

def encode_shift(s: str):
    """"""                                                       """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""grąžina užkoduotą eilutę, kiekvieną raidę alfabete perkeldama 5 punktu.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,lit_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels yra funkcija, kuri imasi eilės ir grąžina eilę be vokalų. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,lit_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Grąžina True, jei visi l sąrašo skaičiai yra žemiau ribos t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,lit_Latn,python,"

def add(x: int, y: int):
    """"""Pridėti du skaičius x ir y >>> pridėti ((2, 3) 5 >>> pridėti ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,lit_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Patikrinkite, ar du žodžiai turi vienodus ženklus. >>> same_chars('eabcdzzzz', 'dddzzzzzzdeddabc') Tinka >>> same_chars('abcd', 'dddddddddabc') Tinka >>> same_chars('dddddddabc', 'abcd') Tinka >>> same_chars('eabcd', 'dddddddddabc') Neteisinga >>> same_chars('abcd', 'dddddddabc') Neteisinga >>> same_chars'(abcdzzzz', 'dddzzzzzzdddabc') Neteisinga """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,lit_Latn,python,"

def fib(n: int):
    """"""Grąžina n-ąjį Fibonaččio skaičių. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,lit_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets yra ""<"" ir "">"" eilutė. grąžina True, jei kiekviena atidaroma bracket turi atitinkamą uždarymo bracket. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,lit_Latn,python,"

def monotonic(l: list):
    """"""Grąžinti True yra sąrašas elementai monotoniškai didėja arba mažėja. >>> monotoniškas (([1, 2, 4, 20]) True >>> monotoniškas (([1, 20, 4, 10]) False >>> monotoniškas (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,lit_Latn,python,"

def common(l1: list, l2: list):
    """"""Grąžina surūšiuotus unikalius bendrus elementus dviem sąrašams. >>> bendras (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> bendras (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,lit_Latn,python,"

def largest_prime_factor(n: int):
    """"""Grąžinkite didžiausią n pirminį veiksnį. Tarkime, kad n > 1 ir nėra pirminis. >>> didžiausia_pirminė_dalelė ((13195) 29 >>> didžiausia_pirminė_dalelė ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,lit_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n yra funkcija, sudaranti skaičių sumą nuo 1 iki n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,lit_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets yra eilutė ""("" ir "")"". grąžina True, jei kiekviena atidaroma bracket turi atitinkamą uždarymo bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,lit_Latn,python,"

def derivative(xs: list):
    """"""xs - polinomo koeficientai. xs[0] + xs[1] * x + xs[2] * x^2 + .... Grąžina polinomo išvestinę iš tos pačios formos. >>> išvestinė (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> išvestinė (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,lit_Latn,python,"

def fibfib(n: int):
    """"""FibFib skaičių seka yra Fibbonacci eilės, kuri yra apibrėžta taip: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Rašykite funkciją, kuri efektyviai apskaičiuotų n-ąjį fibfib skaičių eilės elementą. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,lit_Latn,python,"
FIX = """"""Rašykite funkciją vowels_count, kuri imasi žodžio eilutės ir grąžina eilutėje esančių vokalų skaičių. Šioje eilutėje vokalai yra a, e, i, o, u. Čia ""y"" taip pat yra vokalas, bet tik tada, kai jis yra nurodyto žodžio gale. Pavyzdys: >>> vowels_count (\""abcde"") 2 >>> vowels_count (\""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Pridėti daugiau bandomųjų atvejų. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,lit_Latn,python,"
def circular_shift(x, shift):
    """"""Apskritoji perkelta x skaičių skaitmenų, perkelta skaitmenų į dešinę perkelti ir grąžinti rezultatas kaip eilutė. Jei perkelti > skaičių skaitmenų, grąžinti skaitmenų atvirkščiai. >>> cirkulinis_perkelti""""""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,lit_Latn,python,"
def digitSum(s):
    """"""Užduotis Rašyti funkciją, kuri imasi eilutės kaip įvesties ir grąžina tik viršutinių simbolių sumą' ASCII kodai. Pavyzdžiai: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,lit_Latn,python,"
def fruit_distribution(s,n):
    """"""Šiame užduotyje jums bus pateikta eilutė, kuri atspindi obuolių ir apelsinų skaičių, kurie yra paskirstyti vaisių krepšyje, kurioje yra obuolių, apelsinų ir mango vaisių. Duota eilutė, kuri atspindi bendrą apelsinų ir obuolių skaičių ir visą skaičių, kuris atspindi bendrą vaisių skaičių krepšyje, grąžinkite mangų vaisių skaičių krepšyje. Pavyzdžiui: fruit_distribution""5( obuolių ir 6 apelsinų"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 obuolių ir 1 apelsinų"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 obuolių ir 3 apelsinų"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 obuolių ir 1 apelsinų"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,lit_Latn,python,"
def pluck(arr):
    """"""""Dėl matrico, kuris yra medžio šaka, kurioje yra ne neigiamų skaičių mazgų, jūsų užduotis yra ištraukti vieną iš mazgų ir grąžinti jį. Ištrauktas mazgas turėtų būti mazgas su mažiausia net reikšme. Jei yra daug mazgų su ta pačia mažiausia net reikšme, grąžinkite mazgą, turinčią mažiausią indeksą. Ištrauktas mazgas turėtų būti grąžintas sąraše, [smallest_value, jo indeksas] , Jei nėra net verčių arba nurodytas matris tuščias, grąžinkite []. Pavyzdys: 1: Įėjimas: [4,2,3] Išėjimas: [2, 1] paaiškinimas: 2 turi mažiausią net reikšmę, o 2 turi mažiausią indeksą. Pavyzdys: Įėjimas: [1,2,3] Išėjimas: [2, 1] paaiškinimas: 2 turi mažiausią net reikšmę, o 2 turi mažiausią net reikšmę. Pavyzdys 3: Įėjimas: [] Išėjimas: [] Pavyzdys: [4: 5, 3, 4, 2] Išėjimas: [0, 0] Išėjimas: 1 mazgas, turinčias mažiausią indeksą, tačiau yra du nuoliai.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,lit_Latn,python,"
def search(lst):
    '''Jei nėra tokios vertės, grąžinkite -1. Pvz.: paieškos ([4, 1, 2, 2, 3, 1]) == 2 paieškos ([1, 2, 2, 3, 3, 4, 4]) == 3 paieškos ([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,lit_Latn,python,"
def strange_sort_list(lst):
    '''Jei pateikiamas sveiki skaičiai, jie grąžinami neaiškios tvarkos. Neaiškios rūšys yra tada, kai pradedate nuo mažiausios vertės, tada iki likusių sveikių verčių maksimumo, tada iki mažiausios ir t. t.'''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,lit_Latn,python,"
def triangle_area(a, b, c):
    '''Duotas trijų trikampio šonų ilgis. Grąžina trikampio plotas suapvalintas iki 2 dešimtainės vietos, jei trys šonės sudaro tinkamą trikampio. Priešingu atveju grąžina -1 Trys šonės sudaro tinkamą trikampio, kai bet kurių dviejų šonų suma yra didesnė už trečią šoną. Pavyzdys: trikampio_plotas ((3, 4, 5) == 6.00 trikampio_plotas ((1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,lit_Latn,python,"
def will_it_fly(q,w):
    '''Rašykite funkciją, kuri grąžina True, jei objektas q skris, ir False, jei ne. Objektas q skris, jei jis yra subalansuotas (tai yra palindrominis sąrašas) ir jo elementų suma yra mažesnė nei arba lygi didžiausiam galimam svoriui w. Pavyzdys: will_it_fly (([1, 2], 5) â -> False # 1+2 yra mažesnė nei didžiausia įmanoma masė, bet ji yra nesubalansuota. will_it_fly (([3, 2, 3], 1) â -> False # jis yra subalansuotas, bet 3+2+3 yra didesnis nei didžiausia įmanoma masė. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 yra mažesnis nei didžiausia įmanoma masė ir jis yra subalansuotas. will_it_fly ((([3], â 5) -> True # 3 yra mažesnis nei didžiausia įmanoma masė ir jis yra subalansuotas. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,lit_Latn,python,"
def smallest_change(arr):
    """"""Jei matrica yra iš viso skaičių, nustatykite mažiausią elementų skaičių, kuriuos reikia pakeisti, kad matrica būtų palindrominė. Palindrominė matrica yra matrica, kuri skaityta taip pat atgal ir į priekį. Viename pokyboje galite pakeisti vieną elementą į bet kurį kitą elementą. Pavyzdžiui: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,lit_Latn,python,"
def total_match(lst1, lst2):
    '''Rašykite funkciją, kuri priima du eilutės sąrašus ir grąžina sąrašą, kurio visų eilutės eilutės eilutės yra mažesnės nei kitos. Jei abiejų sąrašų eilutės yra tokios pačios, grąžinkite pirmąjį sąrašą. Pavyzdžiai total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi]) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'], ['5']) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,lit_Latn,python,"
def is_multiply_prime(a):
    """"""Rašykite funkciją, kuri grąžina teisingą, jei nurodytas skaičius yra 3 pirminių skaičių padauginimas, o kitaip - klaidingas.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,lit_Latn,python,"
def is_simple_power(x, n):
    """"""Jūsų užduotis yra parašyti funkciją, kuri grąžina teisingą, jei skaičius x yra paprastas n laipsnis, o kitose atvejais - klaidingas. x yra paprastas n laipsnis, jei n**int=x Pavyzdžiui: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,lit_Latn,python,"
def iscube(a):
    '''Rašykite funkciją, kuri imasi iš viso skaičiaus a ir grąžina reikšmę True, jei šis skaičius yra tam tikro viso skaičiaus kubas. Pastaba: galite manyti, kad įvesties reikšmė visada galioja.'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,lit_Latn,python,"
def hex_key(num):
    """"""Jums buvo pavesta parašyti funkciją, kuri gauna šešioliktapišdinį skaičių kaip eilutę ir skaičiuoja šešioliktapišdinį skaičių, kuris yra pirminio skaičiaus (pirminis skaičius yra natūralus skaičius, didesnis nei 1, kuris nėra dviejų mažesnių natūralų skaičių produktas). Šešioliktapišdiniai skaitmenys yra 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Pirminiai skaičiai yra 2, 3, 5, 7, 11, 13, 17,... Taigi jūs turite nustatyti šiuos skaitmenų skaičius: 2, 3, 5, 7, B (= dešimtapišdinis 11), D (= dešimtapišdinis 13). Pastaba: galite manyti, kad įvesties skaičius visada teisingas arba tuščias eilutė, o simboliai A, B, C, D, E, F visada yra didžiosios raidės. Pavyzdžiai: num = AB, išvesties skaičius turėtų būti num = 1. num = 1077E, išvesties skaičius turėtų būti 2. num = AB33ED1 num = 4.BCD = 6.0128945 A, num = 6.067D.""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,lit_Latn,python,"
def decimal_to_binary(decimal):
    """"""Jums bus pateiktas skaičius dešimtainės formos ir jūsų užduotis yra konvertuoti jį į dvejetainį formatą. Funkcija turėtų grąžinti eilutę, kurioje kiekvienas ženklas atstovauja dvejetainį skaičių. Kiekvienas ženklas eilutėje bus ""0"" arba ""1"". Yra papildoma pora simbolių ""db"" eilutės pradžioje ir pabaigoje. Papildomi simboliai yra ten, kad padėtų su formatu. Pvz.: decimal_to_binary(15) # grąžina ""db1111db"" decimal_to_binary32) # grąžina ""db100000db"" """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,lit_Latn,python,"
def is_happy(s):
    """"""Jums yra pateikta eilutė s. Jūsų užduotis yra patikrinti, ar eilutė yra laiminga, ar ne. eilutė yra laiminga, jei jos ilgis yra bent 3 ir kiekviena iš 3 eilės raidės yra skirtingos. Pavyzdžiui: is_happy (a) => False is_happy (a) => False is_happy (b) => True is_happy (a) => False is_happy (b) => True is_happy (c) => False is_happy (d) => False is_happy (e) => False is_happy (f) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,lit_Latn,python,"
def numerical_letter_grade(grades):
    """"""Tai yra paskutinė semestro savaitė ir mokytoja turi duoti studentams įvertinimus. Mokytoja sukūrė savo įvertinimo algoritmą. Vienintelė problema yra tai, kad ji prarado kodą, kurį naudojo įvertinimui. Ji davė jums kai kurių studentų GPA sąrašą, ir jūs turite parašyti funkciją, kuri gali pateikti raidės įvertinimų sąrašą, naudodamiesi šia lentelė: GPA. Raidės įvertinimas 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E pavyzdys: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,lit_Latn,python,"
def prime_length(string):
    """"""Rašykite funkciją, kuri imasi eilutės ir grąžina True, jei eilutės ilgis yra pirminis skaičius arba False, jei ne. Primena: prime_length (primasis) == True prime_length (primasis) == abcdcba (primasis) == True prime_length (primasis) == True prime_length (primasis) == false """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,lit_Latn,python,"
def starts_one_ends(n):
    """"""Duotas teigiamasis skaičius n, grąžina n skaitmenų teigiamų skaičių, kurie prasideda ar baigiasi 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,lit_Latn,python,"
def solve(N):
    """"""Jei N = 1000, skaitmenų suma bus 1, išvestinė vertė turėtų būti ""1"". Jei N = 150, skaitmenų suma bus 6, išvestinė vertė turėtų būti ""110"". Jei N = 147, skaitmenų suma bus 12, išvestinė vertė turėtų būti ""1100"". Kintamieji: @N skaičius apribojimai: 0 â‰¤ N â‰¤ 10000. Išvestinė vertė: dvejetainių skaičių eilutė """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,lit_Latn,python,"
def add(lst):
    """"""Duotas ne tuščias sveikių skaičių sąrašas lst. pridėti net elementus, kurie yra nevienalytėse indeksų.""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,lit_Latn,python,"
def anti_shuffle(s):
    """"""Rašykite funkciją, kuri imasi eilutės ir grąžina jos tvarkytą versiją. Skirto eilutės versija yra eilutė, kurioje visi žodžiai (skirtos tarpiniu) pakeičiami nauju žodžiu, kuriame visi simboliai išdėstyti didėjančia tvarka pagal ascii vertę. Pastaba: Turėtumėte išlaikyti žodžių ir tuščių erdvių tvarką sakinyje. Pavyzdžiui: anti_shuffle ((('Hi') grąžina ""Hi"" anti_shuffle ((('hello') grąžina ""ehllo"" anti_shuffle (('Hello World!!!') grąžina ""Hello !!!Wdlor"" """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,lit_Latn,python,"
def get_row(lst, x):
    """"""Duotas 2 matmenų duomenų, kaip įklotieji sąrašai, kurie yra panašūs į matricą, tačiau, skirtingai nuo matricų, kiekviena eilutė gali turėti skirtingą skaičių stulpelių. Duotas lst ir sveikas x, raskite sveikus x sąraše ir grąžinkite tuplių sąrašą, [(x1, y1), (x2, y2) ...] taip, kad kiekvienas tuple yra koordinatė - ( eilutė, stulpelės), pradedant nuo 0. Iš pradžių suderinkite koordinates eilutėmis kylančia tvarka. Taip pat, suderinkite eilutės koordinates stulpelėmis mažėjančia tvarka. Pavyzdžiai: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (2, 5), (2, 0), get_(1), [] == [0, 1, 2, 3, 2], [] == [2, 3] """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,lit_Latn,python,"
def sort_array(array):
    """"""Jei matrica yra ne neigiami sveiki skaičiai, po rūšiavimo grąžinkite jos kopiją. Jei suma (pirmoji indeksinė vertė, paskutinė indeksinė vertė) yra netolygus, rūšiuokite matricą didėjančia tvarka, o jei suma (pirmoji indeksinė vertė, paskutinė indeksinė vertė) yra pora, rūšiuokite ją mažėjančia tvarka.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,lit_Latn,python,"
def encrypt(s):
    """"""Sukurkite funkciją encrypt, kuri imasi eilutės kaip argumento ir grąžina eilutę, užšifruotą sukant abėcėlę. Abėcėlę reikia sukti taip, kad raidės nukryptų iki dviejų kartų iki dviejų vietų. Pavyzdžiui: encrypt('hi') grąžina 'lm' encrypt('asdfghjkl') grąžina 'ewhjklnop' encrypt('gf') grąžina 'kj' encrypt('et') grąžina 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,lit_Latn,python,"
def next_smallest(lst):
    """"""Jums pateikiamas sveiki skaičiai. Rašykite funkciją next_smallest ((), kuri grąžina antrąjį mažiausią elementą sąraše. Grąžina Nė vienas, jei tokio elemento nėra. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Nė vienas next_smallest (([1, 1]) == Nė vienas """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,lit_Latn,python,"
def is_bored(S):
    """"""Jums bus pateikta žodžių eilutė, ir jūsų užduotis yra suskaičiuoti nuobodulio skaičių. Nuobodulys yra sakinys, kuris prasideda žodžiu ""I"". Padariai yra apriboti """"., ""?"" arba ""! "". Pavyzdžiui: >>> yra_nuobodulys (sveiki pasauliai) 0 >>> yra_nuobodulys (sveiki pasauliai) 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,lit_Latn,python,"
def any_int(x, y, z):
    '''Sukurkite funkciją, kuri imasi 3 skaičių. Grąžina teisingą, jei vienas iš skaičių yra lygus kitų dviejų sumos, o visi skaičiai yra sveiki skaičiai. Grąžina klaidą bet kuriais kitais atvejais.'''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,lit_Latn,python,"
def encode(message):
    """"""Rašykite funkciją, kuri imasi pranešimo ir užkoduoja taip, kad ji pakeistų visų raidžių pagrindinius raidžius, pakeistų visus žodinius vokalus pranešime raidėmis, kurios yra 2 vietas prieš tą žodinį vokalą anglų alfabete.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,lit_Latn,python,"

def skjkasdkd(lst):
    """"""Jums pateikiamas sveiki skaičiai. Jums reikia rasti didžiausią pirmąją vertę ir grąžinti jos skaitmenų sumą. Pvz.: Jei lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] išvestis skaičius turėtų būti 10 Jei lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] išvestis skaičius turėtų būti 25 Jei lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] išvestis skaičius turėtų būti 13 Jei lst = [0,724,32,71,99,32,6,0,91,83,0,5,6] išvestis skaičius turėtų būti 11 Jei lst = [0,81,12,31,21] išvestis skaičius turėtų būti 3 Jei lst = [1,8,1,2,1,7] išvestis skaičius turėtų būti """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,lit_Latn,python,"
def check_dict_case(dict):
    """"""Jei žodyne yra raktų eilutės mažomis raidėmis arba visos raktai yra eilutės didesnėmis raidėmis, funkcija grąžina True, jei visos raktai yra mažomis raidėmis arba visos raktos yra stygos didesnėmis raidėmis, kitaip grąžina False. Funkcija turėtų grąžinti False, jei nurodytas žodyne yra tuščias. Pavyzdžiai: check_dict_case{""a"":""apelė"", ""b"":""banana""}) turėtų grąžinti True. check_dict_case{""a"":""apelė"", ""A"":""banana"", ""B"":""banana""}) turėtų grąžinti False. check_dict_case{""a"":""apelė"", 8:""banana"", ""a"":""apelė""}) turėtų grąžinti False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) turėtų grąžinti False. Check_dict_case{""NC:""STATE"", ""Z"":""IP""12345}) turėtų grąžinti True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,lit_Latn,python,"
def count_up_to(n):
    """"""Įgyvendinti funkciją, kuri imasi ne neigiamo sveiko skaičiaus ir grąžina pirmųjų n sveiko skaičiaus, kurie yra pirmieji skaičiai ir mažesni nei n, matrizą. Pavyzdžiui: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,lit_Latn,python,"
def multiply(a, b):
    """"""Įrašyti funkciją, kuri imasi dviejų skaičių ir grąžina jų vienetų skaičių išvestį. Įsivaizduokime, kad įvedimas visada galioja. Pavyzdžiai: dauginimas ((148, 412) turėtų grąžinti 16, dauginimas ((19, 28) turėtų grąžinti 72. dauginimas ((2020, 1851) turėtų grąžinti 0, dauginimas ((14,-15) turėtų grąžinti 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,lit_Latn,python,"
def count_upper(s):
    """"""S eilutėje skaičiuokite didžiųjų vokalų skaičių iš vienodų indeksų. Pavyzdžiui: count_upper (('aBCdEf') grąžina 1 count_upper (('abcdefg') grąžina 0 count_upper (('dBBE') grąžina 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,lit_Latn,python,"
def closest_integer(value):
    '''Sukurkite funkciją, kuri imasi reikšmės (sajos), kuri atspindi skaičių ir grąžina artimiausią tolygą skaičių. Jei skaičius yra tolygiai nutolęs nuo dviejų skaičių, suapvalinkite jį nuo nulio. Pvz. >>> artimiausias_talis skaičius ((""10"") 10 >>> artimiausias_talis skaičius ((""15.3"") 15 Pastaba: Apvalinimas nuo nulio reiškia, kad jei duotas skaičius yra tolygiai nutolęs nuo dviejų skaičių, tai turėtumėte grąžinti tą, kuris yra tolimiausias nuo nulio. Pavyzdys: artimiausias_talis skaičius ((""14.5"") turėtų grąžinti 15, o artimiausias_talis skaičius ((-14.5"") turėtų grąžinti -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,lit_Latn,python,"
def make_a_pile(n):
    """"""Jei yra teigiamasis skaičius n, reikia padaryti n lygių akmenų krūvą. Pirmasis lygis turi n akmenų. Kitas akmenų skaičius yra: - kitas netolygus skaičius, jei n yra netolygus. - kitas netolygus skaičius, jei n yra pora. Grąžinkite kiekvieno lygio akmenų skaičių sąraše, kur elementas indekse i reiškia akmenų skaičių lygyje (i + 1).""""""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,lit_Latn,python,"
def words_string(s):
    """"""Jums bus pateikta eilutė žodžių, atskirtų virpliais ar tarpomis. Jūsų užduotis yra padalinti eilutę į žodžius ir grąžinti eilutę žodžių. Pavyzdžiui: words_string ((""Sveiki, mano vardas John"") == [""Sveiki"", ""mano"", ""vardas"", ""yra"", ""John""] words_string ((""Vienas, du, trys, keturi, penki, šeši"") == [""Vienas"", ""du"", ""trys"", ""keturi"", ""penki"", ""šeši""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,lit_Latn,python,"
def choose_num(x, y):
    """"""Ši funkcija imasi dviejų teigiamų skaičių x ir y ir grąžina didžiausią net ir skaičių, kuris yra intervale [x, y] įskaitant. Jei tokio skaičiaus nėra, tada funkcija turėtų grąžinti -1. Pavyzdžiui: choose_num(12, 15) = 14 choose_num(13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,lit_Latn,python,"
def rounded_avg(n, m):
    """"""Jei n yra didesnis nei m, grąžinkite -1. Pvz.: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b1111"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,lit_Latn,python,"
def unique_digits(x):
    """"""Jei pateikiamas teigiamų skaičių sąrašas x, grąžina visus elementus, kuriuose nėra porainių skaitmenų, surūšiuotą sąrašą. Pastaba: Grąžintas sąrašas turi būti surūšiuotas didėjančia tvarka. Pavyzdžiui: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,lit_Latn,python,"
def by_length(arr):
    """"""Duotas visinių skaičių matris, sureguliuoti visinius skaičius, kurie yra tarp 1 ir 9 įskaitant, pakeisti rezultatyvaus matrico, ir tada pakeisti kiekvieną skaitmenį atitinkamu pavadinimu iš ""Vienas"", ""Du"", ""Trys"", ""Keturi"", ""Penki"", ""Šeši"", ""Septyni"", ""Aštunt"", ""Devyni"". Pavyzdžiui: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sureguliauti arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> atvirkštinis arr -> [8, 5, 4, 3, 2, 2, 1, 1] grąžinti [""Aštunt"", ""Keturi"", ""Trys"", ""Du"", ""Du"", ""Vienas"", ""Vienas""] Jei matris yra tuščias, grąžinti: arr = [] grąžinti matris [] Jei matris turi bet kokį keistą numerį ignoruoti: arr = [1, 1 , 1 - 1 , 55] -> arr -> [1, 1 , 1 - 55] -> atvirkštinis arr = [51] - ['One' 1] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,lit_Latn,python,"
def f(n):
    """"""Įgyvendinkite funkciją f, kuri imasi n kaip parametro ir grąžina n dydžio sąrašą, kad i indekso elementas būtų i faktorialus, jei i yra pora arba 1 iki i skaičių suma. i prasideda nuo 1. i faktorialas yra skaičių iš 1 iki i padauginimas (1 * 2 * ... * i).""""""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,lit_Latn,python,"
def even_odd_palindrome(n):
    """"""Jei yra teigiamasis skaičius n, grąžinkite tuplą, kuriame yra pora ir netolygiai sveiki palindromai, kurie patenka į intervalą ((1, n), įskaitant. Pavyzdys1: Įvesties: 3 Išvesties: (1, 2) Išaiškinimas: Tolis palindromas yra 1, 2, 3. Vienas iš jų yra pora, o du iš jų yra netolygiai. Pavyzdys2: Įvesties: 12 Išvesties: (4, 6) Išaiškinimas: Tolis palindromas yra 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. keturi iš jų yra pora, o 6 iš jų yra netolygiai. Pastaba: 1. 1 <= n <= 10^3 2. tuplė grąžino atitinkamai pora ir netolygiai sveiki palindromai. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,lit_Latn,python,"
def count_nums(arr):
    """"""Rašykite funkciją count_nums, kuri imasi iš abiejų skaičių ir grąžina elementų skaičių, kurio skaitmenų suma yra > 0. Jei skaičius yra neigiamas, tada jo pirmasis pasirašytas skaitmenys bus neigiamas: pvz. -123 turi pasirašytus skaitmenis -1, 2, ir 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,lit_Latn,python,"
def move_one_ball(arr):
    """"""Mes turime matrizą 'arr' iš N skaičių arr[1], arr[2], ..., arr[N].Matrizės skaičiai bus atsitiktinai surengti. Jūsų užduotis yra nustatyti, ar įmanoma gauti matrizę sureguliuotą ne mažėjančia tvarka atlikdami šią operaciją ant nustatyto matrizės: Jums leidžiama atlikti dešiniosios poslinkės operaciją bet kiek kartų. Viena dešiniosios poslinkės operacija reiškia, kad visi matrizės elementai bus perkelti viena pozicija dešiniąja kryptimi. Paskutinis matrizės elementas bus perkeltas į pradinę poziciją matrizėje, t. y. 0-asis indeksas. Jei galima gauti sureguotą matrizę atlikdami pirmiau nurodytą operaciją, tada grąžinkite True, kitaip grąžinkite False. Jei pateiktas matrizė yra tuščia, tada grąžinkite True. Pastaba: Įrašytas sąrašas garantuojamas, kad turi unikalius elementus. Pavyzdžiui: move_one_{(ball_[3, 4, 5, 2]""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,lit_Latn,python,"
def exchange(lst1, lst2):
    """"""Šioje problemai jūs įgyvendinsite funkciją, kuri imasi dviejų skaičių sąrašų ir nustato, ar įmanoma atlikti elementų keitimą tarp jų, kad lst1 būtų tik porainių skaičių sąrašas. Lst1 ir lst2 elementų keitimo skaičiui nėra apribojimo. Jei galima keistis elementais tarp lst1 ir lst2, kad visi lst1 elementai būtų porainiai, grąžinkite ""YES"". Priešingu atveju grąžinkite ""NO"". Pavyzdžiui: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Manoma, kad įvesties sąrašai bus ne tušti. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,lit_Latn,python,"
def histogram(test):
    """"""Jei eilutė yra mažųjų raidžių eilutė, grąžinkite žodyną, kuriame yra daugiausiai pasikartojančių raidžių ir atitinkamas skaičius. Jei kelios raidės yra tokios pačios, grąžinkite visas. Pavyzdys: histograma:""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,lit_Latn,python,"
def reverse_delete(s,c):
    """"""Užduotis Duota dvi eilutės s ir c, reikia ištrinti visus s raidės, kurie yra lygūs bet kuriam c raidės simbolio, tada patikrinti, ar rezultatas eilutė yra palindromas. eilutė yra vadinamas palindromas, jei ji skaito taip pat atgal kaip į priekį. Jūs turėtumėte grąžinti tuple, turintis rezultato eilutę ir True/False patikrinimui. Pavyzdžiui, s = ""abcde"", c = ""ae"", rezultatas turėtų būti ('bcd', False) s = ""abcdef"", c = ""b"" rezultatas turėtų būti ('acdef', False) s = ""abcdedcba"", c = ""ab"", rezultatas turėtų būti ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,lit_Latn,python,"
def odd_count(lst):
    """"""Jei pateikiamas eilutės sąrašas, kuriame kiekviena eilutė yra tik skaitmenys, grąžinkite sąrašą. Kiekvienas išėjimo elementas i turėtų būti ""nepavienų elementų skaičius įvesties eilutėje i"". kur visi i turėtų būti pakeičiami nevienų skaitmenų skaičiumi įvesties eilutėje i. >>> nevienų elementų skaičius 4n 4n str4ng. "">"" nevienų elementų skaičius ['3', ""11111111""]) [""nevienų elementų skaičius 1n 1n str1ng 1n. "", ""nevienų elementų skaičius 8n 8n 8n str8ng 8n. ""]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,lit_Latn,python,"
def minSubArraySum(nums):
    """"""Duotas visųjų skaičių n matrica, raskite mažiausią bet kurio ne tušo submatrico skaičių sumą.""""""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,lit_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Jūsų užduotis yra ištuštinti šulinius. Įveskite kiek kartų reikia išleisti šulinius. Pvz.: 1: Įvesties: šulinis: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] šulinio_įtvermė: 1 Išvesties: 62: Įvesties: šulinis: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] šulinio_įtvermė: 2 Išvesties: 53: Įvesties: [[0,0,0], [0,0,0]] šulinio_įtvermė: 5 * 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 3 * 4 * 5 * 6 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,lit_Latn,python,"
def sort_array(arr):
    """"""Šiame Kata, jūs turite surasti ne neigiamų skaičių matricą pagal jų dvejetainio vaizduotės vienetų skaičių augančia tvarka. Dėl panašaus vienetų skaičiaus, surasti pagal dešimtainę vertę. Tai turi būti įgyvendinta taip: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,lit_Latn,python,"
def select_words(s, n):
    """"""Jei eilutė yra tuščia, funkcija turi grąžinti tuščią sąrašą. Pastaba: galite manyti, kad įvesties eilutėje yra tik raidės ir tarpsniai. Pavyzdžiai: select_words (žodis) ""Mary turėjo mažą avis"", 4) ==> [""mažas""] select_words (žodis) ""Mary turėjo mažą avis"", 3) ==> [""Mary"", ""avelis""] select_words (žodis) ""paprasta balta erdvė"", 2) ==> [] select_words (žodis) ""Sveiki, pasaulis"", 4) ==> [""pasaulis""] select_words (žodis) ""Senelis Sam"", 3) ==> [""Senelis""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,lit_Latn,python,"
def get_closest_vowel(word):
    """"""Jums yra duotas žodis. Jūsų užduotis yra rasti artimiausią vokalą, kuris yra tarp dviejų suartinių iš dešinės pusės žodžio (sąskaitų jautrumas). Vokalai pradžioje ir pabaigoje neskaičiuojami. Grąžinkite tuščią eilutę, jei neradote jokio vokalo, atitinkančio pirmiau pateiktą sąlygą. Galite manyti, kad minėta eilutė yra tik anglų raidė. Pavyzdys: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,lit_Latn,python,"
def match_parens(lst):
    '''Jums pateikiamas dviejų eilutės sąrašas, abi eilutės yra tik atvirų sulankstytųjų '(' arba uždarytų sulankstytųjų ') '. Jūsų darbas yra patikrinti, ar įmanoma sujungti dvi eilutės tam tikra tvarka, kad gauta eilutė būtų gera. eilutė S laikoma gera, jei ir tik jei visos juostelės S yra subalansuotos. Pavyzdžiui: eilutė '((()) ' yra gera, o eilutė '()) ' nėra. Grąžinkite ""Taip"", jei yra būdas sukurti gerą eilutę, ir grąžinkite ""Ne"", kitaip.'''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,lit_Latn,python,"
def maximum(arr, k):
    """"""Duotasis eilės Arr iš sveikių skaičių ir teigiamo sveiko skaičiaus k, grąžina surūšiuotą eilės ilgį k su didžiausiais k skaičiais arr. Pavyzdys1: Įvesties: arr = [-3, -4, 5], k = 3 Išvesties: [-4, -3, 5] Pavyzdys2: Įvesties: arr = [4, -4, 4], k = 2 Išvesties: [4, 4] Pavyzdys3: Įvesties: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Išvesties: [2] Pastaba: 1.""""""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,lit_Latn,python,"
def solution(lst):
    """"""Duotas ne tuščias sveikiųjų skaičių sąrašas, grąžina visų netolygų elementų, kurie yra net ir pozicijose, sumą.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,lit_Latn,python,"
def add_elements(arr, k):
    """"""Duotas ne tuščias visumų Arr ir k visumų juostos, grąžinkite elementų, kurių suma yra ne daugiau kaip du skaitmenys iš pirmųjų k elementų Arr, sumą. Pavyzdys: Įvesties: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Išvesties: 24 # sumos 21 + 3 Skirstys: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,lit_Latn,python,"
def get_odd_collatz(n):
    """"""Kolcazo spėju yra matematinė spėju, susijusi su eilutėmis, kurios yra apibrėžtos taip: pradėkite bet kokiu teigiamu skaičiumi n. Tada kiekvienas terminas gaunamas iš ankstesnio termino taip: jei ankstesnis terminas yra pora, kitas terminas yra pusė ankstesnio termino. Jei ankstesnis terminas yra netikslus, kitas terminas yra 3 kartus ankstesnio termino plius 1. Spėju yra tai, kad nesvarbu, kokia n vertė, eilutė visada pasieks 1. Pastaba: 1. Colcazo (n) yra [1] 2. Grąžintas sąrašas, sureguliuotas didėjančia tvarka. Pavyzdžiui: get_odd_colcazo (n) grąžina [1, 5] # Kolcazo eilutė 5 yra [5, 8, 16, 4, 2, 1], taigi netikslūs skaičiai yra tik 1 ir 5.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,lit_Latn,python,"
def valid_date(date):
    """"""Jūs turite parašyti funkciją, kuri patvirtina tam tikrą datos eilutę ir grąžina TIKRĄ, jei data yra teisinga, kitaip - NETIKRA. Data yra teisinga, jei įvykdytos visos šios taisyklės: 1. Datos eilutė nėra tuščia. 2. Dienos skaičius yra ne mažesnis kaip 1 arba didesnis nei 31 diena 1,3,5,7,8,10,12 mėnesiais, o dienų skaičius yra ne mažesnis kaip 1 arba didesnis nei 30 dienų 4,6,9,11 mėnesiais, o dienų skaičius yra ne mažesnis kaip 1 arba didesnis nei 29 mėnesio 2. 3. Mėnesių skaičius neturėtų būti mažesnis nei 1 arba didesnis nei 12. 4. Data turėtų būti tokio formato: mm-dd-yyyy, pvz.: valid_date (parduotas)""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,lit_Latn,python,"
def split_words(txt):
    '''Jei nėra žodžių eilės, grąžinkite žodžių sąrašą, padalintą ant tarpų, jei teksto nėra, turite padalinti ant viršelių, jei nėra viršelių, turite grąžinti mažųjų raidžių skaičių, kurių eilė yra keista alfabete, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 Pavyzdžiai: split_words (labai pasaulis!) â -> [""Labai pasaulis!""] split_words (labai pasaulis!"") â -> [""Labai pasaulis!""] split_words (labai pasaulis!"") â -> [""Labai pasaulis!""]'''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,lit_Latn,python,"
def is_sorted(lst):
    '''Jei pateikiamas skaičius, grąžinkite, ar jie yra sureguliuoti didėjančia tvarka. Jei sąraše yra daugiau nei 1 to paties skaičiaus kopija, grąžinkite False. Nereikia daryti prielaidų, kad yra neigiami skaičiai, o tik sveiki skaičiai.'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,lit_Latn,python,"
def intersection(interval1, interval2):
    """"""Jūsų užduotis yra nustatyti, ar šių dviejų intervalų sankirtos ilgis yra pirminis skaičius. Pavyzdžiui, šių dviejų intervalų sankirtos (1, 3), (2, 4) yra (2, 3), kurios ilgis yra 1, o tai nėra pirminis skaičius. Jei sankirtos ilgis yra pirminis skaičius, grąžinkite ""TAIP"", kitaip grąžinkite ""NE"". Jei du intervalai nesusikirto, grąžinkite ""NE"". [input/output] pavyzdžiai: sankirtas (((1, 2), (2, 3) ==> ""sankirtis ((-1, 1), 4) ==> ""sankirtis (==> 0, ""NO"") ==> 5 ((1), 5 ((-3, ""YES"" - ""YES"") ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,lit_Latn,python,"
def prod_signs(arr):
    """"""Jums yra duotas eilė iš abiejų skaičių ir jums reikia grąžinti abiejų skaičių dydžių sumą, padaugintą iš kiekvieno skaičiaus ženklų skaičiaus, kuris yra eilės dalis, išvestų iš 1, -1 arba 0.""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,lit_Latn,python,"
def minPath(grid, k):
    """"""Jei matome tinklelį su N eilutėmis ir N stulpeliais (N >= 2) ir teigiamu k sveiku skaičiumi, kiekvieno tinklelio langelio reikšmė yra tokia. Kiekvienas sveikas skaičius [1, N * N] įtrauktinai yra rodomas tik vieną kartą tinklelio langeliuose. Jūs turite rasti mažiausią k ilgio tinklelio kelią. Galite pradėti nuo bet kurios ląstelės ir kiekviename žingsnyje galite pereiti prie bet kurios kaimyninės ląstelės, kitaip tariant, galite pereiti prie ląstelių, kurios turi bendrą kraštą su jūsų dabartine ląstelė. Atkreipkite dėmesį, kad k ilgio kelias reiškia, kad apsilankėte tiksliai k ląstelėse (ne būtinai skirtingose). Jūs NEGALITE išeiti iš tinklelio. Kelias A (k ilgio) laikoma mažesne nei kelio B (k ilgio), jei po užrašymo į eilės sąrašus, kuriuose yra reikšmės, kurios yra A ir B (vadinkime jas l_stA ir l_stB), l_stA yra mažesnė nei l_stB, kitaip tariant, yra mažesnė nei l_stB ilgio kelias tinklelio langeliuose. Galite pradėti nuo bet kurios ląstelės ir kiekviename žingsnyje galite pereiti į bet kokius, kuris iš jų turi bendrą kraštą su dabartiniu langeliu. [A = 1, k = k = k, k = k = k = k = 1, k = 1, k = 4, k = k = j_st_j, j_j = j_j = j_j, j_st_j = j_st_st_st_st_st] [1, [4, l_st_st_st] [1, l_st_st, l_st, l_st_i], [=1, l_i=1, l_i=1, l_i=1, l_i=[i], [_i=1, l_i=1, l_i=8, l_i=[i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i] [_i""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,lit_Latn,python,"
def tri(n):
    """"""Visi žino Fibonači seka, ji buvo giliai ištirtas matematikų per pastaruosius porą amžių. Tačiau, kas žmonės nežino yra Tribonači seka. Tribonači seka yra apibrėžta pagal pasikartojimo: tri(1) = 3 tri(n) = 1 + n / 2, jei n yra pora. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jei n yra keistas. Pavyzdžiui: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Jums yra ne neigiamas sveikas skaičius n, jums reikia grąžinti pirmųjų n + 1 Tribonači seka skaičių sąrašą.""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,lit_Latn,python,"
def digits(n):
    """"""Jei yra teigiamasis skaičius n, grąžinkite netolygų skaitmenų išvestį. Grąžinkite 0, jei visi skaitmenys yra pora. Pavyzdžiui: skaitmenys ((1) == 1 skaitmenys ((4) == 0 skaitmenys ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,lit_Latn,python,"
def is_nested(string):
    '''Sukurti funkciją, kuri imasi įvesties eilutės, kurioje yra tik kvadratinių riedmenų. Funkcija turėtų grąžinti True, jei ir tik jei yra galiojanti riedmenų eilutė, kurioje yra bent vienas riedmenys. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]] â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,lit_Latn,python,"

def sum_squares(lst):
    """"""Jums pateikiamas skaičių sąrašas. Jums reikia grąžinti duoto sąrašo skaičių kvadratų sumą, apvalinti kiekvieną sąrašo elementą iki viršutinio int ((plačiausia vertė) pirmiausia. Pavyzdžiai: lst = [1,2,3] išvestinė vertė turėtų būti 14 lst = [1,4,9] išvestinė vertė turėtų būti 98 lst = [1,3,5,7] išvestinė vertė turėtų būti 84 lst = [1.4,4.2,0] išvestinė vertė turėtų būti 29 lst = [-2.4,1,1] išvestinė vertė turėtų būti 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,lit_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Sukurti funkciją, kuri grąžina True, jei paskutinė eilutės raidė yra abėcėlės raidė ir nėra žodžio dalis, ir False, jei ne. Pastaba: ""žodis"" yra raidžių grupė, atskirta tarpiniu. Pavyzdžiai: check_if_last_char_is_a_letter ((""apelė pyrago"") â -> False check_if_last_char_is_a_letter ((""apelė pi e"") â -> True check_if_last_char_is_a_letter ((""apelė pi e"") â -> False check_if_last_char_is_a_letter"" ((("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,lit_Latn,python,"
def can_arrange(arr):
    """"""Sukurti funkciją, kuri grąžina didžiausią indekso elementą, kuris yra ne didesnis nei arba lygus elementui, kuris yra prieš jį. Jei toks elementas nėra, tada grąžinti -1. Duotas matricai nebus dubliuotų verčių. Pvz.: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,lit_Latn,python,"
def largest_smallest_integers(lst):
    '''Sukurkite funkciją, kuri grąžina tuplą (a, b), kur 'a' yra didžiausias neigiamasis visuma, o 'b' yra mažiausias teigiamasis visuma sąraše. Jei nėra neigiamų ar teigiamų visuma, grąžinkite juos kaip None. Pavyzdžiai: didžiausia_mažiausia_visuma[2, 4, 1, 3, 5, 7]) == (Nė viena, 1) didžiausia_mažiausia_visuma[[[]) == (Nė viena, Nė viena) didžiausia_mažiausia_visuma[[0]) == (Nė viena, Nė viena) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,lit_Latn,python,"
def compare_one(a, b):
    """"""Sukurti funkciją, kuri imasi iš skaičių, plūduriuojančių skaičių arba eilutės, atstovaujančių realaus skaičiaus, ir grąžina didesnį kintamąjį pagal jo nustatytą kintamojo tipą. Grąžina Nė vienas, jei reikšmės yra vienodos. Pastaba: Jei realus skaičius yra vaizduojamas kaip eilutė, plūduriuojančiojo taško gali būti . arba , palyginkite_vieną, 2.5) â -> 2.5 palyginkite_vieną, ""2,3"") â -> ""2,3"" palyginkite_vieną, ""5,1"", ""6"") â -> ""6"" palyginkite_vieną, ""1"", 1) â -> Nė vienas """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,lit_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Vertinkite, ar duotas skaičius n gali būti parašytas kaip 4 teigiamų porainių skaičių suma. Pavyzdys yra lygus su lygiomis sumomis (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras) (paras)) == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,lit_Latn,python,"
def special_factorial(n):
    """"""Brazilijos faktorialas apibrėžiamas taip: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! kur n > 0 Pavyzdžiui: >>> special_factorial ((4) 288 Funkcija imsis sveiko skaičiaus įvesties ir turėtų grąžinti šio sveiko skaičiaus specialų faktorialą. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,lit_Latn,python,"
def fix_spaces(text):
    """"""_Pvzydas-3tė yra, visus erdves pakeiskite žymiais, o jei eilutė turi daugiau nei 2 iš eilės esančias erdves, pakeiskite visas iš eilės esančias erdves - fix_spaces (((""Pvz.) "") == ""Pvz"". fix_spaces (((""Pvz.1"") == ""Pvz. 1"" fix_spaces (((""Pvz.2"") == ""_Pvz.2"") fix_spaces (((""Pvz.3"") == ""_Pvz.3"") ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,lit_Latn,python,"
def file_name_check(file_name):
    """"""Sukurti funkciją, kuri imasi eilutės, atstovaujančios failo vardą, ir grąžina ""Taip"", jei failo vardas yra teisingas, ir grąžina ""Ne"", jei ne. Failo vardas laikomas teisingu, jei ir tik jei įvykdytos visos šios sąlygos: - Failo varde neturėtų būti daugiau nei trys skaitmenys ('0'-'9'). - Failo varde turi būti tiksliai viena taškas '.' - Pora prieš tašką neturėtų būti tuščia, ir ji turi prasidėti latino abejonės raidėmis ('a'-'z' ir 'A'Z'). - Pora po taško turi būti viena iš šių: ['txt', 'exe', 'lld'] Pvz.: file_name_check""{example.txt.} # => 'Yes' file_name_check""{example.txt.} => 'Yes' (file_name_check""{example.txt.} #) => 'No' (vardas turėtų prasidėti latino abejonės raidėmis)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,lit_Latn,python,"


def sum_squares(lst):
    """""""" Ši funkcija imsis iš viso skaičių sąrašo. Visų sąrašo įrašų atveju funkcija kvadratuos visą skaičių įrašą, jei jo indekso koeficientas yra 3 daugiklis, ir padengs kubą iš viso skaičiaus įrašą, jei jo indekso koeficientas yra 4 daugiklis, o ne 3 daugiklis. Funkcija nepakeis sąrašo įrašų, kurių indeksai nėra 3 ar 4 daugiklis. Tada funkcija grąžins visų įrašų sumą. Pvz.: Jei lst = [1,2,3] išėjimas turėtų būti 6 Jei lst = [], išėjimas turėtų būti 0 Jei lst = [-1,-5,2,-1,-5], išėjimas turėtų būti -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,lit_Latn,python,"
def words_in_sentence(sentence):
    """"""Jums yra pateikta eilutė, kuri reprezentuoja sakinį, sakinyje yra keli žodžiai, atskirti tarpiniu, ir jūs turite grąžinti eilutę, kurioje yra žodžiai iš originalaus sakinio, kurių ilgis yra pirmieji skaičiai, žodžių eilutė naujame eilutėje turėtų būti tokia pati kaip ir originalioje. Pavyzdys1: Įvesties: sakinys = ""Tai yra testas"" Išvesties: ""is"" Pavyzdys2: Įvesties: sakinys = ""leiskite eiti plaukioti"" Išvesties: ""eikite"" Skirstymas: * 1 <= len(santence) <= 100 * sakinyje yra tik raidės """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,lit_Latn,python,"
def simplify(x, n):
    """"""Jūsų užduotis yra įgyvendinti funkciją, kuri supaprastins išraišką x * n. Funkcija grąžina True, jei x * n yra visuma, o kitaip False. Ir x, ir n yra dalelių eilutės, ir turi tokią formą, <skaityklė>/<vardiklis>, kur tiek skaitiklis, tiek vardiklis yra teigiami visi skaičiai. Galite manyti, kad x ir n yra teisingi daleliai, o vardiklis nėra nulinis. supaprastinti: ""1/5"", ""5/1"") = True (supaprastinti) ""1/6"", ""2/1"") = False (supaprastinti) ""7/10"", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,lit_Latn,python,"
def order_by_points(nums):
    """"""Rašykite funkciją, kuri surenka visą skaičių sąrašą didėjančia tvarka pagal jų skaitmenų sumą.""""""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,lit_Latn,python,"
def specialFilter(nums):
    """"""Rašykite funkciją, kuri imasi skaičių matrico kaip įvesties ir grąžina elementų skaičių matricoje, kurie yra didesni nei 10 ir tiek pirmasis, tiek paskutinis skaitmenys yra netolygūs (1, 3, 5, 7, 9). Pavyzdžiui: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,lit_Latn,python,"
def get_max_triples(n):
    """"""Jums yra duotas teigiamasis skaičius n. Jūs turite sukurti ilgį n turinčią skaičių matricą. Kiekvienai i (1 ‰¤ i ‰¤ n), a[i] = i * i - i + 1 vertė. Grąžinkite a, kur i < j < k, triguolių skaičių (a[i], a[j], a[k]), o a[i] + a[j] + a[k] yra 3 daugiklis.""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,lit_Latn,python,"
def bf(planet1, planet2):
    '''Mūsų Saulės sistemoje yra aštuonios planetos: artimiausia Saulės yra Merkurijus, kita - Venera, tada Žemė, Marsas, Jupiteris, Saturnas, Uranas, Neptunas. Rašykite funkciją, kuri imtų du planetų pavadinimus kaip planetų 1 ir planetų eilutes. Funkcija turėtų grąžinti tuplą, kuriame yra visos planetos, kurių orbitos yra tarp planetos 1 orbitos ir planetos 2 orbitos, sureguotos pagal artumą prie saulės. Funkcija turėtų grąžinti tuplą, kuriame yra tubli, jei planeta 1 arba planeta 2 nėra teisingi planetų pavadinimai.'''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,lit_Latn,python,"
def sorted_list_sum(lst):
    """"""Rašykite funkciją, kuri priima eilutės kaip parametrus, ištrina eilutes, kurių ilginiai yra netikslūs, ir grąžina gautą sąrašą su sureguliuota tvarka. Sąrašas visada yra eilutės sąrašas, o niekada - skaičių matrica, ir jame gali būti dublikatai. Sąrašas turi būti kelinamas pagal kiekvieno žodžio ilgį, ir jūs turėtumėte grąžinti sąrašą, sureguliuotą pagal šią taisyklę. Jei du žodžiai yra vienodo ilgio, sureguliaukite sąrašą alfabetiniu būdu. Funkcija turėtų grąžinti eilutės sąrašą sureguliuota tvarka. Galite manyti, kad visi žodžiai bus vienodo ilgio. Pavyzdžiui: asert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,lit_Latn,python,"
def x_or_y(n, x, y):
    """"""Paprasta programa, kuri turi grąžinti x vertę, jei n yra pirminis skaičius, ir y vertę, jei n nėra pirminis skaičius.""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,lit_Latn,python,"
def double_the_difference(lst):
    '''Jei pateikiamas skaičius, grąžinkite nevienetų skaičių kvadratų sumą. Ignoruokite neigiamus arba ne visą skaičių. duobelis_skirtumas (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 duobelis_skirtumas (([-1, -2, 0]) == 0 duobelis_skirtumas (([9, -2]) == 81 duobelis_skirtumas (([0]) == 0 Jei įvesties sąrašas tuščias, grąžinkite 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,lit_Latn,python,"
def compare(game,guess):
    """"""Manau, kad mes visi prisimename tą jausmą, kai pagaliau žinomas kažkokio ilgai laukiamo įvykio rezultatas. Jausmų ir minčių, kuriuos turite tuo metu, tikrai verta užrašyti ir palyginti. Jūsų užduotis yra nustatyti, ar asmuo teisingai atspėjo kelių rungtynių rezultatus. Jums duoti du lygių ilgio rezultato ir spėlionių matricos, kur kiekvienas indeksas rodo rungtynes. Grąžinkite tokio paties ilgio matricą, nurodančią, kiek toli buvo kiekvienas spėjimas. Jei jie spėjo teisingai, vertė yra 0, o jei ne, vertė yra absoliutus spėlio ir rezultato skirtumas. Pavyzdžiui: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4],[0,4,1,0,2]) -> [4,4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,lit_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Jums bus pateiktas klasės pavadinimas (stringa) ir išplėtimo sąrašas. Plėtimų naudojimas papildomiems klasėms įkelti į klasę. Plėtimų stiprumas yra toks: Tegul CAP yra didesnių raidžių skaičius išplėtimo pavadinime, o SM mažesnių raidžių skaičius išplėtimo pavadinime, stiprumas yra duotas iš frakcijos CAP - SM. Turėtumėte rasti stipriausią išplėtimą ir grąžinti eilutę šiuo formatu: ClassName.StrongestExtensionName. Jei yra du ar daugiau išplėtimų su tuo pačiu stiprumu, turėtumėte pasirinkti tą, kuris yra pirmas sąraše. Pavyzdžiui, jei jums yra pateiktas ""Slices"" kaip klasė ir išplėtimų sąrašas: ['SEviviviSNGCes', 'Cheese', 'StuFfed'], tuomet turėtumėte grąžinti 'Slices.SEviviSNGCes' kadangi 'SviviSNGCes' yra stipriausias išplėtimas (pvz.: 'AA_Beats'), 'AA_Extension_class' yra stipriausias išplėtimas (pvz.: 'AA_Beats'),""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,lit_Latn,python,"
def cycpattern_check(a , b):
    """"""Jums duoti 2 žodžiai. Jums reikia grąžinti True, jei antrasis žodis arba bet kuris jo sukimas yra pirmojo žodžio substring cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,lit_Latn,python,"
def even_odd_count(num):
    """"""Duotas sveikas skaičius. grąžina tuplą, kuriame yra atitinkamai pora ir netarna skaitmenų. Pavyzdys: net_netaikytė_skaita ((-12) ==> (1, 1) net_netaikytė_skaita ((123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,lit_Latn,python,"
def int_to_mini_roman(number):
    """"""Jei yra teigiamasis visuma, gaukite jo romėnų skaitmenų ekvivalentą kaip eilutę ir grąžinkite jį mažomis raidėmis.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,lit_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Jei triukšmas yra iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš dalies iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš iš'''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,lit_Latn,python,"
def find_max(words):
    """"""Rašykite funkciją, kuri priima eilutės. Listoje yra skirtingų žodžių. Grąžinkite žodį su didžiausiu unikalių simbolių skaičiumi. Jei kelios eilutės turi didžiausią unikalių simbolių skaičių, grąžinkite tą, kuris yra pirmas pagal leksikografinę eilutę.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,lit_Latn,python,"
def eat(number, need, remaining):
    """"""Jūs esate alkanas triušis, ir jūs jau valgėte tam tikrą skaičių morkų, bet dabar jums reikia valgyti daugiau morkų, kad užbaigtumėte dienos valgį. jūs turėtumėte grąžinti matricą [bendras valgiamų morkų skaičius po valgio, morkų skaičius, likęs po valgio ] jei nėra pakankamai likusių morkų, jūs valgysite visas likusias morkas, bet vis tiek būsite alkanas. Pavyzdys: * valgyti ((5, 6, 10) -> [11, 4] * valgyti ((4, 8, 9) -> [12, 1] * valgyti ((1, 10, 10) -> [11, 0] * valgyti ((2, 11, 5) -> [7, 0] kintamieji: @number: tuoj yra karotų, kuriuos valgote, skaičius. @need: tuoj yra karotų, kuriuos reikia valgyti. @remaining: likęs karotų skaičius, likęs atsargose.""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,lit_Latn,python,"
def do_algebra(operator, operand):
    """"""Duotas du sąrašai operatoris ir operandų. Pirmasis sąrašas turi pagrindines algebrai taikomas operacijas, o antrasis sąrašas yra visųjų skaičių sąrašas. Naudokite duotus sąrašus, kad sukurtumėte algebrai taikomą išraišką ir grąžintumėte šio išraiškos įvertinimą. Pagrindinės algebrai taikomos operacijos: Skaičiavimas (+) Išskaičiavimas (-)) Padauginimas (*) Lantai padalijimas (//) Eksponentikavimas (**) Pavyzdys: operatoris['+', '*', '-'] matrica = [2, 3, 4, 5] rezultatas = 2 + 3 * 4 - 5 => rezultatas = 9 Pastaba: operatorų sąrašo ilgis yra lygus operando sąrašo ilgiai minus vienas. Operandas yra ne neigiamų visųjų skaičių sąrašas. Operatorius turi bent vieną operatorą, o operandas turi bent du operandus. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,lit_Latn,python,"
def solve(s):
    """"""Jei s[i] yra raidė, pakeiskite jos raidės iš apačios į viršų arba atvirkščiai, kitaip palikite ją kaip yra. Jei eilutėje nėra raidžių, pakeiskite eilutę. Funkcija turėtų grąžinti gautą eilutę.""""""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,lit_Latn,python,"
def string_to_md5(text):
    """"""Jei yra eilutė 'text', grąžinkite jos md5 hašiaus ekvivalentą eilutę. Jei 'text' yra tuščia eilutė, grąžinkite None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,lit_Latn,python,"
def generate_integers(a, b):
    """"""Duodami du teigiami sveiki skaičiai a ir b, grąžinkite net ir skaitmenis tarp a ir b, didėjančia tvarka. Pavyzdžiui: generate_integers(2, 8) => [2, 4, 6, 8] generate_integers(8, 2) => [2, 4, 6, 8] generate_integers(10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
