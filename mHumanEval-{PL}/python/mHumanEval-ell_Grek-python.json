[
    {
        "task_id": "HumanEval/0",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Ελέγξτε αν σε δεδομένη λίστα αριθμών, υπάρχουν δύο αριθμοί πιο κοντά ο ένας στον άλλο από το δεδομένο όριο.\"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Η εισαγωγή σε αυτή τη συνάρτηση είναι μια σειρά γραμμών που περιέχει πολλαπλές ομάδες ενσωματωμένων παρενθέσεων. Στόχος σας είναι να χωρίσετε αυτές τις ομάδες σε ξεχωριστές σειρές γραμμών και να επιστρέψετε τον κατάλογο αυτών. Οι ξεχωριστές ομάδες είναι ισορροπημένες (κάθε ανοιχτή παρενθέση είναι σωστά κλειστή) και δεν ενσωματωμένες η μία μέσα στην άλλη Αγνοήστε τυχόν κενά στην σειρά εισόδου. Παράδειγμα: >>> separate_paren_groups' ((( ) (() ((( ) ) ) ' [' ((() ', '(()) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Με δεδομένο θετικό αριθμό πλωτής κλίμακας, μπορεί να διασπαστεί σε ακεραίο μέρος (μεγαλύτερο ακέραιο μικρότερο από τον δεδομένο αριθμό) και δεκαδικά (απομεινόμενο μέρος πάντα μικρότερο από 1).\"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Σας δίνεται μια λίστα με τις πράξεις κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Το καθήκον σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.\"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Για μια δεδομένη λίστα αριθμών εισόδου, υπολογίστε τη Μέση Απόλυτη Απόκλιση γύρω από τη μέση τιμή αυτού του συνόλου δεδομένων. Η Μέση Απόλυτη Απόκλιση είναι η μέση απόλυτη διαφορά μεταξύ κάθε στοιχείου και ενός κεντρικού σημείου (μέση τιμή σε αυτή την περίπτωση): MAD = μέση τιμή. x - x_μέση τιμή. Παράδειγμα: >>> μέση_απόκλιση_απόλυτης_απόκλισης ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Εισάγετε έναν αριθμό \"διαχωρισμού\" μεταξύ κάθε δύο διαδοχικών στοιχείων του καταλόγου εισόδου `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Η είσοδος σε αυτή τη συνάρτηση είναι μια σειρά που αντιπροσωπεύει πολλαπλές ομάδες για ενσωματωμένες παρενθέσεις χωρισμένες με κενά. Για κάθε ομάδα, εκπέμπει το βαθύτερο επίπεδο ενσωμάτωσης παρενθέσεων.\"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Φιλτράρισμα μιας λίστας εισερχόμενων συμβολοσειρών μόνο για εκείνες που περιέχουν δεδομένη υποσύνδεση >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Για έναν δεδομένο κατάλογο ακέραιων αριθμών, επιστρέφει ένα tuple που αποτελείται από ένα άθροισμα και ένα γινόμενο όλων των ακέραιων αριθμών σε μια λίστα. Το κενό άθροισμα θα πρέπει να είναι ίσο με το 0 και το κενό γινόμενο θα πρέπει να είναι ίσο με το 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Από έναν δεδομένο κατάλογο ακέραιων αριθμών, δημιουργεί έναν κατάλογο των κυλιόμενων μέγιστων στοιχείων που βρέθηκαν μέχρι δεδομένη στιγμή στη σειρά. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Βρείτε το μικρότερο παλινδρόμιο που αρχίζει με μια προμηθευμένη αλυσίδα. Η ιδέα του αλγόριθμου είναι απλή: - Βρείτε το μεγαλύτερο postfix της προμηθευμένης αλυσίδας που είναι παλινδρόμιο. - Προσθέστε στο τέλος της αλυσίδας αντίστροφο προθέματος αλυσίδας που έρχεται πριν από το παλινδρομικό επίθετο. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Δοκιμή εάν η δοθείσα αλυσίδα είναι παλινδρόμιο\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Η είσοδος είναι δύο σειρές α και β που αποτελούνται μόνο από 1 και 0. Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως μια σειρά.\"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Από τη λίστα των συμβολοσειρών, επιστρέφει το μακρύτερο. Επιστρέφει το πρώτο σε περίπτωση πολλαπλών συμβολοσειρών του ίδιου μήκους. Επιστρέφει το None σε περίπτωση που η λίστα εισόδου είναι κενή. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Επιστρέφει τον μέγιστο κοινό διαιρέτη δύο ακέραιων α και β >>> μέγιστος_κοινός_διαιρέτης ((3, 5) 1 >>> μέγιστος_κοινός_διαιρέτης ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Επιστρέφει λίστα όλων των προθεσμιών από το συντομότερο στο μακρύτερο της συμβολοσειράς εισόδου >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"Επιστρέφει μια σειρά που περιέχει αριθμούς με οριοθετημένο χώρο που αρχίζουν από το 0 μέχρι και το n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Με δεδομένη μια συμβολοσειρά, βρείτε πόσους διακριτούς χαρακτήρες (ανεξάρτητα από την περίπτωση) αποτελείται από >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Η εισαγωγή σε αυτή τη συνάρτηση είναι μια χορδή που αντιπροσωπεύει μουσικές νότες σε μια ειδική μορφή ASCII. Το έργο σας είναι να αναλύσετε λίστα χορδών ακεραίων που αντιστοιχούν σε πολλούς ρυθμούς. Εδώ είναι ένας υπόμνημα: 'o' - σημείωση, τελευταίες τέσσερις παλμοί 'o' - μισή σημείωση, τελευταίες δύο παλμοί 'o' - τετραγωνική σημείωση, τελευταίο ένα παλμό >>> parse_music. 'o' . o' . o' . o' . o' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Βρείτε πόσες φορές μπορεί να βρεθεί μια δεδομένη υποσύνδεση στην αρχική αλυσίδα. Μετρήστε τις αλληλεπικαλυπτόμενες περιπτώσεις. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Η είσοδος είναι μια αλυσίδα αριθμητικών στοιχείων με οριοθετημένο χώρο από το \"μηδέν\" έως το \"νέα\". Οι έγκυρες επιλογές είναι το \"μηδέν\", το \"ένα\", το \"δύο\", το \"τρεις\", το \"τέσσερα\", το \"πέντε\", το \"έξι\", το \"επτά\", το \"οκτώ\" και το \"νέα\". Επιστρέφει την αλυσίδα με αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο >>> sort_numbers (('three one five') 'one three five' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"Από μια προμηθευμένη λίστα αριθμών (μήκους τουλάχιστον δύο) επιλέξτε και επιστρέψτε δύο που είναι τα πλησιέστερα μεταξύ τους και επιστρέψτε τα με τη σειρά (μικρότερος αριθμός, μεγαλύτερος αριθμός). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Με δεδομένο κατάλογο αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε έναν γραμμικό μετασχηματισμό σε αυτόν τον κατάλογο, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Φίλτρος δεδομένης λίστας οποιωνδήποτε τιμών Python μόνο για ακέραιους αριθμούς >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"Διάρκεια επιστροφής της δοθείσας αλυσίδας >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Για έναν δεδομένο αριθμό n, βρείτε τον μεγαλύτερο αριθμό που διαιρεί n ομοιόμορφα, μικρότερο από n >>> μεγαλύτερος_διαμεριστής ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Επιστρέφει λίστα με τους πρώτους συντελεστές ενός δεδομένου ακέραιου αριθμού από τη μικρότερη μέχρι τη μεγαλύτερη. Κάθε ένας από τους συντελεστές πρέπει να αναγράφεται αριθμός φορές που αντιστοιχεί σε πόσες φορές εμφανίζεται στη διχοτόμηση. Ο αριθμός εισόδου πρέπει να είναι ίσος με το γινόμενο όλων των συντελεστών >>> παραγοντοποίηση(8) [2, 2, 2] >>> παραγοντοποίηση(25) [5, 5] >>> παραγοντοποίηση(70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Από μια λίστα ακέραιων αριθμών, αφαιρέστε όλα τα στοιχεία που εμφανίζονται περισσότερες από μία φορές. Διατηρήστε την σειρά των στοιχείων που έχουν μείνει ίδια με την εισερχόμενη. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Για μια δεδομένη αλυσίδα, αναστρέψτε μικρογραφικούς χαρακτήρες σε κεφαλαία και κεφαλαία σε μικρογραφικούς. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Συγκεντρώστε λίστα συμβόλων σε μία μόνο συμβόλαιο >>> συγκεντρώστε (([]) '' >>> συγκεντρώστε ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Φιλτράρει μια λίστα εισερχόμενων συμβολοσειρών μόνο για εκείνες που ξεκινούν με ένα δεδομένο πρόθεμα. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Επιστρέφει μόνο θετικούς αριθμούς στον κατάλογο. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"Επιστρέφει true αν ένας δεδομένος αριθμός είναι πρώτος και false διαφορετικά. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"Οι συντελεστές x είναι συντελεστές πολυωνύμου. βρείτε_μηδέν βρείτε x έτσι ώστε το πολυ (x) = 0. βρείτε_μηδέν επιστρέφει μόνο μόνο μηδενικό σημείο, ακόμη και αν υπάρχουν πολλά. Επιπλέον, το βρείτε_μηδέν παίρνει μόνο λίστα xs που έχουν ζυγο αριθμό συντελεστών και μεγαλύτερο μη μηδενικό συντελεστή, καθώς εγγυάται μια λύση. >>> γύρος (x) [1, 2]), 2) # f (x) = 1 + 2x -0,5 >>> γύρος (x) [-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1,0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"Αξιολογεί πολυώνυμο με συντελεστές xs στο σημείο x. επιστρέφει xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Αυτή η συνάρτηση παίρνει μια λίστα l και επιστρέφει μια λίστα l' έτσι ώστε η l' να είναι πανομοιότυπη με την l στους δείκτες που δεν διαιρούνται με το τρία, ενώ οι τιμές της στους δείκτες που διαιρούνται με το τρία είναι ίσες με τις τιμές των αντίστοιχων δείκτων της l, αλλά ταξινομημένες. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"Επιστρέφει ταξινομημένα μοναδικά στοιχεία σε μια λίστα >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Επιστρέφει το μέγιστο στοιχείο στον κατάλογο. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Επιστρέφει τον αριθμό των εμφανίσεων του ψηφίου 7 σε ακέραιους αριθμούς μικρότερους από n οι οποίοι διαιρούνται με 11 ή 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Αυτή η συνάρτηση παίρνει μια λίστα l και επιστρέφει μια λίστα l' έτσι ώστε η l' να είναι πανομοιότυπη με την l στα αρίθμητα δείγματα, ενώ οι τιμές της στα ζυγαρά δείγματα είναι ίσες με τις τιμές των ζυγαρά δείκτων του l, αλλά ταξινομημένες. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"λαμβάνει ως εισερχόμενη σειρά κωδικοποιημένη με τη συνάρτηση encode_cyclic. Επιστρέφει κωδικοποιημένη σειρά. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"επιστρέφει κωδικοποιημένη συμβολοσειρά με κύκλους τριών χαρακτήρων. \"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"Ο αριθμός prime_fib επιστρέφει τον n-ο αριθμό που είναι ένας αριθμός Φιμπονάτσι και είναι επίσης πρώτος. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"Το triple_sum_to_zero παίρνει μια λίστα ακέραιων αριθμών ως είσοδο. Επιστρέφει True αν υπάρχουν τρία ξεχωριστά στοιχεία στη λίστα που αθροίζονται στο μηδέν, και False διαφορετικά. >>> triple_sum_to_zero (([1, 3, 5, 0]) False >>> triple_sum_to_zero (([1, 3, -2, 1]) True >>> triple_sum_to_zero (([1, 2, 3, 7]) False >>> triple_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triple_sum_to_zero [1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Φανταστείτε μια οδό που είναι μια τέλεια ευθεία άπειρα μεγάλη γραμμή. n αυτοκίνητα οδηγούν αριστερά προς τα δεξιά, ταυτόχρονα, ένα διαφορετικό σύνολο από n αυτοκίνητα οδηγούν δεξιά προς τα αριστερά. Τα δύο σύνολα αυτοκινήτων ξεκινούν πολύ μακριά το ένα από το άλλο. Όλα τα αυτοκίνητα κινούνται με την ίδια ταχύτητα. Δύο αυτοκίνητα λέγεται ότι συγκρούονται όταν ένα αυτοκίνητο που κινείται αριστερά προς τα δεξιά χτυπά ένα αυτοκίνητο που κινείται δεξιά προς τα αριστερά. Ωστόσο, τα αυτοκίνητα είναι άπειρα γερά και ισχυρά. Ως αποτέλεσμα, συνεχίζουν να κινούνται στην τροχιά τους σαν να μην συγκρούστηκαν. Αυτή η συνάρτηση εκπέμπει τον αριθμό τέτοιων συγκρούσεων.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Επιστρέφει κατάλογο με στοιχεία αυξημένα κατά 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"Το pairs_sum_to_zero παίρνει μια λίστα από ακέραιους αριθμούς ως είσοδο. Επιστρέφει True αν υπάρχουν δύο ξεχωριστά στοιχεία στη λίστα που αθροίζονται στο μηδέν, και False διαφορετικά. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Αλλαγή αριθμητικής βάσης του αριθμού εισόδου x σε βάση. επιστροφή παράστασης χορδής μετά τη μετατροπή. αριθμοί βάσης είναι μικρότεροι από 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Δίνεται το μήκος μιας πλευράς και η υψηλή περιοχή επιστροφής για ένα τρίγωνο. >>> triangle_area(5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Η αλληλουχία αριθμών Fib4 είναι μια αλληλουχία παρόμοια με τη σειρά Fibbonacci που ορίζεται ως εξής: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Παρακαλούμε γράψτε μια συνάρτηση για να υπολογίσετε αποτελεσματικά το n-το στοιχείο της αλληλουχίας αριθμών fib4. Μην χρησιμοποιείτε την επανάληψη. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"Μεσαία τιμή επιστροφής των στοιχείων του καταλόγου l. >>> μεσαία τιμή (([3, 1, 2, 4, 5]) 3 >>> μεσαία τιμή (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Ελέγχει αν η δοσμένη αλυσίδα είναι ένα παλινδρόμιο >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Επιστρέφει 2^n modulo p (να γνωρίζετε τους αριθμούς). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"λαμβάνει ως εισερχόμενη αλυσίδα κωδικοποιημένη με τη συνάρτηση encode_shift. Επιστρέφει αποκωδικοποιημένη αλυσίδα. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"επιστρέφει κωδικοποιημένη συμβολοσειρά μετατοπίζοντας κάθε χαρακτήρα κατά 5 στο αλφάβητο.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels είναι μια συνάρτηση που παίρνει string και επιστρέφει string χωρίς φωνήεντα. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Επιστρέφει Αληθινό αν όλοι οι αριθμοί στον κατάλογο l είναι κάτω από το όριο t. >>> below_threshold([1, 2, 4, 10], 100) Αληθινό >>> below_threshold([1, 20, 4, 10], 5) Λευκό \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Προσθέστε δύο αριθμούς x και y >>> προσθέστε ((2, 3) 5 >>> προσθέστε ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Αληθινό >>> same_chars (('abcd', 'dddddddabc') Αληθινό >>> same_chars (('dddddddabc', 'abcd') Αληθινό >>> same_chars (('eabcd', 'dddddddddabc') Αληθινό >>> same_chars ((('abcd', 'dddddabddce') Αληθινό >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') Αληθινό \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"Επιστρέφει τον n-το αριθμό Φιμπονάτσι. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"Οι αλυσίδες \"<\" και \">\" είναι μια σειρά από \"<\" και \">\". επιστρέφει Αληθινό αν κάθε αλυσίδα ανοίγματος έχει μια αντίστοιχη αλυσίδα κλείσιμου. >>> correct_bracketing(\"<\") Αληθινό >>> correct_bracketing(\"<>\") Αληθινό >>> correct_bracketing(\"<><>>\") Αληθινό >>> correct_bracketing(\"><<>\") Αληθινό \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Επιστρέφει Αληθινό αν τα στοιχεία της λίστας αυξάνονται ή μειώνονται μονοτονικά. >>> μονοτονικό (([1, 2, 4, 20]) Αληθινό >>> μονοτονικό (([1, 20, 4, 10]) Ψευδές >>> μονοτονικό (([4, 1, 0, -10]) Αληθινό \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Επιστρέφει ταξινομημένα μοναδικά κοινά στοιχεία για δύο λίστες. >>> κοινά (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> κοινά (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Επιστρέφει τον μεγαλύτερο πρώτον παράγοντα του αριθμού n. Υποθέστε ότι ο αριθμός n > 1 δεν είναι πρώτος. >>> μεγαλύτερος_πρώτος_παράγοντας (συνδυασμός) 13195) 29 >>> μεγαλύτερος_πρώτος_παράγοντας (συνδυασμός) 2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"Οι αριστερές αριστερές γραμμές είναι μια σειρά από \"(\" και \")\". επιστρέφει Αλήθεια αν κάθε αριστερή αριστερή γραμμή ανοίγματος έχει μια αντίστοιχη αριστερή αριστερή γραμμή κλείσιμου. >>> correct_bracketing(\"(\") Λευκή >>> correct_bracketing(\"() Αλήθεια >>> correct_bracketing(\"(()) Αλήθεια >>> correct_bracketing(\")\"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"Τα xs αντιπροσωπεύουν συντελεστές ενός πολυωνύμου. xs[0] + xs[1] * x + xs[2] * x^2 + .... Επιστρέφει την παράγωγο αυτού του πολυωνύμου με την ίδια μορφή. >>> παράγωγο (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> παράγωγο [(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Η αλληλουχία αριθμών FibFib είναι μια αλληλουχία παρόμοια με τη σειρά Fibbonacci που ορίζεται ως εξής: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Παρακαλούμε γράψτε μια συνάρτηση για να υπολογίσετε αποτελεσματικά το n-το στοιχείο της αλληλουχίας αριθμών fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"Γράψε μια συνάρτηση vowels_count η οποία παίρνει μια σειρά λέξεων ως εισερχόμενη και επιστρέφει τον αριθμό των φωνητικών στην σειρά.\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Προσθέστε περισσότερες περιπτώσεις δοκιμών.\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Κύκλος μετατόπιση των ψηφίων του ακέραιου αριθμού x, μετατόπιση των ψηφίων δεξιά με μετατόπιση και επιστρέφει το αποτέλεσμα ως μια σειρά. Εάν μετατόπιση > αριθμός ψηφίων, επιστρέφει ψηφία ανάποδα. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"Δουλειά Γράψτε μια συνάρτηση που παίρνει μια σειρά ως εισροή και επιστρέφει το άθροισμα των ανώτερων χαρακτήρων μόνο' κωδικοί ASCII. Παραδείγματα: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"Σε αυτή την εργασία, θα σας δοθεί μια σειρά που αντιπροσωπεύει έναν αριθμό μήλων και πορτοκαλιών που διανέμονται σε ένα καλάθι με φρούτα αυτό το καλάθι περιέχει μήλα, πορτοκάλια και μάνγκο φρούτα. Δεδομένης της σειράς που αντιπροσωπεύει τον συνολικό αριθμό των πορτοκαλιών και μήλων και ένα ακέραιο που αντιπροσωπεύει τον συνολικό αριθμό των φρούτων στο καλάθι επιστρέψτε τον αριθμό των φρούτων μάνγκο στο καλάθι. για παράδειγμα: fruit_distribution\"5(μήλα και 6 πορτοκάλια\", 19) ->19 - 5 - 6 = 8 fruit_distribution\"0 μήλα και 1 πορτοκάλι\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 μήλα και 3 πορτοκάλια\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 μήλα και 1 πορτοκάλι\",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"Δεδομένου ενός πίνακα που αντιπροσωπεύει ένα κλάδο ενός δέντρου που έχει μη αρνητικούς ακέραιους κόμβους, το έργο σας είναι να αρπάξετε έναν από τους κόμβους και να τον επιστρέψετε. Ο αρπαγμένος κόμβος θα πρέπει να είναι ο κόμβος με τη μικρότερη ζυγαριά τιμή. Εάν βρεθούν πολλοί κόμβοι με την ίδια μικρότερη ζυγαριά τιμή, επιστρέψτε τον κόμβο που έχει το μικρότερο δείκτη. Ο αρπαγμένος κόμβος θα πρέπει να επιστρέφεται σε μια λίστα, [smallest_value, το δείκτη του ], Εάν δεν υπάρχουν ζυγαριά τιμές ή ο δεδομένος πίνακας είναι κενός, επιστρέψτε []. Παράδειγμα 1: Ειστροφή: [4,2,3] Αποβολή: [2, 1] Εξηγή: 2 έχει τη μικρότερη ζυγαριά τιμή και 2 έχει το μικρότερο δείκτη. Παράδειγμα 2: Ειστροφή: [1,2,3] Αποβολή: [2, 1] Εξηγή: 2 έχει τη μικρότερη ζυγαριά τιμή και 2 έχει το μικρότερο ζυγαριά δείκτη. Παράδειγμα 3: Εισαγωγή: [1,2,3] [1,2,3] Εξηγή: [1,2,3] Εξηγή: [2,3] Εξηγή: [2,3] Εξηγή: [2,3, [2,3] Εξηγή: [2, 3] Εξηγή: [2, [2, 3] Εξηγή: [2, 4] Εξηγή: [2, [2, 3] Εξηγή] Εξηγή: [2, [2, [2, 3] [2, [2, 3] [2, 4] [2, [2, [2, 3] [2, 4] [2, [2, 3] [2, [2, 3] [2, 4] [2, [2, 3] [2, [2, 4]\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''Σας δίνεται μια μη κενή λίστα θετικών ακέραιων. Επιστρέφει το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ίδιου του ακέραιου. Η συχνότητα ενός ακέραιου είναι ο αριθμός των φορές που εμφανίζεται στη λίστα. Αν δεν υπάρχει τέτοια τιμή, επιστρέφει -1. Παραδείγματα: αναζήτηση ([4, 1, 2, 2, 3, 1]) == 2 αναζήτηση ([1, 2, 2, 3, 3, 3, 4, 4]) == 3 αναζήτηση ([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''Δίνοντας μια λίστα από ακέραιους αριθμούς, επιστρέφουμε τη λίστα με παράξενη σειρά. Η παράξενη ταξινόμηση, είναι όταν ξεκινάμε με την ελάχιστη τιμή, στη συνέχεια με το μέγιστο των υπόλοιπων ακέραιων αριθμών, στη συνέχεια με το ελάχιστο και ούτω καθεξής. Παραδείγματα: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''Δίνοντας τα μήκη των τριών πλευρών ενός τριγώνου. Επιστρέφει την έκταση του τριγώνου στρογγυλοποιημένη σε 2 δεκαδικά ψηφία αν οι τρεις πλευρές σχηματίζουν ένα έγκυρο τρίγωνο. Διαφορετικά επιστρέφει -1 Τρεις πλευρές κάνουν ένα έγκυρο τρίγωνο όταν το άθροισμα των δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα: triangle_area (αριθμός τριών πλευρών)'''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''Γράψε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q πετάξει, και False διαφορετικά. Το αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι μια παλινδρομική λίστα) και το άθροισμα των στοιχείων του είναι μικρότερο ή ίσο με το μέγιστο δυνατό βάρος w. Παράδειγμα: will_it_fly (([1, 2], 5) â -> False # 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά είναι ανισορροπημένο. will_it_fly (([3, 2, 3], 1) â -> False # είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο. will_it_fly ((([3], â 5) -> True # 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο. '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"Βρείτε τον ελάχιστο αριθμό στοιχείων που πρέπει να αλλάξουν για να γίνει ο πίνακας παλινδρόμικος. Ένας παλινδρόμικος πίνακας είναι ένας πίνακας που διαβάζεται ο ίδιος προς τα πίσω και προς τα εμπρός. Σε μια αλλαγή, μπορείτε να αλλάξετε ένα στοιχείο σε οποιοδήποτε άλλο στοιχείο.\"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''Γράψε μια συνάρτηση που δέχεται δύο λίστες συμβόλων και επιστρέφει τη λίστα που έχει συνολικό αριθμό συμβόλων σε όλες τις συμβόλους της λίστας λιγότερο από την άλλη λίστα. αν οι δύο λίστες έχουν τον ίδιο αριθμό συμβόλων, επιστρέφει την πρώτη λίστα. Παραδείγματα total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hi', 'hi', 'hi']) â -> ['hi', 'hi', 'hi'] total_match ((['4', ['1', '2', '3', '4', '5', ['4]) -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Γράψε μια συνάρτηση που επιστρέφει true αν ο αριθμός που δίδεται είναι ο πολλαπλασιασμός 3 πρώτων αριθμών και false διαφορετικά. Γνωρίζοντας ότι (α) είναι μικρότερο από 100.\"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Το καθήκον σας είναι να γράψετε μια συνάρτηση που επιστρέφει true αν ένας αριθμός x είναι μια απλή δύναμη του n και false σε άλλες περιπτώσεις. x είναι μια απλή δύναμη του n αν n**int=x Για παράδειγμα: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''Γράψε μια συνάρτηση που παίρνει έναν ακέραιο αριθμό a και επιστρέφει True αν αυτός ο αριθμός είναι ένας κύβος κάποιου ακέραιου αριθμού. Σημείωση: μπορείτε να υποθέσετε ότι η είσοδος είναι πάντα έγκυρη. Παραδείγματα: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"Σας έχει ανατεθεί να γράψετε μια συνάρτηση που λαμβάνει έναν εξαδεκαδικό αριθμό ως μια σειρά και μετρά τον αριθμό των εξαδεκαδικών ψηφίων που είναι πρώτοι (πρώτος αριθμός, ή ένας πρώτος, είναι ένας φυσικός αριθμός μεγαλύτερος από 1 που δεν είναι ένα προϊόν δύο μικρότερων φυσικών αριθμών). Τα εξαδεκαδικά ψηφία είναι 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, Α, Β, Γ, Δ, Ε, F. Οι πρώτοι αριθμοί είναι 2, 3, 5, 7, 11, 13, 17,... Έτσι, πρέπει να καθορίσετε έναν αριθμό από τους ακόλουθους ψηφία: 2, 3, 5, 7, B (= δεκαδική 11), D (= δεκαδική 13). Σημείωση: μπορείτε να υποθέσετε ότι η είσοδος είναι πάντα σωστή ή κενή σειρά, και τα σύμβολα A,B,C,D,E,F είναι πάντα με κεφαλαία γράμματα. Παραδείγματα: Για num \"AB\" η έξοδος πρέπει να είναι num = 1. Για num = 1077E η έξοδος πρέπει να είναι 2. Για num = \"AB33\" η έξοδος πρέπει να είναι num = 1.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέψει μια σειρά, με κάθε χαρακτήρα να αντιπροσωπεύει έναν δυαδικό αριθμό. Κάθε χαρακτήρα στη σειρά θα είναι '0' ή '1'. Θα υπάρχει ένα επιπλέον ζευγάρι χαρακτήρων 'db' στην αρχή και στο τέλος της σειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφή. Παραδείγματα: decimal_to_binary ((15) # επιστρέφει \"db1111db\" decimal_to_binary32) # επιστρέφει \"db100000db\" \"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"Σας δίνεται μια αλυσίδα s. Η αποστολή σας είναι να ελέγξετε αν η αλυσίδα είναι ευτυχισμένη ή όχι. Μια αλυσίδα είναι ευτυχισμένη αν το μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι ξεχωριστά Για παράδειγμα: is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Είναι η τελευταία εβδομάδα του εξαμήνου και η δασκάλα πρέπει να δώσει τους βαθμούς στους μαθητές. Η δασκάλα έχει κάνει τον δικό της αλγόριθμο για βαθμολόγηση. Το μόνο πρόβλημα είναι ότι έχει χάσει τον κώδικα που χρησιμοποιούσε για βαθμολόγηση. Σας έχει δώσει μια λίστα με τους βαθμούς GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εκδώσει μια λίστα με τους βαθμούς γράμματος χρησιμοποιώντας τον ακόλουθο πίνακα: GPA.\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"Γράψε μια συνάρτηση που παίρνει μια σειρά και επιστρέφει Αληθινό αν το μήκος της σειράς είναι ένας πρώτος αριθμός ή Αληθινό διαφορετικά Παραδείγματα prime_length('Hello') == Αληθινό prime_length('abcdcba') == Αληθινό prime_length('kittens') == Αληθινό prime_length('orange') == Αληθινό \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Με δεδομένο θετικό ακέραιο n, επιστρέφουμε τον αριθμό των αριθμών των n-ψήφων θετικών ακέραιων που αρχίζουν ή τελειώνουν με 1. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"Δίνοντας ένα θετικό ακέραιο αριθμό N, επιστρέφει το συνολικό άθροισμα των ψηφίων του σε δυαδικό. Παράδειγμα Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 η έξοδος θα πρέπει να είναι \"1\". Για N = 150, το άθροισμα των ψηφίων θα είναι 6 η έξοδος θα πρέπει να είναι \"110\". Για N = 147, το άθροισμα των ψηφίων θα είναι 12 η έξοδος θα πρέπει να είναι \"1100\".\"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"Με δεδομένο έναν μη κενό κατάλογο ακέραιων αριθμών, αρχικά προσθέστε τα ζυγαρά στοιχεία που βρίσκονται σε περιττούς δείκτες. Παραδείγματα: προσθέστε ([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Γράψτε μια συνάρτηση που παίρνει μια σειρά και επιστρέφει μια τακτοποιημένη έκδοση της. Η τακτοποιημένη έκδοση της σειράς, είναι μια σειρά όπου όλες οι λέξεις (διαχωρισμένες με κενό) αντικαθίστανται από μια νέα λέξη όπου όλοι οι χαρακτήρες είναι τακτοποιημένοι σε ανοδική σειρά με βάση την τιμή ascii. Σημείωση: Θα πρέπει να διατηρήσετε την σειρά των λέξεων και των κενών κενών θέσεων στη φράση. Για παράδειγμα: anti_shuffle ((('Hi') επιστρέφει 'Hi' anti_shuffle ((('hello') επιστρέφει 'ehllo' anti_shuffle (('Hello World!!!') επιστρέφει 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"Σας δίνεται ένα 2διαστατικό δεδομένο, ως μια ένθετη λίστα, η οποία είναι παρόμοια με το μήτρα, ωστόσο, σε αντίθεση με τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στήλων. Δεδομένου lst, και ακέραιο x, βρείτε ακέραιους x στη λίστα, και επιστρέψτε λίστα των tuples, [(x1, y1), (x2, y2) ...] έτσι ώστε κάθε tuple είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας με 0.\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"Με δεδομένο ένα πλέγμα μη αρνητικών ακέραιων αριθμών, επιστρέψτε ένα αντίγραφο του δεδομένου πλέγματος μετά την ταξινόμηση, θα ταξινομήσετε το δεδομένο πλέγμα με ανοδική σειρά αν το άθροισμα ((πρώτη τιμή δείκτη, τελευταία τιμή δείκτη) είναι αμόρφωτο, ή θα το ταξινομήσετε με φθίνουσα σειρά αν το άθροισμα ((πρώτη τιμή δείκτη, τελευταία τιμή δείκτη) είναι ζυγικό. Σημείωση: * μην αλλάζετε το δεδομένο πλέγμα. Παραδείγματα: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"Δημιουργήστε μια συνάρτηση encrypt που παίρνει ένα string ως επιχείρημα και επιστρέφει ένα string κρυπτογραφημένο με το αλφάβητο να περιστρέφεται. Το αλφάβητο θα πρέπει να περιστρέφεται με τέτοιο τρόπο ώστε τα γράμματα να μετακινούνται προς τα κάτω με δύο πολλαπλασιασμένα σε δύο θέσεις. Για παράδειγμα: encrypt('hi') επιστρέφει 'lm' encrypt('asdfghjkl') επιστρέφει 'ewhjklnop' encrypt('gf') επιστρέφει 'kj' encrypt('et') επιστρέφει 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"Σας δίνεται μια λίστα από ακέραιους αριθμούς. Γράψτε μια συνάρτηση next_smallest (() που επιστρέφει το 2ο μικρότερο στοιχείο της λίστας. Επιστρέφει None αν δεν υπάρχει τέτοιο στοιχείο. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"Θα σας δοθεί μια σειρά λέξεων και η αποστολή σας είναι να μετρήσετε τον αριθμό των βαρεμάτων. Μια βαρεμάρα είναι μια πρόταση που αρχίζει με τη λέξη \"I\". Οι προτάσεις οριοθετούνται από \"\"., \"?' ή \"!\". Για παράδειγμα: >>> είναι_βαρεμένος (is_bored) \"Γεια σας κόσμο\") 0 >>> είναι_βαρεμένος (is_bored) \"Ο ουρανός είναι μπλε. Ο ήλιος λάμπει. Λατρεύω αυτό τον καιρό\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''Δημιουργήστε μια συνάρτηση που παίρνει 3 αριθμούς. Επιστρέφει true αν ένας από τους αριθμούς είναι ίσος με το άθροισμα των άλλων δύο, και όλοι οι αριθμοί είναι ακέραιοι. Επιστρέφει false σε οποιαδήποτε άλλη περίπτωση. Παραδείγματα any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"Γράψτε μια συνάρτηση που παίρνει ένα μήνυμα και κωδικοποιεί με τέτοιο τρόπο ώστε να ανταλλάσσει τα κεντρικά και τα δευτερεύοντα γράμματα όλων των γραμμάτων, να αντικαθιστά όλα τα φωνήεντα στο μήνυμα με το γράμμα που εμφανίζεται 2 θέσεις μπροστά από αυτό το φωνήεντα στο αγγλικό αλφάβητο. Υποθέστε μόνο γράμματα. Παραδείγματα: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Σας δίνεται μια λίστα από ακέραιους αριθμούς. Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της. Παραδείγματα: Για lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] η έξοδος θα πρέπει να είναι 10 Για lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] η έξοδος θα πρέπει να είναι 25 Για lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] η έξοδος θα πρέπει να είναι 13 Για lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] η έξοδος θα πρέπει να είναι 11 Για lst = [0,81,12,31,21] η έξοδος θα πρέπει να είναι 3 Για lst = [0,1,8,1,2,1,7] η έξοδος θα πρέπει να είναι  7\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Δίνοντας ένα λεξικό, επιστρέφει True αν όλα τα πλήκτρα είναι σειρές με μικρά γράμματα ή όλα τα πλήκτρα είναι σειρές με μεγάλα γράμματα, αλλιώς επιστρέφει False. Η συνάρτηση θα πρέπει να επιστρέψει False αν το δεδομένο λεξικό είναι κενό. Παραδείγματα: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) θα πρέπει να επιστρέψει True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) θα πρέπει να επιστρέψει False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) θα πρέπει να επιστρέψει False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False θα πρέπει να επιστρέψει check.dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"12345}) θα πρέπει να επιστρέψει True.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"Εφαρμόστε μια συνάρτηση που παίρνει έναν μη αρνητικό ακέραιο αριθμό και επιστρέφει μια σειρά από τους πρώτους n ακέραιους αριθμούς που είναι πρώτοι αριθμοί και μικρότεροι από n. για παράδειγμα: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"Συμπληρώστε τη συνάρτηση που παίρνει δύο ακέραιους αριθμούς και επιστρέφει το γινόμενο των μονάδων τους. Υποθέστε ότι η είσοδος είναι πάντα έγκυρη. Παραδείγματα: πολλαπλασιάστε 148, 412) θα πρέπει να επιστρέψει 16. πολλαπλασιάστε 19 28, 72. πολλαπλασιάστε 2020, 1851) θα πρέπει να επιστρέψει 0. πολλαπλασιάστε 14, 15) θα πρέπει να επιστρέψει 20. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"Για παράδειγμα: count_upper{\\displaystyle \\mathbb {a} } επιστρέφει 1 count_upper{\\displaystyle \\mathbb {a} } επιστρέφει 0 count_upper{\\displaystyle \\mathbb {a} } επιστρέφει 0 count_upper{\\displaystyle \\mathbb {a} } } επιστρέφει 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (σύνδεση) που αντιπροσωπεύει έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι εξίσου απόμακρος από δύο ακέραιους, στρογγυλοποιήστε τον μακριά από το μηδέν. Παραδείγματα >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 Σημείωση: Η στρογγυλοποίηση μακριά από το μηδέν σημαίνει ότι αν ο δεδομένος αριθμός είναι εξίσου απόμακρος από δύο ακέραιους, αυτός που θα πρέπει να επιστρέψετε είναι αυτός που είναι ο πιο μακρινός από το μηδέν. Για παράδειγμα, ο closest_integer \" ((14.5\") θα πρέπει να επιστρέψει 15 και ο closest_integer \" ((-14.5\") θα πρέπει να επιστρέψει -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"Ο αριθμός των πέτρες στο επόμενο επίπεδο είναι: - ο επόμενος αμόρφωτος αριθμός αν το n είναι αμόρφωτος. - ο επόμενος ζυγικός αριθμός αν το n είναι ζυγικός. Επιστρέφει τον αριθμό των πέτρες σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στο δείκτη i αντιπροσωπεύει τον αριθμό των πέτρες στο επίπεδο (i+1).\"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"Θα σας δοθεί μια σειρά λέξεων χωρισμένες με κόμματα ή κενά. Η αποστολή σας είναι να χωρίσετε τη σειρά σε λέξεις και να επιστρέψετε μια σειρά από λέξεις. Για παράδειγμα: words_string ((\"Γεια, το όνομά μου είναι John\") == [\"Γεια\", \"μου\", \"ονοματεπώνυμο\", \"είναι\", \"John\"] words_string ((\"Ένα, δύο, τρία, τέσσερα, πέντε, έξι\") == [\"Ένα\", \"δύο\", \"τρεις\", \"τέσσερα\", \"πέντε\", \"έξι\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει τον μεγαλύτερο ζυγο αριθμό που είναι στην περιοχή [x, y] συμπεριλαμβανομένου.\"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακέραιων αριθμών από n έως m (συμπεριλαμβανομένων των n και m). Γυρίστε την απάντηση στον πλησιέστερο ακέραιο αριθμό και μετατρέψτε το σε δυαδικό. Αν το n είναι μεγαλύτερο από m, επιστρέψτε -1.\"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"Σημείωση: Η λίστα που επιστρέφεται πρέπει να ταξινομείται με αυξανόμενη σειρά. Για παράδειγμα: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"Με δεδομένο ένα πίνακα ακέραιων αριθμών, ταξινομήστε τους ακέραιους αριθμούς που είναι μεταξύ 1 και 9 συμπεριλαμβανομένων, αντιστρέψτε το αποτέλεσμα του πίνακα, και στη συνέχεια αντικαταστήστε κάθε ψηφίο με το αντίστοιχο όνομα από \"Ένα\", \"Δύο\", \"Τρία\", \"Τέσσερα\", \"Πέντε\", \"Έξι\", \"Επτά\", \"Εκτώ\", \"Εννέα\". Για παράδειγμα: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ταξινομήστε arr -> [1, 1, 2, 3, 4, 5, 8] -> αντιστρέψτε arr -> [8, 5, 4, 3, 2, 1, 1] επιστροφή [\"Οκτώ\", \"Τέσσερα\", \"Τρία\", \"Δύο\", \"Δύο\", \"Ένα\", \"Ένα\"] Εάν ο πίνακας είναι κενός, επιστρέψτε ένα άδειο: arr = [] επιστροφή [] Εάν ο πίνακας έχει οποιοδήποτε παράξενο αριθμό, αγνοήστε το: arr = [1, -1 , 55] -> arr -> [1, 55] -> reverse arr = [51] - return ['One' 1] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"Εφαρμόστε τη συνάρτηση f που παίρνει n ως παράμετρο και επιστρέφει έναν κατάλογο μεγέθους n, έτσι ώστε η τιμή του στοιχείου στο δείκτη i να είναι το παραγοντικό του i αν i είναι ζυγικό ή το άθροισμα των αριθμών από 1 έως i διαφορετικά. i ξεκινά από 1. το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i).\"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"Δίνοντας ένα θετικό ακέραιο n, επιστρέφει ένα tuple που έχει τον αριθμό των ζυγών και των ατόμων ακέραιων παλινδρόμων που εμπίπτουν στην περιοχή ((1, n), συμπεριλαμβανομένων. Παράδειγμα1: Εισροή: 3 Εξόδου: (1, 2) Εξηγήσεις: Τα ακέραια παλινδρόμια είναι 1, 2, 3. ένα από αυτά είναι ζυγών και δύο από αυτά είναι ατόμων. Παράδειγμα2: Εισροή: 12 Εξόδου: (4, 6) Εξηγήσεις: Τα ακέραια παλινδρόμια είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. τέσσερα από αυτά είναι ζυγών και 6 από αυτά είναι ατόμων. Σημείωση: 1. 1 <= n <= 10^3 2. το tuple έχει επιστρέψει τον αριθμό των ζυγών και των ατόμων ακέραιων παλινδρόμων αντίστοιχα. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"Γράψε μια συνάρτηση count_nums η οποία παίρνει ένα πίνακα ακέραιων αριθμών και επιστρέφει τον αριθμό των στοιχείων που έχει άθροισμα ψηφίων > 0. Εάν ένας αριθμός είναι αρνητικός, τότε ο πρώτος υπογεγραμμένος ψηφός του θα είναι αρνητικός: π.χ. -123 έχει υπογεγραμμένα ψηφία -1, 2 και 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Η εργασία σας είναι να καθορίσετε αν είναι δυνατό να επιτευχθεί μια σειρά που δεν μειώνεται με την εκτέλεση της ακόλουθης λειτουργίας στο δεδομένο σύστημα: Επιτρέπεται να εκτελέσετε μια λειτουργία μετατόπισης δεξιάς οποιοδήποτε αριθμό φορές. Μια λειτουργία μετατόπισης δεξιάς σημαίνει μετατόπιση όλων των στοιχείων του συστήματος από μια θέση προς τη σωστή κατεύθυνση. Το τελευταίο στοιχείο του συστήματος θα μετακινηθεί στην αρχική θέση του συστήματος, δηλαδή 0ο δείκτη. Εάν είναι δυνατό να επιτευχθεί η ταξινομημένη σειρά με την εκτέλεση της παραπάνω λειτουργίας, τότε η επιστροφή είναι Αληθής, αλλιώς η επιστροφή είναι Λευκή. Εάν το δεδομένο σύστημα είναι άδειο, τότε η επιστροφή είναι Αληθής. Σημείωση: Η δεδομένη λίστα εγγυάται ότι θα έχει μοναδικά στοιχεία. Για παράδειγμα: move_one_{} ball[3, 4, 5, 2] Αληθής εξήγηση: Με το performin 2 δεξιάς, οι μη μειούμενες λειτουργίες μπορούν να επιτευχθούν για το σύστημα.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Σε αυτό το πρόβλημα, θα εφαρμόσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει αν είναι δυνατό να γίνει μια ανταλλαγή στοιχείων μεταξύ τους για να γίνει η λίστα lst1 μια λίστα μόνο ζυγικών αριθμών. Δεν υπάρχει όριο στον αριθμό των ανταλλαγμένων στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατό να ανταλλαχθούν στοιχεία μεταξύ της lst1 και lst2 για να γίνουν όλα τα στοιχεία της lst1 ζυγικά, επιστρέψτε \"ΝΑΙ\". Διαφορετικά, επιστρέψτε \"ΟΧΙ\". Για παράδειγμα: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"ΝΑΙ\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"ΟΧΙ\" Υποτίθεται ότι οι καταχωρήσεις εισόδου δεν θα είναι κενές. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"Δίνοντας μια σειρά που αντιπροσωπεύει ένα διάστημα χωρισμένα μικρά γράμματα, επιστρέφει ένα λεξικό του γράμματος με την περισσότερη επανάληψη και που περιέχει τον αντίστοιχο αριθμό. Αν πολλά γράμματα έχουν την ίδια εμφάνιση, επιστρέφουν όλα τους.\"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Δίνεται σε μας δύο συμβολοσειρές s και c, πρέπει να διαγράψουμε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c και να ελέγξουμε αν το αποτέλεσμα είναι παλινδρόμιο. Μια συμβολοσειρά ονομάζεται παλινδρόμιο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός. Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα και το True/False για τον έλεγχο.\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"Κάθε στοιχείο i της εξόδου θα πρέπει να είναι \"ο αριθμός των περιττών στοιχείων στην αλυσίδα i της εισόδου\". όπου όλα τα i θα πρέπει να αντικαθίστανται από τον αριθμό των περιττών ψηφίων στην i' αλυσίδα της εισόδου. >>> odd_count['1234567']) [\"ο αριθμός των περιττών στοιχείων 4n το str4ng 4 της 4nput.\"] >>> odd_count['3',\"111111\"]) [\"ο αριθμός των περιττών στοιχείων 1n το str1ng 1 της 1nput.\", \"ο αριθμός των περιττών στοιχείων 8n το str8ng 8 της 8nput.\"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Δίνοντας ένα πίνακα ακεραίων n, βρείτε το ελάχιστο άθροισμα οποιουδήποτε μη κενού υπο-στοιχειώματος των n. Παράδειγμα minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Κάθε γραμμή αντιπροσωπεύει ένα μοναδικό πηγάδι και κάθε 1 σε μια γραμμή αντιπροσωπεύει μια μοναδική μονάδα νερού. Κάθε πηγάδι έχει έναν αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να εξαγάγει νερό από αυτό και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Το καθήκον σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τους πηγάδες. Εκτός ο αριθμός των φορές που πρέπει να κατεβάσετε τους κουβάδες. Παράδειγμα 1: Εισροχή: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Εκτός: 62: Εισροχή: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] bucket_capacity: 2 Εκτός: 53: Εισροχή: [[0,0,0], [0,0,0]] bucket_capacity: 5 Εκτός: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"Σε αυτό το Kata, πρέπει να ταξινομήσετε μια σειρά από μη αρνητικούς ακέραιους αριθμούς σύμφωνα με τον αριθμό των ατόμων στη δυαδική τους αναπαράσταση σε ανοδική σειρά. Για παρόμοιο αριθμό ατόμων, ταξινομήστε με βάση την δεκαδική τιμή. Πρέπει να εφαρμοστεί ως εξής: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"Σημείωση: Μπορείτε να υποθέσετε ότι η εισερχόμενη συμβολοσειρά περιέχει μόνο γράμματα και κενά. Παραδείγματα: select_words (η Μαρία είχε ένα μικρό αρνί), 4) ==> [\"μικρό\"] select_words (η Μαρία είχε ένα μικρό αρνί), 3) ==> [\"Μαρία\", \"αρνί\"] select_words (απλό λευκό χώρο), 2) ==> [] select_words (γεια σου, κόσμο), 4) ==> [\"κόσμος\"] select_words (ο θείος Σαμ), 3) ==> [\"ο θείος\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Σας δίνεται μια λέξη. Η αποστολή σας είναι να βρείτε το πλησιέστερο φωνητικό που βρίσκεται μεταξύ δύο συλλαβών από τη δεξιά πλευρά της λέξης (επισήμως). Οι φωνητικοί στην αρχή και το τέλος δεν μετράνε. Επιστρέψτε κενή σειρά αν δεν βρείτε κανένα φωνητικό που πληροί την ανωτέρω προϋπόθεση. Μπορείτε να υποθέσετε ότι η δεδομένη σειρά περιέχει μόνο αγγλικά γράμματα.\"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''Σας δίνεται μια λίστα με δύο συμβολοσειρές, και οι δύο συμβολοσειρές αποτελούνται μόνο από ανοιχτές παρενθέσεις '(' ή κλειστές παρενθέσεις ') '. Η δουλειά σας είναι να ελέγξετε αν είναι δυνατό να συσσωρεύσετε τις δύο συμβολοσειρές με κάποια σειρά, ώστε το προκύπτον συμβολοσειρά να είναι καλό. Μια συμβολοσειρά S θεωρείται καλή μόνο και μόνο αν όλες οι παρενθέσεις στο S είναι ισορροπημένες. Για παράδειγμα: η συμβολοσειρά '((()) ' είναι καλή, ενώ η συμβολοσειρά '()) ' δεν είναι. Επιστρέψτε 'Ναι' αν υπάρχει τρόπος να κάνετε μια καλή συμβολοσειρά, και επιστρέψτε 'Όχι' διαφορετικά. Παραδείγματα: match_parens[('() ', ') ']) == 'Ναι' match_parens[(') ', ') ']) == 'Όχι' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"Δίνοντας ένα πίνακα arr ακέραιων αριθμών και ένα θετικό ακέραιο αριθμό k, επιστρέφει έναν ταξινομημένο κατάλογο μήκους k με τους μέγιστους αριθμούς k στο arr. Παράδειγμα1: Εισόδου: arr = [-3, -4, 5], k = 3 Εξόδου: [-4, -3, 5] Παράδειγμα2: Εισόδου: arr = [4, -4, 4], k = 2 Εξόδου: [4, 4] Παράδειγμα3: Εισόδου: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Εξόδου: [2] Σημείωση: 1. Το μήκος του πίνακα θα είναι στην περιοχή [1, 1000]. 2. Τα στοιχεία του πίνακα θα είναι στην περιοχή [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"Με δεδομένη μια μη κενή λίστα ακέραιων αριθμών, επιστρέφει το άθροισμα όλων των αμόριων στοιχείων που βρίσκονται σε ζυγικές θέσεις.\"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Με δεδομένο έναν μη κενό πίνακα ακέραιων αριθμών arr και έναν ακέραιο αριθμό k, επιστρέφει το άθροισμα των στοιχείων με το πολύ δύο ψηφία από τα πρώτα k στοιχεία του arr. Παράδειγμα: Εισόδου: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Αποδέσμευση: 24 # άθροισμα 21 + 3 Περιορισμοί: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"Η υπόθεση του Collatz είναι μια υπόθεση στα μαθηματικά που αφορά μια ακολουθία που ορίζεται ως εξής: ξεκινήστε με οποιοδήποτε θετικό ακέραιο n. Στη συνέχεια, κάθε όρος λαμβάνεται από τον προηγούμενο όρο ως εξής: αν ο προηγούμενος όρος είναι ζυγός, ο επόμενος όρος είναι το μισό του προηγούμενου όρου. Αν ο προηγούμενος όρος είναι αμόρφωτος, ο επόμενος όρος είναι 3 φορές ο προηγούμενος όρος συν 1.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"Πρέπει να γράψετε μια συνάρτηση που επικυρώνει μια δεδομένη σειρά ημερομηνιών και επιστρέφει Αληθινό αν η ημερομηνία είναι έγκυρη διαφορετικά Αληθινό. Η ημερομηνία είναι έγκυρη αν πληρούνται όλοι οι ακόλουθοι κανόνες: 1. Η σειρά ημερομηνιών δεν είναι κενή. 2. Ο αριθμός των ημερών δεν είναι μικρότερος από 1 ή μεγαλύτερος από 31 ημέρες για τους μήνες 1,3,5,7,8,10,12. Και ο αριθμός των ημερών δεν είναι μικρότερος από 1 ή μεγαλύτερος από 30 ημέρες για τους μήνες 4,6,9,11. Και ο αριθμός των ημερών δεν είναι μικρότερος από 1 ή μεγαλύτερος από 29 για τον μήνα 2. 3. Οι μήνες δεν πρέπει να είναι μικρότεροι από 1 ή μεγαλύτεροι από 12. 4. Η ημερομηνία πρέπει να είναι στη μορφή: mm-dd-yyyy για παράδειγμα: valid_date (('03-11-2000') => Αληθινό_date (('15-01-2012') => Αληθινό_date (('04-040') => Αληθινό_date (('06-04-2020') => Αληθινό_date (('06/04/2020') => Αληθινό\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''Με δεδομένη μια σειρά λέξεων, επιστρέφει μια λίστα λέξεων χωρισμένες σε κενά, αν δεν υπάρχουν κενά στο κείμενο θα πρέπει να χωριστεί σε κόμματα ',' αν δεν υπάρχουν κόμματα θα πρέπει να επιστρέψει τον αριθμό των μικρών γραμμάτων με αμόρφωτη σειρά στο αλφάβητο, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 Παραδείγματα split_words ((\"Hello world!\") â -> [\"Hello\", \"world!\"] split_words ((\"Hello,world!\") â -> [\"Hello\", \"world!\" split_words\")'''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''Δίνοντας μια λίστα αριθμών, επιστρέφει αν είναι ταξινομημένα ή όχι σε ανοδική σειρά. Αν η λίστα έχει περισσότερους από 1 αντιγράφους του ίδιου αριθμού, επιστρέφει False. Υποθέστε ότι δεν υπάρχουν αρνητικοί αριθμοί και μόνο ακέραιοι. Παραδείγματα is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Για παράδειγμα, η διασταύρωση των διαστημάτων (1, 3), (2, 4) είναι (2, 3) η οποία έχει μήκος 1, που δεν είναι πρώτος αριθμός. Εάν το μήκος της διασταύρωσης είναι πρώτος αριθμός, επιστρέφει \"ΝΑΙ\", διαφορετικά επιστρέφει \"ΟΧΙ\". Αν τα δύο διαστήματα δεν διασταυρώνονται, επιστρέφει \"ΟΧΙ\". [input/output] δείγματα: διασταύρωση (((1, 2), (2, 3) ==> \"διασταύρωση (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \"), \" (\", \"), \" (), \" (), \" (), \" (), \" (), \" (), \" (\", \"), \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \"), \" (\", \"), \" (), \" (), \" (), \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \"), \" (\", \" (\", \"), \"), \" (\", \"), \" (\", \"), \"), \" (\", \"), \" (\", \"), \" (\", \"), \" (\", \"),\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"Σας δίνεται μια σειρά από ακέραιους αριθμούς και πρέπει να επιστρέψετε το άθροισμα των μεγεθών των ακέραιων αριθμών πολλαπλασιασμένο με το γινόμενο όλων των σημάτων κάθε αριθμού στη σειρά, που αντιπροσωπεύεται από 1, -1 ή 0. Σημείωση: επιστρέφει None για κενή σειρά.\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"Μπορείτε να ξεκινήσετε από οποιοδήποτε κελί και σε κάθε βήμα μπορείτε να μετακινηθείτε σε οποιοδήποτε από τα γειτονικά κελιά, με άλλα λόγια, μπορείτε να πάτε σε κελιά που μοιράζονται μια άκρη με το τρέχον κελί σας. Παρακαλούμε σημειώστε ότι μια διαδρομή μήκους k σημαίνει επίσκεψη ακριβώς k κελίων (όχι απαραίτητα διακριτά). Δεν μπορείτε να βγείτε από το πλέγμα. Μια διαδρομή A (μήκους k) θεωρείται μικρότερη από μια διαδρομή B (μήκους k) εάν μετά την παραγωγή των ταξινομημένων λίστας των τιμών στα κελιά που περνούν από το A και το B (ας τις ονομάσουμε l_stA και l_stB), η λεξικογραφική διαδρομή είναι μικρότερη από την l_stA, με άλλα λόγια, υπάρχει ένας ακεραμικός δείκτης με το τρέχον κελί σας. [A=1, j_stA=4, j_stB=5, j_stA=8, j_stB=1, j_stA=1, j_i=j=1, j_j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=j=\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"Όλοι γνωρίζουν τη σειρά Φιμπονατσι, μελετήθηκε βαθιά από τους μαθηματικούς τους τελευταίους δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η σειρά Τριμπονατσι. Η σειρά Τριμπονατσι ορίζεται από την επανάληψη: tri(1) = 3 tri(n) = 1 + n / 2, αν n είναι ζυγική. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν n είναι αρίθμητη. Για παράδειγμα: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε έναν κατάλογο των πρώτων n + 1 αριθμών της σειράς Τριμπονατσι. Παραδείγματα: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"Δίνοντας ένα θετικό ακέραιο αριθμό n, επιστρέφει το γινόμενο των περιττών ψηφίων.\"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''Δημιουργήστε μια συνάρτηση που παίρνει μια σειρά ως εισροή η οποία περιέχει μόνο τετράγωνες αγκύλες. Η συνάρτηση θα πρέπει να επιστρέψει Αληθινή αν και μόνο αν υπάρχει μια έγκυρη υποδοχή αγκυλών όπου τουλάχιστον μία αγκύλα στην υποδοχή είναι ενσωματωμένη. είναι_ενσωματωμένη (ε) '[[]]') â -> Αληθινή είναι_ενσωματωμένη (ε) '[[]]]]]]]]][[[[[[]') â -> Αληθινή είναι_ενσωματωμένη (ε) '[][]') â -> Αληθινή είναι_ενσωματωμένη (ε) '[]') â -> Αληθινή είναι_ενσωματωμένη (ε) '[[]]]]') â -> Αληθινή'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Σας δίνεται μια λίστα αριθμών. Πρέπει να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στη λίστα, στρογγυλοποιώντας κάθε στοιχείο στη λίστα στο ανώτερο int ((Ceiling) πρώτα. Παραδείγματα: Για lst = [1,2,3] η έξοδος θα πρέπει να είναι 14 Για lst = [1,4,9] η έξοδος θα πρέπει να είναι 98 Για lst = [1,3,5,7] η έξοδος θα πρέπει να είναι 84 Για lst = [1.4,4.2,0] η έξοδος θα πρέπει να είναι 29 Για lst = [-2.4,1,1] η έξοδος θα πρέπει να είναι 6 \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''Δημιουργήστε μια συνάρτηση που επιστρέφει Αληθινό αν ο τελευταίος χαρακτήρας μιας δεδομένης αλφαβητικής αλυσίδας είναι αλφαβητικός χαρακτήρας και δεν αποτελεί μέρος μιας λέξης, και Αληθινό σε διαφορετική περίπτωση. Σημείωση: \"λόγος\" είναι μια ομάδα χαρακτήρων χωρισμένων με κενό. Παραδείγματα: check_if_last_char_is_a_letter\" (επιλέξτε \"επιλέξτε\" αν είναι αλφαβητικό ή όχι) -> Αληθινό check_if_last_char_is_a_letter\" (επιλέξτε \"επιλέξτε\" αν είναι αλφαβητικό ή όχι) -> Αληθινό check_if_last_char_is_a_letter\" (επιλέξτε \"επιλέξτε\" αν είναι αλφαβητικό ή όχι)'''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"Δημιουργήστε μια συνάρτηση που επιστρέφει τον μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο με το στοιχείο που το προηγείται αμέσως. Αν δεν υπάρχει τέτοιο στοιχείο, επιστρέφει -1.\"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι το μεγαλύτερο από τα αρνητικά ακέραια, και 'b' είναι το μικρότερο από τα θετικά ακέραια σε μια λίστα. Αν δεν υπάρχουν αρνητικά ή θετικά ακέραια, επιστρέφει ως None. Παραδείγματα: μεγαλύτερο_μικρότερο_ολόκληρο[2, 4, 1, 3, 5, 7]) == (Κανένας, 1) μεγαλύτερο_μικρότερο_ολόκληρο (([]) == (Κανένας, Κανένας) μεγαλύτερο_μικρότερο_ολόκληρο (([0]) == (Κανένας, Κανένας) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"Δημιουργήστε μια συνάρτηση που παίρνει ακέραιους αριθμούς, πλωτές μονάδες ή σειρές που αντιπροσωπεύουν πραγματικούς αριθμούς και επιστρέφει τη μεγαλύτερη μεταβλητή στον δεδομένο τύπο μεταβλητής. Επιστρέφει None αν οι τιμές είναι ίσες. Σημείωση: Εάν ένας πραγματικός αριθμός αντιπροσωπεύεται ως μια σειρά, το πλωτό σημείο μπορεί να είναι . ή , compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Αξιολογήστε αν ο δοθέντος αριθμός n μπορεί να γραφτεί ως το άθροισμα ακριβώς 4 θετικών ζυγικών αριθμών Παράδειγμα is_equal_to_sum_even (αθροιστικό) 4) == Λάθος is_equal_to_sum_even (αθροιστικό) 6) == Λάθος is_equal_to_sum_even (αθροιστικό) 8) == Αλήθεια \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"Το βραζιλιάνικο παραγοντικό ορίζεται ως: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! όπου n > 0 Για παράδειγμα: >>> special_factorial(4) 288 Η συνάρτηση θα λάβει έναν ακέραιο αριθμό ως είσοδο και θα πρέπει να επιστρέψει το ειδικό παραγοντικό αυτού του ακέραιου αριθμού. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_Παράδειγμα-3να κείμενο στη σειρά κειμένων, αντικαταστήστε όλα τα κενά με υπογράμματα, και αν μια σειρά έχει περισσότερα από 2 διαδοχικά κενά, τότε αντικαταστήστε όλα τα διαδοχικά κενά με - fix_spaces ((\"παράδειγμα\") == \"παράδειγμα\" fix_spaces ((\"παράδειγμα1\") == \"παράδειγμα1\" fix_spaces ((\"παράδειγμα2\") == \"_παράδειγμα_2\" fix_spaces ((\"παράδειγμα 3\") == \"_παράδειγμα-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Δημιουργήστε μια συνάρτηση που παίρνει μια σειρά που αντιπροσωπεύει το όνομα ενός αρχείου, και επιστρέφει \"Ναι\" αν το όνομα του αρχείου είναι έγκυρο, και επιστρέφει \"Όχι\" διαφορετικά. Ένα όνομα αρχείου θεωρείται έγκυρο αν και μόνο αν πληρούνται όλες οι ακόλουθες προϋποθέσεις: - Δεν πρέπει να υπάρχουν περισσότερα από τρία ψηφία ('0'-'9') στο όνομα του αρχείου. - Το όνομα του αρχείου περιέχει ακριβώς ένα σημείο '.' - Η υποσύνοδος πριν από το σημείο δεν πρέπει να είναι κενή, και αρχίζει με ένα γράμμα από το λατινικό αλφάβητο ('a'-'z' και 'A'Z'). - Η υποσύνοδος μετά από το σημείο πρέπει να είναι ένα από αυτά: ['txt', 'exe', 'lld'] Παραδείγματα: file_name_check\"(παράδειγμα.txt\") # => 'Ναι' file_name_check\"{example.txt1} => 'Όχι' (το όνομα πρέπει να αρχίζει με ένα λατινικό αλφάβητο) # => 'Όχι' (το όνομα πρέπει να αρχίζει με ένα λατινικό αλφάβητο)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" Αυτή η συνάρτηση θα λάβει μια λίστα από ακέραιους αριθμούς. Για όλες τις καταχωρήσεις στη λίστα, η συνάρτηση θα τετραγωνίσει την ακέραιη καταχώρηση αν ο δείκτης της είναι πολλαπλάσιος του 3 και θα τοποθετήσει στο τρίγωνο την ακέραιη καταχώρηση αν ο δείκτης της είναι πολλαπλάσιος του 4 και όχι πολλαπλάσιος του 3. Η συνάρτηση δεν θα αλλάξει τις καταχωρήσεις στη λίστα των οποίων οι δείκτες δεν είναι πολλαπλάσιος του 3 ή 4. Η συνάρτηση θα επιστρέψει το άθροισμα όλων των καταχωρήσεων. Παραδείγματα: Για lst = [1,2,3] η έξοδος θα πρέπει να είναι 6 Για lst = [] η έξοδος θα πρέπει να είναι 0 Για lst = [-1,-5,2,-1,-5] η έξοδος θα πρέπει να είναι -126 \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Σας δίνεται μια σειρά που αντιπροσωπεύει μια πρόταση, η πρόταση περιέχει μερικές λέξεις χωρισμένες με ένα κενό, και πρέπει να επιστρέψετε μια σειρά που περιέχει τις λέξεις από την αρχική πρόταση, των οποίων τα μήκη είναι πρώτοι αριθμοί, η σειρά των λέξεων στη νέα σειρά θα πρέπει να είναι η ίδια με την αρχική. Παράδειγμα1: Εισροχή: πρόταση = \"Αυτή είναι μια δοκιμή\" Έξοδος: \"είναι\" Παράδειγμα2: Εισροχή: πρόταση = \"αφήστε να πάμε για κολύμπι\" Έξοδος: \"πάμε για\" Περιορισμοί: * 1 <= len(sentence) <= 100 * Η πρόταση περιέχει μόνο γράμματα \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"Το έργο σας είναι να εφαρμόσετε μια συνάρτηση που θα απλοποιήσει την έκφραση x * n. Η συνάρτηση επιστρέφει Αληθινό αν x * n αξιολογείται σε έναν ακέραιο αριθμό και Αληθινό διαφορετικά. Και τα δύο x και n, είναι συμβολισμός γραμμής ενός κλάσματος, και έχουν την ακόλουθη μορφή, < αριθμητής>/< παρονομαστής> όπου και ο αριθμητής και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί. Μπορείτε να υποθέσετε ότι x και n είναι έγκυρα κλάσματα και δεν έχουν μηδέν ως παρονομαστή. απλοποιήστε.\"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"Γράψτε μια συνάρτηση που ταξινομεί την παραχωρημένη λίστα των ακέραιων αριθμών σε ανοδική σειρά σύμφωνα με το άθροισμα των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα με βάση τον δείκτη τους στην αρχική λίστα. Για παράδειγμα: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"Γράψτε μια συνάρτηση που παίρνει ένα πίνακα αριθμών ως εισροή και επιστρέφει τον αριθμό των στοιχείων στο πίνακα που είναι μεγαλύτερο από 10 και τα δύο πρώτα και τελευταία ψηφία ενός αριθμού είναι αμόρφωτα (1, 3, 5, 7, 9). Για παράδειγμα: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"Σας δίνεται ένας θετικός ακέραιος αριθμός n. Πρέπει να δημιουργήσετε έναν πίνακα ακέραιων αριθμών α μήκους n. Για κάθε i (1 ‰¤ i ‰¤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέφει τον αριθμό των τριπλών (a[i], a[j], a[k]) του α όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3. Παράδειγμα: Εισροχή: n = 5 Έξοδος: 1 Εξηγή: a = [1, 3, 7, 13, 21] Το μόνο έγκυρο τριπλό είναι (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλησιέστερος στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτης, στη συνέχεια η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός, ο Ποσειδώνας. Γράψε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως χορδές πλανήτης1 και πλανήτης2. Η συνάρτηση θα πρέπει να επιστρέψει μια συστοιχία που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένες από την εγγύτητα προς τον ήλιο. Η συνάρτηση θα πρέπει να επιστρέψει μια κενή συστοιχία αν ο πλανήτης1 ή ο πλανήτης2 δεν είναι σωστοί ονόματα πλανητών. Παραδείγματα bf\"(Δία\", \"Νέπτωνας\") ==> (\"Σαμήνας\"), bf\"(Δία\", \"Ασφαίρης\") ==>'''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Γράψτε μια συνάρτηση που δέχεται μια λίστα με συμβολοσειρές ως παράμετρο, διαγράφει τις συμβολοσειρές που έχουν ακανόνιστο μήκος από αυτήν, και επιστρέφει την προκύπτουσα λίστα με μια ταξινομημένη σειρά. Η λίστα είναι πάντα μια λίστα με συμβολοσειρές και ποτέ μια σειρά αριθμών, και μπορεί να περιέχει διπλότυπα. Η σειρά της λίστας θα πρέπει να είναι ανοδική κατά μήκος κάθε λέξης, και θα πρέπει να επιστρέψετε τη λίστα ταξινομημένη με αυτόν τον κανόνα. Αν δύο λέξεις έχουν το ίδιο μήκος, ταξινομήστε τη λίστα αλφαβητικά. Η συνάρτηση θα πρέπει να επιστρέψει μια λίστα με συμβολοσειρές σε ταξινομημένη σειρά. Μπορείτε να υποθέσετε ότι όλες οι λέξεις θα έχουν το ίδιο μήκος. Για παράδειγμα: assert list_sort[\"aa\", \"a\", \"aaa\"])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν n είναι ένας πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y διαφορετικά.\"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''Δίνοντας μια λίστα αριθμών, επιστρέφει το άθροισμα των τετραγώνων των αριθμών της λίστας που είναι αμόριοι. Αγνοήστε αριθμούς που είναι αρνητικοί ή όχι ακέραιοι. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Εάν η λίστα εισόδου είναι κενή, επιστρέφει 0. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"Νομίζω ότι όλοι μας θυμόμαστε αυτό το συναίσθημα όταν το αποτέλεσμα κάποιου πολυαναμενόμενου γεγονότος είναι επιτέλους γνωστό. Τα συναισθήματα και οι σκέψεις που έχετε εκείνη τη στιγμή αξίζουν σίγουρα να σημειωθούν και να συγκριθούν. Το καθήκον σας είναι να καθορίσετε αν ένα άτομο μάντεψε σωστά τα αποτελέσματα ενός αριθμού αγώνων. Σας δίνονται δύο συστοιχίες βαθμολογιών και μαντεψιών ίσης διάρκειας, όπου κάθε δείκτης δείχνει μια αντιστοιχία. Επιστρέψτε μια συστοιχία του ίδιου μήκους που υποδηλώνει πόσο μακριά ήταν κάθε μαντεψία. Αν μαντέψατε σωστά, η τιμή είναι 0, και αν όχι, η τιμή είναι η απόλυτη διαφορά μεταξύ της μαντεψίας και του σκορ.\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Θα σας δοθεί το όνομα μιας τάξης (μια σειρά) και μια λίστα με επεκτάσεις. Οι επεκτάσεις θα χρησιμοποιηθούν για να φορτώσετε πρόσθετες τάξεις στην τάξη. Η ισχύς της επεκτάσεως είναι η εξής: Ας είναι η CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επεκτάσεως, και ας είναι η SM ο αριθμός των μικρών γραμμάτων στο όνομα της επεκτάσεως, η ισχύς δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επεκτάση και να επιστρέψετε μια σειρά με αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια ισχύ, θα πρέπει να επιλέξετε την πρώτη που εμφανίζεται στη λίστα. Για παράδειγμα, αν σας δοθεί \"Slices\" ως τάξη και μια λίστα με τις επεκτάσεις: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] τότε θα πρέπει να επιστρέψετε 'Slices.SEviRNGSliCes' επειδή η επεκτάση είναι η ισχυρότερη (πτωση: 'AA_Beats'), για παράδειγμα: 'AA_class' είναι η ισχυρότερη', για την επεκτάση 'AA_Class' (ε ισχυρότερη_).\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Σας δίνονται 2 λέξεις. Πρέπει να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσύνδεση στην πρώτη λέξη cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"Δίνοντας έναν ακέραιο αριθμό, επιστρέφει ένα tuple που έχει τον αριθμό των ζυγών και των αμόριων ψηφίων αντίστοιχα.\"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"Δίνοντας ένα θετικό ακέραιο, πάρτε το ισοδύναμο του ρωμαϊκού αριθμού ως μια σειρά, και επιστρέψτε το σε μικρογράφημα.\"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''Δίνοντας τα μήκη των τριών πλευρών ενός τριγώνου. Επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο μια γωνία είναι ορθογώνιο ή 90 μοίρες. Παράδειγμα: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"Γράψτε μια συνάρτηση που δέχεται μια λίστα με συμβολοσειρές. Η λίστα περιέχει διαφορετικές λέξεις. Επιστρέφει τη λέξη με τον μέγιστο αριθμό μοναδικών χαρακτήρων. Αν οι πολλαπλές συμβολοσειρές έχουν τον μέγιστο αριθμό μοναδικών χαρακτήρων, επιστρέφει αυτόν που έρχεται πρώτος στη λεξικογραφική σειρά.\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Είσαι ένα πεινασμένο κουνέλι, και έχεις ήδη φάει ένα ορισμένο αριθμό καρότων, αλλά τώρα πρέπει να φας περισσότερα καρότα για να ολοκληρώσεις τα γεύματα της ημέρας. θα πρέπει να επιστρέψεις μια σειρά από [συνολικός αριθμός των καρότων που έχουν καταναλωθεί μετά τα γεύματα, ο αριθμός των καρότων που απομένουν μετά τα γεύματα ] αν δεν υπάρχουν αρκετά εναπομείναντα καρότα, θα φας όλα τα εναπομείναντα καρότα, αλλά θα είσαι ακόμα πεινασμένος. Παράδειγμα: * τρώω ((5, 6, 10) -> [11, 4] * τρώω ((4, 8, 9) -> [12, 1] * τρώω ((1, 10, 10) -> [11, 0] * τρώω ((2, 11, 5) -> [7, 0] Κλίμακες: @number: ακέραιο αριθμό των καρότων που έχετε φάει. @need: ακέραιο αριθμό των καρότων που πρέπει να φάτε. @remaining: ακέραιο αριθμό των εναπομείναντων καρότων που υπάρχουν στο απόθεμα: *constrain: 0 = <= 0 * <= 1000 * <= 0 = <= 1000 * resting:>\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"Οι βασικές αλγεβρικές πράξεις: Προσθήκη (+) Υποβολή (-)) Πολλαπλασιασμός (-)) Χωρισμός (-)) Χειρισμός (-)) Διάσπαση (-)) Εκθέτηση (**) Παράδειγμα: Λειτουργός['+', '*', '-'] πίνακας = [2, 3, 4, 5] αποτέλεσμα = 2 + 3 * 4 - 5 => αποτέλεσμα = 9 Σημείωση: Το μήκος της λίστας των χειριστών είναι ίσο με το μήκος της λίστας των χειριστών μείον ένα. Η λίστα των χειριστών είναι μια λίστα μη αρνητικών ακέραιων. Η λίστα των χειριστών έχει τουλάχιστον έναν χειριστές και η λίστα των χειριστών έχει τουλάχιστον δύο χειριστές. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"Σας δίνεται μια αλυσίδα s. αν s[i] είναι ένα γράμμα, αντιστρέψτε την κεντρική της από κάτω προς πάνω ή αντίστροφα, αλλιώς κρατήστε την όπως είναι. Αν η αλυσίδα δεν περιέχει γράμματα, αντιστρέψτε την αλυσίδα. Η συνάρτηση θα πρέπει να επιστρέψει την προκύπτουσα αλυσίδα. Παραδείγματα λύση ((\"1234\") = \"4321\" λύση ((\"ab\") = \"AB\" λύση ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"Εάν η string είναι κενή, επιστρέφει None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "ell_Grek",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"Με δεδομένους δύο θετικούς ακέραιους αριθμούς α και β, επιστρέφουμε τους ζυγούς αριθμούς μεταξύ α και β, με ανοδική σειρά.\"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]