task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,ltg_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Pīmiņ: >>> ir_pīci_elementi (([1.0, 2.0, 3.0], 0.5) napareizs >>> ir_pīci_elementi (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) patīss """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,ltg_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Itys funkcejis īejis ir strings, kas satur vairuokys īkļautuos vītnīkuos vītnīkuos grupys. Tovs mierkis ir atdaleit ituos grupys atseviškūs vītnīkuos i atsagrīzt tūs sarokstā. Atseviškys grupys ir izbalanceitys (kotra atvārtuo vītnīkuota vītnīka vītnīks ir pareizi aiztaiseits) i nav īkļautys vīna ūtra īkļautajā vītnē. Pīmārs: >>> separate_paren_groups' ((( ) (() (()))))) ' [' ((() ', '(()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,ltg_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Atdūdūt pozitivu svorbulam punktu skaitli, tū var sadaleit i vasalūs skaitļu daļā (leluokais vasals skaitlis mozuoks par nūteiktu skaitli) i decimalūs skaitļūs (atstuotī skaitli vysod mozuoki par 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,ltg_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Teik dots īdeve i izjimšonys darbeibu saroksts bankys kontā, kas suocās ar nullu saldo. Tovs uzdavums ir atkluot, voi kaidā šaļtī konta saldo krīt zamuok par nuli, i tamā šaļtī funkcejai juobyut patīsai. Cytaidā gadīnī juobyut napareigai. Pīmārs: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,ltg_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Par nūteiktu īejis skaitļu sarokstu apriekinoj videjuo absolutuo atškireiba ap ituo datu kūpa videjuo. Vydsaceitais absolutuo atškireiba ir videjuo absolutuo atškireiba storp kotru elementu i centra punktu (dažaidā gadīnī - videjuo): MAD = vidējais. x - x_means. Pīmārs: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,ltg_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Īvītuot skaitli ""delimiteru"" storp kotrim divom secūšom īejis saroksta elementim `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,ltg_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Itys funkcejis īejis ir strings, kas ir vairuokys grupys, kas ir īkļauti īkļautajūs korpusūs, kas atškireiti ar atstarpeibom. Kotrai nu grupys izdavums ir īkļautys īkļautūs korpusūs dziļuokais leimiņs. Pīmāram, (() (()) ir maksimāli diveji īkļautūs leimiņi, bet ((())) ir treis. >>> parse_nested_parens (('((()) ((())) () (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,ltg_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtrēt īejis stringu sarokstu tikai par tim, kas satur nūteiktu apakšsaciņu >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,ltg_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Daļa skaitļu, kas ir atkuortuoti ar vītnīkvuordu, ir vītnīkvuordu, kas ir vītnīkvuordu summa, kas ir vītnīkvuordu reizynuojums. Vītnīkvuordu summa ir 0, vītnīkvuordu reizynuojums ir 1 (..) (), (..) (), (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (..) (.. ..) (.. ..) (.. ..) (.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..""""""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,ltg_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Nu nūteikta vasalūs skaitļu saroksta izveiduot vierteiguo maksimuma elementu sarokstu, kas atrosti leidz nūteiktam sekveņcis momentam. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,ltg_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Atrodi īsū palindromu, kas suocās ar nūdrukuotū ryndkūpu. Algoritma ideja ir vīnkuorša: - atrodi ilgū palindromu ryndkūpu, kas ir palindroms. - pīlīk ryndkūpa beiguos ryndkūpa preteju, kas ir pyrma palindromu sufiksa. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Pīsavieršonai, voi nūteikta string ir palindroms .""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,ltg_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Īeja ir div kuortys a i b, kas sastuov nu 1 i 0. Izpiļdeit binaruos XOR iz itim īejom i atsyuteit rezultatu ari kai kuortu. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,ltg_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Nu stringu saroksta atsoka garuokū. Atdūd pyrmū, ka ir vairuokys vīna veida stringys. Atdūd nivīnu, ka īejis saroksts ir tukšs. >>> garuokais (([]) >>> garuokais ((['a', 'b', 'c']) 'a' >>> garuokais ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,ltg_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Atdūd leluokū kūpeigū daleituoju nu diveju vasalūs skaitļu a i b >>> leluokais_kūpš_daleituojs ((3, 5) 1 >>> leluokais_kūpš_daleituojs ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,ltg_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Atvier vysa īlyuguma stringys prefiksu saroksts nu īsokuos da garuokuos >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,ltg_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Atdūd ryndys, kas satur telpā īrūbežuotys skaitļus, suocūt nu 0 leidz n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,ltg_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Daļa string, atrodi, cik daudz atsevišku raksturu (naatkareigi nu burtu) tys sastuov nu >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,ltg_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Itys ir īejis funkceja ir saitis, kas attāluos muzykys notys specialuos ASCII formats. Tovs uzdavums ir analizēt saitis sarokstu ar vasalu skaitli, kas atbylst daudzim bejsim. Ite ir legendys: 'o' notys, pādejuos četruos bejsim 'o' - puse notys, pādejuos divejuos bejsim ' - catūrtuos notys, pādejuos vīna bejsim >>> parse_music. 'o o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,ltg_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Atrodi, cik reižu īteiktuos apakšsaitis var atrast suokūtnejā saitis saitejā. Apsaver puorsakluojūšus gadīņus. >>> cik_viņ_reižu('', 'a') 0 >>> cik_viņ_reižu('aaa', 'a') 3 >>> cik_viņ_reižu('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,ltg_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Īeja ir telpā īrūbežuota skaitļu kuoda nu ""nulys"" leidz ""nou. "" Lykumeigys izvēlis ir ""nulys"", ""vīns"", ""divi"", ""treis"", ""četri"", ""pieci"", ""seši"", ""septi"", ""oši"" i ""nou"". Atdūd kuodu ar skaitlim, kas sakuortuoti nu mozuoka leidz leluokajam >>> sort_numbers ((""treis vīns pīcys"") ""vīns treis pīcys"" """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,ltg_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Nu pīguoduotuo skaitļu saroksta (nu vysmoz diveju garuma) izavielej i atsoka divejus, kas ir tyvuok vīns ūtram, i atsoka tūs seceibā (mozuokais skaitlis, leluokais skaitlis). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,ltg_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Dūt skaitļu sarokstu (nu vysmoz diveju elementu), pīlītuot tam linearū transformaceju, kab mozuokais skaitlis palyktu par 0, leluokais palyktu par 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,ltg_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filtrs nūruodeits sevkura pythona vierteibu saroksts tikai par vasalūs skaitļu >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,ltg_Latn,python,"

def strlen(string: str) -> int:
    """"""Atguodynojūt datu kuortu >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,ltg_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Par nūteiktu skaitli n atrassim leluokū skaitli, kas dal n vīnlaiceigi, mozuokū par n >>> leluokū_daleituoju ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,ltg_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Atdūd dati par īdūtu vasalu skaitli, kas ir pyrmskaitļu reizynuotuoji, kas ir nūgrīzīti nu mozuokūs leidz leluokim. Kotram faktoram juopīroksta reizynuojumu skaits, kas atbylst tūreizei, cik bīži tys pasaruoda faktorizē. Īeja skaitlim juobyun vīnaidam ar vysu faktoru reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotuoju reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuotu reizynuynuynuynuynuynuynuynuynuynu""""""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,ltg_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Nu vasalūs skaitļu saroksta nūjimt vysus elementus, kas pasaruoda vairuok kai vīnu reizi. Īmekliej elementu kuorteibu, kai īvestā. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,ltg_Latn,python,"

def flip_case(string: str) -> str:
    """"""Par nūteiktu šniru, mainuos burtu burtus puorsavierš iz lelu i lelu iz mozu. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,ltg_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Konkatenēt stringu sarokstu vīnā stringā >>> konkatenēt (([]) '' >>> konkatenēt ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,ltg_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtrēt īejis stringu sarokstu tikai par tim, kas suoc ar nūteiktu prefiksu. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,ltg_Latn,python,"

def get_positive(l: list):
    """"""Atdūd tikai pozitivus skaitļus sarokstā. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,ltg_Latn,python,"

def is_prime(n):
    """"""Atgriež patīsu, ka nūteikts skaitlis ir pyrmais, i nā cytaiži. >>> ir_ pyrmais (..) (6) Nā >>> ir_ pyrmais (..) 101) Patīsu >>> ir_ pyrmais (..) 11) Patīsu >>> ir_ pyrmais (..) 13441) Patīsu >>> ir_ pyrmais (..) 61) Patīsu >>> ir_ pyrmais (..) 4) Nā >>> ir_ pyrmais (..) 1) Nā """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,ltg_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs ir polinoma koeficienti. find_zero atrūn x taidu, ka poly(x) = 0. find_zero atdūd tik tikai nulli punktu, pat ka tī ir daudz.""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Izvierzej polinomu ar koeficientim xs punktā x. atsoka xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,ltg_Latn,python,"

def sort_third(l: list):
    """"""Itei funkceja pajam sarakstu l i atdūd sarakstu l', kab l' byutu identisks ar l indeksuos, kurūs nav daleibys ar treis, bet tuos vierteibys indeksuos, kurys ir daleibys ar treis, byutu vīnaidys ar l indexu vierteibom, bet sareikuotys. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,ltg_Latn,python,"

def unique(l: list):
    """"""Atguodynoj sakuortuotus unikaluos vīneigūs elementu saraksteibu >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,ltg_Latn,python,"

def max_element(l: list):
    """"""Atdūd leluokū elementu sarokstā. >>> max_element([1, 2, 3]) 3 >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,ltg_Latn,python,"

def fizz_buzz(n: int):
    """"""Atdūd cipra 7 reižu skaitu, kod tys pasaruoda vītom, kur skaitli ir mozuoki par n, kas ir daleigi ar 11 voi 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,ltg_Latn,python,"

def sort_even(l: list):
    """"""Itei funkceja pajam sarakstu l i atdūd sarakstu l', kab l' byutu identisks l najaušajuos indeksūs, bet tuos vierteibys reizis indeksūs byutu vīnaidys ar l reizis indeksu vierteibom, bet sakuortuotys. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,ltg_Latn,python,"

def encode_cyclic(s: str):
    """"""īejis stringam kodāts ar encode_cyclic funkceju. Atdūd dekodātu stringu. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""atnese kodātu seceibu piec treju raksturu ciklu grupom. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,ltg_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib atdūd n-ū skaitli, kas ir Fibonači skaitlis i tys ir ari pyrmskaitlis. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,ltg_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero pījam vasalūs skaitļu sarokstu kai īejis datus. Tys atdūd patīsu, ka sarokstā ir treis atškireigi elementi, kuru summa ir nulle, i nā, ka nav. >>> triples_sum_to_zero([1, 3, 5, 0]) Nā >>> triples_sum_to_zero[(1, 3, -2, 1]) Patīseiga >>> triples_sum_to_zero([1, 2, 3, 7]) Napateiga >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) Patīseiga >>> triples_sum_to_zero[1]) Napateiga """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,ltg_Latn,python,"

def car_race_collision(n: int):
    """"""Pīminēsim ceļu, kas ir piļneigi taisna bezgaleigi gara līta. n mašynys brauc kreisā pa labi; reizē cyts n mašynys kūps ir brauc pa labi pa kreisi. Obejis mašynys suocās cīši tuoluos vīna nu ūtrys. Vysys mašynys brauc ar vīnu i tū pošu dreizumu. Dūmojams, ka divejis mašynys sadurs, kod mašyna, kas brauc kreisā pa labi, sadurs ar mašynu, kas brauc pa labi pa kreisi. Tok mašynys ir bezgaleigi styprys i spieceigys; rezultatā tuos turpynoj braukt sovā trajektorī, kai ka nabyutu sadursmušys. Itei funkceja snādz itaidu sadursmu skaitu.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,ltg_Latn,python,"

def incr_list(l: list):
    """"""Atvieršona ar elementu, kas pīaug ar 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,ltg_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero pījam vasalūs skaitļu sarokstu kai īejis datus. Tys atdūd patīsu, ka sarokstā ir diveji atškireigi elementi, kuru summa ir nulle, i nā, ka nav. >>> pairs_sum_to_zero([1, 3, 5, 0]) Nā >>> pairs_sum_to_zero[(1, 3, -2, 1]) Nā >>> pairs_sum_to_zero([1, 2, 3, 7]) Nā >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) Patīsu >>> pairs_sum_to_zero[1]) Nā""""""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,ltg_Latn,python,"

def change_base(x: int, base: int):
    """"""Puormainit īejis skaitļa x skaitliskuos bazis. atdūd stringiešonys puorstuovu piec puorsavieršonys. bazis skaitli ir mozuoki par 10. >>> maineit_bazē{\displaystyle \mathbb {{\displaystyle \mathbb {\displaystyle \mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {\mathbb {} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }""""""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,ltg_Latn,python,"

def triangle_area(a, h):
    """"""Datuots škierbu garums i augstuokais atsagrīzšonys laukums trejstūlam. >>> trejstūls_lokums{5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,ltg_Latn,python,"

def fib4(n: int):
    """"""Fib4 skaitļu seceiba ir Fibonači seceibys leidzeiga seceiba, kas ir defināta tai: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Lūdzu, pīraksteit funkceju, kab efektivi apriekinuotu fib4 skaitļu seceibys n-ū elementu. Naizmontuot rekursiju. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,ltg_Latn,python,"

def median(l: list):
    """"""Atvieršonys mediana elementu sarokstā l. >>> mediana (([3, 1, 2, 4, 5]) 3 >>> mediana (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,ltg_Latn,python,"

def is_palindrome(text: str):
    """"""Kontrolē, voi nūteikta kuorta ir palindroms >>> is_palindroms (('') Traiņais >>> is_palindroms (('aba') Traiņais >>> is_palindroms (('aaaaa') Traiņais >>> is_palindroms (('zbcd') Meklēt """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,ltg_Latn,python,"

def modp(n: int, p: int):
    """"""Atvītot 2^n modulo p (apzynuoti skaitli). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,ltg_Latn,python,"

def encode_shift(s: str):
    """"""īnese kodātuos stringys ar encode_shift funkceju. Atdūd dekodātu string. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""atnese kodātu ryndys, nūvierzejūt kotru burtu ar 5 alfabetā.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,ltg_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels ir funkceja, kas pajam string i atdūd string bez vokalom. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,ltg_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Atgriež patīsu, ka vysi skaitli sarokstā l ir zam kuortys t. >>> below_threshold (([1, 2, 4, 10], 100) Patīsu >>> below_threshold (([1, 20, 4, 10], 5) Napareižu """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,ltg_Latn,python,"

def add(x: int, y: int):
    """"""Sajimsim div skaitļus x i y >>> sajimsim ((2, 3) 5 >>> sajimsim ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,ltg_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Pīsavērt, voi divejim vuordim ir vīnaidi rakstīni. >>> same_chars('eabcdzzzz', 'dddzzzzzzdeddabc') Tiks >>> same_chars('abcd', 'dddddddabc') Tiks >>> same_chars('dddddddabc', 'abcd') Tiks >>> same_chars('eabcd', 'dddddddddabc') Mins >>> same_chars('abcd', 'dddddddabddce') Mins >>> same_chars'(abcdzzzz', 'dddzzzzzzdddabc') Mins """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,ltg_Latn,python,"

def fib(n: int):
    """"""Atdūd n-ū Fibonači skaitli. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,ltg_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets ir ""<"" i "">"" string. return True, ja kotram suocūtam bracketam ir atbylstūšs beidzamais bracket. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,ltg_Latn,python,"

def monotonic(l: list):
    """"""Atgriež patīsu, ka saroksta elementi monotoni pīaug voi samazynoj. >>> monotoniski (([1, 2, 4, 20]) Patīsu >>> monotoniski (([1, 20, 4, 10]) Naatkareigi >>> monotoniski (([4, 1, 0, -10]) Patīsu """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,ltg_Latn,python,"

def common(l1: list, l2: list):
    """"""Atdūd div sarokstu sarokstātūs unikalu kūpeigu elementu. >>> kūpeigs (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> kūpeigs (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,ltg_Latn,python,"

def largest_prime_factor(n: int):
    """"""Atdūd leluokū pyrmskaitļa faktoru n. Piejimsim, ka n > 1 i tys nav pyrmskaitlis. >>> leluokais_ pyrmskaitļa_ faktors ((13195) 29 >>> leluokais_ pyrmskaitļa_ faktors ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,ltg_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n ir funkceja, kas saskait numurus nu 1 leidz n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,ltg_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets ir ""("" i """") string. return True, ja kotram suocūtam bracketam ir atbylstūšs beidzamais bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,ltg_Latn,python,"

def derivative(xs: list):
    """"""xs ir polinoma koeficienti. xs[0] + xs[1] * x + xs[2] * x^2 + .... atsoka polinoma atvasynuotuoju taidu pošu formu. >>> atvasynuotuoja (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> atvasynuotuoja (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,ltg_Latn,python,"

def fibfib(n: int):
    """"""FibFib skaitļu seceiba ir Fibbonači seceibys leidzeiga seceiba, kas ir defināta tai: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).""""""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,ltg_Latn,python,"
FIX = """"""Rakstīt funkceju vowels_count, kas īnese vuordu kai īejis viļcīni i atdūd vuordu viļcīņa vokalu skaitu. Vuordi itymā gadīnī ir 'a', 'e', 'i', 'o', 'u'. Ite ari 'y' ir vokals, bet tik tod, kod tys ir nūteiktūs vuordu beiguos. Pīmārs: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Papyldynuot testu gadīņus.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,ltg_Latn,python,"
def circular_shift(x, shift):
    """"""Apkūpis puorviers puorejim ciparim, puorviers ciparus pa labi i atsoka rezultatu kai ryndys. Ka puorviers > ciparu skaits, atsoka ciparus apgrīzt. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,ltg_Latn,python,"
def digitSum(s):
    """"""Nūdarbeibys Raksteit funkceju, kas īejis vuordineicai pījam string i atdūd tikai augšūs burtu summu' ASCII kodus. Pīmāri: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,ltg_Latn,python,"
def fruit_distribution(s,n):
    """"""Itymā uzdavumā jums tiks nūdrūsynuota rynds, kas apzeimoj ols i oranžis skaitu, kas ir izplateiti augļu kuortā. Itymā kuortā ir ols, ols i mango augļi. Dūdūt ryndys, kas apzeimoj kūpeju ols i ols skaitu, i vasalu skaitli, kas apzeimoj kūpeju augļu skaitu kuortā, atsyuti mango augļu skaitu kuortā. pīmāram: fruit_distribution""5(olys i 6 ols"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 ols i 1 ols"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 ols i 3 ols"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 ols i 1 ols"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,ltg_Latn,python,"
def pluck(arr):
    """"""""Dūdūt masvu, kas ir vīna nu kūka nūdaļu, kur ir naeneigi vasals skaitlis, tev ir juopuorskaita vīns nu nūdaļu i juopuorskaita atpakaļ. Izjimtam nūdamam juobyut nūdamam ar mozuokū pat vierteibu. Ka ir atrosts vairuoki nūdaļu ar vīnu i tū pošu mozuokū pat vierteibu, juopuorskaita nūdaļa ar mozuokū indeksu. Izjimtam nūdamam juopuorskaita nūdaļa sarokstā, [smallest_value, its index] , Ka nav pat vierteibu voi nūteiktais masvs ir tukšs, juopuorskaita []. pīmārs: 1: īeja: [4,2,3] izeja: [2, 1] skaidruojums: 2 ir mozuokuo pat vierteiba, i 2 ir mozuokais indekss. pīmārs: 2: īeja: [1,2,3] izeja: [2, 1] skaidruojums: 2 ir mozuokuo pat vierteiba, i 2 ir mozuokais pat indekss. pīmārs: īeja: [1, 2, 2, 3] izeja: [1, 2] izeja: [0, 3 izeja: 0, 4] izeja: 1 ir mozuokais nūdaļa ar mozuokū pat vierteibu, bet indekss ir mozuokūks, nu ir 0, kod ir 0, nu nu tys ir pyrmais.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,ltg_Latn,python,"
def search(lst):
    '''Teik dots na tukšs pozitivu vasalūs skaitļu saroksts. Atdūd leluokū vasalū skaitli, kas ir leluoks par nulle i kura bīžums ir leluoks par voi vīnaids ar vasalū skaitli pošu. Vasalū skaitli bīžums ir tys, cik reižu tys pasaruoda sarokstā. Ka taida vierteiba nav, atsoka -1. Pīmāri: meklēt ([4, 1, 2, 2, 3, 1]) == 2 meklēt ([1, 2, 2, 3, 3, 3, 4, 4]) == 3 meklēt ([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,ltg_Latn,python,"
def strange_sort_list(lst):
    '''Pīmāram: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,ltg_Latn,python,"
def triangle_area(a, b, c):
    '''Atvītōj trejstūša viersa laukumu apgrīžam leidz 2 decimalajim punktim, ja treis viersa veidoj dereigu trejstūšu. Cytaidā gadīnī atvītōj -1 Treis viersa veidoj dereigu trejstūšu, kod sevkura divu viersa summa ir leluoka par trešū viersa laukumu. Pīmārs: trejstūša_viersa_viersa ({3, 4, 5) == 6.00 trejstūša_viersa ({1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,ltg_Latn,python,"
def will_it_fly(q,w):
    '''Rakstīt funkceju, kas atdūd patīsu, ka objekts q lidoj, i nā, ka nav. Objekts q lidoj, ka tys ir balansāts (tei ir palindromu saroksts), i tuo elementu summa ir mozuoka par voi vīnaida ar maksimaluo īspiejamais svars w. Pīmārs: will_it_fly (([1, 2], 5) â -> False # 1+2 ir mozuoka par maksimaluo īspiejamais svars, bet tys ir naizbalanceits. will_it_fly (([3, 2, 3], 1) â -> False # tys ir balansāts, bet 3+2+3 ir leluoks par maksimaluo īspiejamais svars. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 ir mozuoks par maksimaluo īspiejamais svars, i tys ir balansāts. will_it_fly ((([3], â 5) -> True # 3 ir mozuoks par maksimaluo īspiejamais svars, i tys ir balansāts '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,ltg_Latn,python,"
def smallest_change(arr):
    """"""Ar integeru viersrokstu, atrodi minimumu elementu skaitu, kas juomaina, kab viersroksts byutu palindroms. Palindroms viersroksts ir viersroksts, kas teik skaiteits taipoš atpakaļ i iz prīšku. Vīnā izmainā tu vari izmaineit vīnu elementu ar sevkuru cytu elementu. Pīmāram: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,ltg_Latn,python,"
def total_match(lst1, lst2):
    '''Rakstīt funkceju, kas pījam divejus stringim saisteitus sarokstus i atdūd sarokstu, kurā vysūs stringūs ir mozuok burtu, nakai cytā sarokstā. Ka obejūs sarokstūs ir vīnaids burtu skaits, atsoka pyrmū sarokstu. pīmāri total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['i', 'hi', 'hi']) â -> ['hI', 'hi'], 'hi'_match ((['4'], ['1'', '2'', '3'', '4'], ['5']) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,ltg_Latn,python,"
def is_multiply_prime(a):
    """"""Rakstīt funkceju, kas atdūd patīsu, ka dāts skaitlis ir 3 pyrmskaitļu reizynuojums, bet cytaiž - napareizs.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,ltg_Latn,python,"
def is_simple_power(x, n):
    """"""Tavs aizdavums ir raksteit funkceju, kas atdūd patīsu, ka skaitlis x ir vīnkuorša n spāka, bet cytuos gadīņūs - napareizu. x ir vīnkuorša n spāka, ka n**int=x. Pīmāram: ir_ vīnkuorša_spāka (s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_s_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t""""""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,ltg_Latn,python,"
def iscube(a):
    '''Rakstīt funkceju, kas pījam vasalu skaitli a i atdūd patīsu, ka itys skaitlis ir vasalu skaitļu kubs.'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,ltg_Latn,python,"
def hex_key(num):
    """"""Tevi ir īdūta īspieja pīraksteit funkceju, kas sajam heksadecimalu skaitli kai snīgumu i skaita heksadecimalu cyparu skaitu, kas ir pyrmskaitli (pirmskaitlis voi pyrmskaitlis ir dabiskais skaitlis, kas ir leluoks par 1, kas nav divu mozuoku dabiskūs skaitļu reizynuojums). Heksadecimalu cypari ir 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Pīprīmi skaitli ir 2, 3, 5, 7, 11, 13, 17,... Tevi ir juodūmoj, ka juodūmoj, ka īejis skaitlis vysod ir pareizs voi tukšs, i A, B, C, D, E, F simboli vysod ir golvonuo burta. Pīmāri: ""AB"" numam izīme nummārs ir 1, ""AB"" izīme nummārs ir 1, ""AB"" izīme nummārs ir 10, ""AB"" izīme nummārs ir 2, ""AB"" izīme nummārs ir 1, ""AB"" izīme nummārs ir 4, ""AB"" izīme nummārs ir 6,01289 ""AB"" izīme nummārs ir 6,045 ""EFD"" izīme ir 6,0"".""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,ltg_Latn,python,"
def decimal_to_binary(decimal):
    """"""Teik dots skaitlis decimalformātā, i tev ir juopuorvērsta tū binarā formatā. Funkcejai ir juosaucej burta, kur kotrs raksturs ir binars skaitlis. Kotrs raksturs burtā byus '0' voi '1'. Burta suokumā i beiguos byus puora raksturu 'db'. Papyldu raksturu ir, kab paleidzātu formatā. Pīmāri: decimal_to_binary(15) # atdūd ""db1111db"" decimal_to_binary32) # atdūd ""db100000db"" """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,ltg_Latn,python,"
def is_happy(s):
    """"""Tev ir string s. Tovs uzdavums ir puorbaudeit, voi strings ir laimeigs voi nā. Stringa ir laimeiga, ka tuo garums ir vysmoz 3 i kotri 3 uzastuošonys burti ir atškireigi. Pīmāram: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd)) => True is_happy ((aabb)) => False is_happy ((adb)) => True is_happy ((xyy)) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,ltg_Latn,python,"
def numerical_letter_grade(grades):
    """"""Itys ir pādejais semestra mieneša mienešs, i školuotuojam ir juopīteik klasifikacejis studentim. Školuotuoja ir izveiduojuse sovu klasifikacejis algoritmu. Vīneiga problema ir, ka jei ir pazaudiejuse kodu, kū jei izmontuoja klasifikacejai. Jei ir jums dabuojuse dažim školānim GPA sarokstu, i jums ir juopīroksta funkcija, kas var izveiduot burtu klasifikaceju, izmontojūt itaidu tabulu: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,ltg_Latn,python,"
def prime_length(string):
    """"""Rakstīt funkceju, kas pījam string i atnese patīsu, ka string garums ir pyrmskaitlis voi nalykumeigu, ka nav pyrmskaitļa. Pīmāri prime_length{""Lello"") == True prime_length{""abcdcba"") == True prime_length{""kittens"") == True prime_length{""orange"") == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,ltg_Latn,python,"
def starts_one_ends(n):
    """"""Atdūdūt pozitivu vasalu skaitli n, atdūd skaitli, kas ir n cyparu pozitivuos vasaluos skaitļu skaits, kas suocās voi beidzās ar 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,ltg_Latn,python,"
def solve(N):
    """"""Pīduovojūt pozitivu vasalu skaitli N, atsoka tuos cyparu kūpejū summu binarā formā. pīmārs, kod N = 1000, cyparu summa byus 1, izdavums byutu ""1"". kod N = 150, cyparu summa byus 6, izdavums byutu ""110"". kod N = 147, cyparu summa byus 12, izdavums byutu ""1100"". maineigī: @N vasals skaitlis īrūbežuojumi: 0 â‰¤ N â‰¤ 10000. izdavums: binaru skaitļu kuorta """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,ltg_Latn,python,"
def add(lst):
    """"""Dūdūt napylnu vasalūs skaitļu sarokstu, pyrmū reizi saskaiti puora elementus, kas ir najauši. Pīmāri: saskaiti (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,ltg_Latn,python,"
def anti_shuffle(s):
    """"""Rakstīt funkceju, kas pajam string i atdūd tū sakuortuotu. Kuortuotuo string verseja ir string, kur vysi vuordi (atškirami ar atstarpeņu) ir aizstuoti ar jaunu vuordu, kur vysi burti sakuortuoti augšupīaugstūšā kuortā, bolstūtīs iz ascii vierteibu. Napīmiņu: Tev ir juopītur vuordu kuorteiba i tukšys atstarpeibys teiklā. Pīmāram: anti_shuffle ((('Hi') atdūd 'Hi' anti_shuffle ((('hello') atdūd 'ehllo' anti_shuffle (('Hello World!!!') atdūd 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,ltg_Latn,python,"
def get_row(lst, x):
    """"""Teik dūti 2 dimenseju dati, kai īkļauti saroksti, kas ir leidzeigi matricam, tok, atškireibā nu matricom, kotrā ryndā var byut cyts stuovūkļa skaits. Dūdūt lst i vasalū skaitli x, atrūn vasalūs skaitļus x sarakstē i atsoka tupļu sarakstu [(x1, y1), (x2, y2) ...] taids, ka kotrs tuple ir koordinata - (rynds, kolni), suocūt ar 0. Sortoj koordinatis suokūtneji piec ryndim augšupīaugstūšā kuortā. Taipat sortoj ryndys koordinatis piec kolnu lejupīaugstūšā kuortā. Pīmāri: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (2, 5), (2, 0), get_(], 1) [] == [[ryndsoroda]], [1, 2, 3]], [2, 2]] ]]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,ltg_Latn,python,"
def sort_array(array):
    """"""Daļa ar neinegalim vasalīnim, piec sortiešonys atsagrīž ar datora kopeju, tu sortej datoru augšupījimtā kuortā, ka summa (pirmuo indeksa vierteiba, pādejuo indeksa vierteiba) ir najauša, voi sortej tū lejupījimtā kuortā, ka summa (pirmuo indeksa vierteiba, pādejuo indeksa vierteiba) ir puora.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,ltg_Latn,python,"
def encrypt(s):
    """"""Skaiti funkceju encrypt, kas par argumentu pījam string i atnese string, kas ir šifreita ar apgrīztū alfabetu. Alfabetu juopacīš taidā veidā, kab burti byutu nūgrīzuoti, reizynuodami ar divejim, iz div vītom. Par pīmāru: encrypt ((hi) atnese ""lm"" encrypt ((asdfghjkl)) atnese ""ewhjklnop"" encrypt ((gf)) atnese ""kj"" encrypt ((et)) atnese ""ix"" """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,ltg_Latn,python,"
def next_smallest(lst):
    """"""Teik dūta vasalu skaitļu saroksts. Skaitit funkceju next_smallest(), kas atdūd ūtrū mozuokū elementu sarokstā. Atdūd nullis, ka taidu elementu nav. next_smallest([1, 2, 3, 4, 5]) == 2 next_smallest([5, 1, 4, 3, 2]) == 2 next_smallest([]) == Nivīns next_smallest([1, 1]) == Nivīns """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,ltg_Latn,python,"
def is_bored(S):
    """"""Tev tiks pīduovuota vuordu seja, i tev byus juopīmiņ nu kaida laika. ""Nūkaisums"" ir vuords, kas suocās ar vuordu ""i"". Vīnu vuordu rūbežoj ar """"., ""?"" voi ""! "" . Pīmāram: >>> ir_nūkaisums (..) "" sveicynuojums (..) "" 0 >>> ir_nūkaisums (..) "" dabass ir zyls. saule spīd. maņ patyka itys laiks "") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,ltg_Latn,python,"
def any_int(x, y, z):
    '''Izstruoduot funkceju, kas pījam 3 skaitļus. Atdūd taisneibu, ka vīns nu skaitļu ir vīnaids ar puorejuo diveju summu, i vysi skaitli ir vasalī skaitli. Atdūd nalogs vysūs cytuos gadīņūs. Pīmāri any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,ltg_Latn,python,"
def encode(message):
    """"""Rakstīt funkceju, kas pījam ziņuojumu i kodē tai, kab tuos vysūs burtu golvonūs burtus apmaineitu, vysus vuokļus ziņuos aizstuovātu ar burtu, kas angļu alfabetā ir 2 vītys tuoļuok.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,ltg_Latn,python,"

def skjkasdkd(lst):
    """"""Teik dots vasals skaitļu saroksts. Tev ir juodūmoj leluokuo pyrmskaitļa vierteiba i juopuorsyun tuo cyparu summa. Pīmāri: Lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] izdavums ir 10 Lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] izdavums ir 25 Lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] izdavums ir 13 Lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] izdavums ir 11 Lst = [0,81,12,31,21] izdavums ir 3 Lst = [0,1,8,2,1,7] izdavums ir 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,ltg_Latn,python,"
def check_dict_case(dict):
    """"""Atsaverūt vuordineicu, atdūd patīsu, ka vysys klaviaturu zeimis ir mozuos voi vysys zeimis ir leluos burtu burtu zeimis, cytaiž atdūd napareizu. Funkcejai juosaver napareizi, ka dāts vuordineicys vuordineicys nav. Pīmāri: check_dict_case{""a"":""apple"", ""b"":""banana""}) juosaver patīsu. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) juosaver napareizi. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) juosaver napareizi. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) juosaver napareizi. check_dict_case{""NC"":""STATE"", ""Z"":""IP""}) juosaver patīsu.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,ltg_Latn,python,"
def count_up_to(n):
    """"""Īsyuti funkceju, kas pījam naenegai vasalu skaitli i atdūd pyrmūs n vasalu skaitļu, kas ir pyrmskaitli i mozuoki par n, maisi. Par pīmāru: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,ltg_Latn,python,"
def multiply(a, b):
    """"""Pylnynuot funkceju, kas pajam divejus vasalus skaitļus i atdūd tūs vīneibu cyparu reizynuojumu. Piejimsim, ka īejis dati vysod ir dereigi. Pīmāri: reizynuojums ((148, 412) atdūd 16, reizynuojums ((19, 28) atdūd 72. reizynuojums ((2020, 1851) atdūd 0, reizynuojums ((14,-15) atdūd 20.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,ltg_Latn,python,"
def count_upper(s):
    """"""Daļa: skait_augstūšuos burtu vokaluos burtu vuordu skaits, pīmāram: count_upper{""aBCdEf"") atdūd 1 count_upper{""abcdefg"") atdūd 0 count_upper{""dBBE"") atdūd 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,ltg_Latn,python,"
def closest_integer(value):
    '''Sastyprynoj funkceju, kas pījam vierteibu (sacu), kas apzeimoj skaitli, i atdūd tyvuokū vasalu skaitli. Ka skaitlis ir vīnaids nu diveju vasalu skaitļu, apgrīž tū nu nullis. Pīmāri >>> tyvuokais_vasalais skaitlis (((""10"") 10 >>> tyvuokais_vasalais skaitlis (((""15.3"") 15 Pastabe: Apgrīžūt nu nullis nūzeimoj, ka, ka nūteikts skaitlis ir vīnaids nu diveju vasalu skaitļu, tev atdūts tys, kas ir tuoluokais nu nullis. Pīmāram, tyvuokais_vasalais skaitlis (((14.5"") atdūd 15, bet tyvuokais_vasalais skaitlis (((-14.5"") atdūd -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,ltg_Latn,python,"
def make_a_pile(n):
    """"""Dūdams pozitivu vasalū skaitli n, tev ir juosuoc kūpums ar n leimiņu akmiņim. Pyrmajā leiminī ir n akmiņu. Nuokušajā leiminī akmiņu skaits ir: - nuokušais najaušs skaitlis, ka n ir najaušs. - nuokušais puors skaitlis, ka n ir puors. Atdūd kotrā leiminī akmiņu skaitu saraksteibā, kur i indeksa elements apzeimoj akmiņu skaitu leiminī (i+1). Pīmāri: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,ltg_Latn,python,"
def words_string(s):
    """"""Tev tiks pīduovuota vuordu seja, kū atškir ar komom voi atstarpeibom. Tovs uzdavums ir sadaleit seju vuordūs i atsyuteit vuordu kruojumu. Par pīmāru: words_string ((""Lobi, mani sauc Džons"") == [""Lobi"", ""muns"", ""vuords"", ""ir"", ""Džons""] words_string ((""Vīns, div, treis, četri, pīci, seši"") == [""Vīns"", ""divi"", ""treis"", ""četri"", ""pieci"", ""seši""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,ltg_Latn,python,"
def choose_num(x, y):
    """"""Itys ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis, kas ir puorskaitlis.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,ltg_Latn,python,"
def rounded_avg(n, m):
    """"""Tevi teik pīduovuoti div pozitivi vasalī skaitli n i m, i tev ir juopīmiņ vasalī skaitli nu n leidz m (tymā skaitā ari n i m). Apsaver rezultatu leidz tyvuokajam vasalī skaitļam i puorvērst tū binarajā skaitlī. Ka n ir leluoks par m, atsyuti -1. pīmārs: apsaver_avg ((1, 5) => ""0b11"" apsaver_avg ((7, 5) => -1 apsaver_avg ((10, 20) => ""0b1111"" apsaver_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,ltg_Latn,python,"
def unique_digits(x):
    """"""Atvīgluotais skaitlis ir skaitlis, kurā ir div skaitli, kas nav puorskaitomi, pīvadumam: >>> unikals_cypars (numeri) (([15, 33, 1422, 1]) [1, 15, 33] >>> unikals_cypars (numeri) (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,ltg_Latn,python,"
def by_length(arr):
    """"""Daļa nu vasalūs skaitļu, sorgoj vasalus skaitļus, kas ir nu 1. leidz 9. īkļautajam, apgrīž rezultata kūpumu, piec tam aizstuovi kotru cyparu ar atbylstūšū nūsaukumu nu ""Vīna"", ""Dvi"", ""Treis"", ""Cytur"", ""Pīci"", ""Seši"", ""Septi"", ""Osmys"", ""Nausys"". Pīmāram: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sorgoj arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> apgrīž arr -> [8, 5, 4, 3, 2, 1, 1] atsagrīž [""Osmys"", ""Cytur"", ""Cytur"", ""Dvi"", ""Cytur"", ""Dvi"", ""Cytur"", ""Dvi"", ""Vīna"", ""Vīna""] Ka kūpums ir tukšs, atsagrīž kūpums: arr = [] atsagrīž [] Ka kūpums ir ar svešu skaitli, ignorēsim tū: arr = [1, -1 , 55] -> arr -> [1, 55] -> [1, 55] -> apgrīž arr = [55, - atsagrīž - ['One'], atsagrīž ['] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,ltg_Latn,python,"
def f(n):
    """"""Īsyuti funkceju f, kas par parametru pījam n i atdūd n leluma sarokstu, tai, ka i indeksa elementu vierteiba ir i faktorials, ka i ir puora, voi skaitļu summa nu 1 leidz i cytaiž. i suocās nu 1. i faktorials ir skaitļu reizynuošona nu 1 leidz i (1 * 2 * ... * i). Pīmārs: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,ltg_Latn,python,"
def even_odd_palindrome(n):
    """"""Piec pozitivuo vasaluma n, atdūd tupla, kurā ir pat i naparos vasalumu palindromu skaits, kas atsarūn diapazonā ((1, n), īkļaunūt. pīmārs1: īejis: 3 izejis: (1, 2) skaidruojums: vasalumu palindromi ir 1, 2, 3. vīns nu tūs ir pat, i diveji nu tūs ir naparos. pīmārs2: īejis: 12 izejis: (4, 6) skaidruojums: vasalumu palindromi ir 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. četri nu tūs ir pat, i 6 nu tūs ir naparos. pīmiņs: 1. 1 <= n <= 10^3 2. tupla atdūd attīceigi pat i naparos vasalumu palindromu skaitu. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,ltg_Latn,python,"
def count_nums(arr):
    """"""Rakstīt funkceju count_nums, kas pījam vasalūs skaitļu sareiku i atdūd elementu skaitu, kur cifru summa > 0. Ka skaitlis ir nagativs, tod pyrmais pīzeits byus nagativs: pīvadumam, -123 ir pīzeits cifri -1, 2 i 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,ltg_Latn,python,"
def move_one_ball(arr):
    """"""Tautā ir ari N vasalūs skaitļu sakuortuots array, kas ir arhivs ar numerim ar 1, 2, ..., arr[N]. Arhiva skaitli tiks nūlykti najauši. Tovs uzdavums ir nūsaceit, voi ir īspiejams sakuortuot array nasamainūšūs kuortā, veicūt nūteiktu kuortys darbeibu: Tev ir atļauts veikt lobā nūvieršonys darbeibu sevkuru skaitu reižu. Vīna lobā nūvieršonys darbeiba nūzeimoj, ka vysi kuortys elementi tiks puorvītuoti par vīnu poziceju lobā vierzīnī. Pādejais kuortys elements tiks puorvītuots iz suokuma poziceju kuortā, tys ir, 0. Indekss. Ka ir īspiejams sakuortuot array, veicūt augšupīstuodeju, tod atsagrīž patīss, cytaiž atsagrīž napareizs. Ja nūteiktais array ir tukšs, tod atsagrīž patīss. Napareizs: Dāts sarokums garantāts, ka tam ir unikals elementi. Pīmālam: move_one{(ball_[3, 4, 5, 4, 1]""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,ltg_Latn,python,"
def exchange(lst1, lst2):
    """"""Itamā problemā jūs īkļaus funkceju, kas pajims divejus skaitļu sarokstus i nūruoda, voi ir īspiejams veikt elementu apmainis storp tim, kab lst1 byutu tikai puora skaitļu saroksts. Nav īrūbežuojuma apmainuotu elementu skaitam storp lst1 i lst2. Ka ir īspiejams apmainuot elementus storp lst1 i lst2, kab lst1 vysi elementi byutu puori, atsyuti ""YES"". Cytaidā gadīnī atsyuti ""NO"". Pīmāram: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Pījam, ka īejis saroksti byus nabolti. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,ltg_Latn,python,"
def histogram(test):
    """"""Ka teik pīduovuota rynds, kas apzeimoj atstarpeigi mozuos burtu, atsyuti vuordineicu ar burtu, kas ir vairuokys reizis atkuortuots, i ar atbylstūšū skaitli. Ka vairuokim burtim ir vīnaids atkuortuojums, atsyuti vysus. pīmārs: histograms: {'a': 1, 'b': 1, 'c': 1} histograms: {'a': 2, 'b': 2} histograms: {'a': 2, 'b': 2} histograms: {'a': 2, 'b': 2} histograms: {'b' b a') == {'b' 4}: histograms: {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'a'} {'} {'} {'} {'} {'} {'} } } """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,ltg_Latn,python,"
def reverse_delete(s,c):
    """"""Nūteikti ir juopīmiņ, ka rezultats ir palindroms. Stringa ir palindroms, ka tys ir taišni tai, kai atpakaļ. Tev ir juopuorsyun tulkuojums, kurā ir rezultata string i True/False. Pīmāram, kod s = ""abcde"", c = ""ae"", rezultats ir ('bcd', False). Kad s = ""abcdef"", c = ""b"", rezultats ir ('acdef', False). Kad s = ""abcdedcba"", c = ""ab"", rezultats ir ('cdedc',True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,ltg_Latn,python,"
def odd_count(lst):
    """"""Daļa nu stringim, kur kotrs strings sastuov nu vīnys cyparys, atdūd lītu. Kotram i izdavuma elementam juobyut ""naīpazeistamu elementu skaitam īejis stringā i"". kur vysus i juomaina ar naīpazeistamu cyparu cyparu skaitim īejis stringā i. >>> odd_count['1234567']) [""naīpazeistamu elementu skaits 4n str4ng 4 nu 4n izdavuma.""] >>> odd_count['3',""111111""]) [""naīpazeistamu elementu skaits 1n str1ng 1 nu 1n izdavuma. "", ""naīpazeistamu elementu skaits 8n str8ng 8 nu 8n izdavuma. ""]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,ltg_Latn,python,"
def minSubArraySum(nums):
    """"""Dūtūt pylnskaitļu sakuortuojumu ar skaitlim n, atrodi sevkura napuorpruoteiguos skaitļu apakškūpu minimalū summu. pīmārs minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,ltg_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Teik dots taisnstūrveida olūtu tīksnis. Kotrys rynds apzeimoj vīnu olūtu, kotrs 1 ryndā apzeimoj vīnu i tū pošu iudiņa vīneibu. Kotram olūtam ir atbylstūšs burts, kū var izmontuot, kab nu tuo atvasynuotu iudiņu, i vysim burtim ir vīnaida kapacitate. Tovs uzdavums ir izmontuot burtus, kab iztukšynuotu olūtus. Izpiļdeit, cik reižu vajag izlītuot olūtus. pīmārs: 1. īejis: tīksnis: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] burta_vierteiba: 1. izpiļdeitais: 6 pīmārs: īejis: tīksnis: [[0,0,1,1], [0,0,0,0,0], [1,1,1], [0,1,1,1]] burta_vierteiba: 2. izpiļdeitais: 5. pīmiņ: [[0,0,0], [0,0,0]] burta_vierteiba: 5 * 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,ltg_Latn,python,"
def sort_array(arr):
    """"""Itymā Kata, tev ir juosaškir navnegativī vasalī skaitli piec tūs skaitļa, kas ir tūs binarī izteiksmē, pīaugūšajā kuortā.""""""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,ltg_Latn,python,"
def select_words(s, n):
    """"""Pīmāram: select_words ""Merijai beja mozs lops"", 4) ==> [""pīci""] select_words ""Merijai beja mozs lops"", 3) ==> [""Merijai"", ""pīci""] select_words ""baltys lops"", 2) ==> [] select_words ""Sveiki pasauļs"", 4) ==> [""pasauļs""] select_words ""Aucis Sems"", 3) ==> [""Aucis""] Uncle""""""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,ltg_Latn,python,"
def get_closest_vowel(word):
    """"""Tev ir vuords. Tovs uzdavums ir atrast tyvuokū vokalu, kas atsarūn storp divejom kūdulvorumim nu vuorda lobys pusis (kasis nūviertiejamuos). Vokali suokumā i beiguos nateik skaiteiti. Atdūd tukšu ryndys burtu, ka nav atroduots nivīns vokals, kas atbylst augšā nūsaceitajam. Tu vari pījimt, ka nūteiktā ryndā ir tikai angļu burts. Pīmārs: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,ltg_Latn,python,"
def match_parens(lst):
    '''Tev ir pīduovuots diveju ryndkūpu saroksts, obejis ryndkūpus veidoj tikai atvārti korekti ""("" voi aizvārti korekti "") "". Tovs dorbs ir puorbaudeit, voi ir īspiejams obejus ryndkūpus sasavīnuot kaidā kuortā, kab rezultata ryndkūps byutu lobs. S ryndkūps teik skaiteits par lobu, ka i tikai tod, ka vysi korekti S ir leidzsvorā. Par pīmāru: ryndkūps ""((()) "") ir lobs, bet ryndkūps ""()) "" nav. Atdūd ""jā"", ka ir veids, kai izveiduot lobu ryndkūpu, i atsoka ""nē"", ka nav. Pīmāri: match_parens[('(() "", ') ']) == ' jā' match_parens[(') ', ') ']) == 'nē' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,ltg_Latn,python,"
def maximum(arr, k):
    """"""Dabuots pylns skaitlis arr i pozitivs pylns skaitlis k, atsoka sortuotu sarakstu ar garumu k ar maksimalajim k skaitlim arr. pīmārs1: īvode: arr = [-3, -4, 5], k = 3 izdavums: [-4, -3, 5] pīmārs2: īvode: arr = [4, -4, 4], k = 2 izdavums: [4, 4] pīmārs3: īvode: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 izdavums: [2] pīzeime: 1. pylns skaitlis arrays ilgums byus nu [1, 1000]. 2. pylns skaitlis arrays elementi byus nu [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,ltg_Latn,python,"
def solution(lst):
    """"""Atsaverūt na tukšu vasalūs skaitļu sarokstu, atsoka vysūs najaušajuos elementu summu, kas ir pat pozicejuos.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,ltg_Latn,python,"
def add_elements(arr, k):
    """"""Atsaverūt na tukšu vasalūs skaitļu Arr i vasalū skaitli k, atsoka tūs elementu summu, kurūs ir vysmoz diveji cypars nu pyrmūs k arr elementu. Pīmārs: īejis: arr = [111,21,3,4000,5,6,7,8,9], k = 4 izejis: 24 # summys 21 + 3 īrūbežuojumi: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,ltg_Latn,python,"
def get_odd_collatz(n):
    """"""Kolca pieņteze ir matematiska pieņteze, kas saisteita ar sekveņci, kas defināta tai: suoc ar sevkuru pozitivu vasalu skaitli n. Vēļ kotru terminu sajam nu īprīškejūs terminu: ja īprīškejūs termins ir puors, nuokušais termins ir vīna puse nu īprīškejūs terminu. Ja īprīškejūs termins ir najaušs, nuokušais termins ir 3 reizis īprīškejūs termins plus 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,ltg_Latn,python,"
def valid_date(date):
    """"""Tev juopīroksta funkceja, kas aplīcynoj nūteiktu datumu seju i atdūd patīsu, ka data ir dereiga, cytaiž - napareizu. Datums ir dereigs, ka ir pījimti vysi itaidi nūsacejumi: 1. Datumu seja nav tukša. 2. Dīnys skaits ir na mozuok par 1 voi leluoks par 31 dīnys mienešim 1,3,5,7,8,10,12. Dīnys skaits ir na mozuok par 1 voi leluoks par 30 dīnom mienešim 4,6,9,11. Dīnys skaits ir na mozuok par 1 voi leluoks par 29 mienešim 2. Mienešim nav juobyut mozuokim par 1 voi leluokim par 12. Datums ir formatā: mm-dd-yyyy, pīmāram: valid_date (..) '03-11-2000') => true_date (..) '15-01-2012') => false_date (..) '04-04-2040') => false_date (..) '06-04-2020') => true_date (..) '06/04/2020') => false""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,ltg_Latn,python,"
def split_words(txt):
    '''Dūdūt vuordu seju, atsyuti vuordu sarokstu, kas sadaleiti ar vītom, ka tekstā nav vītom, tod juotaisa ar komom, ka nav komu, juotaisa mozuoku burtu skaits ar najaušu alfabeta kuortu, ord ((a)) = 0, ord ((b)) = 1, ... ord ((z)) = 25 pīmāri split_words ((""Sveits pasauļs!"") â -> [""Sveits pasauļs!""] split_words ((""Sveits pasauļs!"") â -> [""Sveits pasauļs!""] split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,ltg_Latn,python,"
def is_sorted(lst):
    '''Pīmāram, ir sakuortuots (s), - > taisneiba ir sakuortuota (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s), - > napareizs ir sakuortuots (s, - > napareizs, - > napareizs ir sakuortuots (s)'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,ltg_Latn,python,"
def intersection(interval1, interval2):
    """"""Teik dūti diveji intervali, kur kotrs intervāls ir vasals skaitlis. Pīmāram, intervāls = (sastart, beigas) = (1, 2). Dūti intervali ir slāgti, kas nūzeimoj, ka intervāls (sastart, beigas) īkļaun gon suokumu, gon beigas. Kotram intervalam teik pījāmts, ka juo suokums ir mozuoks voi leidzs juo beigu. Tovs uzdavums ir nūsaceit, voi itūs diveju intervālu krystpunkta garums ir pyrmskaitlis. Pīmāram, intervālu (1, 3), (2, 4) krystpunkts ir (2, 3), kurys garums ir 1, kas nav pyrmskaitlis. Ka krystpunkta garums ir pyrmskaitlis, atsyuti ""YES"", cytaiž atsyuti ""NE"". Ka diveji intervāli nasaškrīž, atsyuti ""NE"". [input/output] paraugi: krystpunkts ((1, 2), (2, 3) ==> ""NO"" - ""krystpunkts-1, ((1), 4) =="" - ""NO"" - ""(1, 5"", == ((5, - ""YES"" - ""YES"") ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,ltg_Latn,python,"
def prod_signs(arr):
    """"""Teik dots vasals skaitļu sareiks, i tev ir juosauce vasalu skaitļu leluma summa, kas reizynuota ar kotra skaitļa zeimu reizynuojumu, kas ir 1, -1 voi 0.""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,ltg_Latn,python,"
def minPath(grid, k):
    """"""Atsaverūt iz grīdi ar N ryndom i N kolonom (N >= 2) i pozitivu vasalu skaitli k, kotra grīdis šyuna satur vierteibu. Kotrs vasals skaitlis nu diapazona [1, N * N] īkļautais pasaruoda tīseibā vīnu reizi. Tev ir juodūmoj minimums ceļš garums k grīdi. Tu vari suokt nu sevkurys šyunys, i kotrā sūlī tu vari puorsaceļt iz sevkurom kaimiņu šyunom, cytim vuordim, tu vari puorsaceļt iz šyunom, kurim ir vīna vara ar tevi. Juoatzeimoj, ka ceļš garums k nūzeimoj, ka piļneigi k šyunom (navajag byut atseviškim). Tu NIKADĪS vari izīt nu grīdis. ceļš A (garums k) teik skaiteits par mozuokam par ceļu B (garums k), ka piec nūsaceituos vierteibu sarokys, kas ir A i B šyunom (saucim tūs par l_stA i l_stB), l_stA ir mozuoks leksikografiski mozuoks par l_st_A, tys ir mozuoks par l_st_stBst, cytūs vuordūs teik atrūts nu l_stūms ir mozs ceļš, cytai, var saceitīs iz iz iz izplaukim ar vysu šyunim šyunim šyunim, cytim vuordim var puors irā. Tu vari vari vari puors var īt iz sevkurā nu sevkurdys šyunim šyunim, cytim vuordim ar rūbeigim šyunim, cytim vuordim var puors var puors ir leidzeimejūs, i var izplateigam ar rūbežā ar rūbežā, i var izplateigim, i ir tik tik tik tik i ir tik tik tik i ir tik tik iņ iņ iņ iņ iņ iņ i=[i] i=[i] i=[i], i=[i] i=[i] i=[i] i=[i] i=[i] i=[i] i=j =j =j =j =""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,ltg_Latn,python,"
def tri(n):
    """"""Vysim ir zynoma Fibonači seceiba, tū pādejūs diveju godu symtu laikā dzili pieteja matematiki. Tok tū, kū cylvāki nazyna, ir Tribonači seceiba. Tribonači seceiba ir defināta ar atkuortuotū: tri(1) = 3 tri(n) = 1 + n / 2, ka n ir puors. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ka n ir najauši. Par pīmāru: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Tev ir nūteikts naenegai skaitlis n, tev ir juoatsoka pyrmuos n + 1 Tribonači seceibys skaitļu saroksts. Pīmāri: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,ltg_Latn,python,"
def digits(n):
    """"""Atvīnuot n, atdūd lopys reizynuojumu ar najaušim cyparim cyparim. Atvīnuot 0, ja vysi cypari. Pīmāram: cypars ({}) == 1 cypars ({}) == 0 cypars ({}) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,ltg_Latn,python,"
def is_nested(string):
    '''Iztaisūt funkceju, kas īejis vuordineicai pījam tikai kvadratsvorus. Funkcejai juobyut patīsai, ka ir dereiga aizsorguojuma aizsorguojuma kuorteiba, kur vysmoz vīns aizsorguojums ir īkļauts. ir_īkļauts.'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,ltg_Latn,python,"

def sum_squares(lst):
    """"""Teik dots skaitļu saroksts. Tev ir juopuorstuov skaitļu kvadrāta summa lītā, apgrīž kotru elementu sarakstē iz augšuokū int ((Ceiling) pyrmū reizi. Pīmāri: LST = [1,2,3] izdavums ir 14, LST = [1,4,9] izdavums ir 98, LST = [1,3,5,7] izdavums ir 84, LST = [1.4,4.2,0] izdavums ir 29, LST = [-2.4,1,1] izdavums ir 6.""""""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,ltg_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Sagatavuot funkceju, kas atsoka patīsu, ka pādejais zeimiejuma burta raksturs ir alfabeta zeimiejums i nav vuorda daļa, i nā. Napīmiņu: ""vārds"" ir burtu grupa, kū atškir breivuo vīta. Pīmāri: check_if_last_char_is_a_letter""{""apļu pīts"") -> False check_if_last_char_is_a_letter""{""apļu pī e"") -> True check_if_last_char_is_a_letter""{""apļu pī e"") -> False check_if_last_char_is_a_letter""{""}""{""}""{""}'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,ltg_Latn,python,"
def can_arrange(arr):
    """"""Sagatavuot funkceju, kas atdūd leluokū indeksu elementu, kas nav leluoks voi vīnaids ar tū pošu īprīkšejū elementu. Ka taidu elementu nav, tod atsoka -1. Dāts kuorteibuos nabyus dublikatu vierteibys. Pīmāri: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,ltg_Latn,python,"
def largest_smallest_integers(lst):
    '''Sagatavuot funkceju, kas atdūd tupla (a, b), kur a ir leluokais nu nagativuos vasalūs skaitļu, bet b ir mozuokais nu pozitivuos vasalūs skaitļu sarokstā. Ka nav nagativuos voi pozitivuos vasalūs skaitļu, atsyuti tūs kai nivīnu. Pīmāri: leluokais_smalkuokais_vasalūs skaitli[2, 4, 1, 3, 5, 7]) == (Nav, 1) leluokais_smalkuokais_vasalūs skaitli (([]) == (Nav, N) leluokais_smalkuokais_vasalūs skaitli (([0]) == (Nav, N) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,ltg_Latn,python,"
def compare_one(a, b):
    """"""Izstruoduot funkceju, kas pījam vasalus skaitļus, floatus voi ryndys, kas attāluos realus skaitļus, i atdūd leluokū maineigū tam nūteiktā maineigū tipa veidā. Atdūd nullus, ka vierteibys ir vīnaidys. Piezīme: Ka reals skaitlis ir attāluots kai ryndys, svorku punkts var byut . voi , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> Nikuo """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,ltg_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Izvērtēt, voi nūteiktu skaitli n var pīraksteit kai 4 pozitivu puora skaitļu summu. pīmārs: ir_leidzeigs_pīteikumam_pīteikumam (pīteikums) = 4) == Nalieliejs ir_pīteikumam_pīteikumam (pīteikums) = 6) == Naliejs ir_pīteikumam (pīteikums) = 8) == Patīseigs """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,ltg_Latn,python,"
def special_factorial(n):
    """"""Brazileju faktorials ir defināts kai: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! kur n > 0 Par pīmāru: >>> special_factorial ((4) 288 Funkceja sajims vasalu skaitli kai īejis i juoatsoka itam vasalā skaitļam eipašais faktorials. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,ltg_Latn,python,"
def fix_spaces(text):
    """"""_Pīmārs-3dys, aizvītuot vysus vītys ar zamkruosu, i, ka ryndā ir vaira kai 2 uzastuojušys vītys, tod aizvītuot vysus uzastuojušus vītys ar - fix_spaces ((""Pīmārs"") == ""Pīmārs"" fix_spaces ((""Pīmārs1"") == ""Pīmārs_1"" fix_spaces ((""Pīmārs2"") == ""_Pīmārs_2"" fix_spaces ((""Pīmārs 3"") == ""_Pīmārs-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,ltg_Latn,python,"
def file_name_check(file_name):
    """"""Izstruoduot funkceju, kas pījam failu nūsaukumu, kas ir strings, i atdūd ""jā"", ka faila nūsaukums ir dereigs, i atdūd ""nē"", ka nav. Faila nūsaukums teik skaiteits par dereigu, ka ir pījimti vysi itaidi nosacījumi: - faila nūsaukumā nav vaira kai treis cyparsni ('0'-'9'). - faila nūsaukums satur taiseit vīnu punktu '.' - apakšreiksis pyrma punktu nav tukšys, i tys suocās ar latvīšu alfabeta burtu ('a'-'z' i 'A'Z'). - apakšreiksis piec punktu ir vīna nu itaidu: ['txt', 'exe', 'lld'] Pīmāri: file_name_check""{""example.txt""} # => 'jā' file_name_check""{""example.dll1"") => 'nē' (# nūsaukums suocās ar latvīšu alfabeta burtu)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,ltg_Latn,python,"


def sum_squares(lst):
    """"""""Itei funkceja pajims vasalūs skaitļu sarokstu. Vysim sarokstā asūšajim īrokstam funkceja kvadrēs vasalū īrokstu, ka tuo indeksa ir 3 reizynuojums, i kuobēs vasalū īrokstu, ka tuo indeksa ir 4 reizynuojums, na 3. Funkceja naizmaina sarokstā īrokstus, kuru indeksi nav 3 voi 4 reizynuojumi. Funkceja tod atsoka vysūs īrokstu summu. Pīmāri: Lst = [1,2,3] izdavums ir 6 Lst = [] izdavums ir 0 Lst = [-1,-5,2,-1,-5] izdavums ir -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,ltg_Latn,python,"
def words_in_sentence(sentence):
    """"""Tev ir teikta string, kas apzeimoj teikumu, teikumā ir daži vuordi, kas atškir ar atstarpi, i tev ir juosoka strings, kas satur vuordus nu suokūtnejuos teikuma, kuru garumi ir pyrmskaitli, vuordu seceibai jaunā teikumā juobyut taipošai kai suokūtnejā. pīmārs1: īeja: teikums = ""Itys ir tests"" izeja: ""is"" pīmārs2: īeja: teikums = ""lai ej peldēt"" izeja: ""eju pi"" īrūbežuojumi: * 1 <= len(saceņss) <= 100 * teikumā ir tikai burti """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,ltg_Latn,python,"
def simplify(x, n):
    """"""Tavs uzdevums ir realizēt funkceju, kas vīnkuoršoj izteiksmi x * n. Funkceja atdūd patīsu, ja x * n ir vasals skaitlis, bet cytaiž - napareizi. Obeji x i n ir frakcejis burtu attāluojumi, kur obeji skaitlis i sauciejs ir pozitivi vasals skaitlis. Var pījāmt, ka x i n ir dereigi lūšņi, i nav nullis sauciejs. vīnkuoršoj (..) ""1/5"", ""5/1"") = Patīseiga (..) ""1/6"", ""2/1"") = Napareiza (..) ""7/10"", ""10/2"") = Napareiza (..)""""""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,ltg_Latn,python,"
def order_by_points(nums):
    """"""Rakstīt funkceju, kas sakuortuoj nūteiktu vasalūs skaitļu sarokstu augšupīaugūšā kuortā piec tūs cyparu kopsumys.""""""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,ltg_Latn,python,"
def specialFilter(nums):
    """"""Rakstīt funkceju, kas īejis kodam pījam skaitļu kuortu i atdūd kuortu elementu skaitu, kas ir leluoki par 10, i obeji skaitļa pyrmais i pādejais cypars ir najauši (1, 3, 5, 7, 9). Pīmāram: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,ltg_Latn,python,"
def get_max_triples(n):
    """"""Teik dāts pozitivs vasals skaitlis n. Tev ir juopuorstuov vasals skaitlis array a garuma n. Kotram i (1 ‰¤ i ‰¤ n) vierteiba ir a[i] = i * i - i + 1. Atdūd a treis reizis skaitu (a[i], a[j], a[k]) kur i < j < k, a[i] + a[j] + a[k] ir 3 reizynuojums. Pīmārs: īejis: n = 5 izejis: 1 skaidruojums: a = [1, 3, 7, 13, 21] vīneigais dereigs treis reizynuojums ir (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,ltg_Latn,python,"
def bf(planet1, planet2):
    '''Myusu Saulis sistemā ir ostoņys planetys: tyvuokuo Saulei ir Merkurs, ūtrais ir Venera, tod Zeme, Marss, Jupiters, Saturns, Urans, Neptuns. Skaitom funkceju, kas pījam div planetu nūsaukumus kai stringus planet1 i planet2. Funkcejai byutu juopuorsyunoj tupla, kurā ir vysys planetys, kuru orbitys atsarūn storp planetys orbitom i planetys orbitom, sakuortuotys piec tyvumu Saulei. Funkcejai byutu juopuorsyunoj tukša tupla, ka planeta 1 voi planeta 2 nav pareizys planetu nūsaukumus. Pīmāri bf""(Jupiters"", ""Neptuns"") ==> (""Saturns"", ""Uranuss"") bf(""Zeme"", ""Merkurs"") ==> (""Venera"", ""Zeme"", ""Mars"", ""Jupiters"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,ltg_Latn,python,"
def sorted_list_sum(lst):
    """"""Rakstīt funkceju, kas par parametru pījam stringu sarokstu, izdzēš stringus, kurim ir najauši garumi, i atdūd rezultata sarokstu ar sakuortuotu seceibu. Seikumu vysod veidoj stringu saroksts, na skaitļu sareiksnis, i tys var saturēt dublikatus. Seiku seceibu ir juopīlīk ar kotra vuorda garumu, i tev ir juosuoc saroksts sakuortuots piec ituos nūsacejuma. Ka divejim vuordim ir vīnaids garums, sakuortuoj seiku seceibu alfabetiski. Funkcejai ir juosuoc seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku seiku. Tev var byut pījāmums, ka vysi vuordi byus vīnaidi garumi. Pīmāram: assert list_sort[""aa"", ""a"", ""aaa""])""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,ltg_Latn,python,"
def x_or_y(n, x, y):
    """"""Vīnkuorša programa, kas atdūd x vierteibu, ka n ir pyrmskaitlis, i y vierteibu, ka nā. Pīmāri: x_or_y ((7, 34, 12) == 34 x_or_y ((15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,ltg_Latn,python,"
def double_the_difference(lst):
    '''Dūdūt skaitļu sarokstu, atdūd skaitļu kvadratu summu, kas ir najauši. Navaicoj skaitļus, kas ir nagativi voi nav vasals skaitlis. divkārša_daļuošona (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 divkārša_daļuošona (([-1, -2, 0]) == 0 divkārša_daļuošona (([9, -2]) == 81 divkārša_daļuošona (([0]) == 0 Ka īejis saroksts ir tukšs, atsoka 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,ltg_Latn,python,"
def compare(game,guess):
    """"""Es dūmoju, ka mes vysi atguodojam tū sajūtu, kod zynom kaidu ilgi gaideitu nūtykumu rezultatu. Jūprūjom ir svareigi pīraksteit i saleidzynuot tū, kū jiusim dūmoj i dūmoj. Tovs uzdavums ir nūsaceit, voi persona pareizi nūruodeja vairuokuos sasatikšonys rezultatu. Tev ir divi vīnaida garuma rezultatu i nūruodejumu niši, kur kotrs indekss paruoda sasatikšonu. Atdūd vīnaida garuma nišu, kas paruoda, cik tuoli kotrs nūruodejums beja. Ka jī ir pareizi nūruodejuši, vierteiba ir 0, bet ka nā, vierteiba ir absolutuo atškireiba storp nūruodejumu i rezultatu. pīmārs: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,2,4]) -> [4,0,4,0,1,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,ltg_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Teik dots klašu nūsaukums (kuortys) i paplašynuojumu saroksts. Paplašynuojumi ir juoizmontoj, kab īluodeitu klasei papyldu klasis. Paplašynuojuma spieja ir itaida: lai CAP ir leluokūs burtu skaits paplašynuojuma nūsaukumā, i lai SM ir mozuokūs burtu skaits paplašynuojuma nūsaukumā, spieja teik nūruodeita ar frakceju CAP - SM. Tev ir juodūmoj stypruokais paplašynuojums i juosauc kuortys formatā: ClassName.StrongestExtensionName. Ja ir diveji voi vairuoki paplašynuojumi ar vīnu i tū pošu spieju, tev ir juosauc tys, kas ir pyrmais sarokstā. Par pīmāru, ja tev teik dūta ""Slices"" kai klasa i paplašynuojumu saroksts: ['SEviviRNGliSCes', 'Cheese', 'StuFfed'], tod tev ir juosaucyut 'Slices.SEviRNGliS' kod ir 'SEviRNGliS' (mySviRNGliS'myS'Ces'), spieja teik nūruodeita ar frakceju CAP - SM. Tev ir juodūmoj stypruokais paplašynuojums i juosaunu i juosaucys stringit itaida formatā: ClassName.""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,ltg_Latn,python,"
def cycpattern_check(a , b):
    """"""Tev ir dūti 2 vuordi. Tev ir juosauce patīss, ka ūtrais vuords voi kaids nu tuo apgrīzīņu ir apakšreiksnis pyrmajā vuordā cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,ltg_Latn,python,"
def even_odd_count(num):
    """"""Atvīnuot ar īvāruotu vasalu skaitli, atdūd tupla, kurā ir attīceigi pat i napar cyparu cyparu skaitli. Pīmārs: pat_napar_skaita ((-12) ==> (1, 1) pat_napar_skaita ((123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,ltg_Latn,python,"
def int_to_mini_roman(number):
    """"""Daļa: 1 <= num <= 1000 pīmāri: >>> int_to_mini_roman(19) == 'xix' >>> int_to_mini_roman(152) == 'clii' >>> int_to_mini_roman(426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,ltg_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Atvier taisneibu, ka treis ryndys veidoj taisnstūrškū trejstūni, preteji - nalogs.Līcīņs: taisnstūrškū trejstūni ir trejstūni, kur vīns leņkis ir taisnstūrškū voi 90°.Pīmārs: taisnstūrškū trejstūni (right_angle_triangle) {3, 4, 5) == Līcīņs (true) {1, 2, 3) } == Nalogs '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,ltg_Latn,python,"
def find_max(words):
    """"""Rakstīt funkceju, kas pījam stringu sarokstu. Saraksteibā ir dažaidi vuordi. Atdūd vuordu ar leluokū unikalu raksturu skaitu. Ka vairuokim stringim ir leluokais unikalu raksturu skaits, atsyuti tū, kas ir pyrmais leksikografiskajā seceibā.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,ltg_Latn,python,"
def eat(number, need, remaining):
    """"""Tu esi izsalcis trušs, i tu jau esi izēdiejs nūsaceitu skaitu rūkys, bet tagad tev vajag ēst vēļ vaira rūkys, kab pabeigtu dīnys ēstūņus. tev ir juosauce matrica [kopejais ēstūņu skaits piec ēdīņa, rūkys, kas palykušys piec ēdīņa], ja nav pīteikūši daudz rūkys, tu ēst vysys rūkys, bet tu vys vēļ esi izsalcis. pīmārs: * ēst (<5, 6, 10) -> [11, 4] * ēst (<4, 8, 9) -> [12, 1] * ēst (<1, 10, 10) -> [11, 0] * ēst (<2, 11, 5) -> [7, 0] maineigī: @number: vasals rūkys, kū tu esi izēdiejs. @need: vasals rūkys, kū tev vajag ēst. @remaining: vasals rūkys, kas palykušys atsarā: * constrain: * number = 0 * number = < 1000 * resting = < 1000 * number = < 1000 * resting = < 1000 = < 1000 Have fun = 1000 = fun:)""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,ltg_Latn,python,"
def do_algebra(operator, operand):
    """"""Pīmāram, pyrmajā sarokstā ir pamata algebriskuos darbeibu, ūtrajā - vasalūs skaitļu saroksts. Ar itim divom sarokstom var izveiduot algebrisku izteiksmi i atdūt tuos rezultatu. Pamatškirais algebriskais darbeiba: saskaiteišona (+) atjimšona (-), reizynuošona (-), zamkuortu daleišona (-), eksponencialuo darbeiba (-), pīmāram, operatoru (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), vierskuortu (-), viers (-), viers (-, viers-), viers-), viers- (-, viers-), viers-), viers- (-, viers-), viers- (-, viers-), (-, viers-), (-, viers-), (-,-), (-,-), (-,-), (-,-),), (-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,""""""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,ltg_Latn,python,"
def solve(s):
    """"""Ka ir burts s, īmaini juo burtu vītys nu zamuos iz augšu voi ūtrkuort, ka nā, pastuovi tai, kai ir. Ka burts satur nivīnu burtu, īmaini burtu vītys. Funkcejai ir juosaucej rezultata burts. pīmāri solve ((""1234"") = ""4321"" solve ((""ab"") = ""AB"" solve ((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,ltg_Latn,python,"
def string_to_md5(text):
    """"""Atdūdūt ryndys 'teksts', atsagrīž tuo md5 haša ekvivalenta ryndys. Ka 'teksts' ir tukša ryndys, atsagrīž Nivīna. >>> string_to_md5('Sveika pasauļa') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,ltg_Latn,python,"
def generate_integers(a, b):
    """"""Dūdūt divejim pozitivim vasalūs skaitlim a i b, atsoka pat ciparus storp a i b augšupīaugūša kuortā. Par pīmāru: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
