[
    {
        "task_id": "HumanEval/0",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Controleer of er in een gegeven lijst van getallen twee getallen dichter bij elkaar staan dan de gegeven drempel.\"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Input voor deze functie is een string met meerdere groepen geneste haakjes. Je doel is om die groep te scheiden in afzonderlijke strings en de lijst van die terug te geven. Afzonderlijke groepen zijn in evenwicht (elke open haakje is goed gesloten) en niet genest in elkaar Ignoreer alle spaties in de invoerstring. Voorbeeld: >>> separate_paren_groups' ((( ) (() ((( ) )') ['() ', '(()) ', '((()) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Gezien een positief floating point getal, kan het worden ontleed in een geheel getal (grootste geheel getal kleiner dan het gegeven getal) en decimalen (overgebleven deel altijd kleiner dan 1).\"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Je krijgt een lijst van stortings- en opnames op een bankrekening die begint met een nulsaldo. Je taak is om te detecteren of op enig moment het saldo van de rekening onder nul valt, en op dat punt moet de functie True retourneren. Anders moet het False retourneren. Voorbeeld: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Voor een gegeven lijst van inputnummers, berekent u de gemiddelde absolute afwijking rond het gemiddelde van deze gegevensset. De gemiddelde absolute afwijking is het gemiddelde absolute verschil tussen elk element en een middelpunt (gemiddelde in dit geval): MAD = gemiddelde. x - x_mean. Voorbeeld: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Voeg een getal 'afbakening' tussen elke twee opeenvolgende elementen van de invoerlijst `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Input voor deze functie is een string die meerdere groepen voor geneste haken vertegenwoordigt, gescheiden door spaties. Voor elke groep, output het diepste niveau van nesting van haken. Bijvoorbeeld (() (()) heeft maximaal twee niveaus van nesting terwijl ((())) drie heeft. >>> parse_nested_parens (('((()) ((())) () (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Filter een inputlijst van strings alleen voor die met een bepaalde substring >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Voor een gegeven lijst van gehele getallen, retourneert een tuple bestaande uit een som en een product van alle gehele getallen in een lijst.\"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Van een gegeven lijst van gehele getallen, genereer een lijst van rolling maximale element gevonden tot gegeven moment in de reeks. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Zoek het kortste palindroom dat begint met een opgegeven string. Het algoritme is eenvoudig: - Zoek de langste postfix van opgegeven string die een palindroom is. - Voeg aan het einde van de string het omgekeerde van een stringprefix toe die vóór het palindromische achtervoegsel komt. >>> make_palindrome('') '' >>> make_palindrome('cat') 'catac' >>> make_palindrome('cata') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Test of de gegeven string een palindroom is .\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Input zijn twee strings a en b bestaande uit slechts 1 en 0. Voer binaire XOR uit op deze inputs en retourneer het resultaat ook als een string. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Uit de lijst van strings, retourneert de langste. retourneert de eerste in het geval van meerdere strings van dezelfde lengte. retourneert geen in het geval van de invoerlijst leeg is. >>> langste (([]) >>> langste ((['a', 'b', 'c']) 'a' >>> langste ((['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Geeft een grootste gemeenschappelijke deler van twee gehele getallen a en b >>> grootste_gemeenschappelijke_deler ((3, 5) 1 >>> grootste_gemeenschappelijke_deler ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"De lijst met alle voorvoegsels van de kortste naar de langste inputstring >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"Geeft een string met ruimtelijk afgebakende getallen terug die begint met 0 tot en met n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Gezien een string, zoek uit hoeveel verschillende tekens (ongeacht het hoofdletter) het bestaat uit >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Input naar deze functie is een snaar die muzieknoten vertegenwoordigt in een speciaal ASCII-formaat. Uw taak is om de snaarlijst van gehele getallen te parsen die overeenkomt met vele beats. Hier is een legende: 'o' noot, laatste beats 'o' daken - halve noot, laatste twee beats 'o' daken - quater noot, laatste een beat >>> parse_music. 'o' daken . o' daken . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Zoek uit hoe vaak een bepaalde substring in de oorspronkelijke string kan worden gevonden. Tel overlappende gevallen. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Input is een met ruimte afgebakende string van getallen van 'nul' tot 'negen'. Geldige keuzes zijn 'nul', 'één', 'twee', 'drie', 'vier', 'vijf', 'zes', 'zeven', 'acht' en 'negen'. De string retourneert met getallen gesorteerd van kleinste naar grootste >>> sort_numbers (('drie één vijf') 'een drie vijf' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"Selecteer en retourneer twee van de geleverde getallen (met een lengte van ten minste twee) die het dichtst bij elkaar staan en retourneer ze in volgorde (kleinere getal, groter getal). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Gezien de lijst met getallen (van ten minste twee elementen), toepassen van een lineaire transformatie aan die lijst, zodat het kleinste getal 0 wordt en het grootste 1 wordt >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filter gegeven lijst van alle python waarden alleen voor gehele getallen >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"De terugkeerlengte van de gegeven string >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Voor een gegeven getal n, vind het grootste getal dat n gelijk verdeelt, kleiner dan n >>> grootste_deeler ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"De factoren van een gegeven geheel getal worden in volgorde van het kleinste naar het grootste getal weergegeven. Het getal van de factoren moet gelijk zijn aan het product van alle factoren >>> factoriseer ((8) [2, 2, 2] >>> factoriseer ((25) [5, 5] >>> factoriseer ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Verwijder alle elementen die meer dan één keer voorkomen uit een lijst met gehele getallen. Houd de volgorde van de elementen hetzelfde als in de invoer. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Voor een bepaalde string, flip kleine letters naar hoofdletters en hoofdletters naar kleine letters. >>> flip_case ((('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate lijst van strings in een enkele string >>> concatenate (([]) '' >>> concatenate ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Filter een inputlijst van strings alleen voor diegenen die beginnen met een gegeven prefix. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Geeft alleen positieve getallen in de lijst terug. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"Geeft waar terug als een gegeven getal een priemgetal is, en vals anders. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"find_zero geeft alleen nulpunten terug, zelfs als er veel zijn. Bovendien neemt find_zero alleen x's met een even aantal coëfficiënten en de grootste niet-nulcoëfficiënt, omdat het een oplossing garandeert. >>> rond ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> rond ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1,0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"Beoordeelt een polinoom met coëfficiënten xs op punt x. retour xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Deze functie neemt een lijst l en geeft een lijst l' terug, zodat l' identiek is aan l in de indices die niet deelbaar zijn door drie, terwijl de waarden bij de indices die deelbaar zijn door drie gelijk zijn aan de waarden van de overeenkomstige indices van l, maar gesorteerd. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"De waarde van de waarde van de getallijst wordt berekend door de waarde van de getallijst te berekenen.\"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Geeft het maximale element in de lijst terug. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Geeft het aantal keren dat het cijfer 7 voorkomt in gehele getallen kleiner dan n die deelbaar zijn door 11 of 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Deze functie neemt een lijst l en geeft een lijst l' terug, zodat l' identiek is aan l in de oneven indices, terwijl de waarden bij de even indices gelijk zijn aan de waarden van de even indices van l, maar gesorteerd. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"neemt als invoer string gecodeerd met encode_cyclic functie.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"geeft een gecodeerde string terug in cyclusgroepen van drie tekens. \"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib geeft het n-de getal terug dat een Fibonacci getal is en ook een priemgetal. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero neemt een lijst van gehele getallen als input. Het geeft True terug als er drie verschillende elementen in de lijst zijn die op nul tellen, en False anders. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Stel je een weg voor die een perfect rechte oneindig lange lijn is. n auto's rijden van links naar rechts; tegelijkertijd rijden een andere set van n auto's van rechts naar links. De twee sets auto's beginnen heel ver van elkaar vandaan. Alle auto's bewegen met dezelfde snelheid. Twee auto's worden gezegd te botsen wanneer een auto die van links naar rechts beweegt een auto raakt die van rechts naar links beweegt. De auto's zijn echter oneindig stevig en sterk; als gevolg daarvan blijven ze in hun baan bewegen alsof ze niet botsten. Deze functie geeft het aantal dergelijke botsingen. \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"De lijst met elementen die met 1 zijn geincrementeerd, wordt teruggegeven. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero neemt een lijst van gehele getallen als input. Het geeft True terug als er twee verschillende elementen in de lijst zijn die op nul tellen, en False anders. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Verander de numerieke basis van het ingevoerde getal x in basis. retourneer de string weergave na de conversie. basisnummers zijn kleiner dan 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Gezien de lengte van een zijde en het hoogste terugkeergebied voor een driehoek. >>> driehoek_gebied\"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"De Fib4-getallenreeks is een reeks die vergelijkbaar is met de Fibbonacci-reeks die als volgt wordt gedefinieerd: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Schrijf een functie om het n-de element van de fib4-getallenreeks efficiënt te berekenen. Gebruik geen recursiek. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"Terugkeermedian van de elementen in de lijst l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Controleert of een gegeven string een palindroom is >>> is_palindrome('') True >>> is_palindrome('aba') True >>> is_palindrome('aaaaa') True >>> is_palindrome('zbcd') False \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Geef 2^n modulo p (let op de cijfers). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"neemt als invoer string gecodeerd met encode_shift functie.\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"geeft een gecodeerde string terug door elk teken in het alfabet met 5 te verschuiven.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels is een functie die een string neemt en een string zonder klinkers teruggeeft. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Terug naar True als alle getallen in de lijst l onder de drempel t liggen. >>> below_threshold([1, 2, 4, 10], 100) True >>> below_threshold([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Voeg twee getallen x en y bij elkaar.\"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"Controleer of twee woorden dezelfde tekens hebben. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Waar >>> same_chars (('abcd', 'dddddddabc') Waar >>> same_chars (('dddddddabc', 'abcd') Waar >>> same_chars (('eabcd', 'dddddddddabc') Valse >>> same_chars ((('abcd', 'dddddddabddce') Valse >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') Valse \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"Geeft het n-de Fibonacci-getal terug. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets is een string van \"<\" en \">\". return True als elke openingssteun een overeenkomstige sluitende steun heeft. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") True >>> correct_bracketing(\"<><>>\") True >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is lijst elementen monotonisch toenemend of afnemend. >>> monotonisch (([1, 2, 4, 20]) True >>> monotonisch (([1, 20, 4, 10]) False >>> monotonisch (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Geordende gemeenschappelijke elementen voor twee lijsten. >>> gemeenschappelijk (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> gemeenschappelijk (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Geef de grootste priemfactor van n terug. Stel dat n > 1 en geen priem is. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is een functie die getallen van 1 tot n optelt. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets is een string van \"(\" en \")\". return True als elke openingssteun een overeenkomstige sluitende steun heeft. >>> correct_bracketing(\"(\") False >>> correct_bracketing(\"() True >>> correct_bracketing(\"() True >>> correct_bracketing(\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs vertegenwoordigen coëfficiënten van een polinoom. xs[0] + xs[1] * x + xs[2] * x^2 + .... Geef de afgeleide van dit polinoom in dezelfde vorm terug. >>> afgeleide (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> afgeleide ([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"De FibFib-getallenreeks is een reeksen vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Schrijf een functie om het n-de element van de fibfib-getallenreeks efficiënt te berekenen. >>> fibfib(1) 0 >>> fib fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"Schrijf een functie vowels_count die een string die een woord vertegenwoordigt als input neemt en het aantal klinkers in de string teruggeeft. Vowels in dit geval zijn 'a', 'e', 'i', 'o', 'u'. Hier is 'y' ook een klinker, maar alleen als het aan het einde van het gegeven woord staat. Voorbeeld: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"Voeg meer testcases toe.\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Circulair verschuiven van de cijfers van het gehele getal x, verschuiven van de cijfers naar rechts door verschuiving en retourneren van het resultaat als een string. Als verschuiving > aantal cijfers, retourneren cijfers omgekeerd. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"Taak Schrijf een functie die een string als input neemt en de som van de bovenste tekens alleen teruggeeft' ASCII-codes. Voorbeelden: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"In deze taak krijgt u een string die een aantal appels en sinaasappels vertegenwoordigt die in een mand met fruit zijn verdeeld deze mand bevat appels, sinaasappels en mango's. Gezien de string die het totale aantal sinaasappels en appels vertegenwoordigt en een geheel getal dat het totale aantal vruchten in de mand vertegenwoordigt, retourneert u het aantal mango's in de mand. Bijvoorbeeld: fruit_distribution\"5(appels en 6 sinaasappels\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 appels en 1 sinaasappel\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 appels en 3 sinaasappels\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 appels en 120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"Als er meerdere knooppunten met dezelfde kleinste even waarde zijn gevonden, geef dan de knoop met de kleinste index terug. Als er geen even waarden zijn of de gegeven reeks leeg is, geef dan []. Voorbeeld 1: Input: [4,2,3] Output: [2, 1] Uitleg: 2 heeft de kleinste even waarde en 2 heeft de kleinste index. Voorbeeld 2: Input: [1,2,3] Output: [2, 1] Uitleg: 2 heeft de kleinste even waarde en 2 heeft de kleinste even index. Voorbeeld 3: Input: [] Output: [4:] Input: [5, 3, 4, 2] Output: [0, 0] Uitgang: 1 heeft de kleinste index, maar er zijn twee nullen. Voorbeeld: de eerste knoop heeft de kleinste nullen, maar de kleinste index is <= 10000. Voorbeeld: de eerste knoop heeft een lengte van <= 0, 0, maar de kleinste index is <= 0.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''Het grootste geheel getal dat groter is dan nul en een frequentie heeft die groter is dan of gelijk is aan de waarde van het geheel getal zelf. De frequentie van een geheel getal is het aantal keren dat het in de lijst verschijnt. Als er geen dergelijke waarde bestaat, retourneer -1.'''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''Gezien de lijst van gehele getallen, wordt de lijst in vreemde volgorde teruggestuurd. Vreemde sortering, is wanneer je begint met de minimale waarde, dan het maximum van de resterende gehele getallen, dan minimaal en zo verder. Voorbeelden: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''Gezien de lengtes van de drie zijden van een driehoek. Geef de oppervlakte van de driehoek afgerond op 2 komma's terug als de drie zijden een geldige driehoek vormen. Anders geeft -1 drie zijden maken een geldige driehoek als de som van twee zijden groter is dan de derde zijde. Voorbeeld: driehoek_gebied ({3, 4, 5) == 6.00 driehoek_gebied ({1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''Schrijf een functie die True teruggeeft als het object q zal vliegen, en False anders. Het object q zal vliegen als het in evenwicht is (het is een palindrome lijst) en de som van de elementen is kleiner dan of gelijk aan het maximaal mogelijke gewicht w. Voorbeeld: will_it_fly (([1, 2], 5) â -> False # 1+2 is minder dan het maximaal mogelijke gewicht, maar het is niet in evenwicht. will_it_fly (([3, 2, 3], 1) â -> False # het is in evenwicht, maar 3+2+3 is meer dan het maximaal mogelijke gewicht. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 is minder dan het maximaal mogelijke gewicht, en het is in evenwicht. will_it_fly ((([3], â 5) -> True # 3 is minder dan het maximaal mogelijke gewicht, en het is in evenwicht. '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"Een palindromische matrix is een matrix die zowel naar voren als naar achteren hetzelfde wordt gelezen. Bij één wijziging kunt u één element veranderen in een ander element. Bijvoorbeeld: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''Schrijf een functie die twee lijsten van strings accepteert en de lijst retourneert die het totale aantal karakters in alle strings van de lijst minder heeft dan de andere lijst. Als de twee lijsten hetzelfde aantal karakters hebben, retourneer dan de eerste lijst. Voorbeelden total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hi', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'', '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Schrijf een functie die waar als het gegeven getal de vermenigvuldiging is van 3 priemgetallen en vals anders.\"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Je taak is om een functie te schrijven die true teruggeeft als een getal x een eenvoudige macht van n is en false in andere gevallen. x is een eenvoudige macht van n als n**int=x Bijvoorbeeld: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''Schrijf een functie die een geheel getal a neemt en True teruggeeft als deze ingeger een kubus van een heel getal is. Opmerking: u kunt aannemen dat de invoer altijd geldig is. Voorbeelden: iscube(1) ==> True iscube(2) ==> False iscube(-1) ==> True iscube(64) ==> True iscube(0) ==> True iscube(180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"Je hebt de taak om een functie te schrijven die een hexadecimaal getal als een string ontvangt en het aantal hexadecimale cijfers telt die priemgetallen zijn (een priemgetal is een natuurlijk getal groter dan 1 dat niet een product is van twee kleinere natuurlijke getallen). De hexadecimale cijfers zijn 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Eerste getallen zijn 2, 3, 5, 7, 11, 13, 17,... Dus je moet een aantal van de volgende cijfers bepalen: 2, 3, 5, 7, B (= decimaal 11), D (= decimaal 13). Opmerking: je kunt aannemen dat de invoer altijd correct of leeg is, en symbolen A,B,C,D,E,F, zijn altijd hoofdletters. Voor voorbeelden: Voor num \"AB\" moet de output num = 1. Voor num \"1077E\" moet de output 2. Voor num \"AB\" moet num = 1.33AED zijn 4. Voor num \"ABC\" moet num = 6.01289A. Voor \"AEFD\" moet de output num = 6.0452020 zijn.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"De functie moet een string retourneren, waarbij elk teken een binair getal vertegenwoordigt. Elk teken in de string zal '0' of '1' zijn. Er zal een extra paar tekens 'db' zijn aan het begin en aan het einde van de string. De extra tekens zijn er om te helpen met het formaat. Voorbeelden: decimal_to_binary(15) # retourneert \"db1111db\" decimal_to_binary32) # retourneert \"db100000db\" \"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"Je krijgt een string s. Je taak is om te controleren of de string happy is of niet. Een string is happy als de lengte minimaal 3 is en elke 3 opeenvolgende letters verschillend zijn Voorbeeld: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Het is de laatste week van het semester en de leraar moet de cijfers aan de leerlingen geven. De leraar heeft haar eigen algoritme voor het beoordelen gemaakt. Het enige probleem is dat ze de code die ze gebruikte voor het beoordelen is kwijtgeraakt. Ze heeft je een lijst van GPA's voor sommige leerlingen gegeven en je moet een functie schrijven die een lijst van lettercijfers kan geven met behulp van de volgende tabel: GPA. Lettercijfer 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation ([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"Schrijf een functie die een string neemt en True teruggeeft als de stringlengte een priemgetal is of False anders Voorbeelden prime_length('Hello') == True prime_length('abcdcba') == True prime_length('kittens') == True prime_length('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Gezien een positief geheel getal n, geeft het aantal n-cijferige positieve gehele getallen terug die beginnen of eindigen met 1. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"Voor een positief geheel getal N, retourneer de totale som van de cijfers in het binaire. Voorbeeld Voor N = 1000, is de som van de cijfers 1 en de output moet \"1\" zijn. Voor N = 150, is de som van de cijfers 6 en de output moet \"110\" zijn. Voor N = 147, is de som van de cijfers 12 en de output moet \"1100\" zijn. Variabelen: @N geheel getal Beperkingen: 0 â‰¤ N â‰¤ 10000. Uitgang: een reeks binaire getallen \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"Gezien een niet-leeg lijst van gehele getallen lst. voeg de even elementen die bij oneven indexen zijn toe. Voorbeelden: add (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Schrijf een functie die een string neemt en een geordende versie ervan teruggeeft. Geordende versie van string, is een string waarin alle woorden (gescheiden door een spatie) worden vervangen door een nieuw woord waarin alle tekens in oplopende volgorde zijn gerangschikt op basis van de ascii-waarde. Opmerking: U moet de volgorde van woorden en lege spaties in de zin behouden. Bijvoorbeeld: anti_shuffle ((('Hi') retourneert 'Hi' anti_shuffle ((('hello') retourneert 'ehllo' anti_shuffle (('Hello World!!!') retourneert 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"Je krijgt een 2D-data, als een geneste lijst, die vergelijkbaar is met een matrix, maar in tegenstelling tot matrices, kan elke rij een ander aantal kolommen bevatten. Gezien lst en integer x, vind je integer x in de lijst en retourneer je de lijst met tupels, [(x1, y1), (x2, y2) ...] zodanig dat elke tuple een coördinate is - (rij, kolommen), beginnend met 0. Sorteer coördinaten aanvankelijk door rijen in oplopende volgorde. Sorteer ook coördinaten van de rij door kolommen in dalende volgorde. Voorbeelden: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(], 1) [] == == [0, 1, 2, 3, 2, 2, 3], [2, 2] == ==\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"Als je een matrix van niet-negatieve gehele getallen hebt, stuur je een kopie van de gegeven matrix terug na het sorteren, je sorteer de gegeven matrix in oplopende volgorde als de som ((eerste indexwaarde, laatste indexwaarde) oneven is, of sorteer het in dalende volgorde als de som ((eerste indexwaarde, laatste indexwaarde) even is.\"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"Creëer een functie encrypt die een string als argument neemt en een string retourneert die gecodeerd is met het alfabet dat wordt gedraaid. Het alfabet moet zodanig worden gedraaid dat de letters naar beneden verschuiven met twee vermenigvuldigd met twee plaatsen. Bijvoorbeeld: encrypt('hi') retourneert 'lm' encrypt('asdfghjkl') retourneert 'ewhjklnop' encrypt('gf') retourneert 'kj' encrypt('et') retourneert 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"Je krijgt een lijst met gehele getallen. Schrijf een functie next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\displaystyle next_smallest ({\\text{{{{{{{{1,2,3,4,5])]) }) }) die het op één na kleinste element van de lijst teruggeeft.\"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"Je krijgt een reeks woorden en je taak is om het aantal vervelingen te tellen. Een verveling is een zin die begint met het woord \"I\". Zinnen worden afgebakend door '.', '?' of '!'. Bijvoorbeeld: >>> is_verveeld(\"Hallo wereld\") 0 >>> is_verveeld(\"De hemel is blauw. De zon schijnt. Ik hou van dit weer\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''Maak een functie die 3 getallen neemt. Geeft waar als een van de getallen gelijk is aan de som van de andere twee, en alle getallen zijn gehele getallen. Geeft vals in alle andere gevallen. Voorbeelden any_int{5, 2, 7} â -> True any_int{3, 2, 2} â -> False any_int{3, -2, 1) â -> True any_int{3.6, -2.2, 2) â -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"Schrijf een functie die een bericht neemt en codert op een zodanige manier dat het de hoofdletters van alle letters ruilt, alle klinkers in het bericht vervangt door de letter die 2 plaatsen voor die klinker in het Engels alfabet verschijnt.\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Je krijgt een lijst met gehele getallen. Je moet de grootste priemwaarde vinden en de som van de cijfers ervan teruggeven. Voorbeelden: Voor lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] moet de output 10 zijn Voor lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] moet de output 25 zijn Voor lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] moet de output 13 zijn Voor lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] moet de output 11 zijn Voor lst = [0,81,12,31,21] moet de output 3 zijn Voor lst = [0,1,8,2,1,7] moet de output 7 zijn\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Als een woordenboek gegeven is, retourneert True als alle toetsen strings in kleine letters zijn of alle toetsen strings in grote letters zijn, anders retourneert False. De functie moet False retourneren als het gegeven woordenboek leeg is. Voorbeelden: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) moet True retourneren. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) moet False retourneren. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) moet False retourneren. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False moet check.dict_case{\"NC\":\"STATE\", \"ZIP\":\"45\" }) moet True retourneren.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"Implementeer een functie die een niet-negatief geheel getal neemt en een reeks van de eerste n gehele getallen teruggeeft die priemgetallen zijn en kleiner zijn dan n. Bijvoorbeeld: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"Voltooi de functie die twee gehele getallen neemt en het product van hun eenheidscijfers teruggeeft.\"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"Gezien een string s, tel het aantal hoofdlettervowels in even cijfers. Bijvoorbeeld: count_upper (('aBCdEf') geeft 1 count_upper (('abcdefg') geeft 0 count_upper (('dBBE') geeft 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''Maak een functie die een waarde (string) neemt die een getal vertegenwoordigt en het dichtstbijzijnde gehele getal teruggeeft. Als het getal even ver van twee gehele getallen is, afrond het dan weg van nul. Voorbeelden >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 Opmerking: Afronding weg van nul betekent dat als het gegeven getal even ver van twee gehele getallen is, het getal dat je moet retourneren het is dat het verst van nul is. Voor Voorbeeld: closest_integer \" ((14.5\") moet 15 retourneren en closest_integer \" ((-14.5\") moet -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"Als je een positief geheel getal n hebt, moet je een stapel van n niveaus van stenen maken. Het eerste niveau heeft n stenen. Het aantal stenen in het volgende niveau is: - het volgende oneven getal als n oneven is. - het volgende even getal als n even is. Geef het aantal stenen in elk niveau in een lijst terug, waarbij element bij index i het aantal stenen in het niveau (i+1) vertegenwoordigt. Voorbeelden: >>> make_a_pile (i+1) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"Je krijgt een reeks woorden die gescheiden zijn door komma's of spaties. Je taak is om de reeks in woorden te splitsen en een reeks van woorden terug te geven. Bijvoorbeeld: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"Deze functie neemt twee positieve getallen x en y en geeft het grootste even geheel getal terug dat in het bereik [x, y] inclusief is. Als er geen dergelijk getal is, dan zou de functie -1 moeten retourneren. Bijvoorbeeld: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Je krijgt twee positieve gehele getallen n en m, en je taak is om het gemiddelde van de gehele getallen van n tot m (inclusief n en m) te berekenen. Rond het antwoord af tot het dichtstbijzijnde gehele getal en zet dat om naar binair. Als n groter is dan m, retourneer je -1. Voorbeeld: rounded_avg(1, 5) => \"0b11\" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => \"0b1111\" rounded_avg(20, => 33) \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"Gezien een lijst van positieve gehele getallen x. retourneert een gesorteerde lijst van alle elementen die geen paar cijfers hebben.\"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"Als je een reeks gehele getallen hebt, sorteer je de gehele getallen die tussen 1 en 9 zijn, omkeer je de resulterende reeks en vervang je elk cijfer door de overeenkomstige naam van \"Een\", \"Twee\", \"Drie\", \"Vier\", \"Vijf\", \"Zes\", \"Zeven\", \"Acht\", \"Negen\". Bijvoorbeeld: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sorteer arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"Acht\", \"Vijf\", \"Drie\", \"Twee\", \"Twee\", \"Een\", \"Een\"] Als de reeks leeg is, retourneer je een lege reeks: arr = [] return [] Als de reeks een vreemd getal heeft, negeer het: arr = [1, -1 , 55] -> sort -> arr - 1 , 55 -> reverse arr = [55,1] return - ['One' 1] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"Implementeer de functie f die n als parameter neemt en een lijst van grootte n retourneert, zodat de waarde van het element bij index i de factoriële van i is als i even is of de som van de getallen van 1 tot i anders. i begint bij 1. de factoriële van i is de vermenigvuldiging van de getallen van 1 tot i (1 * 2 * ... * i).\"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"Voor een positief geheel getal n, wordt een tuple geretourneerd met het aantal even en oneven palindromen dat binnen het bereik van {1, n} valt. Voorbeeld1: Input: 3 Output: (1, 2) Uitleg: Integer palindromen zijn 1, 2, 3. één van hen is even en twee van hen zijn oneven. Voorbeeld2: Input: 12 Output: (4, 6) Uitleg: Integer palindromen zijn 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. vier van hen zijn even en 6 van hen zijn oneven. Opmerking: 1. 1 <= n <= 10^3 2. tuple heeft het aantal even en oneven palindromen geretourneerd.\"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"Schrijf een functie count_nums die een reeks van gehele getallen neemt en het aantal elementen teruggeeft met een som van cijfers > 0. Als een getal negatief is, dan is het eerste getekende cijfer negatief: bv. -123 heeft getekende cijfers -1, 2 en 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"We hebben een array 'arr' van N gehele getallen arr[1], arr[2], ..., arr[N].De getallen in de array zullen willekeurig worden geordend. Uw taak is om te bepalen of het mogelijk is om een array te sorteren in niet-afnemende volgorde door de volgende bewerking op de gegeven array uit te voeren: U mag een aantal keren rechtsschuifexploitatie uitvoeren. Een rechtsschuifexploitatie betekent dat alle elementen van de array door één positie in de juiste richting worden verschoven. Het laatste element van de array zal naar de startpositie in de array worden verplaatst, d.w.z. 0e index. Als het mogelijk is om de gesorteerde array te verkrijgen door de bovenstaande bewerking uit te voeren, dan is de terugkeer True anders terug False. Als de gegeven array leeg is, dan is de terugkeer True. Opmerking: De gegeven lijst is gegarandeerd unieke elementen te hebben. Bijvoorbeeld: move_one_(ball[3, 4, 5, 2]= True Uitleg: Door middel van 2 rechtsschuifexploatieaties kan de niet-afnemende volgorde voor de array worden bereikt.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In dit probleem implementeer je een functie die twee lijsten met getallen neemt en bepaalt of het mogelijk is om een uitwisseling van elementen tussen hen uit te voeren om lst1 een lijst van alleen even getallen te maken. Er is geen limiet op het aantal uitgewisselde elementen tussen lst1 en lst2. Als het mogelijk is om elementen tussen lst1 en lst2 uit te wisselen om alle elementen van lst1 even te maken, retourneer \"JA\". Anders retourneer \"NEEN\". Bijvoorbeeld: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NEEN\" Er wordt aangenomen dat de invoerlijsten niet leeg zijn. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"Als een string een ruimte gescheiden kleine letters vertegenwoordigt, wordt een woordenboek teruggestuurd van de letter met de meeste herhalingen en met het overeenkomstige aantal. Als meerdere letters hetzelfde voorkomen, worden ze allemaal teruggestuurd. Voorbeeld: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a') == {'b 4}: histogram (('a') == {'b 4}) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Taak We krijgen twee strings s en c, je moet alle tekens in s verwijderen die gelijk zijn aan een teken in c en dan controleren of de resulterende string palindroom is. Een string wordt palindroom genoemd als het hetzelfde achterwaarts leest als voorwaarts. Je moet een tuple met de resulterende string en True/False retourneren voor de controle. Voorbeeld Voor s = \"abcde\", c = \"ae\", moet het resultaat ('bcd',False) zijn Voor s = \"abcdef\", c = \"b\" moet het resultaat ('acdef',False) zijn Voor s = \"abcdedcba\", c = \"ab\", moet het resultaat ('cdedc',True) zijn\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"Gezien een lijst van strings, waarbij elke string alleen uit cijfers bestaat, retourneert u een lijst. Elk element i van de output moet \"het aantal oneven elementen in de string i van de input zijn\". waarbij alle i's moeten worden vervangen door het aantal oneven cijfers in de i'de string van de input. >>> odd_count['1234567']) [\"het aantal oneven elementen 4n de str4ng 4 van de 4nput.\"] >>> odd_count['3',\"111111\"]) [\"het aantal oneven elementen 1n de str1ng 1 van de 1nput.\", \"het aantal oneven elementen 8n de str8ng 8 van de 8nput.\"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Gezien een reeks van gehele getallen, vind de minimale som van elke niet-lege sub-array van getallen.\"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Je krijgt een rechthoekig raster van putten. Elke rij staat voor een enkele put, en elke 1 in een rij staat voor een enkele waterunit. Elke put heeft een bijbehorende emmer die gebruikt kan worden om er water uit te halen, en alle emmers hebben dezelfde capaciteit. Je taak is om de emmers te gebruiken om de putten leeg te maken. Geef het aantal keren dat je nodig hebt om de emmers te laten zakken. Voorbeeld 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Output: 62: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Output: 53: Input: [[:0,0,0], [0,0,0]] bucket_capacity: 5 * 0 * 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 1 * 2 * 2 * 2 * 2 * 3 * 2 * 2 * 3 * 2 * 2 * 3 * 4 * 4 * 5 * 6 * 6 * 6 * 7 * 9 * 10 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"In deze Kata moet je een array van niet-negatieve gehele getallen sorteren volgens het aantal eenen in hun binaire weergave in oplopende volgorde. Voor een vergelijkbaar aantal eenen, sorteren op basis van de decimale waarde. Het moet worden geïmplementeerd als volgt: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"Als de string s leeg is, moet de functie een lege lijst retourneren. Opmerking: u kunt aannemen dat de invoerstring alleen letters en spaties bevat. Voorbeelden: select_words \"Mary had een lammetje\", 4) ==> [\"little\"] select_words \"Mary had een lammetje\", 3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\", 2) ==> [] select_words \"Hello world\", 4) ==> [\"world\"] select_words \"Uncle sam\", 3) ==> [\"Uncle\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Je krijgt een woord. Je taak is om de dichtstbijzijnde klinker te vinden die tussen twee medeklinkers van de rechterkant van het woord staat (case sensitive). De klinkers in het begin en het einde tellen niet mee. Geef een lege string terug als je geen enkele klinker hebt gevonden die aan de bovenstaande voorwaarde voldoet. Je kunt aannemen dat de gegeven string alleen Engelse letters bevat. Voorbeeld: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''Je krijgt een lijst van twee strings, beide strings bestaan alleen uit open haakjes '(' of sluiten haakjes ') '. Je taak is om te controleren of het mogelijk is om de twee strings in een bepaalde volgorde te koppelen, zodat de resulterende string goed is. Een string S wordt als goed beschouwd als en alleen als alle haakjes in S in evenwicht zijn. Bijvoorbeeld: de string '((()) ' is goed, terwijl de string '()) ' niet is. Terug 'Ja' als er een manier is om een goede string te maken, en terug 'Nee' anders. Voorbeelden: match_parens[('() ', ') ']) == 'Ja' match_parens[(') ', ') ']) == 'Nee' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"Voor een reeks arr van gehele getallen en een positief gehele getal k, retourneert een gesorteerde lijst van lengte k met de maximale k getallen in arr. Voorbeeld1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Voorbeeld2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Voorbeeld3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Opmerking: 1. De lengte van de reeks zal zijn in het bereik van [1, 1000]. 2. De elementen in de reeks zal zijn in het bereik van [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"Gezien een niet-leeg lijst van gehele getallen, geeft de som van alle oneven elementen die in gelijke posities zijn terug. Voorbeelden oplossing (([5, 8, 7, 1]) ==> 12 oplossing (([3, 3, 3, 3, 3]) ==> 9 oplossing (([30, 13, 24, 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Gezien een niet-leeg matrix van gehele getallen arr en een gehele getal k, retourneert u de som van de elementen met ten hoogste twee cijfers van de eerste k elementen van arr. Voorbeeld: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # som van 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"De Collatz-veronderstelling is een wiskundige veronderstelling die betrekking heeft op een volgende volgorde: begin met een positief geheel getal n. Vervolgens wordt elke term uit de vorige term als volgt verkregen: als de vorige term even is, is de volgende term een half van de vorige term. Als de vorige term oneven is, is de volgende term 3 keer de vorige term plus 1. De veronderstelling is dat ongeacht welke waarde van n, de volgorde altijd 1 zal bereiken.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"De datum is geldig als aan alle volgende regels is voldaan: 1. De datum is niet leeg. 2. Het aantal dagen is niet minder dan 1 of meer dan 31 dagen voor maanden 1,3,5,7,8,10,12. En het aantal dagen is niet minder dan 1 of meer dan 30 dagen voor maanden 4,6,9,11. En het aantal dagen is niet minder dan 1 of meer dan 29 voor de maand 2. 3. De maanden mogen niet minder dan 1 of meer dan 12. 4. De datum moet in het formaat: mm-dd-yyyy bijvoorbeeld: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-02040') => False_valid_date (('06-04-2020') => True_valid_date (('06/04/2020') => False\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''Gezien een reeks woorden, retourneert een lijst van woorden verdeeld op witte ruimte, als er geen witte ruimte bestaat in de tekst moet je verdeeld op komma's, als er geen komma's bestaan moet je het aantal kleine letters met oneven volgorde in het alfabet teruggeven, ord (('a') = 0, ord (((b') = 1, ... ord ((('z') = 25 Voorbeelden split_words ((\"Hello world!\") â -> [\"Hello\", \"world!\"] split_words ((\"Hello,world!\") â -> [\"Hello\", \"world!\" split_words\" ((abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''Als je een lijst met getallen hebt, geef je terug of ze al dan niet in oplopende volgorde zijn gesorteerd. Als er meer dan 1 dubbele getallen van hetzelfde getal zijn, geef je False terug. Veronderstel geen negatieve getallen en alleen gehele getallen. Voorbeelden is_sorted ({1})'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Je krijgt twee intervallen, waarbij elk interval een paar gehele getallen is. Bijvoorbeeld interval = (begin, einde) = (1, 2). De gegeven intervallen zijn gesloten, wat betekent dat het interval (begin, einde) zowel het begin als het einde omvat. Voor elk gegeven interval wordt aangenomen dat het begin minder is dan of gelijk is aan het einde. Je taak is om te bepalen of de lengte van de snijpunt van deze twee intervallen een priemgetal is. Bijvoorbeeld, de snijpunt van de intervallen (1, 3), (2, 4) is (2, 3) waarvan de lengte 1, wat geen priemgetal is. Als de lengte van de snijpunt een priemgetal is, retourneer dan \"JA\", anders retourneer \"NEEN\". Als de twee intervallen niet elkaar snijden, retourneer dan \"NEEN\". [input/output] voorbeelden: intersectie (((1, 2), (2, 3) ==> \"intersectie ((-1, 1), 4) ==> \"intersectie ((-1, 4) \" ==>\" intersectie ((-1, 5), ==> \"intersectie ((-3, 5>) \"\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"Je krijgt een reeks van gehele getallen en je moet de som van de grootte van de gehele getallen vermenigvuldigen met het product van alle tekens van elk getal in de reeks, weergegeven door 1, -1 of 0.\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"Je kunt beginnen bij elke cel en in elke stap kun je naar de naburige cellen gaan, met andere woorden, je kunt naar cellen die een rand met je huidige cel delen. Merk op dat een pad van lengte k betekent dat je precies k cellen bezoekt (niet noodzakelijkerwijs verschillend). Je KAN NIET uit het rooster gaan. Een pad A (lengte k) wordt beschouwd als minder dan een pad B (lengte k) als na het maken van de geordende lijsten van de waarden op de cellen die A en B doorlopen (laten we ze lA_st en lA_st noemen), lA_st lexisch minder is dan lA_st, in andere woorden, een integerindex i.i. in het rooster bestaat: [A, j_j = 1, lA, j_j = 1, lA, j_j = 2, lA, j_j = 4, lA, j_j = 1, lA, j_j = 1, lA, j_j = 1, lA, j_j = 1, lA, j_j = 1, [A, j_j = 4, lA, j_j = 1, lA, j_j = 2, l_j = 8, l_j = l_j = l_j = l_j, l_j = l_j, l_j = l_j, l_j, l_j, l_j = l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j,\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"De volgende drie getallen zijn de eerste drie getallen van de Tribonacci-reeks. Voorbeeld: tri(1) = 3 tri(n) = 1 + n / 2, als n even is. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), als n oneven is. Bijvoorbeeld: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Je krijgt een niet-negatief geheel getal n, je moet een lijst van de eerste n + 1 getallen van de Tribonacci-reeks teruggeven. Voorbeelden: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"Gezien een positief geheel getal n, geeft het product van de oneven cijfers terug.\"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''Creëer een functie die een string als input neemt die alleen vierkante haken bevat. De functie moet True retourneren als en alleen als er een geldige volgorde van haken is waarin ten minste één haken in de volgorde is genesteld. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]] â -> True'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Voor lst = [1,2,3] is de uitgang 14 Voor lst = [1,4,9] is de uitgang 98 Voor lst = [1,3,5,7] is de uitgang 84 Voor lst = [1.4,4.2,0] is de uitgang 29 Voor lst = [-2.4,1,1] is de uitgang 6 \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''Maak een functie die True retourneert als het laatste teken van een bepaalde string een alfabetisch teken is en geen deel van een woord, en False anders. Opmerking: \"woord\" is een groep tekens gescheiden door een spatie. Voorbeelden: check_if_last_char_is_a_letter\" \"appel pie\" \" -> False check_if_last_char_is_a_letter\" \"appel pi e\" \" -> True check_if_last_char_is_a_letter\" \"appel pi e\" \" -> False check_if_last_char_is_a_letter\" \"'''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"Creëer een functie die de grootste index van een element teruggeeft die niet groter is dan of gelijk is aan het element dat er onmiddellijk voor staat. Als er geen dergelijk element bestaat, retourneer dan -1. De gegeven array zal geen dubbele waarden bevatten. Voorbeelden: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''Maak een functie die een tuple (a, b) retourneert, waarbij 'a' het grootste negatieve geheel is en 'b' het kleinste positieve geheel. Als er geen negatieve of positieve gehele getallen zijn, retourneer je ze als None. Voorbeelden: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"Een functie maken die gehele getallen, floats of reële getallen weergeeft en de grotere variabele in het gegeven variabele type retourneert. Geen teruggeeft als de waarden gelijk zijn. Opmerking: Als een reëel getal als een string wordt weergegeven, kan het zwevende punt zijn . of , compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> Geen \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Beoordeel of het gegeven getal n kan worden geschreven als de som van precies 4 positieve even getallen Voorbeeld is_gelijk_aan_de_even_som ((4) == Onwaar is_gelijk_aan_de_even_som ((6) == Onwaar is_gelijk_aan_de_even_som ((8) == Waar \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"De Braziliaanse factoriële wordt gedefinieerd als: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! waar n > 0 Bijvoorbeeld: >>> special_factorial ((4) 288 De functie ontvangt een geheel getal als input en moet de speciale factoriële van dit geheel getal retourneren. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_Voorbeeld-3eeks wordt gegeven, vervang alle spaties in deze met onderstreepingen, en als een string meer dan 2 opeenvolgende spaties heeft, vervang dan alle opeenvolgende spaties met - fix_spaces ((\"Voorbeeld\") == \"Voorbeeld\" fix_spaces ((\"Voorbeeld1\") == \"Voorbeeld1\" fix_spaces (((\"Voorbeeld2\") == \"_Voorbeeld_2\" fix_spaces ((\"Voorbeeld 3\") == \"_Voorbeeld-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Een functie maken die een string neemt die de naam van een bestand weergeeft, en 'Ja' retourneert als de naam van het bestand geldig is, en 'Nee' retourneert als dat niet het geval is. Een naam van een bestand wordt als geldig beschouwd als en alleen als aan alle volgende voorwaarden is voldaan: - Er mogen niet meer dan drie cijfers ('0'-'9') in de naam van het bestand zijn. - De naam van het bestand bevat precies één punt '.' - De substring vóór de punt mag niet leeg zijn, en het begint met een letter van het Latijnse alfabet ('a'-'z' en 'A'Z'). - De substring na de punt moet een van deze zijn: ['txt', 'exe', 'lld'] Voorbeelden: file_name_check\"(example.txt\") # => 'Ja' file_name_check\"(example.dll1\") => 'Nee' # (de naam moet beginnen met een Latijnse letter) \"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" Deze functie zal een lijst van gehele getallen nemen. Voor alle gegevens in de lijst, zal de functie het gehele getal kwadrateren als de index een veelvoud van 3 is en de gehele getalverdeling vermenigvuldigen als de index een veelvoud van 4 is en niet een veelvoud van 3. De functie zal de gegevens in de lijst niet wijzigen waarvan de indexen geen veelvoud van 3 of 4 zijn. De functie zal dan de som van alle gegevens teruggeven. Voorbeelden: Voor lst = [1,2,3] moet de output 6 zijn Voor lst = [] moet de output 0 zijn Voor lst = [-1,-5,2,-1,-5] moet de output -126 zijn \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Je krijgt een string die een zin vertegenwoordigt, de zin bevat enkele woorden gescheiden door een spatie, en je moet een string teruggeven die de woorden van de oorspronkelijke zin bevat, waarvan de lengtes priemgetallen zijn, de volgorde van de woorden in de nieuwe string moet dezelfde zijn als de oorspronkelijke. Voorbeeld1: Input: zin = \"Dit is een test\" Output: \"is\" Voorbeeld2: Input: zin = \"laat gaan voor zwemmen\" Output: \"ga voor\" Beperkingen: * 1 <= len(zin) <= 100 * zin bevat alleen letters \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"Je taak is om een functie te implementeren die de uitdrukking x * n vereenvoudigt. De functie geeft True terug als x * n een heel getal is en False anders. Zowel x als n zijn een string weergave van een breuk en hebben de volgende indeling, <numerator>/<denominator> waar zowel de teller als de noemer positieve hele getallen zijn. Je kunt aannemen dat x en n geldige breuken zijn en geen nul als noemer hebben. vereenvoudigen:\"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"Schrijf een functie die de gegeven lijst van gehele getallen in stijgende volgorde sorteert volgens de som van hun cijfers.\"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"Schrijf een functie die een reeks getallen als input gebruikt en het aantal elementen in de reeks teruggeeft dat groter is dan 10 en dat zowel het eerste als het laatste cijfer van een getal oneven is (1, 3, 5, 7, 9). Bijvoorbeeld: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"Je krijgt een positief geheel getal n. Je moet een geheel getal array a van lengte n maken. Voor elke i (1 ‰¤ i ‰¤ n) is de waarde van a[i] = i * i - i + 1. Geef het aantal tripels (a[i], a[j], a[k]) van a terug waar i < j < k, en a[i] + a[j] + a[k] een veelvoud is van 3. Voorbeeld: Input: n = 5 Output: 1 Uitleg: a = [1, 3, 7, 13, 21] De enige geldige tripels zijn (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''Er zijn acht planeten in ons zonnestelsel: de dichtstbijzijnde van de zon is Mercurius, de volgende is Venus, dan de aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Schrijf een functie die twee planeetnamen als strings planet1 en planet2 neemt. De functie moet een tuple teruggeven met alle planeten waarvan de banen zich bevinden tussen de baan van planet1 en de baan van planet2, gesorteerd op de nabijheid van de zon. De functie moet een lege tuple teruggeven als planet1 of planet2 geen juiste planeetnamen zijn. Voorbeelden bf\"(Jupiter\", \"Neptunus\") ==> (\"Saturn\", \"Uranus\") bf(\"Earth\", \"Mercury\") ==> (\"Venus\") bf\"(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Sn\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Schrijf een functie die een lijst met strings als parameter accepteert, de strings met oneven lengtes verwijdert en de resulterende lijst met een gesorteerde volgorde retourneert. De lijst is altijd een lijst met strings en nooit een reeks van getallen, en het kan duplicaten bevatten. De volgorde van de lijst moet stijgend zijn naar lengte van elk woord, en u moet de lijst retourneeren gesorteerd volgens die regel. Als twee woorden dezelfde lengte hebben, sorteer de lijst alfabetisch. De functie moet een lijst met strings in gesorteerde volgorde retourneeren. U kunt aannemen dat alle woorden dezelfde lengte hebben. Bijvoorbeeld: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => \"cd\")\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Een eenvoudig programma dat de waarde van x moet retourneren als n een priemgetal is en de waarde van y anders. Voorbeelden: voor x_of_y(7, 34, 12) == 34 voor x_of_y(15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''Gezien een lijst met getallen, retourneert de som van de kwadraten van de getallen in de lijst die oneven zijn. Neemt getallen die negatief zijn of geen gehele getallen zijn. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Als de invoerlijst leeg is, retourneert 0. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"Ik denk dat we ons allemaal dat gevoel herinneren als het resultaat van een langverwachte gebeurtenis eindelijk bekend is. De gevoelens en gedachten die je op dat moment hebt zijn zeker de moeite waard om op te merken en te vergelijken. Je taak is om te bepalen of een persoon de resultaten van een aantal overeenkomsten correct heeft geraden. Je krijgt twee arrays van scores en gissingen van gelijke lengte, waarbij elke index een overeenkomst toont. Geef een array van dezelfde lengte terug die aangeeft hoe ver elke gok was. Als ze correct hebben geraden, is de waarde 0, en als dat niet het geval is, is de waarde het absolute verschil tussen de gok en de score. voorbeeld: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,2,4]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"De sterkte van de extensie is als volgt: laat CAP het aantal hoofdletters in de naam van de extensie zijn, en laat SM het aantal kleine letters in de naam van de extensie zijn, de sterkte wordt gegeven door de breuk CAP - SM. U moet de sterkste extensie vinden en een string in deze indeling retourneren: ClassName.StrongestExtensionName. Als er twee of meer extenties met dezelfde sterkte zijn, moet u de eerste op de lijst kiezen. Als u bijvoorbeeld \"Slices\" als de klasse en een lijst van de extenties krijgt: ['SEvirNGliSCes', 'Cheese', 'StuFfed'] dan moet u 'Slices.SEvirNGliCes' retourneren omdat 'SvirNGliCes' (mySvirNGliCes') de sterkste extensie is (bijvoorbeeld: 'AA_Beats'), omdat 'AA_Beats' de sterkste extensie is (bijvoorbeeld: 'AA_Beats'), 'AA_Class' is de sterkste extensie (bijvoorbeeld: 'AA_Beats').\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Je krijgt 2 woorden. Je moet True retourneren als het tweede woord of een van zijn rotaties een substring is in het eerste woord cycpattern_check(\"abcd\",\"abd\") => False cycpattern_check(\"hello\",\"ell\") => True cycpattern_check(\"whassup\",\"psus\") => False cycpattern_check\"abab\",\"baa\") => True cycpattern_check(\"efef\",\"eeff\") => False cycpattern_check\"(hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"Gezien een geheel getal, geeft een tuple terug die het aantal even en oneven cijfers heeft. Voorbeeld: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"Gezien een positief geheel getal, verkrijg het equivalent van het Romeinse cijfer als een string en retourneer het in kleine letters. Beperkingen: 1 <= num <= 1000 Voorbeelden: >>> int_to_mini_roman{19} == 'xix' >>> int_to_mini_roman{152} == 'clii' >>> int_to_mini_roman{426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''Gezien de lengtes van de drie zijden van een driehoek. Terugkeer Waar als de drie zijden een rechthoekige driehoek vormen, Valse anders. Een rechthoekige driehoek is een driehoek waarin een hoek een rechte hoek of 90 graden is. Voorbeeld: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"Schrijf een functie die een lijst met strings accepteert. De lijst bevat verschillende woorden. Geef het woord met het maximale aantal unieke tekens terug. Als meerdere strings het maximale aantal unieke tekens hebben, geef dan het woord terug dat het eerst in lexicografische volgorde komt.\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Je bent een hongerig konijn en je hebt al een bepaald aantal wortelen gegeten, maar nu moet je meer wortelen eten om de maaltijden van de dag te voltooien. Je moet een array van [ totaal aantal gegeten wortelen na je maaltijden, het aantal wortelen dat na je maaltijden overblijft ] retourneren als er niet genoeg overgebleven wortelen zijn, eet je alle overgebleven wortelen, maar je zult nog steeds honger hebben. Voorbeeld: * eet ((5, 6, 10) -> [11, 4] * eet ((4, 8, 9) -> [12, 1] * eet ((1, 10, 10) -> [11, 0] * eet ((2, 11, 5) -> [7, 0] Variabelen: @nummer: gehele aantal wortelen dat je hebt gegeten. @behoefte : gehele aantal wortelen dat je moet eten. @overgebleven: gehele aantal overgebleven wortelen in voorraad: Constrain: * 0 = <= 0 * <= 1000 * 0 = <= 1000 = = restantwoord:\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"De basis algebraïsche bewerkingen: optellen (+) aftrekken (-)) vermenigvuldigen (*) verdelen (//) exponentieren (**) Voorbeeld: operator['+', '*', '-'] array = [2, 3, 4, 5] resultaat = 2 + 3 * 4 - 5 => resultaat = 9 Opmerking: de lengte van de lijst van operatoren is gelijk aan de lengte van de lijst van operanden minus één. Operand is een lijst van niet-negatieve gehele getallen. Operator heeft ten minste één operator, en operand heeft ten minste twee operanden.\"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"Als de string geen letters bevat, moet de functie de resulterende string retourneren. Voorbeelden oplossen ((\"1234\") = \"4321\" oplossen ((\"ab\") = \"AB\" oplossen ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"Als 'text' een lege string is, retourneert u None. >>> string_to_md5('Hallo wereld') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "nld_Latn",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"Gezien twee positieve gehele getallen a en b, retourneer de even cijfers tussen a en b, in oplopende volgorde. Bijvoorbeeld: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]