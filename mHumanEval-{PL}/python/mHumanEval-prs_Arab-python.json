[
    {
        "task_id": "HumanEval/0",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"بررسی کنید که آیا در لیست داده شده اعداد، هر دو عدد به یکدیگر نزدیک تر از آستانه داده شده است. مثال: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"ورودی این تابع یک رشته است که شامل چندین گروه از بند بند های آشیانه شده است. هدف شما جدا کردن آن گروه ها به رشته های جداگانه و بازگشت لیست آن ها است. گروه های جداگانه متعادل هستند (هر بند باز به درستی بسته شده است) و در داخل یکدیگر آشیانه نشده اند. هر گونه فضای موجود در رشته ورودی را نادیده بگیرید. مثال: >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ['() ', '(()) ', '(() ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"با توجه به یک عدد مثبت پاییز شناور، می توان آن را به بخش های عدد صحیح (بزرگترین عدد صحیح کوچکتر از عدد داده شده) و اعشار (باقی قسمت همیشه کوچکتر از ۱) تجزیه کرد. قسمت اعشار عدد را برگردانید. مثال: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"شما لیستی از عملیات سپرده گذاری و برداشت در یک حساب بانکی را دارید که با میزان صفر شروع می شود. وظیفه شما تشخیص این است که آیا در هر نقطه تعادل حساب زیر صفر است و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند. مثال: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"برای یک لیست داده شده از اعداد ورودی، انحراف مطلق میانگین را در اطراف میانگین این مجموعه داده محاسبه کنید. انحراف مطلق میانگین متوسط تفاوت مطلق بین هر عنصر و یک نقطه مرکزی است (در این مورد میانگین): MAD = میانگین ۰ x - x_mean  مثال: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"یک عدد \"تقاطع\" را بین هر دو عنصر متوالی لیست ورودی وارد کنید `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"ورودی این تابع یک رشته است که چندین گروه را برای قوس های آشیانه ای که با فضاها جدا شده اند نشان می دهد. برای هر یک از گروه ها ، عمیق ترین سطح آشیانه سازی قوس ها را خروجی کنید. به عنوان مثال (() (()) حداکثر دو سطح آشیانه سازی دارد در حالی که ((())) سه سطح دارد. >>> parse_nested_parens('((()) ((())) () ((()) ((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"یک لیست ورودی رشته ها را فقط برای آنهایی که شامل زیر رشته داده شده است فیلتر کنید >>> filter_by_substring([]، 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"برای یک لیست داده شده از اعداد صحیح، یک توپل را که شامل جمع و حاصل از تمام اعداد صحیح در یک لیست است، برگردانید. جمع خالی باید برابر با 0 باشد و حاصل خالی باید برابر با 1 باشد. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"از یک لیست داده شده از اعداد صحیح، لیستی از عناصر حداکثر رولینگ را که تا لحظه مشخص در دنباله یافت شده است، ایجاد کنید. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"کوتاه ترین پالندرم را پیدا کنید که با یک رشته ارائه شده شروع می شود. ایده الگوریتم ساده است: - طولانی ترین پسوند رشته ارائه شده را پیدا کنید که یک پالندرم است. - به انتهای رشته معکوس یک پیشوند رشته را که قبل از پسوند پالندرم می آید اضافه کنید. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"آزمایش اگر رشته داده شده یک پالندرم باشد \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"ورودی دو رشته a و b است که فقط از 1 و 0 تشکیل شده است. XOR دوگانه را روی این ورودی ها اجرا کنید و نتیجه را نیز به عنوان یک رشته برگردانید. >>> string_xor (('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"از لیست رشته ها، طولانی ترین را برگردانید. اولین را در صورت وجود چندین رشته با طول یکسان برگردانید. در صورت خالی بودن لیست ورودی، هیچ را برگردانید. >>> طولانی ترین (([]) >>> طولانی ترین ((['a','b','c']) 'a' >>> طولانی ترین ((['a','bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"بزرگترین تقسیم مشترک دو عدد صحیح a و b را برگرداند >>> بزرگترین_تقسیم_معمول ((3, 5) 1 >>> بزرگترین_تقسیم_معمول ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"لیست تمام پیشوند ها را از کوتاه ترین تا طولانی ترین رشته ورودی >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"یک رشته حاوی اعداد محدود به فضا را از 0 تا n شامل می کند. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"یک رشته داده شده، تعداد کاراکتر های متمایز (بغیر از مورد) را پیدا کنید که از >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 تشکیل شده است.\"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"ورودی برای این تابع یک رشته است که نشان دهنده یادداشت های موسیقی در یک فرمت خاص ASCII است. وظیفه شما تجزیه لیست رشته های عدد معادل بسیاری از ضرب ها است. در اینجا یک افسانه وجود دارد: 'o' - یادداشت, آخرین ضربات چهار 'o' - نصف یادداشت, آخرین دو ضربات 'o' - quater یادداشت, آخرین یک ضرب >>> parse_music. 'o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . o' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"تعداد بار هایی که یک زیر رشته داده شده در رشته اصلی یافت می شود را پیدا کنید. موارد همپوشانی را بشمارید. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"ورودی یک رشته با فضای محدود از اعداد از صفر تا نه است. انتخاب های معتبر صفر، یک، دو، سه، چهار، پنج، شش، هفت، هشت و نه هستند. رشته را با اعداد مرتب شده از کوچک ترین به بزرگ ترین >>> sort_numbers ((('سه یک پنج') 'یک سه پنج' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"از یک لیست ارائه شده از اعداد (با حداقل دو طول) دو عدد را که به یکدیگر نزدیک هستند انتخاب کنید و آنها را به ترتیب (عدد کوچکتر، عدد بزرگتر) برگردانید. >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"لیستی از اعداد (حداقل دو عنصر) داده شده، یک تبدیل خطی را به آن لیست اعمال کنید، به طوری که کوچک ترین عدد به 0 و بزرگ ترین عدد به 1 تبدیل شود >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"فهرست داده شده فیلتر از هر مقدار پایتون فقط برای اعداد صحیح >>> filter_integers ((['a'، 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc'، {}، []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"طول بازگشت رشته داده شده >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"برای یک عدد n داده شده، بزرگترین عدد را پیدا کنید که n را به طور مساوی تقسیم می کند، کوچکتر از n >>> بزرگترین_قسمت دهنده ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"لیست عوامل اصلی عدد صحیح داده شده را از کوچک ترین به بزرگ ترین ترتیب برگردانید. هر یک از عوامل باید به تعداد بار مربوط به تعداد بار ظاهر شدن در فاکتورهای ذکر شده باشد. عدد ورودی باید برابر با محصول همه عوامل >>> فاکتورزه ((8) [2, 2, 2] >>> فاکتورزه ((25) [5, 5] >>> فاکتورزه ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"از یک لیست از اعداد صحیح، تمام عناصر را که بیش از یک بار اتفاق می افتد حذف کنید. ترتیب عناصر را همان طور که در ورودی باقی می گذارد، حفظ کنید. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"برای یک رشته داده شده، کاراکترهای کوچک را به بزرگ و بزرگ به کوچک تبدیل کنید. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"فهرست رشته های یک رشته را به یک رشته واحد متصل کنید >>> متصل کنید (([]) '' >>> متصل کنید ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"یک لیست ورودی رشته ها را فقط برای آنهایی که با یک پیشوند داده شده شروع می شوند، فیلتر کنید. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"فقط اعداد مثبت را در لیست بازگردانید. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"اگر یک عدد داده شده اول باشد، درست را بازگردانید و در غیر این صورت غلط را. >>> اول است. (۶) غلط است. (۱۰۱) درست است. (۱۱) درست است. (۱۳۴۱) درست است. (۱۶۱) درست است. (۱۳۴۴) درست است. (۱۳۵) درست است. (۱۳۴۴) درست است. (۱۶۱) درست است. (۱۳۵) درست است. (۱۶۴) غلط است. (۱۶۵) غلط است. (۱۶۶) غلط است. (۱۷۶) غلط است. (۱۷۷) غلط است. (۱۷۷) غلط است. (۱۸۸) غلط است. (۱۸۸) غلط است. (۱۸۸) غلط است. (۱۹۸) غلط است. (۱۹۹) غلط است. (۱۹۹) غلط است. (۱۹۹) غلط است. (۱۹۹) غلط است. (۱۹۹) غلط است. (۱۹۹)\"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs ضریب های یک چندمعدل هستند. find_zero find x طوری که poly (((x) = 0. find_zero فقط فقط صفر نقطه را باز می گرداند، حتی اگر تعداد زیادی وجود داشته باشد. علاوه بر این، find_zero فقط لیست xs را با تعداد ضریب های حتی و بزرگترین ضریب غیر صفر می گیرد زیرا یک راه حل را تضمین می کند. >>> round (((find_zero[(1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> round (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6^2 + x^3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"یک چند ضلعی با ضریب های xs در نقطه x را ارزیابی می کند. xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n  را باز می گرداند\"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"این تابع یک لیست l را می گیرد و یک لیست l' را باز می گرداند که در شاخص هایی که به سه تقسیم نمی شوند با l یکسان است ، در حالی که مقادیر آن در شاخص هایی که به سه تقسیم می شوند با مقادیر شاخص های مربوطه l برابر است ، اما مرتب شده است. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"عناصر منحصر به فرد مرتب شده را در یک لیست >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123]  برگرداند.\"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"حداکثر عنصر را در لیست بازگردانید. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"عدد 7 را در عدد های کامل کمتر از n که قابل تقسیم بر 11 یا 13 هستند، برگردانید. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"این تابع یک لیست l را می گیرد و یک لیست l' را باز می گرداند که l' با l در شاخص های عجیب یکسان است، در حالی که مقادیر آن در شاخص های جفت برابر با مقادیر شاخص های جفت l است، اما مرتب شده است. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"رشته ای را که با تابع encode_cyclic کدگذاری شده است به عنوان ورودی می گیرد. رشته ای رمزگشایی شده را باز می گرداند. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"رشته های رمزگذاری شده را با گروه های چرخه ای سه کاراکتر باز می گرداند.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib عدد n را که یک عدد فیبوناچی است و همچنین عدد اول است را باز می گرداند. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triple_sum_to_zero لیستی از اعداد صحیح را به عنوان یک ورودی می گیرد. اگر سه عنصر متمایز در لیست وجود داشته باشد که به صفر اضافه شود، درست را باز می گرداند و در غیر این صورت غلط است. >>> triple_sum_to_zero (([1, 3, 5, 0]) False >>> triple_sum_to_zero (([1, 3, -2, 1]) True >>> triple_sum_to_zero (([1, 2, 3, 7]) False >>> triple_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triple_sum_to_zero (([1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"یک جاده را تصور کنید که یک خط بی نهایت مستقیم است. n ماشین از چپ به راست رانندگی می کنند؛ همزمان، یک مجموعه متفاوت از n ماشین از راست به چپ رانندگی می کنند. دو مجموعه از ماشین ها از فاصله بسیار دور از یکدیگر شروع می شوند. همه ماشین ها با سرعت یکسان حرکت می کنند. دو ماشین در هنگام برخورد با یک ماشین که از چپ به راست حرکت می کند با یک ماشین که از راست به چپ حرکت می کند برخورد می کنند. با این حال، ماشین ها بی نهایت محکم و قوی هستند؛ در نتیجه، آنها در مسیر خود حرکت می کنند، انگار که با هم برخورد نکرده اند. این تابع تعداد چنین برخورد ها را نشان می دهد. \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"لیست بازگردانده شده با عناصر افزایش یافته توسط 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero لیستی از اعداد صحیح را به عنوان یک ورودی می گیرد. اگر دو عنصر متمایز در لیست وجود داشته باشد که به صفر اضافه شود، درست را باز می گرداند و در غیر این صورت غلط است. >>> pairs_sum_to_zero (([1, 3, 5, 0]) غلط >>> pairs_sum_to_zero (([1, 3, -2, 1]) غلط >>> pairs_sum_to_zero (([1, 2, 3, 7]) غلط >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) درست >>> pairs_sum_to_zero (([1]) غلط \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"تبدیل پایه عددی عدد ورودی x به پایه. نمایش رشته را پس از تبدیل بازگردانید. اعداد پایه کمتر از 10 هستند. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"طول یک طرف و سطح بازگشت بالا برای یک مثلث داده شده است. >>> مثلث_مجال\"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"تسلسل اعداد فیبوناچی یک تسلسل مشابه به تسلسل فیبوناچی است که به شرح زیر تعریف شده است: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). لطفاً یک تابع برای محاسبه موثر عنصر n-م از تسلسل اعداد فیبوناچی بنویسید. از تکرار استفاده نکنید. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"میانگین بازیافت عناصر در لیست l. >>> میانگین (([3, 1, 2, 4, 5]) 3 >>> میانگین (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"بررسی می کند که آیا رشته داده شده یک پالندروم است >>> is_palindrome (('') درست است >>> is_palindrome (('aba') درست است >>> is_palindrome (('aaaaa') درست است >>> is_palindrome (('zbcd') غلط است \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2^n مودولو p را برگردانید (از اعداد آگاه باشید). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"رشته ای را که با تابع encode_shift کدگذاری شده است به عنوان ورودی می گیرد. رشته ای رمزگشایی شده را باز می گرداند. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"یک رشته رمزگذاری شده را با تغییر هر کاراکتر به 5 در الفبای آن باز می گرداند.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels یک تابع است که رشته را می گیرد و رشته بدون حرف های خود را باز می گرداند. >>> remove_vowels ((('') ' ' >>> remove_vowels ((\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels (('abcdef') 'bcdf' >>> remove_vowels (('aaaaa') ' ' >>> remove_vowels (('aaBAA') 'B' >>> remove_vowels (('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"اگر تمام اعداد موجود در لیست l زیر آستانه t باشند، درست را باز می گرداند. >>> below_threshold (([1, 2, 4, 10], 100) درست >>> below_threshold (([1, 20, 4, 10], 5) غلط \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"دو عدد x و y را جمع کنید >>> جمع کنید (((2, 3) 5 >>> جمع کنید (((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"بررسی کنید که آیا دو کلمه دارای کاراکترهای مشابه هستند. >>> same_chars ((('eabcdzzzz', 'dddzzzzzzdeddabc') درست >>> same_chars ((('abcd', 'dddddddddabc') درست >>> same_chars ((('dddddddabc', 'abcd') درست >>> same_chars ((('eabcd', 'dddddddddabc') غلط >>> same_chars ((('abcd', 'dddddddabddce') غلط >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') غلط \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"عدد n-م فیبوناچی را باز می گرداند. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets یک رشته از \"<\" و \">\". return True اگر هر براکت باز کننده دارای براکت بسته کننده باشد. >>> correct_bracketing ((\"<\") False >>> correct_bracketing ((\"<>\") True >>> correct_bracketing ((\"<><>>\") True >>> correct_bracketing ((\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"عناصر مشترک منحصر به فرد مرتب شده را برای دو لیست بازگردانید. >>> مشترک (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> مشترک (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"بزرگترین عامل اول n را برگردانید. فرض کنید n > 1 و یک عدد اول نیست. >>> بزرگترین_عامل_اول ((13195) 29 >>> بزرگترین_عامل_اول ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n یک تابع است که اعداد را از 1 تا n جمع می کند. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets یک رشته از \"(\" و \")\". return True اگر هر براکت باز کننده دارای براکت بسته کننده باشد. >>> correct_bracketing (((\"(\") False >>> correct_bracketing (((\")) True >>> correct_bracketing (((())) True >>> correct_bracketing (((\") ((()) False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs معادل یک چندمجموعه را نشان می دهد. xs[0] + xs[1] * x + xs[2] * x^2 + .... مشتق این چندمجموعه را به همان شکل برگردانید. >>> مشتق ((([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> مشتق (([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"دنباله اعداد فیب فیب یک دنباله مشابه به دنباله فیبوناچی است که به شرح زیر تعریف شده است: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). لطفاً یک تابع برای محاسبه موثر عنصر n-م دنباله اعداد فیب فیب بنویسید. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"یک تابع vowels_count بنویسید که یک رشته را که یک کلمه را به عنوان ورودی نشان می دهد را می گیرد و تعداد حروف صوتی را در رشته باز می گرداند. حروف صوتی در این مورد \"a\" ، \"e\" ، \"i\" ، \"o\" ، \"u\" است. در اینجا ، \"y\" نیز یک حروف صوتی است ، اما فقط وقتی که در پایان کلمه داده شده باشد. مثال: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"موارد آزمایش بیشتری را اضافه کنید. \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"دایره ای ارقام عدد x را تغییر دهید، ارقام را به سمت راست تغییر دهید و نتیجه را به عنوان یک رشته برگردانید. اگر تغییر > تعداد ارقام، ارقام را معکوس برگردانید. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"وظیفه یک تابع بنویسید که یک رشته را به عنوان ورودی می گیرد و جمع کاراکترهای بالای ASCII را فقط باز می گرداند. مثال: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"در این کار، یک رشته به شما داده می شود که تعداد سیب و پرتقال را نشان می دهد که در یک سبد میوه توزیع می شوند. این سبد شامل سیب، پرتقال و میوه های مانگو است. با توجه به رشته ای که تعداد کل سیب و پرتقال را نشان می دهد و یک عدد صحیح که تعداد کل میوه های سبد را نشان می دهد، تعداد میوه های مانگو در سبد را بازگردانید. برای مثال: fruit_distribution\"5(سیب و 6 پرتقال\"، 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 سیب و 1 پرتقال\"،3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 سیب و 3 پرتقال\"، 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 سیب و 120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\" با توجه به یک آرایه که نمایانگر شاخه ای از یک درخت است که دارای گره های عدد صحیح غیر منفی است ، وظیفه شما این است که یکی از گره ها را انتخاب کرده و آن را برگردانید. گره انتخاب شده باید گره ای با کوچک ترین مقدار جفت باشد. اگر چندین گره با کوچک ترین مقدار جفت یافت شود ، گره ای را که دارای کوچک ترین شاخص است ، برگردانید. گره انتخاب شده باید در یک لیست ، [smallest_value ، index آن ] ، اگر ارزش جفت وجود نداشته باشد یا آرایه داده شده خالی باشد ، [] را برگردانید. مثال 1: ورودی: [4,2,3] خروجی: [2, 1] توضیح: 2 دارای کوچک ترین مقدار جفت است و 2 دارای کوچک ترین شاخص است. مثال 2: ورودی: [1,2,3] خروجی: [2, 1] توضیح: 2 دارای کوچک ترین مقدار جفت است و 2 دارای کوچک ترین شاخص است. مثال 3: ورودی: [] خروجی: [4: 5] ورودی: [0, 3, 4] خروجی: 1 خروجی: کوچک ترین گره ای که دارای شاخص است ، به عنوان مثال اول ، دو صفر وجود دارد. * طول: [1,2,2,3] خروجی: [2,3] خروجی: [2,3] توضیح: [2,3] توضیح: 2 دارای کوچکترین مقدار جفت است و کوچک ترین شاخص است.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''یک لیست غیر خالی از اعداد صحیح مثبت به شما داده شده است. بزرگترین عدد صحیح را که بزرگتر از صفر است و دارای فرکانس بزرگتر یا برابر با ارزش عدد صحیح است، برگردانید. فرکانس یک عدد صحیح تعداد بار هایی است که در لیست ظاهر می شود. اگر چنین ارزشی وجود نداشته باشد، -1 را برگردانید. مثال: search (([4, 1, 2, 2, 3, 1]) == 2 search (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 search (([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''لیست اعداد صحیح را با ترتیب عجیب برگردانید. مرتب سازی عجیب زمانی است که با حداقل مقدار شروع می کنید، سپس حداکثر عدد باقیمانده، سپس حداقل و غیره. مثال: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''با توجه به طول سه طرف مثلث. اگر سه طرف یک مثلث معتبر را تشکیل دهند، مساحت مثلث را به دو نقطه اعشاری گردآوری کنید. در غیر این صورت -1 را برگردانید. اگر مجموع هر دو طرف از سومین طرف بزرگتر باشد، سه طرف مثلث معتبر را تشکیل می دهند. مثال: مثلث_مساحت (((3, 4, 5) == 6.00 مثلث_مساحت (((1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''یک تابع بنویسید که اگر شی q پرواز کند True را باز می گرداند و در غیر این صورت False. اگر شی q متعادل باشد (این یک لیست پالندروم است) و مجموع عناصر آن کمتر از یا برابر با حداکثر وزن ممکن w باشد. مثال: will_it_fly (([1, 2]، 5) â -> False # 1+2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست. will_it_fly (([3, 2, 3]، 1) â -> False # متعادل است، اما 3+2+3 بیشتر از حداکثر وزن ممکن است. will_it_fly (([3, 2, 3]، 9) â -> True # 3+23 کمتر از حداکثر وزن ممکن است و متعادل است. will_it_fly ((([3], 5) â -> True # 3 کمتر از حداکثر وزن ممکن است و متعادل است.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"با توجه به یک آرایه ارجاع های صحیح، حداقل تعداد عناصر را که باید تغییر کنند برای ایجاد آرایه پالندروم پیدا کنید. یک آرایه پالندروم یک آرایه است که به عقب و جلو یکسان خوانده می شود. در یک تغییر، شما می توانید یک عنصر را به هر عنصر دیگر تغییر دهید. به عنوان مثال: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''یک تابع بنویسید که دو لیست رشته را قبول کند و لیستی را که تعداد کاراکترهای کل در تمام رشته های لیست کمتر از لیست دیگر است را باز می گرداند. اگر دو لیست دارای تعداد کاراکترهای یکسان باشند ، لیست اول را باز می گرداند. مثال ها total_match (([] ، []) â -> [] total_match ((['hi' ، 'admin' ، ['hI' ، 'Hi']) â -> ['hI' ، 'Hi'] total_match ((['hi' ، 'admin' ] ، ['hi' ، 'hi' ، 'admin' ، 'project']) â -> ['hi' ، 'admin' ] total_match ((['hi' ، 'admin' ] ، ['hi' ، 'hi']) â -> ['hi' ، 'hi' ، 'hi' ] total_match ((['4' ] ، ['1' ، '2' ، '3' ، '4' ، '5' ، ['4']) -> ['4' ]'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"یک تابع بنویسید که اگر عدد داده شده ضرب 3 عدد اول باشد و در غیر این صورت غلط باشد، صحیح را باز می گرداند. با دانستن اینکه (a) کمتر از 100 است. مثال: is_multiply_prime(30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"وظیفه شما این است که یک تابع بنویسید که اگر عدد x یک توان ساده n باشد و در موارد دیگر غلط باشد. x یک توان ساده n است اگر n**int=x برای مثال: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) => false is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''یک تابع بنویسید که یک عدد صحیح a را می گیرد و اگر این عدد یک مکعب از یک عدد صحیح باشد، درست را باز می گرداند. توجه: شما ممکن است فرض کنید که ورودی همیشه معتبر است. مثال: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"شما وظیفه دارید تا یک تابع بنویسید که یک عدد شش اعشاری را به عنوان یک رشته دریافت می کند و تعداد اعداد شش اعشاری را که اعداد اولیه هستند را می شمارد (عدد اولیه یا یک عدد اولیه یک عدد طبیعی بزرگتر از 1 است که محصول دو عدد طبیعی کوچکتر نیست). اعداد شش اعشاری عبارتند از: 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، A، B، C، D، E، F. اعداد اولیه عبارتند از: 2، 3، 5، 7، 11، 13، 17، ... بنابراین شما باید تعداد از این اعداد را تعیین کنید: 2، 3، 5، 7، 7، B (= اعشاری 11) ، D (= اعشاری 13) توجه: شما ممکن است فرض کنید که ورودی همیشه صحیح یا خالی است و نمادهای A،B،C،D،E،F همیشه بزرگ هستند. مثال: برای num = \"AB\" خروجی باید num = 1. برای num = \"1077E\" خروجی باید 2. برای num = \"AB33\" AED1 باید num = 4. \"BC\" باید num = 6.06712345 AEFD برای \"2020\" خروجی باید 2.0 \"2020\" باشد.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"شما یک عدد در شکل اعشاری داده می شود و وظیفه شما این است که آن را به فرمت باینری تبدیل کنید. تابع باید یک رشته را بازگردانده شود، که هر کاراکتر یک عدد باینری را نشان می دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود. یک زوج اضافی از کاراکتر 'db' در آغاز و پایان رشته وجود خواهد داشت. کاراکترهای اضافی برای کمک به فرمت وجود دارد. مثال: decimal_to_binary ((15) # بازگردانده می شود \"db1111db\" decimal_to_binary32) # بازگردانده می شود \"db100000db\" \"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"یک رشته s به شما داده شده است. وظیفه شما این است که بررسی کنید که رشته خوشحال است یا نه. یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی متمایز باشند. به عنوان مثال: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy)) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"این آخرین هفته ترم است و معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره گذاری ایجاد کرده است. تنها مشکل این است که کد مورد استفاده برای نمره گذاری را از دست داده است. او لیستی از نمرات GPA برای برخی از دانش آموزان را به شما داده است و شما باید یک تابع بنویسید که می تواند لیستی از نمرات نامه را با استفاده از جدول زیر تولید کند: GPA. نمره نامه 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E: مثال grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"یک تابع بنویسید که یک رشته را می گیرد و اگر طول رشته یک عدد اول باشد درست یا غلط را باز می گرداند در غیر این صورت مثال prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"یک عدد صحیح مثبت n داده شده، شمار اعداد صحیح مثبت n-عددی را که با 1 شروع یا به پایان می رسد را برگرداند. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"با توجه به یک عدد صحیح مثبت N، مجموع رقم های آن را در دوگانه برگردانید. مثال برای N = 1000، جمع رقم ها 1 خواهد بود خروجی باید \"1\" باشد. برای N = 150، جمع رقم ها 6 خواهد بود خروجی باید \"110\" باشد. برای N = 147، جمع رقم ها 12 خواهد بود خروجی باید \"1100\" باشد. متغیرها: @N عدد صحیح محدودیت ها: 0 â‰¤ N â‰¤ 10000. خروجی: یک رشته عدد دوگانه \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"با توجه به یک لیست غیر خالی از اعداد صحیح lst. عناصر جفت را که در شاخص های عجیب هستند اضافه کنید.. مثال: اضافه کردن (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"یک تابع بنویسید که یک رشته را می گیرد و یک نسخه مرتب شده از آن را باز می گرداند. نسخه مرتب شده رشته، رشته ای است که در آن تمام کلمات (با فاصله جدا شده) با یک کلمه جدید جایگزین می شوند که در آن همه کاراکترها بر اساس ارزش ascii به ترتیب بالا رفته اند. توجه: شما باید ترتیب کلمات و فضاهای خالی را در جمله حفظ کنید. به عنوان مثال: anti_shuffle ((('Hi') باز می گرداند 'Hi' anti_shuffle ((('hello') باز می گرداند 'ehllo' anti_shuffle (('سلام دنیا!!!') باز می گرداند 'سلام !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"داده های دو بعدی به عنوان لیست های آشیانه ای داده می شود که شبیه به ماتریس است ، اما برخلاف ماتریس ها ، هر ردیف ممکن است حاوی تعداد ستون های مختلف باشد. با توجه به lst و عدد صحیح x ، اعداد صحیح x را در لیست پیدا کنید و لیست tuples را برگردانید ، [(x1 ، y1 ، (x2 ، y2) ...] به طوری که هر توپل یک مختصات - (صف ، ستون ها) است ، با 0 شروع می شود. مختصات را ابتدا با ردیف ها به ترتیب رو به بالا مرتب کنید. همچنین مختصات ردیف را با ستون ها به ترتیب رو به پایین مرتب کنید. مثال: get_row [1,2,3,4,5,6 ] ، [1,2,3,4,1,6 ] ، [1,2,3,4,5,1] ، 1) == [0,0,0, 0, 1, 4 ] ، 0 (1, 4), 0 (2, 5), (2, 0) get_(((1), [] == [[صف 1, 2، 3]] ، [2, 2]] ]]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"با توجه به یک آرایه از اعداد صحیح غیر منفی، یک کپی از آرایه داده شده را پس از مرتب سازی، شما آرایه داده شده را به ترتیب صعودی مرتب می کنید اگر مجموع ((اولین ارزش شاخص، آخرین ارزش شاخص) عجیب باشد، یا آن را به ترتیب نزولی مرتب کنید اگر مجموع ((اولین ارزش شاخص، آخرین ارزش شاخص) جفت است. توجه: * آرایه داده شده را تغییر ندهید. مثال: * sort_array[(]) => [] * sort_array([5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"یک تابع encrypt ایجاد کنید که یک رشته را به عنوان یک آرگومنت می گیرد و یک رشته رمزگذاری شده را با چرخش الفبا باز می گرداند. الفبا باید به گونه ای چرخش یابد که حروف به دو ضرب دو مکان به سمت پایین حرکت کنند. به عنوان مثال: encrypt ((hi) باز می گرداند 'lm' encrypt ((asdfghjkl)) باز می گرداند 'ewhjklnop' encrypt ((gf)) باز می گرداند 'kj' encrypt ((et)) باز می گرداند 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"یک لیست از اعداد صحیح به شما داده شده است. یک تابع next_smallest () بنویسید که کوچک ترین عنصر دوم را در لیست باز می گرداند. اگر چنین عنصر وجود نداشته باشد، None را باز می گرداند. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () []) == None next_smallest () [1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"یک جملۀ خسته کننده عبارت است از جمله ای که با کلمه \"من\" شروع می شود. جملات با \"\"، \"؟\" یا \"! \" محدود می شوند. به عنوان مثال: >>> خسته شده است. (((\"سلام دنیا\") 0 >>> خسته شده است. ((\"آسمان آبی است. خورشید درخشان است. من عاشق این آب و هوا هستم\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''یک تابع ایجاد کنید که ۳ عدد را می گیرد. اگر یکی از اعداد برابر با مجموع دو عدد دیگر باشد و همه اعداد اعداد صحیح باشند، درست را باز می گرداند. در هر مورد دیگر غلط را باز می گرداند. مثال any_int{\\displaystyle any_int{\\displaystyle any_int{\\displaystyle any_{\\displaystyle {\\displaystyle {\\mathbf {5}}{\\displaystyle {\\mathbf {2}}{\\displaystyle {\\mathbf {2}}}}'''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"یک تابع بنویسید که یک پیام را می گیرد و به گونه ای کدگذاری می کند که همه حروف را عوض کند و تمام حروف صوتی را با حروف که 2 جای قبل از آن حرف صوتی در الفبای انگلیسی ظاهر می شود جایگزین کند. فقط حروف را فرض کنید. مثال: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"شما یک لیست از اعداد صحیح داده شده اید. شما باید بزرگترین مقدار اول را پیدا کنید و جمع رقم های آن را برگردانید. مثال: برای lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] خروجی باید 10 باشد برای lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] خروجی باید 25 باشد برای lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] خروجی باید 13 باشد برای lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] خروجی باید 11 باشد برای lst = [0,81,12,3,21,1] خروجی باید 3 باشد برای lst = [1,8,1,2,1,7] خروجی باید 7 باشد\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"اگر یک دیکشنری داده شده باشد، اگر تمام کلید ها رشته های کوچک یا همه کلید ها رشته های بزرگ باشند، راست را بازگردانید، در غیر این صورت غلط را بازگردانید. تابع باید غلط را بازگردانید اگر دیکشنری داده شده خالی باشد. مثال: check_dict_case{\"a\":\"apple\"، \"b\":\"banana\"}) باید راست را بازگردانید. check_dict_case{\"a\":\"apple\"، \"A\":\"banana\"، \"B\":\"banana\"}) باید غلط را بازگردانید. check_dict_case{\"a\":\"apple\"، 8:\"banana\"، \"a\":\"apple\"}) باید غلط را بازگردانید. check_dict_case{\"Name\":\"John\"، \"Age\":\"36\"، \"City\":\"Houston\"}) باید غلط را بازگردانید. check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"}) باید درست را بازگردانید.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"یک تابع را اجرا کنید که یک عدد صحیح غیر منفی را می گیرد و یک آرایه از اولین n عدد صحیح را که اعداد اول هستند و کمتر از n هستند، باز می گرداند. به عنوان مثال: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"تابع را که دو عدد صحیح را می گیرد و حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل\"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"با توجه به یک رشته s، تعداد حروف بلند بزرگ را در شاخص های جفت بشمارید. به عنوان مثال: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 را باز می گرداند \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''یک تابع ایجاد کنید که یک مقدار (سلسلة) را که یک عدد را نشان می دهد را می گیرد و نزدیک ترین عدد صحیح را به آن باز می گرداند. اگر عدد از دو عدد صحیح مساوی باشد، آن را از صفر دور کنید. مثال >>> نزدیکترین عدد صحیح (((\"10\") 10 >>> نزدیکترین عدد صحیح (((\"15.3\") 15 توجه: دور کردن از صفر به این معنی است که اگر عدد داده شده از دو عدد صحیح مساوی باشد، یکی از آن ها که باید از صفر دورتر باشد، همان را باز می گرداند. برای مثال نزدیکترین عدد صحیح (((14.5\") باید 15 و نزدیکترین عدد صحیح (((-14.5\") باید -15. را باز کند. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"با توجه به یک عدد صحیح مثبت n، شما باید یک انبار از n سطح سنگ بسازید. سطح اول دارای n سنگ است. تعداد سنگ ها در سطح بعدی عبارت است از: - عدد عجیب بعدی اگر n عجیب باشد. - عدد جفت بعدی اگر n جفت باشد. تعداد سنگ ها را در هر سطح در یک لیست برگردانید، جایی که عنصر در شاخص i نشان دهنده تعداد سنگ ها در سطح (i+1) است. مثال: >>> make_a_pile(3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"شما یک رشته از کلمات با کوما یا فاصله جدا شده خواهید داشت. وظیفه شما این است که رشته را به کلمات تقسیم کنید و یک آرایه از کلمات را برگردانید. به عنوان مثال: words_string ((\"سلام، نام من جان است\") == [\"سلام\"، \"من\"، \"نام\"، \"است\"، \"جان\"] words_string ((\"یک، دو، سه، چهار، پنج، شش\") == [\"یک\"، \"دو\"، \"سه\"، \"چهار\"، \"پنج\"، \"شش\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"این تابع دو عدد مثبت x و y را می گیرد و بزرگترین عدد صحیح جفت را که در محدوده [x، y] شامل است، باز می گرداند. اگر چنین عددی وجود نداشته باشد، این تابع باید -1 را بازگردانده باشد. به عنوان مثال: choose_num (((12, 15) = 14 choose_num (((13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"شما دو عدد صحیح مثبت n و m داده شده اید و وظیفه شما محاسبه میانگین عدد صحیح از n تا m (از جمله n و m) است. پاسخ را به نزدیک ترین عدد صحیح گرد کنید و آن را به باینری تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید. مثال: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"با توجه به یک لیست از اعداد صحیح مثبت x. یک لیست مرتب شده از تمام عناصر را که هیچ رقم جفتی ندارد را باز می گرداند. توجه: لیست برگشت باید به ترتیب افزایش یافته مرتب شود. به عنوان مثال: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"با توجه به یک آرایه از اعداد صحیح، اعداد صحیح را که بین 1 و 9 شامل می شود مرتب کنید، آرایه حاصل را معکوس کنید و سپس هر رقم را با نام مربوطه خود از \"یک\"، \"دو\"، \"سه\"، \"چهار\"، \"پنج\"، \" شش\"، \"هفت\"، \"هشت\"، \"نه\" جایگزین کنید. به عنوان مثال: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> مرتب کنید arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr معکوس -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"هشت\"، \"پنج\"، \"سه\"، \"دو\"، \"دو\"، \"یک\"، \"یک\"] اگر آرایه خالی باشد، یک آرایه خالی را برگردانید: arr = [] return [] اگر آرایه دارای یک عدد عجیب باشد، آن را نادیده بگیرید: arr = [1, -1 ، 55] -> arr -> [1, 55] -> arr معکوس = [51] return - ['One' 1] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"تابع f را پیاده سازی کنید که n را به عنوان پارامتر می گیرد و یک لیست با اندازه n را باز می گرداند، به طوری که ارزش عنصر در شاخص i فاکتور i باشد اگر i زوج باشد یا مجموع اعداد از 1 تا i در غیر این صورت. i از 1 شروع می شود. فاکتور i ضرب اعداد از 1 تا i است (1 * 2 * ... * i). مثال: f (((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"با توجه به یک عدد صحیح مثبت n، یک توپل را که دارای تعداد palindromes عدد صحیح و غیر صحیح است که در محدوده ((۱، n) قرار می گیرد، شامل می شود. مثال1: ورودی: 3 خروجی: (1, 2) توضیح: palindrome عدد صحیح 1، 2، 3 است. یکی از آنها جفت است و دو مورد از آنها عجیب است. مثال2: ورودی: 12 خروجی: (4, 6) توضیح: palindrome عدد صحیح 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 است. چهار مورد از آنها جفت هستند و 6 مورد از آنها عجیب هستند. توجه: 1. 1 <= n <= 10 ^ 3 2. توپل به ترتیب تعداد palindromes عدد صحیح و جفت را برگرداند. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"یک تابع count_nums بنویسید که یک آرایه از اعداد صحیح را می گیرد و تعداد عناصری را که مجموع عددها > 0 است را باز می گرداند. اگر یک عدد منفی باشد، اولین رقم امضا شده آن منفی خواهد بود: به عنوان مثال -123 دارای ارقام امضا شده -1, 2 و 3 است. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"ما یک آرایه 'arr' از N عدد صحیح arr[1], arr[2]، ..., arr[N] داریم. اعداد در آرایه به صورت تصادفی ترتیب داده می شوند. وظیفه شما این است که تعیین کنید آیا امکان دارد که یک آرایه را به ترتیب غیر کاهش یافته با انجام عملیات زیر در آرایه داده شده مرتب کنید: شما اجازه دارید تا هر تعداد بار عملیات شیفت راست را انجام دهید. یک عملیات شیفت راست به این معنی است که تمام عناصر آرایه را با یک موقعیت در جهت راست جابجا کنید. آخرین عنصر آرایه به موقعیت اولیه در آرایه منتقل می شود به عنوان مثال 0th. اگر امکان دارد که آرایه مرتب شده را با انجام عملیات فوق بدست آورید، سپس True را برگردانید وگرنه False را برگردانید. اگر آرایه داده شده خالی باشد، پس True را برگردانید. توجه: لیست داده شده تضمین شده است که عناصر منحصر به فرد داشته باشد. برای مثال: move_one_{} ball[3, 4, 5, 2]=== True توضیح: با انجام عملیات right_min 2، غیر کاهش یافته برای آرایه می تواند به دست آورد. برای آرایه داده شده، حرکت_one_{} ball[3, 4, 5]=== False برای انجام عملیات های غیر کاهش یافته ممکن است. برای آرایه داده شده:\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"در این مسئله، شما یک تابع را پیاده سازی خواهید کرد که دو لیست از اعداد را می گیرد و تعیین می کند که آیا امکان انجام یک تبادل عناصر بین آنها برای ایجاد lst1 یک لیست از اعداد حتی وجود دارد. هیچ محدودیتی برای تعداد عناصر مبادله شده بین lst1 و lst2 وجود ندارد. اگر امکان مبادله عناصر بین lst1 و lst2 برای ایجاد تمام عناصر lst1 وجود دارد، \"بله\" را برگردانید. در غیر این صورت، \"نه\" را برگردانید. به عنوان مثال: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"بله\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"نه\" فرض می شود که لیست های ورودی غیر خالی خواهند بود. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"با توجه به یک رشته که نشان دهنده یک حروف کوچک جدا شده از فضا است، یک دیکشنری از حرف با تکرار بیشتر و حاوی شمارش مربوطه را برگردانید. اگر چندین حرف یک اتفاق را داشته باشند، همه آنها را برگردانید. مثال: هیستگرام ((('a b c') == {'a': 1, 'b': 1, 'c': 1} هیستگرام ((('a b b a') == {'a': 2, 'b': 2} هیستگرام ((('a b c a b') == {'a': 2, 'b': 2} هیستگرام ((('b b a') == {'b 4}': هیستگرام (((')) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"وظیفه ما دو رشته s و c داده شده است، شما باید تمام کاراکترهای s را که با هر کاراکتر c برابر است حذف کنید و سپس بررسی کنید که آیا رشته نتیجه پالندروم است. یک رشته اگر به عقب و به جلو همان طور که خوانده می شود، پالندروم نامیده می شود. شما باید یک توپل حاوی رشته نتیجه و True/False را برای بررسی برگردانید. مثال برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'، False) باشد برای s = \"abcdef\"، c = \"b\" نتیجه باید ('acdef'، False) باشد برای s = \"abcdedcba\"، c = \"ab\" نتیجه باید ('cdedc'، True) باشد.\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"با توجه به یک لیست رشته ها، که هر رشته فقط از ارقام تشکیل شده است، یک لیست را بازگردانید. هر عنصر i خروجی باید \"تعداد عناصر عجیب در رشته i ورودی\" باشد. جایی که همه i ها باید با تعداد ارقام عجیب در رشته i ورودی جایگزین شوند. >>> odd_count['1234567']) [\"تعداد عناصر عجیب 4n str4ng 4 از 4nput.\"] >>> odd_count['3'،\"111111\"]) [\"تعداد عناصر عجیب 1n str1ng 1 از 1nput.\"، \"تعداد عناصر عجیب 8n str8ng 8 از 8nput.\"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"با توجه به یک آرایه از اعداد صحیح n، حداقل مجموع هر زیر آرایه خالی از اعداد را پیدا کنید. مثال minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"یک شبکه مستطیل از چاه ها به شما داده می شود. هر ردیف یک چاه را نشان می دهد و هر یک از آن ها یک واحد آب را نشان می دهد. هر چاه دارای سطل است که می تواند برای استخراج آب از آن استفاده شود و همه سطل ها دارای ظرفیت یکسان هستند. وظیفه شما این است که از سطل ها برای خالی کردن چاه ها استفاده کنید. تعداد دفعات که برای پایین آوردن سطل ها نیاز دارید را وارد کنید. مثال 1: ورودی: شبکه: [[0,0,1,0] ، [0,1,0,0] ، [1,1,1,1]] bucket_capacity: 1 خروجی: 6 مثال 2: ورودی: شبکه: [[0,0,1,1] ، [0,0,0,0] ، [1,1,1] ، [0,1,1]] bucket_capacity: 2 خروجی: 5 مثال 3: ورودی: [[:0,0,0]] ، [0,0,0]] bucket_capacity: 5 خروجی: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"در این کاتا ، شما باید یک آرایه از اعداد کامل غیر منفی را با توجه به تعداد یک ها در نمایش دوگانه آنها به ترتیب رو به افزایش مرتب کنید. برای تعداد مشابه یک ها ، بر اساس مقدار اعشاری مرتب کنید. باید به این ترتیب اجرا شود: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"با توجه به یک رشته s و یک عدد طبیعی n، شما وظیفه دارید تا یک تابع را پیاده سازی کنید که لیستی از تمام کلمات را از رشته s که دقیقاً n ضمائر دارند، باز می گرداند تا این کلمات در رشته s ظاهر شوند. اگر رشته s خالی باشد، این تابع باید یک لیست خالی را باز گرداند. توجه: ممکن است فرض کنید رشته ورودی فقط شامل حروف و فاصله است. مثال: select_words (((\"مری یک بره کوچک داشت\"، 4) ==> [\"little\"] select_words (((\"مری یک بره کوچک داشت\"، 3) ==> [\"مری\"، \"lamb\"] select_words\" (((فضای سفید ساده\"، 2) ==> [] select_words (((\"سلام دنیا\"، 4) ==> [\"world\"] select_words (((\"عم سام\"، 3) ==> [\"عم\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"یک کلمه به شما داده شده است. وظیفه شما این است که نزدیک ترین حرف صوتی را که بین دو ضمائر از سمت راست کلمه قرار دارد پیدا کنید (حساس به حروف کوچک و بزرگ). حرف های صوتی در آغاز و پایان شمارش نمی شوند. اگر هیچ حرف صوتی را پیدا نکردید که شرایط فوق را برآورده کند، یک رشته خالی را برگردانید. ممکن است فرض کنید که رشته داده شده فقط شامل حرف انگلیسی است. مثال: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''شما لیستی از دو رشته داده می شوید، هر دو رشته فقط از قوس های باز '(' یا قوس های بسته ') ' تشکیل شده اند. کار شما این است که بررسی کنید که آیا امکان اتصال دو رشته به ترتیب وجود دارد، که نتیجه رشته خوب خواهد بود. یک رشته S اگر و تنها اگر تمام قوس های S متعادل باشند، خوب است. به عنوان مثال: رشته '((()) ' خوب است، در حالی که رشته '()) ' نیست. اگر راهی برای ساختن یک رشته خوب وجود داشته باشد، 'بله' را بازگردانید و در غیر این صورت 'نه' را بازگردانید. مثال: match_parens[('() ', ') ']) == 'بله' match_parens[(') ', ') ']) == 'نه' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"با توجه به یک آرایه ار از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k را با حداکثر k عدد در آرر برگردانید. مثال1: ورودی: arr = [-3، -4، 5] ، k = 3 خروجی: [-4، -3، 5] مثال2: ورودی: arr = [4، -4، 4] ، k = 2 خروجی: [4، 4] مثال3: ورودی: arr = [-3، 2، 1، 2، -1، 2، 1] ، k = 1 خروجی: [2] توجه: 1. طول آرایه در محدوده [1، 1000] خواهد بود. 2. عناصر در آرایه در محدوده [-1000، 1000] خواهد بود. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"با توجه به یک لیست غیر خالی از اعداد صحیح، جمع تمام عناصر عجیب را که در موقعیت های حتی هستند، برگردانید. مثال ها راه حل (([5, 8, 7, 1]) ==> 12 راه حل (([3, 3, 3, 3, 3]) ==> 9 راه حل (([30, 13, 24, 321]) ==>0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"با توجه به یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، جمع عناصر با حداکثر دو رقم از اولین عناصر k arr را برگردانید. مثال: ورودی: arr = [111,21,3,4000,5,6,7,8,9], k = 4 خروجی: 24 # جمع 21 + 3 محدودیت ها: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"با توجه به یک عدد صحیح مثبت n، یک لیست مرتب شده که دارای اعداد عجیب در دنباله collatz است را بازگردانید. حدس Collatz یک حدس در ریاضیات است که مربوط به یک دنباله تعریف شده به شرح زیر است: با هر عدد صحیح مثبت n شروع کنید. سپس هر اصطلاح از اصطلاح قبلی به این ترتیب بدست می آید: اگر اصطلاح قبلی جفت باشد ، اصطلاح بعدی نیمی از اصطلاح قبلی است. اگر اصطلاح قبلی عجیب باشد ، اصطلاح بعدی 3 برابر اصطلاح قبلی به علاوه 1 است. حدس این است که مهم نیست که ارزش n چیست ، دنباله همیشه به 1 می رسد. توجه: 1. Collatz (((1) [1] است. 2. لیست مرتب شده در ترتیب افزایش یافته است. به عنوان مثال: get_odd_collatz (((5) [1, 5] # دنباله collatz برای 5 [5, 8, 16, 4, 2, 1] است ، بنابراین اعداد عجیب فقط 1 و 5  هستند.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"شما باید یک تابع بنویسید که یک رشته تاریخ داده شده را تایید کند و اگر تاریخ معتبر باشد درست را باز می گرداند در غیر این صورت غلط. تاریخ معتبر است اگر تمام قواعد زیر برآورده شود: 1. رشته تاریخ خالی نباشد. 2. تعداد روزها کمتر از 1 یا بیشتر از 31 روز برای ماه های 1,3,5,7,8,10,12 نیست. و تعداد روزها کمتر از 1 یا بیشتر از 30 روز برای ماه های 4,6,9,11 نیست. و تعداد روزها کمتر از 1 یا بیشتر از 29 برای ماه 2. 3. ماه ها نباید کمتر از 1 یا بیشتر از 12. 4. تاریخ باید در فرمت: mm-dd-yyyy باشد برای مثال: valid_date ((('03-11-2000') => valid_date (((15-01-2012') => false valid_date ((('04-02040') => false_date (((((06-04-2020') => true_date (((((06/04/2020') => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''با توجه به یک رشته از کلمات، یک لیست از کلمات تقسیم شده بر روی فضای خالی را بازگردانید، اگر هیچ فضای خالی در متن وجود نداشته باشد، باید بر روی کاماها تقسیم شود، اگر هیچ کامایی وجود نداشته باشد، باید تعداد حروف کوچک را با ترتیب عجیب در الفبا، ord ((('a') = 0، ord (((b') = 1، ... ord ((('z') = 25 مثال ها تقسیم_کلمات (((\"سلام دنیا!\") â -> [\"سلام\"، \"دنیا!\"] split_words (((\"سلام، جهان!\") â -> [\"سلام\"، \"دنیا!\" split_words (((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''اگر یک لیست از اعداد داده شده باشد، آن ها را به ترتیب بالا رفته یا نه، بازگردانید. اگر لیست بیش از یک نسخه از همان عدد داشته باشد، False را بازگردانید. فرض کنید که هیچ عدد منفی و فقط اعداد صحیح وجود ندارد. مثال ها is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 2, 3, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"شما دو فاصله داده شده است که هر فاصله یک جفت عدد صحیح است. به عنوان مثال، فاصله = (آغاز، پایان) = (1, 2). فاصله داده شده بسته است که به این معنی است که فاصله (آغاز، پایان) شامل شروع و پایان است. برای هر فاصله داده شده، فرض می شود که شروع آن کمتر از یا برابر با پایان آن است. وظیفه شما این است که تعیین کند که آیا طول تقاطع این دو فاصله یک عدد اول است. به عنوان مثال، تقاطع فاصله (1, 3) ، (2، 4) (2، 3) است که طول آن 1 است که یک عدد اول نیست. اگر طول تقاطع یک عدد اول است، \"بله\" را برگردانید، در غیر این صورت \"نه\" را برگردانید. اگر دو فاصله تقاطع نمی کنند، \"نه\" را برگردانید. نمونه ها: تقاطع (((1، 2، 2) ==> \"تقاطع-1، (((1) \") \"> (2، 3) \"تقاطع-1، (((1) \") 4) \"تقاطع (0,\" ==> \"NO\" ==> 5، (((1) \"> (- (-، 3، 5، 5، (((1)))\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"یک آرایه از اعداد کامل به شما داده شده است و شما باید مجموع مقادیر اعداد کامل ضرب شده با محصول تمام نشانه های هر عدد در آرایه را که توسط 1، -1 یا 0 نشان داده شده است را برگردانید. توجه: برای آرایه خالی هیچ کدام را برگردانید. مثال: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None \"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"با توجه به یک شبکه با N ردیف و N ستون (N >= 2) و یک عدد صحیح مثبت k ، هر سلول شبکه حاوی یک مقدار است. هر عدد صحیح در محدوده [1 ، N * N] شامل یک بار در سلول های شبکه ظاهر می شود. شما باید حداقل مسیر طول k را در شبکه پیدا کنید. شما می توانید از هر سلول شروع کنید و در هر مرحله می توانید به هر یک از سلول های همسایه بروید ، به عبارت دیگر ، می توانید به سلول هایی که لبه ای با شما دارند بروید. لطفا توجه داشته باشید که یک مسیر طول k به معنای بازدید از دقیقا k سلول (نه لزوما متمایز) است. شما نمی توانید از شبکه خارج شوید. یک مسیر A (طول k) کمتر از یک مسیر B (طول k) در نظر گرفته می شود اگر پس از ایجاد لیست های مرتب شده از مقادیر در سلول های A و B (باید آنها را l_st و l_stA صدا کنیم) ، l_stA از نظر لغوی کمتر از l_stA است ، به عبارت دیگر ، یک عدد صحیح در شبکه وجود دارد. مثال: [A، j_1، j_1، j_2، j_4، j_8، j_1، j_2، j_8، j_1، j_8، j_2، j_8، j_8، j_8، j_9، j_8، j_9، j_1، j_8، j_9، j_1، j_6، j_8، j_8، j_9، j_1، j_8، j_9، j_1، j_8، j_9، j_1، j_[]، j_[]، []، j_[]، []، []، [، k]، k===]، [=]، [=]، [=]، [=]، [=]، [=]، [=]، [=]، [=]، [=، [=]، [=، [=، [=]، [=، [=،]، [=، [=،]، [=،]، [=،]، [=، [=،]، [=،]، [=، [=،]، [=،]، [=، [=،]\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"هر کسی دنباله فیبوناچی را می شناسد، این دنباله در دو قرن گذشته توسط ریاضیدانان به طور عمیق مورد مطالعه قرار گرفته است. با این حال، آنچه مردم نمی دانند دنباله تریبوناچی است. دنباله تریبوناچی با تکرار تعریف می شود: tri(1) = 3 tri(n) = 1 + n / 2، اگر n زوج است. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، اگر n عجیب است. به عنوان مثال: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 شما یک عدد صحیح غیر منفی n داده شده اید، شما باید یک لیست از اولین n + 1 اعداد دنباله تریبوناچی را برگردانید. مثال: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"با توجه به یک عدد صحیح مثبت n، حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل\"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''یک تابع ایجاد کنید که یک رشته را به عنوان ورودی می گیرد که فقط شامل براکت های مربع است. تابع باید True را برگرداند اگر و تنها اگر یک زیرنویس معتبر از براکت ها وجود داشته باشد که حداقل یک براکت در زیرنویس در آن جای داده شده باشد. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"یک لیست از اعداد به شما داده می شود. شما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید، هر عنصر در لیست را به بالا جمع کنید. مثال: برای lst = [1,2,3] خروجی باید 14 باشد برای lst = [1,4,9] خروجی باید 98 باشد برای lst = [1,3,5,7] خروجی باید 84 باشد برای lst = [1.4,4.2,0] خروجی باید 29 باشد برای lst = [-2.4,1,1] خروجی باید 6 باشد\"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''یک تابع ایجاد کنید که اگر آخرین کاراکتر یک رشته داده شده یک کاراکتر الفبایی باشد و بخشی از یک کلمه نباشد و در غیر این صورت غلط باشد. توجه: \"کلمه\" یک گروه از کاراکترها است که با یک فضای جدا شده است. مثال: check_if_last_char_is_a_letter ((\"apple pie\") â -> False check_if_last_char_is_a_letter (((apple pi e\") â -> True check_if_last_char_is_a_letter ((\"apple pi e \") â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"یک تابع ایجاد کنید که بزرگترین شاخص یک عنصر را که بزرگتر از یا برابر با عنصر بلافاصله قبل از آن نیست را باز می گرداند. اگر چنین عنصر وجود نداشته باشد پس -1 را باز می گرداند. آرایه داده شده شامل مقادیر تکراری نخواهد بود. مثال: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''یک تابع ایجاد کنید که یک توپل (a, b) را باز می گرداند، جایی که 'a' بزرگترین عدد صحیح منفی است و 'b' کوچک ترین عدد صحیح مثبت در یک لیست است. اگر عدد صحیح منفی یا مثبت وجود نداشته باشد، آنها را به عنوان None باز می گرداند. مثال: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"یک تابع ایجاد کنید که اعداد صحیح، شناور یا رشته های نمایانگر اعداد واقعی را می گیرد و متغیر بزرگتر را در نوع متغیر داده شده خود باز می گرداند. اگر مقادیر برابر باشند، هیچ را باز می گرداند. توجه: اگر یک عدد واقعی به عنوان یک رشته نمایش داده شود، نقطه شناور ممکن است . یا ، compare_one ((۱، ۲.۵) â -> ۲.۵ compare_one ((۱، ۲.۳)) â -> \"۲.۳\" compare_one ((۵، ۱، ۶)) â -> \"۶\" compare_one ((۱، ۱)) â -> هیچ \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"ارزیابی کنید که آیا عدد n داده شده را می توان به عنوان مجموع 4 عدد مثبت جفت به طور دقیق نوشت. مثال: برابر با جمع برابر است.\"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"فاکتورال برازیلی به این شکل تعریف شده است: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! جایی که n > 0 برای مثال: >>> special_factorial ((4) 288 تابع یک عدد صحیح را به عنوان ورودی دریافت می کند و باید فاکتورال خاص این عدد صحیح را بازگردانده باشد. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_مثال-3شته ای، تمام فضای موجود در آن را با زیرنویس ها جایگزین کنید، و اگر یک رشته بیش از 2 فضای متوالی داشته باشد، تمام فضای متوالی را با - fix_spaces ((\"مثال\") == \"مثال\" fix_spaces ((\"مثال1\") == \"مثال1\" fix_spaces (((\"مثال2\") == \"_مثال_2\" fix_spaces ((\"مثال 3\") == \"_مثال-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"یک تابع ایجاد کنید که یک رشته را که نام یک فایل را نشان می دهد، می گیرد و اگر نام فایل معتبر باشد، \"بله\" را باز می گرداند و در غیر این صورت \"نه\" را باز می گرداند. یک نام فایل فقط و فقط در صورتی معتبر است که تمام شرایط زیر برآورده شود: - نباید بیش از سه رقم ('0'-'9') در نام فایل وجود داشته باشد. - نام فایل دقیقاً یک نقطه '.' را شامل می شود. - زیر رشته قبل از نقطه نباید خالی باشد و با یک حرف از الف لاتین شروع می شود ('a'-'z' و 'A'Z'). - زیر رشته بعد از نقطه باید یکی از این موارد باشد: ['txt'، 'exe'، 'll'] مثال: file_name_check\"(example.txt\") # => 'بله' file_name_check\"(example.dll1\") => 'نه' # (نام باید با یک حرف الف لاتین شروع شود)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" این تابع یک لیست از اعداد صحیح را می گیرد. برای تمام نوشته های موجود در لیست، تابع باید عدد صحیح را مربع کند اگر شاخص آن چند برابر 3 باشد و اگر شاخص آن چند برابر 4 باشد و نه چند برابر 3، تابع واردات عدد صحیح را مکعب خواهد کرد. تابع واردات موجود در لیست را که شاخص آن چند برابر 3 یا 4 نیست تغییر نخواهد داد. سپس تابع باید مجموع همه نوشته ها را بازگردانده است. مثال: برای lst = [1,2,3] خروجی باید 6 باشد برای lst = [] خروجی باید 0 باشد برای lst = [-1,-5,2,-1,-5] خروجی باید -126 باشد \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"یک رشته ای به شما داده می شود که یک جمله را نشان می دهد، این جمله شامل برخی از کلمات با یک فضای جداگانه است، و شما باید یک رشته را که شامل کلمات از جمله اصلی است، که طول آن اعداد اول است، برگردانید، ترتیب کلمات در رشته جدید باید همان جمله اصلی باشد. مثال1: ورودی: جمله = \"این یک تست است\" خروجی: \"است\" مثال2: ورودی: جمله = \"بگذارید برای شنا بروید\" خروجی: \"برای رفتن\" محدودیت ها: * 1 <= len(sentence) <= 100 * جمله فقط شامل حروف است \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"وظیفه شما این است که یک تابع را پیاده سازی کنید که عبارت x * n را ساده کند. این تابع اگر x * n به یک عدد کامل و در غیر این صورت False باز گردد. هر دو x و n، نمایش رشته ای از کسری هستند و دارای فرمت زیر هستند، <numerator>/<denominator> که در آن هم عدد و هم ممیز اعداد کامل مثبت هستند. شما می توانید فرض کنید که x و n کسری های معتبر هستند و صفر به عنوان ممیز ندارند. ساده کنید (((\"1/5\"، \"5/1\") = True ساده کنید (((\"1/6\"، \"2/1\") = False ساده کنید (((\"7/10\"، \"10/2\") = False \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"یک تابع بنویسید که لیست داده شده از اعداد صحیح را با ترتیب رو به افزایش بر اساس جمع رقم های آنها مرتب کند. توجه: اگر چندین مورد با مجموع مشابه رقم های آنها وجود دارد ، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید. به عنوان مثال: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی می گیرد و تعداد عناصر در آرایه را که بزرگتر از 10 است و هر دو رقم اول و آخر یک عدد عجیب هستند (1، 3، 5، 7، 9) را باز می گرداند. به عنوان مثال: specialFilter (([15، -73، 14، -15]) => 1 specialFilter (([33، -2، -3، 45، 21، 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"یک عدد صحیح مثبت n به شما داده شده است. شما باید یک آرایه عدد صحیح a با طول n ایجاد کنید. برای هر i (1 ‰¤ i ‰¤ n) ، ارزش a[i] = i * i - i + 1 را برگردانید. تعداد سه گانه (a[i] ، a[j] ، a[k]) از a را برگردانید که در آن i < j < k است و a[i] + a[j] + a[k] یک چند برابر 3 است. مثال: ورودی: n = 5 خروجی: 1 توضیح: a = [1, 3, 7, 13, 21] تنها سه گانه معتبر (1, 7, 13) است. \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''هشت سیاره در منظومه شمسی ما وجود دارد: نزدیک ترین به خورشید عطارد است ، بعدی زهره است ، سپس زمین ، مریخ ، مشتری ، زحل ، اورانوس ، نپتون. یک تابع بنویسید که دو نام سیاره را به عنوان رشته های سیاره 1 و سیاره 2 می گیرد. تابع باید یک توپل را با تمام سیارات که مدار آنها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد ، مرتب کند. تابع باید یک توپل خالی را برگرداند اگر سیاره 1 یا سیاره 2 نام سیاره صحیح نباشد. مثال bf \"(مشتری\"، \"نپتون\") ==> (\"زحل\"، \"اورانوس\") bf (((\"زمین\"، \"مشتری\") ==> (\"زهره\") bf (((\"زحل\"، \"اورانوس\") ==> (\"زهره\"، \"زمین\"، \"مشتری\"، \"مشتری\"، \"زحل\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"یک تابع بنویسید که یک لیست از رشته ها را به عنوان پارامتر قبول کند، رشته هایی را که دارای طول های عجیب از آن هستند حذف کند و لیست نتیجه را با یک ترتیب مرتب شده بازگردانده شود. لیست همیشه یک لیست از رشته ها است و هرگز یک آرایه از اعداد نیست و ممکن است حاوی تکراری باشد. ترتیب لیست باید با طول هر کلمه بالا رود و شما باید لیست را با این قانون مرتب کنید. اگر دو کلمه دارای طول یکسان هستند، لیست را به صورت الفبایی مرتب کنید. تابع باید یک لیست از رشته ها را به ترتیب مرتب کرده بازگردانده کند. شما ممکن است فرض کنید که همه کلمات دارای طول یکسان هستند. به عنوان مثال: assert list_sort[\"aa\"\"، \"a\"\"، \"aaa\"]) => assert list_sort[\"ab\"\"، \"a\"\"، \"aaa\" => assert list_sort[\"ab\"])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"یک برنامه ساده که باید ارزش x را اگر n یک عدد اول باشد و در غیر این صورت باید ارزش y را برگرداند. مثال: برای x_or_y ((7, 34, 12) == 34 برای x_or_y ((15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''با توجه به یک لیست از اعداد، جمع مربع های اعداد عجیب در لیست را برگردانید. اعداد منفی یا غیر عدد را نادیده بگیرید. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference ((([0]) == 0 اگر لیست ورودی خالی باشد، 0 را برگردانید. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"من فکر می کنم همه ما این احساس را به یاد می آوریم که در نهایت نتیجه برخی از رویدادهای طولانی مدت انتظار می رود شناخته شده است. احساسات و افکار شما در آن لحظه قطعاً ارزش یادداشت کردن و مقایسه را دارد. وظیفه شما تعیین این است که آیا یک شخص نتایج تعدادی از مطابقت ها را به درستی حدس زده است. شما دو آرایه نمره و حدس های با طول یکسان داده می شوید ، جایی که هر شاخص یک مطابقت را نشان می دهد. یک آرایه با همان طول را نشان می دهد که هر حدس چقدر دور است. اگر آنها حدس زده اند ، ارزش 0 است و اگر نه ، ارزش تفاوت مطلق بین حدس و نمره است. مثال: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4],[0,4,1,0,-2]) -> [4,4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"به شما نام یک کلاس (یک رشته) و یک لیست از افزونه ها داده می شود. افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: بگذارید CAP تعداد حروف بزرگ در نام افزونه باشد، و بگذارید SM تعداد حروف کوچک در نام افزونه باشد، قدرت توسط کسری CAP - SM داده می شود. شما باید قوی ترین افزونه را پیدا کنید و یک رشته را در این فرمت برگردانید: ClassName.StrongestExtensionName. اگر دو یا چند افزونه با همان قدرت وجود دارد، باید یکی را انتخاب کنید که در لیست اول می آید. به عنوان مثال، اگر به شما \"Slices\" به عنوان کلاس و یک لیست از افزونه ها داده شده است: ['SEviRNGSliCes'، 'Cheese', 'StuFfed'] سپس شما باید 'Slices.SEviRNGSliCes' را برگردانید، زیرا 'SviRNGSliCes'، 'SviRNGSliCes'، 'mySviRNGSliCes']) قوی ترین است. (مثال: 'AA_Beats'، Strongest_Class' = 'AA'، Strongest_Extension' = Strongest_Class')\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"شما 2 کلمه داده شده است. شما نیاز به بازگشت درست است اگر کلمه دوم و یا هر یک از چرخش آن یک زیر رشته در کلمه اول cycpattern_check (((\"abcd\",\"abd\") => غلط cycpattern_check (((\"سلام\",\"ell\") => درست cycpattern_check (((\"whassup\",\"psus\") => غلط cycpattern_check (((\"abab\",\"baa\") => درست cycpattern_check (((\"efef\",\"eeff\") => غلط cycpattern_check (((hims\",\"simen\") => درست \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"یک عدد صحیح داده شده. یک توپل را که به ترتیب تعداد اعداد جفت و عجیب را دارد، بازگردانید. مثال: even_odd_count ((-12) ==> (1, 1) even_odd_count ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"یک عدد صحیح مثبت داده شده، معادل آن را به شکل یک رشته بدست آورید و آن را به صورت کوچک برگردانید. محدودیت ها: 1 <= num <= 1000 نمونه ها: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''طول سه طرف مثلث را داده است. اگر سه طرف مثلث راست زاویه ای را تشکیل دهند، درست را باز می گرداند، در غیر این صورت غلط است. مثلث راست زاویه ای مثلث است که در آن یک زاویه زاویه راست یا 90 درجه است. مثال: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"یک تابع بنویسید که یک لیست از رشته ها را قبول کند. این لیست شامل کلمات مختلف است. کلمه را با حداکثر تعداد کاراکترهای منحصر به فرد برگردانید. اگر چندین رشته دارای حداکثر تعداد کاراکترهای منحصر به فرد باشند، کلمه ای را که در ترتیب لغت شناسی اول می آید برگردانید. find_max (([\"name\"، \"of\"، \"string\"]) == \"string\" find_max (([\"name\"، \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"شما یک خرگوش گرسنه هستید و قبلاً تعداد مشخصی از هویج را خورده اید ، اما اکنون برای تکمیل وعده های غذایی روزانه باید هویج بیشتری بخورید. شما باید یک آرایه از [ تعداد کل هویج خورده شده پس از وعده های غذایی خود ، تعداد هویج های باقی مانده پس از وعده های غذایی خود ] را برگردانید اگر هویج های باقی مانده کافی نباشد ، شما تمام هویج های باقی مانده را می خورید ، اما هنوز هم گرسنه خواهید بود. مثال: * خوردن (((5, 6, 10) -> [11, 4] * خوردن (((4, 8, 9) -> [12, 1] * خوردن (((1, 10, 10) -> [11, 0] * خوردن (((2, 11, 5) -> [7, 0] متغیرها: @number: عدد صحیح تعداد هویج هایی که خورده اید. @need: عدد صحیح تعداد هویج هایی که باید بخورید. @remaining: عدد صحیح تعداد هویج های باقی مانده در انبار موجود است. Constrain: * 0= <= 0 * 1000 <= 0 * 1000 <= 0 باقی مانده = 1000 <= 1000 = 1000 = 0 تفریح کنید:)\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"دو لیست عملگر و عملگر داده شده. لیست اول دارای عملیات الجبر اساسی است و لیست دوم یک لیست از اعداد صحیح است. از دو لیست داده شده برای ساخت عبارت الجبری استفاده کنید و ارزیابی این عبارت را برگردانید. عملیات الجبر اساسی: جمع (+) تفریق (- ) ضرب (*) تقسیم طبقه ( //) ضریب ( **) مثال: عملگر['+'، '*'، '-'] آرایه = [2, 3, 4, 5] نتیجه = 2 + 3 * 4 - 5 => نتیجه = 9 توجه: طول لیست عملگر برابر با طول لیست عملگر منفی یک است. عملگر لیستی از اعداد صحیح غیر منفی است. عملگر حداقل یک لیست عملگر دارد و عملگر لیستی حداقل دو عملگر دارد. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"یک رشته s به شما داده می شود. اگر s[i] یک حرف باشد، مورد آن را از پایین به بالا یا برعکس معکوس کنید، در غیر این صورت آن را همان طور که است نگه دارید. اگر رشته حاوی هیچ حرفی نباشد، رشته را معکوس کنید. تابع باید رشته حاصل را بازگردانده باشد. مثال ها solve ((\"1234\") = \"4321\" solve ((\"ab\") = \"AB\" solve ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"اگر یک رشته 'text' داده شده باشد، رشته معادل هش md5 آن را بازگردانید. اگر 'text' یک رشته خالی باشد، None را بازگردانید. >>> string_to_md5 (('سلام دنیا') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "prs_Arab",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"با توجه به دو عدد صحیح مثبت a و b، اعداد جفت بین a و b را به ترتیب رو به افزایش برگردانید. به عنوان مثال: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]