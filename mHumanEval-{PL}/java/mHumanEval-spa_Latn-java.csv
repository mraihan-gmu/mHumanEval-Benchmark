task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / en el umbral dado.     / Compruebe si en la lista de números de una matriz dada, hay dos números más cercanos entre sí que     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))), (0.5f))
    // (false)
    // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.3f))
    // (true)
    public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {
","import java.util.ArrayList;
import java.util.Collections;

class Problem {
    public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {
        if(numbers == null || numbers.size() < 2) {
            return false;
        }
        Collections.sort(numbers);
        for (int i = 0; i < numbers.size() - 1; i++) {
            if (Math.abs(numbers.get(i) - numbers.get(i + 1)) < threshold) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        ArrayList<Float> numbers1 = new ArrayList<>(Arrays.asList(1.0f, 2.0f, 3.0f));
        System.out.println(hasCloseElements(numbers1, 0.5f)); // Output: false

        ArrayList<Float> numbers2 = new ArrayList<>(Arrays.asList(1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f));
        System.out.println(hasCloseElements(numbers2, 0.3f)); // Output: true
    }
}","    }
    public static void main(String[] args) {
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f))), (0.3f)) == (true));
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f))), (0.05f)) == (false));
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f))), (0.95f)) == (true));
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f))), (0.8f)) == (false));
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.1f)) == (true));
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f))), (1.0f)) == (true));
    assert(hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f))), (0.5f)) == (false));
    }

}
"
HumanEval_1,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ignore cualquier espacio en la cadena de entrada.     / Los grupos separados están equilibrados (cada braza abierta está debidamente cerrada) y no anidados entre sí     / separar esos grupos en cadenas separadas y devolver la lista de matrices de los mismos.     / La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidadas.    // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (new ArrayList<String>(Arrays.asList((String)""()"", (String)""(())"", (String)""(()())"")))
    public static ArrayList<String> separateParenGroups(String paren_string) {
","import java.util.ArrayList;

public class Problem {
    public static ArrayList<String> separateParenGroups(String paren_string) {
        ArrayList<String> groups = new ArrayList<>();
        int balance = 0;
        StringBuilder currentGroup = new StringBuilder();

        for (char c : paren_string.toCharArray()) {
            if (c == '(') {
                balance++;
                currentGroup.append(c);
            } else if (c == ')') {
                balance--;
                currentGroup.append(c);
            }

            if (balance == 0 && currentGroup.length() > 0) {
                groups.add(currentGroup.toString());
                currentGroup.setLength(0);
            }
        }

        return groups;
    }

    public static void main(String[] args) {
        ArrayList<String> result = separateParenGroups(""( ) (( )) (( )( ))"");
        System.out.println(result); // Output: [""()"", ""(())"", ""(()())""]
    }
}","    }
    public static void main(String[] args) {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((new ArrayList<String>(Arrays.asList((String)""(()())"", (String)""((()))"", (String)""()"", (String)""((())()())"")))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((new ArrayList<String>(Arrays.asList((String)""()"", (String)""(())"", (String)""((()))"", (String)""(((())))"")))));
    assert(separateParenGroups((""(()(())((())))"")).equals((new ArrayList<String>(Arrays.asList((String)""(()(())((())))"")))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((new ArrayList<String>(Arrays.asList((String)""()"", (String)""(())"", (String)""(()())"")))));
    }

}
"
HumanEval_2,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve la parte decimal del número.     / (la parte sobrante siempre es menor que 1).     / y la parte entera (integer más grande más pequeño que el número dado) y decimales     / Dado un número de punto flotante positivo, se puede descomponer en     // >>> truncateNumber((3.5f))
    // (0.5f)
    public static float truncateNumber(float number) {
","int integerPart = (int) number;
        return number - integerPart;
    }
}","    }
    public static void main(String[] args) {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / en ese punto la función debe devolver verdadero. de lo contrario debe devolver falso.     Su tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y     / Se le da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (false)
    // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l))))
    // (true)
    public static boolean belowZero(ArrayList<Long> operations) {
","import java.util.ArrayList;

public class Problem {
    public static boolean belowZero(ArrayList<Long> operations) {
        long balance = 0;
        for (Long operation : operations) {
            balance += operation;
            if (balance < 0) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        ArrayList<Long> operations1 = new ArrayList<Long>(Arrays.asList(1L, 2L, 3L));
        System.out.println(belowZero(operations1)); // false

        ArrayList<Long> operations2 = new ArrayList<Long>(Arrays.asList(1L, 2L, -4L, 5L));
        System.out.println(belowZero(operations2)); // true
    }
}","    }
    public static void main(String[] args) {
    assert(belowZero((new ArrayList<Long>(Arrays.asList()))) == (false));
    assert(belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-3l, (long)1l, (long)2l, (long)-3l)))) == (false));
    assert(belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l, (long)6l)))) == (true));
    assert(belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)2l, (long)-2l, (long)5l, (long)-5l, (long)4l, (long)-4l)))) == (false));
    assert(belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)2l, (long)-2l, (long)5l, (long)-5l, (long)4l, (long)-5l)))) == (true));
    assert(belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)-2l, (long)2l, (long)-2l, (long)5l, (long)-5l, (long)4l, (long)-4l)))) == (true));
    }

}
"
HumanEval_4,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / MAD = promedio  x - x_mean     / elemento y un punto central (media en este caso):     / La desviación absoluta media es la diferencia absoluta media entre cada     / alrededor de la media de este conjunto de datos.     / Para una lista de matrices de números de entrada, calcule la desviación absoluta media     // >>> meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f))))
    // (1.0f)
    public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {
","import java.util.ArrayList;

class Problem {
    // For a given array list of input numbers, calculate Mean Absolute Deviation
    // around the mean of this dataset.
    public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {
        if (numbers == null || numbers.isEmpty()) {
            throw new IllegalArgumentException(""The list should not be null or empty"");
        }
        
        // Calculate mean
        float sum = 0.0f;
        for (float num : numbers) {
            sum += num;
        }
        float mean = sum / numbers.size();
        
        // Calculate Mean Absolute Deviation
        float madSum = 0.0f;
        for (float num : numbers) {
            madSum += Math.abs(num - mean);
        }
        
        return madSum / numbers.size();
    }

    // A main method to demonstrate functionality
    public static void main(String[] args) {
        ArrayList<Float> numbers = new ArrayList<Float>();
        numbers.add(1.0f);
        numbers.add(2.0f);
        numbers.add(3.0f);
        numbers.add(4.0f);

        float mad = meanAbsoluteDeviation(numbers);
        System.out.println(""Mean Absolute Deviation: "" + mad);
    }
}","    }
    public static void main(String[] args) {
    assert(meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f)))) == (0.5f));
    assert(meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f)))) == (1.0f));
    assert(meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f)))) == (1.2f));
    }

}
"
HumanEval_5,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Insertar un número ""delimitador"" entre cada dos elementos consecutivos de la lista de matrices de entrada `numbers'     // >>> intersperse((new ArrayList<Long>(Arrays.asList())), (4l))
    // (new ArrayList<Long>(Arrays.asList()))
    // >>> intersperse((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (4l))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)4l, (long)3l)))
    public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    // Insert a number 'delimeter' between every two consecutive elements of input array list `numbers'
    public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {
        if (numbers == null || numbers.size() <= 1) {
            return numbers;
        }

        ArrayList<Long> result = new ArrayList<>();
        for (int i = 0; i < numbers.size(); i++) {
            result.add(numbers.get(i));
            if (i != numbers.size() - 1) {
                result.add(delimeter);
            }
        }
        return result;
    }
    
    public static void main(String[] args) {
        ArrayList<Long> numbers1 = new ArrayList<>(Arrays.asList());
        ArrayList<Long> result1 = intersperse(numbers1, 4L);
        System.out.println(result1);

        ArrayList<Long> numbers2 = new ArrayList<>(Arrays.asList(1L, 2L, 3L));
        ArrayList<Long> result2 = intersperse(numbers2, 4L);
        System.out.println(result2);
    }
}","    }
    public static void main(String[] args) {
    assert(intersperse((new ArrayList<Long>(Arrays.asList())), (7l)).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(intersperse((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)2l))), (8l)).equals((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)6l, (long)8l, (long)3l, (long)8l, (long)2l)))));
    assert(intersperse((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l, (long)2l, (long)2l)))));
    }

}
"
HumanEval_6,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Por ejemplo, (() (()) tiene un máximo de dos niveles de anidación, mientras que ((())) tiene tres.     / Para cada uno de los grupos, emita el nivel más profundo de anidación de paréntesis.     / La entrada de esta función es una cadena representada por múltiples grupos para paréntesis anidadas separadas por espacios.     // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))
    public static ArrayList<Long> parseNestedParens(String paren_string) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static ArrayList<Long> parseNestedParens(String paren_string) {
        String[] groups = paren_string.split("" "");
        ArrayList<Long> depths = new ArrayList<>();

        for (String group : groups) {
            long currentDepth = 0;
            long maxDepth = 0;

            for (char c : group.toCharArray()) {
                if (c == '(') {
                    currentDepth++;
                    if (currentDepth > maxDepth) {
                        maxDepth = currentDepth;
                    }
                } else if (c == ')') {
                    currentDepth--;
                }
            }

            depths.add(maxDepth);
        }

        return depths;
    }

    public static void main(String[] args) {
        String input = ""(()()) ((())) () ((())()())"";
        System.out.println(parseNestedParens(input));
    }
}","    }
    public static void main(String[] args) {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));
    assert(parseNestedParens((""(()(())((())))"")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));
    }

}
"
HumanEval_7,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Filtrar una lista de matrices de entrada de cadenas sólo para las que contienen una determinada subcadena     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList())), (""a""))
    // (new ArrayList<String>(Arrays.asList()))
    // >>> filterBySubstring((new ArrayList<String>(Arrays.asList((String)""abc"", (String)""bacd"", (String)""cde"", (String)""array""))), (""a""))
    // (new ArrayList<String>(Arrays.asList((String)""abc"", (String)""bacd"", (String)""array"")))
    public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {
","public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {
        return strings.stream()
                .filter(s -> s.contains(substring))
                .collect(Collectors.toCollection(ArrayList::new));
    }
}","    }
    public static void main(String[] args) {
    assert(filterBySubstring((new ArrayList<String>(Arrays.asList())), (""john"")).equals((new ArrayList<String>(Arrays.asList()))));
    assert(filterBySubstring((new ArrayList<String>(Arrays.asList((String)""xxx"", (String)""asd"", (String)""xxy"", (String)""john doe"", (String)""xxxAAA"", (String)""xxx""))), (""xxx"")).equals((new ArrayList<String>(Arrays.asList((String)""xxx"", (String)""xxxAAA"", (String)""xxx"")))));
    assert(filterBySubstring((new ArrayList<String>(Arrays.asList((String)""xxx"", (String)""asd"", (String)""aaaxxy"", (String)""john doe"", (String)""xxxAAA"", (String)""xxx""))), (""xx"")).equals((new ArrayList<String>(Arrays.asList((String)""xxx"", (String)""aaaxxy"", (String)""xxxAAA"", (String)""xxx"")))));
    assert(filterBySubstring((new ArrayList<String>(Arrays.asList((String)""grunt"", (String)""trumpet"", (String)""prune"", (String)""gruesome""))), (""run"")).equals((new ArrayList<String>(Arrays.asList((String)""grunt"", (String)""prune"")))));
    }

}
"
HumanEval_8,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / La suma vacía debe ser igual a 0 y el producto vacío debe ser igual a 1.     / Para una lista de matrices de enteros dada, devuelve un par que consiste en una suma y un producto de todos los enteros en una lista de matrices de matrices.     // >>> sumProduct((new ArrayList<Long>(Arrays.asList())))
    // (Pair.with(0l, 1l))
    // >>> sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))
    // (Pair.with(10l, 24l))
    public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {
","long sum = 0L;
        long product = 1L;
        
        for (Long number : numbers) {
            sum += number;
            product *= number;
        }
        
        return Pair.with(sum, product);
    }
}","    }
    public static void main(String[] args) {
    assert(sumProduct((new ArrayList<Long>(Arrays.asList()))).equals((Pair.with(0l, 1l))));
    assert(sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l)))).equals((Pair.with(3l, 1l))));
    assert(sumProduct((new ArrayList<Long>(Arrays.asList((long)100l, (long)0l)))).equals((Pair.with(100l, 0l))));
    assert(sumProduct((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))).equals((Pair.with(15l, 105l))));
    assert(sumProduct((new ArrayList<Long>(Arrays.asList((long)10l)))).equals((Pair.with(10l, 10l))));
    }

}
"
HumanEval_9,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    - En la secuencia.    / De una lista de matrices de enteros, genera una lista de matrices de elementos máximos encontrados hasta el momento dado.    // >>> rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)3l, (long)4l, (long)2l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l)))
    public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {
","import java.util.*;

class Problem {
    // From a given array list of integers, generate an array list of rolling maximum element found until given moment
    // in the sequence.
    public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {
        ArrayList<Long> result = new ArrayList<>();
        if (numbers == null || numbers.isEmpty()) {
            return result;
        }
        long currentMax = Long.MIN_VALUE;
        for (Long number : numbers) {
            currentMax = Math.max(currentMax, number);
            result.add(currentMax);
        }
        return result;
    }

    public static void main(String[] args) {
        ArrayList<Long> numbers = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 2L, 3L, 4L, 2L));
        ArrayList<Long> rollingMaxNumbers = rollingMax(numbers);
        System.out.println(rollingMaxNumbers); // Output: [1, 2, 3, 3, 3, 4, 4]
    }
}","    }
    public static void main(String[] args) {
    assert(rollingMax((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));
    assert(rollingMax((new ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)2l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)4l, (long)4l)))));
    assert(rollingMax((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l, (long)100l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)100l, (long)100l)))));
    }

}
"
HumanEval_10,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / - Añadir al final de la cadena inversa de un prefijo de cadena que viene antes del sufijo palindromo.     / - Encuentre el postfix más largo de la cadena suministrada que sea un palíndromo.     La idea del algoritmo es simple:    / Encuentre el palíndromo más corto que comience con una cadena suministrada.     // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    public static String makePalindrome(String string) {
","public static String makePalindrome(String string) {
    if (string == null || string.length() <= 1) {
        return string;
    }

    // Function to check if a given string is a palindrome
    boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        
        return true;
    }

    // Find longest palindromic suffix
    int n = string.length();
    for (int i = n; i > 0; i--) {
        if (isPalindrome(string.substring(0, i))) {
            StringBuilder sb = new StringBuilder(string.substring(i));
            sb.reverse();
            return string + sb.toString();
        }
    }
    
    return string; // fallback should not be reached
}","    }
    public static void main(String[] args) {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejecutar XOR binario en estas entradas y devolver el resultado también como una cadena.     / La entrada son dos cadenas a y b que consisten sólo en 1s y 0s.     // >>> stringXor((""010""), (""110""))
    // (""100"")
    public static String stringXor(String a, String b) {
","if (a.length() != b.length()) {
            throw new IllegalArgumentException(""Input strings must have the same length."");
        }
        
        StringBuilder result = new StringBuilder();
        
        for (int i = 0; i < a.length(); i++) {
            char charA = a.charAt(i);
            char charB = b.charAt(i);
            
            if (charA != '0' && charA != '1' || charB != '0' && charB != '1') {
                throw new IllegalArgumentException(""Input strings must consist only of '0' and '1'."");
            }
            
            // Perform XOR operation and append to the result
            result.append(charA == charB ? '0' : '1');
        }
        
        return result.toString();
    }
}","    }
    public static void main(String[] args) {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / cadenas de la misma longitud. devuelve null en caso de que la lista de matrices de entrada esté vacía.     / Fuera de la lista de cadenas de array, devuelve la más larga. devuelve la primera en caso de múltiples     // >>> longest((new ArrayList<String>(Arrays.asList())))
    // Optional.empty()
    // >>> longest((new ArrayList<String>(Arrays.asList((String)""a"", (String)""b"", (String)""c""))))
    // Optional.of(""a"")
    // >>> longest((new ArrayList<String>(Arrays.asList((String)""a"", (String)""bb"", (String)""ccc""))))
    // Optional.of(""ccc"")
    public static Optional<String> longest(ArrayList<String> strings) {
","if (strings == null || strings.isEmpty()) {
            return Optional.empty();
        }
        return strings.stream()
                .max(Comparator.comparingInt(String::length)
                .thenComparing(Comparator.naturalOrder()));
    }
}","    }
    public static void main(String[] args) {
    assert(longest((new ArrayList<String>(Arrays.asList()))).equals(Optional.empty()));
    assert(longest((new ArrayList<String>(Arrays.asList((String)""x"", (String)""y"", (String)""z"")))).equals(Optional.of(""x"")));
    assert(longest((new ArrayList<String>(Arrays.asList((String)""x"", (String)""yyy"", (String)""zzzz"", (String)""www"", (String)""kkkk"", (String)""abc"")))).equals(Optional.of(""zzzz"")));
    }

}
"
HumanEval_13,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve el mayor común divisor de dos enteros a y b     // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    public static long greatestCommonDivisor(long a, long b) {
","if (b == 0) {
        return a;
    }
    return greatestCommonDivisor(b, a % b);
}","    }
    public static void main(String[] args) {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve una lista de todos los prefijos de la cadena de entrada desde el más corto hasta el más largo     // >>> allPrefixes((""abc""))
    // (new ArrayList<String>(Arrays.asList((String)""a"", (String)""ab"", (String)""abc"")))
    public static ArrayList<String> allPrefixes(String string) {
","ArrayList<String> prefixes = new ArrayList<>();
        for (int i = 1; i <= string.length(); i++) {
            prefixes.add(string.substring(0, i));
        }
        return prefixes;
    }
}","    }
    public static void main(String[] args) {
    assert(allPrefixes(("""")).equals((new ArrayList<String>(Arrays.asList()))));
    assert(allPrefixes((""asdfgh"")).equals((new ArrayList<String>(Arrays.asList((String)""a"", (String)""as"", (String)""asd"", (String)""asdf"", (String)""asdfg"", (String)""asdfgh"")))));
    assert(allPrefixes((""WWW"")).equals((new ArrayList<String>(Arrays.asList((String)""W"", (String)""WW"", (String)""WWW"")))));
    }

}
"
HumanEval_15,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve una cadena que contiene números delimitados por espacio que comienzan desde 0 hasta n inclusive.     // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    public static String stringSequence(long n) {
","import java.util.stream.Collectors;
import java.util.stream.LongStream;

class Problem {
    public static String stringSequence(long n) {
        return LongStream.rangeClosed(0, n)
                         .mapToObj(Long::toString)
                         .collect(Collectors.joining("" ""));
    }
}","    }
    public static void main(String[] args) {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Dado una cadena, averigüe cuántos caracteres distintos (independientemente de la caja) tiene     // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    public static long countDistinctCharacters(String string) {
","import java.util.*;

public class Problem {
    // Given a string, find out how many distinct characters (regardless of case) does it consist of
    public static long countDistinctCharacters(String string) {
        // Convert the string to lowercase to ensure case-insensitivity
        String lowerCaseString = string.toLowerCase();
        // Use a HashSet to store unique characters
        Set<Character> uniqueChars = new HashSet<>();
        
        // Iterate over each character in the string and add it to the set
        for (char c : lowerCaseString.toCharArray()) {
            uniqueChars.add(c);
        }
        
        // Return the size of the set, i.e., the number of distinct characters
        return uniqueChars.size();
    }
}","    }
    public static void main(String[] args) {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    ""Hacía"" - nota de cuarto, dura un latido.    ""O"" hace media nota, dura dos tiempos.    / 'O' - nota entera, tiene cuatro tiempos     Aquí hay una leyenda:    - No el último.    / Su tarea es analizar esta cadena y devolver una lista de matrices de enteros correspondientes a cuántos latidos hace cada uno     / La entrada de esta función es una cadena que representa notas musicales en un formato ASCII especial.     // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)1l, (long)2l, (long)2l, (long)1l, (long)1l, (long)1l, (long)1l, (long)4l, (long)4l)))
    public static ArrayList<Long> parseMusic(String music_string) {
","import java.util.ArrayList;

class Problem {
    public static ArrayList<Long> parseMusic(String music_string) {
        ArrayList<Long> beats = new ArrayList<>();
        String[] notes = music_string.split("" "");
        
        for (String note : notes) {
            if (note.equals(""o"")) {
                beats.add(4L);
            } else if (note.equals(""o|"")) {
                beats.add(2L);
            } else if (note.equals("".|"")) {
                beats.add(1L);
            }
        }
        
        return beats;
    }
}","    }
    public static void main(String[] args) {
    assert(parseMusic(("""")).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(parseMusic((""o o o o"")).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)4l, (long)4l)))));
    assert(parseMusic(("".| .| .| .|"")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)1l, (long)1l, (long)4l, (long)4l, (long)4l, (long)4l)))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)2l, (long)1l, (long)4l, (long)2l, (long)4l, (long)2l)))));
    }

}
"
HumanEval_18,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Encuentre cuántas veces se puede encontrar una subcadena dada en la cadena original. Cuente los casos superpuestos.     // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    public static long howManyTimes(String string, String substring) {
","public static long howManyTimes(String string, String substring) {
        long count = 0;
        for (int i = 0; i <= string.length() - substring.length(); i++) {
            if (string.substring(i, i + substring.length()).equals(substring)) {
                count++;
            }
        }
        return count;
    }
}","    }
    public static void main(String[] args) {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve la cadena con los números ordenados de menor a mayor     / Las opciones válidas son cero, uno, dos, tres, cuatro, cinco, seis, siete, ocho y nueve.     / La entrada es una cadena de números delimitada por espacio desde 'cero' hasta 'nueve'.     // >>> sortNumbers((""three one five""))
    // (""one three five"")
    public static String sortNumbers(String numbers) {
","public static String sortNumbers(String numbers) {
        List<String> numeralList = Arrays.asList(numbers.split("" ""));
        Map<String, Integer> numeralToValue = new HashMap<>();
        numeralToValue.put(""zero"", 0);
        numeralToValue.put(""one"", 1);
        numeralToValue.put(""two"", 2);
        numeralToValue.put(""three"", 3);
        numeralToValue.put(""four"", 4);
        numeralToValue.put(""five"", 5);
        numeralToValue.put(""six"", 6);
        numeralToValue.put(""seven"", 7);
        numeralToValue.put(""eight"", 8);
        numeralToValue.put(""nine"", 9);

        numeralList.sort(Comparator.comparingInt(numeralToValue::get));

        return String.join("" "", numeralList);
    }
}","    }
    public static void main(String[] args) {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / otros y los devuelve por orden (menor número, mayor número).    / De una lista de números de matriz suministrada (de longitud al menos dos) seleccione y devuelva dos que estén más cerca de cada uno     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f))))
    // (Pair.with(2.0f, 2.2f))
    // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))))
    // (Pair.with(2.0f, 2.0f))
    public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {
","import java.util.*;
import org.javatuples.*;

class Problem {
    public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {
        if (numbers == null || numbers.size() < 2) {
            throw new IllegalArgumentException(""List must contain at least two numbers."");
        }

        Collections.sort(numbers);
        float minDiff = Float.MAX_VALUE;
        Pair<Float, Float> closestPair = null;

        for (int i = 0; i < numbers.size() - 1; i++) {
            float current = numbers.get(i);
            float next = numbers.get(i + 1);
            float diff = Math.abs(current - next);

            if (diff < minDiff) {
                minDiff = diff;
                closestPair = Pair.with(current, next);
            }
        }

        return closestPair;
    }

    public static void main(String[] args) {
        ArrayList<Float> list1 = new ArrayList<>(Arrays.asList(1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f));
        ArrayList<Float> list2 = new ArrayList<>(Arrays.asList(1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f));
        
        System.out.println(findClosestElements(list1)); // Output: (2.0, 2.2)
        System.out.println(findClosestElements(list2)); // Output: (2.0, 2.0)
    }
}","    }
    public static void main(String[] args) {
    assert(findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f)))).equals((Pair.with(3.9f, 4.0f))));
    assert(findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f)))).equals((Pair.with(5.0f, 5.9f))));
    assert(findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f)))).equals((Pair.with(2.0f, 2.2f))));
    assert(findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f)))).equals((Pair.with(2.0f, 2.0f))));
    assert(findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f)))).equals((Pair.with(2.2f, 3.1f))));
    }

}
"
HumanEval_21,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / de tal manera que el número más pequeño se convertirá en 0 y el más grande se convertirá en 1     / Dado una lista de números de matriz (de al menos dos elementos), aplique una transformación lineal a esa lista de matrices,     // >>> rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f))))
    // (new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))
    public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    // Given array list of numbers (of at least two elements), apply a linear transform to that array list,
    // such that the smallest number will become 0 and the largest will become 1
    public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {
        if (numbers == null || numbers.size() < 2) {
            throw new IllegalArgumentException(""Input list must contain at least two elements."");
        }
        
        float min = Float.MAX_VALUE;
        float max = Float.MIN_VALUE;
        
        for (float num : numbers) {
            if (num < min) {
                min = num;
            }
            if (num > max) {
                max = num;
            }
        }
        
        ArrayList<Float> rescaled = new ArrayList<>(numbers.size());
        for (float num : numbers) {
            float normalized = (num - min) / (max - min);
            rescaled.add(normalized);
        }
        
        return rescaled;
    }
    
    public static void main(String[] args) {
        ArrayList<Float> numbers = new ArrayList<>(Arrays.asList(1.0f, 2.0f, 3.0f, 4.0f, 5.0f));
        ArrayList<Float> normalizedNumbers = rescaleToUnit(numbers);
        System.out.println(normalizedNumbers); // Output should be [0.0, 0.25, 0.5, 0.75, 1.0]
    }
}","    }
    public static void main(String[] args) {
    assert(rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)2.0f, (float)49.9f)))).equals((new ArrayList<Float>(Arrays.asList((float)0.0f, (float)1.0f)))));
    assert(rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)100.0f, (float)49.9f)))).equals((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)0.0f)))));
    assert(rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f)))).equals((new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))));
    assert(rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f)))).equals((new ArrayList<Float>(Arrays.asList((float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f)))));
    assert(rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f)))).equals((new ArrayList<Float>(Arrays.asList((float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f)))));
    }

}
"
HumanEval_22,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Filtrar la lista de matrices de cualquier valor de javathon sólo para enteros     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList((String)""a"", (String)3.14f, (String)5l))))
    // (new ArrayList<Long>(Arrays.asList((long)5l)))
    // >>> filterIntegers((new ArrayList<Object>(Arrays.asList(1l, 2l, 3l, ""abc"", new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList())))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))
    public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    // Filter given array list of any javathon values only for integers
    public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {
        ArrayList<Long> result = new ArrayList<>();
        for (Object value : values) {
            if (value instanceof Long) {
                result.add((Long) value);
            }
        }
        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(filterIntegers((new ArrayList<Object>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(filterIntegers((new ArrayList<Object>(Arrays.asList(4l, new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList()), 23.2f, 9l, ""adasd"")))).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)9l)))));
    assert(filterIntegers((new ArrayList<Object>(Arrays.asList(3l, ""c"", 3l, 3l, ""a"", ""b"")))).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l)))));
    }

}
"
HumanEval_23,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Largo de vuelta de la cadena dada     // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    public static long strlen(String string) {
","// Check if the string is null
        if (string == null) {
            return 0L;
        }
        // Return the length of the string
        return (long) string.length();
    }
}","    }
    public static void main(String[] args) {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Para un número dado n, encuentre el número más grande que divide n de manera uniforme, más pequeño que n     // >>> largestDivisor((15l))
    // (5l)
    public static long largestDivisor(long n) {
","if (n <= 1) {
            throw new IllegalArgumentException(""n must be greater than 1"");
        }
        for (long i = n / 2; i >= 1; i--) {
            if (n % i == 0) {
                return i;
            }
        }
        return 1; // This line is actually never reached if the function is used correctly
    }
}","    }
    public static void main(String[] args) {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / El número de entrada debe ser igual al producto de todos los factores     / Cada uno de los factores debe ser enumerado en la matriz el número de veces correspondiente a la cantidad de veces que aparece en la factorización.     / Devuelve una lista de matrices de factores primos de un número entero dado en orden de menor a mayor.     // >>> factorize((8l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))
    // >>> factorize((25l))
    // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l)))
    // >>> factorize((70l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)7l)))
    public static ArrayList<Long> factorize(long n) {
","import java.util.ArrayList;

class Problem {
    public static ArrayList<Long> factorize(long n) {
        ArrayList<Long> factors = new ArrayList<>();
        for (long factor = 2; factor * factor <= n; factor++) {
            while (n % factor == 0) {
                factors.add(factor);
                n /= factor;
            }
        }
        if (n > 1) {
            factors.add(n);
        }
        return factors;
    }

    public static void main(String[] args) {
        // Example usage
        System.out.println(factorize(8l));   // Output: [2, 2, 2]
        System.out.println(factorize(25l));  // Output: [5, 5]
        System.out.println(factorize(70l));  // Output: [2, 5, 7]
    }
}","    }
    public static void main(String[] args) {
    assert(factorize((2l)).equals((new ArrayList<Long>(Arrays.asList((long)2l)))));
    assert(factorize((4l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l)))));
    assert(factorize((8l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))));
    assert(factorize((57l)).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)19l)))));
    assert(factorize((3249l)).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)19l, (long)19l)))));
    assert(factorize((185193l)).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)19l, (long)19l, (long)19l)))));
    assert(factorize((20577l)).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)19l, (long)19l, (long)19l)))));
    assert(factorize((18l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)3l)))));
    }

}
"
HumanEval_26,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Mantenga el orden de los elementos de la izquierda igual que en la entrada.     / De una lista de números enteros de una matriz, elimine todos los elementos que ocurren más de una vez.     // >>> removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)4l)))
    public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {
","import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

public class Problem {
    public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {
        // Create a HashSet to keep track of duplicates
        HashSet<Long> seen = new HashSet<>();
        // Create a list for results
        ArrayList<Long> result = new ArrayList<>();
        // Create a temporary HashSet to track elements that are counted more than once
        HashSet<Long> duplicates = new HashSet<>();

        for (Long number : numbers) {
            if (seen.contains(number)) {
                // If already seen and not added to duplicates, add to duplicates
                duplicates.add(number);
            } else {
                // Mark this number as seen
                seen.add(number);
            }
        }

        for (Long number : numbers) {
            // Add only those numbers to result which are not in duplicates
            if (!duplicates.contains(number)) {
                result.add(number);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        ArrayList<Long> input = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 2L, 4L));
        ArrayList<Long> output = removeDuplicates(input);
        System.out.println(output);  // Output: [1, 3, 4]
    }
}","    }
    public static void main(String[] args) {
    assert(removeDuplicates((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));
    assert(removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l, (long)3l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)5l)))));
    }

}
"
HumanEval_27,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Para una cadena dada, cambie los caracteres minúsculos a mayúsculas y mayúsculas a minúsculas.     // >>> flipCase((""Hello""))
    // (""hELLO"")
    public static String flipCase(String string) {
","StringBuilder flipped = new StringBuilder();
        for (char c : string.toCharArray()) {
            if (Character.isUpperCase(c)) {
                flipped.append(Character.toLowerCase(c));
            } else if (Character.isLowerCase(c)) {
                flipped.append(Character.toUpperCase(c));
            } else {
                flipped.append(c);
            }
        }
        return flipped.toString();
    }
}","    }
    public static void main(String[] args) {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Concatenate lista de matrices de cadenas en una sola cadena     // >>> concatenate((new ArrayList<String>(Arrays.asList())))
    // ("""")
    // >>> concatenate((new ArrayList<String>(Arrays.asList((String)""a"", (String)""b"", (String)""c""))))
    // (""abc"")
    public static String concatenate(ArrayList<String> strings) {
","return String.join("""", strings);
    }
}","    }
    public static void main(String[] args) {
    assert(concatenate((new ArrayList<String>(Arrays.asList()))).equals(("""")));
    assert(concatenate((new ArrayList<String>(Arrays.asList((String)""x"", (String)""y"", (String)""z"")))).equals((""xyz"")));
    assert(concatenate((new ArrayList<String>(Arrays.asList((String)""x"", (String)""y"", (String)""z"", (String)""w"", (String)""k"")))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Filtrar una lista de matrices de entrada de cadenas sólo para los que comienzan con un prefijo dado.     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList())), (""a""))
    // (new ArrayList<String>(Arrays.asList()))
    // >>> filterByPrefix((new ArrayList<String>(Arrays.asList((String)""abc"", (String)""bcd"", (String)""cde"", (String)""array""))), (""a""))
    // (new ArrayList<String>(Arrays.asList((String)""abc"", (String)""array"")))
    public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {
","return strings.stream()
                      .filter(s -> s.startsWith(prefix))
                      .collect(Collectors.toCollection(ArrayList::new));
    }
}","    }
    public static void main(String[] args) {
    assert(filterByPrefix((new ArrayList<String>(Arrays.asList())), (""john"")).equals((new ArrayList<String>(Arrays.asList()))));
    assert(filterByPrefix((new ArrayList<String>(Arrays.asList((String)""xxx"", (String)""asd"", (String)""xxy"", (String)""john doe"", (String)""xxxAAA"", (String)""xxx""))), (""xxx"")).equals((new ArrayList<String>(Arrays.asList((String)""xxx"", (String)""xxxAAA"", (String)""xxx"")))));
    }

}
"
HumanEval_30,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve sólo números positivos en la lista de matrices.     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)-4l, (long)5l, (long)6l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)6l)))
    // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))
    // (new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)9l, (long)123l, (long)1l)))
    public static ArrayList<Long> getPositive(ArrayList<Long> l) {
","import java.util.ArrayList;

class Problem {
    // Return only positive numbers in the array list.
    public static ArrayList<Long> getPositive(ArrayList<Long> l) {
        ArrayList<Long> positives = new ArrayList<>();
        for (Long number : l) {
            if (number > 0) {
                positives.add(number);
            }
        }
        return positives;
    }
}","    }
    public static void main(String[] args) {
    assert(getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)4l, (long)5l, (long)6l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)))));
    assert(getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l)))).equals((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)3l, (long)9l, (long)123l, (long)1l)))));
    assert(getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l)))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(getPositive((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    }

}
"
HumanEval_31,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve verdad si un número dado es primo, y falso de lo contrario.     // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    public static boolean isPrime(long n) {
","if (n <= 1) {
            return false;
        }
        if (n <= 3) {
            return true;
        }
        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }
        for (long i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / a los valores de los índices correspondientes de l, pero ordenados.    / l' es idéntico a l en los índices que no son divisible por tres, mientras que sus valores en los índices que son divisible por tres son iguales     / Esta función toma una lista de array array l y devuelve una lista de array array l' tal que     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))
    // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))
    public static ArrayList<Long> sortThird(ArrayList<Long> l) {
","import java.util.*;

class Problem {
    public static ArrayList<Long> sortThird(ArrayList<Long> l) {
        // Create a new list to store elements at indices divisible by three
        ArrayList<Long> extracted = new ArrayList<>();

        // Extract the elements at indices divisible by three
        for (int i = 0; i < l.size(); i++) {
            if (i % 3 == 0) {
                extracted.add(l.get(i));
            }
        }

        // Sort the extracted elements
        Collections.sort(extracted);

        // Create a new list to store the resultant elements
        ArrayList<Long> result = new ArrayList<>(l);

        // Replace the original elements at indices divisible by three with the sorted ones
        int sortedIndex = 0;
        for (int i = 0; i < l.size(); i++) {
            if (i % 3 == 0) {
                result.set(i, extracted.get(sortedIndex));
                sortedIndex++;
            }
        }

        return result;
    }

    public static void main(String[] args) {
        ArrayList<Long> list1 = new ArrayList<Long>(Arrays.asList(1L, 2L, 3L));
        ArrayList<Long> result1 = sortThird(list1);
        System.out.println(result1);

        ArrayList<Long> list2 = new ArrayList<Long>(Arrays.asList(5L, 6L, 3L, 4L, 8L, 9L, 2L));
        ArrayList<Long> result2 = sortThird(list2);
        System.out.println(result2);
    }
}","    }
    public static void main(String[] args) {
    assert(sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))));
    assert(sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)3l, (long)4l, (long)6l, (long)9l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)8l, (long)3l, (long)4l, (long)6l, (long)9l, (long)5l)))));
    assert(sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)9l, (long)4l, (long)8l, (long)3l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)9l, (long)4l, (long)8l, (long)3l, (long)5l)))));
    assert(sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l, (long)1l)))));
    }

}
"
HumanEval_34,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve elementos únicos ordenados en una lista de arrays .    // >>> unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))
    // (new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))
    public static ArrayList<Long> unique(ArrayList<Long> l) {
","import java.util.*;
import java.util.stream.*;

class Problem {
    // Return sorted unique elements in an array array list
    public static ArrayList<Long> unique(ArrayList<Long> l) {
        return l.stream()
                .distinct()
                .sorted()
                .collect(Collectors.toCollection(ArrayList::new));
    }

    public static void main(String[] args) {
        ArrayList<Long> inputList = new ArrayList<>(Arrays.asList(5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L));
        ArrayList<Long> uniqueSortedList = unique(inputList);
        System.out.println(uniqueSortedList);
    }
}","    }
    public static void main(String[] args) {
    assert(unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))));
    }

}
"
HumanEval_35,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve el elemento máximo en la lista de matrices.     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (3l)
    // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))
    // (123l)
    public static long maxElement(ArrayList<Long> l) {
","public static long maxElement(ArrayList<Long> l) {
        if (l == null || l.isEmpty()) {
            throw new IllegalArgumentException(""List cannot be null or empty"");
        }
        long max = Long.MIN_VALUE;
        for (Long num : l) {
            max = Math.max(max, num);
        }
        return max;
    }
}","    }
    public static void main(String[] args) {
    assert(maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))) == (3l));
    assert(maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)124l, (long)1l, (long)-10l)))) == (124l));
    }

}
"
HumanEval_36,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve el número de veces que aparece el dígito 7 en enteros menores que n que son divisible por 11 o 13.     // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    public static long fizzBuzz(long n) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    public static long fizzBuzz(long n) {
        long count = 0;
        for (long i = 1; i < n; i++) {
            if (i % 11 == 0 || i % 13 == 0) {
                count += countSevens(i);
            }
        }
        return count;
    }

    private static int countSevens(long number) {
        int count = 0;
        while (number > 0) {
            if (number % 10 == 7) {
                count++;
            }
            number /= 10;
        }
        return count;
    }
}","    }
    public static void main(String[] args) {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / a los valores de los índices pares de l, pero ordenados.     / l' es idéntico a l en los índices impares, mientras que sus valores en los índices pares son iguales     / Esta función toma una lista de array array l y devuelve una lista de array array l' tal que     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))
    // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l))))
    // (new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)5l, (long)4l)))
    public static ArrayList<Long> sortEven(ArrayList<Long> l) {
","public static ArrayList<Long> sortEven(ArrayList<Long> l) {
        ArrayList<Long> evenIndicesValues = new ArrayList<>();
        
        // Collect values from even indices
        for (int i = 0; i < l.size(); i += 2) {
            evenIndicesValues.add(l.get(i));
        }
        
        // Sort values collected from even indices
        Collections.sort(evenIndicesValues);
        
        // Create an iterator for sorted even values
        Iterator<Long> iterator = evenIndicesValues.iterator();
        
        // Form the result list by setting sorted even values and copying odd values
        for (int i = 0; i < l.size(); i++) {
            if (i % 2 == 0) {
                // Set sorted values at even indices
                l.set(i, iterator.next());
            }
            // Values at odd indices remain the same
        }
        
        return l;
    }
}","    }
    public static void main(String[] args) {
    assert(sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))));
    assert(sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l)))).equals((new ArrayList<Long>(Arrays.asList((long)-10l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)5l, (long)0l, (long)9l, (long)1l, (long)123l)))));
    assert(sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)-12l, (long)4l, (long)23l, (long)2l, (long)3l, (long)11l, (long)12l, (long)-10l)))).equals((new ArrayList<Long>(Arrays.asList((long)-12l, (long)8l, (long)3l, (long)4l, (long)5l, (long)2l, (long)12l, (long)11l, (long)23l, (long)-10l)))));
    }

}
"
HumanEval_39,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / prime_fib devuelve el n-ésimo número que es un número de Fibonacci y también es primo.     // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    public static long primeFib(long n) {
","import java.util.*;
import org.javatuples.*;

class Problem {
    // Function to check if a number is prime
    public static boolean isPrime(long num) {
        if (num <= 1) return false;
        if (num <= 3) return true; // 2 and 3 are prime
        if (num % 2 == 0 || num % 3 == 0) return false;
        for (long i = 5; i * i <= num; i += 6) {
            if (num % i == 0 || num % (i + 2) == 0) return false;
        }
        return true;
    }

    // Function to get the n-th Fibonacci number that is also prime
    public static long primeFib(long n) {
        long count = 0;
        long a = 0;
        long b = 1;
        
        while (true) {
            long next = a + b;
            a = b;
            b = next;
            
            if (isPrime(next)) {
                count++;
                if (count == n) {
                    return next;
                }
            }
        }
    }
}","    }
    public static void main(String[] args) {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / suma a cero, y falso de lo contrario.     / devuelve true si hay tres elementos distintos en la lista de matrices que     / triples_sum_to_zero toma una lista de matrices de números enteros como entrada.    // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))
    // (false)
    // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))
    // (true)
    // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))
    // (false)
    // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l))))
    // (true)
    // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))
    // (false)
    public static boolean triplesSumToZero(ArrayList<Long> l) {
","import java.util.*;

class Problem {
    public static boolean triplesSumToZero(ArrayList<Long> l) {
        Collections.sort(l);
        int n = l.size();
        for (int i = 0; i < n - 2; i++) {
            int left = i + 1, right = n - 1;
            while (left < right) {
                long sum = l.get(i) + l.get(left) + l.get(right);
                if (sum == 0) {
                    return true;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return false;
    }
}","    }
    public static void main(String[] args) {
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l)))) == (false));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)-1l)))) == (false));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l)))) == (true));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l)))) == (false));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)5l, (long)7l)))) == (false));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l)))) == (true));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l)))) == (false));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)-100l)))) == (false));
    assert(triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)100l, (long)3l, (long)5l, (long)-100l)))) == (false));
    }

}
"
HumanEval_41,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Esta función produce el número de estas colisiones.     / en su trayectoria como si no chocaran.     Sin embargo, los coches son infinitamente robustos y fuertes; como resultado, continúan moviéndose.    / Cuando un coche que se mueve de izquierda a derecha golpea a un coche que se mueve de derecha a izquierda.     Todos los coches se mueven a la misma velocidad.    Los dos pares de coches comienzan a estar muy lejos de la carretera.    / n coches están conduciendo de izquierda a derecha; simultáneamente, un conjunto diferente de n coches     Imagina un camino que es una línea perfectamente recta infinitamente larga.    public static long carRaceCollision(long n) {
","public static long carRaceCollision(long n) {
    // Each car moving left to right will collide with each car moving right to left
    // as they are infinitely far apart initially and moving towards each other.
    // Therefore, the total number of collisions will be n * n.
    return n * n;
}","    }
    public static void main(String[] args) {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve una lista de matrices con elementos incrementados por 1.     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))
    // >>> incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))
    // (new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))
    public static ArrayList<Long> incrList(ArrayList<Long> l) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    // Return array list with elements incremented by 1.
    public static ArrayList<Long> incrList(ArrayList<Long> l) {
        return l.stream().map(x -> x + 1).collect(Collectors.toCollection(ArrayList::new));
    }
}","    }
    public static void main(String[] args) {
    assert(incrList((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(incrList((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)2l)))));
    assert(incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)2l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l, (long)3l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))));
    }

}
"
HumanEval_43,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / suma a cero, y falso de lo contrario.     / devuelve true si hay dos elementos distintos en la lista de matrices que     / pairs_sum_to_zero toma una lista de matrices de números enteros como entrada.    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))
    // (false)
    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))
    // (false)
    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))
    // (false)
    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))
    // (true)
    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))
    // (false)
    public static boolean pairsSumToZero(ArrayList<Long> l) {
","import java.util.ArrayList;
import java.util.HashSet;

class Problem {
    public static boolean pairsSumToZero(ArrayList<Long> l) {
        HashSet<Long> set = new HashSet<>();

        for (Long num : l) {
            if (set.contains(-num)) {
                return true;
            }
            set.add(num);
        }
        
        return false;
    }
}","    }
    public static void main(String[] args) {
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l)))) == (false));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l)))) == (false));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l)))) == (false));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l)))) == (true));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l)))) == (false));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)-3l, (long)9l, (long)-1l, (long)3l, (long)2l, (long)30l)))) == (true));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)-3l, (long)9l, (long)-1l, (long)3l, (long)2l, (long)31l)))) == (true));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)-3l, (long)9l, (long)-1l, (long)4l, (long)2l, (long)30l)))) == (false));
    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)-3l, (long)9l, (long)-1l, (long)4l, (long)2l, (long)31l)))) == (false));
    }

}
"
HumanEval_44,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / los números de base son menores a 10.     / regresa la representación de la cadena después de la conversión.     / Cambiar la base numérica del número de entrada x a la base.     // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    public static String changeBase(long x, long base) {
","StringBuilder result = new StringBuilder();
    while (x > 0) {
        result.append(x % base);
        x /= base;
    }
    return result.reverse().toString();
}","    }
    public static void main(String[] args) {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Dado el largo de un lado y el área de retorno alto para un triángulo.     // >>> triangleArea((5l), (3l))
    // (7.5f)
    public static float triangleArea(long a, long h) {
","public class Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea((5l), (3l))
    // (7.5f)
    public static float triangleArea(long a, long h) {
        return (a * h) / 2.0f;
    }

    public static void main(String[] args) {
        System.out.println(triangleArea(5l, 3l)); // Output: 7.5
    }
}","    }
    public static void main(String[] args) {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Por favor escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números fib4. No use la recursión.     / fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     / fib4(3) -> 0     / fib4(2) -> 2     / fib4(1) -> 0     / fib4(0) -> 0     / La secuencia numérica Fib4 es una secuencia similar a la secuencia de Fibbonacci que se define de la siguiente manera:     // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    public static long fib4(long n) {
","public static long fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    long a = 0, b = 0, c = 2, d = 0;
    for (long i = 4; i <= n; i++) {
        long temp = a + b + c + d;
        a = b;
        b = c;
        c = d;
        d = temp;
    }
    return d;
}","    }
    public static void main(String[] args) {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve la mediana de los elementos en la lista de matrices l.     // >>> median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))
    // (float)3l
    // >>> median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l))))
    // (15.0f)
    public static float median(ArrayList<Long> l) {
","Collections.sort(l);
    int n = l.size();
    if (n % 2 == 1) {
        return l.get(n / 2);
    } else {
        return (float)(l.get(n / 2 - 1) + l.get(n / 2)) / 2;
    }
}","    }
    public static void main(String[] args) {
    assert(median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l)))) == (float)3l);
    assert(median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l)))) == (8.0f));
    assert(median((new ArrayList<Long>(Arrays.asList((long)5l)))) == (float)5l);
    assert(median((new ArrayList<Long>(Arrays.asList((long)6l, (long)5l)))) == (5.5f));
    assert(median((new ArrayList<Long>(Arrays.asList((long)8l, (long)1l, (long)3l, (long)9l, (long)9l, (long)2l, (long)7l)))) == (float)7l);
    }

}
"
HumanEval_48,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Comprueba si la cadena dada es un palíndromo     // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    public static boolean isPalindrome(String text) {
","if (text == null) {
            return false;
        }
        int left = 0;
        int right = text.length() - 1;
        while (left < right) {
            if (text.charAt(left) != text.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve 2^n módulo p (tenga en cuenta los números).     // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    public static long modp(long n, long p) {
","import java.math.BigInteger;

public class Problem {
    // Return 2^n modulo p (be aware of numerics).
    public static long modp(long n, long p) {
        BigInteger base = BigInteger.valueOf(2);
        BigInteger exponent = BigInteger.valueOf(n);
        BigInteger modulo = BigInteger.valueOf(p);
        
        return base.modPow(exponent, modulo).longValue();
    }

    public static void main(String[] args) {
        System.out.println(modp(3L, 5L)); // Output: 3
        System.out.println(modp(1101L, 101L)); // Output: 2
        System.out.println(modp(0L, 101L)); // Output: 1
        System.out.println(modp(3L, 11L)); // Output: 8
        System.out.println(modp(100L, 101L)); // Output: 1
    }
}","    }
    public static void main(String[] args) {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / remove_vowels es una función que toma cadena y devuelve cadena sin vocales.     // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    public static String removeVowels(String text) {
","public static String removeVowels(String text) {
        return text.replaceAll(""(?i)[aeiou]"", """");
    }
}","    }
    public static void main(String[] args) {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / devuelve true si todos los números de la lista de matrices l están por debajo del umbral t.     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l))
    // (true)
    // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l))
    // (false)
    public static boolean belowThreshold(ArrayList<Long> l, long t) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    // Return true if all numbers in the array list l are below threshold t.
    public static boolean belowThreshold(ArrayList<Long> l, long t) {
        for (Long num : l) {
            if (num >= t) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(belowThreshold(new ArrayList<Long>(Arrays.asList(1L, 2L, 4L, 10L)), 100L)); // true
        System.out.println(belowThreshold(new ArrayList<Long>(Arrays.asList(1L, 20L, 4L, 10L)), 5L));  // false
    }
}","    }
    public static void main(String[] args) {
    assert(belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l)) == (true));
    assert(belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l)) == (false));
    assert(belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (21l)) == (true));
    assert(belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (22l)) == (true));
    assert(belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)8l, (long)4l, (long)10l))), (11l)) == (true));
    assert(belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)8l, (long)4l, (long)10l))), (10l)) == (false));
    }

}
"
HumanEval_53,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Añadir dos números x y y     // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    public static long add(long x, long y) {
","return x + y;
    }

    public static void main(String[] args) {
        System.out.println(add(2L, 3L)); // Outputs: 5
        System.out.println(add(5L, 7L)); // Outputs: 12
    }
}","    }
    public static void main(String[] args) {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Compruebe si dos palabras tienen los mismos caracteres.     // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    public static boolean sameChars(String s0, String s1) {
","public static boolean sameChars(String s0, String s1) {
        Set<Character> set0 = s0.chars().mapToObj(e -> (char)e).collect(Collectors.toSet());
        Set<Character> set1 = s1.chars().mapToObj(e -> (char)e).collect(Collectors.toSet());
        return set0.equals(set1);
    }

    public static void main(String[] args) {
        System.out.println(sameChars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")); // true
        System.out.println(sameChars(""abcd"", ""dddddddabc"")); // true
        System.out.println(sameChars(""dddddddabc"", ""abcd"")); // true
        System.out.println(sameChars(""eabcd"", ""dddddddabc"")); // false
        System.out.println(sameChars(""abcd"", ""dddddddabce"")); // false
        System.out.println(sameChars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")); // false
    }
}","    }
    public static void main(String[] args) {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve el n-ésimo número de Fibonacci.     // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    public static long fib(long n) {
","if (n <= 1) {
            return n;
        }
        long a = 0, b = 1, c = 0;
        for (int i = 2; i <= n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}","    }
    public static void main(String[] args) {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / devuelve verdad si cada bracket de apertura tiene un bracket de cierre correspondiente.     / entre paréntesis es una cadena de ""<"" y "">"".     // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    public static boolean correctBracketing(String brackets) {
","import java.util.*;

class Problem {

    public static boolean correctBracketing(String brackets) {
        int balance = 0;
        for (char ch : brackets.toCharArray()) {
            if (ch == '<') {
                balance++;
            } else if (ch == '>') {
                balance--;
                if (balance < 0) {
                    return false;
                }
            }
        }
        return balance == 0;
    }
}","    }
    public static void main(String[] args) {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve verdad si los elementos de la lista de matrices están aumentando o disminuyendo monotónicamente.     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l))))
    // (true)
    // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))))
    // (false)
    // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l))))
    // (true)
    public static boolean monotonic(ArrayList<Long> l) {
","import java.util.ArrayList;

class Problem {
    // Return true if array list elements are monotonically increasing or decreasing.
    public static boolean monotonic(ArrayList<Long> l) {
        if (l.size() <= 1) {
            return true;
        }
        
        boolean increasing = true;
        boolean decreasing = true;
        
        for (int i = 1; i < l.size(); i++) {
            if (l.get(i) > l.get(i - 1)) {
                decreasing = false;
            }
            if (l.get(i) < l.get(i - 1)) {
                increasing = false;
            }
        }
        
        return increasing || decreasing;
    }

    public static void main(String[] args) {
        ArrayList<Long> list1 = new ArrayList<>(Arrays.asList(1L, 2L, 4L, 20L));
        ArrayList<Long> list2 = new ArrayList<>(Arrays.asList(1L, 20L, 4L, 10L));
        ArrayList<Long> list3 = new ArrayList<>(Arrays.asList(4L, 1L, 0L, -10L));

        System.out.println(monotonic(list1)); // true
        System.out.println(monotonic(list2)); // false
        System.out.println(monotonic(list3)); // true
    }
}","    }
    public static void main(String[] args) {
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l)))) == (true));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l)))) == (true));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l)))) == (false));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l)))) == (true));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l)))) == (true));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)5l, (long)60l)))) == (false));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)60l)))) == (true));
    assert(monotonic((new ArrayList<Long>(Arrays.asList((long)9l, (long)9l, (long)9l, (long)9l)))) == (true));
    }

}
"
HumanEval_58,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve elementos comunes únicos ordenados para dos listas de matrices.     // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))
    // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))
    public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {
","import java.util.*;
import java.util.stream.Collectors;

class Problem {
    // Return sorted unique common elements for two array lists.
    public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {
        Set<Long> set1 = new HashSet<>(l1);
        Set<Long> set2 = new HashSet<>(l2);
        
        // Retain only the elements in set1 that are contained in set2
        set1.retainAll(set2);
        
        // Convert to list and sort
        ArrayList<Long> result = new ArrayList<>(set1);
        Collections.sort(result);
        
        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))));
    assert(common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))));
    assert(common((new ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))));
    assert(common((new ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    }

}
"
HumanEval_59,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve el mayor factor primo de n. Suponga que n > 1 y no es un número primo.     // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    public static long largestPrimeFactor(long n) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    public static long largestPrimeFactor(long n) {
        long largestFactor = 1;
        long factor = 2;
        
        // Test for number of 2s that divide n
        while (n % factor == 0) {
            largestFactor = factor;
            n /= factor;
        }
        
        // n must be odd at this point, so a skip of 2 is used (i.e., 3, 5, 7, 9, ...)
        factor = 3;
        while (factor * factor <= n) {
            while (n % factor == 0) {
                largestFactor = factor;
                n /= factor;
            }
            factor += 2;
        }
        
        // This condition checks if n is a prime number greater than 2
        if (n > 2) {
            largestFactor = n;
        }
        
        return largestFactor;
    }
}","    }
    public static void main(String[] args) {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / sum_to_n es una función que suma números de 1 a n.     // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    public static long sumToN(long n) {
","public static long sumToN(long n) {
    return n * (n + 1) / 2;
}","    }
    public static void main(String[] args) {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / devuelve verdad si cada bracket de apertura tiene un bracket de cierre correspondiente.     / entre paréntesis es una cadena de ""("" y "")"".     // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    public static boolean correctBracketing(String brackets) {
","public static boolean correctBracketing(String brackets) {
    int balance = 0;
    for (int i = 0; i < brackets.length(); i++) {
        if (brackets.charAt(i) == '(') {
            balance++;
        } else if (brackets.charAt(i) == ')') {
            balance--;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance == 0;
}","    }
    public static void main(String[] args) {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve la derivada de este polinomio en la misma forma.     / xs[0] + xs[1] * x + xs[2] * x^2 + ....     / xs representan los coeficientes de un polinomio.    // >>> derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))
    // >>> derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))
    public static ArrayList<Long> derivative(ArrayList<Long> xs) {
","import java.util.ArrayList;

public class Problem {
    // xs represent coefficients of a polynomial.
    // xs[0] + xs[1] * x + xs[2] * x^2 + ....
    // Return derivative of this polynomial in the same form.
    public static ArrayList<Long> derivative(ArrayList<Long> xs) {
        ArrayList<Long> result = new ArrayList<>();
        for (int i = 1; i < xs.size(); i++) {
            result.add(xs.get(i) * i);
        }
        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))));
    assert(derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))));
    assert(derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l)))));
    assert(derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)1l, (long)0l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)0l, (long)16l)))));
    assert(derivative((new ArrayList<Long>(Arrays.asList((long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));
    }

}
"
HumanEval_63,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Por favor escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números fibfib.     / fibfib (n) == fibfib (n-1) + fibfib (n-2) + fib (n-3).     / fib fib ({2) } == 1     / fib fib ({1) } == 0     / fib fib ({0) } == 0     / La secuencia de números FibFib es una secuencia similar a la secuencia de Fibbonacci que se define de la siguiente manera:     // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    public static long fibfib(long n) {
","public static long fibfib(long n) {
        if (n == 0) return 0;
        if (n == 1) return 0;
        if (n == 2) return 1;
        
        long[] fibfibSequence = new long[(int) n + 1];
        fibfibSequence[0] = 0;
        fibfibSequence[1] = 0;
        fibfibSequence[2] = 1;
        
        for (int i = 3; i <= n; i++) {
            fibfibSequence[i] = fibfibSequence[i - 1] + fibfibSequence[i - 2] + fibfibSequence[i - 3];
        }
        
        return fibfibSequence[(int) n];
    }
}","    }
    public static void main(String[] args) {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / vocal, pero sólo cuando está al final de la palabra dada.     / Las vocales en este caso son 'a', 'e', 'i', 'o', 'u'. Aquí, 'y' es también un     / una palabra como entrada y devuelve el número de vocales en la cadena.     / Escriba una función vowels_count que toma una cadena que representa     // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    public static long vowelsCount(String s) {
","if (s == null || s.isEmpty()) {
            return 0L;
        }

        s = s.toLowerCase();
        long count = 0L;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (""aeiou"".indexOf(c) >= 0) {
                count++;
            } else if (c == 'y' && i == s.length() - 1) {
                count++;
            }
        }

        return count;
    }
}","    }
    public static void main(String[] args) {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Si el desplazamiento es > número de dígitos, los dígitos de retorno se invierten.     / y devuelve el resultado como una cadena.     / Circular desplazar los dígitos del número entero x, desplazar los dígitos a la derecha por el desplazamiento     // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    public static String circularShift(long x, long shift) {
","import java.util.*;

public class Problem {
    public static String circularShift(long x, long shift) {
        String numStr = Long.toString(x);
        int len = numStr.length();

        // If shift is greater than or equal to the number of digits, reverse the digits.
        if (shift >= len) {
            return new StringBuilder(numStr).reverse().toString();
        }

        // Otherwise, perform a circular shift.
        int actualShift = (int)(shift % len);
        StringBuilder shifted = new StringBuilder();
        shifted.append(numStr.substring(len - actualShift));
        shifted.append(numStr.substring(0, len - actualShift));

        return shifted.toString();
    }

    public static void main(String[] args) {
        // Test cases
        System.out.println(circularShift(12L, 1L));  // Output: ""21""
        System.out.println(circularShift(12L, 2L));  // Output: ""12""
        System.out.println(circularShift(12345L, 3L));  // Output: ""34512""
        System.out.println(circularShift(12345L, 5L));  // Output: ""54321""
        System.out.println(circularShift(12345L, 7L));  // Output: ""54321""
    }
}","    }
    public static void main(String[] args) {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Códigos ASCII.     / Escriba una función que toma una cadena como entrada y devuelve la suma de los caracteres superiores sólo'     - ¿ Qué ?    // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    public static long digitSum(String s) {
","public static long digitSum(String s) {
        long sum = 0;
        for (char c : s.toCharArray()) {
            if (Character.isUpperCase(c)) {
                sum += (long) c;
            }
        }
        return sum;
    }
}","    }
    public static void main(String[] args) {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / para el exámbulo:     / en la cesta devuelve el número de frutos de mango en la cesta.     / las naranjas y las manzanas y un número entero que represente el número total de frutos     / manzanas, naranjas y frutos de mango. dada la cadena que representa el número total de     / que se distribuyen en una canasta de frutas que contiene esta canasta     En esta tarea, se le dará una cadena que representa un número de manzanas y naranjas.    // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    public static long fruitDistribution(String s, long n) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    public static long fruitDistribution(String s, long n) {
        String[] parts = s.split("" "");
        long apples = Long.parseLong(parts[0]);
        long oranges = Long.parseLong(parts[3]);
        long mangoes = n - (apples + oranges);
        return mangoes;
    }
}","    }
    public static void main(String[] args) {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Ejemplo 1:    / Si no hay valores pares o la lista de arrays de arrays dada está vacía, devuelve [].     / El nodo arrancado debe ser devuelto en una lista de array array, [ smalest_value, su índice ],     / Si se encuentran múltiples nodos con el mismo valor par más pequeño, devuelve el nodo que tiene el índice más pequeño.     / El nodo arrancado debe ser el nodo con el valor par más pequeño.     / su tarea es arrancar uno de los nodos y devolverlo.     / ""Dada una lista de matrices matrices que representa una rama de un árbol que tiene nodos enteros no negativos     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((new ArrayList<Long>(Arrays.asList())))
    // (new ArrayList<Long>(Arrays.asList()))
    // Example 4:
    // >>> pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l))))
    // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    public static ArrayList<Long> pluck(ArrayList<Long> arr) {
","public static ArrayList<Long> pluck(ArrayList<Long> arr) {
        ArrayList<Long> result = new ArrayList<>();
        long smallestEvenValue = Long.MAX_VALUE;
        int index = -1;

        for (int i = 0; i < arr.size(); i++) {
            long value = arr.get(i);
            if (value % 2 == 0 && value < smallestEvenValue) {
                smallestEvenValue = value;
                index = i;
            }
        }

        if (index != -1) {
            result.add(smallestEvenValue);
            result.add((long) index);
        }

        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))));
    assert(pluck((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))));
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)0l, (long)5l, (long)3l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l)))));
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)4l, (long)8l, (long)4l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l)))));
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l, (long)6l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l, (long)1l)))));
    assert(pluck((new ArrayList<Long>(Arrays.asList((long)7l, (long)9l, (long)7l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList()))));
    }

}
"
HumanEval_69,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Si no existe tal valor, devuelve -1.     / La frecuencia de un entero es el número de veces que aparece en la lista de matrices.     / cero, y tiene una frecuencia mayor o igual al valor del propio número entero.     / Se le da una lista de matrices no vacías de enteros positivos. Devuelve el mayor entero que sea mayor que     // >>> search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))
    // (2l)
    // >>> search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))
    // (3l)
    // >>> search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l, (long)4l))))
    // (-1l)
    public static long search(ArrayList<Long> lst) {
","import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

class Problem {
    public static long search(ArrayList<Long> lst) {
        HashMap<Long, Integer> frequencyMap = new HashMap<>();

        // Count frequencies of each number
        for (Long num : lst) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }
        
        long result = -1;
        
        // Find the greatest integer that fulfills the condition
        for (Long num : frequencyMap.keySet()) {
            int frequency = frequencyMap.get(num);
            if (frequency >= num && num > result) {
                result = num;
            }
        }
        
        return result;
    }

    public static void main(String[] args) {
        System.out.println(search(new ArrayList<Long>(Arrays.asList(4L, 1L, 2L, 2L, 3L, 1L)))); // 2L
        System.out.println(search(new ArrayList<Long>(Arrays.asList(1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L)))); // 3L
        System.out.println(search(new ArrayList<Long>(Arrays.asList(5L, 5L, 4L, 4L, 4L)))); // -1L
    }
}","    }
    public static void main(String[] args) {
    assert(search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l, (long)1l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)4l, (long)1l, (long)4l, (long)4l)))) == (4l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l)))) == (-1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)8l, (long)8l, (long)8l, (long)8l, (long)8l, (long)8l, (long)8l, (long)8l)))) == (8l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)3l, (long)2l, (long)2l)))) == (2l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)2l, (long)7l, (long)8l, (long)8l, (long)4l, (long)8l, (long)7l, (long)3l, (long)9l, (long)6l, (long)5l, (long)10l, (long)4l, (long)3l, (long)6l, (long)7l, (long)1l, (long)7l, (long)4l, (long)10l, (long)8l, (long)1l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)8l, (long)2l)))) == (2l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)6l, (long)7l, (long)1l, (long)8l, (long)8l, (long)10l, (long)5l, (long)8l, (long)5l, (long)3l, (long)10l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)8l, (long)8l, (long)3l, (long)6l, (long)5l, (long)6l, (long)4l)))) == (-1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)6l, (long)9l, (long)6l, (long)7l, (long)1l, (long)4l, (long)7l, (long)1l, (long)8l, (long)8l, (long)9l, (long)8l, (long)10l, (long)10l, (long)8l, (long)4l, (long)10l, (long)4l, (long)10l, (long)1l, (long)2l, (long)9l, (long)5l, (long)7l, (long)9l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)1l, (long)9l, (long)10l, (long)1l, (long)3l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)6l, (long)9l, (long)7l, (long)5l, (long)8l, (long)7l, (long)5l, (long)3l, (long)7l, (long)5l, (long)10l, (long)10l, (long)3l, (long)6l, (long)10l, (long)2l, (long)8l, (long)6l, (long)5l, (long)4l, (long)9l, (long)5l, (long)3l, (long)10l)))) == (5l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)1l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)8l, (long)8l, (long)10l, (long)6l, (long)4l, (long)3l, (long)5l, (long)8l, (long)2l, (long)4l, (long)2l, (long)8l, (long)4l, (long)6l, (long)10l, (long)4l, (long)2l, (long)1l, (long)10l, (long)2l, (long)1l, (long)1l, (long)5l)))) == (4l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)2l, (long)10l, (long)4l, (long)8l, (long)2l, (long)10l, (long)5l, (long)1l, (long)2l, (long)9l, (long)5l, (long)5l, (long)6l, (long)3l, (long)8l, (long)6l, (long)4l, (long)10l)))) == (2l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)1l, (long)6l, (long)10l, (long)1l, (long)6l, (long)9l, (long)10l, (long)8l, (long)6l, (long)8l, (long)7l, (long)3l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)9l, (long)2l, (long)4l, (long)1l, (long)5l, (long)1l, (long)5l, (long)2l, (long)5l, (long)7l, (long)7l, (long)7l, (long)3l, (long)10l, (long)1l, (long)5l, (long)4l, (long)2l, (long)8l, (long)4l, (long)1l, (long)9l, (long)10l, (long)7l, (long)10l, (long)2l, (long)8l, (long)10l, (long)9l, (long)4l)))) == (4l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)4l, (long)2l, (long)8l, (long)7l, (long)5l, (long)6l, (long)4l, (long)10l, (long)4l, (long)6l, (long)3l, (long)7l, (long)8l, (long)8l, (long)3l, (long)1l, (long)4l, (long)2l, (long)2l, (long)10l, (long)7l)))) == (4l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)9l, (long)8l, (long)6l, (long)10l, (long)2l, (long)6l, (long)10l, (long)2l, (long)7l, (long)8l, (long)10l, (long)3l, (long)8l, (long)2l, (long)6l, (long)2l, (long)3l, (long)1l)))) == (2l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)3l, (long)9l, (long)5l, (long)6l, (long)3l, (long)2l, (long)8l, (long)5l, (long)6l, (long)10l, (long)10l, (long)6l, (long)8l, (long)4l, (long)10l, (long)7l, (long)7l, (long)10l, (long)8l)))) == (-1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)10l)))) == (-1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)9l, (long)7l, (long)7l, (long)2l, (long)4l, (long)7l, (long)2l, (long)10l, (long)9l, (long)7l, (long)5l, (long)7l, (long)2l)))) == (2l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)5l, (long)4l, (long)10l, (long)2l, (long)1l, (long)1l, (long)10l, (long)3l, (long)6l, (long)1l, (long)8l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)7l, (long)9l, (long)9l, (long)9l, (long)3l, (long)4l, (long)1l, (long)5l, (long)9l, (long)1l, (long)2l, (long)1l, (long)1l, (long)10l, (long)7l, (long)5l, (long)6l, (long)7l, (long)6l, (long)7l, (long)7l, (long)6l)))) == (1l));
    assert(search((new ArrayList<Long>(Arrays.asList((long)3l, (long)10l, (long)10l, (long)9l, (long)2l)))) == (-1l));
    }

}
"
HumanEval_70,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / entonces máximo de los enteros restantes, luego mínimo y así sucesivamente.     / Extraña clasificación, es cuando se comienza con el valor mínimo,     / Dada la lista de matrices de enteros, devuelve la lista de matrices en orden extraño.     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))
    // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l))))
    // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))
    // >>> strangeSortList((new ArrayList<Long>(Arrays.asList())))
    // (new ArrayList<Long>(Arrays.asList()))
    public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {
","import java.util.ArrayList;
import java.util.Collections;
import java.util.Arrays;

class Problem {
    public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {
        ArrayList<Long> result = new ArrayList<>();
        Collections.sort(lst);
        
        int left = 0;
        int right = lst.size() - 1;
        boolean flag = true; // true indicates minimum, false indicates maximum
        
        while (left <= right) {
            if (flag) {
                result.add(lst.get(left));
                left++;
            } else {
                result.add(lst.get(right));
                right--;
            }
            flag = !flag;
        }
        
        return result;
    }
    
    // Main method for test purposes
    public static void main(String[] args) {
        ArrayList<Long> list1 = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 4L));
        System.out.println(strangeSortList(list1)); // Outputs: [1, 4, 2, 3]
        
        ArrayList<Long> list2 = new ArrayList<>(Arrays.asList(5L, 5L, 5L, 5L));
        System.out.println(strangeSortList(list2)); // Outputs: [5, 5, 5, 5]
        
        ArrayList<Long> list3 = new ArrayList<>();
        System.out.println(strangeSortList(list3)); // Outputs: []
    }
}","    }
    public static void main(String[] args) {
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)7l, (long)8l, (long)9l)))).equals((new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)6l, (long)8l, (long)7l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)4l, (long)3l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)7l, (long)8l, (long)9l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)9l, (long)5l, (long)8l, (long)6l, (long)7l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l, (long)8l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)8l, (long)2l, (long)7l, (long)3l, (long)6l, (long)4l, (long)5l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)2l, (long)2l, (long)5l, (long)5l, (long)-5l, (long)-5l)))).equals((new ArrayList<Long>(Arrays.asList((long)-5l, (long)5l, (long)-5l, (long)5l, (long)0l, (long)2l, (long)2l, (long)2l)))));
    assert(strangeSortList((new ArrayList<Long>(Arrays.asList((long)111111l)))).equals((new ArrayList<Long>(Arrays.asList((long)111111l)))));
    }

}
"
HumanEval_71,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / que el tercer lado.     / Tres lados hacen un triángulo válido cuando la suma de cualquiera de los dos lados es mayor .    / De lo contrario regresa -1     / el triángulo redondeado a 2 décimas si los tres lados forman un triángulo válido.     / Dadas las longitudes de los tres lados de un triángulo.    // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // (float)-1l
    public static float triangleArea(long a, long b, long c) {
","public static float triangleArea(long a, long b, long c) {
        if (a + b > c && a + c > b && b + c > a) {
            double s = (a + b + c) / 2.0;
            double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
            return Math.round(area * 100.0) / 100.0f;
        } else {
            return -1f;
        }
    }

    public static void main(String[] args) {
        System.out.println(triangleArea(3, 4, 5)); // Output: 6.0
        System.out.println(triangleArea(1, 2, 10)); // Output: -1
    }
}","    }
    public static void main(String[] args) {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == (float)-1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == (float)-1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == (float)-1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == (float)-1l);
    }

}
"
HumanEval_72,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / El objeto q volará si está equilibrado (es una lista de matrices palindrómica) y la suma de sus elementos es menor o igual al peso máximo posible w.     / Escriba una función que devuelva verdadero si el objeto q volará, y falso de lo contrario.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    public static boolean willItFly(ArrayList<Long> q, long w) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static boolean willItFly(ArrayList<Long> q, long w) {
        if (!isPalindromic(q)) {
            return false;
        }
        long sum = 0;
        for (Long num : q) {
            sum += num;
        }
        return sum <= w;
    }

    private static boolean isPalindromic(ArrayList<Long> q) {
        int size = q.size();
        for (int i = 0; i < size / 2; i++) {
            if (!q.get(i).equals(q.get(size - i - 1))) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(willItFly(new ArrayList<Long>(Arrays.asList(1L, 2L)), 5L)); // false
        System.out.println(willItFly(new ArrayList<Long>(Arrays.asList(3L, 2L, 3L)), 1L)); // false
        System.out.println(willItFly(new ArrayList<Long>(Arrays.asList(3L, 2L, 3L)), 9L)); // true
        System.out.println(willItFly(new ArrayList<Long>(Arrays.asList(3L)), 5L)); // true
    }
}","    }
    public static void main(String[] args) {
    assert(willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l)) == (true));
    assert(willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l)) == (false));
    assert(willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l)) == (true));
    assert(willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l)) == (false));
    assert(willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (6l)) == (false));
    assert(willItFly((new ArrayList<Long>(Arrays.asList((long)5l))), (5l)) == (true));
    }

}
"
HumanEval_73,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / se lee de la misma manera hacia atrás y hacia adelante. En un cambio, puede cambiar un elemento a cualquier otro elemento.     / debe ser cambiado para hacer que la lista de arrays de arrays sea palindroma. Una lista de arrays de arrays palindroma es una lista de arrays de arrays que     / Dado un array array lista arr de enteros, encuentre el número mínimo de elementos que     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l))))
    // (4l)
    // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l))))
    // (1l)
    // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l))))
    // (0l)
    public static long smallestChange(ArrayList<Long> arr) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    // Given an array list arr of integers, finds the minimum number of changes
    // to make the list palindromic.
    public static long smallestChange(ArrayList<Long> arr) {
        int left = 0;
        int right = arr.size() - 1;
        long changes = 0;
        
        while (left < right) {
            if (!arr.get(left).equals(arr.get(right))) {
                changes++;
            }
            left++;
            right--;
        }
        return changes;
    }
    
    public static void main(String[] args) {
        System.out.println(smallestChange(new ArrayList<Long>(Arrays.asList(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))); // 4
        System.out.println(smallestChange(new ArrayList<Long>(Arrays.asList(1L, 2L, 3L, 4L, 3L, 2L, 2L)))); // 1
        System.out.println(smallestChange(new ArrayList<Long>(Arrays.asList(1L, 2L, 3L, 2L, 1L)))); // 0
    }
}","    }
    public static void main(String[] args) {
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l)))) == (4l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l)))) == (1l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l)))) == (1l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)4l, (long)2l)))) == (1l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l)))) == (0l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)1l, (long)3l)))) == (0l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)1l)))) == (0l));
    assert(smallestChange((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))) == (1l));
    }

}
"
HumanEval_74,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / si las dos listas de matrices tienen el mismo número de caracteres, devuelve la primera lista de matrices.     / número total de caracteres en todas las cadenas de la lista de matrices menos que la otra lista de matrices.     / Escriba una función que acepte dos listas de matrices de cadenas y devuelva la lista de matrices que tiene     // >>> totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList())))
    // (new ArrayList<String>(Arrays.asList()))
    // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""Hi""))))
    // (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""Hi"")))
    // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hi"", (String)""hi"", (String)""admin"", (String)""project""))))
    // (new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin"")))
    // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""hi"", (String)""hi""))))
    // (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""hi"", (String)""hi"")))
    // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)""4""))), (new ArrayList<String>(Arrays.asList((String)""1"", (String)""2"", (String)""3"", (String)""4"", (String)""5""))))
    // (new ArrayList<String>(Arrays.asList((String)""4"")))
    public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {
","public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {
        int charCount1 = lst1.stream().mapToInt(String::length).sum();
        int charCount2 = lst2.stream().mapToInt(String::length).sum();

        if (charCount1 < charCount2) {
            return lst1;
        } else if (charCount2 < charCount1) {
            return lst2;
        } else {
            return lst1;
        }
    }
}","    }
    public static void main(String[] args) {
    assert(totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList()))).equals((new ArrayList<String>(Arrays.asList()))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hi"", (String)""hi"")))).equals((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""hi"")))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hi"", (String)""hi"", (String)""admin"", (String)""project"")))).equals((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin"")))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""4""))), (new ArrayList<String>(Arrays.asList((String)""1"", (String)""2"", (String)""3"", (String)""4"", (String)""5"")))).equals((new ArrayList<String>(Arrays.asList((String)""4"")))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""Hi"")))).equals((new ArrayList<String>(Arrays.asList((String)""hI"", (String)""Hi"")))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""hi"", (String)""hi"")))).equals((new ArrayList<String>(Arrays.asList((String)""hI"", (String)""hi"", (String)""hi"")))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin""))), (new ArrayList<String>(Arrays.asList((String)""hI"", (String)""hi"", (String)""hii"")))).equals((new ArrayList<String>(Arrays.asList((String)""hi"", (String)""admin"")))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList((String)""this"")))).equals((new ArrayList<String>(Arrays.asList()))));
    assert(totalMatch((new ArrayList<String>(Arrays.asList((String)""this""))), (new ArrayList<String>(Arrays.asList()))).equals((new ArrayList<String>(Arrays.asList()))));
    }

}
"
HumanEval_75,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / Sabiendo que (a) es menor que 100.     / y falso de otra manera.     / Escriba una función que devuelva verdad si el número dado es la multiplicación de 3 números primos     // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    public static boolean isMultiplyPrime(long a) {
","if (a >= 2 && a < 8) return false;

        List<Integer> primes = sieveOfEratosthenes(100);
        for (int i = 0; i < primes.size(); i++) {
            for (int j = i; j < primes.size(); j++) {
                for (int k = j; k < primes.size(); k++) {
                    long product = (long) primes.get(i) * primes.get(j) * primes.get(k);
                    if (product == a) {
                        return true;
                    }
                    if (product > a) {
                        break;
                    }
                }
            }
        }
        return false;
    }

    private static List<Integer> sieveOfEratosthenes(int limit) {
        boolean[] isPrime = new boolean[limit + 1];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i * i <= limit; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= limit; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= limit; i++) {
            if (isPrime[i]) {
                primes.add(i);
            }
        }
        return primes;
    }
}","    }
    public static void main(String[] args) {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / x es una potencia simple de n si n ** int = x     / potencia de n y falso en otros casos.     / Su tarea es escribir una función que devuelva verdad si un número x es un simple     // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    public static boolean isSimplePower(long x, long n) {
","public static boolean isSimplePower(long x, long n) {
        if (x < 1 || n < 1) {
            return false;
        }
        if (n == 1) {
            return x == 1;
        }
        long power = 1;
        while (power < x) {
            power *= n;
        }
        return power == x;
    }

    public static void main(String[] args) {
        System.out.println(isSimplePower(1l, 4l)); // true
        System.out.println(isSimplePower(2l, 2l)); // true
        System.out.println(isSimplePower(8l, 2l)); // true
        System.out.println(isSimplePower(3l, 2l)); // false
        System.out.println(isSimplePower(3l, 1l)); // false
        System.out.println(isSimplePower(5l, 3l)); // false
    }
}","    }
    public static void main(String[] args) {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Nota: puede asumir que la entrada siempre es válida.     / si este ingeger es un cubo de algún número entero.     / Escriba una función que tome un entero a y devuelva true     // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    public static boolean iscube(long a) {
","public static boolean iscube(long a) {
        if (a < 0) {
            a = -a;
        }
        long cubeRoot = Math.round(Math.cbrt(a));
        return cubeRoot * cubeRoot * cubeRoot == a;
    }
}","    }
    public static void main(String[] args) {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / y los símbolos A, B, C, D, E, F son siempre mayúsculas.     / Nota: puede asumir que la entrada es siempre correcta o una cadena vacía,     / B (= decimal 11), D (= decimal 13)     / Así que tienes que determinar un número de los siguientes dígitos: 2, 3, 5, 7,     Los números primos son 2, 3, 5, 7, 11, 13, 17...    / Los dígitos hexadecimales son 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     / mayor que 1 que no es un producto de dos números naturales más pequeños).    / dígitos que son primos (número primo, o un primo, es un número natural     / un número hexadecimal como una cadena y cuenta el número de hexadecimal     / Se le ha encargado escribir una función que recibe     // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    public static long hexKey(String num) {
","import java.util.*;

class Problem {
    public static long hexKey(String num) {
        // Set of hexadecimal ""digits"" that are prime numbers.
        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));
        
        // Count prime digits in the hexadecimal number.
        long count = 0;
        for (char ch : num.toCharArray()) {
            if (primeHexDigits.contains(ch)) {
                count++;
            }
        }
        return count;
    }

    // You can include this main method for testing the function
    public static void main(String[] args) {
        System.out.println(hexKey(""AB"")); // Output: 1
        System.out.println(hexKey(""1077E"")); // Output: 2
        System.out.println(hexKey(""ABED1A33"")); // Output: 4
        System.out.println(hexKey(""123456789ABCDEF0"")); // Output: 6
        System.out.println(hexKey(""2020"")); // Output: 2
    }
}","    }
    public static void main(String[] args) {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Los caracteres adicionales están ahí para ayudar con el formato.     / Habrá un par de caracteres adicionales 'db' al principio y al final de la cadena.     Cada carácter en la cadena será '0' o '1'.    / formato binario. La función debe devolver una cadena, con cada carácter que representa un binario     / Se le dará un número en forma decimal y su tarea es convertirlo a     // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    public static String decimalToBinary(long decimal) {
","public static String decimalToBinary(long decimal) {
        // Convert the decimal number to binary string
        String binaryStr = Long.toBinaryString(decimal);
        // Add 'db' at the beginning and the end of the binary string
        return ""db"" + binaryStr + ""db"";
    }
}","    }
    public static void main(String[] args) {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Una cadena es hapjava si su longitud es de al menos 3 y cada 3 letras consecutivas son distintas     / Su tarea es comprobar si la cadena es hapjava o no.     - Se te da una cadena de s.    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    public static boolean isHappy(String s) {
","public static boolean isHappy(String s) {
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i <= s.length() - 3; i++) {
        if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2) || s.charAt(i + 1) == s.charAt(i + 2)) {
            return false;
        }
    }
    return true;
}","    }
    public static void main(String[] args) {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / 0,0 E     / > 0,0 D-     / > 0,7 D     / > 1,0 D+     / > 1.3 C-     / > 1,7 C     / > 2,0 C+     / > 2.3 B-     / > 2,7 B     / > 3,0 B+     / > 3.3 A-     / > 3.7 A     - ¿Qué es eso?    - El promedio de calificaciones.    / una función que puede producir una lista de matrices de matrices de grados de letras usando la siguiente tabla:     Ella te ha dado una lista de promedios de algunos estudiantes y tienes que escribir .    El único problema es que ha perdido el código que usaba para calificar.    La maestra ha estado haciendo su propio algoritmo para la calificación.    Es la última semana del semestre y el profesor tiene que dar las calificaciones .    // >>> gradeEquation((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f))))
    // (new ArrayList<String>(Arrays.asList((String)""A+"", (String)""B"", (String)""C-"", (String)""C"", (String)""A-"")))
    public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {
","import java.util.ArrayList;

public class Problem {
    public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {
        ArrayList<String> letterGrades = new ArrayList<>();
        for (Float gpa : grades) {
            if (gpa == 4.0) {
                letterGrades.add(""A+"");
            } else if (gpa > 3.7) {
                letterGrades.add(""A"");
            } else if (gpa > 3.3) {
                letterGrades.add(""A-"");
            } else if (gpa > 3.0) {
                letterGrades.add(""B+"");
            } else if (gpa > 2.7) {
                letterGrades.add(""B"");
            } else if (gpa > 2.3) {
                letterGrades.add(""B-"");
            } else if (gpa > 2.0) {
                letterGrades.add(""C+"");
            } else if (gpa > 1.7) {
                letterGrades.add(""C"");
            } else if (gpa > 1.3) {
                letterGrades.add(""C-"");
            } else if (gpa > 1.0) {
                letterGrades.add(""D+"");
            } else if (gpa > 0.7) {
                letterGrades.add(""D"");
            } else if (gpa > 0.0) {
                letterGrades.add(""D-"");
            } else if (gpa == 0.0) {
                letterGrades.add(""E"");
            }
        }
        return letterGrades;
    }
    
    public static void main(String[] args) {
        ArrayList<Float> gpas = new ArrayList<>();
        gpas.add(4.0f);
        gpas.add(3.0f);
        gpas.add(1.7f);
        gpas.add(2.0f);
        gpas.add(3.5f);
        ArrayList<String> grades = numericalLetterGrade(gpas);
        System.out.println(grades);
    }
}","    }
    public static void main(String[] args) {
    assert(numericalLetterGrade((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f)))).equals((new ArrayList<String>(Arrays.asList((String)""A+"", (String)""B"", (String)""C-"", (String)""C"", (String)""A-"")))));
    assert(numericalLetterGrade((new ArrayList<Float>(Arrays.asList((float)1.2f)))).equals((new ArrayList<String>(Arrays.asList((String)""D+"")))));
    assert(numericalLetterGrade((new ArrayList<Float>(Arrays.asList((float)0.5f)))).equals((new ArrayList<String>(Arrays.asList((String)""D-"")))));
    assert(numericalLetterGrade((new ArrayList<Float>(Arrays.asList((float)0.0f)))).equals((new ArrayList<String>(Arrays.asList((String)""E"")))));
    assert(numericalLetterGrade((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f)))).equals((new ArrayList<String>(Arrays.asList((String)""D"", (String)""D-"", (String)""C-"", (String)""B"", (String)""B+"")))));
    assert(numericalLetterGrade((new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.7f)))).equals((new ArrayList<String>(Arrays.asList((String)""E"", (String)""D-"")))));
    }

}
"
HumanEval_82,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / longitud es un número primo o falso de lo contrario     / Escriba una función que tome una cadena y devuelva true si la cadena     // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    public static boolean primeLength(String string) {
","public static boolean primeLength(String string) {
    int length = string.length();
    if (length <= 1) return false;
    for (int i = 2; i <= Math.sqrt(length); i++) {
        if (length % i == 0) {
            return false;
        }
    }
    return true;
}","    }
    public static void main(String[] args) {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / enteros positivos que comienzan o terminan con 1.     / Dado un entero positivo n, devuelve el recuento de los números de n dígitos     public static long startsOneEnds(long n) {
","import java.util.*;

class Problem {
    // Given a positive integer n, return the count of the numbers of n-digit
    // positive integers that start or end with 1.
    public static long startsOneEnds(long n) {
        if (n == 1) return 1; // Only the number '1' is a one-digit number that starts or ends with 1.

        // Total numbers with n digits: 9 * (10^(n-1))
        long totalNDigitNumbers = 9 * (long)Math.pow(10, n - 1);

        // Numbers that start with 1 and are n-digits: 1 * (10^(n-1))
        long startsWithOne = (long)Math.pow(10, n - 1);

        // Numbers that end with 1: 9 * (10^(n-1))/10
        long endsWithOne = totalNDigitNumbers / 10;

        // Since numbers starting and ending with 1 are counted twice, we subtract the overlap.
        return startsWithOne + endsWithOne - 1;
    }

    public static void main(String[] args) {
        System.out.println(startsOneEnds(1)); // Expected output: 1
        System.out.println(startsOneEnds(2)); // Expected output: 19
        System.out.println(startsOneEnds(3)); // Expected output: 190
        System.out.println(startsOneEnds(4)); // Expected output: 1900
    }
}","    }
    public static void main(String[] args) {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    - Ejemplo .    / Dado un entero positivo N, devuelve la suma total de sus dígitos en binario.     // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    public static String solve(long N) {
","public static String solve(long N) {
        long sum = 0;
        while (N > 0) {
            sum += N % 10;
            N /= 10;
        }
        return Long.toBinaryString(sum);
    }
}","    }
    public static void main(String[] args) {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Dado una lista de matrices no vacías de enteros lst. agregar los elementos pares que están en índices impares ..     // >>> add((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)6l, (long)7l))))
    // (2l)
    public static long add(ArrayList<Long> lst) {
","long sum = 0;
        for (int i = 1; i < lst.size(); i += 2) {
            if (lst.get(i) % 2 == 0) {
                sum += lst.get(i);
            }
        }
        return sum;
    }
}","    }
    public static void main(String[] args) {
    assert(add((new ArrayList<Long>(Arrays.asList((long)4l, (long)88l)))) == (88l));
    assert(add((new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l, (long)7l, (long)2l, (long)122l)))) == (122l));
    assert(add((new ArrayList<Long>(Arrays.asList((long)4l, (long)0l, (long)6l, (long)7l)))) == (0l));
    assert(add((new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)6l, (long)8l)))) == (12l));
    }

}
"
HumanEval_86,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Nota: Debe mantener el orden de las palabras y los espacios en blanco en la oración.     / orden ascendente basado en el valor ASCII.     / se sustituyen por una nueva palabra en la que todos los caracteres ordenados en     / Versión ordenada de la cadena, es una cadena donde todas las palabras (separadas por espacio)     / Escriba una función que tome una cadena y devuelva una versión ordenada de la misma.     // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    public static String antiShuffle(String s) {
","public static String antiShuffle(String s) {
    StringBuilder result = new StringBuilder();
    String[] words = s.split(""(?<=\\s)|(?=\\s)"");
    
    for (String word : words) {
        if (word.trim().isEmpty()) {
            result.append(word);
        } else {
            char[] chars = word.toCharArray();
            Arrays.sort(chars);
            result.append(new String(chars));
        }
    }
    
    return result.toString();
}","    }
    public static void main(String[] args) {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / También, ordenar las coordenadas de la fila por columnas en orden descendente.     / Ordenar las coordenadas inicialmente por filas en orden ascendente.     / cada par es una coordenada - (fila, columnas), comenzando con 0.     / y devuelve una lista de pares de matrices, [(x1, y1), (x2, y2) ...] tal que     / Dado lst, y entero x, encontrar enteros x en la lista de matrices,     / cada fila puede contener un número diferente de columnas.    / que es similar a la matriz, sin embargo, a diferencia de las matrices,     / Se le da un 2 datos dimensionales, como una matriz anidada listas,     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l))
    // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))
    // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l))
    // (new ArrayList<Pair<Long, Long>>(Arrays.asList()))
    // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l))
    // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))
    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {
","public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {
        ArrayList<Pair<Long, Long>> result = new ArrayList<>();

        for (long i = 0; i < lst.size(); i++) {
            ArrayList<Long> row = lst.get((int)i);
            for (long j = 0; j < row.size(); j++) {
                if (row.get((int)j) == x) {
                    result.add(Pair.with(i, j));
                }
            }
        }

        result.sort(new Comparator<Pair<Long, Long>>() {
            @Override
            public int compare(Pair<Long, Long> p1, Pair<Long, Long> p2) {
                int rowComparison = Long.compare(p1.getValue0(), p2.getValue0());
                if (rowComparison != 0) {
                    return rowComparison;
                } else {
                    return Long.compare(p2.getValue1(), p1.getValue1());  // Descending order by column
                }
            }
        });

        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));
    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));
    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));
    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));
    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));
    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));
    }

}
"
HumanEval_88,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / * no cambie la lista de arrays de arrays dada.     / Nota:     / o ordenarlo en orden descendente si la suma ((primer valor del índice, último valor del índice) es par.     / ordenarás la lista de arrays de arrays dada en orden ascendente si la suma ((el primer valor de índice, el último valor de índice) es impar,     / Dado una lista de array array de enteros no negativos, devuelve una cojava de la lista de array array dada después de la clasificación,     // >>> sortArray((new ArrayList<Long>(Arrays.asList())))
    // (new ArrayList<Long>(Arrays.asList()))
    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)5l))))
    // (new ArrayList<Long>(Arrays.asList((long)5l)))
    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l))))
    // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))
    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l))))
    // (new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))
    public static ArrayList<Long> sortArray(ArrayList<Long> array) {
","import java.util.ArrayList;
import java.util.Collections;

class Problem {
    public static ArrayList<Long> sortArray(ArrayList<Long> array) {
        if (array.isEmpty()) {
            return new ArrayList<>(array);
        }

        long firstValue = array.get(0);
        long lastValue = array.get(array.size() - 1);
        long sum = firstValue + lastValue;

        ArrayList<Long> result = new ArrayList<>(array);
        
        if (sum % 2 == 0) {
            // Sort in descending order
            result.sort(Collections.reverseOrder());
        } else {
            // Sort in ascending order
            Collections.sort(result);
        }

        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(sortArray((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)5l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l)))).equals((new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)15l, (long)42l, (long)87l, (long)32l, (long)11l, (long)0l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)11l, (long)15l, (long)32l, (long)42l, (long)87l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)21l, (long)14l, (long)23l, (long)11l)))).equals((new ArrayList<Long>(Arrays.asList((long)23l, (long)21l, (long)14l, (long)11l)))));
    }

}
"
HumanEval_89,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / desplazarse hacia abajo por dos multiplicado por dos lugares.     / El alfabeto debe girarse de tal manera que las letras     / devuelve una cadena cifrada con el alfabeto girando.     / Crear una función de cifrado que toma una cadena como argumento y     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    public static String encrypt(String s) {
","import java.util.*;

public class Problem {
    // Create a function encrypt that takes a string as an argument and returns
    // a string encrypted with the alphabet being rotated by 2 * 2 = 4 places.
    public static String encrypt(String s) {
        StringBuilder encryptedString = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLowerCase(c)) {
                char shifted = (char) ((c - 'a' + 4) % 26 + 'a');
                encryptedString.append(shifted);
            } else if (Character.isUpperCase(c)) {
                char shifted = (char) ((c - 'A' + 4) % 26 + 'A');
                encryptedString.append(shifted);
            } else {
                // If the character is not a letter, append it unchanged.
                encryptedString.append(c);
            }
        }
        return encryptedString.toString();
    }

    public static void main(String[] args) {
        // Test examples
        System.out.println(encrypt(""hi""));          // Output: lm
        System.out.println(encrypt(""asdfghjkl""));   // Output: ewhjklnop
        System.out.println(encrypt(""gf""));          // Output: kj
        System.out.println(encrypt(""et""));          // Output: ix
    }
}","    }
    public static void main(String[] args) {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Devuelve null si no hay tal elemento.     / Escriba una función next_smallest (en inglés) que devuelva el segundo elemento más pequeño de la lista de matrices.     / Se le da una lista de números enteros.    // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))
    // Optional.of(2l)
    // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l))))
    // Optional.of(2l)
    // >>> nextSmallest((new ArrayList<Long>(Arrays.asList())))
    // Optional.empty()
    // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))
    // Optional.empty()
    public static Optional<Long> nextSmallest(ArrayList<Long> lst) {
","import java.util.*;

class Problem {
    public static Optional<Long> nextSmallest(ArrayList<Long> lst) {
        if (lst == null || lst.size() < 2) {
            return Optional.empty();
        }

        Set<Long> uniqueSet = new HashSet<>(lst);
        List<Long> uniqueList = new ArrayList<>(uniqueSet);
        if (uniqueList.size() < 2) {
            return Optional.empty();
        }

        Collections.sort(uniqueList);
        return Optional.of(uniqueList.get(1));
    }
}","    }
    public static void main(String[] args) {
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))).equals(Optional.of(2l)));
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l)))).equals(Optional.of(2l)));
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList()))).equals(Optional.empty()));
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l)))).equals(Optional.empty()));
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l, (long)0l)))).equals(Optional.of(1l)));
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l)))).equals(Optional.empty()));
    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)-35l, (long)34l, (long)12l, (long)-45l)))).equals(Optional.of(-35l)));
    }

}
"
HumanEval_91,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Las frases se delimitan con '.', '?' o '!'.     Un aburrimiento es una frase que comienza con la palabra ""yo"".    / Se le dará una cadena de palabras, y su tarea es contar el número     // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    public static long isBored(String S) {
","long boredomCount = 0;
        String[] sentences = S.split(""[.!?]"");
        for (String sentence : sentences) {
            sentence = sentence.trim();
            if (sentence.startsWith(""I"")) {
                boredomCount++;
            }
        }
        return boredomCount;
    }
}","    }
    public static void main(String[] args) {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / Devuelve falso en cualquier otro caso.     / Devuelve verdad si uno de los números es igual a la suma de los otros dos, y todos los números son enteros.     / Crear una función que toma 3 números.     // >>> anyInt((float)5l, (float)2l, (float)7l)
    // (true)
    // >>> anyInt((float)3l, (float)2l, (float)2l)
    // (false)
    // >>> anyInt((float)3l, (float)-2l, (float)1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), (float)2l)
    // (false)
    public static boolean anyInt(float x, float y, float z) {
","public static boolean anyInt(float x, float y, float z) {
        // Check if any of the numbers is the sum of the other two
        // To ensure all are integers, they must be equal to their integer counterpart
        if (x == (int) x && y == (int) y && z == (int) z) {
            // Convert numbers to integers
            int xi = (int) x;
            int yi = (int) y;
            int zi = (int) z;
            return (xi == yi + zi) || (yi == xi + zi) || (zi == xi + yi);
        }
        return false;
    }
}","    }
    public static void main(String[] args) {
    assert(anyInt((float)2l, (float)3l, (float)1l) == (true));
    assert(anyInt((2.5f), (float)2l, (float)3l) == (false));
    assert(anyInt((1.5f), (float)5l, (3.5f)) == (false));
    assert(anyInt((float)2l, (float)6l, (float)2l) == (false));
    assert(anyInt((float)4l, (float)2l, (float)2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt((float)-4l, (float)6l, (float)2l) == (true));
    assert(anyInt((float)2l, (float)1l, (float)1l) == (true));
    assert(anyInt((float)3l, (float)4l, (float)7l) == (true));
    assert(anyInt((3.0f), (float)4l, (float)7l) == (false));
    }

}
"
HumanEval_93,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     - Sólo las letras.    / Vocal en el alfabeto inglés.    / el mensaje con la letra que aparece 2 lugares por delante de eso     / manera que cambia de caso de todas las letras, sustituye todas las vocales en     / Escriba una función que toma un mensaje, y codifica en tal     // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    public static String encode(String message) {
","public static String encode(String message) {
    StringBuilder encodedMessage = new StringBuilder();
    for (char c : message.toCharArray()) {
        if (Character.isLetter(c)) {
            // Swap case
            char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);

            // Replace vowels
            if (""AEIOUaeiou"".indexOf(c) != -1) {
                // Determine the offset for vowel replacement
                char replacementChar = (char) (swappedCaseChar + 2);
                encodedMessage.append(replacementChar);
            } else {
                encodedMessage.append(swappedCaseChar);
            }
        }
    }
    return encodedMessage.toString();
}","    }
    public static void main(String[] args) {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Necesitas encontrar el valor primo más grande y devolver la suma de sus dígitos.     / Se le da una lista de números enteros.    // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l))))
    // (10l)
    // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l))))
    // (25l)
    // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l))))
    // (13l)
    // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l))))
    // (11l)
    // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l))))
    // (3l)
    // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l))))
    // (7l)
    public static long skjkasdkd(ArrayList<Long> lst) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static boolean isPrime(long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;

        if (n % 2 == 0 || n % 3 == 0) return false;

        for (long i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0)
                return false;
        }

        return true;
    }

    public static long sumOfDigits(long n) {
        long sum = 0;
        while (n > 0) {
            sum += n % 10;
            n /= 10;
        }
        return sum;
    }

    public static long skjkasdkd(ArrayList<Long> lst) {
        long largestPrime = -1;

        for (long num : lst) {
            if (isPrime(num)) {
                largestPrime = Math.max(largestPrime, num);
            }
        }

        return largestPrime != -1 ? sumOfDigits(largestPrime) : 0;
    }

    public static void main(String[] args) {
        System.out.println(skjkasdkd(new ArrayList<Long>(Arrays.asList(0L, 3L, 2L, 1L, 3L, 5L, 7L, 4L, 5L, 5L, 5L, 2L, 181L, 32L, 4L, 32L, 3L, 2L, 32L, 324L, 4L, 3L))));
    }
}","    }
    public static void main(String[] args) {
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l)))) == (10l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l)))) == (25l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l)))) == (13l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l)))) == (11l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l)))) == (3l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l)))) == (7l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)8191l)))) == (19l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)8191l, (long)123456l, (long)127l, (long)7l)))) == (19l));
    assert(skjkasdkd((new ArrayList<Long>(Arrays.asList((long)127l, (long)97l, (long)8192l)))) == (10l));
    }

}
"
HumanEval_95,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / La función debe devolver false si el mapa hash dado está vacío.     / caso o todas las claves son cadenas en mayúscula, de lo contrario devuelve false.     / Dado un mapa hash, devuelve verdad si todas las teclas son cadenas en menor     // >>> checkDictCase((new HashMap<String,String>(Map.of(""a"", ""apple"", ""b"", ""banana""))))
    // (true)
    // >>> checkDictCase((new HashMap<String,String>(Map.of(""a"", ""apple"", ""A"", ""banana"", ""B"", ""banana""))))
    // (false)
    // >>> checkDictCase((new HashMap<String,String>(Map.of(""a"", ""apple"", 8l, ""banana"", ""a"", ""apple""))))
    // (false)
    // >>> checkDictCase((new HashMap<String,String>(Map.of(""Name"", ""John"", ""Age"", ""36"", ""City"", ""Houston""))))
    // (false)
    // >>> checkDictCase((new HashMap<String,String>(Map.of(""STATE"", ""NC"", ""ZIP"", ""12345""))))
    // (true)
    public static boolean checkDictCase(HashMap<String,String> dict) {
","import java.util.HashMap;

class Problem {
    public static boolean checkDictCase(HashMap<String, String> dict) {
        if (dict.isEmpty()) {
            return false;
        }

        boolean allLower = true;
        boolean allUpper = true;

        for (String key : dict.keySet()) {
            if (!key.equals(key.toLowerCase())) {
                allLower = false;
            }
            if (!key.equals(key.toUpperCase())) {
                allUpper = false;
            }
        }

        return allLower || allUpper;
    }

    public static void main(String[] args) {
        HashMap<String, String> map1 = new HashMap<>(Map.of(""a"", ""apple"", ""b"", ""banana""));
        HashMap<String, String> map2 = new HashMap<>(Map.of(""a"", ""apple"", ""A"", ""banana"", ""B"", ""banana""));
        HashMap<String, String> map3 = new HashMap<>(Map.of(""a"", ""apple"", ""8"", ""banana"", ""A"", ""apple""));
        HashMap<String, String> map4 = new HashMap<>(Map.of(""Name"", ""John"", ""Age"", ""36"", ""City"", ""Houston""));
        HashMap<String, String> map5 = new HashMap<>(Map.of(""STATE"", ""NC"", ""ZIP"", ""12345""));

        System.out.println(checkDictCase(map1)); // true
        System.out.println(checkDictCase(map2)); // false
        System.out.println(checkDictCase(map3)); // false
        System.out.println(checkDictCase(map4)); // false
        System.out.println(checkDictCase(map5)); // true
    }
}","    }
    public static void main(String[] args) {
    assert(checkDictCase((new HashMap<String,String>(Map.of(""p"", ""pineapple"", ""b"", ""banana"")))) == (true));
    assert(checkDictCase((new HashMap<String,String>(Map.of(""p"", ""pineapple"", ""A"", ""banana"", ""B"", ""banana"")))) == (false));
    assert(checkDictCase((new HashMap<String,String>(Map.of(""p"", ""pineapple"", ""5"", ""banana"", ""a"", ""apple"")))) == (false));
    assert(checkDictCase((new HashMap<String,String>(Map.of(""Name"", ""John"", ""Age"", ""36"", ""City"", ""Houston"")))) == (false));
    assert(checkDictCase((new HashMap<String,String>(Map.of(""STATE"", ""NC"", ""ZIP"", ""12345"")))) == (true));
    assert(checkDictCase((new HashMap<String,String>(Map.of(""fruit"", ""Orange"", ""taste"", ""Sweet"")))) == (true));
    assert(checkDictCase((new HashMap<String,String>())) == (false));
    }

}
"
HumanEval_96,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / por ejemplo:     / enteros que son números primos y menores que n.     / Implementar una función que toma un entero no negativo y devuelve una lista de matrices de las primeras n     // >>> countUpTo((5l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))
    // >>> countUpTo((11l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))
    // >>> countUpTo((0l))
    // (new ArrayList<Long>(Arrays.asList()))
    // >>> countUpTo((20l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))
    // >>> countUpTo((1l))
    // (new ArrayList<Long>(Arrays.asList()))
    // >>> countUpTo((18l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))
    public static ArrayList<Long> countUpTo(long n) {
","import java.util.ArrayList;

public class Problem {
    
    public static ArrayList<Long> countUpTo(long n) {
        ArrayList<Long> primes = new ArrayList<>();
        for (long i = 2; i < n; i++) {
            if (isPrime(i)) {
                primes.add(i);
            }
        }
        return primes;
    }
    
    private static boolean isPrime(long num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 == 0 || num % 3 == 0) return false;
        for (long i = 5; i * i <= num; i += 6) {
            if (num % i == 0 || num % (i + 2) == 0) return false;
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(countUpTo((5l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))));
    assert(countUpTo((6l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l)))));
    assert(countUpTo((7l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l)))));
    assert(countUpTo((10l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))));
    assert(countUpTo((0l)).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(countUpTo((22l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))));
    assert(countUpTo((1l)).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(countUpTo((18l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))));
    assert(countUpTo((47l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l, (long)23l, (long)29l, (long)31l, (long)37l, (long)41l, (long)43l)))));
    assert(countUpTo((101l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l, (long)23l, (long)29l, (long)31l, (long)37l, (long)41l, (long)43l, (long)47l, (long)53l, (long)59l, (long)61l, (long)67l, (long)71l, (long)73l, (long)79l, (long)83l, (long)89l, (long)97l)))));
    }

}
"
HumanEval_97,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Asumir que la entrada es siempre válida.     / el producto de sus dígitos unitarios.     / Completa la función que toma dos enteros y devuelve     // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    public static long multiply(long a, long b) {
","long unitDigitA = Math.abs(a % 10);
        long unitDigitB = Math.abs(b % 10);
        return unitDigitA * unitDigitB;
    }
}","    }
    public static void main(String[] args) {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Dado una cadena s, cuente el número de vocales mayúsculas en índices pares.     // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    public static long countUpper(String s) {
","long count = 0;
        for (int i = 0; i < s.length(); i += 2) {
            char c = s.charAt(i);
            if (""AEIOU"".indexOf(c) != -1) {
                count++;
            }
        }
        return count;
    }
}","    }
    public static void main(String[] args) {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / de dos enteros, redondearlo lejos de cero.     / y devuelve el número entero más cercano a él. Si el número es equidistante     / Crear una función que tome un valor (cadena) que represente un número     // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    public static long closestInteger(String value) {
","public static long closestInteger(String value) {
        double number = Double.parseDouble(value);
        long rounded = Math.round(number);
        if (Math.abs(number - rounded) == 0.5) {
            // Rounding away from zero
            if (number > 0) {
                return rounded + 1;
            } else {
                return rounded - 1;
            }
        }
        return rounded;
    }

    public static void main(String[] args) {
        System.out.println(closestInteger(""10""));   // 10
        System.out.println(closestInteger(""15.3"")); // 15
        System.out.println(closestInteger(""14.5"")); // 15
        System.out.println(closestInteger(""-14.5""));// -15
    }
}","    }
    public static void main(String[] args) {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / i representa el número de piedras en el nivel (i+1).     / Devuelve el número de piedras en cada nivel en una lista de matrices de matrices, donde el elemento en el índice     / - el siguiente número par si n es par.     / - el siguiente número impar si n es impar.     El número de piedras en el siguiente nivel es:    El primer nivel tiene n piedras.    / Dado un entero positivo n, tienes que hacer una pila de n niveles de piedras.     // >>> makeAPile((3l))
    // (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))
    public static ArrayList<Long> makeAPile(long n) {
","public static ArrayList<Long> makeAPile(long n) {
        ArrayList<Long> pile = new ArrayList<>();
        long stones = n;
        boolean isOdd = stones % 2 != 0;

        for (int i = 0; i < n; i++) {
            pile.add(stones);
            if (isOdd) {
                stones += 2; // Next odd number
            } else {
                stones += 2; // Next even number
            }
        }

        return pile;
    }
}","    }
    public static void main(String[] args) {
    assert(makeAPile((3l)).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))));
    assert(makeAPile((4l)).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)6l, (long)8l, (long)10l)))));
    assert(makeAPile((5l)).equals((new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)9l, (long)11l, (long)13l)))));
    assert(makeAPile((6l)).equals((new ArrayList<Long>(Arrays.asList((long)6l, (long)8l, (long)10l, (long)12l, (long)14l, (long)16l)))));
    assert(makeAPile((8l)).equals((new ArrayList<Long>(Arrays.asList((long)8l, (long)10l, (long)12l, (long)14l, (long)16l, (long)18l, (long)20l, (long)22l)))));
    }

}
"
HumanEval_101,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / para dividir la cadena en palabras y devolver una lista de array array de las palabras.     Se le dará una cadena de palabras separadas por comas o espacios.    // >>> wordsString((""Hi, my name is John""))
    // (new ArrayList<String>(Arrays.asList((String)""Hi"", (String)""my"", (String)""name"", (String)""is"", (String)""John"")))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (new ArrayList<String>(Arrays.asList((String)""One"", (String)""two"", (String)""three"", (String)""four"", (String)""five"", (String)""six"")))
    public static ArrayList<String> wordsString(String s) {
","import java.util.*;

class Problem {
    public static ArrayList<String> wordsString(String s) {
        String[] words = s.split(""[,\\s]+"");
        return new ArrayList<String>(Arrays.asList(words));
    }

    public static void main(String[] args) {
        System.out.println(wordsString(""Hi, my name is John""));
        System.out.println(wordsString(""One, two, three, four, five, six""));
    }
}","    }
    public static void main(String[] args) {
    assert(wordsString((""Hi, my name is John"")).equals((new ArrayList<String>(Arrays.asList((String)""Hi"", (String)""my"", (String)""name"", (String)""is"", (String)""John"")))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((new ArrayList<String>(Arrays.asList((String)""One"", (String)""two"", (String)""three"", (String)""four"", (String)""five"", (String)""six"")))));
    assert(wordsString((""Hi, my name"")).equals((new ArrayList<String>(Arrays.asList((String)""Hi"", (String)""my"", (String)""name"")))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((new ArrayList<String>(Arrays.asList((String)""One"", (String)""two"", (String)""three"", (String)""four"", (String)""five"", (String)""six"")))));
    assert(wordsString(("""")).equals((new ArrayList<String>(Arrays.asList()))));
    assert(wordsString((""ahmed     , gamal"")).equals((new ArrayList<String>(Arrays.asList((String)""ahmed"", (String)""gamal"")))));
    }

}
"
HumanEval_102,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / no hay tal número, entonces la función debe devolver -1.     / mayor número entero par que está en el rango [x, y] inclusive. Si     / Esta función toma dos números positivos x e y y devuelve el     // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    public static long chooseNum(long x, long y) {
","if (x > y) {
            return -1l;
        }
        
        long maxEven = y % 2 == 0 ? y : y - 1;
        if (maxEven >= x) {
            return maxEven;
        } else {
            return -1l;
        }
    }
}","    }
    public static void main(String[] args) {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_104,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Nota: La lista de matrices devuelta debe ordenarse en orden creciente.    / elementos que no tiene ningún dígito par.     / Dado un arreglo una lista de enteros positivos x. devuelve una lista ordenada de todos los     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))
    // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l))))
    // (new ArrayList<Long>(Arrays.asList()))
    public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {
","public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {
        return x.stream()
                .filter(num -> hasNoEvenDigits(num))
                .sorted()
                .collect(Collectors.toCollection(ArrayList::new));
    }

    private static boolean hasNoEvenDigits(long num) {
        while (num > 0) {
            long digit = num % 10;
            if (digit % 2 == 0) {
                return false;
            }
            num /= 10;
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))));
    assert(uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l)))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(uniqueDigits((new ArrayList<Long>(Arrays.asList((long)12345l, (long)2033l, (long)111l, (long)151l)))).equals((new ArrayList<Long>(Arrays.asList((long)111l, (long)151l)))));
    assert(uniqueDigits((new ArrayList<Long>(Arrays.asList((long)135l, (long)103l, (long)31l)))).equals((new ArrayList<Long>(Arrays.asList((long)31l, (long)135l)))));
    }

}
"
HumanEval_105,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / ""Uno"", ""Dos"", ""Tres"", ""Cuatro"", ""Cinco"", ""Seis"", ""Siete"", ""Ocho"", ""Nueve"".  El hombre de la noche    / invertir la lista de matrices resultante, y luego reemplazar cada dígito por su nombre correspondiente de     / Dado una matriz matriz lista de enteros, ordenar los enteros que están entre 1 y 9 inclusive,     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l))))
    // (new ArrayList<String>(Arrays.asList((String)""Eight"", (String)""Five"", (String)""Four"", (String)""Three"", (String)""Two"", (String)""Two"", (String)""One"", (String)""One"")))
    // If the array array list is empty, return an empty array array list:
    // >>> byLength((new ArrayList<Long>(Arrays.asList())))
    // (new ArrayList<String>(Arrays.asList()))
    // If the array array list has any strange number ignore it:
    // >>> byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l))))
    // (new ArrayList<String>(Arrays.asList((String)""One"")))
    public static ArrayList<String> byLength(ArrayList<Long> arr) {
","import java.util.*;

public class Problem {
    public static ArrayList<String> byLength(ArrayList<Long> arr) {
        List<String> names = Arrays.asList("""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"");
        ArrayList<Long> filtered = new ArrayList<>();

        // Filter the numbers between 1 and 9
        for (Long num : arr) {
            if (num >= 1 && num <= 9) {
                filtered.add(num);
            }
        }

        // Sort the filtered numbers
        Collections.sort(filtered);

        // Reverse the sorted list
        Collections.reverse(filtered);

        // Replace each number with its corresponding name
        ArrayList<String> result = new ArrayList<>();
        for (Long num : filtered) {
            result.add(names.get(num.intValue()));
        }

        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l)))).equals((new ArrayList<String>(Arrays.asList((String)""Eight"", (String)""Five"", (String)""Four"", (String)""Three"", (String)""Two"", (String)""Two"", (String)""One"", (String)""One"")))));
    assert(byLength((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<String>(Arrays.asList()))));
    assert(byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l)))).equals((new ArrayList<String>(Arrays.asList((String)""One"")))));
    assert(byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)3l, (long)2l)))).equals((new ArrayList<String>(Arrays.asList((String)""Three"", (String)""Two"", (String)""One"")))));
    assert(byLength((new ArrayList<Long>(Arrays.asList((long)9l, (long)4l, (long)8l)))).equals((new ArrayList<String>(Arrays.asList((String)""Nine"", (String)""Eight"", (String)""Four"")))));
    }

}
"
HumanEval_106,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / el factorial de i es la multiplicación de los números de 1 a i (1 * 2 * ... * i).     /i comienza desde el 1.     / o la suma de los números de 1 a i de lo contrario.     / y devuelve una lista de array array de tamaño n, de tal manera que el valor del elemento en el índice i es el factorial de i si i es par     / Implementar la función f que toma n como un parámetro,     // >>> f((5l))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))
    public static ArrayList<Long> f(long n) {
","import java.util.ArrayList;

public class Problem {
    public static ArrayList<Long> f(long n) {
        ArrayList<Long> result = new ArrayList<>();
        
        for (long i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                result.add(factorial(i));
            } else {
                result.add(sumUpTo(i));
            }
        }
        
        return result;
    }

    private static long factorial(long num) {
        long result = 1;
        for (long i = 1; i <= num; i++) {
            result *= i;
        }
        return result;
    }

    private static long sumUpTo(long num) {
        return num * (num + 1) / 2;
    }

    public static void main(String[] args) {
        System.out.println(f(5));
    }
}","    }
    public static void main(String[] args) {
    assert(f((5l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))));
    assert(f((7l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l, (long)720l, (long)28l)))));
    assert(f((1l)).equals((new ArrayList<Long>(Arrays.asList((long)1l)))));
    assert(f((3l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l)))));
    }

}
"
HumanEval_107,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Ejemplo 1:    / palíndromos enteros que caen dentro del rango ((1, n), inclusive.     / Dado un entero positivo n, devuelve un par que tiene el número de pares y impares     // >>> evenOddPalindrome((3l))
    // (Pair.with(1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // (Pair.with(4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned pair has the number of even and odd integer palindromes respectively.
    public static Pair<Long, Long> evenOddPalindrome(long n) {
","import org.javatuples.Pair;

public class Problem {
    public static Pair<Long, Long> evenOddPalindrome(long n) {
        long evenCount = 0;
        long oddCount = 0;
        
        for (long i = 1; i <= n; i++) {
            if (isPalindrome(i)) {
                if (i % 2 == 0) {
                    evenCount++;
                } else {
                    oddCount++;
                }
            }
        }
        
        return Pair.with(evenCount, oddCount);
    }
    
    private static boolean isPalindrome(long number) {
        long original = number;
        long reversed = 0;
        
        while (number > 0) {
            long digit = number % 10;
            reversed = reversed * 10 + digit;
            number /= 10;
        }
        
        return original == reversed;
    }

    public static void main(String[] args) {
        System.out.println(evenOddPalindrome(3));  // Output: (Pair.with(1l, 2l))
        System.out.println(evenOddPalindrome(12)); // Output: (Pair.with(4l, 6l))
    }
}","    }
    public static void main(String[] args) {
    assert(evenOddPalindrome((123l)).equals((Pair.with(8l, 13l))));
    assert(evenOddPalindrome((12l)).equals((Pair.with(4l, 6l))));
    assert(evenOddPalindrome((3l)).equals((Pair.with(1l, 2l))));
    assert(evenOddPalindrome((63l)).equals((Pair.with(6l, 8l))));
    assert(evenOddPalindrome((25l)).equals((Pair.with(5l, 6l))));
    assert(evenOddPalindrome((19l)).equals((Pair.with(4l, 6l))));
    assert(evenOddPalindrome((9l)).equals((Pair.with(4l, 5l))));
    assert(evenOddPalindrome((1l)).equals((Pair.with(0l, 1l))));
    }

}
"
HumanEval_108,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / por ejemplo -123 tiene los dígitos firmados -1, 2 y 3.     / Si un número es negativo, entonces su primer dígito firmado será negativo:     / el número de elementos cuya suma de dígitos sea > 0.     / Escriba una función count_nums que toma una lista de números enteros y devuelve     // >>> countNums((new ArrayList<Long>(Arrays.asList())))
    // (0l)
    // >>> countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)11l, (long)-11l))))
    // (1l)
    // >>> countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l))))
    // (3l)
    public static long countNums(ArrayList<Long> arr) {
","public static long countNums(ArrayList<Long> arr) {
        return arr.stream().filter(num -> {
            long sumOfDigits = 0;
            long n = Math.abs(num);
            while (n > 0) {
                sumOfDigits += n % 10;
                n /= 10;
            }
            return (num < 0 ? sumOfDigits - 2 * (num % 10) : sumOfDigits) > 0;
        }).count();
    }

    public static void main(String[] args) {
        ArrayList<Long> inputs1 = new ArrayList<Long>(Arrays.asList());
        ArrayList<Long> inputs2 = new ArrayList<Long>(Arrays.asList(-1L, 11L, -11L));
        ArrayList<Long> inputs3 = new ArrayList<Long>(Arrays.asList(1L, 1L, 2L));

        System.out.println(countNums(inputs1)); // Output: 0
        System.out.println(countNums(inputs2)); // Output: 1
        System.out.println(countNums(inputs3)); // Output: 3
    }
}","    }
    public static void main(String[] args) {
    assert(countNums((new ArrayList<Long>(Arrays.asList()))) == (0l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)0l)))) == (0l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l, (long)-2l, (long)3l, (long)4l, (long)5l)))) == (6l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)6l, (long)9l, (long)-6l, (long)0l, (long)1l, (long)5l)))) == (5l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)100l, (long)98l, (long)-7l, (long)1l, (long)-1l)))) == (4l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)12l, (long)23l, (long)34l, (long)-45l, (long)-56l, (long)0l)))) == (5l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))) == (1l));
    assert(countNums((new ArrayList<Long>(Arrays.asList((long)1l)))) == (1l));
    }

}
"
HumanEval_109,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Nota: La lista de matrices dada tiene garantizada la existencia de elementos únicos.    / Si la lista de arrays de arrays dada está vacía entonces devuelve true.     / entonces devuelve verdadero o devuelve falso.     / Si es posible obtener la lista de matrices ordenadas mediante la operación anterior     / la posición inicial en la lista de matrices de matrices, es decir, el índice 0.     El último elemento de la lista de arrays de arrays se moverá a     / Una operación de desplazamiento a la derecha significa desplazar todos los elementos de la lista de matrices por uno     / Se le permite realizar la operación de cambio a la derecha cualquier número de veces.     / la siguiente operación en la lista de matrices de array:     / es posible obtener una lista de matrices ordenadas en orden no decreciente realizando     / números en la lista de matrices de matrices se ordenarán al azar. Su tarea es determinar si     / Tenemos una lista de array array 'arr' de N enteros arr[1], arr[2], ..., arr[N]. El     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l))))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given array array list.
    // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l))))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // array array list by performing any number of right shift operations.
    public static boolean moveOneBall(ArrayList<Long> arr) {
","import java.util.ArrayList;
import java.util.Collections;

class Problem {
    public static boolean moveOneBall(ArrayList<Long> arr) {
        if (arr.isEmpty()) {
            return true;
        }
        
        int n = arr.size();
        
        // Find the number of increasing points
        int count = 0;
        for (int i = 1; i < n; i++) {
            if (arr.get(i) < arr.get(i - 1)) {
                count++;
            }
        }
        
        // Check the end and start to be a breaking point
        if (arr.get(n - 1) > arr.get(0)) {
            count++;
        }
        
        // If there is at most one such transition, it can be rotated
        return count <= 1;
    }
}","    }
    public static void main(String[] args) {
    assert(moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l)))) == (true));
    assert(moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)10l, (long)1l, (long)2l)))) == (true));
    assert(moveOneBall((new ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)1l, (long)2l)))) == (false));
    assert(moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l)))) == (false));
    assert(moveOneBall((new ArrayList<Long>(Arrays.asList()))) == (true));
    }

}
"
HumanEval_110,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / De lo contrario, devuelve ""NO"".     / todos los elementos de lst1 para ser incluso, devuelve ""SI"".     / Si es posible intercambiar elementos entre el lst1 y lst2 para hacer     / No hay límite en el número de elementos intercambiados entre lst1 y lst2.     / entre ellos para hacer lst1 una lista de matrices de matrices de sólo números pares.     / y determina si es posible realizar un intercambio de elementos     / En este problema, implementará una función que toma dos listas de matrices de números,     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))
    // (""YES"")
    // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l))))
    // (""NO"")
    // It is assumed that the input array lists will be non-empty.
    public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {
        // Check if all elements in lst1 are already even
        boolean allEvenInLst1 = lst1.stream().allMatch(num -> num % 2 == 0);
        if (allEvenInLst1) {
            return ""YES"";
        }

        // Check if there is at least one even number in lst2
        boolean hasEvenInLst2 = lst2.stream().anyMatch(num -> num % 2 == 0);
        if (hasEvenInLst2) {
            return ""YES"";
        } else {
            return ""NO"";
        }
    }

    public static void main(String[] args) {
        ArrayList<Long> lst1 = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 4L));
        ArrayList<Long> lst2 = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 4L));
        System.out.println(exchange(lst1, lst2));  // Output: ""YES""

        lst1 = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 4L));
        lst2 = new ArrayList<>(Arrays.asList(1L, 5L, 3L, 4L));
        System.out.println(exchange(lst1, lst2));  // Output: ""NO""
    }
}","    }
    public static void main(String[] args) {
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))).equals((""YES"")));
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l)))).equals((""NO"")));
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)4l, (long)3l)))).equals((""YES"")));
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)3l))), (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)4l)))).equals((""YES"")));
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)3l))), (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l)))).equals((""NO"")));
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)6l, (long)1l, (long)8l, (long)9l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)5l, (long)1l, (long)1l, (long)1l)))).equals((""NO"")));
    assert(exchange((new ArrayList<Long>(Arrays.asList((long)100l, (long)200l))), (new ArrayList<Long>(Arrays.asList((long)200l, (long)200l)))).equals((""YES"")));
    }

}
"
HumanEval_111,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     Si varias letras tienen la misma ocurrencia, devuelve todas.    / de la letra con más repeticiones y que contiene el número correspondiente.     / Dado una cadena que representa una letra minúscula separada por espacios, devuelve un mapa hash     // >>> histogram((""a b c""))
    // (new HashMap<String,Long>(Map.of(""a"", 1l, ""b"", 1l, ""c"", 1l)))
    // >>> histogram((""a b b a""))
    // (new HashMap<String,Long>(Map.of(""a"", 2l, ""b"", 2l)))
    // >>> histogram((""a b c a b""))
    // (new HashMap<String,Long>(Map.of(""a"", 2l, ""b"", 2l)))
    // >>> histogram((""b b b b a""))
    // (new HashMap<String,Long>(Map.of(""b"", 4l)))
    // >>> histogram((""""))
    // (new HashMap<String,Long>())
    public static HashMap<String,Long> histogram(String test) {
","import java.util.HashMap;

class Problem {
    public static HashMap<String, Long> histogram(String test) {
        HashMap<String, Long> countMap = new HashMap<>();
        
        if(test == null || test.isEmpty()) {
            return countMap;
        }
        
        String[] letters = test.split(""\\s+"");
        
        long maxCount = 0;
        
        for(String letter : letters) {
            countMap.put(letter, countMap.getOrDefault(letter, 0L) + 1);
            maxCount = Math.max(maxCount, countMap.get(letter));
        }
        
        HashMap<String, Long> result = new HashMap<>();
        
        for(Map.Entry<String, Long> entry : countMap.entrySet()) {
            if(entry.getValue() == maxCount) {
                result.put(entry.getKey(), entry.getValue());
            }
        }
        
        return result;
    }
}","    }
    public static void main(String[] args) {
    assert(histogram((""a b b a"")).equals((new HashMap<String,Long>(Map.of(""a"", 2l, ""b"", 2l)))));
    assert(histogram((""a b c a b"")).equals((new HashMap<String,Long>(Map.of(""a"", 2l, ""b"", 2l)))));
    assert(histogram((""a b c d g"")).equals((new HashMap<String,Long>(Map.of(""a"", 1l, ""b"", 1l, ""c"", 1l, ""d"", 1l, ""g"", 1l)))));
    assert(histogram((""r t g"")).equals((new HashMap<String,Long>(Map.of(""r"", 1l, ""t"", 1l, ""g"", 1l)))));
    assert(histogram((""b b b b a"")).equals((new HashMap<String,Long>(Map.of(""b"", 4l)))));
    assert(histogram((""r t g"")).equals((new HashMap<String,Long>(Map.of(""r"", 1l, ""t"", 1l, ""g"", 1l)))));
    assert(histogram(("""")).equals((new HashMap<String,Long>())));
    assert(histogram((""a"")).equals((new HashMap<String,Long>(Map.of(""a"", 1l)))));
    }

}
"
HumanEval_112,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    - Ejemplo .    / Debe devolver un par que contenga la cadena de resultados y true/false para la comprobación.     / Una cadena se llama palíndromo si se lee al mismo tiempo hacia atrás como hacia delante.     / entonces compruebe si la cadena de resultados es palíndromo.     / Nos dan dos cadenas s y c, tienes que eliminar todos los caracteres en s que son iguales a cualquier carácter en c     - ¿ Qué ?    // >>> reverseDelete((""abcde""), (""ae""))
    // (Pair.with(""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // (Pair.with(""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // (Pair.with(""cdedc"", true))
    public static Pair<String, Boolean> reverseDelete(String s, String c) {
","import org.javatuples.Pair;

public class Problem {

    public static Pair<String, Boolean> reverseDelete(String s, String c) {
        Set<Character> charsToDelete = new HashSet<>();
        for (char ch : c.toCharArray()) {
            charsToDelete.add(ch);
        }
        
        StringBuilder filteredString = new StringBuilder();
        for (char ch : s.toCharArray()) {
            if (!charsToDelete.contains(ch)) {
                filteredString.append(ch);
            }
        }
        
        String resultString = filteredString.toString();
        boolean isPalindrome = isPalindrome(resultString);
        
        return Pair.with(resultString, isPalindrome);
    }

    private static boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(reverseDelete((""abcde""), (""ae"")).equals((Pair.with(""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals((Pair.with(""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals((Pair.with(""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals((Pair.with(""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((Pair.with("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals((Pair.with(""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals((Pair.with(""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals((Pair.with(""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((Pair.with("""", true))));
    }

}
"
HumanEval_113,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / de dígitos impares en la cadena i'th de la entrada.     / cadena i de la entrada. "" donde todas las i deben ser reemplazadas por el número     / Cada elemento i de la salida debe ser ""el número de elementos impares en el     / Dado un listado de array array de cadenas, donde cada cadena consiste solo en dígitos, devuelve una lista de array array.     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)""1234567""))))
    // (new ArrayList<String>(Arrays.asList((String)""the number of odd elements 4n the str4ng 4 of the 4nput."")))
    // >>> oddCount((new ArrayList<String>(Arrays.asList((String)""3"", (String)""11111111""))))
    // (new ArrayList<String>(Arrays.asList((String)""the number of odd elements 1n the str1ng 1 of the 1nput."", (String)""the number of odd elements 8n the str8ng 8 of the 8nput."")))
    public static ArrayList<String> oddCount(ArrayList<String> lst) {
","import java.util.*;

class Problem {
    public static ArrayList<String> oddCount(ArrayList<String> lst) {
        ArrayList<String> result = new ArrayList<>();

        for (String s : lst) {
            int oddCount = 0;
            for (char c : s.toCharArray()) {
                if (Character.isDigit(c)) {
                    int digit = c - '0';
                    if (digit % 2 != 0) {
                        oddCount++;
                    }
                }
            }

            String output = ""the number of odd elements "" + oddCount +
                            ""n the str"" + oddCount + ""ng "" + oddCount + "" of the "" + oddCount + ""nput."";
            result.add(output);
        }

        return result;
    }
    
    public static void main(String[] args) {
        ArrayList<String> input1 = new ArrayList<String>(Arrays.asList(""1234567""));
        ArrayList<String> result1 = oddCount(input1);
        System.out.println(result1);

        ArrayList<String> input2 = new ArrayList<String>(Arrays.asList(""3"", ""11111111""));
        ArrayList<String> result2 = oddCount(input2);
        System.out.println(result2);
    }
}","    }
    public static void main(String[] args) {
    assert(oddCount((new ArrayList<String>(Arrays.asList((String)""1234567"")))).equals((new ArrayList<String>(Arrays.asList((String)""the number of odd elements 4n the str4ng 4 of the 4nput."")))));
    assert(oddCount((new ArrayList<String>(Arrays.asList((String)""3"", (String)""11111111"")))).equals((new ArrayList<String>(Arrays.asList((String)""the number of odd elements 1n the str1ng 1 of the 1nput."", (String)""the number of odd elements 8n the str8ng 8 of the 8nput."")))));
    assert(oddCount((new ArrayList<String>(Arrays.asList((String)""271"", (String)""137"", (String)""314"")))).equals((new ArrayList<String>(Arrays.asList((String)""the number of odd elements 2n the str2ng 2 of the 2nput."", (String)""the number of odd elements 3n the str3ng 3 of the 3nput."", (String)""the number of odd elements 2n the str2ng 2 of the 2nput."")))));
    }

}
"
HumanEval_114,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    - Ejemplo .    - ¿Qué es eso?    / Dado una lista de matrices de números enteros, encuentre la suma mínima de cualquier lista de matrices de sub-matriz no vacía     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l))))
    // (1l)
    // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l))))
    // (-6l)
    public static long minSubArraySum(ArrayList<Long> nums) {
","import java.util.*;

public class Problem {
    public static long minSubArraySum(ArrayList<Long> nums) {
        if (nums == null || nums.isEmpty()) {
            throw new IllegalArgumentException(""The input list cannot be null or empty"");
        }

        long minSum = Long.MAX_VALUE;
        long currentSum = 0;

        for (Long num : nums) {
            currentSum = Math.min(currentSum + num, num);
            minSum = Math.min(minSum, currentSum);
        }

        return minSum;
    }

    public static void main(String[] args) {
        System.out.println(minSubArraySum(new ArrayList<Long>(Arrays.asList(2L, 3L, 4L, 1L, 2L, 4L))));
        System.out.println(minSubArraySum(new ArrayList<Long>(Arrays.asList(-1L, -2L, -3L))));
    }
}","    }
    public static void main(String[] args) {
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l)))) == (1l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l)))) == (-6l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l, (long)2l, (long)-10l)))) == (-14l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-9999999999999999l)))) == (-9999999999999999l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)0l, (long)10l, (long)20l, (long)1000000l)))) == (0l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l, (long)10l, (long)-5l)))) == (-6l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)100l, (long)-1l, (long)-2l, (long)-3l, (long)10l, (long)-5l)))) == (-6l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)10l, (long)11l, (long)13l, (long)8l, (long)3l, (long)4l)))) == (3l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)100l, (long)-33l, (long)32l, (long)-1l, (long)0l, (long)-2l)))) == (-33l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-10l)))) == (-10l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)7l)))) == (7l));
    assert(minSubArraySum((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l)))) == (-1l));
    }

}
"
HumanEval_115,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Ejemplo 1:    / Saque el número de veces que necesita para bajar los cubos.     / Su tarea es usar los cubos para vaciar los pozos.     / y todos los cubos tienen la misma capacidad.     / Cada pozo tiene un cubo correspondiente que se puede utilizar para extraer agua de él,     / y cada 1 en una fila representa una sola unidad de agua.     Se le da una cuadrícula rectangular de pozos, cada fila representa un solo pozo.    // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {
        long totalWater = 0;
        
        for (ArrayList<Long> row : grid) {
            for (Long cell : row) {
                totalWater += cell;
            }
        }

        return (long)Math.ceil((double)totalWater / capacity);
    }

    public static void main(String[] args) {
        ArrayList<ArrayList<Long>> grid1 = new ArrayList<>(Arrays.asList(
            new ArrayList<>(Arrays.asList(0L, 0L, 1L, 0L)),
            new ArrayList<>(Arrays.asList(0L, 1L, 0L, 0L)),
            new ArrayList<>(Arrays.asList(1L, 1L, 1L, 1L))
        ));
        System.out.println(maxFill(grid1, 1L)); // Output: 6

        ArrayList<ArrayList<Long>> grid2 = new ArrayList<>(Arrays.asList(
            new ArrayList<>(Arrays.asList(0L, 0L, 1L, 1L)),
            new ArrayList<>(Arrays.asList(0L, 0L, 0L, 0L)),
            new ArrayList<>(Arrays.asList(1L, 1L, 1L, 1L)),
            new ArrayList<>(Arrays.asList(0L, 1L, 1L, 1L))
        ));
        System.out.println(maxFill(grid2, 2L)); // Output: 5

        ArrayList<ArrayList<Long>> grid3 = new ArrayList<>(Arrays.asList(
            new ArrayList<>(Arrays.asList(0L, 0L, 0L)),
            new ArrayList<>(Arrays.asList(0L, 0L, 0L))
        ));
        System.out.println(maxFill(grid3, 5L)); // Output: 0
    }
}","    }
    public static void main(String[] args) {
    assert(maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l)) == (6l));
    assert(maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l)) == (5l));
    assert(maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l)) == (0l));
    assert(maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (2l)) == (4l));
    assert(maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (9l)) == (2l));
    }

}
"
HumanEval_116,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Debe ser implementado así:     / Para un número similar de unos, ordenar basado en el valor decimal.     / número de unos en su representación binaria en orden ascendente.     / En este Kata, tienes que ordenar una lista de matrices de enteros no negativos de acuerdo a     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l))))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))
    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l))))
    // (new ArrayList<Long>(Arrays.asList((long)-6l, (long)-5l, (long)-4l, (long)-3l, (long)-2l)))
    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l))))
    // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l)))
    public static ArrayList<Long> sortArray(ArrayList<Long> arr) {
","import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

class Problem {

    public static ArrayList<Long> sortArray(ArrayList<Long> arr) {
        Collections.sort(arr, (a, b) -> {
            int countOnesA = Long.bitCount(a);
            int countOnesB = Long.bitCount(b);
            
            if (countOnesA != countOnesB) {
                return countOnesA - countOnesB;
            } else {
                return a.compareTo(b);
            }
        });
        return arr;
    }
    
    public static void main(String[] args) {
        System.out.println(sortArray(new ArrayList<Long>(Arrays.asList(1L, 5L, 2L, 3L, 4L))));
        System.out.println(sortArray(new ArrayList<Long>(Arrays.asList(-2L, -3L, -4L, -5L, -6L))));
        System.out.println(sortArray(new ArrayList<Long>(Arrays.asList(1L, 0L, 2L, 3L, 4L))));
    }
}","    }
    public static void main(String[] args) {
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l)))).equals((new ArrayList<Long>(Arrays.asList((long)-4l, (long)-2l, (long)-6l, (long)-5l, (long)-3l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)4l, (long)3l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)77l, (long)4l, (long)5l, (long)3l, (long)5l, (long)7l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)4l, (long)4l, (long)3l, (long)3l, (long)5l, (long)5l, (long)5l, (long)7l, (long)77l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)44l, (long)12l, (long)32l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)32l, (long)3l, (long)5l, (long)6l, (long)12l, (long)44l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l, (long)16l, (long)32l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l, (long)16l, (long)32l)))));
    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l, (long)16l, (long)32l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l, (long)16l, (long)32l)))));
    }

}
"
HumanEval_117,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Nota: puede asumir que la cadena de entrada contiene sólo letras y espacios.     / Si la cadena s está vacía entonces la función debe devolver una lista de matrices vacía.     / n consonantes, en orden de que estas palabras aparezcan en la cadena s.     / una función que devuelve una lista de array array de todas las palabras de la cadena s que contienen exactamente     / Dado una cadena s y un número natural n, se le ha encargado implementar     // >>> selectWords((""Mary had a little lamb""), (4l))
    // (new ArrayList<String>(Arrays.asList((String)""little"")))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (new ArrayList<String>(Arrays.asList((String)""Mary"", (String)""lamb"")))
    // >>> selectWords((""simple white space""), (2l))
    // (new ArrayList<String>(Arrays.asList()))
    // >>> selectWords((""Hello world""), (4l))
    // (new ArrayList<String>(Arrays.asList((String)""world"")))
    // >>> selectWords((""Uncle sam""), (3l))
    // (new ArrayList<String>(Arrays.asList((String)""Uncle"")))
    public static ArrayList<String> selectWords(String s, long n) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static ArrayList<String> selectWords(String s, long n) {
        ArrayList<String> result = new ArrayList<>();
        if (s == null || s.isEmpty()) {
            return result;
        }
        
        String[] words = s.split("" "");
        for (String word : words) {
            long consonantCount = countConsonants(word);
            if (consonantCount == n) {
                result.add(word);
            }
        }
        
        return result;
    }
    
    private static long countConsonants(String word) {
        long count = 0;
        for (char c : word.toCharArray()) {
            if (isConsonant(c)) {
                count++;
            }
        }
        return count;
    }
    
    private static boolean isConsonant(char c) {
        c = Character.toLowerCase(c);
        return ""bcdfghjklmnpqrstvwxyz"".indexOf(c) != -1;
    }
}","    }
    public static void main(String[] args) {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((new ArrayList<String>(Arrays.asList((String)""little"")))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((new ArrayList<String>(Arrays.asList((String)""Mary"", (String)""lamb"")))));
    assert(selectWords((""simple white space""), (2l)).equals((new ArrayList<String>(Arrays.asList()))));
    assert(selectWords((""Hello world""), (4l)).equals((new ArrayList<String>(Arrays.asList((String)""world"")))));
    assert(selectWords((""Uncle sam""), (3l)).equals((new ArrayList<String>(Arrays.asList((String)""Uncle"")))));
    assert(selectWords((""""), (4l)).equals((new ArrayList<String>(Arrays.asList()))));
    assert(selectWords((""a b c d e f""), (1l)).equals((new ArrayList<String>(Arrays.asList((String)""b"", (String)""c"", (String)""d"", (String)""f"")))));
    }

}
"
HumanEval_118,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / Usted puede asumir que la cadena dada contiene letra sólo en inglés.     / encontrar cualquier vocal cumplió con la condición anterior.     / Vocales en el principio y el final no cuentan. Vuelva cadena vacía si no lo hizo     / dos consonantes desde el lado derecho de la palabra (sensible a la casilla).     Se te da una palabra, tu tarea es encontrar la vocal más cercana que se interponga entre ellas.    // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    public static String getClosestVowel(String word) {
","public static String getClosestVowel(String word) {
    String vowels = ""AEIOUaeiou"";
    int len = word.length();
    if (len < 3) {
        return """";
    }
    
    for (int i = len - 2; i > 0; i--) {
        char currentChar = word.charAt(i);
        if (vowels.indexOf(currentChar) != -1) {
            char prevChar = word.charAt(i - 1);
            char nextChar = word.charAt(i + 1);
            if (vowels.indexOf(prevChar) == -1 && vowels.indexOf(nextChar) == -1) {
                return String.valueOf(currentChar);
            }
        }
    }
    
    return """";
}","    }
    public static void main(String[] args) {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Devuelve 'Sí' si hay una manera de hacer una buena cadena, y devuelve 'No' de lo contrario.     / ""()) "" no es así.    Por ejemplo: la cadena '(()))))) ' es buena, mientras que la cadena     / Una cadena S se considera buena si y sólo si todos los paréntesis en S     / algún orden, que la cadena resultante será buena.     / Tu trabajo es comprobar si es posible concatenar las dos cuerdas en     / sólo entre paréntesis "" (("") o entre paréntesis cerradas "").     / Se le da una lista de array array de dos cadenas, ambas cadenas consisten en abierto     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)""()("", (String)"")""))))
    // (""Yes"")
    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)"")"", (String)"")""))))
    // (""No"")
    public static String matchParens(ArrayList<String> lst) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static String matchParens(ArrayList<String> lst) {
        String s1 = lst.get(0);
        String s2 = lst.get(1);

        // Check s1 + s2
        if (isBalanced(s1 + s2)) {
            return ""Yes"";
        }

        // Check s2 + s1
        if (isBalanced(s2 + s1)) {
            return ""Yes"";
        }

        // None are balanced
        return ""No"";
    }
    
    private static boolean isBalanced(String str) {
        int balance = 0;
        for (char c : str.toCharArray()) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) { 
                return false; 
            }
        }
        return balance == 0;
    }

    public static void main(String[] args) {
        ArrayList<String> test1 = new ArrayList<>(Arrays.asList(""()("", "")""));
        System.out.println(matchParens(test1)); // Output: Yes

        ArrayList<String> test2 = new ArrayList<>(Arrays.asList("")"", "")""));
        System.out.println(matchParens(test2)); // Output: No
    }
}","    }
    public static void main(String[] args) {
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""()("", (String)"")"")))).equals((""Yes"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)"")"", (String)"")"")))).equals((""No"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""(()(())"", (String)""())())"")))).equals((""No"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)"")())"", (String)""(()()("")))).equals((""Yes"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""(())))"", (String)""(()())(("")))).equals((""Yes"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""()"", (String)""())"")))).equals((""No"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""(()("", (String)""()))()"")))).equals((""Yes"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""(((("", (String)""((())"")))).equals((""No"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)"")(()"", (String)""(()("")))).equals((""No"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)"")("", (String)"")("")))).equals((""No"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)""("", (String)"")"")))).equals((""Yes"")));
    assert(matchParens((new ArrayList<String>(Arrays.asList((String)"")"", (String)""("")))).equals((""Yes"")));
    }

}
"
HumanEval_120,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Ejemplo 1:    / de longitud k con el máximo de k números en arr.     / Dado un array array list arr de enteros y un entero positivo k, devuelve una lista de array ordenados     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l))
    // (new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))
    // Example 2:
    // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l))
    // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))
    // Example 3:
    // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))
    // (new ArrayList<Long>(Arrays.asList((long)2l)))
    // Note:
    // 1. The length of the array array list will be in the range of [1, 1000].
    // 2. The elements in the array array list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {
","import java.util.ArrayList;
import java.util.Collections;

class Problem {

    public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {
        // Sort the array list in descending order
        Collections.sort(arr, Collections.reverseOrder());
        
        // Prepare the result list to store the maximum k elements
        ArrayList<Long> result = new ArrayList<Long>();

        // Add the first k elements to the result list
        for (int i = 0; i < k; i++) {
            result.add(arr.get(i));
        }
        
        // Sort the result in ascending order as per the problem statement
        Collections.sort(result);
        
        return result;
    }

    public static void main(String[] args) {
        // Example 1
        ArrayList<Long> example1 = new ArrayList<Long>();
        Collections.addAll(example1, -3L, -4L, 5L);
        System.out.println(maximum(example1, 3));

        // Example 2
        ArrayList<Long> example2 = new ArrayList<Long>();
        Collections.addAll(example2, 4L, -4L, 4L);
        System.out.println(maximum(example2, 2));

        // Example 3
        ArrayList<Long> example3 = new ArrayList<Long>();
        Collections.addAll(example3, -3L, 2L, 1L, 2L, -1L, -2L, 1L);
        System.out.println(maximum(example3, 1));
    }
}","    }
    public static void main(String[] args) {
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l)).equals((new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l)).equals((new ArrayList<Long>(Arrays.asList((long)2l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)123l, (long)-123l, (long)20l, (long)0l, (long)1l, (long)2l, (long)-3l))), (3l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)20l, (long)123l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-123l, (long)20l, (long)0l, (long)1l, (long)2l, (long)-3l))), (4l)).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)20l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)5l, (long)15l, (long)0l, (long)3l, (long)-13l, (long)-8l, (long)0l))), (7l)).equals((new ArrayList<Long>(Arrays.asList((long)-13l, (long)-8l, (long)0l, (long)0l, (long)3l, (long)5l, (long)15l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)0l, (long)2l, (long)5l, (long)3l, (long)-10l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)5l, (long)-7l))), (1l)).equals((new ArrayList<Long>(Arrays.asList((long)5l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)-4l, (long)4l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-10l, (long)10l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)-10l, (long)10l)))));
    assert(maximum((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)-23l, (long)243l, (long)-400l, (long)0l))), (0l)).equals((new ArrayList<Long>(Arrays.asList()))));
    }

}
"
HumanEval_121,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / Dado una lista de matrices no vacías de enteros, devuelve la suma de todos los elementos impares que están en posiciones pares.     // >>> solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l))))
    // (12l)
    // >>> solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l))))
    // (9l)
    // >>> solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l))))
    // (0l)
    public static long solution(ArrayList<Long> lst) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    // Given a non-empty array list of integers, return the sum of all of the odd elements that are in even positions.
    public static long solution(ArrayList<Long> lst) {
        long sum = 0;
        for (int i = 0; i < lst.size(); i += 2) { // Iterate over even indices (0-based)
            long num = lst.get(i);
            if (num % 2 != 0) { // Check if the element is odd
                sum += num;
            }
        }
        return sum;
    }

    // Test the solution method
    public static void main(String[] args) {
        System.out.println(solution(new ArrayList<>(Arrays.asList(5L, 8L, 7L, 1L)))); // Expected output: 12
        System.out.println(solution(new ArrayList<>(Arrays.asList(3L, 3L, 3L, 3L, 3L)))); // Expected output: 9
        System.out.println(solution(new ArrayList<>(Arrays.asList(30L, 13L, 24L, 321L)))); // Expected output: 0
    }
}","    }
    public static void main(String[] args) {
    assert(solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l)))) == (12l));
    assert(solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l)))) == (9l));
    assert(solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l)))) == (0l));
    assert(solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)9l)))) == (5l));
    assert(solution((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l)))) == (0l));
    assert(solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)23l, (long)32l)))) == (23l));
    assert(solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)13l, (long)2l, (long)9l)))) == (3l));
    }

}
"
HumanEval_122,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / la suma de los elementos con como máximo dos dígitos de los primeros k elementos de arr.     / Dado un matriz no vacío matriz lista de enteros arr y un entero k, devuelve     // >>> addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    public static long addElements(ArrayList<Long> arr, long k) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    public static long addElements(ArrayList<Long> arr, long k) {
        long sum = 0;
        for (int i = 0; i < k; i++) {
            long element = arr.get(i);
            if (element < 100) {
                sum += element;
            }
        }
        return sum;
    }
}","    }
    public static void main(String[] args) {
    assert(addElements((new ArrayList<Long>(Arrays.asList((long)1l, (long)-2l, (long)-3l, (long)41l, (long)57l, (long)76l, (long)87l, (long)88l, (long)99l))), (3l)) == (-4l));
    assert(addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)121l, (long)3l, (long)4000l, (long)5l, (long)6l))), (2l)) == (0l));
    assert(addElements((new ArrayList<Long>(Arrays.asList((long)11l, (long)21l, (long)3l, (long)90l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l)) == (125l));
    assert(addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l)) == (24l));
    assert(addElements((new ArrayList<Long>(Arrays.asList((long)1l))), (1l)) == (1l));
    }

}
"
HumanEval_123,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / get_odd_collatz(5) devuelve [1, 5] # La secuencia de collatz para 5 es [5, 16, 8, 4, 2, 1], por lo que los números impares son sólo 1, y 5.     Por ejemplo:    / 2. lista de matrices devuelta ordenada en orden creciente.     / 1. Collatz(1) es [1].     / Nota:     / término más 1. La conjetura es que no importa qué valor de n, la secuencia siempre alcanzará 1.     Si el término anterior es impar, el siguiente término es 3 veces el anterior.    / término anterior de la siguiente manera: si el término anterior es par, el término siguiente es la mitad de     / de la siguiente manera: comienza con cualquier entero positivo n. Luego cada término se obtiene de la     La conjetura de Collatz es una conjetura en matemáticas que concierne a una secuencia definida .    / Dado un entero positivo n, devuelve una lista de matrices ordenadas que tiene los números impares en la secuencia de collatz.     // >>> getOddCollatz((5l))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))
    public static ArrayList<Long> getOddCollatz(long n) {
","import java.util.*;

class Problem {
    public static ArrayList<Long> getOddCollatz(long n) {
        TreeSet<Long> oddNumbers = new TreeSet<>();
        while (n != 1) {
            if (n % 2 == 1) {
                oddNumbers.add(n);
            }
            if (n % 2 == 0) {
                n = n / 2;
            } else {
                n = 3 * n + 1;
            }
        }
        oddNumbers.add(1L); // Adding 1 as it is always included in the sequence
        return new ArrayList<>(oddNumbers);
    }
    
    public static void main(String[] args) {
        System.out.println(getOddCollatz(5)); // Example usage
    }
}","    }
    public static void main(String[] args) {
    assert(getOddCollatz((14l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))));
    assert(getOddCollatz((5l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))));
    assert(getOddCollatz((12l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l)))));
    assert(getOddCollatz((1l)).equals((new ArrayList<Long>(Arrays.asList((long)1l)))));
    }

}
"
HumanEval_124,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / 4. La fecha debe tener el formato: mm-dd-aaaa     / 3. Los meses no deben ser menores de 1 o mayores de 12.    / 2. El número de días no es menor de 1 o mayor de 31 días para los meses 1,3,5,7,8,10,12. Y el número de días no es menor de 1 o mayor de 30 días para los meses 4,6,9,11. Y, el número de días no es menor de 1 o mayor de 29 para el mes 2.     / 1. La cadena de fecha no está vacía.     / La fecha es válida si se cumplen todas las siguientes reglas:     / devuelve verdadero si la fecha es válida de lo contrario falsa.     / Tienes que escribir una función que valide una cadena de fechas dada y     // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    public static boolean validDate(String date) {
","import java.util.*;

class Problem {
    public static boolean validDate(String date) {
        if (date == null || date.isEmpty() || date.length() != 10) {
            return false;
        }

        // Check if format is mm-dd-yyyy
        if (date.charAt(2) != '-' || date.charAt(5) != '-') {
            return false;
        }

        try {
            int month = Integer.parseInt(date.substring(0, 2));
            int day = Integer.parseInt(date.substring(3, 5));
            int year = Integer.parseInt(date.substring(6, 10));
            
            if (month < 1 || month > 12) {
                return false;
            }

            boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
            int[] daysInMonth = {0, 31, (isLeapYear ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
            
            if (day < 1 || day > daysInMonth[month]) {
                return false;
            }
            
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}","    }
    public static void main(String[] args) {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_126,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / número, devuelve false. Asume que no hay números negativos y sólo enteros.     Si la lista de matrices tiene más de 1 duplicado de la misma     / Dado una matriz matriz lista de números, devuelve si están ordenados o no.    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)5l))))
    // (true)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))
    // (true)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l))))
    // (false)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))
    // (true)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l))))
    // (true)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l))))
    // (false)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l))))
    // (true)
    // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l))))
    // (false)
    public static boolean isSorted(ArrayList<Long> lst) {
","public static boolean isSorted(ArrayList<Long> lst) {
        if (lst == null || lst.size() <= 1) {
            return true;
        }
        int duplicateCount = 0;
        for (int i = 1; i < lst.size(); i++) {
            if (lst.get(i) < lst.get(i - 1)) {
                return false;
            }
            if (lst.get(i).equals(lst.get(i - 1))) {
                duplicateCount++;
                if (duplicateCount > 1) {
                    return false;
                }
            } else {
                duplicateCount = 0;
            }
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)5l)))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l)))) == (false));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l)))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l)))) == (false));
    assert(isSorted((new ArrayList<Long>(Arrays.asList()))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l)))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)1l)))) == (false));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l)))) == (false));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l)))) == (false));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l)))) == (true));
    assert(isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))) == (true));
    }

}
"
HumanEval_127,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / [muestras de entrada/salida]:     / Si los dos intervalos no se cruzan, devuelve ""NO"".     / de lo contrario, devuelve ""NO"".     / Si la longitud de la intersección es un número primo, devuelve ""SÍ"",     / cuya longitud es 1, que no es un número primo.     / Ejemplo, la intersección de los intervalos (1, 3), (2, 4) es (2, 3)     / intervalos es un número primo.     / Su tarea es determinar si la longitud de la intersección de estos dos     / Para cada intervalo dado, se supone que su comienzo es menor o igual a su final.     / incluye tanto el principio como el final.     / Los intervalos dados están cerrados lo que significa que el intervalo (inicio, fin)     / donde cada intervalo es un par de enteros. Por ejemplo, intervalo = (inicio, final) = (1, 2).     - Se le dan dos intervalos.    // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))
    // (""NO"")
    // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))
    // (""NO"")
    // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l)))
    // (""YES"")
    public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {
","import org.javatuples.Pair;

public class Problem {
    public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {
        long start1 = interval1.getValue0();
        long end1 = interval1.getValue1();
        long start2 = interval2.getValue0();
        long end2 = interval2.getValue1();

        long startIntersection = Math.max(start1, start2);
        long endIntersection = Math.min(end1, end2);

        if (startIntersection > endIntersection) {
            return ""NO"";
        }

        long intersectionLength = endIntersection - startIntersection;

        if (isPrime(intersectionLength)) {
            return ""YES"";
        } else {
            return ""NO"";
        }
    }

    private static boolean isPrime(long n) {
        if (n <= 1) {
            return false;
        }
        if (n <= 3) {
            return true;
        }
        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }
        for (long i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(intersection(Pair.with(1L, 2L), Pair.with(2L, 3L))); // ""NO""
        System.out.println(intersection(Pair.with(-1L, 1L), Pair.with(0L, 4L))); // ""NO""
        System.out.println(intersection(Pair.with(-3L, -1L), Pair.with(-5L, 5L))); // ""YES""
    }
}","    }
    public static void main(String[] args) {
    assert(intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l))).equals((""NO"")));
    assert(intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l))).equals((""NO"")));
    assert(intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l))).equals((""YES"")));
    assert(intersection((Pair.with(-2l, 2l)), (Pair.with(-4l, 0l))).equals((""YES"")));
    assert(intersection((Pair.with(-11l, 2l)), (Pair.with(-1l, -1l))).equals((""NO"")));
    assert(intersection((Pair.with(1l, 2l)), (Pair.with(3l, 5l))).equals((""NO"")));
    assert(intersection((Pair.with(1l, 2l)), (Pair.with(1l, 2l))).equals((""NO"")));
    assert(intersection((Pair.with(-2l, -2l)), (Pair.with(-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / Nota: devuelve null para arr vacío.     / de cada número en la lista de matrices, representado por 1, -1 o 0.     / suma de magnitudes de enteros multiplicada por el producto de todos los signos     / Se le da una matriz matriz lista arr de enteros y debe devolver     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l))))
    // Optional.of(9l)
    // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l))))
    // Optional.of(0l)
    // >>> prodSigns((new ArrayList<Long>(Arrays.asList())))
    // Optional.empty()
    public static Optional<Long> prodSigns(ArrayList<Long> arr) {
","import java.util.*;

public class Problem {

    public static Optional<Long> prodSigns(ArrayList<Long> arr) {
        if (arr.isEmpty()) {
            return Optional.empty();
        }

        long sumOfMagnitudes = 0;
        long productOfSigns = 1;

        for (Long num : arr) {
            sumOfMagnitudes += Math.abs(num);
            if (num < 0) {
                productOfSigns *= -1;
            } else if (num == 0) {
                productOfSigns = 0;
            }
        }

        return Optional.of(sumOfMagnitudes * productOfSigns);
    }
    
    public static void main(String[] args) {
        // Test cases
        System.out.println(prodSigns(new ArrayList<Long>(Arrays.asList(1L, 2L, 2L, -4L)))); // Optional[9]
        System.out.println(prodSigns(new ArrayList<Long>(Arrays.asList(0L, 1L)))); // Optional[0]
        System.out.println(prodSigns(new ArrayList<Long>())); // Optional.empty
    }
}","    }
    public static void main(String[] args) {
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l)))).equals(Optional.of(-9l)));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))).equals(Optional.of(0l)));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)2l, (long)3l, (long)-1l, (long)1l)))).equals(Optional.of(-10l)));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList()))).equals(Optional.empty()));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)2l, (long)-1l, (long)-1l, (long)9l)))).equals(Optional.of(20l)));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)-1l, (long)1l, (long)-1l, (long)1l)))).equals(Optional.of(4l)));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)-1l, (long)1l, (long)1l, (long)1l)))).equals(Optional.of(-4l)));
    assert(prodSigns((new ArrayList<Long>(Arrays.asList((long)-1l, (long)1l, (long)1l, (long)0l)))).equals(Optional.of(0l)));
    }

}
"
HumanEval_129,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Devuelve una lista de matrices ordenadas de los valores de las celdas por las que pasa la ruta mínima.     Se garantiza que la respuesta es única.    / Lst_A[j] = Lst_B[j]  El número de los miembros de la Comisión es el número de los miembros de la Comisión.    / tal que lst_A[i] < lst_B[i] y para cualquier j (1 <= j < i) tenemos     / que lst_B, en otras palabras, existe un índice entero i (1 <= i <= k)     / a través de (llamémoslos lst_A y lst_B), lst_A es lexicográficamente menos     / después de hacer las listas de matrices ordenadas de los valores en las celdas que A y B van     / Se considera que un camino A (de longitud k) es menor que un camino B (de longitud k) si     - No puedes salir de la red.    / necesariamente distintas).    / Tenga en cuenta que un recorrido de longitud k significa visitar exactamente k celdas (no     - ¿Qué es eso?    En otras palabras, puedes ir a las celdas que comparten un borde con tu corriente.    / de cualquier celda, y en cada paso se puede mover a cualquiera de las células vecinas,     Tienes que encontrar el camino mínimo de longitud k en la cuadrícula.    / inclusive aparece exactamente una vez en las celdas de la cuadrícula.     / cada celda de la cuadrícula contiene un valor.    / Dado una cuadrícula con N filas y N columnas (N >= 2) y un número entero positivo k,     // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))
    // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l))
    // (new ArrayList<Long>(Arrays.asList((long)1l)))
    public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {
","import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;

class Problem {

    public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {
        int n = grid.size();
        int[] dx = {0, 0, 1, -1};
        int[] dy = {1, -1, 0, 0};

        PriorityQueue<Path> pq = new PriorityQueue<>();
        // Start from each cell and try to find the minimum path
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                pq.add(new Path(i, j, k, grid.get(i).get(j)));
            }
        }

        while (!pq.isEmpty()) {
            Path current = pq.poll();
            if (current.k == 1) {
                return current.path;
            }
            for (int dir = 0; dir < 4; dir++) {
                int ni = current.x + dx[dir];
                int nj = current.y + dy[dir];
                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {
                    ArrayList<Long> newPath = new ArrayList<>(current.path);
                    newPath.add(grid.get(ni).get(nj));
                    pq.add(new Path(ni, nj, current.k - 1, newPath));
                }
            }
        }

        return new ArrayList<>();
    }

    static class Path implements Comparable<Path> {
        int x, y;
        long k;
        ArrayList<Long> path;

        Path(int x, int y, long k, long value) {
            this.x = x;
            this.y = y;
            this.k = k;
            this.path = new ArrayList<>();
            this.path.add(value);
        }

        Path(int x, int y, long k, ArrayList<Long> path) {
            this.x = x;
            this.y = y;
            this.k = k;
            this.path = path;
        }

        @Override
        public int compareTo(Path other) {
            for (int i = 0; i < this.path.size(); i++) {
                int comparison = Long.compare(this.path.get(i), other.path.get(i));
                if (comparison != 0) {
                    return comparison;
                }
            }
            return 0;
        }
    }

    public static void main(String[] args) {
        ArrayList<ArrayList<Long>> grid1 = new ArrayList<>();
        grid1.add(new ArrayList<>(Arrays.asList(1L, 2L, 3L)));
        grid1.add(new ArrayList<>(Arrays.asList(4L, 5L, 6L)));
        grid1.add(new ArrayList<>(Arrays.asList(7L, 8L, 9L)));
        System.out.println(minPath(grid1, 3L));

        ArrayList<ArrayList<Long>> grid2 = new ArrayList<>();
        grid2.add(new ArrayList<>(Arrays.asList(5L, 9L, 3L)));
        grid2.add(new ArrayList<>(Arrays.asList(4L, 1L, 6L)));
        grid2.add(new ArrayList<>(Arrays.asList(7L, 8L, 2L)));
        System.out.println(minPath(grid2, 1L));
    }
}","    }
    public static void main(String[] args) {
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l)).equals((new ArrayList<Long>(Arrays.asList((long)1l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)7l, (long)8l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)9l, (long)10l, (long)11l, (long)12l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)13l, (long)14l, (long)15l, (long)16l))))), (4l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)2l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)13l, (long)10l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)12l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)3l, (long)16l, (long)11l, (long)15l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)8l, (long)14l, (long)9l, (long)2l))))), (7l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)10l, (long)1l, (long)10l, (long)1l, (long)10l, (long)1l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)8l, (long)14l, (long)9l, (long)2l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)13l, (long)15l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)12l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)3l, (long)10l, (long)11l, (long)16l))))), (5l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)7l, (long)1l, (long)7l, (long)1l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)11l, (long)8l, (long)7l, (long)2l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)16l, (long)14l, (long)4l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)9l, (long)3l, (long)15l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)12l, (long)13l, (long)10l, (long)1l))))), (9l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)6l, (long)1l, (long)6l, (long)1l, (long)6l, (long)1l, (long)6l, (long)1l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)12l, (long)13l, (long)10l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)9l, (long)3l, (long)15l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)16l, (long)14l, (long)4l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)11l, (long)8l, (long)7l, (long)2l))))), (12l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)6l, (long)1l, (long)6l, (long)1l, (long)6l, (long)1l, (long)6l, (long)1l, (long)6l, (long)1l, (long)6l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)2l, (long)7l, (long)4l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)5l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)6l, (long)8l, (long)9l))))), (8l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)3l, (long)1l, (long)3l, (long)1l, (long)3l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)6l, (long)1l, (long)5l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)3l, (long)8l, (long)9l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)2l, (long)7l, (long)4l))))), (8l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)1l, (long)5l, (long)1l, (long)5l, (long)1l, (long)5l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)3l, (long)4l))))), (10l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)2l, (long)1l, (long)2l, (long)1l, (long)2l, (long)1l, (long)2l)))));
    assert(minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))), (10l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)3l, (long)1l, (long)3l, (long)1l, (long)3l, (long)1l, (long)3l)))));
    }

}
"
HumanEval_130,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / los primeros n + 1 números de la secuencia de Tribonacci.     / Se le da un número entero no negativo n, tiene que devolver una lista de array array de la     / = 2 + 3 + 3 = 8     / tri(3) = tri(2) + tri(1) + tri(4)     / tri(4) = 3     / tri(2) = 1 + (2 / 2) = 2     Por ejemplo:    / tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), si n es impar.     / tri (n) = 1 + n / 2, si n es par.     / tri(1) = 3     / La secuencia de Tribonacci se define por la recurrencia:     Sin embargo, lo que la gente no sabe es la secuencia de Tribonacci.    Todos conocen la secuencia de Fibonacci, fue estudiada profundamente por los matemáticos en el siglo XX.    // >>> tri((3l))
    // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))
    public static ArrayList<Long> tri(long n) {
","import java.util.ArrayList;
import java.util.Arrays;

public class Problem {
    public static ArrayList<Long> tri(long n) {
        // Return empty list if n is negative
        if (n < 0) {
            return new ArrayList<>();
        }
        
        // Create an ArrayList to store the Tribonacci sequence
        ArrayList<Long> tribonacci = new ArrayList<>();
        
        // Define the base cases
        if (n >= 0) {
            tribonacci.add(1L);  // tri(0)
        }
        if (n >= 1) {
            tribonacci.add(3L);  // tri(1)
        }
        
        // Calculate the values for the sequence from tri(2) to tri(n)
        for (long i = 2; i <= n; i++) {
            if (i % 2 == 0) {
                tribonacci.add(1 + i / 2);
            } else {
                long value = tribonacci.get((int)(i - 1)) 
                           + tribonacci.get((int)(i - 2)) 
                           + tribonacci.get((int)(i + 1 - 2)); // i+1-2 = i-1 (next i is processed)
                tribonacci.add(value);
            }
        }
        
        return tribonacci;
    }
    
    public static void main(String[] args) {
        System.out.println(tri(3)); // Outputs: [1, 3, 2, 8]
    }
}","    }
    public static void main(String[] args) {
    assert(tri((3l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))));
    assert(tri((4l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l)))));
    assert(tri((5l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l, (long)15l)))));
    assert(tri((6l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l, (long)15l, (long)4l)))));
    assert(tri((7l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l, (long)15l, (long)4l, (long)24l)))));
    assert(tri((8l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l, (long)15l, (long)4l, (long)24l, (long)5l)))));
    assert(tri((9l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l, (long)15l, (long)4l, (long)24l, (long)5l, (long)35l)))));
    assert(tri((20l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l, (long)3l, (long)15l, (long)4l, (long)24l, (long)5l, (long)35l, (long)6l, (long)48l, (long)7l, (long)63l, (long)8l, (long)80l, (long)9l, (long)99l, (long)10l, (long)120l, (long)11l)))));
    assert(tri((0l)).equals((new ArrayList<Long>(Arrays.asList((long)1l)))));
    assert(tri((1l)).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l)))));
    }

}
"
HumanEval_131,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Devuelve 0 si todos los dígitos son pares.     / Dado un entero positivo n, devuelve el producto de los dígitos impares.     // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    public static long digits(long n) {
","public static long digits(long n) {
        long product = 1;
        boolean hasOddDigit = false;
        
        while (n > 0) {
            long digit = n % 10;
            if (digit % 2 != 0) {
                product *= digit;
                hasOddDigit = true;
            }
            n /= 10;
        }
        
        return hasOddDigit ? product : 0;
    }
}","    }
    public static void main(String[] args) {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / donde al menos un soporte en la subsecuencia está anidado.     / La función debe devolver verdad si y sólo si hay una subsecuencia válida de paréntesis     / Crear una función que toma una cadena como entrada que contiene sólo corchetes cuadrados.     // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    public static boolean isNested(String string) {
","import java.util.*;

class Problem {
    public static boolean isNested(String string) {
        int openCount = 0;
        boolean hasNested = false;
        
        for (char c : string.toCharArray()) {
            if (c == '[') {
                openCount++;
            } else if (c == ']') {
                if (openCount > 0) {
                    openCount--;
                    // If we find a pair and there was an unmatched '[' before this ']'
                    // it means there was nesting.
                    hasNested = true;
                }
                
                if (openCount < 0) {
                    // If at any point we have more closing brackets than opening ones,
                    // it's invalid, so reset openCount.
                    openCount = 0;
                }
            }
        }
        
        return hasNested;
    }

    public static void main(String[] args) {
        System.out.println(isNested(""[[]]"")); // true
        System.out.println(isNested(""[]]]]]]][[[[[]"")); // false
        System.out.println(isNested(""[][]"")); // false
        System.out.println(isNested(""[]"")); // false
        System.out.println(isNested(""[[][]]"")); // true
        System.out.println(isNested(""[[]][["")); // true
    }
}","    }
    public static void main(String[] args) {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / redondear cada elemento en la lista de matrices al int superior ((Techo) primero.     / Necesitas devolver la suma de números al cuadrado en la lista de matrices dada,     / Se le da una lista de números de matriz.    // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))))
    // (14l)
    // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)4.0f, (float)9.0f))))
    // (98l)
    // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f))))
    // (84l)
    // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f))))
    // (29l)
    // >>> lst((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f))))
    // (6l)
    public static long sumSquares(ArrayList<Float> lst) {
","public static long sumSquares(ArrayList<Float> lst) {
        return lst.stream()
                  .mapToInt(f -> (int) Math.ceil(f))
                  .map(i -> i * i)
                  .sum();
    }
}","    }
    public static void main(String[] args) {
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f)))) == (14l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f)))) == (14l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f)))) == (84l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f)))) == (29l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f)))) == (6l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f)))) == (10230l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)10000.0f, (float)10000.0f)))) == (200000000l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)-1.4f, (float)4.6f, (float)6.3f)))) == (75l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f)))) == (1086l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)0.0f)))) == (0l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)-1.0f)))) == (1l));
    assert(sumSquares((new ArrayList<Float>(Arrays.asList((float)-1.0f, (float)1.0f, (float)0.0f)))) == (2l));
    }

}
"
HumanEval_134,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Nota: ""palabra"" es un grupo de caracteres separados por un espacio.     / una parte de una palabra, y falsa de lo contrario.     / de una cadena dada es un carácter alfabético y no es     / Crear una función que devuelva verdad si el último carácter es     // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    public static boolean checkIfLastCharIsALetter(String txt) {
","public static boolean checkIfLastCharIsALetter(String txt) {
    txt = txt.trim();
    if (txt.isEmpty()) {
        return false;
    }
    String[] words = txt.split("" "");
    String lastWord = words[words.length - 1];
    if (lastWord.isEmpty()) {
        return false;
    }
    char lastChar = lastWord.charAt(lastWord.length() - 1);
    return Character.isLetter(lastChar);
}","    }
    public static void main(String[] args) {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / los valores se duplican.    / no existe tal elemento entonces devuelve -1. La lista de array array dada no contendrá     / no es mayor o igual al elemento inmediatamente anterior.    / Crear una función que devuelva el índice más grande de un elemento que     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l))))
    // (3l)
    // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))
    // (-1l)
    public static long canArrange(ArrayList<Long> arr) {
","import java.util.*;

class Problem {
    // Create a function which returns the largest index of an element which
    // is not greater than or equal to the element immediately preceding it.
    // If no such element exists then return -1. The given array list will not
    // contain duplicate values.

    public static long canArrange(ArrayList<Long> arr) {
        for (int i = arr.size() - 1; i > 0; i--) {
            if (arr.get(i) < arr.get(i - 1)) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        ArrayList<Long> list1 = new ArrayList<>(Arrays.asList(1L, 2L, 4L, 3L, 5L));
        System.out.println(canArrange(list1)); // Output: 3
        
        ArrayList<Long> list2 = new ArrayList<>(Arrays.asList(1L, 2L, 3L));
        System.out.println(canArrange(list2)); // Output: -1
    }
}","    }
    public static void main(String[] args) {
    assert(canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l)))) == (3l));
    assert(canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)5l)))) == (-1l));
    assert(canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l, (long)10l)))) == (2l));
    assert(canArrange((new ArrayList<Long>(Arrays.asList((long)4l, (long)8l, (long)5l, (long)7l, (long)3l)))) == (4l));
    assert(canArrange((new ArrayList<Long>(Arrays.asList()))) == (-1l));
    }

}
"
HumanEval_136,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Si no hay números enteros negativos o positivos, devuélvelos como nulo.     / de enteros positivos en una lista de matrices de matrices.     / el mayor de los enteros negativos, y 'b' es el más pequeño     / Crear una función que devuelve un par (a, b), donde 'a' es     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l))))
    // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))
    // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))
    // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))
    // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))
    // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))
    public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {
","import java.util.*;
import org.javatuples.*;

class Problem {
    public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {
        Optional<Long> largestNegative = Optional.empty();
        Optional<Long> smallestPositive = Optional.empty();

        for (Long num : lst) {
            if (num < 0) {
                if (!largestNegative.isPresent() || num > largestNegative.get()) {
                    largestNegative = Optional.of(num);
                }
            } else if (num > 0) {
                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {
                    smallestPositive = Optional.of(num);
                }
            }
        }
        
        return Pair.with(largestNegative, smallestPositive);
    }
}","    }
    public static void main(String[] args) {
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l)))).equals(Pair.with(Optional.of(Optional.empty()), Optional.of(1l))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l, (long)0l)))).equals(Pair.with(Optional.of(Optional.empty()), Optional.of(1l))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)-2l)))).equals(Optional.of(Pair.with(-2l, 1l))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)3l, (long)6l, (long)2l, (long)7l, (long)-7l)))).equals(Optional.of(Pair.with(-7l, 2l))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)7l, (long)3l, (long)8l, (long)4l, (long)9l, (long)2l, (long)5l, (long)-9l)))).equals(Optional.of(Pair.with(-9l, 2l))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList()))).equals(Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l)))).equals(Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-3l, (long)-5l, (long)-6l)))).equals(Pair.with(Optional.of(-1l), Optional.of(Optional.empty()))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-3l, (long)-5l, (long)-6l, (long)0l)))).equals(Pair.with(Optional.of(-1l), Optional.of(Optional.empty()))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-6l, (long)-4l, (long)-4l, (long)-3l, (long)1l)))).equals(Optional.of(Pair.with(-3l, 1l))));
    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-6l, (long)-4l, (long)-4l, (long)-3l, (long)-100l, (long)1l)))).equals(Optional.of(Pair.with(-3l, 1l))));
    }

}
"
HumanEval_138,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    - Ejemplo .    / Evalúe si el número dado n puede ser escrito como la suma de exactamente 4 números pares positivos     // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    public static boolean isEqualToSumEven(long n) {
","// Check if the number n is at least 8 since the smallest sum of 4 positive even numbers is 2+2+2+2=8
        if (n < 8) {
            return false;
        }

        // If n is divisible by 2 and n/2 is even, then n can be expressed as the sum of 4 positive even numbers
        return n % 2 == 0;
    }
}","    }
    public static void main(String[] args) {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / donde n > 0     / brasilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1!     / El factorial brasileño se define como:     // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    public static long specialFactorial(long n) {
","import java.util.stream.LongStream;

public class Problem {
    // The Brazilian factorial is defined as:
    // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
    // where n > 0

    public static long specialFactorial(long n) {
        return LongStream.rangeClosed(1, n)
                .map(Problem::factorial)
                .reduce(1, (a, b) -> a * b);
    }

    private static long factorial(long num) {
        return LongStream.rangeClosed(1, num)
                .reduce(1, (a, b) -> a * b);
    }

    public static void main(String[] args) {
        System.out.println(specialFactorial(4)); // Output: 288
    }
}","    }
    public static void main(String[] args) {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / entonces sustituye todos los espacios consecutivos por -     / y si una cadena tiene más de 2 espacios consecutivos,     / Dado una cadena de texto, sustituir todos los espacios con subrayados,     // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    public static String fixSpaces(String text) {
","if (text == null || text.isEmpty()) {
        return text;
    }
    
    StringBuilder result = new StringBuilder();
    int spaceCount = 0;
    for (char c : text.toCharArray()) {
        if (c == ' ') {
            spaceCount++;
        } else {
            if (spaceCount == 1) {
                result.append('_');
            } else if (spaceCount > 1) {
                result.append('-');
            }
            result.append(c);
            spaceCount = 0;
        }
    }
    
    // Handle trailing spaces
    if (spaceCount == 1) {
        result.append('_');
    } else if (spaceCount > 1) {
        result.append('-');
    }
    
    return result.toString();
}","    }
    public static void main(String[] args) {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / - La subcadena después del punto debe ser uno de estos: ['txt', 'exe', 'dll']     / el alfabeto latino ('a'-'z' y 'A'-'Z').     / - La subcadena antes del punto no debe estar vacío, y comienza con una letra de     / - El nombre del archivo contiene exactamente un punto '.'     / - El nombre del archivo no debe contener más de tres dígitos ('0'-'9').     / se cumplen:     / Se considera válido el nombre de un archivo si y sólo si se cumplen todas las condiciones siguientes     / 'Sí' si el nombre del archivo es válido, y devuelve 'No' en caso contrario.     / Crear una función que toma una cadena que representa el nombre de un archivo, y devuelve     // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    public static String fileNameCheck(String file_name) {
","if (file_name == null || file_name.isEmpty()) {
        return ""No"";
    }
    
    // Split the file name into two parts: before and after the dot.
    String[] parts = file_name.split(""\\."");
    
    // Check for exactly one dot and non-empty parts.
    if (parts.length != 2 || parts[0].isEmpty() || parts[1].isEmpty()) {
        return ""No"";
    }
    
    // Check the extension validity.
    Set<String> validExtensions = new HashSet<>(Arrays.asList(""txt"", ""exe"", ""dll""));
    if (!validExtensions.contains(parts[1])) {
        return ""No"";
    }

    // Check that the first character before the dot is a letter.
    if (!Character.isLetter(parts[0].charAt(0))) {
        return ""No"";
    }

    // Count the number of digits in the part before the dot.
    int digitCount = 0;
    for (char c : parts[0].toCharArray()) {
        if (Character.isDigit(c)) {
            digitCount++;
        }
        if (digitCount > 3) {
            return ""No"";
        }
    }

    // All conditions are satisfied, return ""Yes"".
    return ""Yes"";
}","    }
    public static void main(String[] args) {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / cambiar las entradas en la lista de matrices cuyos índices no son un múltiplo de 3 o 4. La función devuelve la suma de todas las entradas.     / múltiple de 3 y cubrirá la entrada entera si su índice es un múltiplo de 4 y no un múltiplo de 3. La función no lo hará.    / Esta función tomará una lista de números enteros de una matriz. Para todas las entradas de la lista de matrices, la función elevará al cuadrado la entrada entera si su índice es a     - ¿ Qué ?    // >>> lst
    // (long)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))
    // >>> lst
    // (long)new ArrayList<Long>(Arrays.asList())
    // >>> lst
    // (long)new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l))
    public static long sumSquares(ArrayList<Long> lst) {
","import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;

class Problem {
    public static long sumSquares(ArrayList<Long> lst) {
        long sum = 0;

        for (int i = 0; i < lst.size(); i++) {
            Long number = lst.get(i);
            if (i % 3 == 0) {
                sum += Math.pow(number, 2);
            } else if (i % 4 == 0) {
                sum += Math.pow(number, 3);
            } else {
                sum += number;
            }
        }

        return sum;
    }
}","    }
    public static void main(String[] args) {
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))) == (6l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)9l)))) == (14l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList()))) == (0l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l, (long)1l, (long)1l, (long)1l, (long)1l, (long)1l)))) == (9l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-1l, (long)-1l, (long)-1l, (long)-1l, (long)-1l, (long)-1l, (long)-1l, (long)-1l)))) == (-3l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)0l)))) == (0l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l)))) == (-126l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)-56l, (long)-99l, (long)1l, (long)0l, (long)-2l)))) == (3030l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)-1l, (long)0l, (long)0l, (long)0l, (long)0l, (long)0l, (long)0l, (long)0l, (long)-1l)))) == (0l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)-16l, (long)-9l, (long)-2l, (long)36l, (long)36l, (long)26l, (long)-20l, (long)25l, (long)-40l, (long)20l, (long)-4l, (long)12l, (long)-26l, (long)35l, (long)37l)))) == (-14196l));
    assert(sumSquares((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-3l, (long)17l, (long)-1l, (long)-15l, (long)13l, (long)-1l, (long)14l, (long)-14l, (long)-12l, (long)-5l, (long)14l, (long)-14l, (long)6l, (long)13l, (long)11l, (long)16l, (long)16l, (long)4l, (long)10l)))) == (-1448l));
    }

}
"
HumanEval_143,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Ejemplo 1:    / el orden de las palabras en la nueva cadena debe ser el mismo que el original.     / cuya longitud es un número primo,     / y tienes que devolver una cadena que contiene las palabras de la oración original,     / la oración contiene algunas palabras separadas por un espacio,     Se le da una cadena que representa una oración.    // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    public static String wordsInSentence(String sentence) {
","public static String wordsInSentence(String sentence) {
        String[] words = sentence.split("" "");
        List<String> primeLengthWords = new ArrayList<>();
        
        for (String word : words) {
            if (isPrime(word.length())) {
                primeLengthWords.add(word);
            }
        }
        
        return String.join("" "", primeLengthWords);
    }

    private static boolean isPrime(int n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (int i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }
}","    }
    public static void main(String[] args) {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Se puede asumir que x, y n son fracciones válidas, y no tienen cero como denominador.     / <numerador>/<denominador> donde tanto el numerador como el denominador son números enteros positivos.     / de otra manera. Tanto x como n, son representaciones de cadenas de una fracción, y tienen el siguiente formato,     / x * n. La función devuelve verdad si x * n se evalúa como un número entero y falso     / Su tarea es implementar una función que simplifique la expresión     // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    public static boolean simplify(String x, String n) {
","public static boolean simplify(String x, String n) {
    // Split the fractions into numerators and denominators
    String[] fracX = x.split(""/"");
    String[] fracN = n.split(""/"");
    
    // Parse numerators and denominators as integers
    int numX = Integer.parseInt(fracX[0]);
    int denX = Integer.parseInt(fracX[1]);
    int numN = Integer.parseInt(fracN[0]);
    int denN = Integer.parseInt(fracN[1]);

    // Calculate the product of x * n
    int productNumerator = numX * numN;
    int productDenominator = denX * denN;

    // Simplify the product fraction
    int gcd = gcd(productNumerator, productDenominator);

    // If the simplified denominator is 1, then it is a whole number
    return productDenominator / gcd == 1;
}

// Helper method to calculate the greatest common divisor
private static int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}","    }
    public static void main(String[] args) {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / ordenarlos en base a su índice en la lista de matrices original.     / Nota: si hay varios elementos con una suma similar de sus dígitos,     / en orden ascendente de acuerdo con la suma de sus dígitos.     / Escriba una función que ordena la lista de números enteros de la matriz dada     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l))))
    // (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))
    // >>> orderByPoints((new ArrayList<Long>(Arrays.asList())))
    // (new ArrayList<Long>(Arrays.asList()))
    public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {
","import java.util.*;

public class Problem {
    public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {
        return nums.stream()
            .sorted(Comparator.comparingLong(Problem::sumOfDigits).thenComparingLong(nums::indexOf))
            .collect(Collectors.toCollection(ArrayList::new));
    }

    private static long sumOfDigits(Long num) {
        num = Math.abs(num);
        long sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }

    public static void main(String[] args) {
        ArrayList<Long> list1 = new ArrayList<>(Arrays.asList(1L, 11L, -1L, -11L, -12L));
        ArrayList<Long> result1 = orderByPoints(list1);
        System.out.println(result1);

        ArrayList<Long> list2 = new ArrayList<>();
        ArrayList<Long> result2 = orderByPoints(list2);
        System.out.println(result2);
    }
}","    }
    public static void main(String[] args) {
    assert(orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l)))).equals((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))));
    assert(orderByPoints((new ArrayList<Long>(Arrays.asList((long)1234l, (long)423l, (long)463l, (long)145l, (long)2l, (long)423l, (long)423l, (long)53l, (long)6l, (long)37l, (long)3457l, (long)3l, (long)56l, (long)0l, (long)46l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)6l, (long)53l, (long)423l, (long)423l, (long)423l, (long)1234l, (long)145l, (long)37l, (long)46l, (long)56l, (long)463l, (long)3457l)))));
    assert(orderByPoints((new ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));
    assert(orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)-11l, (long)-32l, (long)43l, (long)54l, (long)-98l, (long)2l, (long)-3l)))).equals((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-32l, (long)-98l, (long)-11l, (long)1l, (long)2l, (long)43l, (long)54l)))));
    assert(orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l, (long)10l, (long)11l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)10l, (long)2l, (long)11l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l)))));
    assert(orderByPoints((new ArrayList<Long>(Arrays.asList((long)0l, (long)6l, (long)6l, (long)-76l, (long)-21l, (long)23l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)-76l, (long)-21l, (long)0l, (long)4l, (long)23l, (long)6l, (long)6l)))));
    }

}
"
HumanEval_146,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / los primeros y últimos dígitos de un número son impares (1, 3, 5, 7, 9).     / el número de elementos en la lista de array array que son mayores a 10 y ambos     / Escriba una función que tome una lista de números de matriz como entrada y devuelva     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l))))
    // (1l)
    // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l))))
    // (2l)
    public static long specialFilter(ArrayList<Long> nums) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    // Function to check if a number has odd first and last digits
    private static boolean hasOddFirstAndLastDigit(long num) {
        num = Math.abs(num); // Consider absolute value to handle negative numbers

        String numStr = Long.toString(num);

        // Check first digit
        char firstDigit = numStr.charAt(0);
        if ((firstDigit - '0') % 2 == 0) {
            return false;
        }

        // Check last digit
        char lastDigit = numStr.charAt(numStr.length() - 1);
        return (lastDigit - '0') % 2 != 0;
    }

    public static long specialFilter(ArrayList<Long> nums) {
        return nums.stream()
            .filter(num -> num > 10 && hasOddFirstAndLastDigit(num))
            .count();
    }

    public static void main(String[] args) {
        ArrayList<Long> nums1 = new ArrayList<>(Arrays.asList(15L, -73L, 14L, -15L));
        System.out.println(specialFilter(nums1)); // Output: 1

        ArrayList<Long> nums2 = new ArrayList<>(Arrays.asList(33L, -2L, -3L, 45L, 21L, 109L));
        System.out.println(specialFilter(nums2)); // Output: 2
    }
}","    }
    public static void main(String[] args) {
    assert(specialFilter((new ArrayList<Long>(Arrays.asList((long)5l, (long)-2l, (long)1l, (long)-5l)))) == (0l));
    assert(specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l)))) == (1l));
    assert(specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l)))) == (2l));
    assert(specialFilter((new ArrayList<Long>(Arrays.asList((long)43l, (long)-12l, (long)93l, (long)125l, (long)121l, (long)109l)))) == (4l));
    assert(specialFilter((new ArrayList<Long>(Arrays.asList((long)71l, (long)-2l, (long)-33l, (long)75l, (long)21l, (long)19l)))) == (3l));
    assert(specialFilter((new ArrayList<Long>(Arrays.asList((long)1l)))) == (0l));
    assert(specialFilter((new ArrayList<Long>(Arrays.asList()))) == (0l));
    }

}
"
HumanEval_147,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:    / y a[i] + a[j] + a[k] es un múltiplo de 3.     / Devuelve el número de triples (a[i], a[j], a[k]) de a donde i < j < k,     / Para cada i (1 ≤ i ≤ n), el valor de a[i] = i * i - i + 1.     / Se le da un número entero positivo n. Tiene que crear una lista de matrices de números enteros de longitud n.     // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    public static long getMaxTriples(long n) {
","import java.util.*;

class Problem {
    public static long getMaxTriples(long n) {
        // Generate the array list a based on the given formula
        int[] a = new int[(int) n];
        for (int i = 1; i <= n; i++) {
            a[i - 1] = i * i - i + 1;
        }
        
        long count = 0;
        
        // Iterate through triple combinations and count those whose sum is a multiple of 3
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    if ((a[i] + a[j] + a[k]) % 3 == 0) {
                        count++;
                    }
                }
            }
        }
        
        return count;
    }

    public static void main(String[] args) {
        System.out.println(getMaxTriples(5)); // Example usage
    }
}","    }
    public static void main(String[] args) {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / no son nombres de planetas correctos.     / La función debe devolver un par vacío si el planeta1 o el planeta2     / la proximidad al sol.     / situado entre la órbita del planeta1 y la órbita del planeta2, ordenado por     / La función debe devolver un par que contenga todos los planetas cuyas órbitas son     / Escriba una función que tome dos nombres de planetas como cadenas planet1 y planet2.     - Urano y Neptuno.    / es Mercurio, el siguiente es Venus, luego la Tierra, Marte, Júpiter, Saturno,     Hay ocho planetas en nuestro sistema solar: el más cercano al Sol .    // >>> bf((""Jupiter""), (""Neptune""))
    // (new ArrayList<String>(Arrays.asList((String)""Saturn"", (String)""Uranus"")))
    // >>> bf((""Earth""), (""Mercury""))
    // (ArrayList<String>(""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (new ArrayList<String>(Arrays.asList((String)""Venus"", (String)""Earth"", (String)""Mars"", (String)""Jupiter"", (String)""Saturn"")))
    public static ArrayList<String> bf(String planet1, String planet2) {
","import java.util.*;
import org.javatuples.*;

public class Problem {
    // There are eight planets in our solar system arranged by distance from the Sun
    private static final List<String> PLANETS = Arrays.asList(
            ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""
    );

    public static Pair<ArrayList<String>, ArrayList<String>> bf(String planet1, String planet2) {
        // Validate planet names
        if (!PLANETS.contains(planet1) || !PLANETS.contains(planet2)) {
            return new Pair<>(new ArrayList<>(), new ArrayList<>());
        }

        // Find indices of the planets
        int index1 = PLANETS.indexOf(planet1);
        int index2 = PLANETS.indexOf(planet2);

        // Sort the indices
        int start = Math.min(index1, index2);
        int end = Math.max(index1, index2);

        // Extract planets between the given two planets
        ArrayList<String> planetsBetween = new ArrayList<>(PLANETS.subList(start + 1, end));

        return new Pair<>(planetsBetween, new ArrayList<>());
    }
}","    }
    public static void main(String[] args) {
    assert(bf((""Jupiter""), (""Neptune"")).equals((new ArrayList<String>(Arrays.asList((String)""Saturn"", (String)""Uranus"")))));
    assert(bf((""Earth""), (""Mercury"")).equals((new ArrayList<String>(Arrays.asList((String)""Venus"")))));
    assert(bf((""Mercury""), (""Uranus"")).equals((new ArrayList<String>(Arrays.asList((String)""Venus"", (String)""Earth"", (String)""Mars"", (String)""Jupiter"", (String)""Saturn"")))));
    assert(bf((""Neptune""), (""Venus"")).equals((new ArrayList<String>(Arrays.asList((String)""Earth"", (String)""Mars"", (String)""Jupiter"", (String)""Saturn"", (String)""Uranus"")))));
    assert(bf((""Earth""), (""Earth"")).equals((new ArrayList<String>(Arrays.asList()))));
    assert(bf((""Mars""), (""Earth"")).equals((new ArrayList<String>(Arrays.asList()))));
    assert(bf((""Jupiter""), (""Makemake"")).equals((new ArrayList<String>(Arrays.asList()))));
    }

}
"
HumanEval_149,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / Puedes suponer que todas las palabras tendrán la misma longitud.     / La función debe devolver una lista de cadenas de array array en orden ordenado.     / Si dos palabras tienen la misma longitud, ordenar la lista de matrices por orden alfabético.     / debe devolver la lista de matrices ordenada por esa regla.     / El orden de la lista de matrices debe ser ascendente por la longitud de cada palabra, y usted     / y puede contener duplicados.     / La lista de array es siempre una lista de array array de cadenas y nunca una lista de array array de números,     / y devuelve la lista de matrices resultante con un orden ordenado,     / elimina las cadenas que tienen longitudes impares de ella,     / Escriba una función que acepte una lista de cadenas de array array como parámetro,     // >>> listSort((new ArrayList<String>(Arrays.asList((String)""aa"", (String)""a"", (String)""aaa""))))
    // (new ArrayList<String>(Arrays.asList((String)""aa"")))
    // >>> listSort((new ArrayList<String>(Arrays.asList((String)""ab"", (String)""a"", (String)""aaa"", (String)""cd""))))
    // (new ArrayList<String>(Arrays.asList((String)""ab"", (String)""cd"")))
    public static ArrayList<String> sortedListSum(ArrayList<String> lst) {
","import java.util.*;

class Problem {
    public static ArrayList<String> sortedListSum(ArrayList<String> lst) {
        // Remove strings with odd lengths
        lst.removeIf(s -> s.length() % 2 != 0);

        // Sort the remaining strings first by length, then alphabetically
        lst.sort(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()));

        return lst;
    }

    public static void main(String[] args) {
        ArrayList<String> test1 = new ArrayList<String>(Arrays.asList(""aa"", ""a"", ""aaa""));
        ArrayList<String> test2 = new ArrayList<String>(Arrays.asList(""ab"", ""a"", ""aaa"", ""cd""));

        System.out.println(sortedListSum(test1)); // Output: [aa]
        System.out.println(sortedListSum(test2)); // Output: [ab, cd]
    }
}","    }
    public static void main(String[] args) {
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""aa"", (String)""a"", (String)""aaa"")))).equals((new ArrayList<String>(Arrays.asList((String)""aa"")))));
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""school"", (String)""AI"", (String)""asdf"", (String)""b"")))).equals((new ArrayList<String>(Arrays.asList((String)""AI"", (String)""asdf"", (String)""school"")))));
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""d"", (String)""b"", (String)""c"", (String)""a"")))).equals((new ArrayList<String>(Arrays.asList()))));
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""d"", (String)""dcba"", (String)""abcd"", (String)""a"")))).equals((new ArrayList<String>(Arrays.asList((String)""abcd"", (String)""dcba"")))));
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""AI"", (String)""ai"", (String)""au"")))).equals((new ArrayList<String>(Arrays.asList((String)""AI"", (String)""ai"", (String)""au"")))));
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""a"", (String)""b"", (String)""b"", (String)""c"", (String)""c"", (String)""a"")))).equals((new ArrayList<String>(Arrays.asList()))));
    assert(sortedListSum((new ArrayList<String>(Arrays.asList((String)""aaaa"", (String)""bbbb"", (String)""dd"", (String)""cc"")))).equals((new ArrayList<String>(Arrays.asList((String)""cc"", (String)""dd"", (String)""aaaa"", (String)""bbbb"")))));
    }

}
"
HumanEval_150,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / un número primo y debe devolver el valor de y de lo contrario.     / Un programa simple que debe devolver el valor de x si n es     // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    public static long xOrY(long n, long x, long y) {
","import java.math.BigInteger;

public class Problem {
    public static long xOrY(long n, long x, long y) {
        // Check if n is prime
        if (isPrime(n)) {
            return x;
        } else {
            return y;
        }
    }

    private static boolean isPrime(long n) {
        if (n < 2) return false;
        if (n == 2 || n == 3) return true;
        if (n % 2 == 0) return false;

        for (long i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(xOrY(7L, 34L, 12L));  // Output: 34
        System.out.println(xOrY(15L, 8L, 5L));  // Output: 5
    }
}","    }
    public static void main(String[] args) {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / en la lista de matrices que son impares. Ignorar los números que son negativos o no enteros.     / Dado una matriz matriz lista de números, devuelve la suma de los cuadrados de los números     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)0l))))
    // (10l)
    // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)-1l, (long)-2l, (long)0l))))
    // (0l)
    // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)9l, (long)-2l))))
    // (81l)
    // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)0l))))
    // (0l)
    // If the input array list is empty, return 0.
    public static long doubleTheDifference(ArrayList<Float> lst) {
","import java.util.ArrayList;

class Problem {
    public static long doubleTheDifference(ArrayList<Float> lst) {
        long sum = 0;
        
        for (Float number : lst) {
            if (number != null && number >= 0 && number % 1 == 0) {
                long num = number.longValue();
                if (num % 2 != 0) {
                    sum += num * num;
                }
            }
        }
        
        return sum;
    }
}","    }
    public static void main(String[] args) {
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList()))) == (0l));
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList((float)5.0f, (float)4.0f)))) == (25l));
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList((float)0.1f, (float)0.2f, (float)0.3f)))) == (0l));
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList((float)-10.0f, (float)-20.0f, (float)-30.0f)))) == (0l));
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList((float)-1.0f, (float)-2.0f, (float)8.0f)))) == (0l));
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList((float)0.2f, (float)3.0f, (float)5.0f)))) == (34l));
    assert(doubleTheDifference((new ArrayList<Float>(Arrays.asList((float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f)))) == (165l));
    }

}
"
HumanEval_152,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / ejemplo:     / el valor es 0, y si no es así, el valor es la diferencia absoluta entre la suposición y la puntuación.     / Devuelve una lista de array array de la misma longitud que denota qué tan lejos estaba cada suposición.    / Se le dan dos listas de matrices de puntuaciones y conjeturas de igual longitud, donde cada índice muestra una coincidencia.     / Su tarea es determinar si una persona adivinó correctamente los resultados de un número de partidos.     / Definitivamente vale la pena anotar y comparar.     Los sentimientos y pensamientos que tienes en ese momento son los que te hacen sentir feliz.    Creo que todos recordamos ese sentimiento cuando el resultado de algo tan esperado    // >>> compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l))))
    // (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))
    // >>> compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)5l, (long)0l, (long)0l, (long)0l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l, (long)0l, (long)-2l))))
    // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)1l, (long)0l, (long)0l, (long)6l)))
    public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {
","import java.util.ArrayList;
import java.util.Arrays;

public class Problem {
    public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {
        ArrayList<Long> result = new ArrayList<>();
        for (int i = 0; i < game.size(); i++) {
            result.add(Math.abs(game.get(i) - guess.get(i)));
        }
        return result;
    }

    public static void main(String[] args) {
        ArrayList<Long> game1 = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 4L, 5L, 1L));
        ArrayList<Long> guess1 = new ArrayList<>(Arrays.asList(1L, 2L, 3L, 4L, 2L, -2L));
        System.out.println(compare(game1, guess1));

        ArrayList<Long> game2 = new ArrayList<>(Arrays.asList(0L, 5L, 0L, 0L, 0L, 4L));
        ArrayList<Long> guess2 = new ArrayList<>(Arrays.asList(4L, 1L, 1L, 0L, 0L, -2L));
        System.out.println(compare(game2, guess2));
    }
}","    }
    public static void main(String[] args) {
    assert(compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))));
    assert(compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)0l, (long)0l))), (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)0l, (long)0l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)0l, (long)0l)))));
    assert(compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l)))));
    assert(compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)0l, (long)0l, (long)1l)))));
    }

}
"
HumanEval_153,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / (su fuerza es -1).     / devuelve ""Slices.SErviNGSliCes"" ya que ""SErviNGSliCes"" es la extensión más fuerte     / extensiones: ['SErviNGSliCes', 'Cheese', 'StuFfed'] entonces usted debería     / Por ejemplo, si se le da ""Slices"" como la clase y una lista de array array de la     / elegir el que viene primero en la lista de matrices.     Si hay dos o más extensiones con la misma fuerza, debe    / formato: Nombre de clase. Nombre de extensión más fuerte.     / Debes encontrar la extensión más fuerte y devolver una cadena en esta     / en el nombre de la extensión, la fuerza se da por la fracción CAP - SM.     / letras en el nombre de la extensión, y que SM sea el número de letras minúsculas     / la fuerza de la extensión es la siguiente: Sepa CAP el número de la mayúscula     / Las extensiones se utilizan para cargar clases adicionales a la clase.    / Se le dará el nombre de una clase (una cadena) y una lista de extensiones de array array.     // >>> StrongestExtension((""my_class""), (new ArrayList<String>(Arrays.asList((String)""AA"", (String)""Be"", (String)""CC""))))
    // (""my_class.AA"")
    public static String StrongestExtension(String class_name, ArrayList<String> extensions) {
","public static String StrongestExtension(String class_name, ArrayList<String> extensions) {
        String strongestExtension = """";
        double maxStrength = Double.NEGATIVE_INFINITY;

        for (String extension : extensions) {
            int capCount = 0;
            int smCount = 0;

            for (char c : extension.toCharArray()) {
                if (Character.isUpperCase(c)) {
                    capCount++;
                } else if (Character.isLowerCase(c)) {
                    smCount++;
                }
            }

            double strength = capCount - smCount;

            if (strength > maxStrength) {
                maxStrength = strength;
                strongestExtension = extension;
            }
        }

        return class_name + ""."" + strongestExtension;
    }
}","    }
    public static void main(String[] args) {
    assert(StrongestExtension((""Watashi""), (new ArrayList<String>(Arrays.asList((String)""tEN"", (String)""niNE"", (String)""eIGHt8OKe"")))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (new ArrayList<String>(Arrays.asList((String)""nani"", (String)""NazeDa"", (String)""YEs.WeCaNe"", (String)""32145tggg"")))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (new ArrayList<String>(Arrays.asList((String)""t"", (String)""eMptY"", (String)""nothing"", (String)""zeR00"", (String)""NuLl__"", (String)""123NoooneB321"")))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (new ArrayList<String>(Arrays.asList((String)""Ta"", (String)""TAR"", (String)""t234An"", (String)""cosSo"")))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (new ArrayList<String>(Arrays.asList((String)""Tab"", (String)""123"", (String)""781345"", (String)""-_-"")))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (new ArrayList<String>(Arrays.asList((String)""HhAas"", (String)""okIWILL123"", (String)""WorkOut"", (String)""Fails"", (String)""-_-"")))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (new ArrayList<String>(Arrays.asList((String)""Die"", (String)""NowW"", (String)""Wow"", (String)""WoW"")))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (new ArrayList<String>(Arrays.asList((String)""Bb"", (String)""91245"")))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (new ArrayList<String>(Arrays.asList((String)""671235"", (String)""Bb"")))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Se le dan 2 palabras. Usted necesita devolver verdad si la segunda palabra o cualquiera de sus rotaciones es una subcadena en la primera palabra     // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    public static boolean cycpatternCheck(String a, String b) {
","public static boolean cycpatternCheck(String a, String b) {
        if (b.length() > a.length()) {
            return false;
        }
        
        String doubledB = b + b;
        
        for (int i = 0; i < b.length(); i++) {
            String rotation = doubledB.substring(i, i + b.length());
            if (a.contains(rotation)) {
                return true;
            }
        }
        
        return false;
    }
}","    }
    public static void main(String[] args) {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     / Dado un número entero. devuelve un par que tiene el número de dígitos pares e impares respectivamente.     // >>> evenOddCount((-12l))
    // (Pair.with(1l, 1l))
    // >>> evenOddCount((123l))
    // (Pair.with(1l, 2l))
    public static Pair<Long, Long> evenOddCount(long num) {
","long evenCount = 0;
        long oddCount = 0;
        num = Math.abs(num); // Handle negative numbers by taking the absolute value

        while (num > 0) {
            long digit = num % 10;
            if (digit % 2 == 0) {
                evenCount++;
            } else {
                oddCount++;
            }
            num /= 10;
        }

        return Pair.with(evenCount, oddCount);
    }

    public static void main(String[] args) {
        System.out.println(evenOddCount(-12L)); // Output: (1, 1)
        System.out.println(evenOddCount(123L)); // Output: (1, 2)
    }
}","    }
    public static void main(String[] args) {
    assert(evenOddCount((7l)).equals((Pair.with(0l, 1l))));
    assert(evenOddCount((-78l)).equals((Pair.with(1l, 1l))));
    assert(evenOddCount((3452l)).equals((Pair.with(2l, 2l))));
    assert(evenOddCount((346211l)).equals((Pair.with(3l, 3l))));
    assert(evenOddCount((-345821l)).equals((Pair.with(3l, 3l))));
    assert(evenOddCount((-2l)).equals((Pair.with(1l, 0l))));
    assert(evenOddCount((-45347l)).equals((Pair.with(2l, 3l))));
    assert(evenOddCount((0l)).equals((Pair.with(1l, 0l))));
    }

}
"
HumanEval_156,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos:     / Restricciones: 1 <= num <= 1000     / y devolverlo en minúsculas.     / Dado un entero positivo, obtenga su equivalente numérico romano como una cadena,     // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    public static String intToMiniRoman(long number) {
","String[] thousands = {"""", ""m""};
        String[] hundreds = {"""", ""c"", ""cc"", ""ccc"", ""cd"", ""d"", ""dc"", ""dcc"", ""dccc"", ""cm""};
        String[] tens = {"""", ""x"", ""xx"", ""xxx"", ""xl"", ""l"", ""lx"", ""lxx"", ""lxxx"", ""xc""};
        String[] units = {"""", ""i"", ""ii"", ""iii"", ""iv"", ""v"", ""vi"", ""vii"", ""viii"", ""ix""};
        
        String roman = """";

        roman += thousands[(int)(number / 1000)];
        number %= 1000;
        
        roman += hundreds[(int)(number / 100)];
        number %= 100;
        
        roman += tens[(int)(number / 10)];
        number %= 10;
        
        roman += units[(int)(number)];
        
        return roman;
    }
}","    }
    public static void main(String[] args) {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     - 90 grados.    Un triángulo rectángulo es un triángulo en el que un ángulo es recto o     / los lados forman un triángulo rectángulo, falso de lo contrario.     / Dadas las longitudes de los tres lados de un triángulo.    // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    public static boolean rightAngleTriangle(long a, long b, long c) {
","public class Problem {
    // Given the lengths of the three sides of a triangle. Return true if the three
    // sides form a right-angled triangle, false otherwise.
    public static boolean rightAngleTriangle(long a, long b, long c) {
        // Sort the sides so that c is always the largest one
        long[] sides = {a, b, c};
        Arrays.sort(sides);
        // Check the Pythagorean theorem: a^2 + b^2 == c^2
        return (sides[0] * sides[0] + sides[1] * sides[1]) == sides[2] * sides[2];
    }
}","    }
    public static void main(String[] args) {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / caracteres, devuelve el que aparece primero en orden lexicográfico.     Si varias cadenas tienen un número máximo de caracteres únicos     / La lista de matrices contiene diferentes palabras. Devuelve la palabra con el número máximo     / Escriba una función que acepte una lista de cadenas de array array.     // >>> findMax((new ArrayList<String>(Arrays.asList((String)""name"", (String)""of"", (String)""string""))))
    // (""string"")
    // >>> findMax((new ArrayList<String>(Arrays.asList((String)""name"", (String)""enam"", (String)""game""))))
    // (""enam"")
    // >>> findMax((new ArrayList<String>(Arrays.asList((String)""aaaaaaa"", (String)""bb"", (String)""cc""))))
    // (""aaaaaaa"")
    public static String findMax(ArrayList<String> words) {
","import java.util.*;

public class UniqueCharacterFinder {

    public static String findMax(ArrayList<String> words) {
        String maxWord = """";
        int maxUniqueCount = 0;

        for (String word : words) {
            int uniqueCount = (int) word.chars().distinct().count();
            if (uniqueCount > maxUniqueCount || (uniqueCount == maxUniqueCount && word.compareTo(maxWord) < 0)) {
                maxUniqueCount = uniqueCount;
                maxWord = word;
            }
        }

        return maxWord;
    }

    public static void main(String[] args) {
        System.out.println(findMax(new ArrayList<>(Arrays.asList(""name"", ""of"", ""string"")))); // Output: ""string""
        System.out.println(findMax(new ArrayList<>(Arrays.asList(""name"", ""enam"", ""game"")))); // Output: ""enam""
        System.out.println(findMax(new ArrayList<>(Arrays.asList(""aaaaaaa"", ""bb"", ""cc"")))); // Output: ""aaaaaaa""
    }
}","    }
    public static void main(String[] args) {
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""name"", (String)""of"", (String)""string"")))).equals((""string"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""name"", (String)""enam"", (String)""game"")))).equals((""enam"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""aaaaaaa"", (String)""bb"", (String)""cc"")))).equals((""aaaaaaa"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""abc"", (String)""cba"")))).equals((""abc"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""play"", (String)""this"", (String)""game"", (String)""of"", (String)""footbott"")))).equals((""footbott"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""we"", (String)""are"", (String)""gonna"", (String)""rock"")))).equals((""gonna"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""we"", (String)""are"", (String)""a"", (String)""mad"", (String)""nation"")))).equals((""nation"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""this"", (String)""is"", (String)""a"", (String)""prrk"")))).equals((""this"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""b"")))).equals((""b"")));
    assert(findMax((new ArrayList<String>(Arrays.asList((String)""play"", (String)""play"", (String)""play"")))).equals((""play"")));
    }

}
"
HumanEval_159,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplo:     Si no hay suficientes zanahorias, comerás todas las zanahorias, pero aún así tendrás hambre.    / el número de zanahorias que quedan después de las comidas ]     / debe devolver una lista de [número total de zanahorias consumidas después de las comidas,     Pero ahora necesitas comer más zanahorias para completar las comidas del día.    Eres un conejo hambriento, y ya has comido una cierta cantidad de zanahorias,    // >>> eat((5l), (6l), (10l))
    // (new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))
    // >>> eat((4l), (8l), (9l))
    // (new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))
    // >>> eat((1l), (10l), (10l))
    // (new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))
    // >>> eat((2l), (11l), (5l))
    // (new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    public static ArrayList<Long> eat(long number, long need, long remaining) {
","import java.util.ArrayList;
import java.util.Arrays;

class Problem {
    public static ArrayList<Long> eat(long number, long need, long remaining) {
        long totalEaten = number;
        long carrotsToEat = Math.min(need, remaining);
        totalEaten += carrotsToEat;
        long carrotsLeft = remaining - carrotsToEat;
        
        return new ArrayList<Long>(Arrays.asList(totalEaten, carrotsLeft));
    }
}","    }
    public static void main(String[] args) {
    assert(eat((5l), (6l), (10l)).equals((new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))));
    assert(eat((4l), (8l), (9l)).equals((new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))));
    assert(eat((1l), (10l), (10l)).equals((new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))));
    assert(eat((2l), (11l), (5l)).equals((new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))));
    assert(eat((4l), (5l), (7l)).equals((new ArrayList<Long>(Arrays.asList((long)9l, (long)2l)))));
    assert(eat((4l), (5l), (1l)).equals((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l)))));
    }

}
"
HumanEval_160,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / La lista de matrices de operadores tiene al menos un operador, y la lista de matrices de operandos tiene al menos dos operandos.     / Operando es una lista de matrices de matrices de enteros no negativos.     / La longitud de la lista de matrices de operadores es igual a la longitud de la lista de matrices de operandos menos uno.     / Nota:     / => resultado = 9     / resultado = 2 + 3 * 4 - 5     / lista de array array = [2, 3, 4, 5]     / operador ['+', '*', '-']     / Ejemplo:     / Exposición exponencial (**)     / División de piso ( //)     / Multiplicación (*)     / Sustracción ( - )     / Adición ( +)     Las operaciones básicas de álgebra:    / expresión y devuelve la evaluación de esta expresión.     / la segunda lista de matrices es una lista de matrices de números enteros. Utilice las dos listas de matrices dadas para construir el álgebra     / Dado dos listas de matrices operador y operando. La primera lista de matrices tiene operaciones básicas de álgebra, y     public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {
","import java.util.ArrayList;

class Problem {
    public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {
        if (operand.isEmpty() || op.isEmpty() || operand.size() - 1 != op.size()) {
            throw new IllegalArgumentException(""Invalid input."");
        }

        // Start with the first operand.
        long result = operand.get(0);

        // Apply the operators in sequence.
        for (int i = 0; i < op.size(); i++) {
            String operator = op.get(i);
            long nextOperand = operand.get(i + 1);

            switch (operator) {
                case ""+"":
                    result += nextOperand;
                    break;
                case ""-"":
                    result -= nextOperand;
                    break;
                case ""*"":
                    result *= nextOperand;
                    break;
                case ""//"":
                    if (nextOperand == 0) {
                        throw new ArithmeticException(""Division by zero."");
                    }
                    result /= nextOperand;
                    break;
                case ""**"":
                    result = (long) Math.pow(result, nextOperand);
                    break;
                default:
                    throw new IllegalArgumentException(""Invalid operator: "" + operator);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        ArrayList<String> operators = new ArrayList<>();
        operators.add(""+"");
        operators.add(""*"");
        operators.add(""-"");

        ArrayList<Long> operands = new ArrayList<>();
        operands.add(2L);
        operands.add(3L);
        operands.add(4L);
        operands.add(5L);

        System.out.println(doAlgebra(operators, operands));  // Output: 9
    }
}","    }
    public static void main(String[] args) {
    assert(doAlgebra((new ArrayList<String>(Arrays.asList((String)""**"", (String)""*"", (String)""+""))), (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)5l)))) == (37l));
    assert(doAlgebra((new ArrayList<String>(Arrays.asList((String)""+"", (String)""*"", (String)""-""))), (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)5l)))) == (9l));
    assert(doAlgebra((new ArrayList<String>(Arrays.asList((String)""//"", (String)""*""))), (new ArrayList<Long>(Arrays.asList((long)7l, (long)3l, (long)4l)))) == (8l));
    }

}
"
HumanEval_161,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Ejemplos     / La función debe devolver la cadena resultante.     / Si la cadena no contiene letras, invierta la cadena.     / de lo contrario mantenerlo como está.     / si s[i] es una letra, invierta su caso de inferior a superior o viceversa,     - Se te da una cadena de s.    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    public static String solve(String s) {
","public static String solve(String s) {
        boolean hasLetters = false;
        StringBuilder result = new StringBuilder();
        
        // Check if the string contains any letters and process the string
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isLetter(c)) {
                hasLetters = true;
                if (Character.isUpperCase(c)) {
                    result.append(Character.toLowerCase(c));
                } else {
                    result.append(Character.toUpperCase(c));
                }
            } else {
                result.append(c);
            }
        }
        
        // If no letters are present, reverse the string
        if (!hasLetters) {
            result.reverse();
        }
        
        return result.toString();
    }
}","    }
    public static void main(String[] args) {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    / Si 'text' es una cadena vacía, devuelve null.     / Dado una cadena 'text', devuelve su cadena equivalente de hash md5.     // >>> stringToMd5((""Hello world""))
    // Optional.of(""3e25960a79dbc69b674cd4ec67a72c62"")
    public static Optional<String> stringToMd5(String text) {
","import java.security.*;
import java.util.*;

class Problem {
    public static Optional<String> stringToMd5(String text) {
        if (text.isEmpty()) {
            return Optional.empty();
        }
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] messageDigest = md.digest(text.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : messageDigest) {
                sb.append(String.format(""%02x"", b));
            }
            return Optional.of(sb.toString());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return Optional.empty();
        }
    }
}","    }
    public static void main(String[] args) {
    assert(stringToMd5((""Hello world"")).equals(Optional.of(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(Optional.empty()));
    assert(stringToMd5((""A B C"")).equals(Optional.of(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Optional.of(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,spa_Latn,java,"import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    Por ejemplo:    / y b, en orden ascendente.     / Dado dos enteros positivos a y b, devuelve los dígitos pares entre a     // >>> generateIntegers((2l), (8l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))
    // >>> generateIntegers((8l), (2l))
    // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))
    // >>> generateIntegers((10l), (14l))
    // (new ArrayList<Long>(Arrays.asList()))
    public static ArrayList<Long> generateIntegers(long a, long b) {
","import java.util.*;

public class Problem {
    // Given two positive integers a and b, return the even digits between a
    // and b, in ascending order.
    public static ArrayList<Long> generateIntegers(long a, long b) {
        ArrayList<Long> result = new ArrayList<>();

        // Ensure a is the smaller number and b is the larger number
        long start = Math.min(a, b);
        long end = Math.max(a, b);

        // Find and add even numbers in the range [start, end] to the result list
        for (long i = start; i <= end; i++) {
            if (i % 2 == 0) {
                result.add(i);
            }
        }
        
        return result;
    }

    public static void main(String[] args) {
        System.out.println(generateIntegers(2, 8)); // [2, 4, 6, 8]
        System.out.println(generateIntegers(8, 2)); // [2, 4, 6, 8]
        System.out.println(generateIntegers(10, 14)); // []
    }
}","    }
    public static void main(String[] args) {
    assert(generateIntegers((2l), (10l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))));
    assert(generateIntegers((10l), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))));
    assert(generateIntegers((132l), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))));
    assert(generateIntegers((17l), (89l)).equals((new ArrayList<Long>(Arrays.asList()))));
    }

}
"
