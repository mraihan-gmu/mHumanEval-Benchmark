task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,fao_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Kanningar vísa, at tvey tøl eru tættari at hvørjum øðrum enn tað, sum er ávíst í talgilda talgilda listanum.""""""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,fao_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Input til hetta function er ein stringa, sum inniheldur fleiri bólkar av nested parentesum. Tykkara mál er at skilja hesar bólkar í hvør sær stringar og lata listan av teimum. Separate bólkar eru balanced (eitt hvørt opið parentes er rætt stongt) og ikki nested innan hvørt annað Ignorera øll leikir í inndata stringini. Dømi: >>> separate_paren_groups' ((()) (() ((()))) ' ['() ', '(()) ', '(() ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,fao_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Gevnum einum positivum floating point tali, kann tað verða niðurbrotin í eina og eina heil tøl (størsta heil tøl, sum er minni enn givin tøl) og desimal tøl (leivdartøl, sum altíð er minni enn 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,fao_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Tú fært ein lista við inn- og útgjaldaviðgerðum á eini bankakontu, sum byrjar við null í verandi saldo. Tín uppgáva er at finna út av, um í onkrum føri kontusaldurin á kontuni fellur undir null, og tá skal funkan geva sannleika aftur. Annars skal hon geva falskt aftur. Dømi: >>> below_zero([1, 2, 3]) Falskt >>> below_zero([1, 2, -4, 5]) Sanniligt """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,fao_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Fyri ein givan lista við inngangstølum, rokna miðal absolut fráfall kring miðaltalið av hesum dátubólki. miðal absolut fráfall er miðal absolut munurin millum hvørt element og eitt miðpunkt (miðal í hesum føri): MAD = miðal. x - x_mean. Dømi: >>> miðal_absolut_frávik ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,fao_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Set eitt tal ""avmarkingarmarkið"" ímillum hvørjar tvær raðfestar síður í inngangslistanum `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,fao_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Input til hetta function er ein stringa sum umboðar fleiri bólkar fyri nested parentesir, sum eru skild frá hvørjum øðrum við rúm.""""""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,fao_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtrar ein inngangslista við stringum bert fyri stringar, sum innihalda givnar undirstringar >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,fao_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Til ein givnan lista við heilum tølum, skal ein tuple verða endurgivin, sum er ein summa og eitt produkt av øllum heilum tølum í einum lista. Tólt summa skal vera javnt við 0 og tómt produkt skal vera javnt við 1. >>> sum_produkt (([]) (0, 1) >>> sum_produkt (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,fao_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Av einum givnum lista við heilum tølum, verður ein lista við rullandi størstu elementum funnin til eina ávísa løtu í røðini. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,fao_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Finn tað stytta palindromið, sum byrjar við einari tilskilaðu streng. Algoritmi hugskotið er einfalt: - Finn longsta postfix av tilskilaðu strengini, sum er ein palindromi. - Legg til endan av strengini øvugt av einum strengprefiksi, sum kemur undan palindromiskum suffixi. >>> make_palindrome('') '' >>> make_palindrome('cat') 'catac' >>> make_palindrome('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Royn um givin strengur er ein palindromur""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,fao_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Input eru tveir stringar a og b, sum bert eru 1 og 0. Gera binær XOR á hesum inputum og geva eisini úrslitið sum ein stringa. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,fao_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Um tað eru fleiri strengi við somu longd, skal tað verða tann longsti stringin. Um tað er tómur strengi, skal tað vera tann fyrsti stringin. >>> longst([]) >>> longst(['a', 'b', 'c']) 'a' >>> longst(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,fao_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Vísur størsta felags býtið av tveimum heilum tølum a og b >>> størsti felags býtið ((3, 5) 1 >>> størsti felags býtið ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,fao_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Endurgeva lista yvir øll fororð frá tí stytta til tað longsta í inngangstringini >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,fao_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Gevur eina strenge við talum, sum eru avmarkað við rúmi, og sum byrjar frá 0 og upp til og við n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,fao_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Gevdur ein streng, finn út av hvussu nógvir serstakir teknirøðir (óansæð hvat stíl) hann er samanbygdur av >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,fao_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input til hesa funktión er ein streng, ið umboðar tónleikatónir í einum serligum ASCII-formati. Tín uppgáva er at parsa strenglista av heilum, sum samsvara við fleiri takt, sum ger. Her er ein legend: 'o' notat, síðst beats 'o' - fýra beats, síðst tveir beats, síðst fjórð beats, síðst ein beats >>> parse_music. 'o o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,fao_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Finn hvussu nógvar ferðir ein givin undirstring kann finnast í upprunaliga stringini. Tel yvirskipað dømi. >>> hvussu_mangan_ferðir('', 'a') 0 >>> hvussu_mangan_ferðir('aaa', 'a') 3 >>> hvussu_mangan_ferðir('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,fao_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Input er ein rúmliga avmarkað streng av tølum frá 'nul' til 'níggju'. Gild val eru 'nul', 'ein', 'tvey', 'trý', 'fýra', 'fimm', 'seks', 'sjey', 'eitt' og 'níggju'. Gev stringin við tølum, sum eru raðfest frá tí minsta til tað størsta >>> sort_numbers (('tríggir einir fimm') 'einir tríggir fimm' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,fao_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Av einum tilskilaðum lista við tølum (við longd í minsta lagi tvey) vel og gev tvey, sum eru tættast hvørjum øðrum, og gev tey í raðfylgi (minni tal, størri tal). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,fao_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Gevnum talslista (av minst tveimum elementum), lat eina linju umskifting til tann lista, soleiðis at tað minsta talið verður 0, og tað størsta verður 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,fao_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter givin lista við øllum python-virðum bert fyri heil tøl >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,fao_Latn,python,"

def strlen(string: str) -> int:
    """"""Vís longd á givnu strengi >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,fao_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Fyri eitt givið tal n, finn størsta talið, sum býtir n javnt, minni enn n >>> størsti býtarin ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,fao_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Endurgeva lista við primfaktorum hjá einum givnum heiltali í raðfylgju frá tí minsta til tað størsta. Hvør einstakur faktorur skal vera nevndur fleiri ferðir, sum samsvarar við, hvussu ofta hann kemur fyri í faktorisering. Input nummar skal vera javnt við vøran av øllum faktorum >>> faktorisera(8) [2, 2, 2] >>> faktorisera(25) [5, 5] >>> faktorisera(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,fao_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Av einum lista við heilum tølum, tak burtur øll tøl, sum koma fyri fleiri ferðir. Halda skipanina av tølum eftir sama hátt sum í innganginum. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,fao_Latn,python,"

def flip_case(string: str) -> str:
    """"""Fyri eina givna streng, vend smáum skriftmerki til stór og stór til smá. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,fao_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Listi yvir strengi í einari strengi >>> samansetta (([]) '' >>> samansetta ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,fao_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtrar ein inngangslista við stringum bert fyri stringum, sum byrja við einum givnum forfiksi. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,fao_Latn,python,"

def get_positive(l: list):
    """"""Gev bert jaligar tøl í listanum. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,fao_Latn,python,"

def is_prime(n):
    """"""Gev sannleika, um eitt givið tal er primt, og falskt annars. >>> er_primt(6) Falskt >>> er_primt(101) Sannleiki >>> er_primt(11) Sannleiki >>> er_primt(13441) Sannleiki >>> er_primt(61) Sannleiki >>> er_primt(4) Falskt >>> er_primt(1) Falskt """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,fao_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs eru koeffisientar hjá einum polynomi. find_zero find x soleiðis at poly(x) = 0. find_zero gevur bert nullpunkt, sjálvt um tað eru nógv. find_zero tekur bert lista xs við javnt tal av koeffisientum og størsta ikki-nullu koeffisienti, tí tað tryggjar eina loysn. >>> rundur (((find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> rundur (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Metir polynomium við koeffisientum xs í punktinum x. gevur aftur xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,fao_Latn,python,"

def sort_third(l: list):
    """"""Hesin funktiónin tekur ein lista l og gevur ein lista l' aftur, soleiðis at l' er identiskur við l í teimum indeksu, sum ikki eru deililig við trý, meðan virði hansara í teimum indeksu, sum eru deililig við trý, eru javnt við virði í teimum samsvarandi indeksu í l, men raðfest. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,fao_Latn,python,"

def unique(l: list):
    """"""Gevur upp úrgreidd einastandandi evni í einum listi >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,fao_Latn,python,"

def max_element(l: list):
    """"""Gevur størsta element í listanum. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,fao_Latn,python,"

def fizz_buzz(n: int):
    """"""Gev tølini, hvussu ofta talvurin 7 kemur fyri í heilum tølum, sum eru minni enn n, og sum eru deild við 11 ella 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,fao_Latn,python,"

def sort_even(l: list):
    """"""Hesin funktiónin tekur ein lista l og gevur ein lista l' aftur, soleiðis at l' er identiskur við l í teimum ólitu indikunum, meðan virði hansara í teimum javnu indikunum eru javnt við virði í teimum javnu indikunum hjá l, men skipað. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,fao_Latn,python,"

def encode_cyclic(s: str):
    """"""tekur sum inngangstreng, sum er koddur við encode_cyclic function. Vendur avkoddan streng. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""gevur koddaða strengi aftur eftir súkklubólkum av trimum teknum. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,fao_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib gevur eitt n-tal sum er eitt Fibonacci tal og tað er eisini primt. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,fao_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero tekur ein lista við heilum tølum sum inngang. hon gevur sannleika, um tað eru trý ymisk element í listanum, sum taka upp til null, og falskt annars. >>> triples_sum_to_zero([1, 3, 5, 0]) Falskt >>> triples_sum_to_zero[(1, 3, -2, 1]) Sanniligt >>> triples_sum_to_zero([1, 2, 3, 7]) Falskt >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) Sanniligt >>> triples_sum_to_zero[1]) Falskt """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,fao_Latn,python,"

def car_race_collision(n: int):
    """"""Hugsa tær ein veg, sum er ein fullkomiliga bein, óendaliga lang lína. n bilar koyra frá vinstru til høgru; samstundis koyra onnur hópur av n bilar frá høgru til vinstru. Tveir bilarnir byrja sera langt frá hvørjum øðrum. Allir bilar koyra við somu ferð. Tveir bilar verða sagdir at sláa saman, tá ið ein bilur, sum gongur frá vinstru til høgru, slær í ein bil, sum gongur frá høgru til vinstru. Tó eru bilarnir óendaliga fastir og sterkir; tí halda teir fram at koyra í teirra farleið, sum um teir ikki hava kolliskað. Hesin funktiónin gevur út talið av slíkum kollisjónum. """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,fao_Latn,python,"

def incr_list(l: list):
    """"""Endurgeva lista við evnum, sum eru stignir við 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,fao_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero tekur ein lista við heilum tølum sum inngang. Hon gevur sannleika, um tað eru tveir ymiskir tættir í listanum, sum taka null sum upphædd, og falskt annars. >>> pairs_sum_to_zero (([1, 3, 5, 0]) Falskt >>> pairs_sum_to_zero (([1, 3, -2, 1]) Falskt >>> pairs_sum_to_zero (([1, 2, 3, 7]) Falskt >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) Sannleiki >>> pairs_sum_to_zero (([1]) Falskt """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,fao_Latn,python,"

def change_base(x: int, base: int):
    """"""Broyt talgilda grundarlagið fyri inngangnummar x til grundarlag. Gev strengeframsýning aftur eftir umvælingina. Basunummørk eru minni enn 10. >>> broyting_grundarlag(8, 3) '22' >>> broyting_grundarlag(8, 2) '1000' >>> broyting_grundarlag(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,fao_Latn,python,"

def triangle_area(a, h):
    """"""Givin longd á síðu og høga afturvendandi øki fyri eitt trívutal. >>> triangle_area(5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,fao_Latn,python,"

def fib4(n: int):
    """"""Fib4-talvfylgjan er ein røð, sum líkist Fibbonacci-síðuni, sum er definerað soleiðis: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Vinarliga skriva eina funktión til at rokna n-ta elementin í talvfylgjuni.""""""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,fao_Latn,python,"

def median(l: list):
    """"""Endurgeva median av elementum í listanum l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,fao_Latn,python,"

def is_palindrome(text: str):
    """"""Kanning um givin strengur er ein palindrom >>> er_palindrom (('') Sannur >>> er_palindrom (('aba') Sannur >>> er_palindrom (('aaaaa') Sannur >>> er_palindrom (('zbcd') Falskur """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,fao_Latn,python,"

def modp(n: int, p: int):
    """"""Gev 2^n modul p (ver viðvitað/ur um tøl). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,fao_Latn,python,"

def encode_shift(s: str):
    """"""tekur sum inngangstreng, sum er koddur við encode_shift funktiónini. Vendur avkoddan streng. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""gevur kodda strengi aftur við at flyta hvørt stavilsi við 5 í alfabetinum.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,fao_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels er ein funktión, sum tekur strengi og gevur strengi uttan sjálvljóð. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,fao_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Gevur sannleika, um øll tøl í listanum l eru undir markinum t. >>> below_threshold (([1, 2, 4, 10], 100) Sannleiki >>> below_threshold (([1, 20, 4, 10], 5) Falskur """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,fao_Latn,python,"

def add(x: int, y: int):
    """"""Legg tvey tøl x og y saman við tvey tølum x og y, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl, sum eru tvey tøl.""""""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,fao_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Vís, um tvey orð hava somu stavir. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdddabc') Sanniligt >>> same_chars (('abcd', 'dddddddabc') Sanniligt >>> same_chars (('dddddddabc', 'abcd') Satt >>> same_chars (('eabcd', 'dddddddddabc') Falskt >>> same_chars ((('abcd', 'dddddddabddce') Falskt >>> same_chars (((abcdzzzz', 'dddzzzzdddabc') Falskt """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,fao_Latn,python,"

def fib(n: int):
    """"""Vísur n-ta Fibonacci-talið. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,fao_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets er ein streng av ""<"" og "">"". return True um hvørt opnandi parket hevur eitt samsvarandi lokandi parket. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,fao_Latn,python,"

def monotonic(l: list):
    """"""Return True er listaelementir, ið monotonliga vaksa ella minka. >>> monotonlig (([1, 2, 4, 20]) True >>> monotonlig (([1, 20, 4, 10]) False >>> monotonlig (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,fao_Latn,python,"

def common(l1: list, l2: list):
    """"""Gevur upp úrgreiddar einastandandi felags elementir fyri tveir listar. >>> felags (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> felags (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,fao_Latn,python,"

def largest_prime_factor(n: int):
    """"""Gev størstu primfaktorin av n. Rokna við at n > 1 og er ikki prim. >>> størsti_primfaktorin ((13195) 29 >>> størsti_primfaktorin ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,fao_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n er ein funktión, sum tekur tøl frá 1 til n. sum_to_n30 465 sum_to_n100 5050 sum_to_n05 15 sum_to_n10 55 sum_to_n1 1""""""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,fao_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets er ein streng av ""("" og "")"". return True um hvør opnandi brakk hevur ein samsvarandi stongjandi brakk. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() "") True >>> correct_bracketing("")""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,fao_Latn,python,"

def derivative(xs: list):
    """"""xs er ein faktorur í einum polynomi. xs[0] + xs[1] * x + xs[2] * x^2 + .... Gev avleiðing av hesum polynomi í sama formi. >>> avleiðing (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> avleiðing (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,fao_Latn,python,"

def fibfib(n: int):
    """"""FibFib talsreihurin er ein røð líknandi Fibbonacci-reihinum, sum er definerað soleiðis: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Vinarliga skriva eina funktión til at rokna n-ta elementin í talsreihinum. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,fao_Latn,python,"
FIX = """"""Skriva eina funktión vowels_count sum tekur eina strungu sum umboðar eitt orð sum inngang og gevur talið av vokum í stringini.""""""

def vowels_count(s):
    """"""Legg til fleiri royndartilburðir. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,fao_Latn,python,"
def circular_shift(x, shift):
    """"""Um tú flytur tølini í einum sirkulera x, flytur tølini til høgru við flyting og gevur úrslitið sum eina strengi. Um flyting > tal av tølum, so gevur tú tølini aftur. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,fao_Latn,python,"
def digitSum(s):
    """"""Uppgávan Skrivar eina funktión, sum tekur eina strengi sum inngang og gevur summar av teimum ovastu teknum bert' ASCII koddir. Dømi: digitSum ((("""") => 0 digitSum (((""abAB"") => 131 digitSum (((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum (((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,fao_Latn,python,"
def fruit_distribution(s,n):
    """"""Í hesi uppgávuni fært tú eina strungu, sum vísir eitt tal av eplum og appelsinum, sum eru býtt út í einari fruktkorg, sum hevur epli, appelsinir og mangóar. Gevandi strungu, sum vísir heildartøl av appelsinum og appellunum og eitt heilt tal, sum vísir heildartøl av fruktunum í kurvuni, gevur tú talið av mangóar í kurvuni. t.d. fruit_distribution""5(epli og 6 appelsinir"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 appelsinir og 1 appelsinir"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 appelsinir og 3 appelsinir"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 appelsinir og 120) "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,fao_Latn,python,"
def pluck(arr):
    """"""""Givst einari røð, sum umboðar eina grein av einum træi, sum hevur ikki-negativar heiltaliga knútar, er tín uppgáva at plukka ein av knútarunum og lata hann aftur. Tann plukkaði knøtturin skal vera tann knøtturin við minsta javna virðið. Um fleiri knøttir við sama minsta javna virðið eru funnir, lat so aftur tann knøttin, sum hevur minsta indeksið. Tann plukkaði knøtturin skal latast aftur í einum lista, [smallest_value, its index] , Um tað ikki eru javnvirðir ella givna røðin er tóm, lat so aftur []. Dømi 1: Input: [4,2,3] Output: [2, 1] Frágreiðing: 2 hevur minsta javna virðið, og 2 hevur minsta indeksið. Dømi 2: Input: [1,2,3] Output: [2, 1] Frágreiðing: 2 hevur minsta javna virðið, og 2 hevur minsta javna indeksið. Dømi 3: Input: [] Output: [4: [5,3] Input: [0, 3, 4] Output: 1 [0, 0] Output: [0, 0] Minsta knøttin hevur minsta indeksið, men tað eru tvey null, so vit velja tann minsta knøttin, sum hevur minsta nullvirðið. Dømi:""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,fao_Latn,python,"
def search(lst):
    '''Tú hevur fingið ein ikki tóman lista við positivum heilum tølum. Gev størsta heiltalið, sum er størri enn null, og hevur eina frekvens, sum er størri enn ella javnt við virði av sjálvum heiltalið. Frekvensin av einum heiltali er talið av ferðum, tað kemur fram í listanum. Um einki slíkt virði finst, gev -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,fao_Latn,python,"
def strange_sort_list(lst):
    '''Gevdur listi av heilum tølum, so kemur listi aftur í óvanligari raðfylgju. Óvanligur raðfylgjarar er tá ið tú byrjar við minsta virði, so størsta av verandi heilum tølum, so minsta og so framvegis. Dømi: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,fao_Latn,python,"
def triangle_area(a, b, c):
    '''Given the lengths of the three sides of a triangle. Returns the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise returns -1 Three sides make a valid triangle when the sum of any two sides is greater than the third side. Example: triangle_area(3, 4, 5) == 6.00 triangle_area(1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,fao_Latn,python,"
def will_it_fly(q,w):
    '''Skriva eina funktión, sum gevur True, um objekt q skal flúgva, og False annars. Objekt q skal flúgva, um tað er balanserað (tað er ein palindromur lista) og summan av elementunum er minni enn ella líka við størst møguliga vekt w. Dømi: will_it_fly([1, 2], 5) â -> False # 1+2 er minni enn størst møguliga vekt, men tað er óbalancerað. will_it_fly([3, 2, 3], 1) â -> False # tað er balanserað, men 3+2+3 er meira enn størst møguliga vekt. will_it_fly[3, 2, 3], 9) â -> True # 3+23 er minni enn størst møguliga vekt, og tað er balanserað. will_it_fly([3], â 5) -> True # 3 er minni enn størst møguliga vekt, og tað er balanserað. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,fao_Latn,python,"
def smallest_change(arr):
    """"""Tá ið ein talgreiðsla er útgjørd, er neyðugt at finna minst møguliga tal av elementum, sum skulu broytast fyri at gera talgreiðsluna palindromiska.""""""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,fao_Latn,python,"
def total_match(lst1, lst2):
    '''Skriva eina funktión, sum tekur ímóti tveimum stringum og gevur tann lista, sum hevur færri karakterir í øllum stringunum enn hin listin. Um báðir listarnir hava sama tal av karakterum, gevur tú tann fyrsta listan aftur. Dømi: total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,fao_Latn,python,"
def is_multiply_prime(a):
    """"""Skriva eina funktión, sum gevur sannleika, um tað givna talið er multiplikatiónin av 3 primnumum, og falskan annars.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,fao_Latn,python,"
def is_simple_power(x, n):
    """"""Tín uppgáva er at skriva eina funktión, sum gevur sannleika, um eitt tal x er ein einføld potens av n, og falskt í øðrum førum. x er ein einføld potens av n, um n**int=x Til dømis: er_einføld_potentia (a) (i) (i) (ii) => sannur er_einføld_potentia (i) (ii) => sannur er_einføld_potentia (i) (iii) => sannur er_einføld_potentia (i) (iii) => falskur er_einføld_potentia (i) (iii) => falskur er_einføld_potentia (i) (iii) => falskur """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,fao_Latn,python,"
def iscube(a):
    '''Skriva eina funktión, sum tekur eitt heilt tal a og gevur aftur sannleika, um hetta er ein kubus av einum heilt tali.'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,fao_Latn,python,"
def hex_key(num):
    """"""Tú hevur fingið til uppgávu at skriva eina funktión, sum tekur ímóti einum hexadecimaltal sum einari strengi og telur talið av hexadecimaltaltølum, sum eru primtøl (prímtøl, ella eitt primtøl, er eitt natúrligt tal størri enn 1, sum ikki er eitt produkt av tveimum smærri natúrligum tølum). Hexadecimaltølini eru 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prímtølini eru 2, 3, 5, 7, 11, 13, 17,... So tú mást finna eitt tal av hesum tølum: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Viðmerking: Tú kanst rokna við, at inngangurin altíð er rættur ella tómur strengi, og symbolini A,B,C,D,E,F eru altíð stórskrivað. Dømi: Fyri num = AB skal útgávurin vera num = 1. Fyri num = 1077E skal útgávurin vera 2. Fyri num = ""AB33"" skal útgávurin vera num = 4.33 ""ABC"" skal útgávurin vera num = 6.01234567 ""A"" skal útgávurin vera num = 2.2020 EFD""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,fao_Latn,python,"
def decimal_to_binary(decimal):
    """"""Tær verða givnar eitt tal í tíggjaldarformati og tín uppgáva er at umskapa tað til binary format. Funktiónin skal geva eina strengi, har hvør stavur umboðar eitt binary tal. Hvør stavur í stringini verður '0' ella '1'. Tað verður eitt par eyka stavir 'db' í byrjanini og í endanum av stringini.""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,fao_Latn,python,"
def is_happy(s):
    """"""Tú hevur eina strengi s. Tín uppgáva er at kanna, um stringin er happy ella ikki. Ein stringa er happy, um longdin er í minsta lagi 3 og hvørjir 3 letrarnir eru ymiskir.""""""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,fao_Latn,python,"
def numerical_letter_grade(grades):
    """"""Tað er seinasta vikuna í lestrarhálvuni, og lærarin skal geva næmingunum karakterir. Lærarin hevur gjørt sína egnu algoritmu til at meta. Einasti trupulleikin er, at hon hevur mist koduna, hon brúkti til at meta. Hon hevur givið tær ein lista við GPA fyri nakrar næmingar, og tú skalt skriva eina funktión, sum kann geva út ein lista við bókstavsgreinum við at nýta hesa tabell: GPA. Bókstavsgrein 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (..)""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,fao_Latn,python,"
def prime_length(string):
    """"""Skriva eina funktión, sum tekur eina strengi og gevur aftur True, um strengi er eitt primtal ella False annars. Dømi prime_length{'Hello') == True prime_length{'abcdcba') == True prime_length{'kittens') == True prime_length{'orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,fao_Latn,python,"
def starts_one_ends(n):
    """"""Gevið eitt jaligt heilt tal n, gevur tal av tølum av n-siffrum jaligum heilt talum, sum byrja ella enda við 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,fao_Latn,python,"
def solve(N):
    """"""Um N = 1000, verður talið av talvum 1 og útgangsstøðið skal vera ""1"". Um N = 150, verður talið av talvum 6 og útgangsstøðið skal vera ""110"". Um N = 147, verður talið av talvum 12 og útgangsstøðið skal vera ""1100"".""""""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,fao_Latn,python,"
def add(lst):
    """"""Gevdur ein ikki tóman lista við heilum tølum, leggur tú tættar tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir tættir""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,fao_Latn,python,"
def anti_shuffle(s):
    """"""Skrivið eina funktión, sum tekur eina strengi og gevur eina raðfestna útgávu av henni. Raðfestna útgávan av strengi er ein strengi, har øll orð (skilin sundur við plássi) verða skift út við eitt nýtt orð, har allir stavirnir eru raðfestir í uppstigandi raðfylgi, grundað á ascii virði. Gev gætur: Tú skalt halda raðfylgin av orðum og leysum plássum í setninginum. T.d. anti_shuffle ((('Hi') gevur 'Hi' anti_shuffle ((('hello') gevur 'ehllo' anti_shuffle (('Hello World!!!') gevur 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,fao_Latn,python,"
def get_row(lst, x):
    """"""Tú hevur fingið eitt tvívídimensional data, sum er ein nested list, sum líkist matrix, tó, ólíkt matrisum, kann hvør røð innihalda eitt annað tal av stólpum. Gevst lst, og heiltali x, finn heiltøl x í listanum, og gev list av tuples, [(x1, y1), (x2, y2) ...] soleiðis at hvør tuple er ein koordinati - (røð, stólpar), byrjað við 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,fao_Latn,python,"
def sort_array(array):
    """"""Gev einari røð av ikki-negativum heilum tølum, send eitt avrit av tí givnu røðini eftir at hava sorterað, so skal tú sortera ta givnu røðina í uppgongdarsvari, um summan ((fyrsta indekstvirði, seinasta indekstvirði) er ólíkt, ella sortera hana í fallandi rað, um summan ((fyrsta indekstvirði, seinasta indekstvirði) er javnt.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,fao_Latn,python,"
def encrypt(s):
    """"""Skapa eitt function encrypt sum tekur ein streng sum argument og gevur eina strengi aftur, sum er krypterað við at rotera alfabetið. alfabetið skal roterast soleiðis, at bókstavirnir flyta seg niður við tveimum, sum verða fleirfaldaðir til tvey pláss. t.d. encrypt (('hi') gevur 'lm' encrypt (('asdfghjkl') gevur 'ewhjklnop' encrypt (('gf') gevur 'kj' encrypt (('et') gevur 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,fao_Latn,python,"
def next_smallest(lst):
    """"""Tú hevur fingið ein lista við heilum tølum. Skriva eina funktión next_smallest (() sum gevur tað næstminstu elementin á listanum. Gevur null aftur, um einki slíkt element er. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Eingin next_smallest (([1, 1]) == Eingin """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,fao_Latn,python,"
def is_bored(S):
    """"""Tú fært eina røð av orðum, og tín uppgáva er at telja, hvussu nógv orð tú ert troytt av. Eitt orð, sum er troytt av, er ein setning, sum byrjar við orðinum ""I"". Setningar eru avmarkaðar við '.', '?' ella '!'. T.d.: >>> er_troyttur (i) ""Hello world"") 0 >>> er_troyttur (i) ""Himmalin er bláur. Sólin skínur. Eg elski hetta veðrið"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,fao_Latn,python,"
def any_int(x, y, z):
    '''Skapa eina funktión, sum tekur 3 tøl. Gevur sann, um eitt av tølunum er javnt sum uppsjóvartalið av hinum báðum, og øll tølini eru heil tøl. Gevur ósann í øllum øðrum førum. Dømi:'''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,fao_Latn,python,"
def encode(message):
    """"""Skriva eina funktión, sum tekur ein boðskap, og kodar soleiðis, at hon skiftir case av øllum bókstavum, skiftir allar vokalur í boðskapinum við bókstav, sum er 2 pláss frammanfyri tann vokalin í enska alfabetinum.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,fao_Latn,python,"

def skjkasdkd(lst):
    """"""Tú fært ein lista við heilum tølum. Tú skalt finna størsta prim-virðið og lata summar av tí nummarinum. Dømi: Fyri lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] skal útgávuna vera 10 Fyri lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] skal útgávuna vera 25 Fyri lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] skal útgávuna vera 13 Fyri lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] skal útgávuna vera 11 Fyri lst = [0,81,12,31,21] skal útgávuna vera 3 Fyri lst = [0,1,8,2,1,7] skal útgávuna vera 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,fao_Latn,python,"
def check_dict_case(dict):
    """"""Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, otherwise return False. Funktiónin skal geva False, tá ið givin orðabók er tóm. Dømi: check_dict_case{""a"":""apple"", ""b"":""banana""}) skal geva True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) skal geva False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) skal geva False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) skal geva False. check_dict_case{""NC"":""STATE"", ""Z"":""IP""}) skal geva True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,fao_Latn,python,"
def count_up_to(n):
    """"""Set í verk eina funktión, sum tekur eitt ikki-negativt heiltal og gevur eina matris av teimum fyrstu n heiltølunum, sum eru primtøl og minni enn n. t.d.: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,fao_Latn,python,"
def multiply(a, b):
    """"""Uppfylla funktiónina, sum tekur tvey heiltøl og gevur vøru av teirra eindatølum.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,fao_Latn,python,"
def count_upper(s):
    """"""T.d. count_upper (('aBCdEf') gevur 1 count_upper (('abcdefg') gevur 0 count_upper (('dBBE') gevur 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,fao_Latn,python,"
def closest_integer(value):
    '''Skapa eina funktión, sum tekur eitt virði (string) sum umboðar eitt tal og gevur tað tættasta heiltalið aftur. Um talið er líka langt frá tveimum heiltølum, so rundar tú tað burtur frá null. Dømi >>> nærmastu_alltøl ((""10"") 10 >>> nærmastu_alltøl ((""15.3"") 15 At rundar burtur frá null merkir, at um tað givna talið er líka langt frá tveimum heiltølum, so er tað tað, sum er longst burtur frá null, tú skalt lata aftur. Til dømis eigur nærmastu_alltøl "" ((14.5"") at geva aftur 15 og nærmastu_alltøl "" ((-14.5"") at geva aftur -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,fao_Latn,python,"
def make_a_pile(n):
    """"""Given a positive integer n, you have to make a pile of n levels of stones. Fyrsta stigið hevur n steinar. Talið av steinum í næsta stigi er: - næsta ólíkt tal, um n er ólíkt. - næsta javnt tal, um n er javnt. Gev talið av steinum í hvørjum stigi í einum lista, har elementur við indeksi i umboðar talið av steinum í stigi (i+1). Dømi: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,fao_Latn,python,"
def words_string(s):
    """"""Tú fært eina strenge av orðum, sum eru skilin sundur við komma ella rúm. Tín uppgáva er at býta strengen í orð og geva eina røð av orðunum. T.d.: words_string ((""Hej, mítt navn er John"") == [""Hej"", ""mín"", ""navn"", ""er"", ""John""] words_string ((""Ein, tveir, tríggir, fýra, fimm, seks"") == [""Ein"", ""tvey"", ""tríggir"", ""fýra"", ""fimm"", ""seks""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,fao_Latn,python,"
def choose_num(x, y):
    """"""Henda funktión tekur tvey positivar tøl x og y og gevur størsta javna heilt tal, sum er í rásini [x, y] inklusivt. Um tað ikki er eitt slíkt tal, so skal funktiónin geva -1.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,fao_Latn,python,"
def rounded_avg(n, m):
    """"""Tú hevur fingið tvey positivir heil tøl n og m, og tín uppgáva er at rokna miðaltalið av heil tølum frá n til m (inkluderað n og m). Runda svarið til nærmastu heil tøl og umset tað til binært tal. Um n er størri enn m, so vend aftur til -1.""""""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,fao_Latn,python,"
def unique_digits(x):
    """"""Gevur ein lista við positivum heilum tølum x. gevur ein raðfestan lista við øllum elementum, sum ikki hava nakað javnt tal.""""""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,fao_Latn,python,"
def by_length(arr):
    """"""Við einum talvi av heilum tølum, raðfest øll tølini, sum eru millum 1 og 9, vend tí úrslitinum og set so hvørt talv í staðin fyri við sínum navni frá ""Ein"", ""Tveir"", ""Trí"", ""Fyri"", ""Fyri"", ""Seks"", ""Sjey"", ""Eitt"", ""Nín"". T.d.: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> raðfest arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""Eitt"", ""Fyri"", ""Tveir"", ""Tveir"", ""Tveir"", ""Tvey"", ""Eitt"", ""Eitt""] Um talvi er tóm, send eitt talv aftur: arr = [] return [] Um talvi hevur nakað fremmant tal, ignorera tað: arr = [1, -1 , 55] -> arr -> [-1, 1, 55] -> reverse arr = [55,1] - return ['One' 1,' ]""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,fao_Latn,python,"
def f(n):
    """"""Umset funktiónina f, sum tekur n sum parametur, og gevur eina lista við støddini n, soleiðis at virðið av elementinum við indeksi i er faktoriala av i, um i er javnt, ella summan av tølunum frá 1 til i annars. i byrjar frá 1. faktoriala av i er multiplikatiónin av tølunum frá 1 til i (1 * 2 * ... * i). Dømi: f(5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,fao_Latn,python,"
def even_odd_palindrome(n):
    """"""Given a positive integer n, returns a tuple that has the number of even and odd integer palindromes that fall within the range ((1, n), inclusive. Example1: Input: 3 Output: (1, 2) Explanation: Integer palindrome are 1, 2, 3. ein teirra er javnur, og tveir teirra eru ójavnir. Example2: Input: 12 Output: (4, 6) Explanation: Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. fýra teirra eru javnir, og 6 teirra eru ójavnir. Note: 1. 1 <= n <= 10^3 2. tuple returns the number of even and odd integer palindromes respectively. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,fao_Latn,python,"
def count_nums(arr):
    """"""Skriva eina funktión count_nums sum tekur eina røð av heilum tølum og gevur tøl fyri hvussu nógv element sum hava eitt tal sum er summarið av tølum > 0. Um eitt tal er negativt, so er tað fyrsta undirskrivað tal tal tal eisini negativt: t.d. -123 hevur undirskrivað tal -1, 2 og 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,fao_Latn,python,"
def move_one_ball(arr):
    """"""Vit hava eina talvuarray 'arr' av N heilum tølum arr[1], arr[2], ..., arr[N].Tølini í talvuni verða raðfest á tilvildarligan hátt. Tín uppgáva er at finna út av, um tað er møguligt at fáa eina talvuarray raðfest í ikki-dálkandi raðfylgi við at gera hesa operatión á givnu talvuarray: Tú hevur loyvi at gera hægri-skiftingartøk eina og hvørja ferð. Ein hægri-skiftingartøk merkir at flyta øll evni í talvuni við einari støðu í røttu leið. Síðsta evni í talvuni verður flutt til útgangsstøðuna í talvuni t.e. 0th indeks. Um tað er møguligt at fáa raðfestar talvurar við at gera omanfyri nevndu gerð, so verður returns True annars returns False. Um givin talvur er tóm, so verður returns True.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,fao_Latn,python,"
def exchange(lst1, lst2):
    """"""Í hesum trupuleikanum skalt tú seta í verk eina funktión, sum tekur tveir talslistar, og avger um tað er møguligt at gera eitt skifti av elementum millum teirra fyri at gera lst1 til ein lista við bert javnum tølum. Tað er einki mark fyri talið av elementum, sum verða skift millum lst1 og lst2. Um tað er møguligt at skifta element millum lst1 og lst2 fyri at gera øll elementini í lst1 til at vera javn, so skal tú svara ""JA"". Annars skal tú svara ""NEI"". T.d.""""""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,fao_Latn,python,"
def histogram(test):
    """"""Um ein stranga er, sum umboðar eitt rúm, sum er skilt frá smáum bókstavum, skal ein orðabók verða send aftur, sum lýsir bókstav, sum er flestu ferð at koma, og sum hevur samsvarandi tal. Um fleiri bókstavir koma í sama stað, skulu øll verða send aftur.""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,fao_Latn,python,"
def reverse_delete(s,c):
    """"""Uppgávan Vit hava fingið tvær strengi s og c, tú skalt strika allar stavirnar í s, sum eru javnsettar við ein og hvønn stavin í c, og so kanna, um úrslitstrengurin er palindromur. Ein strengi verður kallað palindrom, um hon lesur sama aftur og fram. Tú skalt lata eina tupplu við úrslitstrenginum og True/False til kanningina. Dømi: Fyri s = ""abcde"", c = ""ae"", skal úrslitið vera ('bcd',False) Fyri s = ""abcdef"", c = ""b"" skal úrslitið vera ('acdef',False) Fyri s = ""abcdedcba"", c = ""ab"", skal úrslitið vera ('cdedc',True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,fao_Latn,python,"
def odd_count(lst):
    """"""Given a list of strings, where each string consists of only digits, return a list. Hvør elementur i í útgangslutinum skal vera ""talið av odd elementum í stringi i í inngangi"". har øll i'ini skulu verða skift út við talið av odd digitum í i'ta stringi í inngangi. >>> odd_count['1234567']) [""talið av odd elementum 4n str4ng 4 í 4n input.""] >>> odd_count['3',""111111""]) [""talið av odd elementum 1n str1ng 1 í 1n input."", ""talið av odd elements 8n str8ng 8 í 8n input.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,fao_Latn,python,"
def minSubArraySum(nums):
    """"""Gevst einari røð av heilum tølum, finn minst summan av einari ikki tómari undirrøð av tølum. Dømi minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,fao_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Tú hevur eitt rektangulært rásverk av brunnum. Hvør røð umboðar eina brunn, og hvør 1 í røðini umboðar eina vatnstykki. Hvør brunnur hevur eina samsvarandi spann, sum kann brúkast til at taka vatn úr, og allir spannir hava sama kapasitet. Tín uppgáva er at brúka spannirnar til at tøma brunnirnar. Útgangin er, hvussu ofta tú skalt lækka brunnirnar.""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,fao_Latn,python,"
def sort_array(arr):
    """"""Í hesum Kata, skalt tú raðfesta eina røð av ikki-negativum heilum tølum eftir tali av einum í teirra binara representatión í uppgongd.""""""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,fao_Latn,python,"
def select_words(s, n):
    """"""Gevst ein streng s og eitt náttúrligt tal n, hevur tú fingið til uppgávu at seta í verk eina funktión, sum gevur ein lista við øllum orðum frá streng s, sum innihalda júst n samljóð, fyri at hesi orðini skulu koma í streng s. Um strengurin s er tómur, so skal funkan geva eina tóma lista.""""""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,fao_Latn,python,"
def get_closest_vowel(word):
    """"""Tú hevur fingið eitt orð. Tín uppgáva er at finna tættasta vokalin, sum stendur millum tveir samljóð frá høgru síðu av orðinum (case sensitive). Vokallar í byrjan og enda telja ikki. Gev tóman streng, um tú ikki hevur funnið nakran vokal, sum lýkur treytina omanfyri. Tú kanst rokna við, at givin streng bert inniheldur enskum bókstav. Dømi: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,fao_Latn,python,"
def match_parens(lst):
    '''Tú hevur fingið ein lista við tveimum strengum, báðir strengirnir eru bert av opnum parentesum '(' ella stongdum parentesum ') '. Tín uppgáva er at kanna, um tað er møguligt at knýta báðar strengirnar saman í onkrari raðfylgju, so at úrslitið verður ein góð streng. Ein streng S verður mett at vera góð, um og bert um allar parentesurnar í S eru javnsettar. T.d. er strengurin '((())) ' góð, meðan strengurin '()) ' ikki er tað. Gev 'Yes' aftur, um tað er ein máti at gera ein góðan streng, og gev 'No' aftur, um ikki. Dømi: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,fao_Latn,python,"
def maximum(arr, k):
    """"""Given an array arr of integers and a positive integer k, return a sorted list of length k with the maximum k numbers in arr. Example1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Example2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Example3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Note: 1.""""""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,fao_Latn,python,"
def solution(lst):
    """"""Við einum ikki tómum listanum av heilum tølum, skal summan av øllum teimum ólitu tølunum, sum eru í javnum støðum, verða latin aftur.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,fao_Latn,python,"
def add_elements(arr, k):
    """"""Gevst ein ikki tóm røð av heilum tølum arr og eitt heil tøl k, so skal summarið av elementunum við í mesta lagi tveimum tølum frá teimum fyrstu k elementunum í arr, verða latin aftur. Dømi: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # summarið av 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,fao_Latn,python,"
def get_odd_collatz(n):
    """"""Tá ið ein positivur heilur talur er n, so er tað at lata ein raðfestan lista við ólíkum tølum í Collatz-seri. Collatz-uppgávuna er ein giting í matematikki, sum snýr seg um eina røð, sum er definerað soleiðis: byrja við einum og hvørjum positivum heilum talum n. Síðani verður hvør terminur tikin frá undanfarna terminum soleiðis: Um undanfarni termin er javnur, er næsti terminur ein helmingur av undanfarna terminum. Um undanfarni termin er ólíkur, er næsti terminur 3 ferðir undanfarni terminur pluss 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,fao_Latn,python,"
def valid_date(date):
    """"""Tú skalt skriva eitt funktión, sum váttar eina givna dagfestingstreng og gevur sannleika, um dagfestingin er galdandi, annars falskt. Dagfestingin er galdandi, um allar hesar reglur eru uppfyltar: 1. dagfestingin er ikki tóm. 2. dagatalið er ikki minni enn 1 ella størri enn 31 dagar fyri mánaðir 1,3,5,7,8,10,12. Og dagatalið er ikki minni enn 1 ella størri enn 30 dagar fyri mánaðir 4,6,9,11. Og dagatalið er ikki minni enn 1 ella størri enn 29 dagar fyri mánaðin 2. 3. mánaðirnar skulu ikki vera minni enn 1 ella størri enn 12. 4. dagfestingin skal vera í formati: mm-dd-yyyy-yyyy til dømis: valid_date (<br />'03-11-2000') => true_date (<br />'15-01-2012') => false valid_date (<br />'04-02040') => false_date (<br />'06-04-2020') => true (<br />'06/04/2020')""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,fao_Latn,python,"
def split_words(txt):
    '''Gevdur ein orðastringa, so skal ein lista við orðum, býtt upp í hvítvølli, verða latin aftur, um eingin hvítvølli er í tekstinum, so skal tú býta upp í komma ',' um eingin komma er, so skal tú geva aftur talið av smáum bókstavum við ólíka raðfylgju í alfabetinum, ord('a') = 0, ord'(b') = 1, ... ord('z') = 25 Dømi um split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words"")'''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,fao_Latn,python,"
def is_sorted(lst):
    '''Um tølini eru í uppstigandi raðfylgju, skal tú svara, um tey eru raðfest ella ikki. Um tølini eru fleiri enn eitt, skal tú svara Fals. Tú skalt ikki taka negativt tal og bert heiltøl.'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,fao_Latn,python,"
def intersection(interval1, interval2):
    """"""Tú hevur tvey intervall, har hvørt intervall er eitt pari av heilum tølum. T.d. intervall = (start, end) = (1, 2). Tær givnu intervallini eru stongd, sum merkir, at intervall (start, end) inniheldur bæði start og end. Fyri hvørt givið intervall verður roknað við, at starturin er minni enn ella líka við endin. Tín uppgáva er at finna út av, um longdin á skerjingini av hesum báðum intervallum er eitt primtal. Dømi: Skeringin av intervallunum (1, 3), (2, 4) er (2, 3) sum hevur longdina 1, sum ikki er eitt primtal. Um longdin á skerjingini er eitt primtal, sendur tú ""JA"", annars sendur tú ""NEI"". Um teir báðir intervallini ikki skerjast, sendir tú ""NEI"". [input/output] samplar: intersection (((1, 2), (2, 3) ==> ""intersection (-1), ==> ""intersection (-1), ==> ""intersection (-1), ==> ""intersection (-1), ==> ""intersection (-1), ==> ""intersection (-1), ==> (<0, 4) ==> ""NO"", ==> 5 ==> (<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,fao_Latn,python,"
def prod_signs(arr):
    """"""Tú hevur eina talgreiðslu av heilum tølum, og tú skalt lata summar av stórum talgreiðslum, sum eru margfalda við eitt produkt av øllum teknum hjá hvørjum tali í talgreiðsluni, sum er 1, -1 ella 0.""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,fao_Latn,python,"
def minPath(grid, k):
    """"""Tú kanst byrja frá einari og hvørjari keldu, og í hvørjum stigi kanst tú fara til aðrar teldur, sum hava somu kantar sum tínir í verandi keldu. Gev gætur, at ein leið, sum er k lang, merkir, at tú skalt vitja júst k keldur (ikki neyðturviliga serstakar). Tú kanst IKKI fara út um netið. Ein leið A (longd á k) verður mett at vera minni enn ein leið B (longd á k), um eftir at hava gjørt raðfestar listar av virðunum á kellunum, sum A og B ganga ígjøgnum (við at kalla tær l_stA og l_stB), er l_stA orðalega minni enn l_stB, t.d. ein talgildi talgildi í netinum er: [1,4,5,6,7,8,9,9,9,] [1,1,1,2,2,] [1,2,], [1,2,], [1,2,], [1,3,] [4,], [1,], [1,], [2,], [1,], [1,], [2,], [3,] [4,] [4,] [5,] [6,] [7,]""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,fao_Latn,python,"
def tri(n):
    """"""Fibonacci-seriuna kenna øll, hon er granskað nógv av matematikarum seinastu par hundraðárini. Men tað, sum fólk ikki kenna, er Tribonacci-seriuna. Tribonacci-seriuna er definerað við endurtøku: tri(1) = 3 tri(n) = 1 + n / 2, um n er javnt. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), um n er ójavnt. Til dømis: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Tú hevur fingið eitt ikki-negativt heiltal n, tú skalt lata eina lista við teimum fyrstu n + 1 tølunum í Tribonacci-seriuni. Dømi: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,fao_Latn,python,"
def digits(n):
    """"""Gev eitt jaligt heilt tal n, gev so útvoldina av teimum ólitu tølunum. Gev út 0 um øll tølini eru javn. T.d.: tølini""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,fao_Latn,python,"
def is_nested(string):
    '''Skapa eina funktión, sum tekur eina strengi sum inngang, sum bert inniheldur kvadratiskar parentesir. Funktiónin skal geva sannleika, um og bert um tað er ein galdandi undirstrika av parentesum, har minst ein parentesur í undirstrikanum er nestur. er_nestur'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,fao_Latn,python,"

def sum_squares(lst):
    """"""Tú fært eina talgilda skrá, sum tú skalt rokna summar av talgildum tølum í talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talgildum talg""""""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,fao_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Skapa eina funktión, sum gevur sannleika, um seinasti stavurin í eini givnari strengi er ein stavur í alfabeti og ikki er partur av einum orði, og falskt annars.'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,fao_Latn,python,"
def can_arrange(arr):
    """"""Skapa eina funktión, sum gevur størsta indeksið av einum elementi, sum ikki er størri enn ella líka við elementin beint undan. Um einki slíkt element er, so gevur tað -1.""""""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,fao_Latn,python,"
def largest_smallest_integers(lst):
    '''Skapa eina funktión, sum gevur eitt tuppul (a, b), har 'a' er størsta av negativu heilum tølum, og 'b' er tað minsta av positivum heilum tølum í einum lista. Um tað ikki eru negativa ella positiva heil tøl, gevur tú tey sum None. Dømi: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,fao_Latn,python,"
def compare_one(a, b):
    """"""Skapa eina funktión, sum tekur heil tøl, floats ella strengi, sum umboða verulig tøl, og gevur størru broyting í sínum givnu broytingartýpi. Gevur null, um virðini eru javnsett.""""""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,fao_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Met um, um tað givna talið n kann skrivast sum uppsumma av júst 4 positivum javnum tølum Dømi er:""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,fao_Latn,python,"
def special_factorial(n):
    """"""Brasilian faktorialurin er defineraður sum: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! har n > 0 T.d.: >>> special_factorial ((4) 288 Funktiónin fær eitt heilt tal sum inngang og skal geva serstaka faktorialin av hesum heilum tali. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,fao_Latn,python,"
def fix_spaces(text):
    """"""_Dømi-3r er givin, so skifta øll rúm í honum út við undirstrik, og um ein strengur hevur fleiri enn 2 raðfestir rúm, so skifta øll raðfestir rúm út við - fix_spaces ((""Dømi"") == ""Dømi"" fix_spaces ((""Dømi1"") == ""Dømi1"" fix_spaces (((""Dømi2"") == ""_Dømi2"" fix_spaces (((""Dømi 3"") == ""_Dømi-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,fao_Latn,python,"
def file_name_check(file_name):
    """"""Skapa eina funktión, sum tekur ein streng, sum umboðar eitt fíls navn, og gevur 'Ja' aftur, um fíls navnið er galdandi, og gevur 'Nei' aftur, um ikki. Eitt fíls navn verður mett at vera galdandi, um og bert um allar hesar treytir eru uppfyltar: - Tað skulu ikki vera fleiri enn trý talvur ('0'-'9') í fíls navninum. - Fíls navnið inniheldur akkurát eitt prikk '.' - Undirstringin áðrenn prikkin skal ikki vera tóm, og hon skal byrja við einum bókstavi úr latin alphapet ('a'-'z' og 'A'Z'). - Undirstringin aftaná prikkin skal vera ein av hesum: ['txt', 'exe', 'lld'] Dømi: file_name_check""{example.txt.txt"") # => 'Yes' file_name_check""{example.txt.1} => 'No' (navnið skal byrja við latin alphapet) #""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,fao_Latn,python,"


def sum_squares(lst):
    """""""" Hetta virkið tekur ein lista við heilum tølum. Fyri allar inntøkurnar á listanum skal virkið kvadera heiltøl, um indeksið er margfeldi av 3, og skal kubera heiltøl, um indeksið er margfeldi av 4 og ikki margfeldi av 3. Virkið broytir ikki tær inntøkurnar á listanum, sum ikki eru margfeldi av 3 ella 4. Virkið skal so geva summan av øllum inntøkunum. Dømi: Fyri lst = [1,2,3] skal útgávuna vera 6 Fyri lst = [] skal útgávuna vera 0 Fyri lst = [-1,-5,2,-1,-5] skal útgávuna vera -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,fao_Latn,python,"
def words_in_sentence(sentence):
    """"""Tú hevur fingið eina strengi, sum umboðar ein setning, setningin inniheldur nøkur orð, sum eru skilin sundur við eitt pláss, og tú skalt lata eina strengi, sum inniheldur orðini úr upprunaliga setningini, hvørs longd er primtøl, og raðfylgjan av orðunum í nýggju stringini skal vera tann sama sum í upprunaliga setninginum.""""""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,fao_Latn,python,"
def simplify(x, n):
    """"""Tín uppgáva er at seta í verk eina funktión, sum skal forklára úttrykkið x * n. Funktiónin gevur aftur True, um x * n er eitt heilt tal og False annars. Bæði x og n eru strengi av brotum, og hava fylgjandi format, <numerator>/<denominator> har bæði teljari og nevnari eru jalig heil tøl. Tú kanst rokna við, at x og n eru galdandi brot, og hava ikki null sum nevnari. forklára "" 1/5 "", ""5/1"") = True forklára "" 1/6 "", ""2/1"") = False forklára "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,fao_Latn,python,"
def order_by_points(nums):
    """"""Skriva eina funktión, sum raðfestir talvtalurnar í uppstigandi raðfylgi eftir summan av talvnum.""""""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,fao_Latn,python,"
def specialFilter(nums):
    """"""Skriva eina funktión, sum tekur eina talvu sum inngang og gevur talið av elementum í talvu, sum eru størri enn 10, og bæði fyrsta og seinasta talvtalv er óliviligt (1, 3, 5, 7, 9). T.d. specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,fao_Latn,python,"
def get_max_triples(n):
    """"""Tú hevur fingið eitt positivt heilt tal n. Tú skalt skapa eina heiltaliga talrøð a av longd n. Fyri hvørt i (1 ‰¤ i ‰¤ n), er virði á a[i] = i * i - i + 1. Gev tølini fyri trívingar (a[i], a[j], a[k]) av a har i < j < k, og a[i] + a[j] + a[k] er eitt fleirfaldi av 3.""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,fao_Latn,python,"
def bf(planet1, planet2):
    '''Tað eru átta planetar í okkara sólskipan: Tann tættasta til sólina er Merkur, tann næsti er Venus, síðan Jørðin, Mars, Jupiter, Saturn, Uranus, Neptunus. Skriva eina funktión, sum tekur tvey planetanavn sum strenger planet1 og planet2. Funktiónin skal geva eina tuppul, sum inniheldur allar planetar, hvørs umlopi er millum umlopið hjá planet1 og umlopið hjá planet2, raðfest eftir nærleika til sólina. Funktiónin skal geva eina tóma tuppul, um planet1 ella planet2 ikki eru røttu planetanavnini. Dømi: bf""(Jupiter"", ""Neptunus"") ==> (""Saturn"", ""Uranus"") bf(""Jørðin"", ""Merkur"") ==> (""Venus"") bf(""Merkur"", ""Uranus"") ==> (""Venus"", ""Jørðin"", ""Mars"", ""Jupiter"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,fao_Latn,python,"
def sorted_list_sum(lst):
    """"""Skriva eina funktión, sum tekur eitt tal av stringum sum parametur, strikar stringum, sum hava ólíkar longdir, og gevur úrslitini við einum raðfestum raðfylgi. Listin er altíð ein tal av stringum og ongantíð ein talbólkur, og hann kann hava dupultir. Raðfylgjan á listanum skal vera stigandi eftir longd á hvørjum orði, og tú skalt geva listan raðfestan eftir hesi reglu. Um tvey orð hava somu longd, raðfesta tú listan alfabetiskt. Funktiónin skal geva eina lista av stringum í raðfestari raðfylgju. Tú kanst rokna við, at øll orðini hava somu longd. T.d.: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""ab"", ""cd ])""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,fao_Latn,python,"
def x_or_y(n, x, y):
    """"""Eitt einfalt forrit, sum skal geva virðið av x, um n er eitt primtal, og skal geva virðið av y, um ikki.""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,fao_Latn,python,"
def double_the_difference(lst):
    '''Gevdur ein lista við tølum, so skal summar av kvadratunum av tølunum í listanum, sum eru ólivandi. Ignorera tøl, sum eru negativ ella ikki eru heiltøl. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Um innleggslistan er tómur, skal 0 returnerast. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,fao_Latn,python,"
def compare(game,guess):
    """"""Eg haldi, at vit øll minnast ta kensluna, tá ið úrslitið av onkrari leingi væntandi hending er endaliga kend. Kenslurnar og tankarnar, tú hevur í tí løtuni, eru avgjørt vert at skriva niður og samanbera. Tín uppgáva er at finna útav, um ein persónur hevur gitað úrslitini av fleiri dystum rætt. Tú fært tvær røðir av stigum og gátum av somu longd, har hvør indeksur vísir eina samsýning. Gev eina røð av somu longd, sum vísir, hvussu langt burtur hvørt gát var. Um tey hava gitað rætt, er virði 0, og um ikki, er virði tann absoluta munurin millum gát og stig.""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,fao_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Tú fært navnið á einum flokki (eitt strengi) og ein lista við útstykkingum. Útstykkingarnar skulu brúkast til at leggja fleiri klassar inn í flokkin. Styrkin á útstykkingini er sum fylgir: Lat CAP vera talið av stórum bókstavum í navninum á útstykkingini, og lat SM vera talið av smáum bókstavum í navninum á útstykkingini, styrkin er givin við brotinum CAP - SM. Tú skalt finna sterkasta útstykkingina og senda eina strengi í hesum sniði: ClassName.StrongestExtensionName. Um tað eru tvær ella fleiri útstykkingar við somu styrki, skalt tú velja ta, sum kemur fyrst á listanum. T.d. um tú hevur fingið ""Slices"" sum flokk og ein lista við útstykkingum: ['SEviviRNGliSCes', 'Cheese', 'StuFfed'] so skalt tú senda 'Slices.SEviRNGliS' aftur, tí at 'SviRNGliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSliSli""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,fao_Latn,python,"
def cycpattern_check(a , b):
    """"""Tú hevur 2 orð. Tú mást lata sannleika koma aftur, um annað orðið ella einhvør av tíni rotatiónir er ein undirstringur í fyrsta orði cycpattern_check(""abcd"",""abd"") => False cycpattern_check(""hello"",""ell"") => True cycpattern_check(""whassup"",""psus"") => False cycpattern_check""abab"",""baa"") => True cycpattern_check(""efef"",""eeff"") => False cycpattern_check""(hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,fao_Latn,python,"
def even_odd_count(num):
    """"""Givt eitt heilt tal. gevur eitt tuppul, sum hevur talið av javnum og ójavnum talnum. Dømi: javn_ójavnt_tal ((-12) ==> (1, 1) javn_ójavnt_tal ((123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,fao_Latn,python,"
def int_to_mini_roman(number):
    """"""Gevnum einum positivum heiltali, fá rómverskum talvtali tað sama sum ein streng, og gev tað aftur í lágstavi.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,fao_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Given the lengths of the three sides of a triangle. Return True if the three sides form a right-angled triangle, False otherwise. Ein rættvinkulur tríhyrningur er ein tríhyrningur, har ein vinkul er rættvinkulur ella 90 stig. Dømi: rættvinkulur tríhyrningur ((3, 4, 5) == Rættvinkulur tríhyrningur ((1, 2, 3) == Falst '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,fao_Latn,python,"
def find_max(words):
    """"""Skriva eina funktión, sum tekur ímóti einum lista við stringum. Listin inniheldur ymisk orð. Gev orðini við mest møguligum tali av serstovnum teknum. Um fleiri stringar hava mest møguligum tali av serstovnum teknum, gev so tað orðið aftur, sum kemur fyrst í orðabókarskipanarligari raðfylgju.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,fao_Latn,python,"
def eat(number, need, remaining):
    """"""Tú ert ein svangur kanin, og tú hevur longu etið eitt ávíst tal av gulrøtum, men nú skalt tú eta fleiri gulrøtur fyri at klára máltíðirnar í dag. tú skalt lata eina talvu av [total number of eaten carrots after your meals, the number of carrots left after your meals] um tað ikki eru nóg nógvir gulrøtur eftir, so skalt tú eta allar tær verandi gulrøturnar, men tú verður tó svangur. Dømi: * eta(5, 6, 10) -> [11, 4] * eta(4, 8, 9) -> [12, 1] * eta(1, 10, 10) -> [11, 0] * eta(2, 11, 5) -> [7, 0] Variablar: @number: heil tal av gulrøtum, sum tú hevur etið. @need: heil tal av gulrøtum, sum tú skalt eta. @remaining: heil tal av verandi gulrøtum í goymslu: * Constrain: 0= <= 0 * 1000 <= 0 * resting <= 1000 <= 1000 <= 1000 = have fun = 1000:)""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,fao_Latn,python,"
def do_algebra(operator, operand):
    """"""Tveir listar operator, og operand. Fyrsti listin hevur grundleggjandi algebra operatiónir, og annar listin er ein lista við heilum tølum. Brúka báðar givnu listarnar til at byggja algebra úttrykkið og geva útgerðina av hesum úttrykki. Grundleggjandi algebra operatiónir: Addition ( +) Subtraction ( - ) Multiplication ( *) Floor division ( // ) Exponentiation ( ** Example): operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 Note: The length of list of operator is equal to the length of operand list minus one. Operand er ein lista við ikki-negativum heilum tølum. Operator hevur í minsta lagi ein list av operatorum, og listin hevur í minsta lagi tveir operand. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,fao_Latn,python,"
def solve(s):
    """"""Tú hevur fingið eina strengi s. Um s[i] er ein bókstavur, so vend tíni mál frá niðri til ovast ella øvugt, annars goym tað sum tað er. Um stringin ikki inniheldur nakrar bókstavir, vend stringini. Funktiónin skal geva úrslitstringini. Dømi loysa""""""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,fao_Latn,python,"
def string_to_md5(text):
    """"""Gevdur ein streng 'text', sendir tú aftur sín md5 hash-javnstøðugan streng. Um 'text' er ein tómur streng, sendir tú None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,fao_Latn,python,"
def generate_integers(a, b):
    """"""Gevdu tvey jalig heil tøl a og b, so skal tú lata javnt tal millum a og b, í uppgongd. T.d.: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
