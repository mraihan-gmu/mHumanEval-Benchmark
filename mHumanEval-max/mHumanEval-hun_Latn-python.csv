task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,hun_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Ellenőrizze, hogy az adott számlista bármelyik két szám közelebb van-e egymáshoz, mint az adott küszöbérték. Például: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) Hamis >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) Igaz """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,hun_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""A bevitel a fonctióhoz egy húr, amely több csoportot tartalmaz fészkelő zárójelből. A cél az, hogy elválassza azokat a csoportokat külön húrokba, és visszaadja azok listáját. Az elválasztható csoportok kiegyensúlyozottak (minden nyitott zárójel megfelelően zárva van), és nem fészkelődnek egymásba.""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,hun_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Ha egy pozitív lebegőpontos számot kapunk, akkor az osztható egy egész számra (a legnagyobb egész szám kisebb, mint az adott szám) és tizedes számra (a maradék mindig kisebb, mint 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,hun_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""A bankban a számla egyenlege nullával kezdődik. A feladatod az, hogy észleld, ha a számla egyenlege valamikor nullánál alacsonyabb, és akkor a függvénynek True-t kell adnia. Ellenkező esetben hamisnak kell adnia. Például: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,hun_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Egy adott beviteli számok listájánál számítsuk ki az átlagos abszolút eltérés mértéket az adatkészlet átlagával. Az átlagos abszolút eltérés az egyes elemek és a középpont közötti átlagos abszolút különbség (a középérték ebben az esetben: MAD = átlag ⋅ x - x_központ ⋅ Például: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,hun_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""A bevezető listán minden két egymást követő elem között helyezze el a ""határértéket"" jelölő számot `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,hun_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""A függvény bevitele egy sztring, amely több csoportot képvisel a fészkelő zárójelök számára, szelvényekkel elválasztva. A csoport mindegyikére a zárójelek legmélyebb fészkelési szintjét adja ki. Például (() (()) legfeljebb két fészkelési szintet tartalmaz, míg ((())) három. >>> parse_nested_parens('((()) ((())) () (((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,hun_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""A bevezető sorok listáját csak azokra szűri, amelyek adott alsorral rendelkeznek >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,hun_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Egy adott egész számlistához adja vissza a listában lévő összes egész szám összegéből és szorzatából álló tuplát. Az üres összegnek 0-val és az üres szorzatnak 1-el kell lennie. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,hun_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Egy adott egész számlistából generáljunk egy listát a sorozat adott pillanatáig megtalálható legnagyobb hullámzó elemről. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,hun_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""A legkisebb palindrómát találjuk, amely egy adott sztrámból kezdődik. Az algoritmus ötlete egyszerű: - Keresse meg a megadott sztrámból a leghosszabb postfix-et, amely egy palindróm. - Hozza hozzá a sztrámból a sztrámból a prefix-et, amely a palindróm utótag előtt van. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('catac') ' >>> make_palindrome ((('catac') ' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Ellenőrizzük, hogy az adott sztring palindróm-e.""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,hun_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""A bevitel két olyan string, a és b, amelyek csak 1 és 0-ból állnak. Csináljunk bináris XOR-t ezen a bemeneten, és az eredmény egy stringként is visszatér. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,hun_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""A sorok listájából a leghosszabbat adja vissza. Az elsőt adja vissza, ha több, azonos hosszúságú sor van. A nullát adja vissza, ha a bemeneti lista üres. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,hun_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""A két egész szám a és b legnagyobb közös osztója >>> legnagyobb_közös_osztója ((3, 5) 1 >>> legnagyobb_közös_osztója ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,hun_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""A bevitel sorának a legrövidebből a leghosszabbig terjedő összes előtagjának listáját adja vissza >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,hun_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Adja vissza a 0 és n közötti térrel határolt számokat tartalmazó string-et. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,hun_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Egy adott karakterlánc, találd ki, hány különböző karakterből áll (a nagybetűtől függetlenül) >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,hun_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""A funkcióhoz egy hangsor kerül, amely zenés hangjegyeket képvisel egy speciális ASCII formátumban. A feladatod az, hogy elemezze a sok ütésnek megfelelő egész számok listáját: 'o' hangjegy, utolsó négy ütés 'o' - 1/2 hangjegy, utolsó két ütés ' - 4 hangjegy, utolsó egy ütés >>> parse_music. 'o' . o' . o' . o' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,hun_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Találd meg, hányszor található meg egy adott allánc az eredeti láncban. Számold meg az átfedő eseteket. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,hun_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""A bevitel egy térrel határolt számlánc, amely a ""nullól"" a ""kilencig"" terjed. Az érvényes választások a ""nulló"", ""egy"", ""két"", ""három"", ""négy"", ""öt"", ""hat"", ""hét"", ""nyolc"" és ""kilenc"". Visszaadja a számláncot a legkisebbtől a legnagyobbig rendezve >>> sort_numbers (('három egy öt') 'egy három öt' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,hun_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""A megadott számok listájából (amely legalább kétes hosszúságú) válasszon és adja vissza a két egymáshoz legközelebbi számot, és adja vissza azokat sorrendben (kisebb szám, nagyobb szám). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,hun_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""A számok listája (legalább két elemből), egy lineáris átalakítást alkalmaz a listára, hogy a legkisebb szám 0 legyen, a legnagyobb pedig 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,hun_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Szűrés adott listája bármilyen Python értékek csak egész számok >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,hun_Latn,python,"

def strlen(string: str) -> int:
    """"""A megadott sztring >>> strlen('') 0 >>> strlen('abc') 3  visszaküldési hossza""""""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,hun_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Egy adott n számnál találjuk meg a legnagyobb számot, amely egyenletesen osztja n-t, kisebb, mint n >>> legnagyobb_osztó ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,hun_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""A megadott egész szám elsődleges tényezőinek listáját a legkisebbtől a legnagyobbig sorrendben adja vissza. A tényezők mindegyikének meg kell szerepelnie a szorzatban megjelenő számnak megfelelő számmal. A bemeneti számnak meg kell lennie az összes tényező szorzatának >>> szorzatának ((8) [2, 2, 2] >>> szorzatának ((25) [5, 5] >>> szorzatának ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,hun_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""A teljes számok listájából távolítsuk el az egynél többször előforduló elemeket. Az elemek sorrendjét ugyanazzal a sorrendgel kell megtartani, mint a bemeneti elemek sorrendjében. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,hun_Latn,python,"

def flip_case(string: str) -> str:
    """"""Egy adott karakterlánc esetében a kisbetűket nagybetűkbe és a nagybetűket kisbetűkbe kell fordítani. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,hun_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Összefonás egy vonalba >>> összefonás([]) '' >>> összefonás(['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,hun_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""A bevezető sorok listáját csak azokra szűri, amelyek egy adott előtaggal kezdődnek. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,hun_Latn,python,"

def get_positive(l: list):
    """"""Csak pozitív számokat adja vissza a listából. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,hun_Latn,python,"

def is_prime(n):
    """"""Ha egy adott szám prím, akkor a true értéket adja vissza, ha nem, akkor a false értéket. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,hun_Latn,python,"import math


def poly(xs: list, x: float):
    """"""A find_zero csak a nullás tényezőket adja vissza, még ha sok is van. Továbbá a find_zero csak a listát adja, ha a tényezők száma páros és a legnagyobb nem nulla tényező, mivel garantálja a megoldást. >>> körben (((find_zero[1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> körben (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1,0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Értékel egy polinomiumot xs együtthatóval az x pontban. Vissza xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,hun_Latn,python,"

def sort_third(l: list):
    """"""Ez a függvény vesz egy l-es listát és olyan l'-es listát ad vissza, hogy az l' azonos legyen az l-el a háromra nem osztható indexekben, míg az értékei az l-nek a megfelelő indexek értékeivel megegyeznek, de rendezettek. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,hun_Latn,python,"

def unique(l: list):
    """"""A sorolt egyedi elemek visszatérítése egy listában >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,hun_Latn,python,"

def max_element(l: list):
    """"""A listában található legnagyobb elemet adja vissza. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,hun_Latn,python,"

def fizz_buzz(n: int):
    """"""Adja meg a 7 számjegy 11 vagy 13 számozott egész számokban való megjelenésének számát, amelyek kisebb, mint n. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,hun_Latn,python,"

def sort_even(l: list):
    """"""Ez a függvény vesz egy listát l és adja vissza egy listát l 'olyan módon, hogy l' azonos l a páratlan indexek, míg az értékei a páros indexek egyenlőek az értékek a páros indexek l, de rendezett. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,hun_Latn,python,"

def encode_cyclic(s: str):
    """"""az encode_cyclic funkcióval kódolt sztringet veszi be. Dekódolt sztringet ad vissza. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""három karakterből álló cikluscsoportok által kódolt karakterláncot ad vissza. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,hun_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib adja vissza az n-ik számot, ami egy Fibonacci szám és egyben prím is. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,hun_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""A triples_sum_to_zero egy egész számok listáját veszi be. Ha a listában három különböző elem van, amelyek nulla összegűek, akkor az Igaz, és a False egyébként. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,hun_Latn,python,"

def car_race_collision(n: int):
    """"""Képzeljünk el egy olyan utat, amely egy tökéletesen egyenes végtelen hosszú vonal. n autó vezet balról jobbra; egyidejűleg, n másik autó vezet jobbról balra. A két autócsoport nagyon messze kezdődik egymástól. Minden autó ugyanabban a sebességben mozog. Két autó ütközik, amikor egy balról jobbra haladó autó ütközik egy jobbról balra haladó autóval. Azonban az autók végtelenül erősek és erősek; ennek eredményeként továbbra is a pályájukon mozognak, mintha nem ütköznének. Ez a függvény az ilyen ütközések számát adja ki.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,hun_Latn,python,"

def incr_list(l: list):
    """"""Visszaállít egy listát, amelynek elemeit 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,hun_Latn,python,"

def pairs_sum_to_zero(l):
    """"""A pairs_sum_to_zero egy egész számok listáját veszi be. Ha két különböző elem van a listában, amelyek nulla összeget adnak, akkor az True-t adja vissza, és a False-t, ha nem. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,hun_Latn,python,"

def change_base(x: int, base: int):
    """"""A bevitel számának számszerű alapját alapra változtatni. A konverzió után visszaadja a sztring reprezentációt. Az alap számok kevesebb, mint 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,hun_Latn,python,"

def triangle_area(a, h):
    """"""A háromszög oldalának hosszát és a legnagyobb visszatérési területét tekintve. >>> háromszög_területe""""""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,hun_Latn,python,"

def fib4(n: int):
    """"""A Fib4 számsorozat a Fibbonacci-sorozathoz hasonló sorozat, amelyet a következőképpen definiálnak: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Kérjük, írjon egy funkciót a fib4 számsorozat n-ik elemének hatékony kiszámítására. Ne használja a rekurziót. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,hun_Latn,python,"

def median(l: list):
    """"""A listán szereplő elemek visszatérési mediánja l. >>> medián (([3, 1, 2, 4, 5]) 3 >>> medián (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,hun_Latn,python,"

def is_palindrome(text: str):
    """"""Ellenőriz, hogy az adott sztring palindróm-e >>> is_palindrom (('') Igaz >>> is_palindrom (('aba') Igaz >>> is_palindrom (('aaaaa') Igaz >>> is_palindrom (('zbcd') Téves """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,hun_Latn,python,"

def modp(n: int, p: int):
    """"""Visszaadja a 2^n modulo p-t (tudomás a számokról). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,hun_Latn,python,"

def encode_shift(s: str):
    """"""az encode_shift funkcióval kódolt bevezető karakterláncként veszi. Dekódolt karakterláncot ad vissza. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""kódolt karakterláncot ad vissza az ábécé minden karakterének 5 - es elmozdításával.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,hun_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels egy olyan függvény, amely vonalokat vesz és vokálok nélküli vonalokat ad vissza. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,hun_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Az érték értékét az érték értékének az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az értéknek az érték""""""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,hun_Latn,python,"

def add(x: int, y: int):
    """"""Adjunk össze két számot x és y >>> add(2, 3) 5 >>> add(5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,hun_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Ellenőrizze, hogy két szó azonos karakterekkel rendelkezik-e. >>> same_chars('eabcdzzzz', 'dddzzzzzzdeddabc') Igaz >>> same_chars('abcd', 'dddddddabc') Igaz >>> same_chars('dddddddabc', 'abcd') Igaz >>> same_chars('eabcd', 'dddddddddabc') Téves >>> same_chars('abcd', 'dddddddabc') Téves >>> same_chars'(abcdzzzz', 'dddzzzzzzdddabc') Téves """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,hun_Latn,python,"

def fib(n: int):
    """"""Adja vissza az n-ik Fibonacci-számot. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,hun_Latn,python,"

def correct_bracketing(brackets: str):
    """"""a zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben""""""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,hun_Latn,python,"

def monotonic(l: list):
    """"""Ha a listás elemei monoton módon nőnek vagy csökkennek, akkor az igaz. >>> monoton (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,hun_Latn,python,"

def common(l1: list, l2: list):
    """"""Vissza rendezett egyedi közös elemeket két listában. >>> közös (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> közös (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,hun_Latn,python,"

def largest_prime_factor(n: int):
    """"""Adja vissza a legnagyobb prímszámot az n-ből. Tegyük fel, hogy n > 1 és nem prímszám. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,hun_Latn,python,"

def sum_to_n(n: int):
    """"""A sum_to_n egy olyan függvény, amely 1 és n közötti számokat összegzi. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,hun_Latn,python,"

def correct_bracketing(brackets: str):
    """"""a zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő zárójelben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben lévő záróben""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,hun_Latn,python,"

def derivative(xs: list):
    """"""xs egy többnév együtthatóit jelöli. xs[0] + xs[1] * x + xs[2] * x^2 + .... Hozza vissza a többnév származékát ugyanabban a formában. >>> származék (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> származék [(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,hun_Latn,python,"

def fibfib(n: int):
    """"""A FibFib számsorozat a Fibbonacci-sorozathoz hasonló sorozat, amelyet a következőképpen definiálnak: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Írjon egy funkciót a fibfib számsorozat n-ik elemének hatékony kiszámítására. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,hun_Latn,python,"
FIX = """"""Írjunk egy olyan függvényt, amely a szószöveget ad be, és a szószövegben lévő magánhangzók számát adja vissza. Ebben az esetben az 'a', 'e', 'i', 'o', 'u' magánhangzók. Itt az 'y' is magánhangzó, de csak akkor, ha az adott szó végén van. Például: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Adjunk hozzá több vizsgálati esetet.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,hun_Latn,python,"
def circular_shift(x, shift):
    """"""Körbe helyezzük az x egész szám számjegyeit, a számjegyek jobbra helyezzük el, és a sztring formájában adja vissza az eredményt. Ha a shift > számjegyek száma, adja vissza a számjegyeket fordítva. >>> cirkuláris_megmozdulás(12, 1) ""21"" >>> cirkuláris_megmozdulás(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,hun_Latn,python,"
def digitSum(s):
    """"""Feladat Olyan függvény írása, amely bevitelként egy karakterláncot vesz és csak a felső karakterek összegét adja vissza ASCII kódok. Példák: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,hun_Latn,python,"
def fruit_distribution(s,n):
    """"""Ebben a feladatban kap egy olyan húr, amely egy gyümölcskosárban elosztott almákat és narancsokat jelképezik, ez a kosár almát, narancsot és mangó gyümölcsöket tartalmaz. Ha a húr jelképezi a narancsok és almákat és egy egész szám, amely a gyümölcsök számát jelképezi, adja vissza a mangó gyümölcsök számát a kosárban. Például: fruit_distribution""5(almákat és 6 narancsot"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 almát és 1 narancsot"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 almát és 3 narancsot"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 almát és 120 narancsot"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,hun_Latn,python,"
def pluck(arr):
    """"""""Ha egy sor egy olyan faágát képviseli, amelynek nem negatív egész számú csomópontjai vannak, a feladatunk az, hogy kivesszük az egyik csomópontot és visszaadjuk. A kivesszük csomópontnak a legkisebb páros értékű csomópontnak kell lennie. Ha több csomópontot találunk, amelyek ugyanazon a legkisebb páros értékkel vannak, akkor visszaadjuk a legkisebb indexű csomópontot. A kivesszük csomópontot egy listában kell visszaadni, [smallest_value, index] Ha nincsenek páros értékek, vagy az adott sor üres, akkor visszaadjuk []. Például: 1: Bevitel: [4,2,3] Kivitel: [2, 1] Magyarázat: 2 a legkisebb páros értékű, és 2 a legkisebb indexű. Például: Bevitel: [1,2,3] Kivitel: [2, 1] Magyarázat: 2 a legkisebb páros értékű, és 2 a legkisebb indexű. Például: Bevitel: [] Kivitel: [4: [5, 3], Bevitel: [4,] Bevitel: [0, 1 Kivitel: 0] A legkisebb csomópontot, amely a legkisebb indexű, de a legkisebb értékű, tehát a legkisebb a nulla. Például: az első csomópontotának van a legkisebb értéke: * 100 * 0 = 0""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,hun_Latn,python,"
def search(lst):
    '''A teljes szám gyakorisága az egész szám számának a listában megjelenő gyakorisága. Ha nincs ilyen érték, akkor adja vissza -1. Példák: keresés: (([4, 1, 2, 2, 3, 1]) == 2 keresés: (([1, 2, 2, 3, 3, 4, 4]) == 3 keresés: (([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,hun_Latn,python,"
def strange_sort_list(lst):
    '''A teljes számok listája, a lista visszaküldése furcsa sorrendben. Furcsa rendezés, amikor a minimális értékkel kezdjük, majd a fennmaradó egész számok maximuma, majd a minimum és így tovább. Példák: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,hun_Latn,python,"
def triangle_area(a, b, c):
    '''A háromszög három oldalának hosszát megadva. Ha a három oldal egy érvényes háromszög, akkor a háromszög területét kerekítjük 2 tizedesjegyre. Ellenkező esetben -1 értéket adunk, ha bármelyik két oldal összege nagyobb, mint a harmadik oldal. Például: háromszög_terület ({3, 4, 5) == 6.00 háromszög_terület ({1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,hun_Latn,python,"
def will_it_fly(q,w):
    '''Írjunk egy olyan függvényt, amely Ha az objektum q repül, akkor az Igaz, ha a többi esetben Téves. Ha az objektum q kiegyensúlyozott (palindróm lista), és elemének összege kisebb vagy egyenlő a maximális lehetséges súlynál w. Például: will_it_fly (([1, 2], 5) â -> Ha az objektum # 1+2 kisebb a maximális lehetséges súlynál, de kiegyensúlyozatlan. will_it_fly (([3, 2, 3], 1) â -> Ha a objektum # kiegyensúlyozott, de a 3+2+3 nagyobb a maximális lehetséges súlynál. will_it_fly (([3, 2, 3], 9) â -> Ha a objektum q kisebb a maximális lehetséges súlynál, és kiegyensúlyozott.'''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,hun_Latn,python,"
def smallest_change(arr):
    """"""Ha egy egész számokból álló sorrendet adunk, akkor a sorrend palindromikusá tételéhez a legkisebb elemek számát kell megváltani. A palindromikus sor olyan sor, amely ugyanazt olvasja előre és hátra. Egy változás során egy elemet bármelyik másik elemre változtathat. Például: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,hun_Latn,python,"
def total_match(lst1, lst2):
    '''Írjunk egy olyan függvényt, amely két listát fogad el, és azt a listát adja vissza, amelyikben a listában lévő összes karakter kevesebb, mint a másik listában. Ha a két listában azonos számú karakter van, adja vissza az első listát. Példák: total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hi', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4']) ].'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,hun_Latn,python,"
def is_multiply_prime(a):
    """"""Írjunk egy olyan függvényt, amely igaz, ha a megadott szám 3 prímszám szorzata, és máskülönben hamis.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,hun_Latn,python,"
def is_simple_power(x, n):
    """"""A feladatunk az, hogy írjunk egy olyan függvényt, amely igazat ad, ha egy szám x n egyszerű hatódja, és hamis más esetekben. x n egyszerű hatódja, ha n**int=x Például: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,hun_Latn,python,"
def iscube(a):
    '''Írjunk egy olyan függvényt, amely egy egész számot a és True-t ad vissza, ha ez az ingeger egy egész szám kockája. Megjegyzés: feltételezhetjük, hogy a bemenet mindig érvényes. Példák: iscube(1) ==> True iscube(2) ==> False iscube(-1) ==> True iscube(64) ==> True iscube(0) ==> True iscube(180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,hun_Latn,python,"
def hex_key(num):
    """"""A hexadecimális számok a következők: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. A prímszámok a következők: 2, 3, 5, 7, 11, 13, 17,... Megjegyzés: feltételezhetjük, hogy a bemeneti szám mindig helyes vagy üres, és az A, B, C, D, E, F szimbólumok mindig nagybetűkkel vannak megírva. Példák: A num = AB, a kimeneti számnak 1. kell lennie. A num = 1077E kimeneti számnak 2. kell lennie. A num = AB331EDA a num = 4. kell lennie. A num = 4. kell lennie. A num = 6.01289ABCDEFD6452020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,hun_Latn,python,"
def decimal_to_binary(decimal):
    """"""A függvénynek egy karakterláncot kell visszatérítene, ahol minden karakter egy bináris számot jelöl. A karakterlánc minden egyes karaktere 0 vagy 1. A karakterlánc elején és végén egy pár extra karakter lesz, a db. A többlet karakterek a formátumban segítenek. Példák: decimal_to_binary ((15) # ""db1111db"" -t térít vissza decimal_to_binary32) # ""db100000db"" -t tér vissza""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,hun_Latn,python,"
def is_happy(s):
    """"""A string akkor happy, ha legalább 3 betűvel rendelkezik, és minden 3 egymást követő betű megkülönböztethető. Például: is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,hun_Latn,python,"
def numerical_letter_grade(grades):
    """"""A tanár a tanároknak a jegyeket adta. A tanár a saját algoritmusa alapján osztályozta a diákokat. Az egyetlen probléma az, hogy elvesztette a kódot, amit a osztályozáshoz használt. Adott egy listát a GPA-król néhány diák számára, és egy olyan függvényt kell írnod, amely a következő táblázat segítségével adhat ki egy listát a betűi osztályzatokról: GPA  Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,hun_Latn,python,"
def prime_length(string):
    """"""Írjunk egy olyan függvényt, amely egy stringet vesz és True-t ad vissza, ha a string hossza egy prímszám, vagy False-t, ha nem. Példák prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,hun_Latn,python,"
def starts_one_ends(n):
    """"""Ha egy n pozitív egész számot kapunk, adja meg az n-jegyű pozitív egész számok számát, amelyek 1-el kezdődnek vagy végződnek.""""""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,hun_Latn,python,"
def solve(N):
    """"""Ha egy N pozitív egész számot kapunk, adja vissza a számjegyek bináris összegeit. Például N = 1000 esetén a számjegyek összege 1 lesz, a kimenőnek ""1"" kell lennie. N = 150 esetén a számjegyek összege 6 lesz, a kimenőnek ""110"" kell lennie. N = 147 esetén a számjegyek összege 12 lesz, a kimenőnek ""1100"" kell lennie. Változók: @N egész szám Korlátozások: 0 â‰¤ N â‰¤ 10000. Kivitel: bináris számok sora """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,hun_Latn,python,"
def add(lst):
    """"""Ha egy nem üres egész számlistát látunk, először adjuk össze a páros elemeket, amelyek páratlan indexek.. Példák: add (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,hun_Latn,python,"
def anti_shuffle(s):
    """"""Írjunk egy olyan függvényt, amely egy húrból egy sorrendbe rendezett változatot ad vissza. A húr sorrendbe rendezett változata olyan húr, ahol minden szót (térrel elválasztva) egy új szó vált ki, ahol az összes karakter emelkedő sorrendben van elrendezve az ascii érték alapján. Megjegyzés: Meg kell tartani a szavak és a szóközök sorrendjét a mondatban. Például: anti_shuffle ((('Hi') visszaadja az 'Hi' anti_shuffle ((('hello') visszaadja az 'ehllo' anti_shuffle (('Hello World!!!') visszaadja az 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,hun_Latn,python,"
def get_row(lst, x):
    """"""A matrixhoz hasonlóan, de a mátrixoktól eltérően, minden sor tartalmazhat különböző számú oszlopot. Az lst és az x egész számot megadva, találj x egész számot a listában, és térj vissza a tuplek listájához, [(x1, y1), (x2, y2) ...] oly módon, hogy minden tuple egy koordinátát - (sor, oszlopok), kezdve a 0-val. Sorolja össze a koordinátákat kezdetben sorok szerint emelkedő sorrendben. Továbbá sorolja össze a sor koordinátáit oszlopok szerint csökkenő sorrendben. Például: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (2, 5), (2, 0) get_(], 1) [] == [0, 1, 2, 3, 2, 2, 3], [2, 2] == []""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,hun_Latn,python,"
def sort_array(array):
    """"""Ha egy nem negatív egész számokból álló tömbet adunk, a rendezés után küldjünk vissza egy másolatot a megadott tömbről, és soroljunk felfelé, ha a summa ((az első indexérték, az utolsó indexérték) páratlan, vagy soroljunk lefelé, ha a summa ((az első indexérték, az utolsó indexérték) páros.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,hun_Latn,python,"
def encrypt(s):
    """"""Hozzon létre egy encrypt funkciót, amely egy stringet vesz érvként, és egy kódolt stringet ad vissza az ábécé forgatásával. Az ábécé olyan módon forgatható, hogy a betűk lejjebb menjenek kettővel szorozva két helyre. Például: encrypt('hi') adja vissza 'lm' encrypt('asdfghjkl') adja vissza 'ewhjklnop' encrypt('gf') adja vissza 'kj' encrypt('et') adja vissza 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,hun_Latn,python,"
def next_smallest(lst):
    """"""Írj egy funkciót, amely a listán lévő második legkisebb elemet adja vissza. Ha nincs ilyen elem, akkor a nullát adja vissza.""""""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,hun_Latn,python,"
def is_bored(S):
    """"""A ""boredom"" egy olyan mondat, amely ""I"" szót használ. A mondatokat """"., ""?' vagy ""! "" határolja. Például: >>> is_bored ((""Hello world"") 0 >>> is_bored ((""Az ég kék. A nap ragyog. Szeretem ezt az időjárást"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,hun_Latn,python,"
def any_int(x, y, z):
    '''Hozzon létre egy olyan függvényt, amely 3 számot vesz fel. Ha az egyik szám egyenlő a másik kettő összegével, és minden szám egész szám, akkor az igaz. Ha más esetben nem, akkor a hamis. Példák: any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,hun_Latn,python,"
def encode(message):
    """"""Írjunk egy olyan funkciót, amely egy üzenetet vesz és úgy kódol, hogy az összes betű case-ját cseréli, és az üzenet összes magánhangzóját az angol ábécében az önhangzó előtt 2 helyen megjelenő betűvel helyettesíti.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,hun_Latn,python,"

def skjkasdkd(lst):
    """"""A teljes számok listája van. Meg kell találni a legnagyobb prímértéket és vissza kell adni a számjegyek összegét. Példák: Ha lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] a kimenő érték 10 Ha lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] a kimenő érték 25 Ha lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] a kimenő érték 13 Ha lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] a kimenő érték 11 Ha lst = [0,81,12,31,21] a kimenő érték 3 Ha lst = [1,0,8,1,2,1,7] a kimenő érték 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,hun_Latn,python,"
def check_dict_case(dict):
    """"""Ha egy szótárban minden kulcs kisebb betűkkel vagy nagyobb betűkkel van, akkor a funkció az Igazot adja vissza, ha az összes kulcs kisebb betűkkel vagy nagyobb betűkkel van, máskülönben a Valót. Ha a megadott szótár üres, a funkciónak Valót kell adnia. Példák: check_dict_case{""a"":""alma"", ""b"":""banán""}) Valót kell adnia. check_dict_case{""a"":""alma"", ""A"":""banán"", ""B"":""banán""}) Valót kell adnia. check_dict_case{""a"":""alma"", 8:""banán"", ""a"":""alma""}) Valót kell adnia. Check_dict_case{""Név"", ""John"", ""Eredet"", ""36"", ""City"", ""Houston""}) Valót kell adnia.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,hun_Latn,python,"
def count_up_to(n):
    """"""Olyan függvény végrehajtása, amely nem negatív egész számot vesz és az első n egész számokból álló tömböt ad vissza, amelyek prímszámok és kisebbek, mint n. Például: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,hun_Latn,python,"
def multiply(a, b):
    """"""A függvény teljesítése, amely két egész számot veszi és az egységjegyek szorzatát adja vissza. Feltételezzük, hogy a bemenet mindig érvényes. Példák: szorozni ((148, 412) 16-ot kell adnia, szorozni ((19, 28) 72-et kell adnia. szorozni ((2020, 1851) 0-ot kell adnia, szorozni ((14,-15) 20-at kell adnia.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,hun_Latn,python,"
def count_upper(s):
    """"""Egy s-es karakterláncban számold meg a páros jelzésű főszóval betűzett magánhangzók számát. Például: count_upper (('aBCdEf') 1 számot ad vissza count_upper (('abcdefg') 0 számot ad vissza count_upper (('dBBE') 0 számot ad vissza """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,hun_Latn,python,"
def closest_integer(value):
    '''Hozzon létre egy olyan függvényt, amely egy számot reprezentáló értéket (láncot) veszi és a legközelebbi egész számot adja vissza. Ha a szám két egész számtól egyenlő távolságra van, kerekítse ki a nullától. Példák >>> legközelebbi_egész szám (((""10"") 10 >>> legközelebbi_egész szám (((""15.3"") 15 Megjegyzés: A nullától való kerekítés azt jelenti, hogy ha az adott szám két egész számtól egyenlő távolságra van, akkor az a szám, amelyet vissza kell adni, az a nullatól legmesszebb. Példaként a legközelebbi_egész szám (((14.5"") 15-et, a legközelebbi_egész szám (((-14.5"") pedig -15-et kell adni. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,hun_Latn,python,"
def make_a_pile(n):
    """"""Ha egy n pozitív egész számot kapunk, akkor n kőből kell állítanunk egy halom kőket. Az első szint n kővel rendelkezik. A következő szintben a kőszámok száma: - a következő páratlan szám, ha n páratlan. - a következő páros szám, ha n páros. Adja vissza a kőszámokat az egyes szintekben egy listában, ahol az i indexű elem az i szint kőszámát képviseli (i+1). Példák: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,hun_Latn,python,"
def words_string(s):
    """"""A feladatunk, hogy szétválasztjuk a szálakat szavakra és visszaadjuk a szavak tömbét. Például: words_string ((""Szia, a nevem John"") == [""Szia"", ""az enyém"", ""név"", ""az"", ""John""] words_string ((""Egy, kettő, három, négy, öt, hat"") == [""Egy"", ""kettő"", ""három"", ""négy"", ""öt"", ""hat""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,hun_Latn,python,"
def choose_num(x, y):
    """"""Ez a függvény két pozitív számot vesz fel, x és y, és a legnagyobb páros egész számot adja vissza, amely [x, y] tartományban van.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,hun_Latn,python,"
def rounded_avg(n, m):
    """"""A válasz a legközelebbi egész számra kerekítve, majd binárisra konvertálva. Ha n nagyobb mint m, adja vissza a -1-et. Például: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b1111"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,hun_Latn,python,"
def unique_digits(x):
    """"""A pozitív egész számok listája x. A listát sorolt listával kell rendezni, amely nem tartalmaz páros számjegyeket.""""""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,hun_Latn,python,"
def by_length(arr):
    """"""Ha egy egész számok sorát kapunk, akkor rendezzük az 1-től 9-ig terjedő egész számokat, fordítjuk meg az eredő sorrendet, majd minden egyes számjegyet helyettesítünk a megfelelő névvel az ""Egy"", ""Két"", ""Három"", ""Négy"", ""Öt"", ""Hat"", ""Hét"", ""Nyolc"", ""Kilenc"" sorrendből. Például: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> rendezzük arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> fordított arr -> [8, 5, 4, 3, 2, 2, 1, 1] visszaadunk [""Hét"", ""Négy"", ""Három"", ""Két"", ""Két"", ""Egy"", ""Egy""] Ha az ábra üres, akkor térünk vissza egy egész számot: arr = [] visszaadunk [] Ha az ábrán furcsa szám van, figyelmen kívül hagyjuk: arr = [1, 1 , 1 - 55] -> arr -> [1, 1], 55 -> fordított arr = [51] - ['One' 1] ].""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,hun_Latn,python,"
def f(n):
    """"""A f függvényt, amely n-et vesz paraméternek, és egy n-es listát ad vissza, hogy az i indexben lévő elem értéke i-nek a faktoriala, ha i páros, vagy az 1-től i-ig terjedő számok összege. i 1-től kezdődik. i faktoriala az 1-től i-ig terjedő számok szorzása (1 * 2 * ... * i). Például: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,hun_Latn,python,"
def even_odd_palindrome(n):
    """"""Ha egy n pozitív egész számot kapunk, akkor egy olyan tuplot adunk vissza, amely a ((1, n) tartományba tartozó páros és páratlan egész számú palindrómák számát tartalmazza. Például1: bemenet: 3 kimenet: (1, 2) magyarázat: egész számú palindrómák: 1, 2, 3. ezek közül az egyik páros, kettő pedig páratlan. Például2: bemenet: 12 kimenet: (4, 6) magyarázat: egész számú palindrómák: 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. négy közülük páros, és hat közülük páratlan. Megjegyzés: 1. 1 <= n <= 10^3 2. a tupl visszaadta a páros és páratlan egész számú palindrómák számát. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,hun_Latn,python,"
def count_nums(arr):
    """"""Írjunk egy count_nums függvényt, amely egy egész számokból álló tömböt vesz és olyan elemek számát adja vissza, amelyek száma > 0. Ha egy szám negatív, akkor az első aláírt számjegye negatív lesz: pl. -123 aláírt számjegye -1, 2, és 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,hun_Latn,python,"
def move_one_ball(arr):
    """"""A sorban lévő számok véletlenszerűen lesznek rendezve. A feladatod az, hogy eldöntsd, lehetséges-e egy sorrendet nem csökkenő sorrendben rendezni az adott sorrendben az alábbi művelet végrehajtásával: Bármikor megengedett a jobb oldali mozgás művelete. Egy jobb oldali mozgás művelet azt jelenti, hogy az összes elemet az array egy pozícióval a jobb irányba mozgatja. Az utolsó elem az array kezdő pozíciójába kerül az arrayban, azaz 0-as index. Ha lehetséges a rendezett sorrendet az előző művelet végrehajtásával, akkor True vissza, más esetben False vissza. Ha az adott sor üres, akkor True vissza. Megjegyzés: Az adott listában garantáltan egyedi elemek vannak. Például: move_one_(ball[3, 4, 5, 2]==================================================================================================================================================================================================================================================================================================================================""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,hun_Latn,python,"
def exchange(lst1, lst2):
    """"""Ebben a probléma, akkor megvalósítani egy függvény, amely két listát számok, és meghatározza, hogy lehetséges-e, hogy egy cserét elemek között, hogy lst1 egy listát csak páros számok. Nincs korlát a számát elemek cseréje között lst1 és lst2. Ha lehetséges, hogy elemek cseréje között lst1 és lst2 hogy az összes elemek lst1 páros, vissza ""Igen"". Egyébként vissza ""NEM"". Például: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""Igen"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NEM"" Feltételezzük, hogy a bemeneti listák nem üres. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,hun_Latn,python,"
def histogram(test):
    """"""Ha egy karakterlánc egy térrel elválasztott kisbetűs betűszámot mutat, akkor a legtöbbet ismételt betű szótárát kell visszaküldeni, amely tartalmazza a megfelelő számot. Ha több betűnek is ugyanaz a megjelenése, akkor mindegyiket kell visszaküldeni. Például: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a b') == {'b 4}: histogram (('a') == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,hun_Latn,python,"
def reverse_delete(s,c):
    """"""Feladat Két s és c karakterlánc van, törölni kell az s-ben lévő karaktereket, amelyek egyenlőek a c karakterével, majd ellenőrizni kell, hogy az eredménylánc palindróm-e. Egy string palindrómnak nevezik, ha ugyanazt olvassa visszafelé, mint előre. Vissza kell adnia egy tuplát, amely tartalmazza az eredményláncot és a True/False-t a ellenőrzéshez. Például az s = ""abcde"", c = ""ae"" esetén az eredménynek az ('bcd',False) kell lennie az s = ""abcdef"", c = ""b"" esetén az eredménynek az ('acdef',False) kell lennie az s = ""abcdedcba"", c = ""ab"", az eredménynek az ('cdedc',True) kell lennie""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,hun_Latn,python,"
def odd_count(lst):
    """"""Ha egy olyan string listát kapunk, ahol minden egyes string csak számjegyekből áll, akkor egy listát kell visszatértenünk. Az output minden i elemének ""a páratlan elemek száma az input i string-ében"". ahol az összes i-t a bevitel i-ik string-ének páratlan számjegyeinek számával kell helyettesíteni. >>> odd_count['1234567']) [""a páratlan elemek száma 4n a 4n input str4ng 4"".] >>> odd_count['3',""111111""]) [""a páratlan elemek száma 1n a 1n input str1ng 1""., ""a páratlan elemek száma 8n a 8n input str8ng 8"".]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,hun_Latn,python,"
def minSubArraySum(nums):
    """"""Egy n egész számú tömbben találjuk meg a n-ek nem üres al-tömbének minimális összegét.""""""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,hun_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""A vízbevonás a vízbevonásból, a vízbevonásból és a vízbevonásból történik. A vízbevonás a vízbevonásból és a vízbevonásból történik. A vízbevonás a vízbevonásból és a vízbevonásból történik. A vízbevonás a vízbevonásból és a vízbevonásból történik. A vízbevonás a vízbevonásból és a vízbevonásból történik.""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,hun_Latn,python,"
def sort_array(arr):
    """"""Ebben a Kata-ban a nem negatív egész számok sorát a bináris ábrázolásukban lévő egyek számának megfelelően sorolja felfelé. Az egyesek hasonló számához a tizedes érték alapján sorolja. Ezt így kell megvalósítani: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,hun_Latn,python,"
def select_words(s, n):
    """"""Ha egy s-es húr és egy n-es természetes szám van, akkor egy olyan függvényt kell végrehajtani, amely az s-es húr összes olyan szavának listáját adja vissza, amelyek pontosan n konsonánt tartalmaznak, hogy ezek a szavak az s-es húrban jelenjenek meg. Ha az s-es húr üres, akkor a függvénynek egy üres listát kell adnia vissza. Megjegyzés: feltételezhetjük, hogy a bemeneti húr csak betűket és űröket tartalmaz. Példák: select_words ""Mary had a little lamb"" 4) ==> [""little""] select_words ""Mary had a little lamb"" 3) ==> [""Mary"", ""lamb""] select_words ""simple white space"" 2) ==> [] select_words ""Hello world"" 4) ==> [""world""] select_words ""Uncle sam"" 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,hun_Latn,python,"
def get_closest_vowel(word):
    """"""Egy szó van megadva. A feladatod az, hogy megtaláld a legközelebbi magánhangzót, amely a szó jobb oldalán két konsonáns között áll (a nagybetűkkel érzékeny). A kezdeti és a végső magánhangzók nem számítanak. Üres húrot küldj vissza, ha nem találtál semmilyen magánhangzót, amely megfelel a fenti feltételnek. Feltételezheted, hogy az adott húr csak angol betűt tartalmaz. Például: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,hun_Latn,python,"
def match_parens(lst):
    '''A S-t akkor és csak akkor tekintik jónak, ha az S-ben lévő összes zárójel kiegyensúlyozott. Például: a ""((()) "") sor jó, míg a ""()) "" sor nem. Ha van mód egy jó sor létrehozására, adja vissza az ""Igen"", és máskülönben adja vissza a ""Nem"". Példák: match_parens[((() "", "" ()) "" == ""Igen"" match_parens[(') "", "" ()) "" == ""Nem"" '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,hun_Latn,python,"
def maximum(arr, k):
    """"""Ha egy egész számokból álló arr és egy k pozitív egész számot kapunk, akkor egy k hosszúságú, sorolt listát adunk vissza, amely az arr-ben lévő k számok maximális számát tartalmazza. Például1: bemenet: arr = [-3, -4, 5], k = 3 kimenet: [-4, -3, 5] Például2: bemenet: arr = [4, -4, 4], k = 2 kimenet: [4, 4] Például3: bemenet: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 kimenet: [2] Megjegyzés: 1. Az array hosszúsága [1, 1000] tartományban lesz. 2. Az array elemei [-1000, 1000] tartományban lesznek.""""""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,hun_Latn,python,"
def solution(lst):
    """"""Ha egy nem üres egész számlistát kapunk, akkor adja vissza a páratlan elemek egyenletes pozícióban lévő összes elemének összegét.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,hun_Latn,python,"
def add_elements(arr, k):
    """"""Ha egy nem üres tömbben van az arr egész szám és egy k egész szám, akkor adja vissza az arr első k elemének legfeljebb két számjeggyel rendelkező elemeinek összegét. Például: bemenet: arr = [111,21,3,4000,5,6,7,8,9], k = 4 kimenet: 24 # 21 + 3 összeg Korlátozások: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,hun_Latn,python,"
def get_odd_collatz(n):
    """"""A Collatz-telet egy matematikai telet, amely a következőképpen definiált sorrendet érinti: kezdjük bármely pozitív egész szám n-vel. Ezután minden kifejezést az előző kifejezésből az alábbiak szerint kapjuk: ha az előző kifejezés páros, a következő kifejezés az előző kifejezés fele. Ha az előző kifejezés páratlan, a következő kifejezés az előző kifejezés 3szerese plusz 1. A telet az, hogy nem számít, hogy mekkora az n értéke, a sorrend mindig elér 1. Megjegyzés: 1. Collatz(1) [1] 2. Visszatért sorrendben sorolt lista. Például: get_odd_collatz(5) [1, 5] Visszatér 5 # A Collatz sorrend az 5 [5, 8, 16, 4, 2, 1], így a páratlan számok csak 1, és 5 """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,hun_Latn,python,"
def valid_date(date):
    """"""Írjon egy olyan függvényt, amely érvényesíti az adott dátumláncot és az Igazat adja vissza, ha a dátum érvényes, máskülönben Téves. A dátum érvényes, ha az alábbi szabályok mindegyike teljesül: 1. A dátumlánc nem üres. 2. A napok száma nem kevesebb, mint 1 vagy több, mint 31 nap a hónapok esetében 1,3,5,7,8,10,12. És a napok száma nem kevesebb, mint 1 vagy több, mint 30 nap a hónapok esetében 4,6,9,11. És a napok száma nem kevesebb, mint 1 vagy több, mint 29 a hónap esetében 2. 3. A hónapok száma nem lehet kevesebb, mint 1 vagy több, mint 12. 4. A dátumnak a következő formátumban kell lennie: mm-dd-yyyy-yy például: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-02040') => False_valid_date (('06-04-2020') => True_valid_date (('06/04/2020') => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,hun_Latn,python,"
def split_words(txt):
    '''Ha egy szólánc megadva van, adja vissza a szavak listáját, a szószakaszokat elosztva, ha nincs szószakasz a szövegben, akkor a szöveget vesszővel kell elosztani, ha nincs vessző, akkor a kisbetűk számát kell visszaküldeni a páratlan sorrendben az ábécében, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 Példák split_words (hello world!) â -> [""Hello"", ""world!""] split_words (hello,world!"") â -> [""Hello"", ""world!"" split_words (abcdef)) == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,hun_Latn,python,"
def is_sorted(lst):
    '''Ha egy számlistát kapunk, akkor azt kell visszaküldeni, hogy azok felfelé soroltak-e vagy sem. Ha a listában egyazon szám több mint egy másolata van, akkor a False-t kell visszaküldeni. Ne vegyünk negatív számokat, csak egész számokat. Példák: is_sorted (a) -> True is_sorted (a) [1, 2, 3, 4, 5]) -> True is_sorted (a) [1, 2, 3, 4, 5, 6]) -> True is_sorted (a) [1, 2, 3, 4, 5, 6, 7]) -> True is_sorted (a) [1, 3, 2, 4, 5, 6, 7]) -> True is_sorted (a) [1, 3, 2, 4, 5, 6, 7]) -> False is_sorted (a) [1, 2, 2, 3, 3, 4]) -> True is_sorted (a) [1, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,hun_Latn,python,"
def intersection(interval1, interval2):
    """"""A két intervallum egy egész szám párja. Például: intervallum = (kezdés, vég) = (1, 2). A megadott intervallumok zárt, ami azt jelenti, hogy az intervallum (kezdés, vég) tartalmazza mind a kezdetet, mind a véget. Minden adott intervallum esetében feltételezzük, hogy a kezdet kisebb vagy egyenlő a végével. A feladatunk az, hogy meghatározzuk, hogy a két intervallum kereszteződésének hossza prímszám-e. Például: az intervallumok (1, 3), (2, 4) kereszteződésének hossza (2, 3) az 1, ami nem prímszám. Ha a kereszteződés hossza prímszám, akkor adja vissza az ""Igen"", máskülönben adja vissza a ""Nem"". Ha a két intervallum nem kereszteződik, adja vissza a ""Nem""-et. [input/output] minták: kereszteződés (((1, 2), (2, 3) ==> ""kereszteződés"" ((1, 1) ""Igen"") == ""kereszteződés"" (=== (0, NO) - 5), ""(1, 5"", ((((5, ""Igen"")""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,hun_Latn,python,"
def prod_signs(arr):
    """"""Egy egész számokból álló tömbet kapunk, és a teljes számok nagyságának összegét kell megadni, amit az összes számjegy szorzata szoroz az egész számok tömbében, 1, -1 vagy 0-val. Megjegyzés: nullát kell adni az üres tömbre. Például: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) ==  Nincs""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,hun_Latn,python,"
def minPath(grid, k):
    """"""Ha egy rácsban N sor és N oszlop van (N >= 2), és minden cellája k pozitív egész szám, akkor minden cellája tartalmaz egy értéket. Minden egész szám a [1, N * N] tartományban pontosan egyszer jelenik meg a rács sejtjein. Meg kell találnod a minimális k hosszúságú utat a rácsban. Bármelyik cellából indulhatsz, és minden lépésnél a szomszédos sejtek bármelyikére mozoghatsz, más szavakkal, olyan sejtekbe mehetsz, amelyek egy széle van a jelenlegi sejteddel. Kérjük, vegye figyelembe, hogy a k hosszúságú út pontosan k sejtet jelent (nem feltétlenül különböző). NEM mehet ki a rácsból. Egy A (k hosszúságú) út kisebb, mint egy B (k hosszúságú) út, ha az A és B (nevezzük őket l_A és l_A) sejtjein lévő értékek rendezett listájának elkészlése után a rácsban szókincsen kevesebb, mint az l_A és B (l_A és l_A) sejtjein belül található értékek) az egész rácsban. A rácsban minden cellákban megtalálható a minimális k k hosszúságú út, vagy a rácsban található cellákhoz képestől.""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,hun_Latn,python,"
def tri(n):
    """"""A Fibonacci-szekvenciát mindenki ismeri, a matematikusok az elmúlt néhány évszázadban mélyen tanulmányozták. Azonban amit az emberek nem ismernek, az a Tribonacci-szekvenciát. A Tribonacci-szekvenciát az ismétlődés határozza meg: tri(1) = 3 tri(n) = 1 + n / 2, ha n páros. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ha n páratlan. Például: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Adunk egy nem negatív egész számot n, vissza kell adnunk a Tribonacci-szekvenciának első n + 1 számának listáját. Példák: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,hun_Latn,python,"
def digits(n):
    """"""Ha egy n pozitív egész számot adunk, akkor a páratlan számjegyek szorzata. Ha minden számjegy páros, akkor 0-t adunk. Például: számjegyek(1) == 1 számjegy(4) == 0 számjegy(235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,hun_Latn,python,"
def is_nested(string):
    '''Hozzon létre egy olyan függvényt, amely csak négyzetkötőket tartalmazó sorokat veszi be. A függvénynek akkor és csak akkor kell True-t visszaadnia, ha és csak akkor van egy érvényes zárójel-sorozat, ahol legalább egy zárójel a zárójel-sorozatban van beágyazva. is_nested (('[[]]') â -> True is_nested (('[]]]]]]]]] [[[[[[[[]]]]') â -> False is_nested (('[][]') â -> False is_nested (('[]') â -> False is_nested (('[[]]') â -> True is_nested (('[[]]') â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,hun_Latn,python,"

def sum_squares(lst):
    """"""A számok listája van. Vissza kell adnia a megadott lista négyzetén lévő számok összegét, először kerekítse be a lista minden elemét a felső int-re. Példák: lst = [1,2,3] kimenete 14 lst = [1,4,9] kimenete 98 lst = [1,3,5,7] kimenete 84 lst = [1.4,4.2,0] kimenete 29 lst = [-2.4,1,1] kimenete 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,hun_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Olyan függvényt hozzunk létre, amely Ha egy adott karakterlánc utolsó karaktere egy ábécébeli karakter, és nem egy szó része, akkor az Igaz, és egyébként Hazug. Megjegyzés: ""szó"" egy térrel elválasztott karaktercsoport. Példák: check_if_last_char_is_a_letter (((""alma pité"") â -> Hazug check_if_last_char_is_a_letter (((alma pité"") â -> Hazug check_if_last_char_is_a_letter (((alma pité)) â -> Hazug check_if_last_char_is_a_letter "" (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((('''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,hun_Latn,python,"
def can_arrange(arr):
    """"""Hozzon létre egy olyan függvényt, amely olyan elem legnagyobb indexét adja vissza, amely nem nagyobb vagy egyenlő az közvetlenül előtte lévő elemnél. Ha ilyen elem nem létezik, akkor adja vissza a -1-et. Az adott tömb nem tartalmaz duplikált értékeket. Példák: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,hun_Latn,python,"
def largest_smallest_integers(lst):
    '''Hozzon létre egy olyan függvényt, amely egy tuplumot (a, b) ad vissza, ahol az a a negatív egész számok közül a legnagyobb, a b pedig a pozitív egész számok közül a legkisebb. Ha nincsenek negatív vagy pozitív egész számok, akkor a nullát adja vissza. Példák: legnagyobb_legrövidebb_egész számok[2, 4, 1, 3, 5, 7]) == (Nincsen, 1) legnagyobb_legrövidebb_egész számok([]) == (Nincsen, 1) legnagyobb_legrövidebb_egész számok[0]) == (Nincsen, Nincsen) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,hun_Latn,python,"
def compare_one(a, b):
    """"""Hozzon létre egy olyan függvényt, amely a valós számokat reprezentáló egész számokat, lebegő számokat vagy sztringeket veszi és a nagyobb változót megadott változótípusában adja vissza. Ha az értékek egyenlőek, akkor a nullát adja vissza. Megjegyzés: Ha egy valós számot sztringként mutatnak be, a lebegő pont lehet . vagy , compare_one{1,2,5} -> 2.5 compare_one{1,2,3}) -> ""2,3"" compare_one{5,1}"", ""6"") -> ""6"" compare_one{1}"", 1) -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,hun_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Értékelje, hogy az adott n szám pontosan 4 pozitív páros szám összegeként írható-e be. Például: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő: egyenlő""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,hun_Latn,python,"
def special_factorial(n):
    """"""A brazil faktoriál a következőképpen definiálható: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! ahol n > 0 Például: >>> special_factorial(4) 288 A függvény bevitelként egy egész számot kap, és ennek a teljes számnak a speciális faktoriálját kell visszaadnia. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,hun_Latn,python,"
def fix_spaces(text):
    """"""_Példátum-3ban több mint két egymást követő hely van, akkor a helyét a következők töltik ki: - fix_spaces (((""Példány"") == ""Példány"" fix_spaces (((""Példány1"") == ""Példány1"" fix_spaces (((""Példány2"") == ""Példány_2"" fix_spaces (((""Példány 3"") == ""Példány-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,hun_Latn,python,"
def file_name_check(file_name):
    """"""Hozzon létre egy olyan függvényt, amely egy fájl nevét reprezentáló karakterláncot vesz, és ha a fájl neve érvényes, akkor ""Igen"", ha nem, akkor ""Nem"" jelzést ad. Egy fájl neve akkor és csak akkor tekinthető érvényesnek, ha az alábbi feltételek teljesülnek: - A fájl nevében nem lehet több, mint három számjegy ('0'-'9'). - A fájl neve pontosan egy pontot tartalmaz '.' - A pont előtti allánc nem lehet üres, és a latin betűkkel kezdődik ('a'-'z' és 'A'Z'). - A pontot követő alláncnak az alábbiak valamelyikével kell kezdődnie: ['txt', 'exe', 'lld'] Példak: file_name_check""(example.txt"") # => 'Igen' => 'file_name_check""(example.dll1"") # => 'Nem' (a név latin betűkkel kell kezdődnie)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,hun_Latn,python,"


def sum_squares(lst):
    """""""" Ez a függvény egy egész számok listáját veszi. A listában lévő összes bejegyzés esetében a függvény négyzetre emeli a teljes számot, ha az index 3-as, és a teljes számot köbké teszi, ha az index 4-es, és nem 3-as, a függvény nem változtatja meg a listában lévő bejegyzéseket, ha az index nem 3-as vagy 4-es. A függvény azután minden bejegyzés összegét adja vissza. Példák: lst = [1,2,3] kimenete 6 lst = [] kimenete 0 lst = [-1,-5,2,-1,-5] kimenete -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,hun_Latn,python,"
def words_in_sentence(sentence):
    """"""Egy mondatot ábrázoló húr van megadva, a mondat néhány szót tartalmaz, amelyeket egy űr választ el, és vissza kell adnia egy húrot, amely tartalmazza az eredeti mondat szavaiit, amelyek hosszúsága prímszámok, az új húr szavai sorrendjének meg kell felelnie az eredetinek. Például1: Bevitel: mondat = ""Ez egy teszt"" Kivitel: ""az"" Például2: Bevitel: mondat = ""megyünk úszni"" Kivitel: ""megyünk"" Korlátozások: * 1 <= len(mondat) <= 100 * A mondat csak betűket tartalmaz """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,hun_Latn,python,"
def simplify(x, n):
    """"""A feladatunk az, hogy egy olyan függvényt valósítsunk meg, amely egyszerűsíti az x * n kifejezést. A függvény akkor ad vissza Valót, ha x * n egész számra értékelik, és Hazug, ha nem. Mind az x, mind az n egy töredék sztringjelzése, és a következő formátummal rendelkezik, <számláló>/<nevényező>, ahol mind a számláló, mind a nevező pozitív egész számok. Feltételezhetjük, hogy az x és az n érvényes töredékek, és nem nulla a nevező. egyszerűsítse:""""""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,hun_Latn,python,"
def order_by_points(nums):
    """"""Írjunk egy olyan függvényt, amely a teljes számok megadott listáját emelkedő sorrendben rendezi a számjegyek összegének megfelelően. Megjegyzés: ha több elem van, amelyek azonos számjegyeinek összegével, rendezzük őket az eredeti lista indexje alapján. Például: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,hun_Latn,python,"
def specialFilter(nums):
    """"""Írjunk egy olyan függvényt, amely a számok sorát veszi be, és olyan elemek számát adja vissza, amelyek nagyobbak, mint 10, és egy szám első és utolsó számjegye páratlan (1, 3, 5, 7, 9). Például: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,hun_Latn,python,"
def get_max_triples(n):
    """"""Egy pozitív egész szám n van. Egy egész szám-mátrixot kell létrehoznunk, amelynek hossza n. Minden i (1 ‰¤ i ‰¤ n) számára a [i] = i * i - i + 1. Adja vissza az a hármasok számát (a [i], a [j], a [k]) ahol i < j < k, és az a [i] + a [j] + a [k] a 3-as többszöröse. Például: bemenet: n = 5 kimenet: 1 magyarázat: a = [1, 3, 7, 13, 21] Az egyetlen érvényes hármas (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,hun_Latn,python,"
def bf(planet1, planet2):
    '''Naprendszerünkben nyolc bolygó van: a Naphoz legközelebb lévő a Merkúr, a következő a Vénusz, majd a Föld, a Mars, a Jupiter, a Szaturnusz, az Uránusz, a Neptunusz. Írjunk egy olyan függvényt, amely két bolygó nevét veszi a planet1 és a planet2 sztringeként. A függvénynek egy tuplát kell adnia, amely tartalmazza az összes bolygót, amelyek pályái a planet1 és a planet2 pályája között találhatók, a Nap közelsége szerint rendezve. A függvénynek egy üres tuplát kell adnia, ha a planet1 vagy a planet2 nem a helyes bolygónév. Például bf""(Jupiter"", ""Neptunusz"") ==> (""Szaturnusz"", ""Uranusz"") bf("" Föld"", ""Merkurusz"") ==> (""Vénusz"") bf(""Merkurusz"", ""Uranusz"") ==> (""Vénusz"", ""Föld"", ""Mars"", ""Jupiter"", ""Szaturnusz"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,hun_Latn,python,"
def sorted_list_sum(lst):
    """"""Írjunk egy olyan függvényt, amely elfogadja a szalagok listáját paraméternek, törli a páratlan hosszúságú szalagokat, és rendezett sorrendben adja vissza az eredményt. A lista mindig egy szalaglista, és soha nem egy számok tömbje, és lehet, hogy duplikátumokat tartalmaz. A lista sorrendjének felfelé kell emelkednie az egyes szavak hosszúsága szerint, és a listát ennek a szabálynak megfelelően kell rendezni. Ha két szó azonos hosszúságú, sorolja a listát alfabetikus sorrendben. A függvénynek sorolt sorrendben kell visszaadnia a szalagok listáját. Feltételezhetjük, hogy minden szó ugyanolyan hosszúságú lesz. Például: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ab"")""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,hun_Latn,python,"
def x_or_y(n, x, y):
    """"""Egy egyszerű program, amely visszaadja az x értékét, ha n prímszám, és máskülönben visszaadja az y értékét. Példák: x_or_y(7, 34, 12) == 34 x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,hun_Latn,python,"
def double_the_difference(lst):
    '''Adott számok listája, adja vissza a listában lévő páratlan számok négyzetének összegét. Felejtsd el a negatív vagy nem egész számokat. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Ha a bemeneti lista üres, adja vissza a 0-t. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,hun_Latn,python,"
def compare(game,guess):
    """"""Azt hiszem, mindannyian emlékszünk arra az érzésre, amikor egy régóta várt esemény eredménye végre ismert. Az abban a pillanatban érzett érzések és gondolatok biztosan érdemes feljegyezni és összehasonlítani. A feladatod az, hogy eldöntsd, hogy egy személy helyesen találta-e ki a több mérkőzés eredményét. Két egyenlő hosszúságú pontszám és találgatás társult, ahol minden index egy mérkőzést mutat. Visszaad egy azonos hosszúságú társulatot, amely jelzi, hogy milyen messze volt az egyes tippek. Ha helyesen találták ki, az érték 0, és ha nem, az érték a tipp és a pontszám közötti abszolút különbség. Például: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,2,4]) -> [4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,hun_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""A kiterjesztés ereje a következő: A CAP legyen a kiterjesztés nevében lévő nagybetűk száma, és az SM legyen a kiterjesztés nevében lévő kisbetűk száma, az erő a CAP - SM töredékkel adódik. Meg kell találnia a legerősebb kiterjesztést, és egy olyan sort kell visszaküldeni, amely az alábbi formátumban jelenik meg: ClassName.StrongestExtensionName. Ha két vagy több kiterjesztés azonos erővel rendelkezik, akkor azt kell választania, amelyik az első a listában. Például, ha ""Slices"" az osztály és a kiterjesztések listája: ['SEviviviSNGCes', 'Cheese', 'StuFfed'], akkor vissza kell adnia a 'Slices.SEviviSNGCes' és a 'SviviSNGCes' betűket, mivel a kiterjesztés neve a legerősebb. (Akk_Extension: 'AA_Beats'), például 'AA_Beats' (Legősebb erő: 'AA_Class'), mivel a kiterjesztés erőssége az 'AA_Beats' (Legősebb erősség: 'AA_Extension');""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,hun_Latn,python,"
def cycpattern_check(a , b):
    """"""Két szó van megadva. Ha a második szó vagy bármelyik forgatása az első szó allánca, akkor a True értékét kell megadnia. cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((whassup"",""psus"") => False cycpattern_check (((abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,hun_Latn,python,"
def even_odd_count(num):
    """"""Egy egész szám megadása esetén egy páros és páratlan számjegyeket tartalmazó tuplust ad vissza. Például: páros_egyenetlen_szám(-12) ==> (1, 1) páros_egyenetlen_szám(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,hun_Latn,python,"
def int_to_mini_roman(number):
    """"""Ha pozitív egész számot kapunk, szerezzük meg a római számok egyenértékét, és kisbetűvel küldjük vissza.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,hun_Latn,python,"
def right_angle_triangle(a, b, c):
    '''A háromszög három oldalának hosszát megadva. Ha a három oldal egy jobbszögű háromszöget alkot, akkor az Igaz, máskülönben a Téves. Egy jobbszögű háromszög olyan háromszög, amelyben az egyik szög a jobbszög vagy 90 fok. Például: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == Téves '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,hun_Latn,python,"
def find_max(words):
    """"""Írjunk egy olyan funkciót, amely elfogadja a szalagok listáját. A lista különböző szavakat tartalmaz. Visszaadja a szót, amely a legmagasabb számú egyedi karakterrel rendelkezik. Ha több szalagban van a legmagasabb számú egyedi karakter, adja vissza azt, amelyik a lexikográfiai sorrendben az első.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,hun_Latn,python,"
def eat(number, need, remaining):
    """"""Te egy éhes nyúl vagy, és már egy bizonyos számú répát ettél, de most még több répát kell enned, hogy befejezd a napi étkezést. Adj vissza egy [ teljes számú elfogyasztott répát étkezés után, a maradék répák száma étkezés után ] matricát, ha nincs elég maradék répát, akkor megeszed az összes maradék répát, de még mindig éhes leszel. Például: * enni ((5, 6, 10) -> [11, 4] * enni ((4, 8, 9) -> [12, 1] * enni ((1, 10, 10) -> [11, 0] * enni ((2, 11, 5) -> [7, 0] Variablek: @szám: egész számú répát, amit ettél. @szükséglet: egész számú répát, amit meg kell enni. @maradék: egész számú maradék répát a készletben.""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,hun_Latn,python,"
def do_algebra(operator, operand):
    """"""Az első listában az alap algebrai műveletek vannak, a második listában pedig a teljes számok listája. Használja a két listát az algebrai kifejezés létrehozásához és adja vissza a kifejezés értékét. Az alap algebrai műveletek: Összeadás (+) Levonás (-)) Szorozás (*) Lépcsőosztás (//) Képesítés (**) Például: operátor['+', '*', '-'] tömb = [2, 3, 4, 5] eredmény = 2 + 3 * 4 - 5 => eredmény = 9 Megjegyzés: Az operátorok listájának hossza egyenlő az operand listájának hossza mínusz egy. Az operand nem negatív egész számok listája. Az operátornak legalább egy operátor listája van, és az operand listának legalább két operandja van.""""""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,hun_Latn,python,"
def solve(s):
    """"""Ha a s[i] egy betű, fordítsa a betűt az alsó betűtől a felső betűig, vagy fordítva, máskülönben tartsa meg. Ha a string nem tartalmaz betűket, fordítsa meg a stringet. A függvénynek vissza kell adnia az eredményt. Példák megoldás ((""1234"") = ""4321"" megoldás (((""ab"") = ""AB"" megoldás (((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,hun_Latn,python,"
def string_to_md5(text):
    """"""Ha a 'text' egy üres string, akkor a None-t adja vissza. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,hun_Latn,python,"
def generate_integers(a, b):
    """"""Két pozitív egész szám a és b esetén a és b közötti páros számjegyeket emelkedő sorrendben adja vissza. Például: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
