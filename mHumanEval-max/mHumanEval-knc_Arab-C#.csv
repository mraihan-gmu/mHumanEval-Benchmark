task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //عَتَبَةٌ مَعْطُوَةٌ    //تَفَقَّدْ إنْ كَانَ في قائمة الأرقام المُعطَاة، أيّ رقمين أقرب لَبَعْضهم مِنْ     // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))
    // (false)
    // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))
    // (true)
    public static bool HasCloseElements(List<float> numbers, float threshold) {
","public static bool HasCloseElements(List<float> numbers, float threshold) {
    numbers.Sort();
    for (int i = 1; i < numbers.Count; i++) {
        if (numbers[i] - numbers[i - 1] < threshold) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
    }

}
"
HumanEval_1,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَجَاهَلْ أَيّ فُرُوج فِي سِلْسِلَةِ الإِدْخَال.    //فَمَا بَيْنَهُمَا مِنْ فَرْقٍ وَلَا بَيْنَهُمَا مِنْ فَرْقٍ    //يَفْصِلُ هَذِهِ المَجْمُوعَاتِ إلى سِلَالَاتٍ مُفَرَّدَةٍ وَيَرُدُّ قِيمَةَ هَذِهِ.    //دَخَلَتْ هَذِهِ الوَظِيفَةُ سِلْسِلَةً مَوْضُوعَةً بِجَمَاعَاتٍ مِنْ قُرُونٍ مُتَعَدِّدَةٍ.    // >>> SeparateParenGroups((""( ) (( )) (( )( ))""))
    // (new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))
    public static List<string> SeparateParenGroups(string paren_string) {
","public static List<string> SeparateParenGroups(string paren_string) {
        List<string> result = new List<string>();
        StringBuilder currentGroup = new StringBuilder();
        int balance = 0;

        foreach (char c in paren_string) {
            if (c == ' ') {
                continue;
            }

            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }

            currentGroup.Append(c);

            // When balance is zero, we have a complete group
            if (balance == 0 && currentGroup.Length > 0) {
                result.Add(currentGroup.ToString());
                currentGroup.Clear();
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SeparateParenGroups((""(()()) ((())) () ((())()())"")).Equals((new List<string>(new string[]{(string)""(()())"", (string)""((()))"", (string)""()"", (string)""((())()())""}))));
    Debug.Assert(SeparateParenGroups((""() (()) ((())) (((())))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""((()))"", (string)""(((())))""}))));
    Debug.Assert(SeparateParenGroups((""(()(())((())))"")).Equals((new List<string>(new string[]{(string)""(()(())((())))""}))));
    Debug.Assert(SeparateParenGroups((""( ) (( )) (( )( ))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))));
    }

}
"
HumanEval_2,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدْ عَشْرَةَ أَوْسَطَ مِنْ الْعَدَدِ.    //(بَقِيَّةُ الْجُزْءِ دَائِمًا أَصْغَرُ مِنْ 1).    //وَجُزْءُ سَمِيْرٍ (أَكْبَرُ سَمِيْرٍ أَصْغَرُ مِنْ عَدَدٍ مَعْطُوْدٍ) وَعَشَرِيَّاتٍ    //مُعْطَى عَدَدِ مُوجِبِ الْعَدَدِ الْمُتَغَيِّرِ، يُمْكِنُ تَحْلِيلُهُ إِلَى    // >>> TruncateNumber((3.5f))
    // (0.5f)
    public static float TruncateNumber(float number) {
","using System;

class Problem {
    // Given a positive floating point number, it can be decomposed into
    // an integer part (largest integer smaller than the given number) and decimals
    // (leftover part always smaller than 1).
    // Return the decimal part of the number.
    public static float TruncateNumber(float number) {
        return number - (float)Math.Floor(number);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TruncateNumber((3.5f)) == (0.5f));
    Debug.Assert(TruncateNumber((1.25f)) == (0.25f));
    Debug.Assert(TruncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //فَيَجِبُ أَنْ تَرُدَّ فِي تِلْكَ النَّهْيِ صَحِيحًا. وَإِلَّا فَيَرُدُّ كَذِبًا.    //مَسْؤُولَتُكَ تَكْشِفُ إنْ هَبَطَ رَصِيدُ الحَسَبِ أَيَّةً مَرَّةً تَحْتَ الصِفَةِ، و    //تُعْطَى قِائِمَةُ عملياتِ الإيداعِ والسَحْبِ في حسابِ بنكي يَبْدأُ بِ    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (false)
    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L})))
    // (true)
    public static bool BelowZero(List<long> operations) {
","long balance = 0;
    foreach (var operation in operations) {
        balance += operation;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowZero((new List<long>())) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-3L, (long)1L, (long)2L, (long)-3L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-5L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-2L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (true));
    }

}
"
HumanEval_4,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَدْ = مَدَدْ. x - x_مَدَدْ.    //وَمَوْضِعٌ وَنُصْبٌ (مَعْنَى فِي هَذِهِ الْحَالِ):    //مَعْنَى مُبَرَّدِ الْمَحِيلِ هُوَ الْمُبَرَّدُ الْمُتَعَدِّدُ بَيْنَ كُلِّ    //مَعْنَى مِنْ هَذِهِ المَعْدُودَةِ    //لِقَائِمِ مَعْطُوفِ أَرْبَابِ الدَّخْلِ، حَسْبُوا الْمُتَعَدِّدَ الْمُطْلَقَ     // >>> MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))
    // (1.0f)
    public static float MeanAbsoluteDeviation(List<float> numbers) {
","if (numbers == null || numbers.Count == 0)
    {
        throw new ArgumentException(""The list of numbers must not be null or empty."");
    }
    
    float sum = 0.0f;
    foreach (float number in numbers)
    {
        sum += number;
    }

    float mean = sum / numbers.Count;
    float absoluteDeviationSum = 0.0f;
    
    foreach (float number in numbers)
    {
        absoluteDeviationSum += Math.Abs(number - mean);
    }
    
    float meanAbsoluteDeviation = absoluteDeviationSum / numbers.Count;
    return meanAbsoluteDeviation;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f}))) == (0.5f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
    }

}
"
HumanEval_5,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //إدْخُلْ عَدَدَ ""دَلِيمِيْتِر"" بَيْنَ كُلِّ عَنْصَرَيْنِ مُتَتَابِعَيْنِ مِنْ قِيَاسِ الإِدْخَالِ ∀numbers""     // >>> Intersperse((new List<long>()), (4L))
    // (new List<long>())
    // >>> Intersperse((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (4L))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)4L, (long)3L}))
    public static List<long> Intersperse(List<long> numbers, long delimeter) {
","public static List<long> Intersperse(List<long> numbers, long delimeter)
{
    List<long> result = new List<long>();

    if (numbers == null || numbers.Count == 0)
    {
        return result;
    }

    for (int i = 0; i < numbers.Count; i++)
    {
        result.Add(numbers[i]);
        if (i < numbers.Count - 1)
        {
            result.Add(delimeter);
        }
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersperse((new List<long>()), (7L)).Equals((new List<long>())));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)2L})), (8L)).Equals((new List<long>(new long[]{(long)5L, (long)8L, (long)6L, (long)8L, (long)3L, (long)8L, (long)2L}))));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)2L, (long)2L, (long)2L})), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L, (long)2L, (long)2L}))));
    }

}
"
HumanEval_6,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثْلَ (() (()) لَهُ كَثِيرُهُمَا مَرَاتِبُ التَّعَشُّشِ وَلِ ((())) ثَلَاثٌ.    //لِكُلِّ مِنْ المَعْمُولَةِ، أَخْرِجْ أَعْمَقَ مَنْطِقِ قُرْبَانٍ.    //دَخَلَتْ هَذِهِ الوَظِيفَةُ سِلْسِلَةٌ تَمْثِلُ جَمَاعَاتٍ لِقُفَّاتٍ مُتَوَسِّطَةٍ مُفَرَّقَةٍ بِسَفَرٍ.    // >>> ParseNestedParens((""(()()) ((())) () ((())()())""))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))
    public static List<long> ParseNestedParens(string paren_string) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> ParseNestedParens(string paren_string) {
        List<long> nestingLevels = new List<long>();
        string[] groups = paren_string.Split(' ');

        foreach (string group in groups) {
            long currentLevel = 0;
            long maxLevel = 0;

            foreach (char c in group) {
                if (c == '(') {
                    currentLevel++;
                    if (currentLevel > maxLevel) {
                        maxLevel = currentLevel;
                    }
                } else if (c == ')') {
                    currentLevel--;
                }
            }

            nestingLevels.Add(maxLevel);
        }

        return nestingLevels;
    }

    static void Main(string[] args) {
        string input = ""(()()) ((())) () ((())()())"";
        List<long> result = ParseNestedParens(input);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseNestedParens((""(()()) ((())) () ((())()())"")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(ParseNestedParens((""() (()) ((())) (((())))"")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(ParseNestedParens((""(()(())((())))"")).Equals((new List<long>(new long[]{(long)4L}))));
    }

}
"
HumanEval_7,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَفْتِيلُ قِيمَةَ السِّلَالِ الْمُدْخَلَةِ لِلْمُدْخَلَاتِ الَّتِي تَحْتَ سِلْسِلَةٍ مَعْطُوَّةٍ    // >>> FilterBySubstring((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterBySubstring((new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""array""}))
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
        List<string> result = new List<string>();
        foreach (string str in strings) {
            if (str.Contains(substring)) {
                result.Add(str);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterBySubstring((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""aaaxxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""aaaxxy"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""grunt"", (string)""trumpet"", (string)""prune"", (string)""gruesome""})), (""run"")).Equals((new List<string>(new string[]{(string)""grunt"", (string)""prune""}))));
    }

}
"
HumanEval_8,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //فَيَجِبُ أَنْ يَكُونَ الجُمْلُ فَارِغًا وَالْمُتَجَرِّدُ فَارِغًا.    //لِقَائِمِ مَعْطُوفِ مِنْ أَعْدَادِ، ارْجِعْ تَبْلَاً مَعْقُولَةً مِنْ جُمْلَةٍ وَنَاتِجِ كُلِّ أَعْدَادِ فِي قَائِمٍ.    // >>> SumProduct((new List<long>()))
    // (Tuple.Create(0L, 1L))
    // >>> SumProduct((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (Tuple.Create(10L, 24L))
    public static Tuple<long, long> SumProduct(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<long, long> SumProduct(List<long> numbers) {
        long sum = 0L;
        long product = 1L;

        foreach (var number in numbers) {
            sum += number;
            product *= number;
        }

        return Tuple.Create(sum, product);
    }

    static void Main(string[] args) {
        // Test cases
        var result1 = SumProduct(new List<long>());
        Console.WriteLine($""({result1.Item1}, {result1.Item2})""); // Should output (0, 1)

        var result2 = SumProduct(new List<long> { 1L, 2L, 3L, 4L });
        Console.WriteLine($""({result2.Item1}, {result2.Item2})""); // Should output (10, 24)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumProduct((new List<long>())).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)1L, (long)1L, (long)1L}))).Equals((Tuple.Create(3L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)100L, (long)0L}))).Equals((Tuple.Create(100L, 0L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))).Equals((Tuple.Create(15L, 105L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)10L}))).Equals((Tuple.Create(10L, 10L))));
    }

}
"
HumanEval_9,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //في التَسلسلِ    //مِنْ قِيمَةِ سَمَائِلِ أَعْدَادٍ، أَصْنَعْ قِيمَةَ أَكْثَرِ عَنْصَرَةٍ مَوْجُودَةٍ إِلَى حِينٍ مَوْجُودٍ.    // >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))
    public static List<long> RollingMax(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> RollingMax(List<long> numbers) {
        List<long> rollingMaxList = new List<long>();
        long currentMax = long.MinValue;

        foreach (var number in numbers) {
            if (number > currentMax) {
                currentMax = number;
            }
            rollingMaxList.Add(currentMax);
        }

        return rollingMaxList;
    }

    public static void Main(string[] args) {
        List<long> numbers = new List<long> { 1L, 2L, 3L, 2L, 3L, 4L, 2L };
        List<long> result = RollingMax(numbers);
        Console.WriteLine(""Rolling Max: "" + string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RollingMax((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));
    }

}
"
HumanEval_10,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //- ضَمْ لِنهايةِ السلسلةِ عَكسيّةِ سِلسلةِ بَادِئَةٍ تَأتي قبلَ اللَّحْدَةِ الْمُتَكَلِّمَةِ.    //- أَعْثِرْ أَطْوَلَ بَعْدَ الْمُتَعَلِّقِ مِنْ السَّلَسِلِ الْمُقَدَّمِ الَّذِي هُوَ بَالِندْرُومٌ.    //فكرةَ الخُوارِجِمَةَ بسيطةٌ:    //تَجِدْ أَقْصَرَ حَالِدٍ يَبْدَأُ بِخَطِّ مَوْضُوعٍ.    // >>> MakePalindrome((""""))
    // ("""")
    // >>> MakePalindrome((""cat""))
    // (""catac"")
    // >>> MakePalindrome((""cata""))
    // (""catac"")
    public static string MakePalindrome(string str) {
","if (string.IsNullOrEmpty(str)) return str;

    int maxPalindromeLength = 0;
    for (int i = 0; i < str.Length; i++) {
        if (IsPalindrome(str, i, str.Length - 1)) {
            maxPalindromeLength = str.Length - i;
            break;
        }
    }

    string suffixToPrepend = str.Substring(0, str.Length - maxPalindromeLength);
    char[] reversedPrefix = suffixToPrepend.Reverse().ToArray();
    return str + new string(reversedPrefix);
}

private static bool IsPalindrome(string str, int left, int right) {
    while (left < right) {
        if (str[left] != str[right]) return false;
        left++;
        right--;
    }
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakePalindrome(("""")).Equals(("""")));
    Debug.Assert(MakePalindrome((""x"")).Equals((""x"")));
    Debug.Assert(MakePalindrome((""xyz"")).Equals((""xyzyx"")));
    Debug.Assert(MakePalindrome((""xyx"")).Equals((""xyx"")));
    Debug.Assert(MakePalindrome((""jerry"")).Equals((""jerryrrej"")));
    }

}
"
HumanEval_11,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أَجْرُ ثَنِيَّةِ XOR عَلَى هَذِهِ الْمَدْخُولَاتِ وَيَرُدُّ النَّتِيجَةَ كَسِلْطَةٍ.    //دَخَلْنَا سِلْسِلَتَيْنِ a و b مَعْ 1 و 0    // >>> StringXor((""010""), (""110""))
    // (""100"")
    public static string StringXor(string a, string b) {
","if (a.Length != b.Length) {
        throw new ArgumentException(""Input strings must be of the same length."");
    }

    StringBuilder result = new StringBuilder(a.Length);

    for (int i = 0; i < a.Length; i++) {
        result.Append(a[i] == b[i] ? '0' : '1');
    }

    return result.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringXor((""111000""), (""101010"")).Equals((""010010"")));
    Debug.Assert(StringXor((""1""), (""1"")).Equals((""0"")));
    Debug.Assert(StringXor((""0101""), (""0000"")).Equals((""0101"")));
    }

}
"
HumanEval_12,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //سَلَسَلَةٍ مِنْ طُولٍ مُتَسَاوِي. رُدَّ null في الحَالِ الْمُدْخَلِيَّةِ فَارِغَةٌ.    //مِنْ قِيمَةِ السِّلَالِ، رُدَّ أَطْوَلَهُ. رُدَّ الأَوَّلَ فِي حَالِ مُتَعَدِّدِ     // >>> Longest((new List<string>()))
    // null
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""a"")
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""bb"", (string)""ccc""})))
    // (""ccc"")
    public static string Longest(List<string> strings) {
","if (strings == null || strings.Count == 0)
    {
        return null;
    }
    
    string longest = strings[0];
    
    foreach (string str in strings)
    {
        if (str.Length > longest.Length)
        {
            longest = str;
        }
    }
    
    return longest;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Longest((new List<string>())).Equals(null));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""x"")));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""yyy"", (string)""zzzz"", (string)""www"", (string)""kkkk"", (string)""abc""}))).Equals((""zzzz"")));
    }

}
"
HumanEval_13,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَعُودُ أَعْظَمَ مُقْسِمٍ مَشْهُورٍ لِعَدَدَيْنِ a و b     // >>> GreatestCommonDivisor((3L), (5L))
    // (1L)
    // >>> GreatestCommonDivisor((25L), (15L))
    // (5L)
    public static long GreatestCommonDivisor(long a, long b) {
","// Base case: if b is 0, gcd is a
    if (b == 0)
        return a;
    
    // Recursive call: gcd(a, b) = gcd(b, a % b)
    return GreatestCommonDivisor(b, a % b);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GreatestCommonDivisor((3L), (7L)) == (1L));
    Debug.Assert(GreatestCommonDivisor((10L), (15L)) == (5L));
    Debug.Assert(GreatestCommonDivisor((49L), (14L)) == (7L));
    Debug.Assert(GreatestCommonDivisor((144L), (60L)) == (12L));
    }

}
"
HumanEval_14,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرُدُّ قَائِمَةَ كُلِّ الْمُقَدِّمَاتِ مِنْ أَقْصَرِهَا إِلَى أَطْوَلِهَا مِنْ سِلْسِلَةِ الإِدْخَالِ    // >>> AllPrefixes((""abc""))
    // (new List<string>(new string[]{(string)""a"", (string)""ab"", (string)""abc""}))
    public static List<string> AllPrefixes(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list of all prefixes from shortest to longest of the input string
    public static List<string> AllPrefixes(string str) {
        List<string> prefixes = new List<string>();
        for (int i = 1; i <= str.Length; i++) {
            prefixes.Add(str.Substring(0, i));
        }
        return prefixes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AllPrefixes(("""")).Equals((new List<string>())));
    Debug.Assert(AllPrefixes((""asdfgh"")).Equals((new List<string>(new string[]{(string)""a"", (string)""as"", (string)""asd"", (string)""asdf"", (string)""asdfg"", (string)""asdfgh""}))));
    Debug.Assert(AllPrefixes((""WWW"")).Equals((new List<string>(new string[]{(string)""W"", (string)""WW"", (string)""WWW""}))));
    }

}
"
HumanEval_15,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرُدُّ سِلْسِلَةً مَعْدُودَةً بِأَرْضِ أَرْقَامٍ بِمُبْتَدَأٍ مِنْ 0 إِلَى n مَعًا.    // >>> StringSequence((0L))
    // (""0"")
    // >>> StringSequence((5L))
    // (""0 1 2 3 4 5"")
    public static string StringSequence(long n) {
","public static string StringSequence(long n) {
    StringBuilder sb = new StringBuilder();
    for (long i = 0; i <= n; i++) {
        if (i > 0) {
            sb.Append("" "");
        }
        sb.Append(i);
    }
    return sb.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringSequence((0L)).Equals((""0"")));
    Debug.Assert(StringSequence((3L)).Equals((""0 1 2 3"")));
    Debug.Assert(StringSequence((10L)).Equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَنْ أَعْطَى سِلْسِلَةً، فَاحْصُرْ كَمْ حَرْفٍ مُتَمَيِّزٍ (بِغَيْرِ حَالٍ) تَتَأَلَّفُ مِنْهَا    // >>> CountDistinctCharacters((""xyzXYZ""))
    // (3L)
    // >>> CountDistinctCharacters((""Jerry""))
    // (4L)
    public static long CountDistinctCharacters(string str) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long CountDistinctCharacters(string str) {
        // Convert the string to lower case to handle case insensitivity
        str = str.ToLower();

        // Use a HashSet to store distinct characters
        HashSet<char> distinctChars = new HashSet<char>(str);

        // Return the count of distinct characters
        return distinctChars.Count;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountDistinctCharacters(("""")) == (0L));
    Debug.Assert(CountDistinctCharacters((""abcde"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""abcdecadeCADE"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""aaaaAAAAaaaa"")) == (1L));
    Debug.Assert(CountDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5L));
    }

}
"
HumanEval_17,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //""تَكَوَّنَ"" - نُوتَةُ رباعِيَّة، تَدُومُ ضَرْبَةً وَاحِدَةً    //'o ""شَيْء"" - نِصْف نُوتَة، يَدُومُ ضَرْبَيْنِ     //'وَ' - نُوتَةٌ كُلُّهَا، تَدُومُ أَرْبَعَةَ ضَرْبَات     //هَاهُنَا أَسَاطِيرُ:    //لَيسَ آخِرَ.    //مَهْمَلُكَ هُوَ أنْ تُحَلِّلَ هذه السلسلةَ وتُرجِعَ قائمةَ أرقامٍ صحيحةٍ تُوافقُ كمْ ضربةٍ يَلْعَبُ كُلُّ واحدٍ مِنْها    //دَخَلَتْ هَذِهِ الوَظِيفَةُ سِلْسِلَةً تَمْثِلُ النُّوتَاتَ المُوسِيقِيَّةَ بِصُورَةٍ مُمَيِّزَةٍ بِالأَسْكِي.    // >>> ParseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (new List<long>(new long[]{(long)4L, (long)2L, (long)1L, (long)2L, (long)2L, (long)1L, (long)1L, (long)1L, (long)1L, (long)4L, (long)4L}))
    public static List<long> ParseMusic(string music_string) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> ParseMusic(string music_string)
    {
        List<long> beats = new List<long>();
        string[] notes = music_string.Split(' ');
        
        foreach (string note in notes)
        {
            switch (note)
            {
                case ""o"":
                    beats.Add(4L);
                    break;
                case ""o|"":
                    beats.Add(2L);
                    break;
                case "".|"":
                    beats.Add(1L);
                    break;
                default:
                    break;
            }
        }
        
        return beats;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseMusic(("""")).Equals((new List<long>())));
    Debug.Assert(ParseMusic((""o o o o"")).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic(("".| .| .| .|"")).Equals((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}))));
    Debug.Assert(ParseMusic((""o| o| .| .| o o o o"")).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)1L, (long)1L, (long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic((""o| .| o| .| o o| o o|"")).Equals((new List<long>(new long[]{(long)2L, (long)1L, (long)2L, (long)1L, (long)4L, (long)2L, (long)4L, (long)2L}))));
    }

}
"
HumanEval_18,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَجِدْ كَمْ مَرَّةٍ يُوجَدُ سُلْطَانٌ مُعَيَّنٌ فِي السُّلْطَانِ الأَصْلِيِّ. عُدَّ الْمَوَاقِعَ الْمُتَتَعَاوِنَةَ.    // >>> HowManyTimes((""""), (""a""))
    // (0L)
    // >>> HowManyTimes((""aaa""), (""a""))
    // (3L)
    // >>> HowManyTimes((""aaaa""), (""aa""))
    // (3L)
    public static long HowManyTimes(string str, string substring) {
","using System;

class Problem {
    public static long HowManyTimes(string str, string substring) {
        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) {
            return 0L;
        }

        long count = 0;
        int index = 0;

        while ((index = str.IndexOf(substring, index)) != -1) {
            count++;
            index++;
        }

        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(HowManyTimes(""aaa"", ""a"")); // Output: 3
        Console.WriteLine(HowManyTimes(""aaaa"", ""aa"")); // Output: 3
        Console.WriteLine(HowManyTimes("""", ""a"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HowManyTimes((""""), (""x"")) == (0L));
    Debug.Assert(HowManyTimes((""xyxyxyx""), (""x"")) == (4L));
    Debug.Assert(HowManyTimes((""cacacacac""), (""cac"")) == (4L));
    Debug.Assert(HowManyTimes((""john doe""), (""john"")) == (1L));
    }

}
"
HumanEval_19,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرُدُّ السلسلةَ بِالأرقامِ مُنَظَّمَةً مِنْ أصْغَرِهَا إلَى أكْبَرِهَا    //خُيُولٌ سَلِيمَةٌ: ""صَفْرٌ""، ""واحد""، ""اثنان""، ""ثلاثة""، ""أربعة""، ""خمسة""، ""ستة""، ""سبعة""، ""ثمانية"" و ""تسعة"".    //إِدْخَالٌ هُوَ سِلْسِلَةٌ مُحَدَّدَةٌ بِفَضاءٍ مِنَ الأَرقَامِ مِنْ ""صِفْرٍ"" إلى ""تِسْعٍ"".    // >>> SortNumbers((""three one five""))
    // (""one three five"")
    public static string SortNumbers(string numbers) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static string SortNumbers(string numbers)
    {
        Dictionary<string, int> numberWords = new Dictionary<string, int>
        {
            { ""zero"", 0 },
            { ""one"", 1 },
            { ""two"", 2 },
            { ""three"", 3 },
            { ""four"", 4 },
            { ""five"", 5 },
            { ""six"", 6 },
            { ""seven"", 7 },
            { ""eight"", 8 },
            { ""nine"", 9 }
        };

        List<string> numberList = new List<string>(numbers.Split(' '));
        numberList.Sort((a, b) => numberWords[a].CompareTo(numberWords[b]));
        return string.Join("" "", numberList);
    }

    static void Main(string[] args)
    {
        Console.WriteLine(SortNumbers(""three one five"")); // Output: ""one three five""
        Console.WriteLine(SortNumbers(""nine eight seven six"")); // Output: ""six seven eight nine""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortNumbers(("""")).Equals(("""")));
    Debug.Assert(SortNumbers((""three"")).Equals((""three"")));
    Debug.Assert(SortNumbers((""three five nine"")).Equals((""three five nine"")));
    Debug.Assert(SortNumbers((""five zero four seven nine eight"")).Equals((""zero four five seven eight nine"")));
    Debug.Assert(SortNumbers((""six five four three two one zero"")).Equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //وَرَدَّهُمْ بِالتَّرْتِيبِ (أَقَلَّ عَدَدًا، أَكْثَرَ عَدَدًا).    //مِنْ قِطَاعِ أَرْبَعَةِ أَرْبَعَةِ أَرْبَعَةٍ (مِنْ طُولِ أَقَلِّ اثْنَيْنِ) اخْتَارْ وَارْجِعْ اثْنَيْنِ أَقْرَبَ مِنْ كُلِّ وَاحِدٍ    // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))
    // (Tuple.Create(2.0f, 2.2f))
    // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))
    // (Tuple.Create(2.0f, 2.0f))
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
        if (numbers == null || numbers.Count < 2) {
            throw new ArgumentException(""List must contain at least two numbers."");
        }
        
        numbers.Sort();
        float minDifference = float.MaxValue;
        Tuple<float, float> closestPair = null;

        for (int i = 0; i < numbers.Count - 1; i++) {
            float difference = numbers[i + 1] - numbers[i];
            if (difference < minDifference) {
                minDifference = difference;
                closestPair = Tuple.Create(numbers[i], numbers[i + 1]);
            }
        }

        return closestPair;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(3.9f, 4.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))).Equals((Tuple.Create(5.0f, 5.9f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(2.0f, 2.2f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))).Equals((Tuple.Create(2.0f, 2.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))).Equals((Tuple.Create(2.2f, 3.1f))));
    }

}
"
HumanEval_21,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //كَيْ يَصِيرَ أصْغَرَ عَدَدٍ 0 وَأكْبَرَ عَدَدٍ 1     //مَنْ أُعْطِيَ قِيَاسَ أَرْكَانٍ (مِنْ عَنْدَهُ عَنْدَهُ عَنْدَهُ) ، فَأَدْرِي مَا يَجْرِي    // >>> RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))
    // (new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))
    public static List<float> RescaleToUnit(List<float> numbers) {
","public static List<float> RescaleToUnit(List<float> numbers) {
        if (numbers == null || numbers.Count < 2)
            throw new ArgumentException(""List must contain at least two elements."");

        float min = numbers.Min();
        float max = numbers.Max();

        if (min == max)
            throw new ArgumentException(""All elements are the same. Cannot rescale."");

        return numbers.Select(num => (num - min) / (max - min)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)100.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)1.0f, (float)0.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    }

}
"
HumanEval_22,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَفْتِيلْ مَعْطُوْمَةِ كُلِّ قِيَمِ csthon لِلْكُلِّيْمِيْنِ    // >>> FilterIntegers((new List<object>(new string[]{(string)""a"", (string)3.14f, (string)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> FilterIntegers((new List<object>(new object[]{1L, 2L, 3L, ""abc"", new List<object>()})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    public static List<long> FilterIntegers(List<object> values) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> FilterIntegers(List<object> values) {
        List<long> result = new List<long>();
        foreach (var value in values) {
            if (value is long) {
                result.Add((long)value);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterIntegers((new List<object>())).Equals((new List<long>())));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{4L, new List<object>(), 23.2f, 9L, ""adasd""}))).Equals((new List<long>(new long[]{(long)4L, (long)9L}))));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{3L, ""c"", 3L, 3L, ""a"", ""b""}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_23,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رَجَعَ طُولَ السِّلْسِلَةِ    // >>> StringLength((""""))
    // (0L)
    // >>> StringLength((""abc""))
    // (3L)
    public static long Strlen(string str) {
","return str.Length;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Strlen(("""")) == (0L));
    Debug.Assert(Strlen((""x"")) == (1L));
    Debug.Assert(Strlen((""asdasnakj"")) == (9L));
    }

}
"
HumanEval_24,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //لِعَدَدٍ مَعْطُوْدٍ n، اعْلَمْ أَكْبَرَ عَدَدٍ يَقْسِمُ n بِنَظِيْمٍ، أَصْغَرَ مِنْ n     // >>> LargestDivisor((15L))
    // (5L)
    public static long LargestDivisor(long n) {
","if (n <= 1)
        {
            throw new ArgumentOutOfRangeException(""n must be greater than 1"");
        }
        for (long i = n / 2; i >= 1; i--)
        {
            if (n % i == 0)
            {
                return i;
            }
        }
        return 1; // This line is theoretically unreachable since 1 is always a divisor of n
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestDivisor((3L)) == (1L));
    Debug.Assert(LargestDivisor((7L)) == (1L));
    Debug.Assert(LargestDivisor((10L)) == (5L));
    Debug.Assert(LargestDivisor((100L)) == (50L));
    Debug.Assert(LargestDivisor((49L)) == (7L));
    }

}
"
HumanEval_25,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَجِبُ أَنْ يَكُونَ عَدَدُ الإِدْخَالِ مُسَاوِيًا لِجَمِيعِ العوامل    //كُلُّ عَامِلٍ يَجِبُ أَنْ يُسَمَّى عَدَدَ مَرَّاتٍ يُوافِقُ عَدَدَ مَرَّاتِ ظُهُورِهِ فِي التَّعْلِيلِ.    //يَرُدُّ قَائِمَةَ العُوَلِ الأَوَّلِيَّةِ لِكُلِّ عَدَدٍ مُعَيَّنٍ بِالتَّرْتِيبِ مِنْ أَصْغَرِ إِلَى أَكْبَرِ.    // >>> Factorize((8L))
    // (new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))
    // >>> Factorize((25L))
    // (new List<long>(new long[]{(long)5L, (long)5L}))
    // >>> Factorize((70L))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)7L}))
    public static List<long> Factorize(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Factorize(long n) {
        List<long> factors = new List<long>();
        for (long i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                factors.Add(i);
                n /= i;
            }
        }
        if (n > 1) {
            factors.Add(n);
        }
        return factors;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Factorize((2L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Factorize((4L)).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Factorize((8L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))));
    Debug.Assert(Factorize((57L)).Equals((new List<long>(new long[]{(long)3L, (long)19L}))));
    Debug.Assert(Factorize((3249L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((185193L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((20577L)).Equals((new List<long>(new long[]{(long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_26,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَبَقَّى تَرْتِيبُ العِنَادِ مِثْلَ المَدْخُولِ    //مِنْ قَائِمَةِ الأَصْحَابِ، أَزِلْ كُلَّ العَنَاصِرِ الَّتِي تَظْهَرُ أَكْثَرَ مِنْ مَرَّةٍ.    // >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)4L}))
    public static List<long> RemoveDuplicates(List<long> numbers) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    // From a list of integers, remove all elements that occur more than once.
    // Keep order of elements left the same as in the input.
    public static List<long> RemoveDuplicates(List<long> numbers)
    {
        var elementCount = numbers.GroupBy(n => n)
                                  .ToDictionary(g => g.Key, g => g.Count());

        return numbers.Where(n => elementCount[n] == 1).ToList();
    }

    static void Main(string[] args)
    {
        List<long> numbers = new List<long> { 1, 2, 3, 2, 4 };
        List<long> result = RemoveDuplicates(numbers);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveDuplicates((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L, (long)3L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)5L}))));
    }

}
"
HumanEval_27,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //لِسِلْسِلَةٍ مَعْطُوفَةٍ، أَلْفِ حُرُوفَ حَرْفٍ صَغِيرٍ إِلَى حَرْفٍ كَبِيرٍ وَحَرْفٍ كَبِيرٍ إِلَى حَرْفٍ صَغِيرٍ.    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
","using System;

class Problem {
    // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
        char[] chars = str.ToCharArray();
        for (int i = 0; i < chars.Length; i++) {
            if (char.IsUpper(chars[i])) {
                chars[i] = char.ToLower(chars[i]);
            } else if (char.IsLower(chars[i])) {
                chars[i] = char.ToUpper(chars[i]);
            }
        }
        return new string(chars);
    }
    
    static void Main(string[] args) {
        Console.WriteLine(FlipCase(""Hello"")); // Output should be ""hELLO""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FlipCase(("""")).Equals(("""")));
    Debug.Assert(FlipCase((""Hello!"")).Equals((""hELLO!"")));
    Debug.Assert(FlipCase((""These violent delights have violent ends"")).Equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَرْتِيبُ قَائِمَةِ سَلاَسِلٍ فِي سَلاَسِلٍ وَاحِدٍ    // >>> Concatenate((new List<string>()))
    // ("""")
    // >>> Concatenate((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""abc"")
    public static string Concatenate(List<string> strings) {
","return string.Concat(strings);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Concatenate((new List<string>())).Equals(("""")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""xyz"")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z"", (string)""w"", (string)""k""}))).Equals((""xyzwk"")));
    }

}
"
HumanEval_29,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَفْتِيلْرْ لَوْحَةْ دَخْلِيَّةْ مِنْ السَّلاَسِلْ مَا يَبْدَأْ بِسَبْقٍ مَعْطُوْدْ    // >>> FilterByPrefix((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterByPrefix((new List<string>(new string[]{(string)""abc"", (string)""bcd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""array""}))
    public static List<string> FilterByPrefix(List<string> strings, string prefix) {
","return strings.Where(s => s.StartsWith(prefix)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterByPrefix((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterByPrefix((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    }

}
"
HumanEval_30,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدَّ فَقَطْ أَرْبَابَ الْجَمِيلِ فِي الْقِيمَةِ.    // >>> GetPositive((new List<long>(new long[]{(long)-1L, (long)2L, (long)-4L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)6L}))
    // >>> GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)9L, (long)123L, (long)1L}))
    public static List<long> GetPositive(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetPositive(List<long> l)
    {
        List<long> positiveNumbers = new List<long>();
        foreach (long number in l)
        {
            if (number > 0)
            {
                positiveNumbers.Add(number);
            }
        }
        return positiveNumbers;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L, (long)4L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)4L, (long)5L, (long)6L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)3L, (long)9L, (long)123L, (long)1L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L}))).Equals((new List<long>())));
    Debug.Assert(GetPositive((new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_31,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدَّ صَحِيحًا إِنْ كَانَ عَدَدٌ مُعَيَّنًا أَوَّلًا، وَكَذِبًا إِلَّا.    // >>> IsPrime((6L))
    // (false)
    // >>> IsPrime((101L))
    // (true)
    // >>> IsPrime((11L))
    // (true)
    // >>> IsPrime((13441L))
    // (true)
    // >>> IsPrime((61L))
    // (true)
    // >>> IsPrime((4L))
    // (false)
    // >>> IsPrime((1L))
    // (false)
    public static bool IsPrime(long n) {
","public static bool IsPrime(long n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPrime((6L)) == (false));
    Debug.Assert(IsPrime((101L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((13441L)) == (true));
    Debug.Assert(IsPrime((61L)) == (true));
    Debug.Assert(IsPrime((4L)) == (false));
    Debug.Assert(IsPrime((1L)) == (false));
    Debug.Assert(IsPrime((5L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((17L)) == (true));
    Debug.Assert(IsPrime((85L)) == (false));
    Debug.Assert(IsPrime((77L)) == (false));
    Debug.Assert(IsPrime((255379L)) == (false));
    }

}
"
HumanEval_33,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //لَكِنْ مُنْتَقَطَةً.    //l' هُوَ مُتَشَابِهٌ لِلْمُؤَشِّرِينَ لَا يَقْسِمُونَ بِثَلَاثَةٍ، وَقِيَمُهُ لِلْمُؤَشِّرِينَ يَقْسِمُونَ بِثَلَاثَةٍ مِثْلُهَا    //هَذِهِ الوَظِيفَة تَأْخُذُ قِطَاعَةً وَتَرُدُّ قِطَاعَةً كَأَنَّهَا    // >>> SortThird((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))
    public static List<long> SortThird(List<long> l) {
","public static List<long> SortThird(List<long> l) {
        List<long> sortedValues = new List<long>();

        // Collect values at indices divisible by three
        for (int i = 0; i < l.Count; i++) {
            if (i % 3 == 0) {
                sortedValues.Add(l[i]);
            }
        }

        // Sort the collected values
        sortedValues.Sort();

        // Place sorted values back into their positions
        int sortedIndex = 0;
        List<long> result = new List<long>(l);
        for (int i = 0; i < result.Count; i++) {
            if (i % 3 == 0) {
                result[i] = sortedValues[sortedIndex++];
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L, (long)1L}))));
    }

}
"
HumanEval_34,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرُدُّ مُنْتَدَبَةً فَرْدَةَ أَلْفَ عَنْدَةٍ    // >>> Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))
    public static List<long> Unique(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return sorted unique elements in a list
    public static List<long> Unique(List<long> l) {
        HashSet<long> uniqueSet = new HashSet<long>(l);
        List<long> uniqueList = new List<long>(uniqueSet);
        uniqueList.Sort();
        return uniqueList;
    }
    
    static void Main(string[] args) {
        List<long> input = new List<long>{5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L};
        List<long> result = Unique(input);
        Console.WriteLine(string.Join("", "", result)); // Output: 0, 2, 3, 5, 9, 123
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))));
    }

}
"
HumanEval_35,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرُدُّ كَبِيرَ العَنَاقِدِ فِي القَائِمَةِ.    // >>> MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (3L)
    // >>> MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (123L)
    public static long MaxElement(List<long> l) {
","return l.Max();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (3L));
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)124L, (long)1L, (long)-10L}))) == (124L));
    }

}
"
HumanEval_36,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَعُودُ عَدَدَ مَرَّاتِ يَظْهَرُ الرَّقْمُ 7 فِي أَعْدَادٍ سَوَاءٍ أَقَلَّ مِنْ n تَقْسِمُ بِ 11 أَوْ 13.    // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
        long count = 0;
        for (long i = 1; i < n; i++) {
            if (i % 11 == 0 || i % 13 == 0) {
                count += CountSevens(i);
            }
        }
        return count;
    }

    private static int CountSevens(long num) {
        int count = 0;
        while (num > 0) {
            if (num % 10 == 7) {
                count++;
            }
            num /= 10;
        }
        return count;
    }

    // You can test the function with the following main method:
    static void Main(string[] args) {
        Console.WriteLine(FizzBuzz(50));  // Output: 0
        Console.WriteLine(FizzBuzz(78));  // Output: 2
        Console.WriteLine(FizzBuzz(79));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FizzBuzz((50L)) == (0L));
    Debug.Assert(FizzBuzz((78L)) == (2L));
    Debug.Assert(FizzBuzz((79L)) == (3L));
    Debug.Assert(FizzBuzz((100L)) == (3L));
    Debug.Assert(FizzBuzz((200L)) == (6L));
    Debug.Assert(FizzBuzz((4000L)) == (192L));
    Debug.Assert(FizzBuzz((10000L)) == (639L));
    Debug.Assert(FizzBuzz((100000L)) == (8026L));
    }

}
"
HumanEval_37,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //لَكِنْ مُنْتَقَطَةً.    //l' مُتَشَابِه لَهُ لِلْمُعَدَّدِينَ، وَقِيَمُهُ لِلْمُعَدَّدِينَ مُسَاوِيَة     //هَذِهِ الوَظِيفَة تَأْخُذُ قِطَاعَةً وَتَرُدُّ قِطَاعَةً كَأَنَّهَا    // >>> SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortEven((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)3L, (long)6L, (long)5L, (long)4L}))
    public static List<long> SortEven(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // This function takes a list l and returns a list l' such that
    // l' is identical to l in the odd indices, while its values at the even indices are equal
    // to the values of the even indices of l, but sorted.
    public static List<long> SortEven(List<long> l) {
        List<long> evenIndicesValues = new List<long>();

        // Collect values from even indices
        for (int i = 0; i < l.Count; i += 2) {
            evenIndicesValues.Add(l[i]);
        }

        // Sort the collected even index values
        evenIndicesValues.Sort();

        // Reconstruct the list with sorted values at even indices
        List<long> result = new List<long>(l);

        for (int i = 0, j = 0; i < result.Count; i += 2, j++) {
            result[i] = evenIndicesValues[j];
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-10L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)5L, (long)0L, (long)9L, (long)1L, (long)123L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)8L, (long)-12L, (long)4L, (long)23L, (long)2L, (long)3L, (long)11L, (long)12L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-12L, (long)8L, (long)3L, (long)4L, (long)5L, (long)2L, (long)12L, (long)11L, (long)23L, (long)-10L}))));
    }

}
"
HumanEval_39,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //prime_fib يَرُدُّ عَدَدَ n-th هُوَ عَدَدُ فِبُونَاتْكِي وَهُوَ أَيْضًا عَدَدٌ أَوَّلٌ.     // >>> PrimeFib((1L))
    // (2L)
    // >>> PrimeFib((2L))
    // (3L)
    // >>> PrimeFib((3L))
    // (5L)
    // >>> PrimeFib((4L))
    // (13L)
    // >>> PrimeFib((5L))
    // (89L)
    public static long PrimeFib(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Method to check if a number is prime
    public static bool IsPrime(long num)
    {
        if (num <= 1) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;

        long boundary = (long)Math.Floor(Math.Sqrt(num));

        for (long i = 3; i <= boundary; i += 2)
        {
            if (num % i == 0)
                return false;
        }

        return true;
    }

    // Method to generate Fibonacci numbers and find the n-th prime Fibonacci
    public static long PrimeFib(long n)
    {
        long a = 1, b = 1;
        long primeFibCount = 0;

        while (true)
        {
            long temp = a;
            a = b;
            b = temp + b;

            if (IsPrime(a))
            {
                primeFibCount++;
                if (primeFibCount == n)
                {
                    return a;
                }
            }
        }
    }

    static void Main(string[] args)
    {
        Console.WriteLine(PrimeFib(1)); // Output: 2
        Console.WriteLine(PrimeFib(2)); // Output: 3
        Console.WriteLine(PrimeFib(3)); // Output: 5
        Console.WriteLine(PrimeFib(4)); // Output: 13
        Console.WriteLine(PrimeFib(5)); // Output: 89
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeFib((1L)) == (2L));
    Debug.Assert(PrimeFib((2L)) == (3L));
    Debug.Assert(PrimeFib((3L)) == (5L));
    Debug.Assert(PrimeFib((4L)) == (13L));
    Debug.Assert(PrimeFib((5L)) == (89L));
    Debug.Assert(PrimeFib((6L)) == (233L));
    Debug.Assert(PrimeFib((7L)) == (1597L));
    Debug.Assert(PrimeFib((8L)) == (28657L));
    Debug.Assert(PrimeFib((9L)) == (514229L));
    Debug.Assert(PrimeFib((10L)) == (433494437L));
    }

}
"
HumanEval_40,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَجْمُوعٌ لِلْصِفَرِ، وَكَذِبٌ غَيْرُهُ.    //يَعُودُ صَحِيحًا إِنْ كَانَ ثَلَاثَةُ عَنَاصِرٍ مُتَمَيِّزَةٍ فِي الْقَائِمِ     //triples_sum_to_zero يَأْخُذُ قِيمَةَ أَعْدَادٍ كَدَخْلٍ.    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool TriplesSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool TriplesSumToZero(List<long> l)
    {
        if (l.Count < 3)
            return false;

        l.Sort();

        for (int i = 0; i < l.Count - 2; i++)
        {
            if (i > 0 && l[i] == l[i - 1])
                continue;

            int left = i + 1;
            int right = l.Count - 1;

            while (left < right)
            {
                long sum = l[i] + l[left] + l[right];
                if (sum == 0)
                    return true;
                else if (sum < 0)
                    left++;
                else
                    right--;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)5L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-100L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)100L, (long)3L, (long)5L, (long)-100L}))) == (false));
    }

}
"
HumanEval_41,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //هَذِهِ الوَظِيفَةُ تَخْرُجُ عَدَدَ هَذِهِ الاصطداماتِ.    //فِي مَسِيرِهِمْ كَأَنَّهُمْ لَمْ يَصْطَدِمُوا    //وَلَكِنَّ السَّيَّارَاتَ قَوِيَّةٌ وَقَوِيَّةٌ بِلاَ حَدٍّ وَبِذَلِكَ تَسْتَمِرُّ    //إِذَا كَانَتْ مَرَّةً فَتَقَدَّمَتْ مَرَّةً    //كُلّ السّيّارات تَسِيرُ بِنَفس السّرعةِ. سَيّارتَانِ يُقَالُ لَهُمْ يَصطَادِمُونَ.    //يَسِيرُونَ مِنْ الْيَمِينِ إِلَى الْيَسَارِ.    //n كَرَاتْ تَسِيرُ مِنْ يَسَارْ لِيَمِينْ؛ فِي الْمُتَزَامِنْ، مجموعة مختلفة من n كَرَاتْ     //تَصَوَّرْ سَبِيلًا مُسْتَقِيمًا مُتَوَسِّطًا بِلَا حَدٍّ.    public static long CarRaceCollision(long n) {
","// Each car moving left to right will collide with each car moving right to left.
        // So the total number of collisions is n * n.
        return n * n;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CarRaceCollision(5));  // Example usage
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CarRaceCollision((2L)) == (4L));
    Debug.Assert(CarRaceCollision((3L)) == (9L));
    Debug.Assert(CarRaceCollision((4L)) == (16L));
    Debug.Assert(CarRaceCollision((8L)) == (64L));
    Debug.Assert(CarRaceCollision((10L)) == (100L));
    }

}
"
HumanEval_42,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //قَائِمَةُ الرَّجْعِ بِالعِنَادِ مَزِيدَةٌ بِ1.    // >>> IncrList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))
    // >>> IncrList((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)6L, (long)4L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))
    public static List<long> IncrList(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list with elements incremented by 1.
    public static List<long> IncrList(List<long> l) {
        return l.Select(x => x + 1).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IncrList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)3L, (long)2L}))));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)5L, (long)2L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)6L, (long)3L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))));
    }

}
"
HumanEval_43,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَجْمُوعٌ لِلْصِفَرِ، وَكَذِبٌ غَيْرُهُ.    //يَعُودُ صَحِيحًا إِنْ كَانَ فِي الْقِرَاءَةِ عَنْصَفَانِ مُتَمَيِّزَانِ    //pairs_sum_to_zero يَأْخُذُ لِسَانَ أَعْدَادٍ كَدَخْلٍ.    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))
    // (true)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool PairsSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool PairsSumToZero(List<long> l)
    {
        HashSet<long> seenNumbers = new HashSet<long>();

        foreach (long number in l)
        {
            if (seenNumbers.Contains(-number))
            {
                return true;
            }
            seenNumbers.Add(number);
        }

        return false;
    }

    public static void Main(string[] args)
    {
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, 5L, 0L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, -2L, 1L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 2L, 3L, 7L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 2L, 4L, -5L, 3L, 5L, 7L })); // true
        Console.WriteLine(PairsSumToZero(new List<long> { 1L })); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)30L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)31L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)30L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)31L}))) == (false));
    }

}
"
HumanEval_44,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أَسَاسَاتُ أَقَلَّ مِنْ 10    //يَعُودُ بِتَمْثِيلِ السَّلَسِ بَعْدَ التَّحْوِيلِ.    //تَغَيَّرْ قَاعِدَةَ العَدَدِ لِعَدَدِ x    // >>> ChangeBase((8L), (3L))
    // (""22"")
    // >>> ChangeBase((8L), (2L))
    // (""1000"")
    // >>> ChangeBase((7L), (2L))
    // (""111"")
    public static string ChangeBase(long x, long numBase) {
","using System;
using System.Collections.Generic;

class Problem {
    // Change numerical base of input number x to base.
    // return string representation after the conversion.
    // base numbers are less than 10.
    public static string ChangeBase(long x, long numBase) {
        if (numBase < 2 || numBase > 9) 
            throw new ArgumentException(""Base must be between 2 and 9."");

        if (x < 0) 
            throw new ArgumentException(""Number must be non-negative."");

        if (x == 0) 
            return ""0"";

        string result = string.Empty;
        while (x > 0) {
            long remainder = x % numBase;
            result = remainder + result;
            x /= numBase;
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChangeBase((8L), (3L)).Equals((""22"")));
    Debug.Assert(ChangeBase((9L), (3L)).Equals((""100"")));
    Debug.Assert(ChangeBase((234L), (2L)).Equals((""11101010"")));
    Debug.Assert(ChangeBase((16L), (2L)).Equals((""10000"")));
    Debug.Assert(ChangeBase((8L), (2L)).Equals((""1000"")));
    Debug.Assert(ChangeBase((7L), (2L)).Equals((""111"")));
    Debug.Assert(ChangeBase((2L), (3L)).Equals((""2"")));
    Debug.Assert(ChangeBase((3L), (4L)).Equals((""3"")));
    Debug.Assert(ChangeBase((4L), (5L)).Equals((""4"")));
    Debug.Assert(ChangeBase((5L), (6L)).Equals((""5"")));
    Debug.Assert(ChangeBase((6L), (7L)).Equals((""6"")));
    Debug.Assert(ChangeBase((7L), (8L)).Equals((""7"")));
    }

}
"
HumanEval_45,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مُعَطَى طُولِ جَانِبٍ وَمَسْطَحِ عَوْدٍ عَلَى ثَلَاثِيٍّ.    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
","using System;

class Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
        return (a * h) / 2.0f;
    }

    static void Main(string[] args) {
        Console.WriteLine(TriangleArea(5L, 3L)); // Output: 7.5
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((5L), (3L)) == (7.5f));
    Debug.Assert(TriangleArea((2L), (2L)) == (2.0f));
    Debug.Assert(TriangleArea((10L), (8L)) == (40.0f));
    }

}
"
HumanEval_46,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رَجَاءَ اَكْتُبْ فَعْلَةً لِتَحْسِبَ بِالْكَفَاءَةِ الْعَنْصَرَةَ الْمُتَتَابِعَةَ لِلْعَدَدِ. لاَ تَسْتَعْمِلِ الرَّدْمَ.    //فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ فَيَكُونُ    //fib4(3) -> 0     //فَيَا رَبِّ!    //fib4(1) -> 0     //fib4(0) -> 0     //تَتَابُعُ أَرْبَعِيَةِ فِبْرُونْكِي مُشْبِهٌ لِتَتَابُعِ فِبْرُونْكِي وَهُوَ مُعَرَّفٌ كَمَا يَلِي:    // >>> Fib4((5L))
    // (4L)
    // >>> Fib4((6L))
    // (8L)
    // >>> Fib4((7L))
    // (14L)
    public static long Fib4(long n) {
","public static long Fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    long[] fib4Seq = new long[n + 1];
    fib4Seq[0] = 0;
    fib4Seq[1] = 0;
    fib4Seq[2] = 2;
    fib4Seq[3] = 0;

    for (long i = 4; i <= n; i++) {
        fib4Seq[i] = fib4Seq[i - 1] + fib4Seq[i - 2] + fib4Seq[i - 3] + fib4Seq[i - 4];
    }

    return fib4Seq[n];
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib4((5L)) == (4L));
    Debug.Assert(Fib4((8L)) == (28L));
    Debug.Assert(Fib4((10L)) == (104L));
    Debug.Assert(Fib4((12L)) == (386L));
    }

}
"
HumanEval_47,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرْجِعُ وَسَطَ العَنَاصِرِ في القَائِمَةِ    // >>> Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (float)3L
    // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L})))
    // (15.0f)
    public static float Median(List<long> l) {
","public static float Median(List<long> l) {
        l.Sort();
        int count = l.Count;
        if (count % 2 == 1) {
            return (float)l[count / 2];
        } else {
            long mid1 = l[(count / 2) - 1];
            long mid2 = l[count / 2];
            return (mid1 + mid2) / 2.0f;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) == (float)3L);
    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));
    Debug.Assert(Median((new List<long>(new long[]{(long)5L}))) == (float)5L);
    Debug.Assert(Median((new List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));
    Debug.Assert(Median((new List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L, (long)7L}))) == (float)7L);
    }

}
"
HumanEval_48,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَتَفَقَّدُ إنْ كَانَتْ السِّلْسِلَةُ مَوْصُولَةً    // >>> IsPalindrome((""""))
    // (true)
    // >>> IsPalindrome((""aba""))
    // (true)
    // >>> IsPalindrome((""aaaaa""))
    // (true)
    // >>> IsPalindrome((""zbcd""))
    // (false)
    public static bool IsPalindrome(string text) {
","public static bool IsPalindrome(string text) {
    if (string.IsNullOrEmpty(text))
        return true;

    int left = 0;
    int right = text.Length - 1;

    while (left < right) {
        if (text[left] != text[right])
            return false;
        left++;
        right--;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPalindrome(("""")) == (true));
    Debug.Assert(IsPalindrome((""aba"")) == (true));
    Debug.Assert(IsPalindrome((""aaaaa"")) == (true));
    Debug.Assert(IsPalindrome((""zbcd"")) == (false));
    Debug.Assert(IsPalindrome((""xywyx"")) == (true));
    Debug.Assert(IsPalindrome((""xywyz"")) == (false));
    Debug.Assert(IsPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدَّ 2^n مُدُوْلُوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْوْ    // >>> Modp((3L), (5L))
    // (3L)
    // >>> Modp((1101L), (101L))
    // (2L)
    // >>> Modp((0L), (101L))
    // (1L)
    // >>> Modp((3L), (11L))
    // (8L)
    // >>> Modp((100L), (101L))
    // (1L)
    public static long Modp(long n, long p) {
","using System;
using System.Numerics;

class Problem {
    public static long Modp(long n, long p) {
        // Using the property of modular arithmetic: (a^b) % c = ((a % c)^b) % c
        // We are calculating (2^n) % p
        BigInteger baseNum = 2;
        BigInteger result = BigInteger.ModPow(baseNum, n, p);
        return (long)result;
    }

    static void Main(string[] args) {
        Console.WriteLine(Modp(3L, 5L));   // (3L)
        Console.WriteLine(Modp(1101L, 101L)); // (2L)
        Console.WriteLine(Modp(0L, 101L));   // (1L)
        Console.WriteLine(Modp(3L, 11L));   // (8L)
        Console.WriteLine(Modp(100L, 101L));  // (1L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Modp((3L), (5L)) == (3L));
    Debug.Assert(Modp((1101L), (101L)) == (2L));
    Debug.Assert(Modp((0L), (101L)) == (1L));
    Debug.Assert(Modp((3L), (11L)) == (8L));
    Debug.Assert(Modp((100L), (101L)) == (1L));
    Debug.Assert(Modp((30L), (5L)) == (4L));
    Debug.Assert(Modp((31L), (5L)) == (3L));
    }

}
"
HumanEval_51,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //remove_vowels فَعَلَةٌ تَأْخُذُ السِّلْطَ وَتَرُدُّ السِّلْطَ بِدُونِ حُرُوفٍ.    // >>> RemoveVowels((""""))
    // ("""")
    // >>> RemoveVowels((""abcdef""))
    // (""bcdf"")
    // >>> RemoveVowels((""aaaaa""))
    // ("""")
    // >>> RemoveVowels((""aaBAA""))
    // (""B"")
    // >>> RemoveVowels((""zbcd""))
    // (""zbcd"")
    public static string RemoveVowels(string text) {
","HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        StringBuilder result = new StringBuilder();

        foreach (char c in text) {
            if (!vowels.Contains(c)) {
                result.Append(c);
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveVowels(("""")).Equals(("""")));
    Debug.Assert(RemoveVowels((""abcdef\nghijklm"")).Equals((""bcdf\nghjklm"")));
    Debug.Assert(RemoveVowels((""fedcba"")).Equals((""fdcb"")));
    Debug.Assert(RemoveVowels((""eeeee"")).Equals(("""")));
    Debug.Assert(RemoveVowels((""acBAA"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""EcBOO"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""ybcd"")).Equals((""ybcd"")));
    }

}
"
HumanEval_52,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَرْجِعُ حَقًّا إِنْ كَانَ كُلُّ الأَرْقَامِ فِي الْقَائِمِ l دُونَ الْعَتَبَةِ t.    // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L))
    // (true)
    // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L))
    // (false)
    public static bool BelowThreshold(List<long> l, long t) {
","return l.All(x => x < t);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L)) == (false));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (21L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (22L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (11L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (10L)) == (false));
    }

}
"
HumanEval_53,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ضِمْ عدَدَيْنِ x و y     // >>> Add((2L), (3L))
    // (5L)
    // >>> Add((5L), (7L))
    // (12L)
    public static long Add(long x, long y) {
","return x + y;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((0L), (1L)) == (1L));
    Debug.Assert(Add((1L), (0L)) == (1L));
    Debug.Assert(Add((2L), (3L)) == (5L));
    Debug.Assert(Add((5L), (7L)) == (12L));
    Debug.Assert(Add((7L), (5L)) == (12L));
    }

}
"
HumanEval_54,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَفَقَّدْ إنْ كَانَ لِكَلِمَتَيْنِ حَرْفٌ مُتَشَابِهٌ.    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> SameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> SameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> SameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> SameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    public static bool SameChars(string s0, string s1) {
","public static bool SameChars(string s0, string s1) {
        // Return true if s1 contains all characters of s0
        return s0.All(c => s1.Contains(c)) && s1.All(c => s0.Contains(c));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    Debug.Assert(SameChars((""abcd""), (""dddddddabc"")) == (true));
    Debug.Assert(SameChars((""dddddddabc""), (""abcd"")) == (true));
    Debug.Assert(SameChars((""eabcd""), (""dddddddabc"")) == (false));
    Debug.Assert(SameChars((""abcd""), (""dddddddabcf"")) == (false));
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    Debug.Assert(SameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدَّ نَوْمَ فِبُونَاتْكِي    // >>> Fib((10L))
    // (55L)
    // >>> Fib((1L))
    // (1L)
    // >>> Fib((8L))
    // (21L)
    public static long Fib(long n) {
","if (n <= 0) return 0;
    if (n == 1) return 1;

    long a = 0;
    long b = 1;

    for (long i = 2; i <= n; i++)
    {
        long temp = a + b;
        a = b;
        b = temp;
    }

    return b;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib((10L)) == (55L));
    Debug.Assert(Fib((1L)) == (1L));
    Debug.Assert(Fib((8L)) == (21L));
    Debug.Assert(Fib((11L)) == (89L));
    Debug.Assert(Fib((12L)) == (144L));
    }

}
"
HumanEval_56,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //return true إِنْ كُلُّ قُفَّةِ فَتْحٍ لَهَا قُفَّةُ إِغْلَاقٍ مُطَابِقَةٌ    //قُرَيْشٌ سِلْسِلَةٌ مِنْ ""<"" و "">"".    // >>> CorrectBracketing((""<""))
    // (false)
    // >>> CorrectBracketing((""<>""))
    // (true)
    // >>> CorrectBracketing((""<<><>>""))
    // (true)
    // >>> CorrectBracketing((""><<>""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","public static bool CorrectBracketing(string brackets) 
{
    int balance = 0;
    foreach (char c in brackets) 
    {
        if (c == '<') 
        {
            balance++;
        } 
        else if (c == '>') 
        {
            balance--;
        }
        
        if (balance < 0) 
        {
            return false;
        }
    }

    return balance == 0;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""<>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<><>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<><>><>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<<><>>>>"")) == (false));
    Debug.Assert(CorrectBracketing((""><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<"")) == (false));
    Debug.Assert(CorrectBracketing((""<<<<"")) == (false));
    Debug.Assert(CorrectBracketing(("">"")) == (false));
    Debug.Assert(CorrectBracketing((""<<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدَّ صَحِيحًا أَنْ يَكُونَ عَنْ مُنْتَهَى الْمَوْضُوعِ أَوْ الْمُنْتَهَى.    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L})))
    // (true)
    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})))
    // (false)
    // >>> Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L})))
    // (true)
    public static bool Monotonic(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return true if list elements are monotonically increasing or decreasing.
    public static bool Monotonic(List<long> l) {
        if (l.Count < 2) return true; // Lists with less than 2 elements are trivially monotonic.
        
        bool increasing = true;
        bool decreasing = true;

        for (int i = 1; i < l.Count; i++) {
            if (l[i] > l[i - 1]) {
                decreasing = false;
            } else if (l[i] < l[i - 1]) {
                increasing = false;
            }

            // If both flags are false, the list is not monotonic.
            if (!increasing && !decreasing) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)5L, (long)60L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)60L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)9L, (long)9L, (long)9L, (long)9L}))) == (true));
    }

}
"
HumanEval_58,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَعُودُ مُصَنَّفَةً فَرْدَةً مَوْجُودَةً لِقَوْمَيْنِ.    // >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))
    // (new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))
    // >>> Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    public static List<long> Common(List<long> l1, List<long> l2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> Common(List<long> l1, List<long> l2)
    {
        // Use HashSet to store unique elements of l1
        var set1 = new HashSet<long>(l1);

        // Use HashSet to store unique elements of l2 and filter common elements
        var commonSet = new HashSet<long>(l2.Where(x => set1.Contains(x)));

        // Convert to a list, sort it and return
        var result = commonSet.ToList();
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_59,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدُّوا أَكْبَرَ عَدَدِ أَوَّلِ نَ. فَلْنَتَأَمَّلْ أَنَّ ن > 1 وَلَيْسَ بِأَوَّلِ.     // >>> LargestPrimeFactor((13195L))
    // (29L)
    // >>> LargestPrimeFactor((2048L))
    // (2L)
    public static long LargestPrimeFactor(long n) {
","using System;

class Problem {
    public static long LargestPrimeFactor(long n) {
        long largestFactor = -1;
        
        // Remove the factor of 2
        while (n % 2 == 0) {
            largestFactor = 2;
            n /= 2;
        }

        // Check odd factors from 3 upwards
        for (long i = 3; i <= Math.Sqrt(n); i += 2) {
            while (n % i == 0) {
                largestFactor = i;
                n /= i;
            }
        }

        // If n becomes a prime number greater than 2
        if (n > 2) {
            largestFactor = n;
        }

        return largestFactor;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestPrimeFactor((15L)) == (5L));
    Debug.Assert(LargestPrimeFactor((27L)) == (3L));
    Debug.Assert(LargestPrimeFactor((63L)) == (7L));
    Debug.Assert(LargestPrimeFactor((330L)) == (11L));
    Debug.Assert(LargestPrimeFactor((13195L)) == (29L));
    }

}
"
HumanEval_60,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //sum_to_n دَلِيلٌ يُجَمِّعُ الأَرقامَ مِنْ 1 إلى n.     // >>> SumToN((30L))
    // (465L)
    // >>> SumToN((100L))
    // (5050L)
    // >>> SumToN((5L))
    // (15L)
    // >>> SumToN((10L))
    // (55L)
    // >>> SumToN((1L))
    // (1L)
    public static long SumToN(long n) {
","return n * (n + 1) / 2;
}
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumToN((1L)) == (1L));
    Debug.Assert(SumToN((6L)) == (21L));
    Debug.Assert(SumToN((11L)) == (66L));
    Debug.Assert(SumToN((30L)) == (465L));
    Debug.Assert(SumToN((100L)) == (5050L));
    }

}
"
HumanEval_61,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //return true إِنْ كُلُّ قُفَّةِ فَتْحٍ لَهَا قُفَّةُ إِغْلَاقٍ مُطَابِقَةٌ    //قَيْدَةٌ مِنْ ""("" و """")    // >>> CorrectBracketing((""(""))
    // (false)
    // >>> CorrectBracketing((""()""))
    // (true)
    // >>> CorrectBracketing((""(()())""))
    // (true)
    // >>> CorrectBracketing(("")(()""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","using System;

class Problem {
    public static bool CorrectBracketing(string brackets) {
        int balance = 0;
        foreach (char c in brackets) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""()"")) == (true));
    Debug.Assert(CorrectBracketing((""(()())"")) == (true));
    Debug.Assert(CorrectBracketing((""()()(()())()"")) == (true));
    Debug.Assert(CorrectBracketing((""()()((()()())())(()()(()))"")) == (true));
    Debug.Assert(CorrectBracketing((""((()())))"")) == (false));
    Debug.Assert(CorrectBracketing(("")(()"")) == (false));
    Debug.Assert(CorrectBracketing((""("")) == (false));
    Debug.Assert(CorrectBracketing((""(((("")) == (false));
    Debug.Assert(CorrectBracketing(("")"")) == (false));
    Debug.Assert(CorrectBracketing((""(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())())(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدُّ مُشتَقَةَ هَذَا الكَثْرَيْنِ بِنَفْسِ الشَّكْلِ.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....  لَا تَنْتَهِيْ إِلَى الْمَوْتِ    //xs يَمْثِلُ مُؤَكِّدَاتِ كَثْرَةٍ.    // >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))
    // >>> Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)6L}))
    public static List<long> Derivative(List<long> xs) {
","public static List<long> Derivative(List<long> xs) {
        List<long> derivative = new List<long>();
        for (int i = 1; i < xs.Count; i++) {
            derivative.Add(xs[i] * i);
        }
        return derivative;
    }

    static void Main(string[] args) {
        List<long> poly1 = new List<long>{3L, 1L, 2L, 4L, 5L};
        List<long> result1 = Derivative(poly1);
        Console.WriteLine(string.Join("", "", result1));

        List<long> poly2 = new List<long>{1L, 2L, 3L};
        List<long> result2 = Derivative(poly2);
        Console.WriteLine(string.Join("", "", result2));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L, (long)0L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)0L, (long)16L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_63,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رَجَاءً اَكْتُبْ دَلِيْلَةً لِتَحْسِبَ بِكَفَاءَةٍ العَنْصَرَةَ n مِنْ تَتَابُعِ الأَرْبَعِيْنَ.    //فَيْبِيْبِيْنْ) == فَيْبِيْبِيْنْ-1) + فَيْبِيْبِيْنْ-2) + فَيْبِيْبِيْنْ-3).    //فَفَفَفَ ((2) == 1     //فَفَفَفَتَتَتَتَتَتَتَ    //فَفَفَفَ    //تَتَابُعُ أَرْبَعِيْنَ مِنْ فِبْنَاكِيْ يُعَرَّفُ بِالْمَعْنَى:    // >>> Fibfib((1L))
    // (0L)
    // >>> Fibfib((5L))
    // (4L)
    // >>> Fibfib((8L))
    // (24L)
    public static long Fibfib(long n) {
","public static long Fibfib(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 1;

    long a = 0, b = 0, c = 1;
    long result = 0;

    for (long i = 3; i <= n; i++) {
        result = a + b + c;
        a = b;
        b = c;
        c = result;
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fibfib((2L)) == (1L));
    Debug.Assert(Fibfib((1L)) == (0L));
    Debug.Assert(Fibfib((5L)) == (4L));
    Debug.Assert(Fibfib((8L)) == (24L));
    Debug.Assert(Fibfib((10L)) == (81L));
    Debug.Assert(Fibfib((12L)) == (274L));
    Debug.Assert(Fibfib((14L)) == (927L));
    }

}
"
HumanEval_64,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //حَرْفٌ، وَلَكِنْ فِي آخِرِ كَلِمَةٍ مَعْطُوفَةٍ.    //وَالْوَاوُ فِي هَذِهِ الْحَالِ هِيَ "" أ "" وَ "" ي "" وَ "" ي "" وَ "" ي "" وَهِيَ أَيْضًا    //كَلِمَة كَدَخْل وَيَرُدّ عَدَدَ الْحُرُوف فِي السلسلة.    //اُكْتُبْ دَالِيَةَ vowels_count الَّتِي تَتَّخِذُ سِلْسِلَةً تَمْثِلُ     // >>> VowelsCount((""abcde""))
    // (2L)
    // >>> VowelsCount((""ACEDY""))
    // (3L)
    public static long VowelsCount(string s) {
","using System;

class Problem {
    public static long VowelsCount(string s) {
        if (s == null) return 0;

        s = s.ToLower();
        long count = 0;
        
        for (int i = 0; i < s.Length; i++) {
            char c = s[i];
            if (""aeiou"".Contains(c) || (c == 'y' && i == s.Length - 1)) {
                count++;
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(VowelsCount(""abcde""));  // Output: 2
        Console.WriteLine(VowelsCount(""ACEDY""));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(VowelsCount((""abcde"")) == (2L));
    Debug.Assert(VowelsCount((""Alone"")) == (3L));
    Debug.Assert(VowelsCount((""key"")) == (2L));
    Debug.Assert(VowelsCount((""bye"")) == (1L));
    Debug.Assert(VowelsCount((""keY"")) == (2L));
    Debug.Assert(VowelsCount((""bYe"")) == (1L));
    Debug.Assert(VowelsCount((""ACEDY"")) == (3L));
    }

}
"
HumanEval_65,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //إِنْ تَحَوَّلَتْ > عَدَدُ أَلْفَاتٍ، تَعُودُ أَلْفَاتٌ مُعَكَّسَةٌ.    //وَيَرْجِعُ النَّتِيجَةَ سِلْسِلَةً.    //دَوَرْ دَوَرْ دَوَرْ دَوَرْ دَوَرْ دَوَرْ دَوَرْ    // >>> CircularShift((12L), (1L))
    // (""21"")
    // >>> CircularShift((12L), (2L))
    // (""12"")
    public static string CircularShift(long x, long shift) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Circular shift the digits of the integer x, shift the digits right by shift
    // and return the result as a string.
    // If shift > number of digits, return digits reversed.
    
    public static string CircularShift(long x, long shift) {
        string digits = x.ToString();
        int length = digits.Length;
        
        if (shift > length) {
            char[] reversedDigits = digits.ToCharArray();
            Array.Reverse(reversedDigits);
            return new string(reversedDigits);
        }

        shift = shift % length;  // Normalize shift
        string shiftedPart = digits.Substring(length - (int)shift);
        string remainingPart = digits.Substring(0, length - (int)shift);
        return shiftedPart + remainingPart;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CircularShift((100L), (2L)).Equals((""001"")));
    Debug.Assert(CircularShift((12L), (2L)).Equals((""12"")));
    Debug.Assert(CircularShift((97L), (8L)).Equals((""79"")));
    Debug.Assert(CircularShift((12L), (1L)).Equals((""21"")));
    Debug.Assert(CircularShift((11L), (101L)).Equals((""11"")));
    }

}
"
HumanEval_66,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //أَسْكِيْيْيْيْيْيْيْيْ    //كَتِبْ دَلِيلَ يَأْخُذُ سِلْطَةً كَدَخْلٍ وَيَرُدُّ جَمْعَ الْحُرُوفِ الْعُلْيَا فَقَطْ'     //مَهمَة     // >>> Digitsum((""""))
    // (0L)
    // >>> Digitsum((""abAB""))
    // (131L)
    // >>> Digitsum((""abcCd""))
    // (67L)
    // >>> Digitsum((""helloE""))
    // (69L)
    // >>> Digitsum((""woArBld""))
    // (131L)
    // >>> Digitsum((""aAaaaXa""))
    // (153L)
    public static long Digitsum(string s) {
","public static long Digitsum(string s) {
    long sum = 0;
    foreach (char c in s) {
        if (char.IsUpper(c)) {
            sum += c; // Add ASCII value of the upper case letters.
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digitsum(("""")) == (0L));
    Debug.Assert(Digitsum((""abAB"")) == (131L));
    Debug.Assert(Digitsum((""abcCd"")) == (67L));
    Debug.Assert(Digitsum((""helloE"")) == (69L));
    Debug.Assert(Digitsum((""woArBld"")) == (131L));
    Debug.Assert(Digitsum((""aAaaaXa"")) == (153L));
    Debug.Assert(Digitsum(("" How are yOu?"")) == (151L));
    Debug.Assert(Digitsum((""You arE Very Smart"")) == (327L));
    }

}
"
HumanEval_67,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //لِلْمُتَكَلِّمِ:    //في السلة يَعُودُ عَدَدَ ثِمَارِ الْمَنْجُوسِ فِي السلة.    //البُرتُونِ و التفاح وَ عَدَد كُلّي يَمْثُل العَدَد الكَامِل للفَاكِهَة     //تَفَاحٌ، وَتَمْرَةٌ، وَفَاكِهَةُ الْمَنْجُوسِ.    //تُوزَعُ في سَلَّةٍ مِنْ فَاكِهَةٍ تَحتَوِي هَذِهِ السَّلَّةَ    //فِي هَذِهِ المَسَأَةِ، سَتُعْطَى سِلْسِلَةً تَمْثِلُ عَدَدَ تُفَّاحٍ وَتَمْرَجَاتٍ.    // >>> FruitDistribution((""5 apples and 6 oranges""), (19L))
    // (8L)
    // >>> FruitDistribution((""0 apples and 1 oranges""), (3L))
    // (2L)
    // >>> FruitDistribution((""2 apples and 3 oranges""), (100L))
    // (95L)
    // >>> FruitDistribution((""100 apples and 1 oranges""), (120L))
    // (19L)
    public static long FruitDistribution(string s, long n) {
","using System;

class Problem {
    public static long FruitDistribution(string s, long n) {
        var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        long apples = long.Parse(parts[0]);
        long oranges = long.Parse(parts[3]);

        long totalApplesAndOranges = apples + oranges;
        long mangoes = n - totalApplesAndOranges;
        
        return mangoes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (19L)) == (8L));
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (21L)) == (10L));
    Debug.Assert(FruitDistribution((""0 apples and 1 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""1 apples and 0 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (100L)) == (95L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (5L)) == (0L));
    Debug.Assert(FruitDistribution((""1 apples and 100 oranges""), (120L)) == (19L));
    }

}
"
HumanEval_68,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالُ 1:    //إِنْ لَمْ يَكُنْ فِي القَدَرِ مَوْضُوعٌ أَوْ فِي القَدَرِ فَارِغٌ، عُدْ [].    //يَجِبُ أَنْ تُرَدَّ العَقْدَ المَقْطُوعَ في قِيمَةٍ، [smallest_value، index ]،     //إِنْ وُجِدَ عَقَدَاتٌ عَدَدَةٌ بِأَصْغَرِ قِيمَةٍ زَوَائِدَةٍ رُدَّ عَقَدَةَ أَصْغَرِ فَهْمٍ.    //عُقدَةُ المَقْطُوعَةِ يَجِبُ أَنْ تَكُونَ عُقدَةَ أصْغَرِ قيمةٍ زَوْجِيَّةٍ.    //مَهمَتُكَ تَمْزِقُ إحدى العُقدِ وتَرُدُّهَا.    //""إِذَا أُعْطِيَتْ قِيمَةٌ تَمْثِيلُ فَرْعَةٍ مِنْ شَجَرَةٍ لَهَا عُقَدٌ سَمِيْنٌ غَيْرُ سَالبٍ    // >>> Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> Pluck((new List<long>()))
    // (new List<long>())
    // Example 4:
    // >>> Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)0L, (long)1L}))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    public static List<long> Pluck(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Pluck(List<long> arr)
    {
        long smallestEven = long.MaxValue;
        int indexOfSmallest = -1;

        for (int i = 0; i < arr.Count; i++)
        {
            if (arr[i] % 2 == 0 && arr[i] < smallestEven)
            {
                smallestEven = arr[i];
                indexOfSmallest = i;
            }
        }

        if (indexOfSmallest == -1)
        {
            return new List<long>();
        }
        else
        {
            return new List<long> { smallestEven, indexOfSmallest };
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>())).Equals((new List<long>())));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)0L, (long)5L, (long)3L}))).Equals((new List<long>(new long[]{(long)0L, (long)3L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)4L, (long)8L, (long)4L, (long)8L}))).Equals((new List<long>(new long[]{(long)4L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)6L, (long)7L, (long)1L}))).Equals((new List<long>(new long[]{(long)6L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)9L, (long)7L, (long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_69,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //إِنْ لَمْ تَكُنْ هَذِهِ القِيمَةُ موجودةً، ارْجِعْ -1.    //تَوَاتُرُ عَدَدِ كُلِّيٍّ عَدَدُ مَرَّاتِ ظُهُورِهِ فِي الْقِيَاسِ.    //وَلَهُ تَوَاتُرٌ أَكْبَرُ أَوْ مُسَاوٍ لِقِيمَةِ العَدَدِ الكَامِلِ نَفْسِهِ.    //تُعْطَى لِسْمَةٌ غَيْرُ فَارِغَةٍ مِنْ أَعْدَادٍ مُوجِبَةٍ. رُدُّوا أَكْبَرَ عَدَدٍ أَكْبَرَ مِنْ     // >>> Search((new List<long>(new long[]{(long)4L, (long)1L, (long)2L, (long)2L, (long)3L, (long)1L})))
    // (2L)
    // >>> Search((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L, (long)4L})))
    // (3L)
    // >>> Search((new List<long>(new long[]{(long)5L, (long)5L, (long)4L, (long)4L, (long)4L})))
    // (-1L)
    public static long Search(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static long Search(List<long> lst)
    {
        // Create a dictionary to store the frequency of each number
        Dictionary<long, long> frequency = new Dictionary<long, long>();

        // Count the frequency of each number in the list
        foreach (long num in lst)
        {
            if (frequency.ContainsKey(num))
            {
                frequency[num]++;
            }
            else
            {
                frequency[num] = 1;
            }
        }

        // Variable to store the greatest integer found
        long result = -1;

        // Go through each item in the frequency dictionary
        foreach (var kvp in frequency)
        {
            long number = kvp.Key;
            long freq = kvp.Value;

            // Check if the number's frequency is greater than or equal to the number itself
            if (freq >= number && number > 0)
            {
                // Update the result if this number is greater than the current result
                result = Math.Max(result, number);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)4L, (long)1L, (long)4L, (long)1L, (long)4L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)3L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L}))) == (8L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)3L, (long)3L, (long)2L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)7L, (long)8L, (long)8L, (long)4L, (long)8L, (long)7L, (long)3L, (long)9L, (long)6L, (long)5L, (long)10L, (long)4L, (long)3L, (long)6L, (long)7L, (long)1L, (long)7L, (long)4L, (long)10L, (long)8L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)2L, (long)8L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)7L, (long)1L, (long)8L, (long)8L, (long)10L, (long)5L, (long)8L, (long)5L, (long)3L, (long)10L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)3L, (long)6L, (long)5L, (long)6L, (long)4L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)6L, (long)7L, (long)1L, (long)4L, (long)7L, (long)1L, (long)8L, (long)8L, (long)9L, (long)8L, (long)10L, (long)10L, (long)8L, (long)4L, (long)10L, (long)4L, (long)10L, (long)1L, (long)2L, (long)9L, (long)5L, (long)7L, (long)9L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)9L, (long)10L, (long)1L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)7L, (long)5L, (long)8L, (long)7L, (long)5L, (long)3L, (long)7L, (long)5L, (long)10L, (long)10L, (long)3L, (long)6L, (long)10L, (long)2L, (long)8L, (long)6L, (long)5L, (long)4L, (long)9L, (long)5L, (long)3L, (long)10L}))) == (5L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)10L, (long)6L, (long)4L, (long)3L, (long)5L, (long)8L, (long)2L, (long)4L, (long)2L, (long)8L, (long)4L, (long)6L, (long)10L, (long)4L, (long)2L, (long)1L, (long)10L, (long)2L, (long)1L, (long)1L, (long)5L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)10L, (long)4L, (long)8L, (long)2L, (long)10L, (long)5L, (long)1L, (long)2L, (long)9L, (long)5L, (long)5L, (long)6L, (long)3L, (long)8L, (long)6L, (long)4L, (long)10L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)6L, (long)10L, (long)1L, (long)6L, (long)9L, (long)10L, (long)8L, (long)6L, (long)8L, (long)7L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)2L, (long)4L, (long)1L, (long)5L, (long)1L, (long)5L, (long)2L, (long)5L, (long)7L, (long)7L, (long)7L, (long)3L, (long)10L, (long)1L, (long)5L, (long)4L, (long)2L, (long)8L, (long)4L, (long)1L, (long)9L, (long)10L, (long)7L, (long)10L, (long)2L, (long)8L, (long)10L, (long)9L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)6L, (long)4L, (long)2L, (long)8L, (long)7L, (long)5L, (long)6L, (long)4L, (long)10L, (long)4L, (long)6L, (long)3L, (long)7L, (long)8L, (long)8L, (long)3L, (long)1L, (long)4L, (long)2L, (long)2L, (long)10L, (long)7L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)8L, (long)6L, (long)10L, (long)2L, (long)6L, (long)10L, (long)2L, (long)7L, (long)8L, (long)10L, (long)3L, (long)8L, (long)2L, (long)6L, (long)2L, (long)3L, (long)1L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)3L, (long)9L, (long)5L, (long)6L, (long)3L, (long)2L, (long)8L, (long)5L, (long)6L, (long)10L, (long)10L, (long)6L, (long)8L, (long)4L, (long)10L, (long)7L, (long)7L, (long)10L, (long)8L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)10L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)7L, (long)7L, (long)2L, (long)4L, (long)7L, (long)2L, (long)10L, (long)9L, (long)7L, (long)5L, (long)7L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)4L, (long)10L, (long)2L, (long)1L, (long)1L, (long)10L, (long)3L, (long)6L, (long)1L, (long)8L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)7L, (long)9L, (long)9L, (long)9L, (long)3L, (long)4L, (long)1L, (long)5L, (long)9L, (long)1L, (long)2L, (long)1L, (long)1L, (long)10L, (long)7L, (long)5L, (long)6L, (long)7L, (long)6L, (long)7L, (long)7L, (long)6L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)10L, (long)10L, (long)9L, (long)2L}))) == (-1L));
    }

}
"
HumanEval_70,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //ثُمَّ أَكْثَرُ الْأَصْحَابِ الْبَاقِينَ ثُمَّ أَقَلُّهُمْ وَهَكَذَا.    //فَمَا الْمُنْتَقَطُ غَرِيبٌ، إِذَا بَدَأْتَ بِالْقِيمَةِ الدَّانِيَةِ،    //مُعْطَى قَائِمَةِ أَعْدَادٍ، تَرْجِعُ قَائِمَةً بِتَرْتِيبٍ غَرِيبٍ.    // >>> StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))
    // >>> StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L})))
    // (new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))
    // >>> StrangeSortList((new List<long>()))
    // (new List<long>())
    public static List<long> StrangeSortList(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> StrangeSortList(List<long> lst) {
        List<long> result = new List<long>();
        lst.Sort();
        int start = 0;
        int end = lst.Count - 1;
        
        while (start <= end) {
            if (start <= end) {
                result.Add(lst[start]);
                start++;
            }
            if (start <= end) {
                result.Add(lst[end]);
                end--;
            }
        }
        
        return result;
    }
    
    static void Main(string[] args) {
        var example1 = StrangeSortList(new List<long> { 1L, 2L, 3L, 4L });
        var example2 = StrangeSortList(new List<long> { 5L, 5L, 5L, 5L });
        var example3 = StrangeSortList(new List<long>());

        Console.WriteLine(string.Join("", "", example1)); // Output: 1, 4, 2, 3
        Console.WriteLine(string.Join("", "", example2)); // Output: 5, 5, 5, 5
        Console.WriteLine(string.Join("", "", example3)); // Output: (empty line)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L, (long)4L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L, (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L, (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));
    }

}
"
HumanEval_71,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //مِنْ الجَانِبِ الثالثِ.    //ثَلاثَةَ جَانِبَاتٍ تَجْعَلُ ثَلاثَةَ أَطْرَافٍ سَادَةً إِذَا كَانَتْ جُمْلَةُ أَيِّ جَانِبَيْنِ أَكْبَرَ    //وَإِلاَّ رُدَّ -1     //مثلثٌ مُقَدَّرٌ لِعُشْرَيْنِ إنْ كَانَتْ جُنُوبُهُمْ ثُلُثَةً صَحِيحَةً.    //مُعْطَى أَطْوَالِ الْجَانِبَيْنِ مِنْ ثَلَاثَةِ أَوْجُهٍ، أَعِدْ مَوْضِعَ    // >>> TriangleArea((3L), (4L), (5L))
    // (6.0f)
    // >>> TriangleArea((1L), (2L), (10L))
    // (float)-1L
    public static float TriangleArea(long a, long b, long c) {
","public static float TriangleArea(long a, long b, long c) {
    // Check if the sides form a valid triangle using the triangle inequality theorem
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area of the triangle
        double s = (a + b + c) / 2.0;
        double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));
        return (float)Math.Round(area, 2);
    }
    return -1;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((3L), (4L), (5L)) == (6.0f));
    Debug.Assert(TriangleArea((1L), (2L), (10L)) == (float)-1L);
    Debug.Assert(TriangleArea((4L), (8L), (5L)) == (8.18f));
    Debug.Assert(TriangleArea((2L), (2L), (2L)) == (1.73f));
    Debug.Assert(TriangleArea((1L), (2L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((10L), (5L), (7L)) == (16.25f));
    Debug.Assert(TriangleArea((2L), (6L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((1L), (1L), (1L)) == (0.43f));
    Debug.Assert(TriangleArea((2L), (2L), (10L)) == (float)-1L);
    }

}
"
HumanEval_72,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //كَيْ يَطِيرَ إنْ كَانَ مُتَوَازِنًا (هُوَ قِيَاسٌ مُتَعَدِّدٌ) وَكَانَتْ مَجْمُوعَةُ أَلْفَاتِهِ أَقَلَّ مِنْ أَوْ مُسَاوِيًا لِأَكْبَرِ وَزْنٍ مُمْكِنٍ w.    //كَتِبْ دَلِيلَ يَرْجِعُ حَقًّا إِنْ طَارَ الجَسَدُ q، وَكَذِبًا إِلَّا.    // >>> WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L})), (5L))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    public static bool WillItFly(List<long> q, long w) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool WillItFly(List<long> q, long w)
    {
        if (IsPalindromic(q) && SumIsLessThanOrEqual(q, w))
        {
            return true;
        }
        return false;
    }

    private static bool IsPalindromic(List<long> q)
    {
        int count = q.Count;
        for (int i = 0; i < count / 2; i++)
        {
            if (q[i] != q[count - i - 1])
            {
                return false;
            }
        }
        return true;
    }

    private static bool SumIsLessThanOrEqual(List<long> q, long w)
    {
        long sum = 0;
        foreach (var item in q)
        {
            sum += item;
            if (sum > w)
            {
                return false;
            }
        }
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L})), (5L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (6L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)5L})), (5L)) == (true));
    }

}
"
HumanEval_73,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //يَقْرَأُ بِنَفْسِهِ مِنْ خَلْفٍ وَمِنْ قُدُومٍ. فِي تَغْيِيرٍ وَاحِدٍ، تَغْيِيرُ عَنْصَرٍ بِعَنْصَرٍ آخَرَ.    //يَجِبُ أَنْ يُغَيَّرَ لِيُصْنَعَ الْقَائِمَةَ بِالْمُتَقَابِلِ.    //مُعْطَيَةَ قَائِمَةِ arr مِنْ الأَصْحَابِ، أَعْرِفُ الحَدَّ الأَقَلَّ مِنَ العَنَاصِرِ    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L})))
    // (4L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L})))
    // (1L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L})))
    // (0L)
    public static long SmallestChange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SmallestChange(List<long> arr)
    {
        long changes = 0;
        int left = 0;
        int right = arr.Count - 1;

        while (left < right)
        {
            if (arr[left] != arr[right])
            {
                changes++;
            }
            left++;
            right--;
        }

        return changes;
    }

    static void Main()
    {
        // Example usage:
        List<long> list1 = new List<long> { 1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L };
        Console.WriteLine(SmallestChange(list1)); // Output: 4

        List<long> list2 = new List<long> { 1L, 2L, 3L, 4L, 3L, 2L, 2L };
        Console.WriteLine(SmallestChange(list2)); // Output: 1

        List<long> list3 = new List<long> { 1L, 2L, 3L, 2L, 1L };
        Console.WriteLine(SmallestChange(list3)); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L}))) == (4L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)3L, (long)1L, (long)1L, (long)3L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    }

}
"
HumanEval_74,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //إِنْ كَانَ لِلْقَوْلَيْنِ عَدَدُ حَرْفٍ مُتَسَاوِي، فَارْجِعْ بِالْقَوْلِ الأَوَّلِ.    //كُلّ عَدَدِ الْكَوَاتِبِ فِي كُلِّ سَلَسِلِ الْقَائِمَةِ أَقَلَّ مِنَ الْقَائِمَةِ الْأُخْرَى    //اُكْتُبْ دَلِيْلَةً تَقْبَلُ قَوْمَيْ سَلاَسِلٍ وَتَرُدُّ القَائِمَةَ الَّتِيْ عِنْدَهَا    // >>> TotalMatch((new List<string>()), (new List<string>()))
    // (new List<string>())
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""})))
    // (new List<string>(new string[]{(string)""hi"", (string)""admin""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""})))
    // (new List<string>(new string[]{(string)""4""}))
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2)
    {
        int totalCharsLst1 = lst1.Sum(s => s.Length);
        int totalCharsLst2 = lst2.Sum(s => s.Length);

        if (totalCharsLst1 <= totalCharsLst2)
        {
            return lst1;
        }
        else
        {
            return lst2;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>())).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""}))).Equals((new List<string>(new string[]{(string)""4""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""Hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hii""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>(new string[]{(string)""this""}))).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""this""})), (new List<string>())).Equals((new List<string>())));
    }

}
"
HumanEval_75,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //مَعْرِفَةً بِأَنَّ (أ) أَقَلُّ مِنْ 100.    //وَكَذِبَ إِلاَّ هُوَ.    //اُكْتُبْ دَلِيْلَ يَرُدُّ صَحِيْحًا إِنْ كَانَ العَدَدُ المَوْصُوْفُ ضِرْبَةَ 3 أَعْدَادٍ أَوَّلِيَّة     // >>> IsMultiplyPrime((30L))
    // (true)
    // 30 = 2 * 3 * 5
    public static bool IsMultiplyPrime(long a) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsMultiplyPrime(long a) {
        if (a >= 100) return false;
        
        List<long> primes = GeneratePrimes(100);
        
        int count = 0;
        foreach (long prime in primes) {
            while (a % prime == 0) {
                a /= prime;
                count++;
            }
            if (count > 3) break;
        }
        
        return a == 1 && count == 3;
    }

    private static List<long> GeneratePrimes(int max) {
        List<long> primes = new List<long>();
        bool[] isPrime = new bool[max + 1];
        for (int i = 2; i <= max; i++) isPrime[i] = true;

        for (int i = 2; i * i <= max; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= max; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for (int i = 2; i <= max; i++) {
            if (isPrime[i]) primes.Add(i);
        }

        return primes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsMultiplyPrime((5L)) == (false));
    Debug.Assert(IsMultiplyPrime((30L)) == (true));
    Debug.Assert(IsMultiplyPrime((8L)) == (true));
    Debug.Assert(IsMultiplyPrime((10L)) == (false));
    Debug.Assert(IsMultiplyPrime((125L)) == (true));
    Debug.Assert(IsMultiplyPrime((105L)) == (true));
    Debug.Assert(IsMultiplyPrime((126L)) == (false));
    Debug.Assert(IsMultiplyPrime((729L)) == (false));
    Debug.Assert(IsMultiplyPrime((891L)) == (false));
    Debug.Assert(IsMultiplyPrime((1001L)) == (true));
    }

}
"
HumanEval_76,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //x عَلَى قَدْرِ ن إذا ن**int=x     //قوةْ n وَكَذِبْ في الحالاتِ الاخرى    //مَهْمَلُكَ أَنْ تَكْتُبَ دَلِيْلَةً تَرُدُّ صَحِيحَةً إِنْ كَانَ عَدَدٌ x عَدَدٌ بَسِيْرٌ    // >>> IsSimplePower((1L), (4L))
    // (true)
    // >>> IsSimplePower((2L), (2L))
    // (true)
    // >>> IsSimplePower((8L), (2L))
    // (true)
    // >>> IsSimplePower((3L), (2L))
    // (false)
    // >>> IsSimplePower((3L), (1L))
    // (false)
    // >>> IsSimplePower((5L), (3L))
    // (false)
    public static bool IsSimplePower(long x, long n) {
","if (x < 1 || n < 2)
        return false;

    while (x > 1)
    {
        if (x % n != 0)
            return false;
        x /= n;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSimplePower((16L), (2L)) == (true));
    Debug.Assert(IsSimplePower((143214L), (16L)) == (false));
    Debug.Assert(IsSimplePower((4L), (2L)) == (true));
    Debug.Assert(IsSimplePower((9L), (3L)) == (true));
    Debug.Assert(IsSimplePower((16L), (4L)) == (true));
    Debug.Assert(IsSimplePower((24L), (2L)) == (false));
    Debug.Assert(IsSimplePower((128L), (4L)) == (false));
    Debug.Assert(IsSimplePower((12L), (6L)) == (false));
    Debug.Assert(IsSimplePower((1L), (1L)) == (true));
    Debug.Assert(IsSimplePower((1L), (12L)) == (true));
    }

}
"
HumanEval_77,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَعْلِيقَة: تَجِبُ أَنْ تَتَأَمَّلَ أَنَّ الْمَدْخُولَ دَائِمًا.    //إنْ كَانَ هَذَا الْمُكَبَّرُ مِنْ عَدَدٍ كُلِّيٍّ.    //اُكْتُبْ دَلِيْلَ يَأْخُذُ عَدَدَ كُلٍّ a وَيَرُدُّ true     // >>> Iscube((1L))
    // (true)
    // >>> Iscube((2L))
    // (false)
    // >>> Iscube((-1L))
    // (true)
    // >>> Iscube((64L))
    // (true)
    // >>> Iscube((0L))
    // (true)
    // >>> Iscube((180L))
    // (false)
    public static bool Iscube(long a) {
","using System;

class Problem {
    public static bool Iscube(long a) {
        if (a == 0) return true;
        long absA = Math.Abs(a);
        long cubeRoot = (long)Math.Round(Math.Pow(absA, 1.0 / 3.0));
        return cubeRoot * cubeRoot * cubeRoot == absA;
    }

    static void Main(string[] args) {
        Console.WriteLine(Iscube(1L));    // true
        Console.WriteLine(Iscube(2L));    // false
        Console.WriteLine(Iscube(-1L));   // true
        Console.WriteLine(Iscube(64L));   // true
        Console.WriteLine(Iscube(0L));    // true
        Console.WriteLine(Iscube(180L));  // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Iscube((1L)) == (true));
    Debug.Assert(Iscube((2L)) == (false));
    Debug.Assert(Iscube((-1L)) == (true));
    Debug.Assert(Iscube((64L)) == (true));
    Debug.Assert(Iscube((180L)) == (false));
    Debug.Assert(Iscube((1000L)) == (true));
    Debug.Assert(Iscube((0L)) == (true));
    Debug.Assert(Iscube((1729L)) == (false));
    }

}
"
HumanEval_78,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //وَالأَلْوَاحُ أ، ب، ج، د، إي، ف كَبِيرَةٌ دَائِمًا.    //تَنْبِيه: تَجُوزُ أَنْ تَتَّخِذَ الْمَدْخُول دَائِمًا صَحِيحًا أَوْ خَالِيًا.    //ب (= عَشْرِيَّةِ 11) ، د (= عَشْرِيَّةِ 13)     //فَيَجِبُ أَنْ تَحْدُدَ عَدَدَ أَحْدَى الأَرْبَاعِ التَّالِيَةِ: 2، 3، 5، 7،     //أَعْدَدُ الأَوَّلِينَ هُمْ: 2، 3، 5، 7، 11، 13، 17، ...    //أَشْعَرَةُ الْعَشْرِينَ عَشْرَةُ أَشْعَرَةٌ هِيَ: 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، أ، ب، ج، د، إ، ف.    //اكبر مِنْ 1 لَيْسَ بِنَاتِجِ اثْنَيْنِ أصْغَرَيْنِ)    //أَرْبَعَةُ أَعْدَادٍ أَوْ أَوْلَى عَدَدٌ عَدَدٌ    //a hexadecimal number كَسِلْسِلَةٍ وَيَعُدُّ عَدَدَ الْهَكَسَادِيْمَالِيْنَ     //تَكُونُ مُكَلَّفَةً بِكَتْبِ دَالِي تَلَقَّى    // >>> HexKey((""AB""))
    // (1L)
    // >>> HexKey((""1077E""))
    // (2L)
    // >>> HexKey((""ABED1A33""))
    // (4L)
    // >>> HexKey((""123456789ABCDEF0""))
    // (6L)
    // >>> HexKey((""2020""))
    // (2L)
    public static long HexKey(string num) {
","public static long HexKey(string num) {
    // Define a set of prime hexadecimal digits
    HashSet<char> primeHexDigits = new HashSet<char> { '2', '3', '5', '7', 'B', 'D' };

    long primeCount = 0;

    // Iterate through each character in the input string
    foreach (char c in num) {
        // If the character is in the set of prime hex digits, increase the count
        if (primeHexDigits.Contains(c)) {
            primeCount++;
        }
    }

    return primeCount;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HexKey((""AB"")) == (1L));
    Debug.Assert(HexKey((""1077E"")) == (2L));
    Debug.Assert(HexKey((""ABED1A33"")) == (4L));
    Debug.Assert(HexKey((""2020"")) == (2L));
    Debug.Assert(HexKey((""123456789ABCDEF0"")) == (6L));
    Debug.Assert(HexKey((""112233445566778899AABBCCDDEEFF00"")) == (12L));
    }

}
"
HumanEval_79,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //الحروف الإضافية هُنَاكَ لِتَسْاعَدَ بِالتَّنْسِيقِ.    //سَيَكُونُ بَعْضُ حُرُوفِ 'db' فِي بَدْءِ السِّلْسِلَةِ وَفِي آخِرِهَا.    //كُلُّ حَرْفٍ فِي السِّلْسِلَةِ سَيَكُونُ ""0"" أَو ""1"".    //بَينَارِيَةُ شَكْلِ. فَتْلَةُ يَجِبُ أَنْ تَرُدَّ سِلْسِلَةً، بِكُلِّ حَرْفٍ يَمْثُلُ بَينَارِيَةً     //سَتُعْطَى عَدَدَةٌ بِشَكْلِ عَشَرِيٍّ وَمُهِمَّتُكَ تَحْوِيلُهَا إلَى    // >>> DecimalToBinary((15L))
    // (""db1111db"")
    // >>> DecimalToBinary((32L))
    // (""db100000db"")
    public static string DecimalToBinary(long decimalNum) {
","public static string DecimalToBinary(long decimalNum) {
    string binary = Convert.ToString(decimalNum, 2);
    return ""db"" + binary + ""db"";
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DecimalToBinary((0L)).Equals((""db0db"")));
    Debug.Assert(DecimalToBinary((32L)).Equals((""db100000db"")));
    Debug.Assert(DecimalToBinary((103L)).Equals((""db1100111db"")));
    Debug.Assert(DecimalToBinary((15L)).Equals((""db1111db"")));
    }

}
"
HumanEval_80,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //سِلْسِلَةٌ هَابِسَةٌ إِنْ كَانَ طُولُهَا 3 وَكُلُّ 3 حُرُوفٍ مُتَتَابِعَةٍ مُمَيِّزَةٌ    //مَهْمَلُكَ هُوَ التَّحْقِيقُ إِنْ كَانَتِ السِّلْسِلَةُ هَابِسَةً أَمْ لا.    //تُعْطَى سِلْسِلَةٌ s.    // >>> IsHappy((""a""))
    // (false)
    // >>> IsHappy((""aa""))
    // (false)
    // >>> IsHappy((""abcd""))
    // (true)
    // >>> IsHappy((""aabb""))
    // (false)
    // >>> IsHappy((""adb""))
    // (true)
    // >>> IsHappy((""xyy""))
    // (false)
    public static bool IsHappy(string s) {
","if (s.Length < 3) {
        return false;
    }

    for (int i = 0; i <= s.Length - 3; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsHappy((""a"")) == (false));
    Debug.Assert(IsHappy((""aa"")) == (false));
    Debug.Assert(IsHappy((""abcd"")) == (true));
    Debug.Assert(IsHappy((""aabb"")) == (false));
    Debug.Assert(IsHappy((""adb"")) == (true));
    Debug.Assert(IsHappy((""xyy"")) == (false));
    Debug.Assert(IsHappy((""iopaxpoi"")) == (true));
    Debug.Assert(IsHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //0.0 إِي     //> 0.0 دَ    //> 0.7 دَ    //> 1.0 د+     //> 1.3 C-     //> 1.7 سَ    //> 2.0 C+  أَوْ    //> 2.3 بِ    //> 2.7 بَ    //> 3.0 ب+     //> 3.3 أَ    //> 3.7 أَ    //4.0 أَ +     //مَعدَلُ المُؤَدَاةِ.    //a function that can output a list of letter grades using the following table:  يَجُوزُ أَنْ يُخْرِجَ رَتْبَ حَرْفٍ بِالْجَدَلِ الْأَوَّلِ:    //وَأَعْطَاكَ a قَائِمَة مِنْ GPA لبعض الطلابِ وَلَكَ أَنْ تَكْتُبَ     //المَشَكَّةُ الوحِيدَةُ، أَنَّهَا فَقَدَتْ الشِّفرَةَ الَّتي أَستخدَمَتْها لِلتَّصْفِيَةِ.    //مُعَلِّمٌ يَصْنَعُ خُطَّتَهُ لِلتَّعْمِيلِ    //هُوَ الأَسبوعُ الأخِرُ مِنَ الفِصلِ وَالمُعلِمُ يَجِبُ أَنْ يُعطيَ الدرجاتَ    // >>> GradeEquation((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f})))
    // (new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))
    public static List<string> NumericalLetterGrade(List<float> grades) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> NumericalLetterGrade(List<float> grades)
    {
        List<string> letterGrades = new List<string>();

        foreach (var gpa in grades)
        {
            if (gpa == 4.0f)
                letterGrades.Add(""A+"");
            else if (gpa > 3.7f)
                letterGrades.Add(""A"");
            else if (gpa > 3.3f)
                letterGrades.Add(""A-"");
            else if (gpa > 3.0f)
                letterGrades.Add(""B+"");
            else if (gpa > 2.7f)
                letterGrades.Add(""B"");
            else if (gpa > 2.3f)
                letterGrades.Add(""B-"");
            else if (gpa > 2.0f)
                letterGrades.Add(""C+"");
            else if (gpa > 1.7f)
                letterGrades.Add(""C"");
            else if (gpa > 1.3f)
                letterGrades.Add(""C-"");
            else if (gpa > 1.0f)
                letterGrades.Add(""D+"");
            else if (gpa > 0.7f)
                letterGrades.Add(""D"");
            else if (gpa > 0.0f)
                letterGrades.Add(""D-"");
            else
                letterGrades.Add(""E"");
        }

        return letterGrades;
    }

    static void Main(string[] args)
    {
        List<float> gpas = new List<float> { 4.0f, 3.0f, 1.7f, 2.0f, 3.5f };
        List<string> grades = NumericalLetterGrade(gpas);
        Console.WriteLine(string.Join("", "", grades));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f}))).Equals((new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.2f}))).Equals((new List<string>(new string[]{(string)""D+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.5f}))).Equals((new List<string>(new string[]{(string)""D-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f}))).Equals((new List<string>(new string[]{(string)""E""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))).Equals((new List<string>(new string[]{(string)""D"", (string)""D-"", (string)""C-"", (string)""B"", (string)""B+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f, (float)0.7f}))).Equals((new List<string>(new string[]{(string)""E"", (string)""D-""}))));
    }

}
"
HumanEval_82,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //طُولُ عَدَدٌ أَوْ كَذِبٌ إِلاّ    //اِكْتُبْ دَلِيْلَةً تَأْخُذُ سِلْسِلَةً وَتَرُدُّ صَحِيْحَةً إِنْ كَانَتْ السِلْسِلَةُ     // >>> PrimeLength((""Hello""))
    // (true)
    // >>> PrimeLength((""abcdcba""))
    // (true)
    // >>> PrimeLength((""kittens""))
    // (true)
    // >>> PrimeLength((""orange""))
    // (false)
    public static bool PrimeLength(string str) {
","using System;

class Problem {
    public static bool PrimeLength(string str) {
        int length = str.Length;
        if (length < 2) return false;
        
        for (int i = 2; i <= Math.Sqrt(length); i++) {
            if (length % i == 0) return false;
        }
        
        return true;
    }
    
    // Example usage
    public static void Main() {
        Console.WriteLine(PrimeLength(""Hello""));    // true
        Console.WriteLine(PrimeLength(""abcdcba""));  // true
        Console.WriteLine(PrimeLength(""kittens""));  // true
        Console.WriteLine(PrimeLength(""orange""));   // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeLength((""Hello"")) == (true));
    Debug.Assert(PrimeLength((""abcdcba"")) == (true));
    Debug.Assert(PrimeLength((""kittens"")) == (true));
    Debug.Assert(PrimeLength((""orange"")) == (false));
    Debug.Assert(PrimeLength((""wow"")) == (true));
    Debug.Assert(PrimeLength((""world"")) == (true));
    Debug.Assert(PrimeLength((""MadaM"")) == (true));
    Debug.Assert(PrimeLength((""Wow"")) == (true));
    Debug.Assert(PrimeLength(("""")) == (false));
    Debug.Assert(PrimeLength((""HI"")) == (true));
    Debug.Assert(PrimeLength((""go"")) == (true));
    Debug.Assert(PrimeLength((""gogo"")) == (false));
    Debug.Assert(PrimeLength((""aaaaaaaaaaaaaaa"")) == (false));
    Debug.Assert(PrimeLength((""Madam"")) == (true));
    Debug.Assert(PrimeLength((""M"")) == (false));
    Debug.Assert(PrimeLength((""0"")) == (false));
    }

}
"
HumanEval_83,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أَجْمَلَاتٌ إيجَابِيَّةٌ تَبْدَأُ أَو تَنْتَهِي بِ1.    //مُنَطَقٌ بِكُلِّيٍّ نَافِعٍ، رُدَّ عَدَدَ أَرْكَانِ الْأَرْكَانِ نَافِعَةٍ     public static long StartsOneEnds(long n) {
","if (n == 1) return 1;
        return (long)Math.Pow(10, n - 1) + 9 * (long)Math.Pow(10, n - 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StartsOneEnds((1L)) == (1L));
    Debug.Assert(StartsOneEnds((2L)) == (18L));
    Debug.Assert(StartsOneEnds((3L)) == (180L));
    Debug.Assert(StartsOneEnds((4L)) == (1800L));
    Debug.Assert(StartsOneEnds((5L)) == (18000L));
    }

}
"
HumanEval_84,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلْ    //مَنْصُوبٌ عَلَى عَدَدِ كُلٍّ نَافِعٍ، رُدُّ جُمْلَةَ أَشْرَافِهِ بِالنَّصْبِ.    // >>> Solve((1000L))
    // (""1"")
    // >>> Solve((150L))
    // (""110"")
    // >>> Solve((147L))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    public static string Solve(long N) {
","public static string Solve(long N) {
        int sumOfDigits = 0;
        while (N > 0) {
            sumOfDigits += (int)(N % 10);
            N /= 10;
        }
        return Convert.ToString(sumOfDigits, 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((1000L)).Equals((""1"")));
    Debug.Assert(Solve((150L)).Equals((""110"")));
    Debug.Assert(Solve((147L)).Equals((""1100"")));
    Debug.Assert(Solve((333L)).Equals((""1001"")));
    Debug.Assert(Solve((963L)).Equals((""10010"")));
    }

}
"
HumanEval_85,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //مُعْطَيَةَ قَائِمَةٍ غَيْرِ فَارِغَةٍ مِنَ الأَصْحَابِ أَوَّلَاً، أَضِفْ العَنَاصِرَ الزَّوَائِفَ الَّتِي فِي أَسْمَاءٍ فُرَادِيَّةٍ.    // >>> Add((new List<long>(new long[]{(long)4L, (long)2L, (long)6L, (long)7L})))
    // (2L)
    public static long Add(List<long> lst) {
","long sum = 0;
    for (int i = 1; i < lst.Count; i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)88L}))) == (88L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)5L, (long)6L, (long)7L, (long)2L, (long)122L}))) == (122L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)0L, (long)6L, (long)7L}))) == (0L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)4L, (long)6L, (long)8L}))) == (12L));
    }

}
"
HumanEval_86,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //تَعْلِيقَة: يَجِبُ أَنْ تَحْفَظَ تَرْتِيبَ الكَلِمَاتِ وَالفُرُوجِ فِي الجُمْلَةِ.    //تَرْتِيبٌ صَاعِدٌ بِنَاءً عَلَى قِيمَةِ ascii    //تُسْتَبْدَلُ بِكَلِمَةٍ جَدِيدَةٍ حَيْثُ كُلُّ الْحُرُوفِ مُنْتَظَمَةٌ    //وَصْفُ سِلْسِلَةٍ مُتَرَتِّبَةٌ، سِلْسِلَةٌ فِيهَا كُلُّ كَلِمَاتٍ (مُفَرَّقَةٌ بِفَرْضٍ)    //كَتِبْ دَلِيلَ يَأْخُذُ سِلْسِلَةً وَيَرُدُّ إِسْنَادَهَا مُتَرَتِّبَاً.    // >>> AntiShuffle((""Hi""))
    // (""Hi"")
    // >>> AntiShuffle((""hello""))
    // (""ehllo"")
    // >>> AntiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    public static string AntiShuffle(string s) {
","using System;
using System.Linq;

class Problem
{
    public static string AntiShuffle(string s)
    {
        return string.Join("" "", s.Split(' ')
            .Select(word => string.Concat(word.OrderBy(c => c))));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AntiShuffle((""Hi"")).Equals((""Hi"")));
    Debug.Assert(AntiShuffle((""hello"")).Equals((""ehllo"")));
    Debug.Assert(AntiShuffle((""number"")).Equals((""bemnru"")));
    Debug.Assert(AntiShuffle((""abcd"")).Equals((""abcd"")));
    Debug.Assert(AntiShuffle((""Hello World!!!"")).Equals((""Hello !!!Wdlor"")));
    Debug.Assert(AntiShuffle(("""")).Equals(("""")));
    Debug.Assert(AntiShuffle((""Hi. My name is Mister Robot. How are you?"")).Equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //وَأَيْضًا، أَنْزِلْ إِحْدَادَاتَ الصَّفِّ بِالْعُمُودِ فِي تَرْتِيبٍ مُنْحَدِرٍ.    //تَنْظِمُ الإِسْتِعْدَادَاتَ مُبْتَدَأً بِالصُّفُوفِ فِي التَّصْعِيدِ.    //كُلُّ مُتَوَاصِلٍ هُوَ مُوَاصِلٌ - (صَفٌّ، عُمُودٌ) ، يَبْدَأُ بِ 0.    //وَيَرْجِعُ لِسَانَ الْمُتَوَاصِلِينَ، [(x1, y1), (x2, y2) ...] كَذَا     //مُعْطَى lst، وَكُلُّ عَدَدٍ x، وَجِدُوا أَعْدَدَ x فِي الْقَائِمَةِ،     //كُلُّ صَفٍّ يَجُوزُ أَنْ يَكُونَ لَهُ عَدَدٌ مُخْتَلِفٌ مِنَ الْعُمُودِ.    //وَهُوَ مِثْلُ المَتْرَسِ، وَلَكِنْ بِخِلَافِ المَتْرَسِ،    //تُعْطَى مَعْرُوفَاتٌ ثَنِيَّةٌ، كَقُلُوْصٍ مُتَعَدِّدَةٍ،    // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))
    // >>> GetRow((new List<List<long>>()), (1L))
    // (new List<Tuple<long, long>>())
    // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
        var result = new List<Tuple<long, long>>();
        
        for (long row = 0; row < lst.Count; row++) {
            List<long> currentRow = lst[(int)row];
            var foundIndices = new List<long>();
            
            for (long col = 0; col < currentRow.Count; col++) {
                if (currentRow[(int)col] == x) {
                    foundIndices.Add(col);
                }
            }
            
            foundIndices.Sort((a, b) => b.CompareTo(a)); // Sort columns in descending order
            
            foreach (var col in foundIndices) {
                result.Add(Tuple.Create(row, col));
            }
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})})), (2L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 1L), (Tuple<long, long>)Tuple.Create(1L, 1L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(3L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(5L, 1L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)1L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(2L, 0L), (Tuple<long, long>)Tuple.Create(3L, 2L), (Tuple<long, long>)Tuple.Create(3L, 0L), (Tuple<long, long>)Tuple.Create(4L, 3L), (Tuple<long, long>)Tuple.Create(4L, 0L), (Tuple<long, long>)Tuple.Create(5L, 4L), (Tuple<long, long>)Tuple.Create(5L, 0L), (Tuple<long, long>)Tuple.Create(6L, 5L), (Tuple<long, long>)Tuple.Create(6L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>()), (1L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L})})), (2L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))));
    }

}
"
HumanEval_88,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //* لَا تُغَيِّرْ الْقَائِمَةَ الْمَوْهُوبَةَ.    //تَذْكِرَة:    //أَوْ يُصَنِّفُهُ بِتَنْزِيلِ الْمَنْزِلِ إِنْ كَانَتْ مَجْمُوعَةً ((أَوَّلُ قِيمَةِ فَهْمٍ، آخِرُ قِيمَةِ فَهْمٍ))    //تُصَنِّفُ الْقَائِمَةَ بِالتَّصْعِيدِ إِذَا كَانَتْ مَجْمُوعَةً ((قِيمَةُ الْمُؤَوَّلِ، قِيمَةُ الْمُؤَوَّلِ)) فُرَادِيَّةً،     //مَنْ أُعْطِيَ قِيمَةَ لَا سُبُلَ لِلْكُلِّيَّاتِ، رُدَّ أَلْفَ أَلْفٍ مِنْ الْقِيمَةِ بَعْدَ الْمُنَقِّمَةِ،    // >>> SortArray((new List<long>()))
    // (new List<long>())
    // >>> SortArray((new List<long>(new long[]{(long)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))
    public static List<long> SortArray(List<long> array) {
","public static List<long> SortArray(List<long> array) {
        if (array == null || array.Count <= 1) {
            return new List<long>(array);
        }
        
        long firstValue = array[0];
        long lastValue = array[array.Count - 1];
        long sum = firstValue + lastValue;

        List<long> sortedArray = new List<long>(array);

        if (sum % 2 != 0) { // sum is odd, sort ascending
            sortedArray.Sort();
        } else { // sum is even, sort descending
            sortedArray.Sort();
            sortedArray.Reverse();
        }

        return sortedArray;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)5L}))).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)15L, (long)42L, (long)87L, (long)32L, (long)11L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)11L, (long)15L, (long)32L, (long)42L, (long)87L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)21L, (long)14L, (long)23L, (long)11L}))).Equals((new List<long>(new long[]{(long)23L, (long)21L, (long)14L, (long)11L}))));
    }

}
"
HumanEval_89,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //تَحَوَّلْ لِثَانِيَةٍ مُضَاعَفَةٍ إِلَى مَكَانَيْنِ.    //الْأَلِفُ يَجِبُ أَنْ يُدَوَّرَ بِطَرِيقَةٍ حَتَّى تَكُونَ الحُرُوفُ    //يَعُودُ سِلْسِلَةً مُشَفَّرَةً بِالْأَلِفِ تُدَارِجُ.    //تَخْلُقُ تَشْفِيرَ دَالِيَةٍ تَتَّخِذُ سِلْسِلَةً كَدَلِيلٍ و     // >>> Encrypt((""hi""))
    // (""lm"")
    // >>> Encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> Encrypt((""gf""))
    // (""kj"")
    // >>> Encrypt((""et""))
    // (""ix"")
    public static string Encrypt(string s) {
","const int shiftAmount = 4; // 2 multiplied by 2 equals 4.

    StringBuilder encrypted = new StringBuilder();

    foreach (char c in s) {
        if (char.IsLetter(c)) {
            char start = char.IsUpper(c) ? 'A' : 'a';
            char encryptedChar = (char)(start + (c - start + shiftAmount) % 26);
            encrypted.Append(encryptedChar);
        } else {
            encrypted.Append(c); // Non-letter characters are not encrypted.
        }
    }

    return encrypted.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encrypt((""hi"")).Equals((""lm"")));
    Debug.Assert(Encrypt((""asdfghjkl"")).Equals((""ewhjklnop"")));
    Debug.Assert(Encrypt((""gf"")).Equals((""kj"")));
    Debug.Assert(Encrypt((""et"")).Equals((""ix"")));
    Debug.Assert(Encrypt((""faewfawefaewg"")).Equals((""jeiajeaijeiak"")));
    Debug.Assert(Encrypt((""hellomyfriend"")).Equals((""lippsqcjvmirh"")));
    Debug.Assert(Encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).Equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    Debug.Assert(Encrypt((""a"")).Equals((""e"")));
    }

}
"
HumanEval_90,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //رُدَّ null إِنْ لَمْ يَكُنْ هَذَا العَنَاقِدُ    //كَتَبْتُ دَلِيلَ next_smallest (() يَرُدُّ ثَانِيَ أَصْغَرَ عَنْصَرَةٍ فِي الْقَائِمَةِ.    //تُعْطَى لِسْمَةٌ مِنْ أَعْدَادٍ.    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // 2L
    // >>> NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))
    // 2L
    // >>> NextSmallest((new List<long>()))
    // null
    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))
    // null
    public static Nullable<long> NextSmallest(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Nullable<long> NextSmallest(List<long> lst) {
        if (lst == null || lst.Count < 2) {
            return null;
        }

        HashSet<long> uniqueElements = new HashSet<long>(lst);
        if (uniqueElements.Count < 2) {
            return null;
        }

        List<long> sortedUniqueElements = uniqueElements.ToList();
        sortedUniqueElements.Sort();

        return sortedUniqueElements[1];
    }

    static void Main(string[] args) {
        Console.WriteLine(NextSmallest(new List<long> {1, 2, 3, 4, 5})); // 2
        Console.WriteLine(NextSmallest(new List<long> {5, 1, 4, 3, 2})); // 2
        Console.WriteLine(NextSmallest(new List<long>())); // null
        Console.WriteLine(NextSmallest(new List<long> {1, 1})); // null
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>())).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)0L}))).Equals(1L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));
    }

}
"
HumanEval_91,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //جُمُوعُ تَتَحَيَّرُ بِ "" ""، ""؟ "" أَوْ ""! ""    //مِنْ مَلَلٍ. مَلَلٌ جُمْلَةٌ تَبْدَأُ بِكَلِمَةِ ""أَنَا"".    //سَتُعْطَى سِلْسِلَةَ كَلِمَاتٍ، وَمُهِمَّتُكَ عَدُّ العَدَدِ.    // >>> IsBored((""Hello world""))
    // (0L)
    // >>> IsBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1L)
    public static long IsBored(string S) {
","using System;

class Problem {
    public static long IsBored(string S) {
        // Split the input string into sentences based on delimiters '.', '?', '!'
        char[] delimiters = new char[] { '.', '?', '!' };
        string[] sentences = S.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);

        // Count sentences that start with 'I' after trimming leading whitespaces
        long boredomCount = 0;
        foreach (string sentence in sentences) {
            if (sentence.TrimStart().StartsWith(""I"")) {
                boredomCount++;
            }
        }

        return boredomCount;
    }

    static void Main(string[] args) {
        // Example usage:
        Console.WriteLine(IsBored(""Hello world"")); // Output: 0
        Console.WriteLine(IsBored(""The sky is blue. The sun is shining. I love this weather"")); // Output: 1
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsBored((""Hello world"")) == (0L));
    Debug.Assert(IsBored((""Is the sky blue?"")) == (0L));
    Debug.Assert(IsBored((""I love It !"")) == (1L));
    Debug.Assert(IsBored((""bIt"")) == (0L));
    Debug.Assert(IsBored((""I feel good today. I will be productive. will kill It"")) == (2L));
    Debug.Assert(IsBored((""You and I are going for a walk"")) == (0L));
    }

}
"
HumanEval_92,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //يَرُدُّ كَذِبَ فِي كُلِّ حَالٍ آخَرَ.    //يَرُدُّ صَحِيحًا إِنْ كَانَ أَحَدُ الأَرْقَامِ مُسَاوِيًا لِجُمْلَةِ الأَرْقَامِ الأُخْرَى، وَكُلُّ الأَرْقَامِ عَدَدٌ كَامِلٌ.    //تَخْلُقُ دَلِيلَةً تَتَأَخَّذُ ثَلَاثَةَ أَرْقَامٍ.    // >>> AnyInt((float)5L, (float)2L, (float)7L)
    // (true)
    // >>> AnyInt((float)3L, (float)2L, (float)2L)
    // (false)
    // >>> AnyInt((float)3L, (float)-2L, (float)1L)
    // (true)
    // >>> AnyInt((3.6f), (-2.2f), (float)2L)
    // (false)
    public static bool AnyInt(float x, float y, float z) {
","public static bool AnyInt(float x, float y, float z) {
        if (x == Math.Round(x) && y == Math.Round(y) && z == Math.Round(z)) {
            if (x == y + z || y == x + z || z == x + y) {
                return true;
            }
        }
        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AnyInt((float)2L, (float)3L, (float)1L) == (true));
    Debug.Assert(AnyInt((2.5f), (float)2L, (float)3L) == (false));
    Debug.Assert(AnyInt((1.5f), (float)5L, (3.5f)) == (false));
    Debug.Assert(AnyInt((float)2L, (float)6L, (float)2L) == (false));
    Debug.Assert(AnyInt((float)4L, (float)2L, (float)2L) == (true));
    Debug.Assert(AnyInt((2.2f), (2.2f), (2.2f)) == (false));
    Debug.Assert(AnyInt((float)-4L, (float)6L, (float)2L) == (true));
    Debug.Assert(AnyInt((float)2L, (float)1L, (float)1L) == (true));
    Debug.Assert(AnyInt((float)3L, (float)4L, (float)7L) == (true));
    Debug.Assert(AnyInt((3.0f), (float)4L, (float)7L) == (false));
    }

}
"
HumanEval_93,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَأَمَّلْ حُرُوفَاً.    //حَرْفٌ فِي أَلِفِ الإِنْجِيلِيِّ.    //الرسالة بِالحرفِ الّذي يَظْهَرُ مَوْضُوعَيْنِ قُبَيْلَ ذلك     //يَسْتَبْدِلُ كُلَّ حُرُوفٍ، يَسْتَبْدِلُ كُلَّ حُرُوفٍ فِي    //اُكْتُبْ دَلِيْلَةً تَأْخُذُ رِسَالَةً، وَتُشَفِّرُ فِيْهَا    // >>> Encode((""test""))
    // (""TGST"")
    // >>> Encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    public static string Encode(string message) {
","public static string Encode(string message) {
    // Define vowels and their replacements
    Dictionary<char, char> vowelReplacement = new Dictionary<char, char>
    {
        { 'a', 'c' },
        { 'e', 'g' },
        { 'i', 'k' },
        { 'o', 'q' },
        { 'u', 'w' },
        { 'A', 'C' },
        { 'E', 'G' },
        { 'I', 'K' },
        { 'O', 'Q' },
        { 'U', 'W' }
    };

    StringBuilder encodedMessage = new StringBuilder();

    foreach (char c in message) {
        if (char.IsLetter(c)) {
            // Swap case
            char swappedCaseChar = char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c);

            // Replace vowels according to the defined map
            if (vowelReplacement.ContainsKey(swappedCaseChar)) {
                encodedMessage.Append(vowelReplacement[swappedCaseChar]);
            } else {
                encodedMessage.Append(swappedCaseChar);
            }
        } else {
            // Non-letter characters should be appended as-is (if necessary)
            encodedMessage.Append(c);
        }
    }

    return encodedMessage.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encode((""TEST"")).Equals((""tgst"")));
    Debug.Assert(Encode((""Mudasir"")).Equals((""mWDCSKR"")));
    Debug.Assert(Encode((""YES"")).Equals((""ygs"")));
    Debug.Assert(Encode((""This is a message"")).Equals((""tHKS KS C MGSSCGG"")));
    Debug.Assert(Encode((""I DoNt KnOw WhAt tO WrItE"")).Equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَحْتَاجُ لِتَجِدَ أَكْبَرَ قِيمَةٍ أَوَّلِيَّةٍ وَتَرُدَّ جُمْلَةَ أَعْدَادِهَا.    //تُعْطَى لِسْمَةٌ مِنْ أَعْدَادٍ.    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L})))
    // (10L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L})))
    // (25L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L})))
    // (13L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L})))
    // (11L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L})))
    // (3L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L})))
    // (7L)
    public static long Skjkasdkd(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long Skjkasdkd(List<long> lst) {
        long largestPrime = -1;

        foreach (var num in lst) {
            if (IsPrime(num) && num > largestPrime) {
                largestPrime = num;
            }
        }

        if (largestPrime == -1) return 0;

        return SumOfDigits(largestPrime);
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;

        if (number % 2 == 0 || number % 3 == 0) return false;

        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }

        return true;
    }

    private static long SumOfDigits(long number) {
        long sum = 0;
        while (number != 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }
}

// Example of usage:
// var result = Problem.Skjkasdkd(new List<long> {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3});
// Console.WriteLine(result); // Output will be 10","    }
    public static void Main(string[] args) {
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L}))) == (10L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L}))) == (25L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L}))) == (13L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L}))) == (11L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L}))) == (3L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L}))) == (7L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L, (long)123456L, (long)127L, (long)7L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)127L, (long)97L, (long)8192L}))) == (10L));
    }

}
"
HumanEval_95,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَجِبُ أَنْ تَرُدَّ عَدَمَ الصَّحِيحِ إِذَا كَانَ القَامُوسُ فَارِغًا.    //كَيْفَ أَنْ تَكُونَ كُلُّ المَفَاتِيحِ سَلَسِلَةً بِكَبِيرِ الحَرْفِ، وإلا رَدَّ false.    //مُعْطَى قَامُوسٍ، يَرُدُّ صَحِيحًا إِنْ كَانَتْ كُلُّ المَفَاتِيحِ سَلَسَلَاتٍ في lower     // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""b"", ""banana""}}))
    // (true)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {8L, ""banana""}, {""a"", ""apple""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))
    // (true)
    public static bool CheckDictCase(Dictionary<string,string> dict) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool CheckDictCase(Dictionary<string, string> dict)
    {
        if (dict.Count == 0)
            return false;

        bool allLower = true;
        bool allUpper = true;

        foreach (var key in dict.Keys)
        {
            if (key != key.ToLower())
                allLower = false;
            if (key != key.ToUpper())
                allUpper = false;
        }

        return allLower || allUpper;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""b"", ""banana""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""fruit"", ""Orange""}, {""taste"", ""Sweet""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>())) == (false));
    }

}
"
HumanEval_96,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //أَصْلَى أَعْدَادٍ أَوَّلِيَّةٍ وَأَصْغَرَ مِنْ ن    //تَنْفِذُ دَلِيلَةً تَأْخُذُ كُلَّ عَدَدٍ غَيْرِ سَلبِيٍّ وَتَرُدُّ قِيمَةَ أَوَّلِ n     // >>> CountUpTo((5L))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    // >>> CountUpTo((11L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))
    // >>> CountUpTo((0L))
    // (new List<long>())
    // >>> CountUpTo((20L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))
    // >>> CountUpTo((1L))
    // (new List<long>())
    // >>> CountUpTo((18L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))
    public static List<long> CountUpTo(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> CountUpTo(long n) {
        List<long> primes = new List<long>();
        if (n <= 2) return primes;

        // Check for prime numbers from 2 up to n-1
        for (long i = 2; i < n; i++) {
            if (IsPrime(i)) {
                primes.Add(i);
            }
        }

        return primes;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number == 2) return true;

        long boundary = (long)Math.Sqrt(number);

        for (long i = 2; i <= boundary; i++) {
            if (number % i == 0) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpTo((5L)).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(CountUpTo((6L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((7L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((10L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))));
    Debug.Assert(CountUpTo((0L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((22L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))));
    Debug.Assert(CountUpTo((1L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(CountUpTo((47L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L}))));
    Debug.Assert(CountUpTo((101L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L, (long)47L, (long)53L, (long)59L, (long)61L, (long)67L, (long)71L, (long)73L, (long)79L, (long)83L, (long)89L, (long)97L}))));
    }

}
"
HumanEval_97,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَأْمُلُوا أنَّ الدَّخْلَ دَائِمًا صَحِيحٌ.    //بِجَمْعِ أَلْفَاتِهِمْ    //تَمْلِي الوَظِيفَةَ الَّتِي تَأْخُذُ اثْنَيْنِ مِنْ الأَصْحَابِ وَتَعُودُ     // >>> Multiply((148L), (412L))
    // (16L)
    // >>> Multiply((19L), (28L))
    // (72L)
    // >>> Multiply((2020L), (1851L))
    // (0L)
    // >>> Multiply((14L), (-15L))
    // (20L)
    public static long Multiply(long a, long b) {
","public static long Multiply(long a, long b) {
    int unitDigitA = (int)(Math.Abs(a) % 10);
    int unitDigitB = (int)(Math.Abs(b) % 10);
    return (long)(unitDigitA * unitDigitB);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Multiply((148L), (412L)) == (16L));
    Debug.Assert(Multiply((19L), (28L)) == (72L));
    Debug.Assert(Multiply((2020L), (1851L)) == (0L));
    Debug.Assert(Multiply((14L), (-15L)) == (20L));
    Debug.Assert(Multiply((76L), (67L)) == (42L));
    Debug.Assert(Multiply((17L), (27L)) == (49L));
    Debug.Assert(Multiply((0L), (1L)) == (0L));
    Debug.Assert(Multiply((0L), (0L)) == (0L));
    }

}
"
HumanEval_98,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //مُعْطَيَةَ سِلْطَةٍ s، عُدَّ عَدَدَ الحُرُوفِ الكبيرةِ في مُؤَشِّرَاتِ الزَّوَائِدِ.    // >>> CountUpper((""aBCdEf""))
    // (1L)
    // >>> CountUpper((""abcdefg""))
    // (0L)
    // >>> CountUpper((""dBBE""))
    // (0L)
    public static long CountUpper(string s) {
","using System;

class Problem {
    public static long CountUpper(string s) {
        long count = 0;
        for (int i = 0; i < s.Length; i += 2) {
            if (""AEIOU"".Contains(s[i])) {
                count++;
            }
        }
        return count;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CountUpper(""aBCdEf"")); // Output: 1
        Console.WriteLine(CountUpper(""abcdefg"")); // Output: 0
        Console.WriteLine(CountUpper(""dBBE"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpper((""aBCdEf"")) == (1L));
    Debug.Assert(CountUpper((""abcdefg"")) == (0L));
    Debug.Assert(CountUpper((""dBBE"")) == (0L));
    Debug.Assert(CountUpper((""B"")) == (0L));
    Debug.Assert(CountUpper((""U"")) == (1L));
    Debug.Assert(CountUpper(("""")) == (0L));
    Debug.Assert(CountUpper((""EEEE"")) == (2L));
    }

}
"
HumanEval_99,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //مِنْ اثْنَيْنِ أَعْدَدَيْنِ، يُقَدِّمُهُ مِنْ الصِّفَرِ.    //وَيَرُدُّ أَقْرَبَ عَدَدٍ كَامِلٍ إِنْ كَانَ الرَّقْمُ مُتَسَاوِيًا    //تَخْلُقُ دَلِيْلَةً تَتَأَخَّذُ قِيَمَةً (خَطّ) تَمْثِلُ عَدَدًا     // >>> ClosestInteger((""10""))
    // (10L)
    // >>> ClosestInteger((""15.3""))
    // (15L)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    public static long ClosestInteger(string value) {
","public static long ClosestInteger(string value) {
    double number = double.Parse(value);
    return (long)Math.Round(number, MidpointRounding.AwayFromZero);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ClosestInteger((""10"")) == (10L));
    Debug.Assert(ClosestInteger((""14.5"")) == (15L));
    Debug.Assert(ClosestInteger((""-15.5"")) == (-16L));
    Debug.Assert(ClosestInteger((""15.3"")) == (15L));
    Debug.Assert(ClosestInteger((""0"")) == (0L));
    }

}
"
HumanEval_100,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //i يَمْثُلُ عَدَدَ الحِجَارَةِ فِي المستوى (i+1).    //يَعُودُ عَدَدَ الحِجَارَةِ فِي كُلِّ دَرَجَةٍ فِي قَائِمَةٍ، حَيْثُ العَنَاءُ في المؤشر     //- الرَّقْمُ الْمُتَابِعُ الزَّوَائِدُ إِنْ كَانَ n زَوَائِدَاً.    //- الرَّقْمُ الْعَدْلُ الْمُتَابِعُ إِذَا كَانَ n عَدْلًا.    //عَدَدُ الحَجَرِ في المستوى التَالِي هُوَ:    //لَهُمْ حِجَارَةٌ    //مُعْطَى عَدَدَ كُلٍّ مُوجِبَ n، لَكَ أنْ تَجْعَلَ كُومَةً مِنْ نَوَاعِدِ حِجَارَةٍ.    // >>> MakeAPile((3L))
    // (new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))
    public static List<long> MakeAPile(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> MakeAPile(long n) {
        List<long> pile = new List<long>();
        long currentStones = n;
        
        for (long i = 0; i < n; i++) {
            pile.Add(currentStones);
            currentStones += (n % 2 == 0) ? 2 : 2;
        }

        return pile;
    }
    
    static void Main(string[] args) {
        List<long> result = MakeAPile(3L);
        Console.WriteLine(string.Join("", "", result));  // Output: 3, 5, 7
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakeAPile((3L)).Equals((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))));
    Debug.Assert(MakeAPile((4L)).Equals((new List<long>(new long[]{(long)4L, (long)6L, (long)8L, (long)10L}))));
    Debug.Assert(MakeAPile((5L)).Equals((new List<long>(new long[]{(long)5L, (long)7L, (long)9L, (long)11L, (long)13L}))));
    Debug.Assert(MakeAPile((6L)).Equals((new List<long>(new long[]{(long)6L, (long)8L, (long)10L, (long)12L, (long)14L, (long)16L}))));
    Debug.Assert(MakeAPile((8L)).Equals((new List<long>(new long[]{(long)8L, (long)10L, (long)12L, (long)14L, (long)16L, (long)18L, (long)20L, (long)22L}))));
    }

}
"
HumanEval_101,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //لِيَقْسِمَ السِّلْسِلَةَ كَلِمَاتٍ وَيَرُدَّ قِيمَةَ كَلِمَاتٍ.    //سَتُعْطَى سِلْسِلَةَ كَلِمَاتٍ مُفَرَّقَةٍ بِالْفُصُولِ أَوِ الْبَيَانِ.    // >>> WordsString((""Hi, my name is John""))
    // (new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))
    // >>> WordsString((""One, two, three, four, five, six""))
    // (new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))
    public static List<string> WordsString(string s) {
","public static List<string> WordsString(string s) {
    char[] separators = new char[] { ' ', ',' };
    var words = s.Split(separators, StringSplitOptions.RemoveEmptyEntries);
    return new List<string>(words);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsString((""Hi, my name is John"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))));
    Debug.Assert(WordsString((""One, two, three, four, five, six"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString((""Hi, my name"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name""}))));
    Debug.Assert(WordsString((""One,, two, three, four, five, six,"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString(("""")).Equals((new List<string>())));
    Debug.Assert(WordsString((""ahmed     , gamal"")).Equals((new List<string>(new string[]{(string)""ahmed"", (string)""gamal""}))));
    }

}
"
HumanEval_102,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //لَيْسَ هَكَذَا، فَتَرُدُّ -1.    //أَكْبَرُ عَدَدٍ سَمِيْرٍ مُجَرَّدٍ فِي النَّطْقِ [x، y] مَشْمُوْلًا.    //هَذِهِ الوَظِيفَة تَأْخُذُ عَدَدَيْ إيجَابٍ x و y وَتَرُدُّ     // >>> ChooseNum((12L), (15L))
    // (14L)
    // >>> ChooseNum((13L), (12L))
    // (-1L)
    public static long ChooseNum(long x, long y) {
","if (x > y) {
            return -1;
        }
        
        // Ensure x is the bigger one for simplicity
        if (x > y) {
            long temp = x;
            x = y;
            y = temp;
        }
        
        // Start searching from y down to x
        for (long i = y; i >= x; i--) {
            if (i % 2 == 0) {
                return i;
            }
        }
        
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChooseNum((12L), (15L)) == (14L));
    Debug.Assert(ChooseNum((13L), (12L)) == (-1L));
    Debug.Assert(ChooseNum((33L), (12354L)) == (12354L));
    Debug.Assert(ChooseNum((5234L), (5233L)) == (-1L));
    Debug.Assert(ChooseNum((6L), (29L)) == (28L));
    Debug.Assert(ChooseNum((27L), (10L)) == (-1L));
    Debug.Assert(ChooseNum((7L), (7L)) == (-1L));
    Debug.Assert(ChooseNum((546L), (546L)) == (546L));
    }

}
"
HumanEval_104,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //تَعْلِيقَة: الْقَائِمَة الْمُرْجَعَة تُصَنَّف بِالتَّرْتِيبِ الْمُتَزَايِد.    //مَا لَيْسَ لَهُ أَيُّ عَدَدٍ مُزَوَّجٍ.    //مُعْطَيَةَ قِيَاسِ مَوَاضِعِ الْمُسْتَوْجِبِينَ x. رُدَّ قِيَاسَ مُنَقَّطِ كُلِّ     // >>> UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L})))
    // (new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))
    // >>> UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L})))
    // (new List<long>())
    public static List<long> UniqueDigits(List<long> x) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> UniqueDigits(List<long> x) {
        return x.Where(n => !n.ToString().Any(c => ""02468"".Contains(c)))
                .OrderBy(n => n)
                .ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L}))).Equals((new List<long>())));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)12345L, (long)2033L, (long)111L, (long)151L}))).Equals((new List<long>(new long[]{(long)111L, (long)151L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)135L, (long)103L, (long)31L}))).Equals((new List<long>(new long[]{(long)31L, (long)135L}))));
    }

}
"
HumanEval_105,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //""واحدَ، اثنانَ، ثلاثةَ، أربعةَ، خمسةَ، ستَةَ، سبعةَ، ثمانيةَ، تسعةَ""    //تَعَكَّسَ الْقَائِمَ النَّاتِجَ، ثُمَّ بَدَّلَ كُلَّ أَلْفٍ بِاسْمِهِ الْمُتَّفِقِ مِنْ     //مُعْطَيَةَ قِائِمَةِ أَعْدَادٍ سَمِيَّةٍ، أَنْزِلُوا الأَعْدَادَ الَّتِي بَيْنَ 1 و 9 مَشْمُولَةً،    // >>> ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L})))
    // (new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))
    // If the list is empty, return an empty list:
    // >>> ByLength((new List<long>()))
    // (new List<string>())
    // If the list has any strange number ignore it:
    // >>> ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L})))
    // (new List<string>(new string[]{(string)""One""}))
    public static List<string> ByLength(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ByLength(List<long> arr) {
        // Define a dictionary to map numbers to their names.
        var digitToName = new Dictionary<long, string> {
            {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""},
            {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}
        };

        // Filter the numbers that are between 1 and 9.
        var filtered = arr.Where(x => digitToName.ContainsKey(x)).ToList();

        // Sort the filtered numbers.
        filtered.Sort();

        // Reverse the list.
        filtered.Reverse();

        // Map the numbers to their names using the dictionary.
        return filtered.Select(x => digitToName[x]).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L}))).Equals((new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>())).Equals((new List<string>())));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L}))).Equals((new List<string>(new string[]{(string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)3L, (long)2L}))).Equals((new List<string>(new string[]{(string)""Three"", (string)""Two"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)9L, (long)4L, (long)8L}))).Equals((new List<string>(new string[]{(string)""Nine"", (string)""Eight"", (string)""Four""}))));
    }

}
"
HumanEval_106,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //فَنَظِيرُ i هُوَ ضِرْبُ الأَرْقَامِ مِنْ 1 إلى i (1 * 2 * ... * i).    //يَبْدَأُ مِنْ 1.    //أَوْ جَمْعَ الأَرْقَامِ مِنْ 1 إلى i إِلاَّ هُوَ.    //وَيَرُدُّ قَائِمَةً مِنْ حَجَرِ n، كَمَا أَنَّ قِيمَةَ العَنْوَةِ فِي مُؤَنَّثِي i فَاعِلَةُ i إِذَا كَانَ i زَوِيًّا     //تَنْفِذُ الوِظَافَةَ f تَتَّخِذُ n كَالْمُعَايَنَةِ،     // >>> F((5L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))
    public static List<long> F(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> F(long n) {
        List<long> result = new List<long>();

        for (long i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                result.Add(Factorial(i));
            } else {
                result.Add(SumUpTo(i));
            }
        }
        
        return result;
    }

    private static long Factorial(long number) {
        if (number == 0) return 1;
        long factorial = 1;
        for (long i = 1; i <= number; i++) {
            factorial *= i;
        }
        return factorial;
    }

    private static long SumUpTo(long number) {
        return (number * (number + 1)) / 2;
    }

    static void Main(string[] args) {
        List<long> result = F(5);
        foreach (long val in result) {
            Console.WriteLine(val);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(F((5L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))));
    Debug.Assert(F((7L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L, (long)720L, (long)28L}))));
    Debug.Assert(F((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(F((3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L}))));
    }

}
"
HumanEval_107,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالُ 1:    //كَمْ مِنْ كَمْ مِنْ كَمْ مِنْ كَمْ مِنْ    //مُعْطَى عَدَدَ كُلٍّ مُوجِبَ n، رُدَّ تَوْبِلَةً لَهَا عَدَدُ الزَّوَاجِ وَالْفُرَاتِ     // >>> EvenOddPalindrome((3L))
    // (Tuple.Create(1L, 2L))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> EvenOddPalindrome((12L))
    // (Tuple.Create(4L, 6L))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    public static Tuple<long, long> EvenOddPalindrome(long n) {
","public static Tuple<long, long> EvenOddPalindrome(long n) {
    long evenCount = 0;
    long oddCount = 0;

    for (long i = 1; i <= n; i++) {
        if (IsPalindrome(i)) {
            if (i % 2 == 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return Tuple.Create(evenCount, oddCount);
}

private static bool IsPalindrome(long number) {
    long original = number;
    long reversed = 0;

    while (number > 0) {
        long digit = number % 10;
        reversed = reversed * 10 + digit;
        number /= 10;
    }

    return original == reversed;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddPalindrome((123L)).Equals((Tuple.Create(8L, 13L))));
    Debug.Assert(EvenOddPalindrome((12L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((3L)).Equals((Tuple.Create(1L, 2L))));
    Debug.Assert(EvenOddPalindrome((63L)).Equals((Tuple.Create(6L, 8L))));
    Debug.Assert(EvenOddPalindrome((25L)).Equals((Tuple.Create(5L, 6L))));
    Debug.Assert(EvenOddPalindrome((19L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((9L)).Equals((Tuple.Create(4L, 5L))));
    Debug.Assert(EvenOddPalindrome((1L)).Equals((Tuple.Create(0L, 1L))));
    }

}
"
HumanEval_108,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثْلَ -123 لَهُ أَشْرَافُ -1,2,و3.    //إِنْ كَانَ عَدَدٌ سَلبي، فَعَدَدُهُ الْمُوقَعُ أَوَّلُهُ سَلبي:    //عَدَدَ العَنَوَاتِ الَّذِي لَهُ جَمْعُ أَلْفَاتٍ > 0.     //اُكْتُبْ دَلِيْلَ count_nums يَأْخُذُ قِيَامَةَ أَعْدَادٍ وَيَرُدُّ     // >>> CountNums((new List<long>()))
    // (0L)
    // >>> CountNums((new List<long>(new long[]{(long)-1L, (long)11L, (long)-11L})))
    // (1L)
    // >>> CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L})))
    // (3L)
    public static long CountNums(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long CountNums(List<long> arr) {
        long count = 0;

        foreach (long number in arr) {
            long sumOfDigits = 0;
            long num = number;
            
            while (num != 0) {
                long digit = num % 10;
                sumOfDigits += digit;
                num /= 10;
            }

            if (sumOfDigits > 0) {
                count++;
            }
        }

        return count;
    }

    static void Main(string[] args) {
        // Test cases
        Console.WriteLine(CountNums(new List<long>())); // (0L)
        Console.WriteLine(CountNums(new List<long> { -1L, 11L, -11L })); // (1L)
        Console.WriteLine(CountNums(new List<long> { 1L, 1L, 2L })); // (3L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountNums((new List<long>())) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)-1L, (long)-2L, (long)0L}))) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L, (long)-2L, (long)3L, (long)4L, (long)5L}))) == (6L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)6L, (long)9L, (long)-6L, (long)0L, (long)1L, (long)5L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)100L, (long)98L, (long)-7L, (long)1L, (long)-1L}))) == (4L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)12L, (long)23L, (long)34L, (long)-45L, (long)-56L, (long)0L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L}))) == (1L));
    }

}
"
HumanEval_109,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //تَعْلِيقَة: الْقِيمَة مَعْطُوفَة مَضْمُونَة لَهَا فَرْدَة.    //إِنْ كَانَتْ القَائِمَةُ فَارِغَةً فَارْجِعْ حَقًّا.    //ثُمَّ ارْجِعْ حَقًّا أَوْ ارْجِعْ كَذِبًا.    //إنْ كانَ مُمْكِنَاً أنْ نَحْصُلَ على القائمةِ المُنَظَّمَةِ بِأداءِ العمليةِ المذكورةِ أعلاهَا    //مَوْضِعُ الْبَدْءِ فِي الْقَائِمَةِ أَيْ: الْمُؤَوَّلُ 0    //وَمَوْضِعُهُ فِي الْوَجْهِ الْمُسْتَقِيمِ.    //حَرْفُ الْيَمِينِ يَعْنِي تَحْرِيفَ كُلِّ عَنَاصِرِ الْقَائِمَةِ بِوَاحِدٍ    //يُسْمَحُ لَكَ بِأَنْ تَعْمَلَ حَرْفَ الْيَمِينِ عَدَدَ مَرَّاتٍ.    //فِي الْمَوْضُوعِ الْمَعْطُوفِ:    //يُمْكِنُ أَنْ تَحْصُلَ قِيَاسٌ بِأَمْرٍ غَيْرِ تَنْقِصَةٍ بِأَدَاءِ     //أَرقامُ القائمة سَتُترتَبُ عشوائيًا. مُهمَتُكَ تَحدُدُ إذا     //لَنَا قَائِمَةٌ 'arr' مِنْ نَوْمِيَّاتٍ كُلِّيَّاتٍ arr[1], arr[2], ..., arr[N].    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L})))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L})))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    public static bool MoveOneBall(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool MoveOneBall(List<long> arr) {
        if (arr.Count == 0) return true;

        int n = arr.Count;
        int descentCount = 0;
        int indexOfDescent = -1;

        // Find number of descents in the array
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[(i + 1) % n]) {
                descentCount++;
                indexOfDescent = (i + 1) % n;
            }
            if (descentCount > 1) {
                return false;
            }
        }

        // No descents means the array is already sorted
        if (descentCount == 0) {
            return true;
        }

        // Check if the single descent allows a circular sorted order
        for (int i = 0; i < n; i++) {
            if (arr[(indexOfDescent + i) % n] > arr[(indexOfDescent + i + 1) % n]) {
                return false;
            }
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)10L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)4L, (long)3L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>())) == (true));
    }

}
"
HumanEval_110,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //وَإِلاَّ فَارْجِعْ ""لاَ""    //كُلُّ عَنَاصِرِ lst1 لِتَكُونَ زَوَائِجَ، رُدَّ ""نَعَمْ"".    //إنْ كانَ مُمْكِنَاً تَبَادُلُ العِنَادَاتِ بَيْنَ lst1 و lst2 لِتَجْعَلَ    //لَيْسَ لَهُ حَدٌّ عَلَى عَدَدِ الْعَوَانِي الْمُتَبَادِلَةِ بَيْنَ lst1 و lst2.    //بَيْنَهُمْ لِيَجْعَلَ lst1 قِطَاعَ أَعْدَادٍ مُجَرَّدَةٍ.    //وَيَقِيسُ هَلْ هُوَ مُمْكِنُ أَنْ يُجْرَى تَبَادُلُ العِنَادِ    //فِي هَذِهِ المَسْأَلَةِ، سَتُنَفِّذُ دَلِيلًا يَأْخُذُ قَائِمَيْ أَرْقَامٍ،    // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (""YES"")
    // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L})))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    public static string Exchange(List<long> lst1, List<long> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string Exchange(List<long> lst1, List<long> lst2)
    {
        int countOfOddsInLst1 = lst1.Count(x => x % 2 != 0);
        int countOfEvensInLst2 = lst2.Count(x => x % 2 == 0);

        return countOfOddsInLst1 <= countOfEvensInLst2 ? ""YES"" : ""NO"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)2L, (long)1L, (long)4L, (long)3L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)3L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)3L, (long)2L, (long)6L, (long)1L, (long)8L, (long)9L})), (new List<long>(new long[]{(long)3L, (long)5L, (long)5L, (long)1L, (long)1L, (long)1L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)100L, (long)200L})), (new List<long>(new long[]{(long)200L, (long)200L}))).Equals((""YES"")));
    }

}
"
HumanEval_111,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //إنْ كَانَتْ عِدَّةُ حُرُوفٍ تَظْهَرُ فِي الْمَوْضِعِ ذَاتِهِ، فَارْجِعْ كُلَّهَا.    //حَرْفُ بِأَكْثَرِ تَكْرَارٍ وَمَعَهُ الْعَدَدُ الْمُتَوافِقُ    //مُنَطَّقَةٌ تَمْثِيلُ حُرُوفَ مُفَرَّقَةً بِسِيطَانٍ، تَرُدُّ قَامُوسًا     // >>> Histogram((""a b c""))
    // (new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}})
    // >>> Histogram((""a b b a""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""a b c a b""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""b b b b a""))
    // (new Dictionary<string,long>(){{""b"", 4L}})
    // >>> Histogram((""""))
    // (new Dictionary<string,long>())
    public static Dictionary<string,long> Histogram(string test) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Dictionary<string, long> Histogram(string test) {
        if (string.IsNullOrWhiteSpace(test)) {
            return new Dictionary<string, long>();
        }

        var words = test.Split(' ');
        var letterCounts = new Dictionary<string, long>();

        // Count the occurrences of each letter
        foreach (var word in words) {
            if (letterCounts.ContainsKey(word)) {
                letterCounts[word]++;
            } else {
                letterCounts[word] = 1;
            }
        }

        // Determine the maximum count
        long maxCount = letterCounts.Values.Max();

        // Create a dictionary for letters with the maximum count
        var result = letterCounts.Where(pair => pair.Value == maxCount)
                                 .ToDictionary(pair => pair.Key, pair => pair.Value);

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Histogram((""a b b a"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c a b"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c d g"")).Equals((new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}, {""d"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""b b b b a"")).Equals((new Dictionary<string,long>(){{""b"", 4L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram(("""")).Equals((new Dictionary<string,long>())));
    Debug.Assert(Histogram((""a"")).Equals((new Dictionary<string,long>(){{""a"", 1L}})));
    }

}
"
HumanEval_112,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلْ    //يَجِبُ أَنْ تَرُدَّ تَوْبِلَةً مَعَهَا سِلْطَةُ النَّتِيجَةِ وَصَحِيحٌ/كَذِبٌ لِلْفَحْصِ.    //سِلْسِلَةٌ تُدْعَى بِالْمُتَوَسِّطِ إِنْ قُرِئَتْ مِثْلَ الْمُتَوَسِّطِ.    //ثُمَّ تَفَقَّدْ إنْ كَانَتْ السِّلْطَةُ النَّتِيجَةُ بَالِندْرَامَةً.    //نُعْطِي سِلْسِلَتَيْنِ s و c، وَلَكَ أَنْ تَحْذِفَ كُلَّ الْحُرُوفِ فِي s الَّتِي تَسْتَوِي إِلَى كُلِّ حُرُوفِ فِي c     //مَهمَة     // >>> ReverseDelete((""abcde""), (""ae""))
    // (Tuple.Create(""bcd"", false))
    // >>> ReverseDelete((""abcdef""), (""b""))
    // (Tuple.Create(""acdef"", false))
    // >>> ReverseDelete((""abcdedcba""), (""ab""))
    // (Tuple.Create(""cdedc"", true))
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
","using System;
using System.Linq;

class Problem {
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
        // Remove characters from 's' that are in 'c'
        string resultString = new string(s.Where(ch => !c.Contains(ch)).ToArray());
        
        // Check if the result string is a palindrome
        bool isPalindrome = resultString.SequenceEqual(resultString.Reverse());

        // Return the result string and palindrome check as a tuple
        return Tuple.Create(resultString, isPalindrome);
    }

    // Example usage
    static void Main(string[] args) {
        var example1 = ReverseDelete(""abcde"", ""ae"");
        Console.WriteLine($""(\""bcd\"", false) == ({example1.Item1}, {example1.Item2})"");

        var example2 = ReverseDelete(""abcdef"", ""b"");
        Console.WriteLine($""(\""acdef\"", false) == ({example2.Item1}, {example2.Item2})"");

        var example3 = ReverseDelete(""abcdedcba"", ""ab"");
        Console.WriteLine($""(\""cdedc\"", true) == ({example3.Item1}, {example3.Item2})"");
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ReverseDelete((""abcde""), (""ae"")).Equals((Tuple.Create(""bcd"", false))));
    Debug.Assert(ReverseDelete((""abcdef""), (""b"")).Equals((Tuple.Create(""acdef"", false))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""ab"")).Equals((Tuple.Create(""cdedc"", true))));
    Debug.Assert(ReverseDelete((""dwik""), (""w"")).Equals((Tuple.Create(""dik"", false))));
    Debug.Assert(ReverseDelete((""a""), (""a"")).Equals((Tuple.Create("""", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), ("""")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""v"")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""vabba""), (""v"")).Equals((Tuple.Create(""abba"", true))));
    Debug.Assert(ReverseDelete((""mamma""), (""mia"")).Equals((Tuple.Create("""", true))));
    }

}
"
HumanEval_113,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِنْ أَشْكَالِ الْمُدْخَلِ الْمُتَقَدِّمَةِ    //حَيْثُ كُلّ الْأَيَاءِ يَجِبُ أَنْ تُسْتَبْدَلَ بِالرَّقْمِ    //كُلُّ عَنْصَرٍ i مِنْ النَّاتِجِ يَجِبُ أَنْ يَكُونَ عَدَدَ العَنَاصِرِ الفُرْقَةِ في    //مُعْطَى قَائِمَةِ سَلَسِلَةٍ، حَيْثُ كُلُّ سَلَسِلَةٍ تَتَأَلَّفُ مِنْ أَرْبَعَةِ أَعْدَادٍ، رُدَّ قَائِمَةً.    // >>> OddCount((new List<string>(new string[]{(string)""1234567""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))
    // >>> OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))
    public static List<string> OddCount(List<string> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> OddCount(List<string> lst)
    {
        List<string> result = new List<string>();
        foreach (var str in lst)
        {
            int oddCount = 0;
            foreach (var c in str)
            {
                if ((c - '0') % 2 != 0) // Check if the digit is odd
                {
                    oddCount++;
                }
            }

            string output = $""the number of odd elements {oddCount}n the str{oddCount}ng {oddCount} of the {oddCount}nput."";
            result.Add(output);
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""1234567""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""271"", (string)""137"", (string)""314""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (string)""the number of odd elements 2n the str2ng 2 of the 2nput.""}))));
    }

}
"
HumanEval_114,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلْ    //مِنْ أَرْبَابِ    //مُعْطَيَةَ قَائِمَةِ أَعْدَادِ سَمَاءٍ، أَعْثِرْ عَلَى أَقَلِّ مَجْمُوعِ أَيِّ قَائِمَةٍ دُونَ خَالِيَةٍ    // >>> Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))
    // (1L)
    // >>> Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L})))
    // (-6L)
    public static long Minsubarraysum(List<long> nums) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Minsubarraysum(List<long> nums) {
        long minSum = nums[0], currentSum = nums[0];
        
        for (int i = 1; i < nums.Count; i++) {
            currentSum = Math.Min(nums[i], currentSum + nums[i]);
            minSum = Math.Min(minSum, currentSum);
        }
        
        return minSum;
    }

    // Example usage
    public static void Main() {
        Console.WriteLine(Minsubarraysum(new List<long> { 2L, 3L, 4L, 1L, 2L, 4L })); // Output: 1L
        Console.WriteLine(Minsubarraysum(new List<long> { -1L, -2L, -3L }));         // Output: -6L
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L}))) == (1L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)2L, (long)-10L}))) == (-14L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-9999999999999999L}))) == (-9999999999999999L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)0L, (long)10L, (long)20L, (long)1000000L}))) == (0L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)10L, (long)11L, (long)13L, (long)8L, (long)3L, (long)4L}))) == (3L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-33L, (long)32L, (long)-1L, (long)0L, (long)-2L}))) == (-33L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-10L}))) == (-10L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)7L}))) == (7L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)1L, (long)-1L}))) == (-1L));
    }

}
"
HumanEval_115,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالُ 1:    //أَخْرِجْ عَدَدَ مَرَّاتٍ تَحْتَاجُ لِتَنْزِيلِ الْبِرَكَاتِ.    //مَهمَتُكَ تَستَخدِمُ الدِّلاءَ لتَفْرِغُ البِئَارَ.    //وَكُلُّ الْمَاءِ لَهُ سَعَةٌ مِثْلُهَا    //كُلُّ بِئْرٍ لَهَا دَلْوٌ يُمْكِنُ أَنْ يُسْتَخْرَجَ مِنْهَا الْمَاءُ    //وَكُلُّ 1 فِي الصَّفِّ يَمْثُلُ وَاحِدَةً مِنَ الْمَاءِ.    //تُعْطَى شَبَكَة مُقَوَّمَة مِنْ الآبار. كُلّ صَفّ يَمْثِلُ آباراً واحِدَة,    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L))
    // (6L)
    // Example 2:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L))
    // (5L)
    // Example 3:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L))
    // (0L)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    public static long MaxFill(List<List<long>> grid, long capacity) {
","public static long MaxFill(List<List<long>> grid, long capacity) {
    long operations = 0;

    foreach (var row in grid) {
        long waterUnits = row.Sum();
        operations += waterUnits / capacity;
        if (waterUnits % capacity != 0) {
            operations++;
        }
    }

    return operations;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L)) == (6L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L)) == (5L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L)) == (0L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (2L)) == (4L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (9L)) == (2L));
    }

}
"
HumanEval_116,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //يَجِبُ أَنْ يُنفَذَ كَمَا يَلِي:    //لِمِثْلِ عَدَدِ الْوَاحِدَاتِ، تَصْنِيف بِنَاء عَشْرِيّة.    //عَدَدَ الْوَاحِدَاتِ فِي تَمْثِيلِهَا الثنِيّ فِي تَرْتِيبٍ مُصْعَدٍ.    //فِي هَذَا الكَاتَا، يَجِبُ أَنْ تُصَنِّفَ قِيمَةَ الأَصْلِيَّاتِ الغَيْرِ السَّالبَةِ بِمُوجَبِ    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))
    // (new List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))
    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))
    public static List<long> SortArray(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> SortArray(List<long> arr) {
        return arr.OrderBy(num => CountOnesInBinary(num))
                  .ThenBy(num => num)
                  .ToList();
    }

    private static int CountOnesInBinary(long num) {
        return Convert.ToString(num, 2).Count(c => c == '1');
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    }

}
"
HumanEval_117,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَمَسُّكُكَ: تَتَأَمَّلُ أَنَّ سِلْسِلَةَ الإِدْخَالِ تَتَضَمَّنُ حُرُوفًا وَفُسُوفًا.    //إِنْ كَانَتْ السِّلْطَةُ s فَارِغَةً فَتَرُدُّ الوَظِيفَةَ قَائِمَةً فَارِغَةً.    //نَ حَرَامَاتٍ، بِتَرْتِيبِ تَظْهُرُ هَذِهِ الكَلِمَاتُ فِي السِّلْسِلَةِ.    //a function يَعُودُ بِقَائِمَةِ كُلِّ كَلِمَاتٍ مِنْ سِلْسِلَةِ s يَتَضَمَّنُ بِالتَّفْصِيلِ     //مُعَطَى سِلْسِلَة s وَعَدَدِ نَفْسِيٍّ n، قَدْ كُلِّفَتْ تَنْفِذُ     // >>> SelectWords((""Mary had a little lamb""), (4L))
    // (new List<string>(new string[]{(string)""little""}))
    // >>> SelectWords((""Mary had a little lamb""), (3L))
    // (new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))
    // >>> SelectWords((""simple white space""), (2L))
    // (new List<string>())
    // >>> SelectWords((""Hello world""), (4L))
    // (new List<string>(new string[]{(string)""world""}))
    // >>> SelectWords((""Uncle sam""), (3L))
    // (new List<string>(new string[]{(string)""Uncle""}))
    public static List<string> SelectWords(string s, long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> SelectWords(string s, long n) {
        List<string> result = new List<string>();
        if (string.IsNullOrEmpty(s)) 
            return result;

        string[] words = s.Split(' ');
        string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";

        foreach (string word in words) {
            int consonantCount = 0;
            foreach (char c in word) {
                if (consonants.Contains(c)) {
                    consonantCount++;
                }
            }

            if (consonantCount == n) {
                result.Add(word);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SelectWords((""Mary had a little lamb""), (4L)).Equals((new List<string>(new string[]{(string)""little""}))));
    Debug.Assert(SelectWords((""Mary had a little lamb""), (3L)).Equals((new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))));
    Debug.Assert(SelectWords((""simple white space""), (2L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""Hello world""), (4L)).Equals((new List<string>(new string[]{(string)""world""}))));
    Debug.Assert(SelectWords((""Uncle sam""), (3L)).Equals((new List<string>(new string[]{(string)""Uncle""}))));
    Debug.Assert(SelectWords((""""), (4L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""a b c d e f""), (1L)).Equals((new List<string>(new string[]{(string)""b"", (string)""c"", (string)""d"", (string)""f""}))));
    }

}
"
HumanEval_118,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //تَجِبُ أَنْ تَتَأَمَّلَ أَنَّ السِّلْسِلَةَ الْمَوْصُوفَةَ تَتَضَمَّنُ حَرْفَ إِنْجِيلِيٍّ.    //تَجِدْ أَيَّ حَرْفٍ تَمَسَّكَ بِالشَّرْطِ الْمَوْضُوعِ.    //فَلاَ تَحْسَبُ الْوَاوَاتُ فِي بَدْءِ وَنِهَايَةِ. رُدَّ سِلْطَةً فَارِغَةً إِنْ لَمْ تَكُنْ.    //حَرْفَيْنِ مِنْ جَانِبِ الْكَلِمَةِ الْأَيْمَنِ (حَسَبَ حَرْفِ الْكَبِيرِ).    //تُعْطَى كَلِمَةٌ. مُهِمَّتُكَ هيَ أنْ تَجِدَ أقْرَبَ حَرْفٍ يَقِفُ بَيْنَهُمَا    // >>> GetClosestVowel((""yogurt""))
    // (""u"")
    // >>> GetClosestVowel((""FULL""))
    // (""U"")
    // >>> GetClosestVowel((""quick""))
    // ("""")
    // >>> GetClosestVowel((""ab""))
    // ("""")
    public static string GetClosestVowel(string word) {
","using System;

class Problem {
    public static string GetClosestVowel(string word) {
        if (string.IsNullOrWhiteSpace(word) || word.Length < 3) {
            return """";
        }
        
        HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        
        for (int i = word.Length - 2; i > 0; i--) {
            if (vowels.Contains(word[i]) && 
                !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {
                return word[i].ToString();
            }
        }
        return """";
    }

    static void Main(string[] args) {
        Console.WriteLine(GetClosestVowel(""yogurt"")); // Output: ""u""
        Console.WriteLine(GetClosestVowel(""FULL""));   // Output: ""U""
        Console.WriteLine(GetClosestVowel(""quick""));  // Output: """"
        Console.WriteLine(GetClosestVowel(""ab""));     // Output: """"
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetClosestVowel((""yogurt"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""full"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""easy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""eAsy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ali"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""bad"")).Equals((""a"")));
    Debug.Assert(GetClosestVowel((""most"")).Equals((""o"")));
    Debug.Assert(GetClosestVowel((""ab"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ba"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""quick"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""anime"")).Equals((""i"")));
    Debug.Assert(GetClosestVowel((""Asia"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""Above"")).Equals((""o"")));
    }

}
"
HumanEval_119,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //رُدَّ ""نَعَمْ"" إِنْ كَانَ ثَمَّةَ طَرِيقٌ لِصُنْعِ سِلْسِلَةٍ جَيِّدَةٍ، وَرُدَّ ""لَا"" إِلَّا.    //"" (()) "" لَيْسَ هُوَ.    //مَثَلًا: السِّلْطُ '(((() ' جَيِّدٌ، وَالسِّلْطُ     //سِلْسِلَةٌ S تُعْتَبَرُ جَيِّدَةً إِنْ وَإِنْ سَمِعَ كُلُّ قُرْبَانِ S     //لَكِنْ لَوْ كَانَ لَكَ أَمْرٌ، لَكَانَ النَّتِيجَةُ جَيِّدَةً.    //مَهْمَلُكَ هُوَ أنْ تَتَفَقَّدَ إنْ كانَ مُمْكِنًا أنْ تُرَابِطَ السَّلَسَتَيْنِ في    //قَطَائِفُ "" (("" أَو قَطَائِفُ قَرِيبَةٌ "")) "" فَقَطْ.    //تُعْطَى قِيمَةٌ مِنْ سَلْسَلَتَيْنِ، كِلاَهُمَا مَفْتُوحٌ    // >>> MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""})))
    // (""Yes"")
    // >>> MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""})))
    // (""No"")
    public static string MatchParens(List<string> lst) {
","public static string MatchParens(List<string> lst) {
        if (lst.Count != 2) return ""No"";

        string str1 = lst[0];
        string str2 = lst[1];

        // Check both possible concatenations
        if (IsValidParentheses(str1 + str2) || IsValidParentheses(str2 + str1))
            return ""Yes"";
        
        return ""No"";
    }

    private static bool IsValidParentheses(string s) {
        int balance = 0;
        foreach (char c in s) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false; // More closing parens than opening
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()(())"", (string)""())())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")())"", (string)""(()()(""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(())))"", (string)""(()())((""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()"", (string)""())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()("", (string)""()))()""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(((("", (string)""((())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")(()"", (string)""(()(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")("", (string)"")(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)""(""}))).Equals((""Yes"")));
    }

}
"
HumanEval_120,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالُ 1:    //مِنْ طُولِ k بِأَكْثَرِ k أَرْبَعَةِ أَرْبَعَةِ أَرْبَعَةِ    //مُنَطَّقَةٌ بِمَوْضِعِ أَرْ وَمَوْضِعِ كَمْ، رُدَّ مَوْضِعَ مُنَتَّبَةً    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L))
    // (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))
    // Example 2:
    // >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L))
    // (new List<long>(new long[]{(long)4L, (long)4L}))
    // Example 3:
    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))
    // (new List<long>(new long[]{(long)2L}))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    public static List<long> Maximum(List<long> arr, long k) {
","public static List<long> Maximum(List<long> arr, long k) {
    return arr.OrderByDescending(n => n).Take((int)k).OrderBy(n => n).ToList();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)20L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})), (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L, (long)3L, (long)5L, (long)15L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new List<long>(new long[]{(long)3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L, (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));
    }

}
"
HumanEval_121,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //مُعْطَيَةَ قَائِمَةٍ غَيْرِ فَارِغَةٍ مِنَ الأَصْحَابِ، ارْجِعْ بِجَمِيعِ العَنَاصِرِ الغَرِيبَةِ الْمُتَوَاضِعَةِ.    // >>> Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L})))
    // (12L)
    // >>> Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L})))
    // (9L)
    // >>> Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L})))
    // (0L)
    public static long Solution(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Solution(List<long> lst) {
        long sum = 0;
        for (int i = 0; i < lst.Count; i += 2) { // Iterate over even indices
            if (lst[i] % 2 != 0) { // Check if the element is odd
                sum += lst[i];
            }
        }
        return sum;
    }
    
    static void Main() {
        Console.WriteLine(Solution(new List<long>{5L, 8L, 7L, 1L})); // Output: 12
        Console.WriteLine(Solution(new List<long>{3L, 3L, 3L, 3L, 3L})); // Output: 9
        Console.WriteLine(Solution(new List<long>{30L, 13L, 24L, 321L})); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L}))) == (12L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L}))) == (9L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)9L}))) == (5L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)2L, (long)4L, (long)8L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)23L, (long)32L}))) == (23L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)13L, (long)2L, (long)9L}))) == (3L));
    }

}
"
HumanEval_122,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //مَجْمُوعُ العَوَانِيدِ بِكُلِّ عَدَدِ أَوْلَى مِنْ أَوَّلِ كَوَانِيدِ arr.    //مُعْطَى لَفْظِ لَيْسَ فَارِغَ مِنْ أَعْدَادِ الْكُلِّ arr وَكُلِّيَّة k، return     // >>> AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L))
    // (24L)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    public static long AddElements(List<long> arr, long k) {
","public static long AddElements(List<long> arr, long k) {
        long sum = 0;
        for (int i = 0; i < k; i++) {
            if (arr[i] >= -99 && arr[i] <= 99) {
                sum += arr[i];
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L, (long)-2L, (long)-3L, (long)41L, (long)57L, (long)76L, (long)87L, (long)88L, (long)99L})), (3L)) == (-4L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)121L, (long)3L, (long)4000L, (long)5L, (long)6L})), (2L)) == (0L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)11L, (long)21L, (long)3L, (long)90L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (125L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (24L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L})), (1L)) == (1L));
    }

}
"
HumanEval_123,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //get_odd_collatz(5) يَرُدُّ [1, 5] # تَتَابُعَةَ collatz لِ 5 هِيَ [5, 16, 8, 4, 2, 1], فَالأَرْقَامُ الغَرِيبَةُ هِيَ 1 و 5 فقط.     //مِثَالًا:    //رَدَّتْ الْقَائِمَةَ مُنْتَقَمَةً    //1. كُولَاتزَ ((1)) هُوَ [1].    //تَذْكِرَة:    //مَرْضِيَّةُ أَنْ لَا يَهُمَّ أَيُّ قِيمَةٍ لِنْتَ، فَتَتَتَابُعُ تَتَابُعُ تَتَابُعُ تَتَابُعُ تَتَابُعُ تَتَابُعُ تَتَابُعُ    //فَإِنْ كَانَتِ الأَوَّلَةُ فُرَادِيَّةً فَالأَوَّلُ تَكُونُ ثَلاثَةَ أَضْعَافٍ    //مَرَّةً قَبْلَهَا كَمَا يَلِي: إِنْ كَانَتْ مَرَّةً قَبْلَهَا زَوْجَةً، فَالْمَرَّةُ التَّالِيَةُ نِصْفُ    //كَمَا يَلِي: بَدَأْ بِكُلِّ عَدَدٍ سَمِيْنٍ نَافِعٍ. ثُمَّ كُلُّ عَطْفٍ يُحْصَلُ مِنْ     //تَخْيِيلُ كُولاتزِ هُوَ تَخْيِيلٌ فِي الْمَعْدِنِ يَتَعَلَّقُ بِتَتَابُعٍ مُعَرَّفٍ    //مَنْصُوبٌ عَلَى عَدَدِ كُلٍّ نَافِعٍ، رُدَّ قَائِمَةً مُنَقَّطَةً تَتَمَاثَلُ بِهَا الأَعْدَادُ فِي تَتَابُعِ كُلَاتَز.    // >>> GetOddCollatz((5L))
    // (new List<long>(new long[]{(long)1L, (long)5L}))
    public static List<long> GetOddCollatz(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetOddCollatz(long n)
    {
        HashSet<long> oddNumbers = new HashSet<long>();

        while (n != 1)
        {
            if (n % 2 != 0)
            {
                oddNumbers.Add(n);
            }

            if (n % 2 == 0)
            {
                n /= 2;
            }
            else
            {
                n = 3 * n + 1;
            }
        }

        oddNumbers.Add(1); // Add 1 to the set as per problem statement

        List<long> result = new List<long>(oddNumbers);
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetOddCollatz((14L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(GetOddCollatz((5L)).Equals((new List<long>(new long[]{(long)1L, (long)5L}))));
    Debug.Assert(GetOddCollatz((12L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)5L}))));
    Debug.Assert(GetOddCollatz((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    }

}
"
HumanEval_124,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //4. التَوْم يَجِبُ أَنْ يَكُونَ في صُورَة: مَ-دَ-نَنَنْنَنْنَنْ    //3 لَا يَجِبُ أَنْ يَكُونَ أَقَلَّ مِنْ شَهْرٍ وَلَا أَكْثَرَ مِنْ 12    //وَلَا يَكُونُ عَدَدُ الْأَيَّامِ أَقَلَّ مِنْ وَلَا أَكْثَرَ مِنْ 31 يَوْمًا لِشُهُورِ 1,3,5,7,8,10,12. وَلَا يَكُونُ عَدَدُ الْأَيَّامِ أَقَلَّ مِنْ وَلَا أَكْثَرَ مِنْ 30 يَوْمًا لِشُهُورِ 4,6,9,11. وَلَا يَكُونُ عَدَدُ الْأَيَّامِ أَقَلَّ مِنْ وَلَا أَكْثَرَ مِنْ 29 يَوْمًا لِشَهْرِ 2.    //1. سِلْسِلَةُ التَّوْمِ لَيْسَتْ فَارِغَةً.    //التَّوْمُ صَحِيحٌ إِذَا تَمَّتْ كُلُّ القَوَاعِدِ التَّالِيَةِ:    //يَرُدُّ صَحِيحَةً إِنْ كَانَ التَّوْمُ صَحِيحًا وَإِلَّا فَكَاذِبَةً.    //يَجِبُ أَنْ تَكْتُبَ دَلِيْلَةً تُثَبِّتُ سِلْسِلَةَ تَوْمٍ مَعْطُوْدَةٍ وَ    // >>> ValidDate((""03-11-2000""))
    // (true)
    // >>> ValidDate((""15-01-2012""))
    // (false)
    // >>> ValidDate((""04-0-2040""))
    // (false)
    // >>> ValidDate((""06-04-2020""))
    // (true)
    // >>> ValidDate((""06/04/2020""))
    // (false)
    public static bool ValidDate(string date) {
","public static bool ValidDate(string date)
{
    if (string.IsNullOrEmpty(date) || date.Length != 10) return false;

    string[] dateParts = date.Split('-');
    if (dateParts.Length != 3) return false;

    if (!int.TryParse(dateParts[0], out int month) || !int.TryParse(dateParts[1], out int day) || !int.TryParse(dateParts[2], out int year))
    {
        return false;
    }

    if (month < 1 || month > 12) return false;

    if (year < 1) return false;

    bool isValidDay = false;

    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 1 && day <= 31)
    {
        isValidDay = true;
    }
    else if ((month == 4 || month == 6 || month == 9 || month == 11) && day >= 1 && day <= 30)
    {
        isValidDay = true;
    }
    else if (month == 2 && day >= 1 && day <= 29)
    {
        isValidDay = true;
    }

    return isValidDay;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ValidDate((""03-11-2000"")) == (true));
    Debug.Assert(ValidDate((""15-01-2012"")) == (false));
    Debug.Assert(ValidDate((""04-0-2040"")) == (false));
    Debug.Assert(ValidDate((""06-04-2020"")) == (true));
    Debug.Assert(ValidDate((""01-01-2007"")) == (true));
    Debug.Assert(ValidDate((""03-32-2011"")) == (false));
    Debug.Assert(ValidDate(("""")) == (false));
    Debug.Assert(ValidDate((""04-31-3000"")) == (false));
    Debug.Assert(ValidDate((""06-06-2005"")) == (true));
    Debug.Assert(ValidDate((""21-31-2000"")) == (false));
    Debug.Assert(ValidDate((""04-12-2003"")) == (true));
    Debug.Assert(ValidDate((""04122003"")) == (false));
    Debug.Assert(ValidDate((""20030412"")) == (false));
    Debug.Assert(ValidDate((""2003-04"")) == (false));
    Debug.Assert(ValidDate((""2003-04-12"")) == (false));
    Debug.Assert(ValidDate((""04-2003"")) == (false));
    }

}
"
HumanEval_126,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //number, return false. يَتَأَمَّلُونَ أَنْ لاَ يَكُونَ أَصْلُهُمْ أَصْلُ الأَصْلِ.    //إنْ كَانَتْ لَهُ أَكْثَرَ مِنْ مُثَنَّاةٍ وَاحِدَةٍ    //مُعْطَيَةَ قِيَامَةِ أَرْقَامٍ، تَرْجِعُ أَوْ لَا تُنَقَّطُ    // >>> IsSorted((new List<long>(new long[]{(long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L})))
    // (false)
    public static bool IsSorted(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static bool IsSorted(List<long> lst) {
        if (lst.Count == 0) return true;

        // To store the occurrence of each number
        var occurrences = new Dictionary<long, int>();

        for (int i = 0; i < lst.Count - 1; i++) {
            // Check if the current number is greater than the next number
            if (lst[i] > lst[i + 1]) {
                return false;
            }

            // Count the occurrences of each number
            if (occurrences.ContainsKey(lst[i])) {
                occurrences[lst[i]]++;
            } else {
                occurrences[lst[i]] = 1;
            }

            // If any number occurs more than twice
            if (occurrences[lst[i]] > 2) {
                return false;
            }
        }

        // Check the last element in the list for more than two occurrences
        if (occurrences.ContainsKey(lst[lst.Count - 1])) {
            occurrences[lst[lst.Count - 1]]++;
            if (occurrences[lst[lst.Count - 1]] > 2) {
                return false;
            }
        } else {
            occurrences[lst[lst.Count - 1]] = 1;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (false));
    Debug.Assert(IsSorted((new List<long>())) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))) == (true));
    }

}
"
HumanEval_127,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //[دَخَلَ/خَرَجَ] عَيْنَاتٌ:     //إِنْ لَمْ تَتَجَاوَزِ الْمُدَّتَانِ، ارْجِعْ بِ""لا"".    //إِلاَّ فَارْجِعْ ""لاَ""    //إِنْ كَانَ طُولُ التَّشْتِمَةِ عَدَدًا أَوَّلًا، رُدُّ ""نَعَمْ""،    //وَطُولُهُ 1 وَلَيْسَ بِعَدَدٍ أَوَّلٍ.    //مِثَالُ تَشَارُكِ الْمَوَاقِيتِ (1, 3) ، (2, 4) هُوَ (2, 3)    //فَتَيَسَتَرَ مَدَدَ    //مَهْمَلُكَ هُوَ أَنْ تَحْدُثَ طُولُ تَقاطِعِ هذَيْنِ    //لِكُلِّ فَصْلٍ مَعْطُوفٍ، يُفترضُ أنَّ بَدْءَهُ أَصْغَرُ أَوْ يَسْتَوِي لنهايَتِهِ.    //يَشْمَلُ بِدَايَةً وَنِهَايَةً.    //فَتَتَبَاطَأُ الْمَوَاقِيتُ الْمَوْقُوفَةُ، وَمَعْنَاهَا أَنَّ الْمَوَاقِيتَ (بَدَأَ، وَانْتَهَى)    //حَيْثُ كُلُّ فَاصِلٍ جَوْرٌ مِنَ الأَصْحَابِ. مَثَلًا، فَاصِلٌ = (بَدْءٌ، نِهَايَةٌ) = (1, 2).    //تُعْطَى فَاصِلَتَيْنِ،    // >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L)))
    // (""YES"")
    public static string Intersection(Tuple<long, long> interval1, Tuple<long, long> interval2) {
","long start1 = interval1.Item1;
    long end1 = interval1.Item2;
    long start2 = interval2.Item1;
    long end2 = interval2.Item2;

    long intersectStart = Math.Max(start1, start2);
    long intersectEnd = Math.Min(end1, end2);

    if (intersectStart > intersectEnd) {
        return ""NO"";
    }

    long intersectionLength = intersectEnd - intersectStart + 1;

    if (IsPrime(intersectionLength)) {
        return ""YES"";
    } else {
        return ""NO"";
    }
}

private static bool IsPrime(long number) {
    if (number < 2) return false;
    if (number == 2) return true;
    if (number % 2 == 0) return false;

    long boundary = (long)Math.Floor(Math.Sqrt(number));

    for (long i = 3; i <= boundary; i += 2) {
        if (number % i == 0) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, 2L)), (Tuple.Create(-4L, 0L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-11L, 2L)), (Tuple.Create(-1L, -1L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(3L, 5L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(1L, 2L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, -2L)), (Tuple.Create(-3L, -2L))).Equals((""NO"")));
    }

}
"
HumanEval_128,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //تَعَلَّقْ: رُدَّ null لِلْفَارِغِ arr.     //مِنْ كُلِّ عَدَدٍ فِي الْقَائِمَةِ، مُمَثَّل بِ 1، -1 أَو 0.    //مَجْمُوعُ كَبَرَاتِ الأَصْحَابِ مُضَاعَفَةً بِجَمِيعِ العَلَامَاتِ    //تُعْطَى لِسْمَةٌ مِنْ أَعْدَادٍ وَيَجِبُ أَنْ تَرْجِعَ    // >>> ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L})))
    // 9L
    // >>> ProdSigns((new List<long>(new long[]{(long)0L, (long)1L})))
    // 0L
    // >>> ProdSigns((new List<long>()))
    // null
    public static Nullable<long> ProdSigns(List<long> arr) {
","public static Nullable<long> ProdSigns(List<long> arr) {
        if (arr == null || arr.Count == 0) return null;

        long sumOfMagnitudes = 0;
        long productOfSigns = 1;

        foreach (var num in arr) {
            sumOfMagnitudes += Math.Abs(num);

            if (num > 0) {
                productOfSigns *= 1;
            } else if (num < 0) {
                productOfSigns *= -1;
            } else {
                productOfSigns = 0;
                break;
            }
        }

        return sumOfMagnitudes * productOfSigns;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L}))).Equals(-9L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)0L, (long)1L}))).Equals(0L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)2L, (long)3L, (long)-1L, (long)1L}))).Equals(-10L));
    Debug.Assert(ProdSigns((new List<long>())).Equals(null));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)2L, (long)-1L, (long)-1L, (long)9L}))).Equals(20L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)-1L, (long)1L}))).Equals(4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)1L}))).Equals(-4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)0L}))).Equals(0L));
    }

}
"
HumanEval_129,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //يَرُدُّ قَائِمَةً مُنْتَظَمَةً لِلْقِيَمِ فِي الْخُلاَءِ الَّتِي يَمُرُّ بِهَا الْحَدِيثُ.    //يُضْمَنُ أَنَّ الجَوَابَ فَرْدٌ.    //lst_A[j] = lst_B[j] . وَلَوْ كَانَتْ مَعَكَ    //كَذَلِكَ lst_A[i] < lst_B[i] وَلِكُلِّ j (1 <= j < i) لَنَا     //مِنْ lst_B، بِأَيْنَمَا، هُنَاكَ مُؤَنَّثُ عَدَدٍ سَمِيْرٍ i (1 <= i <= k)     //مِنْ (لِنَدْعُوهُمَا lst_A و lst_B) ، lst_A أَقَلُّ مِنْ الْمَجَازِيَّةِ    //بَعْدَ تَصْنِيعِ قَوَدِ القِيَمِ المُنَظَّمَةِ فِي الخَلاَئِجِ الَّتِي يَذْهَبُ بِهَا أَو بِهَا    //يُعْتَبَرُ طَرِيقٌ أَصْغَرُ مِنْ طَرِيقٍ بِأَصْغَرَ مِنْ طَرِيقِهِ    //لَا تَستطيعُ أَنْ تَخْرُجَ مِنَ الشَّبَكَةِ.    //لَا بُدَّ مِنْ تَمْيِيزِهِ).    //رُبَّمَا تَذَكَّرُوا أَنَّ مَسِيرَةَ طُولِ k تَعْنِي زِيَارَةَ كَلِمَاتِ k (لَيْسَ     //خَلَلْ    //بِكَلِمَاتٍ أُخَرَ، تَجِدُ خَلاَئِجَ تَشْتَرِكُ حَدَاً مَعَكَ    //مِنْ كُلِّ خَلِيَّةٍ، وَفِي كُلِّ حَدَثٍ تَتَحَرَّكُ إِلَى كُلِّ خَلِيَّةٍ جَارَةٍ،    //لَكَ أَنْ تَجِدَ الحَدَّ الأَقَلَ مِنْ طُولِ k فِي الشَّبَكَةِ.    //يَظْهَرُ مَعْمُولٌ مَرَّةً فِي خَلاَئِجِ الشَّبَكَةِ.    //كُلُّ خَلْوَةٍ مِنْ الْكُرْسِيِّ تَحْتَلُّ قِيمَةً كُلُّ عَدَدٍ كُلِّيٍّ فِي مَوْضِعِ [1, N * N]    //مُنَطَّقٌ بِسِلْسِلَةٍ بِنُوْرِ الصُّفُوْرِ وَنُوْرِ الْعُمُوْرِ (ن >= 2) وَعَدَدٌ كَامِلٌ مُوجِبٌ كَ    // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))
    // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L))
    // (new List<long>(new long[]{(long)1L}))
    public static List<long> Minpath(List<List<long>> grid, long k) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Minpath(List<List<long>> grid, long k) {
        int n = grid.Count;
        List<long> result = new List<long>();
        long[,] dp = new long[n, n];
        (int, int)[,] parent = new (int, int)[n, n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = long.MaxValue;
            }
        }

        var directions = new List<(int, int)>() { (0, 1), (1, 0), (0, -1), (-1, 0) };
        SortedSet<(long, int, int)> pq = new SortedSet<(long, int, int)>((a, b) => a.Item1 == b.Item1 ? (a.Item2 == b.Item2 ? a.Item3.CompareTo(b.Item3) : a.Item2.CompareTo(b.Item2)) : a.Item1.CompareTo(b.Item1));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = grid[i][j];
                pq.Add((grid[i][j], i, j));
            }
        }

        while (pq.Count > 0) {
            var curr = pq.Min;
            pq.Remove(curr);
            long currValue = curr.Item1;
            int x = curr.Item2;
            int y = curr.Item3;

            foreach (var dir in directions) {
                int newX = x + dir.Item1;
                int newY = y + dir.Item2;
                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {
                    long newCost = currValue + grid[newX][newY];
                    if (dp[newX, newY] > newCost) {
                        if (dp[newX, newY] != long.MaxValue) {
                            pq.Remove((dp[newX, newY], newX, newY));
                        }
                        dp[newX, newY] = newCost;
                        parent[newX, newY] = (x, y);
                        pq.Add((dp[newX, newY], newX, newY));
                    }
                }
            }
        }

        (int, int) end = (0, 0);
        long minPathSum = long.MaxValue;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (minPathSum > dp[i, j]) {
                    minPathSum = dp[i, j];
                    end = (i, j);
                }
            }
        }

        Stack<long> pathStack = new Stack<long>();
        (int, int) node = end;
        for (int step = 0; step < k; step++) {
            pathStack.Push(grid[node.Item1][node.Item2]);
            node = parent[node.Item1, node.Item2];
        }

        while (pathStack.Count > 0) {
            result.Add(pathStack.Pop());
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L}), (List<long>)new List<long>(new long[]{(long)9L, (long)10L, (long)11L, (long)12L}), (List<long>)new List<long>(new long[]{(long)13L, (long)14L, (long)15L, (long)16L})})), (4L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)10L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)12L, (long)1L}), (List<long>)new List<long>(new long[]{(long)3L, (long)16L, (long)11L, (long)15L}), (List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L})})), (7L)).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)1L, (long)10L, (long)1L, (long)10L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L}), (List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)15L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)12L}), (List<long>)new List<long>(new long[]{(long)3L, (long)10L, (long)11L, (long)16L})})), (5L)).Equals((new List<long>(new long[]{(long)1L, (long)7L, (long)1L, (long)7L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L})})), (9L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L})})), (12L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)6L, (long)8L, (long)9L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)3L, (long)8L, (long)9L}), (List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)3L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    }

}
"
HumanEval_130,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //أَوَّلَ ن + 1 أَرقَامِ تَسلِيلِ تَريبوناتشي.    //تُعْطَى عَدَدَ كُلٍّ غَيْرِ سِيِّئٍ n، لَكَ أَنْ تَرُدَّ قِيمَةَ    //= 2 + 3 + 3 = 8  أَيْنَ مَكَانُكَ؟    //تِرْتِيْدِيْنْ = تِرْتِيْدِيْنْ + تِرْتِيْدِيْنْ (1) + تِرْتِيْدِيْنْ (4)    //تِرِيَيْتِ (4) = 3     //tri(2) = 1 + (2 / 2) = 2     //مِثَالًا:    //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), إِنْ كَانَ n فَرْدًا.     //tri ((n) = 1 + n / 2، إنْ كَانَ n زَوِيًّا.     //تِرِيَتَيَ (1) = 3     //تَسلسلُ تَربوناكي يَتَعَرَّف بِتَكرارِ:    //وَلَكِنْ مَا لا يَعْرِفُهُ النَّاسُ هُوَ تَتْبِيعُ تَرْبُونَكْي    //كُلُّ وَاحِدٍ يَعْرِفُ تَسلُولَ فِيبُونَاتْشي، تَدَرَّسَهُ بعمقٍ مِن قِبلِ علماءِ الرياضياتِ في    // >>> Tri((3L))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))
    public static List<long> Tri(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Tri(long n)
    {
        List<long> tribonacci = new List<long>(new long[n + 1]);

        for (long i = 0; i <= n; i++)
        {
            if (i == 0)
                tribonacci[(int)i] = 1;
            else if (i == 1)
                tribonacci[(int)i] = 3;
            else if (i % 2 == 0)
                tribonacci[(int)i] = 1 + i / 2;
            else
                tribonacci[(int)i] = tribonacci[(int)(i - 1)] + tribonacci[(int)(i - 2)] + tribonacci[(int)(i + 1)];
        }
        
        return tribonacci;
    }
    
    static void Main(string[] args)
    {
        // Example usage:
        Console.WriteLine(string.Join("", "", Tri(3)));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Tri((3L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))));
    Debug.Assert(Tri((4L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L}))));
    Debug.Assert(Tri((5L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L}))));
    Debug.Assert(Tri((6L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L}))));
    Debug.Assert(Tri((7L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L}))));
    Debug.Assert(Tri((8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L}))));
    Debug.Assert(Tri((9L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L}))));
    Debug.Assert(Tri((20L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L, (long)6L, (long)48L, (long)7L, (long)63L, (long)8L, (long)80L, (long)9L, (long)99L, (long)10L, (long)120L, (long)11L}))));
    Debug.Assert(Tri((0L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Tri((1L)).Equals((new List<long>(new long[]{(long)1L, (long)3L}))));
    }

}
"
HumanEval_131,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //يَعُودُ 0 إِنْ كَانَ كُلُّ الأَرْبَابِ زَوِيَّةً.    //مُعْطَى عَدَدَ كُلٍّ مُوجِبَ n، رُدَّ بِضَاعَةَ الأَرْجُلِ الغَرِيبَةِ.    // >>> Digits((1L))
    // (1L)
    // >>> Digits((4L))
    // (0L)
    // >>> Digits((235L))
    // (15L)
    public static long Digits(long n) {
","using System;

class Problem {
    public static long Digits(long n) {
        long product = 1;
        bool hasOdd = false;

        while (n > 0) {
            long digit = n % 10;
            if (digit % 2 != 0) {
                product *= digit;
                hasOdd = true;
            }
            n /= 10;
        }

        return hasOdd ? product : 0;
    }

    static void Main(string[] args) {
        Console.WriteLine(Digits(1L));    // Output: 1
        Console.WriteLine(Digits(4L));    // Output: 0
        Console.WriteLine(Digits(235L));  // Output: 15
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digits((5L)) == (5L));
    Debug.Assert(Digits((54L)) == (5L));
    Debug.Assert(Digits((120L)) == (1L));
    Debug.Assert(Digits((5014L)) == (5L));
    Debug.Assert(Digits((98765L)) == (315L));
    Debug.Assert(Digits((5576543L)) == (2625L));
    Debug.Assert(Digits((2468L)) == (0L));
    }

}
"
HumanEval_132,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //حَيْثُ أَقَامَةٌ وَاحِدَةٌ مِنَ الْمُتَعَدِّدِينَ مُتَعَدِّدَةٌ.    //تَجِبُ الوَظِيفَةُ تَرُدُّ صَحِيحًا إِنْ وَإِنْسَانًا إِنْ كَانَ ثَابِتًا تَتْبِعَةُ قُفَّيْنِ     //تَخْلُقُ دَلِيْلَةً تَتَّخِذُ سِلْسِلَةً كَدَخْلٍ تَتَضَمَّنُ قُسُوفَ مُرَبَّعَةٍ.    // >>> IsNested((""[[]]""))
    // (true)
    // >>> IsNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> IsNested((""[][]""))
    // (false)
    // >>> IsNested((""[]""))
    // (false)
    // >>> IsNested((""[[][]]""))
    // (true)
    // >>> IsNested((""[[]][[""))
    // (true)
    public static bool IsNested(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsNested(string str) {
        Stack<char> stack = new Stack<char>();
        bool hasNested = false;
        
        foreach (char ch in str) {
            if (ch == '[') {
                stack.Push(ch);
            } else if (ch == ']') {
                if (stack.Count > 0) {
                    stack.Pop();
                    hasNested = true;
                } else {
                    return false; // More closing brackets than opening
                }
            }

            // Check for nesting
            if (stack.Count > 1) {
                hasNested = true;
            }
        }
        
        return stack.Count == 0 && hasNested;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsNested((""[[]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]][[[[[]"")) == (false));
    Debug.Assert(IsNested((""[][]"")) == (false));
    Debug.Assert(IsNested((""[]"")) == (false));
    Debug.Assert(IsNested((""[[[[]]]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]]]]]"")) == (false));
    Debug.Assert(IsNested((""[][][[]]"")) == (true));
    Debug.Assert(IsNested((""[[]"")) == (false));
    Debug.Assert(IsNested((""[]]"")) == (false));
    Debug.Assert(IsNested((""[[]][["")) == (true));
    Debug.Assert(IsNested((""[[][]]"")) == (true));
    Debug.Assert(IsNested(("""")) == (false));
    Debug.Assert(IsNested((""[[[[[[[["")) == (false));
    Debug.Assert(IsNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //يَقْرُبُ كُلُّ عَنْصَرٍ مِنَ الْقَائِمَةِ إِلَى الْأَعْلَى    //تَحْتَاجُ أَنْ تَرُدَّ جُمْلَةَ الرُّتَبِ الرَّابِعَةِ فِي الْقَائِمَةِ،    //تُعْطَى لِسَانَ أَرقَامٍ.    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})))
    // (14L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)4.0f, (float)9.0f})))
    // (98L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))
    // (84L)
    // >>> Lst((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f})))
    // (29L)
    // >>> Lst((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f})))
    // (6L)
    public static long SumSquares(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<float> lst)
    {
        long sum = 0;
        foreach (float num in lst)
        {
            int roundedNum = (int)Math.Ceiling(num);
            sum += (long)(roundedNum * roundedNum);
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f}))) == (29L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)10000.0f, (float)10000.0f}))) == (200000000L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)0.0f}))) == (0L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f}))) == (1L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2L));
    }

}
"
HumanEval_134,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَعْلِيقَة: ""كَلِمَة"" جَمْعُ حُرُوفٍ مُفَارَقَة بِفَرْضٍ.    //وَكَذِبَ إِلَّا كَذِبَ    //مِنْ سِلْسِلَةٍ مَعْطُوفَةٍ حَرْفٌ أَلْفَاظِيٌّ وَلَيْسَ     //تَخْلُقُ دَلِيْلَةً تَرُدُّ صَحِيحَةً إِنْ كَانَ آخِرُ حَرْفٍ     // >>> CheckIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> CheckIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""""))
    // (false)
    public static bool CheckIfLastCharIsALetter(string txt) {
","public static bool CheckIfLastCharIsALetter(string txt) {
        if (string.IsNullOrWhiteSpace(txt)) {
            return false;
        }

        txt = txt.Trim();
        if (txt.Length == 0) {
            return false;
        }

        int lastIndex = txt.Length - 1;
        char lastChar = txt[lastIndex];

        if (!char.IsLetter(lastChar)) {
            return false;
        }

        if (lastIndex == 0 || char.IsWhiteSpace(txt[lastIndex - 1])) {
            return true;
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckIfLastCharIsALetter((""apple"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""A"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter(("""")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee e "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pie"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //قِيَمٌ مُتَوَاثِرَةٌ    //لَيْسَ كَذَا العَنْصَرُ فَيَرْجِعُ -1.    //لَيْسَ أَكْبَرَ مِنْ أَوْ مُسَاوِي العَنْصَرِ الْمُتَقَدِّمِ    //تَخْلُقُ دَلِيْلَةً تَرُدُّ أَكْبَرَ فَهْمِ عَنْصَرٍ    // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L})))
    // (3L)
    // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (-1L)
    public static long CanArrange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    // Create a function which returns the largest index of an element which
    // is not greater than or equal to the element immediately preceding it.
    // If no such element exists, then return -1.
    public static long CanArrange(List<long> arr) {
        for (int i = arr.Count - 1; i > 0; i--) {
            if (arr[i] < arr[i - 1]) {
                return i;
            }
        }
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))) == (3L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)5L}))) == (-1L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L}))) == (2L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)4L, (long)8L, (long)5L, (long)7L, (long)3L}))) == (4L));
    Debug.Assert(CanArrange((new List<long>())) == (-1L));
    }

}
"
HumanEval_136,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //إِنْ لَمْ يَكُنْ سِوَى أَوْ إِضَافِي أَعْدَدَ، رُدُّوهُمْ بِلَا شَيْءٍ.    //مِنْ أَصْحَابِ الْجَمِيلِ الْمُوجِبِينَ    //أَكْبَرُ سُبُلٍ سَلبِيَّةٍ، وَ ""ب"" أَصْغَرُ     //تَخْلُقُ دَلِيلَةً تَرُدُّ تَوْبَةً (a, b) ، حَيْثُ 'a' هُوَ     // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))
    // Tuple.Create((Nullable<long>)null, 1L)
    // >>> LargestSmallestIntegers((new List<long>()))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
","public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
        Nullable<long> largestNegative = null;
        Nullable<long> smallestPositive = null;

        foreach (var number in lst) {
            if (number < 0) {
                if (largestNegative == null || number > largestNegative) {
                    largestNegative = number;
                }
            } else if (number > 0) {
                if (smallestPositive == null || number < smallestPositive) {
                    smallestPositive = number;
                }
            }
        }

        return Tuple.Create(largestNegative, smallestPositive);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L, (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L, (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    }

}
"
HumanEval_138,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلْ    //تَقَيَّمْ هَلْ يُمْكِنُ أَنْ يُكْتَبَ الرَّقْمُ n كَمِثْلِ جُمْلَةِ 4 أَصْوَاتٍ مُوجِبَةٍ مُجَرَّدَةٍ    // >>> IsEqualToSumEven((4L))
    // (false)
    // >>> IsEqualToSumEven((6L))
    // (false)
    // >>> IsEqualToSumEven((8L))
    // (true)
    public static bool IsEqualToSumEven(long n) {
","using System;

class Problem {
    // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    public static bool IsEqualToSumEven(long n) {
        // Check if n is at least the sum of the smallest 4 positive even numbers (2 + 2 + 2 + 2 = 8)
        return n >= 8 && n % 2 == 0;
    }
    
    static void Main() {
        Console.WriteLine(IsEqualToSumEven(4L));  // false
        Console.WriteLine(IsEqualToSumEven(6L));  // false
        Console.WriteLine(IsEqualToSumEven(8L));  // true
        Console.WriteLine(IsEqualToSumEven(10L)); // true
        Console.WriteLine(IsEqualToSumEven(12L)); // true
        Console.WriteLine(IsEqualToSumEven(15L)); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsEqualToSumEven((4L)) == (false));
    Debug.Assert(IsEqualToSumEven((6L)) == (false));
    Debug.Assert(IsEqualToSumEven((8L)) == (true));
    Debug.Assert(IsEqualToSumEven((10L)) == (true));
    Debug.Assert(IsEqualToSumEven((11L)) == (false));
    Debug.Assert(IsEqualToSumEven((12L)) == (true));
    Debug.Assert(IsEqualToSumEven((13L)) == (false));
    Debug.Assert(IsEqualToSumEven((16L)) == (true));
    }

}
"
HumanEval_139,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //حَيْثُ n > 0     //brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!  أَيْ أَنْ تَكُونَ الْمَوْضُوعَةُ مُتَقَابِلَةً لِلْمَوْضُوعِ    //فَالعَدِيْلُ البرازِيليُ يُعرَفُ كَ:    // >>> SpecialFactorial((4L))
    // (288L)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    public static long SpecialFactorial(long n) {
","using System;
using System.Numerics;

class Problem {
    public static long SpecialFactorial(long n) {
        if (n <= 0)
            throw new ArgumentException(""n must be greater than 0"");
        
        BigInteger brazilianFactorial = 1;
        
        for (long i = 1; i <= n; i++) {
            brazilianFactorial *= Factorial(i);
        }
        
        return (long)brazilianFactorial;
    }
    
    private static BigInteger Factorial(long num) {
        BigInteger result = 1;
        for (long i = 1; i <= num; i++) {
            result *= i;
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SpecialFactorial((4L)) == (288L));
    Debug.Assert(SpecialFactorial((5L)) == (34560L));
    Debug.Assert(SpecialFactorial((7L)) == (125411328000L));
    Debug.Assert(SpecialFactorial((1L)) == (1L));
    }

}
"
HumanEval_140,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ثُمَّ أَبْدِلْ كُلَّ الْمَسَافاتِ التَّتَابِعَةِ بِـ -     //وَإِنْ كَانَتْ السِّلْسِلَةُ لَهَا أَكْثَرُ مِنْ بَيَانَيْنِ مُتَتَابِعَيْنِ،    //مَنْطِقَةٌ مِنْ النَّصِّ، فَاحْلِلْ كُلَّ الْفُرُوجِ بِالْخَفِيفِ،     // >>> FixSpaces(("" Example""))
    // (""Example"")
    // >>> FixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> FixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> FixSpaces(("" Example 3""))
    // (""_Example-3"")
    public static string FixSpaces(string text) {
","public static string FixSpaces(string text) {
        StringBuilder result = new StringBuilder();
        int spaceCount = 0;

        for (int i = 0; i < text.Length; i++) {
            if (text[i] == ' ') {
                spaceCount++;
            } else {
                if (spaceCount > 2) {
                    result.Append('-');
                } else {
                    for (int j = 0; j < spaceCount; j++) {
                        result.Append('_');
                    }
                }
                result.Append(text[i]);
                spaceCount = 0;
            }
        }

        if (spaceCount > 2) {
            result.Append('-');
        } else {
            for (int j = 0; j < spaceCount; j++) {
                result.Append('_');
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FixSpaces((""Example"")).Equals((""Example"")));
    Debug.Assert(FixSpaces((""Mudasir Hanif "")).Equals((""Mudasir_Hanif_"")));
    Debug.Assert(FixSpaces((""Yellow Yellow  Dirty  Fellow"")).Equals((""Yellow_Yellow__Dirty__Fellow"")));
    Debug.Assert(FixSpaces((""Exa   mple"")).Equals((""Exa-mple"")));
    Debug.Assert(FixSpaces((""   Exa 1 2 2 mple"")).Equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //- سَبْتَرْنْدْ بَعْدْ النُّقْطَة يَجِبْ أَنْ يَكُونْ وَاحِدْ مِنْ هَذِهِ: ['تَكْتُبْ'، 'إكْيِسْ، 'دَلْ]     //حَرْفُ اللَّاتِينِيَّةِ ('a'-'z' وَ 'A'-'Z').    //- فَلَا يَجِبُ أَنْ يَكُونَ السِّلْسِلَةُ الْمُتَقَدِّمَةُ لِلْبَيِّنَةِ فَارِغَةً، وَيَبْدَأُ بِحَرْفِ     //- اسم الملف يَحتوي بالضبط على نقطة واحدة '.'     //- لاَ يَجِبُ أَكْثَرُ مِنْ ثَلاثَةِ أَرْكَانٍ ('0'-'9') فِي اسْمِ الملف.    //تُلبَى:    //يُعْتَبَرُ اسْمُ مَسْجِلٍ صَحِيحًا إِنْ وَإِنْ سَمَّى كُلَّ الشُّرُوطِ التَّالِيَةِ     //""نَعَمْ"" إنْ كَانَ اسْمُ الملف صحيحاً، وَيَرُدُّ ""لا"" إنْ كَانَ غير ذلك.    //تَخْلُقُ دَلِيْلَةً تَأْخُذُ سِلْسِلَةً تَمْثُلُ اسْمَ مَسْجِدٍ، وَتَرُدُّ     // >>> FileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> FileNameCheck((""1example.dll""))
    // (""No"")
    public static string FileNameCheck(string file_name) {
","using System;
using System.Text.RegularExpressions;

class Problem {
    public static string FileNameCheck(string file_name) {
        // Regular expression to validate the file name
        string pattern = @""^[a-zA-Z][^.]*\.[^.]+$"";
        
        // Check if there is exactly one dot and matches the overall pattern
        if (Regex.IsMatch(file_name, pattern)) {
            string[] parts = file_name.Split('.');
            
            // Check if the file extension is one of the allowed values
            if (new[] { ""txt"", ""exe"", ""dll"" }.Contains(parts[1])) {
                // Count the number of digits in the file name
                int digitCount = file_name.Count(char.IsDigit);
                
                // Validate the digit count
                if (digitCount <= 3) {
                    return ""Yes"";
                }
            }
        }
        
        return ""No"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FileNameCheck((""example.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1example.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s1sdf3.asd"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""K.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""MY16FILE3.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""His12FILE94.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_Y.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""?aREYA.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""/this_is_valid.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.wow"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txtexe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""#this2_i4s_5valid.ten"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""@this1_is6_valid.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_12valid.6exe4.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""all.exe.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_No.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""Is3youfault.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""no_one#knows.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1I563_Yes3.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_Yes3.txtt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final..txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final132"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_f4indsartal132."")).Equals((""No"")));
    Debug.Assert(FileNameCheck(("".txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s."")).Equals((""No"")));
    }

}
"
HumanEval_142,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //تَغْيِيرُ الإِدْخَالَاتِ فِي الْقَائِمَةِ الَّتِي لَيْسَتْ أَدِلَّتُهَا مُضَارَبَةً لِ3 أَوْ 4. تَرُدُّ الْمَصْدَرُ جُمْلَةَ كُلِّ الإِدْخَالَاتِ.    //مُتَكَاثِرُ 3 وَسَيَكُوْبُ الإِنْتِدَاءَ الصَّحِيْحَ إِنْ كَانَ مُتَكَاثِرُ 4 وَلَيْسَ مُتَكَاثِرُ 3    //هَذِهِ الْمَنْطِقَةُ تَأْخُذُ قِيمَةَ أَعْدَادٍ. لِكُلِّ الْمَدَائِنِ فِي الْقِيمَةِ، تَرْتَبِعُ الْمَدَادِنَ إِذَا كَانَ مُؤَوِّلُهَا a     //""     // >>> lst
    // (long)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})
    // >>> lst
    // (long)new List<long>()
    // >>> lst
    // (long)new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L})
    public static long SumSquares(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<long> lst)
    {
        for (int i = 0; i < lst.Count; i++)
        {
            if (i % 3 == 0)
            {
                lst[i] = lst[i] * lst[i];
            }
            else if (i % 4 == 0)
            {
                lst[i] = lst[i] * lst[i] * lst[i];
            }
        }
        long sum = 0;
        foreach (long number in lst)
        {
            sum += number;
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (6L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)4L, (long)9L}))) == (14L));
    Debug.Assert(SumSquares((new List<long>())) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L}))) == (9L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L}))) == (-3L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)0L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L}))) == (-126L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-56L, (long)-99L, (long)1L, (long)0L, (long)-2L}))) == (3030L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)-1L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-16L, (long)-9L, (long)-2L, (long)36L, (long)36L, (long)26L, (long)-20L, (long)25L, (long)-40L, (long)20L, (long)-4L, (long)12L, (long)-26L, (long)35L, (long)37L}))) == (-14196L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-3L, (long)17L, (long)-1L, (long)-15L, (long)13L, (long)-1L, (long)14L, (long)-14L, (long)-12L, (long)-5L, (long)14L, (long)-14L, (long)6L, (long)13L, (long)11L, (long)16L, (long)16L, (long)4L, (long)10L}))) == (-1448L));
    }

}
"
HumanEval_143,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالُ 1:    //يَجِبُ أَنْ يَكُونَ تَرْتِيبُ الكَلِمَاتِ فِي السِّلْسِلَةِ الجَدِيدَةِ كَالأُولَى.    //مَا مَدَاهُ أَعْدَادٌ أُولَى،     //وَلَكَ أَنْ تَرُدَّ سِلْسِلَةً تَحْتَوِي كَلِمَاتِ الجُمْلَةِ الأُولَى،     //الجُمْلَةُ تَتَضَمَّنُ بَعْضَ الكَلِمَاتِ مُفَرَّقَةً بِسِيطَةٍ،     //تُعْطَى سِلْسِلَةٌ تَمْثِلُ جُمْلَةً،     // >>> WordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> WordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    public static string WordsInSentence(string sentence) {
","using System;
using System.Collections.Generic;

class Problem {
    public static string WordsInSentence(string sentence) {
        bool IsPrime(int number) {
            if (number <= 1) return false;
            if (number == 2) return true;
            for (int i = 2; i * i <= number; i++) {
                if (number % i == 0) return false;
            }
            return true;
        }

        string[] words = sentence.Split(' ');
        List<string> primeLengthWords = new List<string>();

        foreach (string word in words) {
            if (IsPrime(word.Length)) {
                primeLengthWords.Add(word);
            }
        }

        return string.Join("" "", primeLengthWords);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsInSentence((""This is a test"")).Equals((""is"")));
    Debug.Assert(WordsInSentence((""lets go for swimming"")).Equals((""go for"")));
    Debug.Assert(WordsInSentence((""there is no place available here"")).Equals((""there is no place"")));
    Debug.Assert(WordsInSentence((""Hi I am Hussein"")).Equals((""Hi am Hussein"")));
    Debug.Assert(WordsInSentence((""go for it"")).Equals((""go for it"")));
    Debug.Assert(WordsInSentence((""here"")).Equals(("""")));
    Debug.Assert(WordsInSentence((""here is"")).Equals((""is"")));
    }

}
"
HumanEval_144,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَجِدُ أَنَّ x و n كَسَرَاتٌ صَحِيحَةٌ وَلَيْسَ لَهُمَا قَائِمٌ 0    //<مُجَدِّد>/<مُسَمِّي> حَيْثُ كِلاَ الْمُجَدِّد وَالْمُسَمِّي عَدَدَانِ كُلَّاهُمَا إيجَابِيَّانِ.    //كِلاَ x و n، وَهُمَا تَمْثِيلَاتُ كَسْرٍ، وَلَهُمَا التَّصْوِيرُ التَّالِي،    //x * n. تَرُدُّ الصَّدَقَةَ إِذَا تَقَدَّمَتْ x * n إِلَى عَدَدٍ كَامِلٍ وَكَذِبَ     //مَهمَتُكَ تَنفيذُ دَالةٍ تُبَسِّطُ التَعبيرَ    // >>> Simplify((""1/5""), (""5/1""))
    // (true)
    // >>> Simplify((""1/6""), (""2/1""))
    // (false)
    // >>> Simplify((""7/10""), (""10/2""))
    // (false)
    public static bool Simplify(string x, string n) {
","using System;

class Problem {
    public static bool Simplify(string x, string n) {
        var xParts = x.Split('/');
        var nParts = n.Split('/');
        
        int xNumerator = int.Parse(xParts[0]);
        int xDenominator = int.Parse(xParts[1]);
        
        int nNumerator = int.Parse(nParts[0]);
        int nDenominator = int.Parse(nParts[1]);
        
        // Calculate the resulting fraction for x * n
        int resultNumerator = xNumerator * nNumerator;
        int resultDenominator = xDenominator * nDenominator;
        
        // Simplify the fraction by finding the gcd
        int gcd = GCD(resultNumerator, resultDenominator);
        resultNumerator /= gcd;
        resultDenominator /= gcd;
        
        // It is a whole number if the simplified denominator is 1
        return resultDenominator == 1;
    }
    
    private static int GCD(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/6""), (""2/1"")) == (false));
    Debug.Assert(Simplify((""5/1""), (""3/1"")) == (true));
    Debug.Assert(Simplify((""7/10""), (""10/2"")) == (false));
    Debug.Assert(Simplify((""2/10""), (""50/10"")) == (true));
    Debug.Assert(Simplify((""7/2""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""11/6""), (""6/1"")) == (true));
    Debug.Assert(Simplify((""2/3""), (""5/2"")) == (false));
    Debug.Assert(Simplify((""5/2""), (""3/5"")) == (false));
    Debug.Assert(Simplify((""2/4""), (""8/4"")) == (true));
    Debug.Assert(Simplify((""2/4""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //يَنْظُمُهُمْ بِنَاءً عَلَى فَصْلِهِمْ فِي الْقِيمَةِ    //تَعْلِيقَة: إِنْ كَانَ بَعْض الْبَدَائِع مَع مِثْل جُمْلَة أَرْبَابهمْ    //في ترتيبٍ مُصْعَدٍ وَيَتَبَايَنُ بِجُمْلَةِ أَرْبَاعِهِمْ    //اُكْتُبْ دَلِيْلَ يُنَوِّنُ القَائِمَ المَوْعُودَ مِنَ الأَصْحَابِ    // >>> OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L})))
    // (new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))
    // >>> OrderByPoints((new List<long>()))
    // (new List<long>())
    public static List<long> OrderByPoints(List<long> nums) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> OrderByPoints(List<long> nums)
    {
        return nums.Select((num, index) => new { Number = num, Index = index, DigitSum = SumOfDigits(num) })
                   .OrderBy(item => item.DigitSum)
                   .ThenBy(item => item.Index)
                   .Select(item => item.Number)
                   .ToList();
    }

    private static int SumOfDigits(long number)
    {
        number = Math.Abs(number);
        int sum = 0;
        while (number > 0)
        {
            sum += (int)(number % 10);
            number /= 10;
        }
        return sum;
    }

    static void Main(string[] args)
    {
        var sortedList = OrderByPoints(new List<long> { 1L, 11L, -1L, -11L, -12L });
        Console.WriteLine(string.Join("", "", sortedList));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L}))).Equals((new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1234L, (long)423L, (long)463L, (long)145L, (long)2L, (long)423L, (long)423L, (long)53L, (long)6L, (long)37L, (long)3457L, (long)3L, (long)56L, (long)0L, (long)46L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)6L, (long)53L, (long)423L, (long)423L, (long)423L, (long)1234L, (long)145L, (long)37L, (long)46L, (long)56L, (long)463L, (long)3457L}))));
    Debug.Assert(OrderByPoints((new List<long>())).Equals((new List<long>())));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)-11L, (long)-32L, (long)43L, (long)54L, (long)-98L, (long)2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)-3L, (long)-32L, (long)-98L, (long)-11L, (long)1L, (long)2L, (long)43L, (long)54L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L, (long)11L}))).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)2L, (long)11L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)0L, (long)6L, (long)6L, (long)-76L, (long)-21L, (long)23L, (long)4L}))).Equals((new List<long>(new long[]{(long)-76L, (long)-21L, (long)0L, (long)4L, (long)23L, (long)6L, (long)6L}))));
    }

}
"
HumanEval_146,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //أَوَّلُ وَآخِرُ أَلْفَاظِ عَدَدٍ فُرَادِيَّةٌ (1, 3, 5, 7, 9).    //عَدَدَ العَنَوَاتِ فِي القَائِمَةِ الَّتِي هِيَ أَكْبَرُ مِنْ 10 وَكِلَاهُمَا     //اُكْتُبْ دَلِيْلَةً تَتَأَخَّذُ قِيَامَ أَرْقَامٍ كَدَخْلٍ وَتَعُودُ    // >>> Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L})))
    // (1L)
    // >>> Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L})))
    // (2L)
    public static long Specialfilter(List<long> nums) {
","public static long Specialfilter(List<long> nums) {
        return nums.Count(num => {
            if (num <= 10) return false;
            long positiveNum = Math.Abs(num);
            string numStr = positiveNum.ToString();
            char firstDigit = numStr[0];
            char lastDigit = numStr[numStr.Length - 1];
            return IsOddDigit(firstDigit) && IsOddDigit(lastDigit);
        });
    }

    private static bool IsOddDigit(char digit) {
        return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9';
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)5L, (long)-2L, (long)1L, (long)-5L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L}))) == (1L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L}))) == (2L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)43L, (long)-12L, (long)93L, (long)125L, (long)121L, (long)109L}))) == (4L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)71L, (long)-2L, (long)-33L, (long)75L, (long)21L, (long)19L}))) == (3L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>())) == (0L));
    }

}
"
HumanEval_147,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلٌ:    //وَأَيْ + جَ + كَ ضِعْفُ ثَلَاثٍ.    //يَرْجِعُ عَدَدَ الثَّلَاثَاتِ (a[i], a[j], a[k]) مِنْ a حَيْثُ i < j < k,     //لِكُلِّ i (1 ≤ i ≤ n) ، قِيمَةُ a[i] = i * i - i + 1.    //تُعْطَى عَدَدَ كُلٍّ مُوجِبٍ ن. لَكَ أن تَصْنَعَ قَائِمَةَ عَدَدٍ مُوجِبٍ مِنْ طُولِ ن.    // >>> GetMaxTriples((5L))
    // (1L)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    public static long GetMaxTriples(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long GetMaxTriples(long n) {
        List<long> a = new List<long>();
        for (long i = 1; i <= n; i++) {
            a.Add(i * i - i + 1);
        }

        long count = 0;
        for (int i = 0; i < a.Count; i++) {
            for (int j = i + 1; j < a.Count; j++) {
                for (int k = j + 1; k < a.Count; k++) {
                    if ((a[i] + a[j] + a[k]) % 3 == 0) {
                        count++;
                    }
                }
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        long n = 5; // Example input
        Console.WriteLine(GetMaxTriples(n)); // Should output 1 based on the example given
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetMaxTriples((5L)) == (1L));
    Debug.Assert(GetMaxTriples((6L)) == (4L));
    Debug.Assert(GetMaxTriples((10L)) == (36L));
    Debug.Assert(GetMaxTriples((100L)) == (53361L));
    }

}
"
HumanEval_148,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //لَيسَت أسْمَاءَ كَواكبٍ صحيحة.    //تَجِبُ الوَظِيفَةُ تَرُدُّ فَارِغَةً إِنْ كَانَتْ كَوْكَبَةً1 أَوْ كَوْكَبَةً2    //قُرْبَةَ الشَّمْسِ.    //يَكُونُ بَيْنَ مَدارِ كَوكَبِ1 وَمَدارِ كَوكَبِ2, مُنْتَقَطٌ بِ    //تَجِبُ أَنْ تَرُدَّ مُضَارِعَةً مَوْجُودَةً كُلَّ الْكَوَاكِبِ الَّتِي أَمَارَاتُهَا    //كَتِبْ دَلِيلَ يَأْخُذُ اسْمَيْ كَوْكَبٍ كَسِلْسِلَةِ كَوْكَبِ1 وَكَوْكَبِ2.    //أُورَانُسُ، نَبْتُونُ.    //هُوَ زَهْرُوبُ، وَالْآخَرُ هُوَ الْفِنُوسُ، ثُمَّ الْأَرْضُ، مَارِسُ، جُوبِيْتُرُ، زَوْرَبُ،    //هُنَاكَ ثَمَانُ كَواكبٍ فِي مَنظَمِنا الشَّمْسي: الأقْربُ مِنَ الشَّمْسِ    // >>> Bf((""Jupiter""), (""Neptune""))
    // (new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))
    // >>> Bf((""Earth""), (""Mercury""))
    // (List<string>(""Venus""))
    // >>> Bf((""Mercury""), (""Uranus""))
    // (new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))
    public static List<string> Bf(string planet1, string planet2) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> Bf(string planet1, string planet2) {
        List<string> planets = new List<string> { ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"" };
        int index1 = planets.IndexOf(planet1);
        int index2 = planets.IndexOf(planet2);

        if (index1 == -1 || index2 == -1) {
            return new List<string>();
        }
        
        List<string> result = new List<string>();
        int start = Math.Min(index1, index2);
        int end = Math.Max(index1, index2);

        for (int i = start + 1; i < end; i++) {
            result.Add(planets[i]);
        }

        return result;
    }

    public static void Main() {
        Console.WriteLine(string.Join("", "", Bf(""Jupiter"", ""Neptune""))); // Output: Saturn, Uranus
        Console.WriteLine(string.Join("", "", Bf(""Earth"", ""Mercury"")));   // Output: Venus
        Console.WriteLine(string.Join("", "", Bf(""Mercury"", ""Uranus""))); // Output: Venus, Earth, Mars, Jupiter, Saturn
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Bf((""Jupiter""), (""Neptune"")).Equals((new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Mercury"")).Equals((new List<string>(new string[]{(string)""Venus""}))));
    Debug.Assert(Bf((""Mercury""), (""Uranus"")).Equals((new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))));
    Debug.Assert(Bf((""Neptune""), (""Venus"")).Equals((new List<string>(new string[]{(string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Mars""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Jupiter""), (""Makemake"")).Equals((new List<string>())));
    }

}
"
HumanEval_149,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //تَتَوَهَّمُ أَنَّ كُلَّ كَلِمَاتٍ تَكُونُ بِمِثْلِ الطُّولِ.    //يَجِبُ أَنْ تَرُدَّ الْمُدَّةَ قِيَامَةَ سُلُطَاتٍ مُنَظَّمَةٍ.    //إِنْ كَانَ لِكَلِمَتَيْنِ طُولُهُمَا مُتَسَاوِي، فَصُنْفِ الْقَائِمَةَ حَرْفِيَّةً.    //يَجِبُ أَنْ يَرْجِعَ الْقَائِمَ مُنْتَقَبَةً بِهَذِهِ الْقَاعِدَةِ.    //لَيْسَ لِي أَنْ أَكُونَ مُتَعَلِّقًا بِكُلِّ كَلِمَةٍ    //وَقَدْ يَتَضَمَّنُ مُثَنَّاتٍ.    //القَدَرُ دَائِمًا قَدَرُ سَلاَسِلٍ وَلاَ قَدَرُ أَرْقَامٍ    //وَيَرُدُّ الْقَائِمَ النَّاتِجَ بِتَرْتِيبٍ مُنْتَقَبٍ،     //يَحْذِفُ السِّلَالَ الَّتِي لَهَا أَطْوَالٌ فُرَادِيَّةٌ مِنْهَا،     //كَتِبْ دَلِيلَ يَقْبَلُ قَائِمَةَ سِلَالٍ كَمُعَايَنَةٍ،    // >>> ListSort((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""})))
    // (new List<string>(new string[]{(string)""aa""}))
    // >>> ListSort((new List<string>(new string[]{(string)""ab"", (string)""a"", (string)""aaa"", (string)""cd""})))
    // (new List<string>(new string[]{(string)""ab"", (string)""cd""}))
    public static List<string> SortedListSum(List<string> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ListSort(List<string> lst) {
        return lst.Where(x => x.Length % 2 == 0)
                  .OrderBy(x => x.Length)
                  .ThenBy(x => x)
                  .ToList();
    }
    
    static void Main() {
        var result1 = ListSort(new List<string> { ""aa"", ""a"", ""aaa"" });
        Console.WriteLine(string.Join("", "", result1)); // Output: aa

        var result2 = ListSort(new List<string> { ""ab"", ""a"", ""aaa"", ""cd"" });
        Console.WriteLine(string.Join("", "", result2)); // Output: ab, cd
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""}))).Equals((new List<string>(new string[]{(string)""aa""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""school"", (string)""AI"", (string)""asdf"", (string)""b""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""asdf"", (string)""school""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""b"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""dcba"", (string)""abcd"", (string)""a""}))).Equals((new List<string>(new string[]{(string)""abcd"", (string)""dcba""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""b"", (string)""c"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aaaa"", (string)""bbbb"", (string)""dd"", (string)""cc""}))).Equals((new List<string>(new string[]{(string)""cc"", (string)""dd"", (string)""aaaa"", (string)""bbbb""}))));
    }

}
"
HumanEval_150,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //a prime number وَيَجِبُ أَنْ يَرُدَّ قِيمَةَ y إِلَّا.    //برنامجٌ بسيطٌ يَرُدُّ قيمةَ x إذا كانَ n     // >>> XOrY((7L), (34L), (12L))
    // (34L)
    // >>> XOrY((15L), (8L), (5L))
    // (5L)
    public static long XOrY(long n, long x, long y) {
","using System;

class Problem {
    public static long XOrY(long n, long x, long y) {
        return IsPrime(n) ? x : y;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;
        if (number % 2 == 0 || number % 3 == 0) return false;
        
        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }
        
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(XOrY((7L), (34L), (12L)) == (34L));
    Debug.Assert(XOrY((15L), (8L), (5L)) == (5L));
    Debug.Assert(XOrY((3L), (33L), (5212L)) == (33L));
    Debug.Assert(XOrY((1259L), (3L), (52L)) == (3L));
    Debug.Assert(XOrY((7919L), (-1L), (12L)) == (-1L));
    Debug.Assert(XOrY((3609L), (1245L), (583L)) == (583L));
    Debug.Assert(XOrY((91L), (56L), (129L)) == (129L));
    Debug.Assert(XOrY((6L), (34L), (1234L)) == (1234L));
    Debug.Assert(XOrY((1L), (2L), (0L)) == (0L));
    Debug.Assert(XOrY((2L), (2L), (0L)) == (2L));
    }

}
"
HumanEval_151,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تَجَاهَلْ الأَرْقَامَ الَّتِي هِيَ سَبِيْبَةٌ أَوْ غَيْرُ سَمِيْرَةٍ.    //مُعْطَيَةَ قِيَامَةِ أَرْقَامٍ، ارْجِعْ بِجَمْعِ رُبُوعِ الأَرْقَامِ    // >>> DoubleTheDifference((new List<float>(new long[]{(long)1L, (long)3L, (long)2L, (long)0L})))
    // (10L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)-1L, (long)-2L, (long)0L})))
    // (0L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)9L, (long)-2L})))
    // (81L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)0L})))
    // (0L)
    // If the input list is empty, return 0.
    public static long DoubleTheDifference(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    // Given a list of numbers, return the sum of squares of the numbers
    // in the list that are odd. Ignore numbers that are negative or not integers.
    public static long DoubleTheDifference(List<float> lst) {
        long sum = 0;
        foreach (var num in lst) {
            if (num >= 0 && num == (long)num && ((long)num % 2) != 0) {
                sum += (long)num * (long)num;
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoubleTheDifference((new List<float>())) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)5.0f, (float)4.0f}))) == (25L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.1f, (float)0.2f, (float)0.3f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.2f, (float)3.0f, (float)5.0f}))) == (34L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165L));
    }

}
"
HumanEval_152,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //القِيمَةُ 0، وَإِنْ لَمْ تَكُنْ، فَالقِيمَةُ هِيَ الْفَرْقُ المُطلق بين التخمين والنتيجة.    //رُدَّ سِلْسِلَةً مِنْ ذَاتِ الطُّولِ تُشِيرُ كَمْ كَانَ كُلُّ خُيُولٍ مُتَبَاعِدَةً.    //تُعْطَى قَدَرَانِ مِنْ الْحُصُولِ وَالتَّخَيُّرِ مِنْ طُولِ مُسَاوٍ، حَيْثُ كُلُّ فَصْلٍ يُبَيِّنُ مُطَابَقَةً.    //مَهْمَا تَكُونُ مَهْمَا تَكُونُ مَهْمَا تَكُونُ مَهْمَا تَكُونُ    //يَجِبُ أَنْ تُسَجَّلَ وَتُقَارَنَ    //حَدثٌ مَعْرُوفٌ أخِيراً.    //أَظُنُّ أَنَّنَا كُلّنَا نَتَذَكَّرُ ذلك الشَّعْرِ عندما نَتِمُّ بَعْضَ الطَّوِيلِ المُنتَظَرِ    // >>> Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L})))
    // (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))
    // >>> Compare((new List<long>(new long[]{(long)0L, (long)5L, (long)0L, (long)0L, (long)0L, (long)4L})), (new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L, (long)0L, (long)-2L})))
    // (new List<long>(new long[]{(long)4L, (long)4L, (long)1L, (long)0L, (long)0L, (long)6L}))
    public static List<long> Compare(List<long> game, List<long> guess) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Compare(List<long> game, List<long> guess)
    {
        List<long> differences = new List<long>();
        for (int i = 0; i < game.Count; i++)
        {
            differences.Add(Math.Abs(game[i] - guess[i]));
        }
        return differences;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L})), (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L})), (new List<long>(new long[]{(long)-1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)0L, (long)0L, (long)1L}))));
    }

}
"
HumanEval_153,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //(قُوَّتُهُ -1).    //return ""Slices.SErviNGSliCes"" مِنْ أَنَّ ""SErviNGSliCes"" هُوَ أَقْوَى تَمْدِيد     //إِذَنْ يَجِبُ أَنْ تَقُولَ:    //مَثَلاً، إنْ أُعْطِيتَ ""شِطَارَات"" كَالصِّنَفِ وَقِيمَةٌ مِنْ     //اخْتَارْ الَّذِي يَأْتِي أَوَّلَ فِي الْقَائِمَة.    //إنْ كَانَ ثَنِيَةٌ أوْ أكثر مِنْ إمتِدَادٍ بنفس القوَةِ،    //format: ClassName.StrongestExtensionName.  أَيْ أَقْوَى إِضَافَةَ اسْمِ.    //يَجِبُ أَنْ تَجِدَ أَقْوَى إِضَافَةٍ وَتَرُدَّ سِلْسِلَةً فِي هَذِهِ    //في أَسْمَاءِ التَمْدِ، تُعْطَى القُوَّةُ بِكَسْرِ CAP - SM.    //حُرُوفُ في اسمِ التَمْدِيدِ، وَلْتَكُنْ SM عَدَدَ حُرُوفِ الصَّغِيرَةِ     //قوة الإضافة هي كَمَا يَلِي: لِيَكُنْ CAP الرَّقْمَ مِنْ حَرْفِ الْكَبِيرِ     //التَمَدُّدَاتْ تَستَعملْ لِتَحْمِلْ فِئَاتْ إضافِيَة لِلفِئَةْ.    //سَتُعْطَى اسْمَ فِئَةٍ (سِلْسِلَةٍ) وَقِيمَةَ مَزَايِدِهَا.    // >>> StrongestExtension((""my_class""), (new List<string>(new string[]{(string)""AA"", (string)""Be"", (string)""CC""})))
    // (""my_class.AA"")
    public static string StrongestExtension(string class_name, List<string> extensions) {
","public static string StrongestExtension(string class_name, List<string> extensions) {
        string strongestExtension = null;
        int maxStrength = int.MinValue;

        foreach (var extension in extensions) {
            int countUpper = extension.Count(char.IsUpper);
            int countLower = extension.Count(char.IsLower);
            int strength = countUpper - countLower;

            if (strength > maxStrength) {
                maxStrength = strength;
                strongestExtension = extension;
            }
        }

        return $""{class_name}.{strongestExtension}"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrongestExtension((""Watashi""), (new List<string>(new string[]{(string)""tEN"", (string)""niNE"", (string)""eIGHt8OKe""}))).Equals((""Watashi.eIGHt8OKe"")));
    Debug.Assert(StrongestExtension((""Boku123""), (new List<string>(new string[]{(string)""nani"", (string)""NazeDa"", (string)""YEs.WeCaNe"", (string)""32145tggg""}))).Equals((""Boku123.YEs.WeCaNe"")));
    Debug.Assert(StrongestExtension((""__YESIMHERE""), (new List<string>(new string[]{(string)""t"", (string)""eMptY"", (string)""nothing"", (string)""zeR00"", (string)""NuLl__"", (string)""123NoooneB321""}))).Equals((""__YESIMHERE.NuLl__"")));
    Debug.Assert(StrongestExtension((""K""), (new List<string>(new string[]{(string)""Ta"", (string)""TAR"", (string)""t234An"", (string)""cosSo""}))).Equals((""K.TAR"")));
    Debug.Assert(StrongestExtension((""__HAHA""), (new List<string>(new string[]{(string)""Tab"", (string)""123"", (string)""781345"", (string)""-_-""}))).Equals((""__HAHA.123"")));
    Debug.Assert(StrongestExtension((""YameRore""), (new List<string>(new string[]{(string)""HhAas"", (string)""okIWILL123"", (string)""WorkOut"", (string)""Fails"", (string)""-_-""}))).Equals((""YameRore.okIWILL123"")));
    Debug.Assert(StrongestExtension((""finNNalLLly""), (new List<string>(new string[]{(string)""Die"", (string)""NowW"", (string)""Wow"", (string)""WoW""}))).Equals((""finNNalLLly.WoW"")));
    Debug.Assert(StrongestExtension((""_""), (new List<string>(new string[]{(string)""Bb"", (string)""91245""}))).Equals((""_.Bb"")));
    Debug.Assert(StrongestExtension((""Sp""), (new List<string>(new string[]{(string)""671235"", (string)""Bb""}))).Equals((""Sp.671235"")));
    }

}
"
HumanEval_154,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //تُعْطَى كَلِمَتَيْنِ. تَحْتَاجُ إِلَى إِرْجَاعِ صَحِيحٍ إِنْ كَانَتِ الكَلِمَةُ الثَّانِيَةُ أَوْ أَيُّ تَدَارُكَاتِهَا سُكُونَةً في الكَلِمَةِ الأُولَى.    // >>> CycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> CycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> CycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> CycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> CycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> CycpatternCheck((""himenss""), (""simen""))
    // (true)
    public static bool CycpatternCheck(string a, string b) {
","using System;

class Problem {
    public static bool CycpatternCheck(string a, string b) {
        if (a.Length < b.Length) {
            return false;
        }

        string combinedB = b + b;
        for (int i = 0; i < b.Length; i++) {
            string rotation = combinedB.Substring(i, b.Length);
            if (a.Contains(rotation)) {
                return true;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CycpatternCheck((""xyzw""), (""xyw"")) == (false));
    Debug.Assert(CycpatternCheck((""yello""), (""ell"")) == (true));
    Debug.Assert(CycpatternCheck((""whattup""), (""ptut"")) == (false));
    Debug.Assert(CycpatternCheck((""efef""), (""fee"")) == (true));
    Debug.Assert(CycpatternCheck((""abab""), (""aabb"")) == (false));
    Debug.Assert(CycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //مُعْطَى عَدَدَ كُلٍّ. رُدَّ مُضَارِعَةً لَهَا عَدَدُ أَعْدَادِ الزَّوَاجِ وَالْعَدَدِ.    // >>> EvenOddCount((-12L))
    // (Tuple.Create(1L, 1L))
    // >>> EvenOddCount((123L))
    // (Tuple.Create(1L, 2L))
    public static Tuple<long, long> EvenOddCount(long num) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    public static Tuple<long, long> EvenOddCount(long num) {
        // Convert the number to positive to handle negative numbers
        num = Math.Abs(num);
        long evenCount = 0;
        long oddCount = 0;
        
        while (num > 0) {
            long digit = num % 10;
            if (digit % 2 == 0)
                evenCount++;
            else
                oddCount++;
            num /= 10;
        }
        
        return Tuple.Create(evenCount, oddCount);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddCount((7L)).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(EvenOddCount((-78L)).Equals((Tuple.Create(1L, 1L))));
    Debug.Assert(EvenOddCount((3452L)).Equals((Tuple.Create(2L, 2L))));
    Debug.Assert(EvenOddCount((346211L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-345821L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-2L)).Equals((Tuple.Create(1L, 0L))));
    Debug.Assert(EvenOddCount((-45347L)).Equals((Tuple.Create(2L, 3L))));
    Debug.Assert(EvenOddCount((0L)).Equals((Tuple.Create(1L, 0L))));
    }

}
"
HumanEval_156,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَلَات:    //قَيَدَات: 1 <= num <= 1000     //وَأَرْجِعْهُ بِحُرُوفٍ صَغِيرَةٍ.    //مُعْطَى عَدَدَ كُلٍّ إيجَابِيٍّ، احْصُلْ عَدَدَهُ الْرُومَانِيَّ كَسِلْسِلَةٍ،     // >>> IntToMiniRoman((19L))
    // (""xix"")
    // >>> IntToMiniRoman((152L))
    // (""clii"")
    // >>> IntToMiniRoman((426L))
    // (""cdxxvi"")
    public static string IntToMiniRoman(long number) {
","if (number < 1 || number > 1000)
            throw new ArgumentOutOfRangeException(""number"", ""Input must be between 1 and 1000"");

        // Mapping of Roman numerals
        var romanNumerals = new List<(int value, string numeral)>
        {
            (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
            (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
            (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
            (1, ""i"")
        };

        var sb = new StringBuilder();

        foreach (var (value, numeral) in romanNumerals)
        {
            while (number >= value)
            {
                sb.Append(numeral);
                number -= value;
            }
        }

        return sb.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IntToMiniRoman((19L)).Equals((""xix"")));
    Debug.Assert(IntToMiniRoman((152L)).Equals((""clii"")));
    Debug.Assert(IntToMiniRoman((251L)).Equals((""ccli"")));
    Debug.Assert(IntToMiniRoman((426L)).Equals((""cdxxvi"")));
    Debug.Assert(IntToMiniRoman((500L)).Equals((""d"")));
    Debug.Assert(IntToMiniRoman((1L)).Equals((""i"")));
    Debug.Assert(IntToMiniRoman((4L)).Equals((""iv"")));
    Debug.Assert(IntToMiniRoman((43L)).Equals((""xliii"")));
    Debug.Assert(IntToMiniRoman((90L)).Equals((""xc"")));
    Debug.Assert(IntToMiniRoman((94L)).Equals((""xciv"")));
    Debug.Assert(IntToMiniRoman((532L)).Equals((""dxxxii"")));
    Debug.Assert(IntToMiniRoman((900L)).Equals((""cm"")));
    Debug.Assert(IntToMiniRoman((994L)).Equals((""cmxciv"")));
    Debug.Assert(IntToMiniRoman((1000L)).Equals((""m"")));
    }

}
"
HumanEval_157,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //90 دَرَجَةْ    //مُثَلَّثٌ مُسْتَقِيمٌ مُثَلَّثٌ فِيهِ زَاوِيَةٌ مُسْتَقِيمَةٌ أَوْ    //أَوْجَهُ تَشْكُلُ ثَلَاثَةً مُسْتَقِيمَةً، غَيْرَهَا.    //مُعْطَى أَطْوَالِ الْجَانِبَيْنِ الثَّلَاثَةِ مِنْ مُثَلَّثٍ.    // >>> RightAngleTriangle((3L), (4L), (5L))
    // (true)
    // >>> RightAngleTriangle((1L), (2L), (3L))
    // (false)
    public static bool RightAngleTriangle(long a, long b, long c) {
","using System;

class Problem
{
    public static bool RightAngleTriangle(long a, long b, long c)
    {
        // Sort the sides to make it easier to apply the Pythagorean theorem.
        long[] sides = { a, b, c };
        Array.Sort(sides);

        // Check if the sum of the squares of the smaller two sides equals the square of the largest side.
        return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RightAngleTriangle((3L), (4L), (5L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (2L), (3L)) == (false));
    Debug.Assert(RightAngleTriangle((10L), (6L), (8L)) == (true));
    Debug.Assert(RightAngleTriangle((2L), (2L), (2L)) == (false));
    Debug.Assert(RightAngleTriangle((7L), (24L), (25L)) == (true));
    Debug.Assert(RightAngleTriangle((10L), (5L), (7L)) == (false));
    Debug.Assert(RightAngleTriangle((5L), (12L), (13L)) == (true));
    Debug.Assert(RightAngleTriangle((15L), (8L), (17L)) == (true));
    Debug.Assert(RightAngleTriangle((48L), (55L), (73L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (1L), (1L)) == (false));
    Debug.Assert(RightAngleTriangle((2L), (2L), (10L)) == (false));
    }

}
"
HumanEval_158,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //حَرْفَيْنِ، رُدُّوا أَوَّلَ مَنْ يَأْتِي بِهِمَا مِنْ حَرْفِ الْمَجَازِ.    //مِنْ حُرُوفِ فَرَدِيَّةٍ.    //القَائِمَةُ تَتَضَمَّنُ كَلِمَاتٍ مُخْتَلِفَةً.    //اُكْتُبْ دَلِيْلَةً تَقْبَلُ قَائِمَةَ سَلاَلَاتٍ.    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""})))
    // (""string"")
    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""})))
    // (""enam"")
    // >>> FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""})))
    // (""aaaaaaa"")
    public static string FindMax(List<string> words) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string FindMax(List<string> words)
    {
        string result = string.Empty;
        int maxUniqueChars = 0;

        foreach (var word in words)
        {
            var uniqueChars = word.ToCharArray().Distinct().Count();

            if (uniqueChars > maxUniqueChars || (uniqueChars == maxUniqueChars && string.Compare(word, result, StringComparison.Ordinal) < 0))
            {
                maxUniqueChars = uniqueChars;
                result = word;
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""}))).Equals((""string"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""}))).Equals((""enam"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""}))).Equals((""aaaaaaa"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""abc"", (string)""cba""}))).Equals((""abc"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""this"", (string)""game"", (string)""of"", (string)""footbott""}))).Equals((""footbott"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""gonna"", (string)""rock""}))).Equals((""gonna"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""a"", (string)""mad"", (string)""nation""}))).Equals((""nation"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""this"", (string)""is"", (string)""a"", (string)""prrk""}))).Equals((""this"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""b""}))).Equals((""b"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""play"", (string)""play""}))).Equals((""play"")));
    }

}
"
HumanEval_159,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مَثَل:    //إِنْ لَمْ يَكُنْ بَاقِيَ بَعْضُ الجَوْزِ، فَسَتَأْكُلُ كُلَّ الجَوْزِ، وَسَتَظْلُمُ الجُوعَ.    //عَدَدَ الجَوْزِ بَاقٍ بَعْدَ وَجْعِكَ]     //يَجِبُ أَنْ تَرُدَّ قِيمَةَ [الْجَمِيعِ مِنْ الجُزُورِ الْمَأْكُولَةِ بَعْدَ وَقْتِ الْأَكْلِ،     //لَكِنَّكِ الآنَ تَحتاجينَ أَكْلَ المزيد مِنْ الجَزرِ لِكَمْلِ وَجباتِ اليومِ.    //أَنْتَ أَرْنَبٌ جَائِعٌ، وَقَدْ أَكَلْتَ عَدَدًا مُعَيَّنًا مِنَ الجَوْزِ،    // >>> Eat((5L), (6L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)4L}))
    // >>> Eat((4L), (8L), (9L))
    // (new List<long>(new long[]{(long)12L, (long)1L}))
    // >>> Eat((1L), (10L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)0L}))
    // >>> Eat((2L), (11L), (5L))
    // (new List<long>(new long[]{(long)7L, (long)0L}))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    public static List<long> Eat(long number, long need, long remaining) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Eat(long number, long need, long remaining) {
        long totalEaten = number;
        long leftAfterMeals;

        if(remaining >= need) {
            totalEaten += need;
            leftAfterMeals = remaining - need;
        } else {
            totalEaten += remaining;
            leftAfterMeals = 0;
        }
        
        return new List<long>{ totalEaten, leftAfterMeals };
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Eat((5L), (6L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)4L}))));
    Debug.Assert(Eat((4L), (8L), (9L)).Equals((new List<long>(new long[]{(long)12L, (long)1L}))));
    Debug.Assert(Eat((1L), (10L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)0L}))));
    Debug.Assert(Eat((2L), (11L), (5L)).Equals((new List<long>(new long[]{(long)7L, (long)0L}))));
    Debug.Assert(Eat((4L), (5L), (7L)).Equals((new List<long>(new long[]{(long)9L, (long)2L}))));
    Debug.Assert(Eat((4L), (5L), (1L)).Equals((new List<long>(new long[]{(long)5L, (long)0L}))));
    }

}
"
HumanEval_160,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //لِسْمِ الْمُشَارِكِ عِنْدَهُ مُشَارِكٌ وَاحِدٌ، وَلِسْمِ الْمُشَارِكِ عِنْدَهُ مُشَارِكَانِ.    //أُوبِرَانْدْ هِيَ قِيَامَةٌ مِنْ أَعْدَادِ الْكُلِّيَّاتِ الْغَيْرِ السَّالبَةِ.    //طُولُ لِسَانِ الْمُشَارِكِ سَوَاءٌ بِطُولِ لِسَانِ الْعَامِلِ دُونَ وَاحِدٍ.    //تَذْكِرَة:    //=> نَتِيجَةٌ = 9     //النَّتِيجَةُ = 2 + 3 * 4 - 5     //لَيْسَ لَهُمْ أَيْضًا    //مُشَغِّلُ['+', '*', '-']     //مَثَل:    //تَعَدُّدُ (**)     //تَقْسِيمُ الطَّبَقَةِ (//)    //ضِعْفُ (*)     //خَفْضُ ( - )     //إضافَةٌ (+)     //العمليات الجبرية الأساسية:  كَمْ مِنْ مَعْنَى    //وَيَرْجِعُ بِتَقْدِيرِ هَذَا الْعِبَارَةِ.    //وَالْقَائِمَةُ الثَّانِيَةُ قِيَامُ أَعْدَادٍ. أَسْتَعْمِلُ الْقَائِمَتَيْنِ لِتَبْنِيَ الجِبْرِيَّةَ.    //مَعْطُوفَةٌ بِفَتْحَتَيْنِ، وَمُشَغِّلَةٍ.    public static long DoAlgebra(List<string> op, List<long> operand) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long DoAlgebra(List<string> op, List<long> operand)
    {
        if (op.Count + 1 != operand.Count || operand.Count < 2)
        {
            throw new ArgumentException(""Invalid input lists."");
        }

        long result = operand[0];

        for (int i = 0; i < op.Count; i++)
        {
            string currentOp = op[i];
            long currentOperand = operand[i + 1];

            switch (currentOp)
            {
                case ""+"":
                    result += currentOperand;
                    break;
                case ""-"":
                    result -= currentOperand;
                    break;
                case ""*"":
                    result *= currentOperand;
                    break;
                case ""//"":
                    result /= currentOperand;
                    break;
                case ""**"":
                    result = (long)Math.Pow(result, currentOperand);
                    break;
                default:
                    throw new InvalidOperationException($""Unsupported operator: {currentOp}"");
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""**"", (string)""*"", (string)""+""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (37L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""+"", (string)""*"", (string)""-""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (9L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""//"", (string)""*""})), (new List<long>(new long[]{(long)7L, (long)3L, (long)4L}))) == (8L));
    }

}
"
HumanEval_161,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //أمثلة     //تَجِبُ أَنْ تَرُدَّ الدَّلِيلَةَ السَّلَالَةَ النَّاتِجَةَ.    //إِنْ لَمْ تَكُنْ فِي السِّلْسِلَةِ حُرُوفٌ، فَعَكِّسِ السِّلْسِلَةَ.    //وإلاّ فَإِبْقَاهَا كَمَا هِيَ.    //إِنْ كَانَتْ حَرْفَةً، فَعَكْسُهَا مِنْ أَسْفَلِهَا إِلَى أَعْلَى أَوْ عَكْسُهَا،    //تُعْطَى سِلْسِلَةٌ s.    // >>> Solve((""1234""))
    // (""4321"")
    // >>> Solve((""ab""))
    // (""AB"")
    // >>> Solve((""#a@C""))
    // (""#A@c"")
    public static string Solve(string s) {
","public static string Solve(string s) {
        bool hasLetter = s.Any(char.IsLetter);
        if (hasLetter) {
            var result = new StringBuilder(s.Length);
            foreach (char c in s) {
                if (char.IsLetter(c)) {
                    result.Append(char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c));
                } else {
                    result.Append(c);
                }
            }
            return result.ToString();
        } else {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((""AsDf"")).Equals((""aSdF"")));
    Debug.Assert(Solve((""1234"")).Equals((""4321"")));
    Debug.Assert(Solve((""ab"")).Equals((""AB"")));
    Debug.Assert(Solve((""#a@C"")).Equals((""#A@c"")));
    Debug.Assert(Solve((""#AsdfW^45"")).Equals((""#aSDFw^45"")));
    Debug.Assert(Solve((""#6@2"")).Equals((""2@6#"")));
    Debug.Assert(Solve((""#$a^D"")).Equals((""#$A^d"")));
    Debug.Assert(Solve((""#ccc"")).Equals((""#CCC"")));
    }

}
"
HumanEval_162,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //إِنْ كَانَ 'text' خَطّ فَارِغ، رُدّ null.     //مُعْطَى سِلْطَة 'text', رُدَّ سِلْطَتَهَا مُسَاوِيَةَ الْمَخْتَلَطِ md5.    // >>> StringToMd5((""Hello world""))
    // (""3e25960a79dbc69b674cd4ec67a72c62"")
    public static string StringToMd5(string text) {
","using System;
using System.Security.Cryptography;
using System.Text;

class Problem {
    public static string StringToMd5(string text) {
        if (string.IsNullOrEmpty(text)) {
            return null;
        }
        
        using (MD5 md5 = MD5.Create()) {
            byte[] inputBytes = Encoding.UTF8.GetBytes(text);
            byte[] hashBytes = md5.ComputeHash(inputBytes);
            
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < hashBytes.Length; i++) {
                sb.Append(hashBytes[i].ToString(""x2""));
            }
            return sb.ToString();
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringToMd5((""Hello world"")).Equals((""3e25960a79dbc69b674cd4ec67a72c62"")));
    Debug.Assert(StringToMd5(("""")).Equals(null));
    Debug.Assert(StringToMd5((""A B C"")).Equals((""0ef78513b0cb8cef12743f5aeb35f888"")));
    Debug.Assert(StringToMd5((""password"")).Equals((""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,knc_Arab,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //مِثَالًا:    //وَبَ، بِالتَّرْتِيبِ الصَّاعِدِ.    //مَنْ أَنْصَتَيْنِ مُوجِبَيْنِ أَوْ بَيْنَهُمَا، رُدَّ أَوْجَهَيْنِ مُجَرَّدَيْنِ    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    public static List<long> GenerateIntegers(long a, long b) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Given two positive integers a and b, return the even digits between a
    // and b, in ascending order.
    // For example:
    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    
    public static List<long> GenerateIntegers(long a, long b)
    {
        List<long> evenDigits = new List<long> { 2, 4, 6, 8 };
        List<long> result = new List<long>();

        if (a > b)
        {
            // Swap values if a is greater than b to ensure ascending order
            long temp = a;
            a = b;
            b = temp;
        }

        foreach (var even in evenDigits)
        {
            if (even >= a && even <= b)
            {
                result.Add(even);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GenerateIntegers((2L), (10L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((10L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((132L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((17L), (89L)).Equals((new List<long>())));
    }

}
"
