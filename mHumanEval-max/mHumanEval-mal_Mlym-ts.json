[{"task_id":"HumanEval_0","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു നിശ്ചിത തുക.\/\/ എന്നതിനേക്കാൾ അടുത്തുള്ള സംഖ്യകളുണ്ടോ എന്ന് പരിശോധിക്കുക.\/\/ >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/ true\nfunction has_close_elements(numbers: number[], threshold: number): boolean {\n","canonical_solution":"function has_close_elements(numbers: number[], threshold: number): boolean {\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = i + 1; j < numbers.length; j++) {\n            if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = has_close_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);\n}\n\ntest();"},{"task_id":"HumanEval_1","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഇൻപുട്ട് സ്ട്രിങ്ങിലെ സ്പെയ്സുകളെ അവഗണിക്കുക.\/\/പ്രത്യേക ഗ്രൂപ്പുകള് സന്തുലിതമാണ് (ഓരോ തുറന്ന ബ്രേസും ശരിയായി അടച്ചിരിക്കുന്നു) പരസ്പരം കൂടിച്ചേർന്നിട്ടില്ല.\/\/ആ ഗ്രൂപ്പുകളെ പ്രത്യേക സ്ട്രിങ്ങുകളാക്കി വേർതിരിച്ച് അവയുടെ അറേ തിരികെ നൽകുക.\/\/ഈ ഫങ്ഷന് നല് കുന്ന ഇൻപുട്ട് ഒരു സ്ട്രിംഗ് ആണ്, അതിൽ ഒന്നിലധികം കൂട്ടം നെസ്റ്റഡ് പരാൻതീസിസ് അടങ്ങിയിരിക്കുന്നു. നിങ്ങളുടെ ലക്ഷ്യം \/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n","canonical_solution":"function separate_paren_groups(paren_string: string): string[] {\n    const result: string[] = [];\n    let currentGroup: string = \"\";\n    let balance: number = 0;\n\n    for (let char of paren_string) {\n        if (char === ' ') {\n            continue; \/\/ Ignore spaces\n        }\n        \n        currentGroup += char;\n\n        if (char === '(') {\n            balance++;\n        } else if (char === ')') {\n            balance--;\n        }\n\n        if (balance === 0 && currentGroup.length > 0) {\n            result.push(currentGroup);\n            currentGroup = \"\";\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();"},{"task_id":"HumanEval_2","nl":"mal_Mlym","pl":"ts","prompt":"\/\/സംഖ്യയുടെ ദശാംശ ഭാഗം തിരികെ നൽകുക.\/\/(അവശേഷിക്കുന്ന ഭാഗം എല്ലായ്പ്പോഴും 1 ന് താഴെയാണ്).\/\/യും ഇന്റര് ഭാഗവും (നൽകിയ സംഖ്യയേക്കാൾ ചെറുതാണ് ഏറ്റവും വലിയ ഇന്റര്) ദശാംശവും\/\/ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് നമ്പർ കൊടുത്താൽ, അതിനെ  ആയി വിഭജിക്കാം.\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunction truncate_number(number: number): number {\n","canonical_solution":"function truncate_number(number: number): number {\n    const integerPart = Math.floor(number);\n    return number - integerPart;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = truncate_number;\n  assert.deepEqual(candidate(3.5),0.5);\n  assert.deepEqual(candidate(1.25),0.25);\n  assert.deepEqual(candidate(123.0),0.0);\n}\n\ntest();"},{"task_id":"HumanEval_3","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ആ ഘട്ടത്തിൽ ഫംഗ്ഷൻ true ആയി തിരിച്ചു വരും. അല്ലാത്തപക്ഷം false ആയി തിരിച്ചു വരും.\/\/നിങ്ങളുടെ ജോലി അക്കൌണ്ട് ബാലൻസ് പൂജ്യത്തിന് താഴെയായി എന്ന് കണ്ടെത്തുക എന്നതാണ്.\/\/ഒരു ബാങ്ക് അക്കൌണ്ടിൽ നിക്ഷേപവും പിൻവലിക്കലും നടത്താനുള്ള ഒരു നിര പ്രവർത്തനങ്ങൾ നിങ്ങൾക്ക് ലഭിക്കുന്നു, അത് തുടങ്ങുന്നത് \/\/ >>> below_zero([1, 2, 3])\n\/\/ false\n\/\/ >>> below_zero([1, 2, -4, 5])\n\/\/ true\nfunction below_zero(operations: number[]): boolean {\n","canonical_solution":"function below_zero(operations: number[]): boolean {\n    let balance = 0;\n    \n    for (let operation of operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = below_zero;\n  assert.deepEqual(candidate([]),false);\n  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);\n  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);\n  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);\n  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);\n  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);\n}\n\ntest();"},{"task_id":"HumanEval_4","nl":"mal_Mlym","pl":"ts","prompt":"\/\/MAD = ശരാശരി. x - x_mean. \/\/ഒരു ഘടകവും ഒരു കേന്ദ്രബിന്ദുവും (ഈ കേസിൽ ശരാശരി):\/\/ശരാശരി അബ്സലൂട്ട് ഡീവിയേഷൻ എന്നത് ഓരോ യും തമ്മിലുള്ള ശരാശരി അബ്സലൂട്ട് വ്യത്യാസമാണ്.\/\/ഈ ഡാറ്റാ സെറ്റിന്റെ ശരാശരിയിൽ.\/\/ഒരു നിശ്ചിത അറേ ഇൻപുട്ട് നമ്പറുകള് ക്ക്, ശരാശരി കേവല വ്യതിയാനം കണക്കുകൂട്ടുക.\/\/ >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n\/\/ 1.0\nfunction mean_absolute_deviation(numbers: number[]): number {\n","canonical_solution":"function mean_absolute_deviation(numbers: number[]): number {\n    const mean = numbers.reduce((acc, num) => acc + num, 0) \/ numbers.length;\n    const absoluteDifferences = numbers.map(num => Math.abs(num - mean));\n    const mad = absoluteDifferences.reduce((acc, diff) => acc + diff, 0) \/ numbers.length;\n    return mad;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = mean_absolute_deviation;\n  assert.deepEqual(candidate([1.0, 2.0]),0.5);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);\n}\n\ntest();"},{"task_id":"HumanEval_5","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഓരോ രണ്ട് തുടർച്ചയായ ഘടകങ്ങൾ തമ്മിലും ഒരു 'ഡിലിമിറ്റർ' ചേർക്കുക.\/\/ >>> intersperse([], 4)\n\/\/ []\n\/\/ >>> intersperse([1, 2, 3], 4)\n\/\/ [1, 4, 2, 4, 3]\nfunction intersperse(numbers: number[], delimeter: number): number[] {\n","canonical_solution":"function intersperse(numbers: number[], delimeter: number): number[] {\n    if (numbers.length === 0) {\n        return [];\n    }\n\n    let result: number[] = [];\n\n    for (let i = 0; i < numbers.length; i++) {\n        result.push(numbers[i]);\n        if (i < numbers.length - 1) {\n            result.push(delimeter);\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = intersperse;\n  assert.deepEqual(candidate([], 7),[]);\n  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);\n  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);\n}\n\ntest();"},{"task_id":"HumanEval_6","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്, (() (()) ന് പരമാവധി രണ്ട് നെസ്റ്റിംഗ് ലെവലുകൾ ഉണ്ട്, അതേസമയം ((())) ന് മൂന്ന് ഉണ്ട്. \/\/ഓരോ ഗ്രൂപ്പിനും പരേതന്മാരുടെ ഏറ്റവും ആഴത്തിലുള്ള തലത്തിലുള്ള നെസ്റ്റിംഗ് നൽകുക.\/\/ഈ ഫങ്ഷന് ഒരു സ്ട്രിംഗ് ആണ്. സ്പെയ്സുകളാൽ വേർതിരിക്കപ്പെട്ട, കൂട്ടിയിണക്കിയ പരാൻതീസിനു വേണ്ടി ഒന്നിലധികം ഗ്രൂപ്പുകളെ പ്രതിനിധീകരിക്കുന്നു.\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string: string): number[] {\n","canonical_solution":"function parse_nested_parens(paren_string: string): number[] {\n    return paren_string.split(' ').map(group => {\n        let maxDepth = 0;\n        let currentDepth = 0;\n\n        for (const char of group) {\n            if (char === '(') {\n                currentDepth++;\n                if (currentDepth > maxDepth) {\n                    maxDepth = currentDepth;\n                }\n            } else if (char === ')') {\n                currentDepth--;\n            }\n        }\n\n        return maxDepth;\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1, 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"},{"task_id":"HumanEval_7","nl":"mal_Mlym","pl":"ts","prompt":"\/\/സ്ട്രിങ്ങുകളുടെ ഒരു ഇൻപുട്ട് അറേ ഫിൽട്ടർ ചെയ്യുക, അതിൽ സബ്സ്ട്രിങ് അടങ്ങിയിരിക്കുന്നവ മാത്രം ഫിൽട്ടർ ചെയ്യുക.\/\/ >>> filter_by_substring([], \"a\")\n\/\/ []\n\/\/ >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n\/\/ [\"abc\", \"bacd\", \"array\"]\nfunction filter_by_substring(strings: string[], substring: string): string[] {\n","canonical_solution":"function filter_by_substring(strings: string[], substring: string): string[] {\n    return strings.filter(s => s.includes(substring));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_by_substring;\n  assert.deepEqual(candidate([], \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"),[\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"),[\"grunt\", \"prune\"]);\n}\n\ntest();"},{"task_id":"HumanEval_8","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ശൂന്യ സംഖ്യ 0 ഉം ശൂന്യ ഉൽപ്പന്നം 1 ഉം ആയിരിക്കണം.\/\/ഒരു നിശ്ചിത അറേയിലെ എല്ലാ പൂർണ്ണസംഖ്യകളുടെയും സംഖ്യയും ഗുണിതവും അടങ്ങിയ ഒരു അറേ നൽകുക.\/\/ >>> sum_product([])\n\/\/ [0, 1]\n\/\/ >>> sum_product([1, 2, 3, 4])\n\/\/ [10, 24]\nfunction sum_product(numbers: number[]): [number, number] {\n","canonical_solution":"function sum_product(numbers: number[]): [number, number] {\n    const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n    const product = numbers.reduce((acc, curr) => acc * curr, 1);\n    return [sum, product];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_product;\n  assert.deepEqual(candidate([]),[0, 1]);\n  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);\n  assert.deepEqual(candidate([100, 0]),[100, 0]);\n  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);\n  assert.deepEqual(candidate([10]),[10, 10]);\n}\n\ntest();"},{"task_id":"HumanEval_9","nl":"mal_Mlym","pl":"ts","prompt":"\/\/യില് തന്നെ.\/\/ഒരു നിശ്ചിത ശ്രേണിയിൽ നിന്ന്, ഒരു നിശ്ചിത നിമിഷം വരെ കണ്ടെത്തിയ പരമാവധി ഘടകങ്ങളുടെ ഒരു ശ്രേണി സൃഷ്ടിക്കുക.\/\/ >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunction rolling_max(numbers: number[]): number[] {\n","canonical_solution":"function rolling_max(numbers: number[]): number[] {\n    let maxArray: number[] = [];\n    let currentMax: number = Number.NEGATIVE_INFINITY;\n    \n    for (let i = 0; i < numbers.length; i++) {\n        if (numbers[i] > currentMax) {\n            currentMax = numbers[i];\n        }\n        maxArray.push(currentMax);\n    }\n\n    return maxArray;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rolling_max;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);\n  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);\n}\n\ntest();"},{"task_id":"HumanEval_10","nl":"mal_Mlym","pl":"ts","prompt":"\/\/- സ്ട്രിംഗ് റിവേഴ്സ് അവസാനിക്കുന്നതിനു മുമ്പ് ഒരു സ്ട്രിംഗ് പ്രിഫിക്സ് ചേർക്കുക.\/\/- ഒരു പാലിൻഡ്രോം ആയ സ്ട്രിംഗിന്റെ ഏറ്റവും നീളം കൂടിയ പോസ്റ്റ്ഫിക്സ് കണ്ടെത്തുക.\/\/അല് ഗോരിതം ആശയം ലളിതമാണ്:\/\/ഒരു സ്ട്രിങ്ങിൽ തുടങ്ങുന്ന ഏറ്റവും ചെറിയ പാലിൻഡ്രോം കണ്ടെത്തുക.\/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunction make_palindrome(string: string): string {\n","canonical_solution":"function make_palindrome(string: string): string {\n    function isPalindrome(s: string): boolean {\n        let left = 0;\n        let right = s.length - 1;\n        while (left < right) {\n            if (s[left] !== s[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    const n = string.length;\n    let longestPalindromicPostfixIndex = n;\n\n    for (let i = 0; i < n; i++) {\n        if (isPalindrome(string.substring(i))) {\n            longestPalindromicPostfixIndex = i;\n            break;\n        }\n    }\n\n    const prefix = string.substring(0, longestPalindromicPostfixIndex);\n    const reversedPrefix = prefix.split('').reverse().join('');\n    return string + reversedPrefix;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"jerry\"),\"jerryrrej\");\n}\n\ntest();"},{"task_id":"HumanEval_11","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഈ ഇൻപുട്ടുകളിൽ ബൈനറി XOR നടത്തുകയും ഫലം ഒരു സ്ട്രിംഗായി നൽകുകയും ചെയ്യുക.\/\/ഇൻപുട്ട് എന്നത് 1 ഉം 0 ഉം മാത്രമുള്ള a, b എന്നീ രണ്ട് സ്ട്രിങ്ങുകൾ ആണ്.\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunction string_xor(a: string, b: string): string {\n","canonical_solution":"function string_xor(a: string, b: string): string {\n    let result = '';\n    for (let i = 0; i < a.length; i++) {\n        result += (a[i] === b[i] ? '0' : '1');\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_xor;\n  assert.deepEqual(candidate(\"111000\", \"101010\"),\"010010\");\n  assert.deepEqual(candidate(\"1\", \"1\"),\"0\");\n  assert.deepEqual(candidate(\"0101\", \"0000\"),\"0101\");\n}\n\ntest();"},{"task_id":"HumanEval_12","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരേ നീളമുള്ള സ്ട്രിങ്ങുകൾ. ഇൻപുട്ട് അറേ ശൂന്യമാണെങ്കിൽ undefined എന്ന് തിരികെ നൽകുക.\/\/സ്ട്രിങ്ങുകളുടെ ഒരു ശ്രേണിയിൽ നിന്നും ഏറ്റവും നീളം കൂടിയ സ്ട്രിംഗ് തിരികെ നൽകുക. ഒന്നിലധികം സ്ട്രിങ്ങുകൾ ഉണ്ടെങ്കിൽ ആദ്യത്തേത് തിരികെ നൽകുക.\/\/ >>> longest([])\n\/\/ undefined\n\/\/ >>> longest([\"a\", \"b\", \"c\"])\n\/\/ \"a\"\n\/\/ >>> longest([\"a\", \"bb\", \"ccc\"])\n\/\/ \"ccc\"\nfunction longest(strings: string[]): string | undefined {\n","canonical_solution":"function longest(strings: string[]): string | undefined {\n    if (strings.length === 0) {\n        return undefined;\n    }\n\n    let longestString = strings[0];\n\n    for (const str of strings) {\n        if (str.length > longestString.length) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"},{"task_id":"HumanEval_13","nl":"mal_Mlym","pl":"ts","prompt":"\/\/a, b എന്നീ രണ്ടു സംഖ്യകളുടെ ഏറ്റവും വലിയ പൊതുവിഭജനം തിരികെ നല് കുക.\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunction greatest_common_divisor(a: number, b: number): number {\n","canonical_solution":"function greatest_common_divisor(a: number, b: number): number {\n    while (b !== 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = greatest_common_divisor;\n  assert.deepEqual(candidate(3, 7),1);\n  assert.deepEqual(candidate(10, 15),5);\n  assert.deepEqual(candidate(49, 14),7);\n  assert.deepEqual(candidate(144, 60),12);\n}\n\ntest();"},{"task_id":"HumanEval_14","nl":"mal_Mlym","pl":"ts","prompt":"\/\/എല്ലാ പ്രിഫിക്സുകളും ഏറ്റവും ചെറുത് മുതൽ ഏറ്റവും നീളം കൂടിയത് വരെ ഉള്ള ഒരു ശ്രേണി റിട്ടേൺ ചെയ്യുന്നു.\/\/ >>> all_prefixes(\"abc\")\n\/\/ [\"a\", \"ab\", \"abc\"]\nfunction all_prefixes(string: string): string[] {\n","canonical_solution":"function all_prefixes(string: string): string[] {\n    const result: string[] = [];\n    for (let i = 1; i <= string.length; i++) {\n        result.push(string.substring(0, i));\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = all_prefixes;\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"asdfgh\"),[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]);\n  assert.deepEqual(candidate(\"WWW\"),[\"W\", \"WW\", \"WWW\"]);\n}\n\ntest();"},{"task_id":"HumanEval_15","nl":"mal_Mlym","pl":"ts","prompt":"\/\/0 മുതൽ n വരെയുള്ള സംഖ്യകളുടെ ഒരു സ്ട്രിംഗ് നൽകുന്നു.\/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunction string_sequence(n: number): string {\n","canonical_solution":"function string_sequence(n: number): string {\n    let result: string[] = [];\n    for (let i = 0; i <= n; i++) {\n        result.push(i.toString());\n    }\n    return result.join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_sequence;\n  assert.deepEqual(candidate(0),\"0\");\n  assert.deepEqual(candidate(3),\"0 1 2 3\");\n  assert.deepEqual(candidate(10),\"0 1 2 3 4 5 6 7 8 9 10\");\n}\n\ntest();"},{"task_id":"HumanEval_16","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു സ്ട്രിംഗ് തന്നാൽ, എത്ര വ്യത്യസ്ത പ്രതീകങ്ങൾ (കേസ് പരിഗണിക്കാതെ) അതിൽ ഉണ്ടെന്ന് കണ്ടെത്തുക \/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunction count_distinct_characters(string: string): number {\n","canonical_solution":"function count_distinct_characters(inputString: string): number {\n    const lowerCasedString = inputString.toLowerCase();\n    const distinctCharacters = new Set<string>();\n\n    for (const char of lowerCasedString) {\n        distinctCharacters.add(char);\n    }\n\n    return distinctCharacters.size;\n}\n\n\/\/ Example usage:\nconsole.log(count_distinct_characters(\"xyzXYZ\")); \/\/ Output: 3\nconsole.log(count_distinct_characters(\"Jerry\"));  \/\/ Output: 4","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_distinct_characters;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"abcde\"),5);\n  assert.deepEqual(candidate(\"abcdecadeCADE\"),5);\n  assert.deepEqual(candidate(\"aaaaAAAAaaaa\"),1);\n  assert.deepEqual(candidate(\"Jerry jERRY JeRRRY\"),5);\n}\n\ntest();"},{"task_id":"HumanEval_17","nl":"mal_Mlym","pl":"ts","prompt":"\/\/'ഹാച്ചാ' - ഒരു ക്വാർട്ടർ നോട്ട്, ഒരു ബീറ്റ് നീണ്ടുനിൽക്കും.\/\/'ഒ ശെരി' - പാതി നോട്ട്, രണ്ടു ബീറ്റ് നീണ്ടുനിൽക്കും.\/\/'ഒ' - മുഴുവൻ നോട്ടും, നാലു താളം നീണ്ടുനിൽക്കും.\/\/ഇതാ ഒരു ഇതിഹാസം:\/\/അവസാനത്തേത് അല്ല.\/\/നിങ്ങളുടെ ജോലി ഈ സ്ട്രിംഗ് പാഴ്സ് ചെയ്ത് ഓരോന്നും എത്ര തവണ ആവർത്തിക്കുന്നു എന്നതിന് തുല്യമായ സംഖ്യകളുടെ ഒരു ശ്രേണി തിരികെ നൽകുക എന്നതാണ്.\/\/ഈ ഫങ്ഷന് ഒരു പ്രത്യേക ASCII ഫോർമാറ്റിലുള്ള സംഗീത കുറിപ്പുകളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് ആണ്.\/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunction parse_music(music_string: string): number[] {\n","canonical_solution":"function parse_music(music_string: string): number[] {\n    const notes = music_string.split(' ');\n    return notes.map(note => {\n        switch (note) {\n            case 'o':\n                return 4;\n            case 'o|':\n                return 2;\n            case '.|':\n                return 1;\n            default:\n                return 0;\n        }\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = parse_music;\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"o o o o\"),[4, 4, 4, 4]);\n  assert.deepEqual(candidate(\".| .| .| .|\"),[1, 1, 1, 1]);\n  assert.deepEqual(candidate(\"o| o| .| .| o o o o\"),[2, 2, 1, 1, 4, 4, 4, 4]);\n  assert.deepEqual(candidate(\"o| .| o| .| o o| o o|\"),[2, 1, 2, 1, 4, 2, 4, 2]);\n}\n\ntest();"},{"task_id":"HumanEval_18","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു സബ് സ്ട്രിംഗ് എത്ര തവണ ഒറിജിനൽ സ്ട്രിംഗിൽ കാണാനാകും എന്ന് കണ്ടെത്തുക.\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunction how_many_times(string: string, substring: string): number {\n","canonical_solution":"function how_many_times(string: string, substring: string): number {\n    if (substring.length === 0) return 0;\n    let count = 0;\n    for (let i = 0; i <= string.length - substring.length; i++) {\n        if (string.substring(i, i + substring.length) === substring) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\/\/ Example usage:\n\/\/ console.log(how_many_times(\"aaa\", \"a\")); \/\/ Output: 3\n\/\/ console.log(how_many_times(\"aaaa\", \"aa\")); \/\/ Output: 3\n\/\/ console.log(how_many_times(\"\", \"a\")); \/\/ Output: 0","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = how_many_times;\n  assert.deepEqual(candidate(\"\", \"x\"),0);\n  assert.deepEqual(candidate(\"xyxyxyx\", \"x\"),4);\n  assert.deepEqual(candidate(\"cacacacac\", \"cac\"),4);\n  assert.deepEqual(candidate(\"john doe\", \"john\"),1);\n}\n\ntest();"},{"task_id":"HumanEval_19","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഏറ്റവും ചെറിയ സംഖ്യ മുതൽ ഏറ്റവും വലിയ സംഖ്യ വരെ ക്രമീകരിച്ചിരിക്കുന്ന സ്ട്രിംഗ് തിരികെ നൽകുന്നു.\/\/സാധുവായ തിരഞ്ഞെടുപ്പുകൾ 'പൂജ്യം', 'ഒന്ന്', 'രണ്ട്', 'മൂന്ന്', 'നാല്', 'അഞ്ച്', 'ആറ്', 'ഏഴ്', 'എട്ട്' എന്നിവയാണ്.  എട്ട്, ഒമ്പത് എന്നിങ്ങനെ നിരവധി പേരുകൾ ഇതിൽ ഉൾപ്പെടുന്നു.\/\/'0' മുതൽ '9' വരെയുള്ള സംഖ്യകളുടെ ഒരു സ്പേസ് ഡെലിമെന്റ് ചെയ്ത സ്ട്രിംഗ് ആണ് ഇൻപുട്ട്.\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunction sort_numbers(numbers: string): string {\n","canonical_solution":"function sort_numbers(numbers: string): string {\n    const numberWords = [\n        'zero', 'one', 'two', 'three', 'four', \n        'five', 'six', 'seven', 'eight', 'nine'\n    ];\n    \n    \/\/ Split the input string into an array of words\n    const wordsArray = numbers.split(' ');\n\n    \/\/ Sort the wordsArray based on the index of each word in numberWords\n    wordsArray.sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b));\n\n    \/\/ Join the sorted array back into a space-delimited string and return\n    return wordsArray.join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_numbers;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"three\"),\"three\");\n  assert.deepEqual(candidate(\"three five nine\"),\"three five nine\");\n  assert.deepEqual(candidate(\"five zero four seven nine eight\"),\"zero four five seven eight nine\");\n  assert.deepEqual(candidate(\"six five four three two one zero\"),\"zero one two three four five six\");\n}\n\ntest();"},{"task_id":"HumanEval_20","nl":"mal_Mlym","pl":"ts","prompt":"\/\/മറ്റു് നമ്പറുകള് ക്രമം അനുസരിച്ച് തിരിച്ചു് തരിക (കുറഞ്ഞ എണ്ണം, വലിയ എണ്ണം).\/\/ഒരു സംഖ്യാ ശ്രേണിയിൽ നിന്നും (കുറഞ്ഞത് രണ്ടെണ്ണം) ഓരോന്നിനും ഏറ്റവും അടുത്തുള്ള രണ്ടെണ്ണം തെരഞ്ഞെടുത്ത് തിരികെ നൽകുക \/\/ >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/ [2.0, 2.2]\n\/\/ >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/ [2.0, 2.0]\nfunction find_closest_elements(numbers: number[]): [number, number] {\n","canonical_solution":"function find_closest_elements(numbers: number[]): [number, number] {\n    if (numbers.length < 2) {\n        throw new Error(\"Array must contain at least two numbers\");\n    }\n\n    \/\/ Sort the array so that we can check consecutive elements\n    numbers.sort((a, b) => a - b);\n\n    let closestPair: [number, number] = [numbers[0], numbers[1]];\n    let minDifference = Math.abs(numbers[1] - numbers[0]);\n\n    for (let i = 1; i < numbers.length - 1; i++) {\n        let currentDifference = Math.abs(numbers[i + 1] - numbers[i]);\n        if (currentDifference < minDifference) {\n            minDifference = currentDifference;\n            closestPair = [numbers[i], numbers[i + 1]];\n        }\n    }\n\n    return closestPair;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = find_closest_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);\n}\n\ntest();"},{"task_id":"HumanEval_21","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഏറ്റവും ചെറിയ സംഖ്യ 0 ആയിത്തീരും, ഏറ്റവും വലിയ സംഖ്യ 1 ആയിത്തീരും.\/\/ഒരു സംഖ്യകളുടെ അറേ (കുറഞ്ഞത് രണ്ട് മൂലകങ്ങളുടെ), ആ അറേയിൽ ഒരു ലീനിയർ ട്രാൻസ്ഫോർമേഷൻ പ്രയോഗിക്കുക, \/\/ >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunction rescale_to_unit(numbers: number[]): number[] {\n","canonical_solution":"function rescale_to_unit(numbers: number[]): number[] {\n    if (numbers.length < 2) {\n        throw new Error(\"Array must contain at least two elements\");\n    }\n\n    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n    const range = max - min;\n\n    if (range === 0) {\n        throw new Error(\"All numbers are the same; rescale not possible\");\n    }\n\n    return numbers.map(num => (num - min) \/ range);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rescale_to_unit;\n  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);\n  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);\n  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);\n  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n\ntest();"},{"task_id":"HumanEval_22","nl":"mal_Mlym","pl":"ts","prompt":"\/\/്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്്\/\/ >>> filter_integers([\"a\", 3.14, 5])\n\/\/ [5]\n\/\/ >>> filter_integers([1, 2, 3, \"abc\", {}, []])\n\/\/ [1, 2, 3]\nfunction filter_integers(values: any[]): number[] {\n","canonical_solution":"function filter_integers(values: any[]): number[] {\n    return values.filter(value => Number.isInteger(value));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_integers;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([4, {}, [], 23.2, 9, \"adasd\"]),[4, 9]);\n  assert.deepEqual(candidate([3, \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_23","nl":"mal_Mlym","pl":"ts","prompt":"\/\/തന്നിരിക്കുന്ന സ്ട്രിങ്ങിന്റെ നീളം തിരികെ നൽകുക \/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunction strlen(string: string): number {\n","canonical_solution":"function strlen(string: string): number {\n    return string.length;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = strlen;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"x\"),1);\n  assert.deepEqual(candidate(\"asdasnakj\"),9);\n}\n\ntest();"},{"task_id":"HumanEval_24","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു നിശ്ചിത സംഖ്യ n ന്, n നെ തുല്യമായി വിഭജിക്കുന്ന ഏറ്റവും വലിയ സംഖ്യ കണ്ടെത്തുക, n യിൽ ചെറുത് \/\/ >>> largest_divisor(15)\n\/\/ 5\nfunction largest_divisor(n: number): number {\n","canonical_solution":"function largest_divisor(n: number): number {\n    for (let i = n - 1; i > 0; i--) {\n        if (n % i === 0) {\n            return i;\n        }\n    }\n    return 1; \/\/ By mathematical definition, 1 is a divisor of any integer.\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_divisor;\n  assert.deepEqual(candidate(3),1);\n  assert.deepEqual(candidate(7),1);\n  assert.deepEqual(candidate(10),5);\n  assert.deepEqual(candidate(100),50);\n  assert.deepEqual(candidate(49),7);\n}\n\ntest();"},{"task_id":"HumanEval_25","nl":"mal_Mlym","pl":"ts","prompt":"\/\/എല്ലാ ഘടകങ്ങളുടെയും ഗുണനത്തിന് തുല്യമാണ് ഈ സംഖ്യ.\/\/ഓരോ ഘടകങ്ങളും ഘടകവൽക്കരണത്തിൽ എത്ര തവണ പ്രത്യക്ഷപ്പെടുന്നു എന്നതിന് അനുസൃതമായി എത്ര തവണ അറേ ചെയ്യണം.\/\/ഒരു നിശ്ചിത സംഖ്യയുടെ പ്രൈം ഫാക്ടറുകളുടെ ശ്രേണി ഏറ്റവും ചെറിയതിൽ നിന്ന് ഏറ്റവും വലിയതിലേക്ക് ക്രമത്തിൽ നൽകുന്നു.\/\/ >>> factorize(8)\n\/\/ [2, 2, 2]\n\/\/ >>> factorize(25)\n\/\/ [5, 5]\n\/\/ >>> factorize(70)\n\/\/ [2, 5, 7]\nfunction factorize(n: number): number[] {\n","canonical_solution":"function factorize(n: number): number[] {\n    const factors: number[] = [];\n    let divisor = 2;\n    \n    while (n >= 2) {\n        if (n % divisor === 0) {\n            factors.push(divisor);\n            n \/= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    return factors;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_26","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഘടകങ്ങളുടെ ക്രമം ഇൻപുട്ടിൽ ഉള്ളതു പോലെ തന്നെ നിലനിർത്തുക.\/\/ഒരു അറേയിൽ നിന്നും ഒന്നിലധികം തവണ വരുന്ന എല്ലാ എലമെന്റുകളും നീക്കം ചെയ്യുക.\/\/ >>> remove_duplicates([1, 2, 3, 2, 4])\n\/\/ [1, 3, 4]\nfunction remove_duplicates(numbers: number[]): number[] {\n","canonical_solution":"function remove_duplicates(numbers: number[]): number[] {\n    const frequencyMap: Map<number, number> = new Map();\n\n    \/\/ Count the occurrences of each number\n    for (const num of numbers) {\n        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);\n    }\n\n    \/\/ Filter out the numbers occurring more than once\n    return numbers.filter(num => frequencyMap.get(num) === 1);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = remove_duplicates;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);\n}\n\ntest();"},{"task_id":"HumanEval_27","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു സ്ട്രിങിന്, ചെറിയ അക്ഷരങ്ങളെ വലിയ അക്ഷരങ്ങളാക്കി മാറ്റുക.\/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunction flip_case(string: string): string {\n","canonical_solution":"function flip_case(str: string): string {\n    let flipped = '';\n    for (let char of str) {\n        if (char === char.toUpperCase()) {\n            flipped += char.toLowerCase();\n        } else {\n            flipped += char.toUpperCase();\n        }\n    }\n    return flipped;\n}\n\n\/\/ Example usage:\nconsole.log(flip_case(\"Hello\")); \/\/ Output: \"hELLO\"","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = flip_case;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"Hello!\"),\"hELLO!\");\n  assert.deepEqual(candidate(\"These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n\ntest();"},{"task_id":"HumanEval_28","nl":"mal_Mlym","pl":"ts","prompt":"\/\/സ്ട്രിങ്ങുകളുടെ ഒരു ശ്രേണി ഒരൊറ്റ സ്ട്രിങ്ങിലേക്ക് കൂട്ടിച്ചേർക്കുക \/\/ >>> concatenate([])\n\/\/ \"\"\n\/\/ >>> concatenate([\"a\", \"b\", \"c\"])\n\/\/ \"abc\"\nfunction concatenate(strings: string[]): string {\n","canonical_solution":"function concatenate(strings: string[]): string {\n    return strings.join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = concatenate;\n  assert.deepEqual(candidate([]),\"\");\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"xyz\");\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\", \"w\", \"k\"]),\"xyzwk\");\n}\n\ntest();"},{"task_id":"HumanEval_29","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു നിശ്ചിത പ്രിഫിക്സ് ഉപയോഗിച്ച് തുടങ്ങുന്ന സ്ട്രിങ്ങുകൾ മാത്രം ഇൻപുട്ട് അറേ ഫിൽട്ടർ ചെയ്യുക.\/\/ >>> filter_by_prefix([], \"a\")\n\/\/ []\n\/\/ >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n\/\/ [\"abc\", \"array\"]\nfunction filter_by_prefix(strings: string[], prefix: string): string[] {\n","canonical_solution":"function filter_by_prefix(strings: string[], prefix: string): string[] {\n    return strings.filter(str => str.startsWith(prefix));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_by_prefix;\n  assert.deepEqual(candidate([], \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\n\ntest();"},{"task_id":"HumanEval_30","nl":"mal_Mlym","pl":"ts","prompt":"\/\/അറേയിലെ പോസിറ്റീവ് നമ്പറുകൾ മാത്രം റിട്ടേൺ ചെയ്യുന്നു.\/\/ >>> get_positive([-1, 2, -4, 5, 6])\n\/\/ [2, 5, 6]\n\/\/ >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunction get_positive(l: number[]): number[] {\n","canonical_solution":"function get_positive(l: number[]): number[] {\n    return l.filter(num => num > 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_positive;\n  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);\n  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);\n  assert.deepEqual(candidate([-1, -2]),[]);\n  assert.deepEqual(candidate([]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_31","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു നിശ്ചിത സംഖ്യ പ്രൈം ആണെങ്കിൽ ശരി, അല്ലെങ്കിൽ തെറ്റായത് എന്ന് റിട്ടേൺ ചെയ്യുക.\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunction is_prime(n: number): boolean {\n","canonical_solution":"function is_prime(n: number): boolean {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    }\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_prime;\n  assert.deepEqual(candidate(6),false);\n  assert.deepEqual(candidate(101),true);\n  assert.deepEqual(candidate(11),true);\n  assert.deepEqual(candidate(13441),true);\n  assert.deepEqual(candidate(61),true);\n  assert.deepEqual(candidate(4),false);\n  assert.deepEqual(candidate(1),false);\n  assert.deepEqual(candidate(5),true);\n  assert.deepEqual(candidate(11),true);\n  assert.deepEqual(candidate(17),true);\n  assert.deepEqual(candidate(85),false);\n  assert.deepEqual(candidate(77),false);\n  assert.deepEqual(candidate(255379),false);\n}\n\ntest();"},{"task_id":"HumanEval_33","nl":"mal_Mlym","pl":"ts","prompt":"\/\/l എന്നതിന്റെ അനുബന്ധ സൂചികകളുടെ മൂല്യങ്ങളുമായി താരതമ്യം ചെയ്യുമ്പോൾ, അവയെ തരം തിരിക്കുക.\/\/l' എന്നത് l ന് തുല്യമാണ്, അത് മൂന്നിൽ ഹരിക്കാത്ത സൂചികകളിൽ, അതിന്റെ മൂല്യങ്ങൾ മൂന്നിൽ ഹരിക്കാവുന്ന സൂചികകളിൽ തുല്യമാണ്.\/\/ഈ ഫങ്ഷൻ ഒരു അറേ l എടുക്കുകയും ഒരു അറേ l' തിരിച്ചുനൽകുകയും ചെയ്യുന്നു.\/\/ >>> sort_third([1, 2, 3])\n\/\/ [1, 2, 3]\n\/\/ >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunction sort_third(l: number[]): number[] {\n","canonical_solution":"function sort_third(l: number[]): number[] {\n    const indicesDivByThree = l.map((_, i) => i).filter(i => i % 3 === 0);\n    const valuesDivByThree = indicesDivByThree.map(i => l[i]).sort((a, b) => a - b);\n\n    const result = l.slice();\n    for (let i = 0; i < indicesDivByThree.length; i++) {\n        result[indicesDivByThree[i]] = valuesDivByThree[i];\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_third;\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);\n  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);\n  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_34","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു അറേയില് തരം തിരിക്കപ്പെട്ട അദ്വിതീയ ഘടകങ്ങള് തിരികെ നല്കുന്നു\/\/ >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/ [0, 2, 3, 5, 9, 123]\nfunction unique(l: number[]): number[] {\n","canonical_solution":"function unique(l: number[]): number[] {\n    const uniqueSet = new Set(l);\n    const uniqueArray = Array.from(uniqueSet);\n    uniqueArray.sort((a, b) => a - b);\n    return uniqueArray;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = unique;\n  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);\n}\n\ntest();"},{"task_id":"HumanEval_35","nl":"mal_Mlym","pl":"ts","prompt":"\/\/അറേയിലെ പരമാവധി എലമെന്റ് തിരികെ നൽകുന്നു.\/\/ >>> max_element([1, 2, 3])\n\/\/ 3\n\/\/ >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/ 123\nfunction max_element(l: number[]): number {\n","canonical_solution":"function max_element(l: number[]): number {\n    if (l.length === 0) {\n        throw new Error(\"Array is empty\");\n    }\n    let max = l[0];\n    for (let i = 1; i < l.length; i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_element;\n  assert.deepEqual(candidate([1, 2, 3]),3);\n  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);\n}\n\ntest();"},{"task_id":"HumanEval_36","nl":"mal_Mlym","pl":"ts","prompt":"\/\/11 നും 13 നും ഭിന്നമാകുന്ന n നേക്കാൾ ചെറു സംഖ്യകളിൽ 7 എന്ന അക്കം എത്ര പ്രാവശ്യം കാണുന്നു എന്ന് തിരികെ നൽകുക.\/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunction fizz_buzz(n: number): number {\n","canonical_solution":"function fizz_buzz(n: number): number {\n    let count = 0;\n\n    for (let i = 1; i < n; i++) {\n        if (i % 11 === 0 || i % 13 === 0) {\n            let numString = i.toString();\n            for (let char of numString) {\n                if (char === '7') {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fizz_buzz;\n  assert.deepEqual(candidate(50),0);\n  assert.deepEqual(candidate(78),2);\n  assert.deepEqual(candidate(79),3);\n  assert.deepEqual(candidate(100),3);\n  assert.deepEqual(candidate(200),6);\n  assert.deepEqual(candidate(4000),192);\n  assert.deepEqual(candidate(10000),639);\n  assert.deepEqual(candidate(100000),8026);\n}\n\ntest();"},{"task_id":"HumanEval_37","nl":"mal_Mlym","pl":"ts","prompt":"\/\/l യുടെ ഇരട്ട സൂചികകളുടെ മൂല്യങ്ങളിലേക്ക്, പക്ഷേ അടുക്കിയിരിക്കുന്നു.\/\/l' എന്നത് l യ്ക്ക് തുല്യമാണ്, അത് ഇരട്ട സൂചികകളിലാണ്, അതേസമയം അതിന്റെ മൂല്യങ്ങൾ ഇരട്ട സൂചികകളിലാണ്.\/\/ഈ ഫങ്ഷൻ ഒരു അറേ l എടുക്കുകയും ഒരു അറേ l' തിരിച്ചുനൽകുകയും ചെയ്യുന്നു.\/\/ >>> sort_even([1, 2, 3])\n\/\/ [1, 2, 3]\n\/\/ >>> sort_even([5, 6, 3, 4])\n\/\/ [3, 6, 5, 4]\nfunction sort_even(l: number[]): number[] {\n","canonical_solution":"function sort_even(l: number[]): number[] {\n    const evenIndices: number[] = [];\n    const result: number[] = [...l];\n\n    \/\/ Collect values at even indices\n    for (let i = 0; i < l.length; i += 2) {\n        evenIndices.push(l[i]);\n    }\n\n    \/\/ Sort the collected even indices values\n    evenIndices.sort((a, b) => a - b);\n\n    \/\/ Place the sorted values back in their original even indices\n    for (let i = 0; i < l.length; i += 2) {\n        result[i] = evenIndices.shift()!;\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_even;\n  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);\n  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n\ntest();"},{"task_id":"HumanEval_39","nl":"mal_Mlym","pl":"ts","prompt":"\/\/prime_fib ഫിബോനാച്ചി സംഖ്യയായ n-ാം സംഖ്യയെ തിരികെ നൽകുന്നു അത് പ്രൈം ആണ്.\/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunction prime_fib(n: number): number {\n","canonical_solution":"function isPrime(num: number): boolean {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 === 0 || num % 3 === 0) return false;\n    for (let i = 5; i * i <= num; i += 6) {\n        if (num % i === 0 || num % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction* fibonacciGenerator(): Generator<number, void, unknown> {\n    let a = 0, b = 1;\n    while (true) {\n        let current = a;\n        a = b;\n        b = current + b;\n        yield current;\n    }\n}\n\nfunction prime_fib(n: number): number {\n    const fibGen = fibonacciGenerator();\n    let primeFibs: number[] = [];\n    let i = 0;\n    while (primeFibs.length < n) {\n        const fibNum = fibGen.next().value;\n        if (isPrime(fibNum)) {\n            primeFibs.push(fibNum);\n        }\n    }\n    return primeFibs[n - 1];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prime_fib;\n  assert.deepEqual(candidate(1),2);\n  assert.deepEqual(candidate(2),3);\n  assert.deepEqual(candidate(3),5);\n  assert.deepEqual(candidate(4),13);\n  assert.deepEqual(candidate(5),89);\n  assert.deepEqual(candidate(6),233);\n  assert.deepEqual(candidate(7),1597);\n  assert.deepEqual(candidate(8),28657);\n  assert.deepEqual(candidate(9),514229);\n  assert.deepEqual(candidate(10),433494437);\n}\n\ntest();"},{"task_id":"HumanEval_40","nl":"mal_Mlym","pl":"ts","prompt":"\/\/പൂജ്യത്തിന് തുല്യമാണ്, അല്ലാത്തപക്ഷം തെറ്റാണ്.\/\/  ന്നതിന് സമാനമായ മൂന്ന് വ്യത്യസ്ത ഘടകങ്ങൾ അറേയിലുണ്ടെങ്കിൽ അത് true ആയി നൽകുന്നു\/\/triples_sum_to_zero ഒരു സംഖ്യകളുടെ അറേ ഒരു ഇൻപുട്ടായി എടുക്കുന്നു.\/\/ >>> triples_sum_to_zero([1, 3, 5, 0])\n\/\/ false\n\/\/ >>> triples_sum_to_zero([1, 3, -2, 1])\n\/\/ true\n\/\/ >>> triples_sum_to_zero([1, 2, 3, 7])\n\/\/ false\n\/\/ >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n\/\/ true\n\/\/ >>> triples_sum_to_zero([1])\n\/\/ false\nfunction triples_sum_to_zero(l: number[]): boolean {\n","canonical_solution":"function triples_sum_to_zero(l: number[]): boolean {\n    if (l.length < 3) {\n        return false;\n    }\n\n    \/\/ Sort the array\n    l.sort((a, b) => a - b);\n\n    \/\/ Iterate through the array\n    for (let i = 0; i < l.length - 2; i++) {\n        let left = i + 1;\n        let right = l.length - 1;\n\n        \/\/ Use two pointers to find a pair that makes the sum zero with l[i]\n        while (left < right) {\n            const sum = l[i] + l[left] + l[right];\n            if (sum === 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triples_sum_to_zero;\n  assert.deepEqual(candidate([1, 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, 5, -1]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),true);\n  assert.deepEqual(candidate([1, 2, 3, 7]),false);\n  assert.deepEqual(candidate([1, 2, 5, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);\n  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([1, 3, 5, -100]),false);\n  assert.deepEqual(candidate([100, 3, 5, -100]),false);\n}\n\ntest();"},{"task_id":"HumanEval_41","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഈ ഫങ്ഷൻ ഇത്തരം കൂട്ടിയിടികളുടെ എണ്ണം ഔട്ട്പുട്ട് ചെയ്യുന്നു.\/\/അവ തമ്മില് കൂട്ടിയിടിച്ച് നോക്കാത്ത പോലെ.\/\/എന്നിരുന്നാലും, ഈ കാറുകൾ വളരെ കരുത്തുറ്റതും ശക്തവുമാണ്; അതിന്റെ ഫലമായി, അവ തുടർന്നും നീങ്ങുന്നു.\/\/ഇടത്തു നിന്ന് വലത്തോട്ട് പോകുന്ന ഒരു കാറ് വലത്തു നിന്ന് ഇടത്തോട്ട് പോകുന്ന കാറിനെ തട്ടുമ്പോൾ.\/\/എല്ലാ കാറുകളും ഒരേ വേഗതയിൽ നീങ്ങുന്നു. രണ്ടു കാറുകൾ കൂട്ടിയിടിക്കപ്പെടുന്നു.\/\/രണ്ടു കൂട്ടം കാറുകൾ വളരെ അകലെയായി തുടങ്ങുന്നു.\/\/n കാറുകൾ ഇടത്തുനിന്ന് വലത്തോട്ട് ഓടുന്നു; ഒരേ സമയം, n കാറുകളുടെ മറ്റൊരു കൂട്ടം \/\/ഒരു റോഡ് സങ്കൽപ്പിക്കുക അത് തികച്ചും നേരായ ഒരു അനന്തമായ നീണ്ട വരിയാണ്.function car_race_collision(n: number): number {\n","canonical_solution":"function car_race_collision(n: number): number {\n    \/\/ Since the cars move at the same speed and are infinitely strong,\n    \/\/ each pair of a left-to-right car and a right-to-left car will \"collide\" at some point.\n    \/\/ Therefore, every pair of cars from different sets will collide exactly once.\n    \n    \/\/ We need to find the number of such pairs, which is simply n * n.\n    return n * n;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = car_race_collision;\n  assert.deepEqual(candidate(2),4);\n  assert.deepEqual(candidate(3),9);\n  assert.deepEqual(candidate(4),16);\n  assert.deepEqual(candidate(8),64);\n  assert.deepEqual(candidate(10),100);\n}\n\ntest();"},{"task_id":"HumanEval_42","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഘടകങ്ങൾ 1 കൊണ്ട് വർദ്ധിപ്പിച്ച ഒരു ശ്രേണി തിരികെ നൽകുക.\/\/ >>> incr_list([1, 2, 3])\n\/\/ [2, 3, 4]\n\/\/ >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunction incr_list(l: number[]): number[] {\n","canonical_solution":"function incr_list(l: number[]): number[] {\n    return l.map(num => num + 1);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = incr_list;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);\n  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n\ntest();"},{"task_id":"HumanEval_43","nl":"mal_Mlym","pl":"ts","prompt":"\/\/പൂജ്യത്തിന് തുല്യമാണ്, അല്ലാത്തപക്ഷം തെറ്റാണ്.\/\/ എന്ന് പറയുന്ന അറേയില് രണ്ട് വ്യത്യസ്ത ഘടകങ്ങള് ഉണ്ടെങ്കില് അത് true ആയി തിരിച്ചുനല് കും.\/\/pairs_sum_to_zero ഒരു സംഖ്യകളുടെ അറേ ഒരു ഇൻപുട്ടായി എടുക്കുന്നു.\/\/ >>> pairs_sum_to_zero([1, 3, 5, 0])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([1, 3, -2, 1])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([1, 2, 3, 7])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([1])\n\/\/ false\nfunction pairs_sum_to_zero(l: number[]): boolean {\n","canonical_solution":"function pairs_sum_to_zero(l: number[]): boolean {\n    const seen = new Set<number>();\n\n    for (const num of l) {\n        if (seen.has(-num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pairs_sum_to_zero;\n  assert.deepEqual(candidate([1, 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),false);\n  assert.deepEqual(candidate([1, 2, 3, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);\n  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);\n  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);\n}\n\ntest();"},{"task_id":"HumanEval_44","nl":"mal_Mlym","pl":"ts","prompt":"\/\/അടിസ്ഥാന സംഖ്യകൾ 10 ൽ കുറവാണ്.\/\/പരിവർത്തനത്തിനു ശേഷം സ്ട്രിംഗ് റെപ്രസന്റേഷൻ തിരിച്ചുനൽകുന്നു.\/\/ഇൻപുട്ട് നമ്പർ x ന്റെ സംഖ്യാ അടിത്തറയെ അടിസ്ഥാനമായി മാറ്റുക.\/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunction change_base(x: number, base: number): string {\n","canonical_solution":"function change_base(x: number, base: number): string {\n    if (base < 2 || base > 9) {\n        throw new Error(\"Base must be between 2 and 9 inclusive\");\n    }\n    \n    if (x === 0) return \"0\";\n\n    let result: string = \"\";\n    let number: number = x;\n\n    while (number > 0) {\n        const remainder = number % base;\n        result = remainder.toString() + result;\n        number = Math.floor(number \/ base);\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = change_base;\n  assert.deepEqual(candidate(8, 3),\"22\");\n  assert.deepEqual(candidate(9, 3),\"100\");\n  assert.deepEqual(candidate(234, 2),\"11101010\");\n  assert.deepEqual(candidate(16, 2),\"10000\");\n  assert.deepEqual(candidate(8, 2),\"1000\");\n  assert.deepEqual(candidate(7, 2),\"111\");\n  assert.deepEqual(candidate(2, 3),\"2\");\n  assert.deepEqual(candidate(3, 4),\"3\");\n  assert.deepEqual(candidate(4, 5),\"4\");\n  assert.deepEqual(candidate(5, 6),\"5\");\n  assert.deepEqual(candidate(6, 7),\"6\");\n  assert.deepEqual(candidate(7, 8),\"7\");\n}\n\ntest();"},{"task_id":"HumanEval_45","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഒരു ത്രികോണത്തിന്റെ വശത്തിന്റെ നീളവും ഉയർന്ന മടക്ക പ്രദേശവും കണക്കിലെടുക്കുമ്പോൾ.\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunction triangle_area(a: number, h: number): number {\n","canonical_solution":"function triangle_area(a: number, h: number): number {\n    return 0.5 * a * h;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triangle_area;\n  assert.deepEqual(candidate(5, 3),7.5);\n  assert.deepEqual(candidate(2, 2),2.0);\n  assert.deepEqual(candidate(10, 8),40.0);\n}\n\ntest();"},{"task_id":"HumanEval_46","nl":"mal_Mlym","pl":"ts","prompt":"\/\/fib4 സംഖ്യാ ശ്രേണിയുടെ n-ആം മൂലകം കാര്യക്ഷമമായി കണക്കുകൂട്ടാൻ ഒരു ഫംഗ്ഷൻ എഴുതുക. ആവർത്തനം ഉപയോഗിക്കരുത്.\/\/ഫിബര് ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു\/\/fib4(3) -> 0 \/\/fib4(2) -> 2 \/\/fib4(1) -> 0 \/\/fib4(0) -> 0 \/\/ഫിബൊനാച്ചി അനുക്രമത്തിന് സമാനമായ ഒരു അനുക്രമമാണ് ഫിബൊനച്ചി സംഖ്യാ അനുക്രമം, അത് താഴെ പറയുന്ന രീതിയിൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു:\/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunction fib4(n: number): number {\n","canonical_solution":"function fib4(n: number): number {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 2;\n    if (n === 3) return 0;\n\n    let fibNumbers = [0, 0, 2, 0];\n    for (let i = 4; i <= n; i++) {\n        const nextFib = fibNumbers[3] + fibNumbers[2] + fibNumbers[1] + fibNumbers[0];\n        fibNumbers.shift();\n        fibNumbers.push(nextFib);\n    }\n    return fibNumbers[3];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fib4;\n  assert.deepEqual(candidate(5),4);\n  assert.deepEqual(candidate(8),28);\n  assert.deepEqual(candidate(10),104);\n  assert.deepEqual(candidate(12),386);\n}\n\ntest();"},{"task_id":"HumanEval_47","nl":"mal_Mlym","pl":"ts","prompt":"\/\/അറേയിലെ മൂലകങ്ങളുടെ മീഡിയൻ മടക്കിനൽകുന്നു l. \/\/ >>> median([3, 1, 2, 4, 5])\n\/\/ 3\n\/\/ >>> median([-10, 4, 6, 1000, 10, 20])\n\/\/ 15.0\nfunction median(l: number[]): number {\n","canonical_solution":"function median(l: number[]): number {\n    const sorted = l.slice().sort((a, b) => a - b);\n    const len = sorted.length;\n    \n    if (len % 2 === 0) {\n        return (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2;\n    } else {\n        return sorted[Math.floor(len \/ 2)];\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);\n}\n\ntest();"},{"task_id":"HumanEval_48","nl":"mal_Mlym","pl":"ts","prompt":"\/\/തന്നിരിക്കുന്ന സ്ട്രിംഗ് ഒരു പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുന്നു.\/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunction is_palindrome(text: string): boolean {\n","canonical_solution":"function is_palindrome(text: string): boolean {\n    return text === text.split('').reverse().join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_palindrome;\n  assert.deepEqual(candidate(\"\"),true);\n  assert.deepEqual(candidate(\"aba\"),true);\n  assert.deepEqual(candidate(\"aaaaa\"),true);\n  assert.deepEqual(candidate(\"zbcd\"),false);\n  assert.deepEqual(candidate(\"xywyx\"),true);\n  assert.deepEqual(candidate(\"xywyz\"),false);\n  assert.deepEqual(candidate(\"xywzx\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_49","nl":"mal_Mlym","pl":"ts","prompt":"\/\/2^n മോഡുലോ പി തിരിച്ചുവിടുന്നു (നമ്പറുകളെക്കുറിച്ച് ബോധവാനായിരിക്കുക).\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunction modp(n: number, p: number): number {\n","canonical_solution":"function modp(n: number, p: number): number {\n    if (n === 0) return 1 % p;\n    let result = 1;\n    let base = 2;\n    \n    while (n > 0) {\n        if (n % 2 === 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = Math.floor(n \/ 2);\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101, 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3, 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30, 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"},{"task_id":"HumanEval_51","nl":"mal_Mlym","pl":"ts","prompt":"\/\/remove_vowels എന്നത് സ്ട്രിംഗ് എടുക്കുകയും സ്വരാക്ഷരങ്ങളില്ലാത്ത സ്ട്രിംഗ് തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷനാണ്.\/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunction remove_vowels(text: string): string {\n","canonical_solution":"function remove_vowels(text: string): string {\n    return text.replace(\/[aeiouAEIOU]\/g, '');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = remove_vowels;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"abcdef\\nghijklm\"),\"bcdf\\nghjklm\");\n  assert.deepEqual(candidate(\"fedcba\"),\"fdcb\");\n  assert.deepEqual(candidate(\"eeeee\"),\"\");\n  assert.deepEqual(candidate(\"acBAA\"),\"cB\");\n  assert.deepEqual(candidate(\"EcBOO\"),\"cB\");\n  assert.deepEqual(candidate(\"ybcd\"),\"ybcd\");\n}\n\ntest();"},{"task_id":"HumanEval_52","nl":"mal_Mlym","pl":"ts","prompt":"\/\/എല്ലാ സംഖ്യകളും മുകളിലാണെങ്കിൽ,  എന്ന സംഖ്യയെ തറവാടിനു താഴെയാണെങ്കിൽ,  എന്ന സംഖ്യയെ തറവാടിനു താഴെയാണെങ്കിൽ,  എന്ന സംഖ്യയെ തറവാടിനു താഴെയാണെങ്കിൽ,  എന്ന സംഖ്യയെ തറവാടിനു താഴെയാണെങ്കിൽ,\/\/ >>> below_threshold([1, 2, 4, 10], 100)\n\/\/ true\n\/\/ >>> below_threshold([1, 20, 4, 10], 5)\n\/\/ false\nfunction below_threshold(l: number[], t: number): boolean {\n","canonical_solution":"function below_threshold(l: number[], t: number): boolean {\n    return l.every(num => num < t);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = below_threshold;\n  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);\n  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);\n  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);\n  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);\n  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);\n  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);\n}\n\ntest();"},{"task_id":"HumanEval_53","nl":"mal_Mlym","pl":"ts","prompt":"\/\/x, y എന്നീ രണ്ടു സംഖ്യകളെ കൂട്ടുക.\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunction add(x: number, y: number): number {\n","canonical_solution":"function add(x: number, y: number): number {\n    return x + y;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add;\n  assert.deepEqual(candidate(0, 1),1);\n  assert.deepEqual(candidate(1, 0),1);\n  assert.deepEqual(candidate(2, 3),5);\n  assert.deepEqual(candidate(5, 7),12);\n  assert.deepEqual(candidate(7, 5),12);\n}\n\ntest();"},{"task_id":"HumanEval_54","nl":"mal_Mlym","pl":"ts","prompt":"\/\/രണ്ട് വാക്കുകളിലും ഒരേ അക്ഷരങ്ങളുണ്ടോ എന്ന് പരിശോധിക്കുക.\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunction same_chars(s0: string, s1: string): boolean {\n","canonical_solution":"function same_chars(s0: string, s1: string): boolean {\n    const charSet0: Set<string> = new Set(s0);\n    const charSet1: Set<string> = new Set(s1);\n\n    if (charSet0.size !== charSet1.size) {\n        return false;\n    }\n\n    for (const char of charSet0) {\n        if (!charSet1.has(char)) {\n            return false;\n        }\n    }\n\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = same_chars;\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),true);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabc\"),true);\n  assert.deepEqual(candidate(\"dddddddabc\", \"abcd\"),true);\n  assert.deepEqual(candidate(\"eabcd\", \"dddddddabc\"),false);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabcf\"),false);\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),false);\n  assert.deepEqual(candidate(\"aabb\", \"aaccc\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_55","nl":"mal_Mlym","pl":"ts","prompt":"\/\/n-ആം ഫിബോനാച്ചി സംഖ്യ തിരികെ നൽകുക.\/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunction fib(n: number): number {\n","canonical_solution":"function fib(n: number): number {\n    if (n <= 0) {\n        throw new Error(\"Input should be a positive integer.\");\n    }\n    if (n === 1) return 1;\n    if (n === 2) return 1;\n\n    let a = 1, b = 1;\n    for (let i = 3; i <= n; i++) {\n        const temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n\/\/ Example usage:\nconsole.log(fib(10)); \/\/ 55\nconsole.log(fib(1));  \/\/ 1\nconsole.log(fib(8));  \/\/ 21","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fib;\n  assert.deepEqual(candidate(10),55);\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(8),21);\n  assert.deepEqual(candidate(11),89);\n  assert.deepEqual(candidate(12),144);\n}\n\ntest();"},{"task_id":"HumanEval_56","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഓരോ തുറക്കുന്ന ബ്രാക്കറ്റിനും ഒരു അടയ്ക്കുന്ന ബ്രാക്കറ്റും ഉണ്ടെങ്കിൽ true എന്ന് റിട്ടേൺ ചെയ്യുക.\/\/ബ്രാക്കറ്റുകളില് \"<\" ഉം \">\" ഉം അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്.\/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunction correct_bracketing(brackets: string): boolean {\n","canonical_solution":"function correct_bracketing(brackets: string): boolean {\n    let balance = 0;\n    for (let char of brackets) {\n        if (char === '<') {\n            balance++;\n        } else if (char === '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"<>\"),true);\n  assert.deepEqual(candidate(\"<<><>>\"),true);\n  assert.deepEqual(candidate(\"<><><<><>><>\"),true);\n  assert.deepEqual(candidate(\"<><><<<><><>><>><<><><<>>>\"),true);\n  assert.deepEqual(candidate(\"<<<><>>>>\"),false);\n  assert.deepEqual(candidate(\"><<>\"),false);\n  assert.deepEqual(candidate(\"<\"),false);\n  assert.deepEqual(candidate(\"<<<<\"),false);\n  assert.deepEqual(candidate(\">\"),false);\n  assert.deepEqual(candidate(\"<<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>><<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>>><>\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_57","nl":"mal_Mlym","pl":"ts","prompt":"\/\/                            \/\/ >>> monotonic([1, 2, 4, 20])\n\/\/ true\n\/\/ >>> monotonic([1, 20, 4, 10])\n\/\/ false\n\/\/ >>> monotonic([4, 1, 0, -10])\n\/\/ true\nfunction monotonic(l: number[]): boolean {\n","canonical_solution":"function monotonic(l: number[]): boolean {\n    if (l.length <= 1) return true;\n    \n    let increasing = true;\n    let decreasing = true;\n    \n    for (let i = 1; i < l.length; i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n        \n        if (!increasing && !decreasing) return false;\n    }\n    \n    return increasing || decreasing;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = monotonic;\n  assert.deepEqual(candidate([1, 2, 4, 10]),true);\n  assert.deepEqual(candidate([1, 2, 4, 20]),true);\n  assert.deepEqual(candidate([1, 20, 4, 10]),false);\n  assert.deepEqual(candidate([4, 1, 0, -10]),true);\n  assert.deepEqual(candidate([4, 1, 1, 0]),true);\n  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);\n  assert.deepEqual(candidate([9, 9, 9, 9]),true);\n}\n\ntest();"},{"task_id":"HumanEval_58","nl":"mal_Mlym","pl":"ts","prompt":"\/\/രണ്ട് അറേകളുടെയും ഏകീകൃതമായ പൊതുവായ ഘടകങ്ങൾ തിരികെ നൽകുന്നു.\/\/ >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\/\/ [1, 5, 653]\n\/\/ >>> common([5, 3, 2, 8], [3, 2])\n\/\/ [2, 3]\nfunction common(l1: number[], l2: number[]): number[] {\n","canonical_solution":"function common(l1: number[], l2: number[]): number[] {\n    const set1 = new Set(l1);\n    const set2 = new Set(l2);\n    const commonElements = Array.from(set1).filter(item => set2.has(item));\n    return commonElements.sort((a, b) => a - b);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"},{"task_id":"HumanEval_59","nl":"mal_Mlym","pl":"ts","prompt":"\/\/n ന്റെ ഏറ്റവും വലിയ പ്രൈം ഫാക്ടർ തിരികെ നൽകുക. n > 1 ആണെന്നും പ്രൈം അല്ലെന്നും കരുതുക. \/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunction largest_prime_factor(n: number): number {\n","canonical_solution":"function largest_prime_factor(n: number): number {\n    let largestFactor = 1;\n\n    \/\/ Divide n by 2 until it becomes odd\n    while (n % 2 === 0) {\n        largestFactor = 2;\n        n \/= 2;\n    }\n\n    \/\/ Check for odd factors from 3 upwards\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        while (n % i === 0) {\n            largestFactor = i;\n            n \/= i;\n        }\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if (n > 2) {\n        largestFactor = n;\n    }\n\n    return largestFactor;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_prime_factor;\n  assert.deepEqual(candidate(15),5);\n  assert.deepEqual(candidate(27),3);\n  assert.deepEqual(candidate(63),7);\n  assert.deepEqual(candidate(330),11);\n  assert.deepEqual(candidate(13195),29);\n}\n\ntest();"},{"task_id":"HumanEval_60","nl":"mal_Mlym","pl":"ts","prompt":"\/\/sum_to_n എന്നത് 1 മുതൽ n വരെയുള്ള സംഖ്യകളുടെ സംഖ്യയായി കണക്കാക്കുന്ന ഒരു ഫംഗ്ഷനാണ്.\/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunction sum_to_n(n: number): number {\n","canonical_solution":"function sum_to_n(n: number): number {\n    return n * (n + 1) \/ 2;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_to_n;\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(6),21);\n  assert.deepEqual(candidate(11),66);\n  assert.deepEqual(candidate(30),465);\n  assert.deepEqual(candidate(100),5050);\n}\n\ntest();"},{"task_id":"HumanEval_61","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഓരോ തുറക്കുന്ന ബ്രാക്കറ്റിനും ഒരു അടയ്ക്കുന്ന ബ്രാക്കറ്റും ഉണ്ടെങ്കിൽ true എന്ന് റിട്ടേൺ ചെയ്യുക.\/\/ബ്രാക്കറ്റുകളില് \"(\" ഉം \"\") യും അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്.\/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunction correct_bracketing(brackets: string): boolean {\n","canonical_solution":"function correct_bracketing(brackets: string): boolean {\n    let balance = 0;\n\n    for (let char of brackets) {\n        if (char === '(') {\n            balance++;\n        } else if (char === ')') {\n            balance--;\n        }\n\n        \/\/ If balance goes negative, there's a closing bracket without a matching opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    \/\/ If balance is zero, all opening brackets have matching closing brackets\n    return balance === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\")(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"(()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"()()(()())()))()\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_62","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഈ പോളിനോമിയുടെ ഡെറിവേറ്റീവ് അതേ രൂപത്തിൽ തിരികെ നൽകുക.\/\/xs[0] + xs[1] * x + xs[2] * x^2 + ....  എന്നിങ്ങനെ ഒരു സംഖ്യയുടെ സംഖ്യകൾ കൂട്ടിച്ചേർക്കുക\/\/xs ഒരു പോളിനോമിയുടെ ഗുണകങ്ങളെ പ്രതിനിധീകരിക്കുന്നു.\/\/ >>> derivative([3, 1, 2, 4, 5])\n\/\/ [1, 4, 12, 20]\n\/\/ >>> derivative([1, 2, 3])\n\/\/ [2, 6]\nfunction derivative(xs: number[]): number[] {\n","canonical_solution":"function derivative(xs: number[]): number[] {\n    return xs.slice(1).map((coef, index) => coef * (index + 1));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = derivative;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);\n  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);\n  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);\n  assert.deepEqual(candidate([1]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_63","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഫിബ്ബി നമ്പർ സീക്വൻസിന്റെ n-ആം എലമെന്റ് കാര്യക്ഷമമായി കണക്കുകൂട്ടാൻ ഒരു ഫംഗ്ഷൻ എഴുതുക.\/\/ഫിബ്ബി (n) == ഫിബ്ബി (n-1) + ഫിബ്ബി (n-2) + ഫിബ്ബി (n-3). \/\/ഫിഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്\/\/ഫിഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്\/\/ഫിഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്\/\/ഫിബോനാച്ചി അനുക്രമത്തിന് സമാനമായ ഒരു അനുക്രമമാണ് ഫിബോനാച്ചി സംഖ്യാ അനുക്രമം, അത് താഴെ പറയുന്ന രീതിയിൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു:\/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunction fibfib(n: number): number {\n","canonical_solution":"function fibfib(n: number): number {\n    if (n === 0 || n === 1) return 0;\n    if (n === 2) return 1;\n\n    let a = 0;\n    let b = 0;\n    let c = 1;\n\n    for (let i = 3; i <= n; i++) {\n        let next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fibfib;\n  assert.deepEqual(candidate(2),1);\n  assert.deepEqual(candidate(1),0);\n  assert.deepEqual(candidate(5),4);\n  assert.deepEqual(candidate(8),24);\n  assert.deepEqual(candidate(10),81);\n  assert.deepEqual(candidate(12),274);\n  assert.deepEqual(candidate(14),927);\n}\n\ntest();"},{"task_id":"HumanEval_64","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/വോക്കൽ, പക്ഷേ അത് വാക്കിന്റെ അവസാനം ഉള്ളപ്പോൾ മാത്രം.\/\/ഈ കേസിലെ സ്വരാക്ഷരങ്ങൾ 'a', 'e', 'i', 'o', 'u' ആണ്. ഇവിടെ, 'y' ഒരു യും ആണ്.\/\/ഒരു വാക്ക് ഇൻപുട്ടായി നല് കുകയും സ്ട്രിങ്ങിലെ സ്വരാക്ഷരങ്ങളുടെ എണ്ണം നല് കുകയും ചെയ്യുന്നു.\/\/ എന്നൊരു സ്ട്രിംഗ് എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ vowels_count എഴുതുക.\/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunction vowels_count(s: string): number {\n","canonical_solution":"function vowels_count(s: string): number {\n    let count = 0;\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n    const lowerCaseString = s.toLowerCase();\n\n    for (let i = 0; i < lowerCaseString.length; i++) {\n        if (vowels.has(lowerCaseString[i])) {\n            count++;\n        }\n        if (i === lowerCaseString.length - 1 && lowerCaseString[i] === 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = vowels_count;\n  assert.deepEqual(candidate(\"abcde\"),2);\n  assert.deepEqual(candidate(\"Alone\"),3);\n  assert.deepEqual(candidate(\"key\"),2);\n  assert.deepEqual(candidate(\"bye\"),1);\n  assert.deepEqual(candidate(\"keY\"),2);\n  assert.deepEqual(candidate(\"bYe\"),1);\n  assert.deepEqual(candidate(\"ACEDY\"),3);\n}\n\ntest();"},{"task_id":"HumanEval_65","nl":"mal_Mlym","pl":"ts","prompt":"\/\/shift > അക്കങ്ങളുടെ എണ്ണം എങ്കിൽ, അക്കങ്ങൾ വിപരീതമായി നൽകുക.\/\/ഫലം ഒരു സ്ട്രിംഗായി റിട്ടേൺ ചെയ്യുക.\/\/x ന്റെ അക്കം വലത്തോട്ട് നീക്കുക, വലത്തോട്ട് നീക്കുക\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunction circular_shift(x: number, shift: number): string {\n","canonical_solution":"function circular_shift(x: number, shift: number): string {\n    const strNum = x.toString();\n    const length = strNum.length;\n    if (shift >= length) {\n        return strNum.split('').reverse().join('');\n    }\n    const normalizedShift = shift % length;\n    const splitIndex = length - normalizedShift;\n    return strNum.slice(splitIndex) + strNum.slice(0, splitIndex);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = circular_shift;\n  assert.deepEqual(candidate(100, 2),\"001\");\n  assert.deepEqual(candidate(12, 2),\"12\");\n  assert.deepEqual(candidate(97, 8),\"79\");\n  assert.deepEqual(candidate(12, 1),\"21\");\n  assert.deepEqual(candidate(11, 101),\"11\");\n}\n\ntest();"},{"task_id":"HumanEval_66","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ASCII കോഡുകൾ \/\/ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുക്കുകയും മുകളിലെ പ്രതീകങ്ങളുടെ തുക മാത്രം നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക' \/\/ചുമതല \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunction digitSum(s: string): number {\n","canonical_solution":"function digitSum(s: string): number {\n    let sum = 0;\n    for (const char of s) {\n        if (char >= 'A' && char <= 'Z') {\n            sum += char.charCodeAt(0);\n        }\n    }\n    return sum;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = digitSum;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"abAB\"),131);\n  assert.deepEqual(candidate(\"abcCd\"),67);\n  assert.deepEqual(candidate(\"helloE\"),69);\n  assert.deepEqual(candidate(\"woArBld\"),131);\n  assert.deepEqual(candidate(\"aAaaaXa\"),153);\n  assert.deepEqual(candidate(\" How are yOu?\"),151);\n  assert.deepEqual(candidate(\"You arE Very Smart\"),327);\n}\n\ntest();"},{"task_id":"HumanEval_67","nl":"mal_Mlym","pl":"ts","prompt":"\/\/യും\/\/കൊട്ടയില് , കൊട്ടയില് മാങ്ങയുടെ എണ്ണം തിരിച്ച് കൊടുക്കുക.\/\/ആപ്പിളും ഓറഞ്ചും, പഴങ്ങളുടെ ആകെ എണ്ണം സൂചിപ്പിക്കുന്ന ഒരു സംഖ്യയും.\/\/ആപ്പിളും ഓറഞ്ചും മാംഗോയും.\/\/ഈ കൊട്ടയില് അടങ്ങിയിരിക്കുന്ന പഴങ്ങളുടെ ഒരു കൊട്ടയില് വിതരണം ചെയ്യപ്പെടുന്ന \/\/ഈ ടാസ്കിൽ, നിങ്ങൾക്ക് ഒരു സ്ട്രിംഗ് ലഭിക്കും അത് ആപ്പിളുകളുടെയും ഓറഞ്ചുകളുടെയും എണ്ണം പ്രതിനിധീകരിക്കും.\/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunction fruit_distribution(s: string, n: number): number {\n","canonical_solution":"function fruit_distribution(s: string, n: number): number {\n    const regex = \/(\\d+) apples and (\\d+) oranges\/;\n    const match = s.match(regex);\n    \n    if (!match) {\n        throw new Error(\"Invalid input format\");\n    }\n    \n    const apples = parseInt(match[1], 10);\n    const oranges = parseInt(match[2], 10);\n    \n    const totalApplesAndOranges = apples + oranges;\n    return n - totalApplesAndOranges;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fruit_distribution;\n  assert.deepEqual(candidate(\"5 apples and 6 oranges\", 19),8);\n  assert.deepEqual(candidate(\"5 apples and 6 oranges\", 21),10);\n  assert.deepEqual(candidate(\"0 apples and 1 oranges\", 3),2);\n  assert.deepEqual(candidate(\"1 apples and 0 oranges\", 3),2);\n  assert.deepEqual(candidate(\"2 apples and 3 oranges\", 100),95);\n  assert.deepEqual(candidate(\"2 apples and 3 oranges\", 5),0);\n  assert.deepEqual(candidate(\"1 apples and 100 oranges\", 120),19);\n}\n\ntest();"},{"task_id":"HumanEval_68","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം 1:\/\/ഇരട്ട മൂല്യങ്ങളില്ലെങ്കിലോ നൽകിയിരിക്കുന്ന അറേ ശൂന്യമാണെങ്കിലോ, മടങ്ങുക [].\/\/പിളര് ന്ന നോഡ് ഒരു അറേയില് തിരിച്ചെത്തണം, [smallest_value, അതിന്റെ സൂചിക ], \/\/ഒരേ ചെറിയ ഇരട്ട മൂല്യം ഉള്ള ഒന്നിലധികം നോഡുകൾ കണ്ടെത്തിയാൽ ഏറ്റവും ചെറിയ സൂചികയുള്ള നോഡ് തിരികെ നൽകുക.\/\/ഈ നോഡിൽ ഏറ്റവും ചെറിയ ഇരട്ട മൂല്യം ഉണ്ടായിരിക്കണം.\/\/നിങ്ങളുടെ ജോലി ഒരു നോഡിൽ നിന്ന് പിഴുതെടുത്ത് അത് തിരികെ കൊടുക്കുക എന്നതാണ്.\/\/\"ഒരു വൃക്ഷത്തിന്റെ ശാഖയെ പ്രതിനിധീകരിക്കുന്ന ഒരു അറേ നൽകിയിട്ടുണ്ടെങ്കിൽ, അത് നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യാ നോഡുകളാണ് \/\/ >>> pluck([4, 2, 3])\n\/\/ [2, 1]\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([1, 2, 3])\n\/\/ [2, 1]\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([])\n\/\/ []\n\/\/ Example 4:\n\/\/ >>> pluck([5, 0, 3, 0, 4, 2])\n\/\/ [0, 1]\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunction pluck(arr: number[]): number[] {\n","canonical_solution":"function pluck(arr: number[]): number[] {\n    let minEvenValue: number | null = null;\n    let minIndex: number | null = null;\n\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] % 2 === 0) { \/\/ Check if the number is even\n            if (minEvenValue === null || arr[i] < minEvenValue) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minEvenValue !== null && minIndex !== null) {\n        return [minEvenValue, minIndex];\n    } else {\n        return [];\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_69","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/അത്തരമൊരു മൂല്യം ഇല്ലെങ്കിൽ, -1 തിരികെ നൽകുക.\/\/ഒരു സംഖ്യയുടെ ആവൃത്തി അറേയില് എത്ര പ്രാവശ്യം പ്രത്യക്ഷപ്പെടുന്നു എന്നതിന്റെ അളവാണ്.\/\/പൂജ്യമാണ്, കൂടാതെ സംഖ്യയുടെ മൂല്യത്തേക്കാൾ വലുതോ തുല്യമോ ആയ ഒരു ആവൃത്തി ഉണ്ട്.\/\/പോസിറ്റീവ് ഇന്ററുകളുടെ ഒരു ശൂന്യമല്ലാത്ത അറേ കിട്ടും.                                   \/\/ >>> search([4, 1, 2, 2, 3, 1])\n\/\/ 2\n\/\/ >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/ 3\n\/\/ >>> search([5, 5, 4, 4, 4])\n\/\/ -1\nfunction search(lst: number[]): number {\n","canonical_solution":"function search(lst: number[]): number {\n    const frequencyMap: Map<number, number> = new Map();\n\n    \/\/ Count frequencies of each integer in the array\n    for (const num of lst) {\n        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);\n    }\n\n    let result = -1;\n\n    \/\/ Determine the greatest integer that meets the condition\n    for (const [num, freq] of frequencyMap.entries()) {\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = search;\n  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);\n  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);\n  assert.deepEqual(candidate([3, 3]),-1);\n  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);\n  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);\n  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);\n  assert.deepEqual(candidate([3, 2, 8, 2]),2);\n  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);\n  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);\n  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);\n  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);\n  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);\n  assert.deepEqual(candidate([1]),1);\n  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);\n  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);\n  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);\n  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);\n  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);\n  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);\n  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);\n  assert.deepEqual(candidate([10]),-1);\n  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);\n  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);\n  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);\n  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_70","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/പിന്നെ ബാക്കിയുള്ള സംഖ്യകളുടെ പരമാവധി, പിന്നെ കുറഞ്ഞത്, അങ്ങനെ.\/\/ഏറ്റവും കുറഞ്ഞ മൂല്യം ഉപയോഗിച്ച് തുടങ്ങുന്നതാണ് വിചിത്രമായ തരംതിരിവ്,\/\/ഒരു സംഖ്യാ ശ്രേണി തന്നാൽ, അത് വിചിത്രമായ ക്രമത്തിൽ മടങ്ങും.\/\/ >>> strange_sort_list([1, 2, 3, 4])\n\/\/ [1, 4, 2, 3]\n\/\/ >>> strange_sort_list([5, 5, 5, 5])\n\/\/ [5, 5, 5, 5]\n\/\/ >>> strange_sort_list([])\n\/\/ []\nfunction strange_sort_list(lst: number[]): number[] {\n","canonical_solution":"function strange_sort_list(lst: number[]): number[] {\n    const sorted = [...lst].sort((a, b) => a - b);\n    const result: number[] = [];\n    let left = 0;\n    let right = sorted.length - 1;\n\n    while (left <= right) {\n        if (left === right) {\n            result.push(sorted[left]);\n        } else {\n            result.push(sorted[left]);\n            result.push(sorted[right]);\n        }\n        left++;\n        right--;\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = strange_sort_list;\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);\n  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);\n  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);\n  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);\n  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);\n  assert.deepEqual(candidate([111111]),[111111]);\n}\n\ntest();"},{"task_id":"HumanEval_71","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/മൂന്നാം വശത്തേക്കാൾ.\/\/ഏതെങ്കിലും രണ്ട് വശങ്ങളുടെ സംഖ്യ കൂടുതലാണെങ്കിൽ മൂന്നു വശങ്ങളും ഒരു ത്രികോണത്തെ രൂപപ്പെടുത്തുന്നു.\/\/ഇല്ലെങ്കിൽ -1  തിരിച്ചു നൽകും.\/\/ത്രികോണം രണ്ട് ദശാംശസ്ഥാനങ്ങളിലേക്ക് ചുരുക്കിയിട്ടുണ്ടെങ്കിൽ അതിന്റെ മൂന്നു വശങ്ങളും ഒരു സാധുവായ ത്രികോണമായിരിക്കണം.\/\/ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങളുടെ നീളം കണക്കിലെടുത്താൽ ന്റെ വിസ്തീർണ്ണം തിരികെ കൊടുക്കുക\/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunction triangle_area(a: number, b: number, c: number): number {\n","canonical_solution":"function triangle_area(a: number, b: number, c: number): number {\n    \/\/ Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        \/\/ Calculate the semi-perimeter\n        const s = (a + b + c) \/ 2;\n        \/\/ Calculate the area using Heron's formula\n        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \/\/ Return the area rounded to 2 decimal places\n        return Math.round(area * 100) \/ 100;\n    }\n    \/\/ Return -1 if the sides do not form a valid triangle\n    return -1;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triangle_area;\n  assert.deepEqual(candidate(3, 4, 5),6.0);\n  assert.deepEqual(candidate(1, 2, 10),-1);\n  assert.deepEqual(candidate(4, 8, 5),8.18);\n  assert.deepEqual(candidate(2, 2, 2),1.73);\n  assert.deepEqual(candidate(1, 2, 3),-1);\n  assert.deepEqual(candidate(10, 5, 7),16.25);\n  assert.deepEqual(candidate(2, 6, 3),-1);\n  assert.deepEqual(candidate(1, 1, 1),0.43);\n  assert.deepEqual(candidate(2, 2, 10),-1);\n}\n\ntest();"},{"task_id":"HumanEval_72","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/വസ്തു q സന്തുലിതമാണെങ്കിൽ പറക്കും (അത് ഒരു പാലിൻഡ്രോമിക് അറേ ആണ്) അതിന്റെ ഘടകങ്ങളുടെ ആകെത്തുക പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കുറവോ തുല്യമോ ആണെങ്കിൽ w.\/\/വസ്തു q പറന്നു പോകുന്നുവെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫങ്ഷൻ എഴുതുക, അല്ലാത്തപക്ഷം false എന്ന് തിരികെ നൽകുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.\/\/ >>> will_it_fly([1, 2], 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([3, 2, 3], 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([3, 2, 3], 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([3], 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunction will_it_fly(q: number[], w: number): boolean {\n","canonical_solution":"function will_it_fly(q: number[], w: number): boolean {\n    \/\/ Check if the array is balanced (palindromic)\n    const isBalanced = (arr: number[]): boolean => {\n        for (let i = 0; i < arr.length \/ 2; i++) {\n            if (arr[i] !== arr[arr.length - 1 - i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    \/\/ Calculate the sum of the elements in the array\n    const sumElements = q.reduce((acc, curr) => acc + curr, 0);\n\n    \/\/ Check both conditions: balanced array and sum less than or equal to max weight\n    return isBalanced(q) && sumElements <= w;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = will_it_fly;\n  assert.deepEqual(candidate([3, 2, 3], 9),true);\n  assert.deepEqual(candidate([1, 2], 5),false);\n  assert.deepEqual(candidate([3], 5),true);\n  assert.deepEqual(candidate([3, 2, 3], 1),false);\n  assert.deepEqual(candidate([1, 2, 3], 6),false);\n  assert.deepEqual(candidate([5], 5),true);\n}\n\ntest();"},{"task_id":"HumanEval_73","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/ഒരു മാറ്റം കൊണ്ട്, നിങ്ങൾക്ക് ഒരു മൂലകം മറ്റേതെങ്കിലും മൂലകത്തിലേക്ക് മാറ്റാം.\/\/ഒരു പലിൻഡ്രോമിക് അറേ എന്നത് ഒരു അറേ ആണ്.\/\/ഒരു അറേ arr എന്ന സംഖ്യകൾ കൊടുത്താൽ,  എന്നതിൽ  ഉള്ള ഘടകങ്ങളുടെ ഏറ്റവും കുറഞ്ഞ എണ്ണം കണ്ടെത്തുക.\/\/ >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n\/\/ 4\n\/\/ >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n\/\/ 1\n\/\/ >>> smallest_change([1, 2, 3, 2, 1])\n\/\/ 0\nfunction smallest_change(arr: number[]): number {\n","canonical_solution":"function smallest_change(arr: number[]): number {\n    let changes = 0;\n    let left = 0;\n    let right = arr.length - 1;\n\n    while (left < right) {\n        if (arr[left] !== arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = smallest_change;\n  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);\n  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);\n  assert.deepEqual(candidate([1, 4, 2]),1);\n  assert.deepEqual(candidate([1, 4, 4, 2]),1);\n  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);\n  assert.deepEqual(candidate([3, 1, 1, 3]),0);\n  assert.deepEqual(candidate([1]),0);\n  assert.deepEqual(candidate([0, 1]),1);\n}\n\ntest();"},{"task_id":"HumanEval_74","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/രണ്ട് അറേകളിലും ഒരേ എണ്ണം കറുകളുണ്ടെങ്കിൽ, ആദ്യത്തെ അറേ തിരികെ നൽകുക.\/\/എല്ലാ സ്ട്രിങ്ങുകളിലും ഉള്ള ഛര് കളുടെ ആകെ എണ്ണം മറ്റേ സ്ട്രിങ്ങിനേക്കാൾ കുറവാണ്.\/\/രണ്ട് സ്ട്രിങ്ങുകളുടെ അറേ സ്വീകരിക്കുകയും  ഉള്ള അറേ മടക്കിനൽകുകയും ചെയ്യുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.\/\/ >>> total_match([], [])\n\/\/ []\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n\/\/ [\"hI\", \"Hi\"]\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/ [\"hi\", \"admin\"]\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/ >>> total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/ [\"4\"]\nfunction total_match(lst1: string[], lst2: string[]): string[] {\n","canonical_solution":"function total_match(lst1: string[], lst2: string[]): string[] {\n    const getTotalChars = (arr: string[]): number => {\n        return arr.reduce((acc, str) => acc + str.length, 0);\n    };\n\n    const totalChars1 = getTotalChars(lst1);\n    const totalChars2 = getTotalChars(lst2);\n\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else if (totalChars2 < totalChars1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = total_match;\n  assert.deepEqual(candidate([], []),[]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\"]),[\"hi\", \"hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]),[\"hi\", \"admin\"]);\n  assert.deepEqual(candidate([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]),[\"4\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"Hi\"]),[\"hI\", \"Hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]),[\"hI\", \"hi\", \"hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]),[\"hi\", \"admin\"]);\n  assert.deepEqual(candidate([], [\"this\"]),[]);\n  assert.deepEqual(candidate([\"this\"], []),[]);\n}\n\ntest();"},{"task_id":"HumanEval_75","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/(a) 100 ൽ കുറവാണെന്ന് അറിയുന്നത്.\/\/അല്ലെങ്കിൽ തെറ്റാണ്.\/\/3 പ്രൈം നമ്പറുകളുടെ ഗുണനമാണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.\/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunction is_multiply_prime(a: number): boolean {\n","canonical_solution":"function is_multiply_prime(a: number): boolean {\n    \/\/ Helper function to check if a number is prime\n    function isPrime(n: number): boolean {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 === 0 || n % 3 === 0) return false;\n        for (let i = 5; i * i <= n; i += 6) {\n            if (n % i === 0 || n % (i + 2) === 0) return false;\n        }\n        return true;\n    }\n\n    \/\/ Generate a list of primes less than 100\n    const primes: number[] = [];\n    for (let i = 2; i < 100; i++) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n    }\n\n    \/\/ Check if a can be expressed as a product of 3 distinct primes\n    const primeCount = primes.length;\n    for (let i = 0; i < primeCount - 2; i++) {\n        for (let j = i + 1; j < primeCount - 1; j++) {\n            for (let k = j + 1; k < primeCount; k++) {\n                if (primes[i] * primes[j] * primes[k] === a) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_multiply_prime;\n  assert.deepEqual(candidate(5),false);\n  assert.deepEqual(candidate(30),true);\n  assert.deepEqual(candidate(8),true);\n  assert.deepEqual(candidate(10),false);\n  assert.deepEqual(candidate(125),true);\n  assert.deepEqual(candidate(105),true);\n  assert.deepEqual(candidate(126),false);\n  assert.deepEqual(candidate(729),false);\n  assert.deepEqual(candidate(891),false);\n  assert.deepEqual(candidate(1001),true);\n}\n\ntest();"},{"task_id":"HumanEval_76","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/x എന്നത് n ന്റെ ഒരു ലളിതമായ പവറാണ്, n**int=x  ആണെങ്കിൽ\/\/n ന്റെ ശക്തിയും മറ്റു കേസുകളിൽ തെറ്റും.\/\/നിങ്ങളുടെ ജോലി ഒരു സംഖ്യ x ഒരു ലളിതമായ  ആണെങ്കിൽ true എന്ന് നൽകുന്ന ഒരു ഫങ്ഷൻ എഴുതുക എന്നതാണ്.\/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunction is_simple_power(x: number, n: number): boolean {\n","canonical_solution":"function is_simple_power(x: number, n: number): boolean {\n    if (x < 1 || n < 1) return false;\n    if (x === 1) return true; \/\/ n^0 is 1 for any n\n\n    let power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    \n    return power === x;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_simple_power;\n  assert.deepEqual(candidate(16, 2),true);\n  assert.deepEqual(candidate(143214, 16),false);\n  assert.deepEqual(candidate(4, 2),true);\n  assert.deepEqual(candidate(9, 3),true);\n  assert.deepEqual(candidate(16, 4),true);\n  assert.deepEqual(candidate(24, 2),false);\n  assert.deepEqual(candidate(128, 4),false);\n  assert.deepEqual(candidate(12, 6),false);\n  assert.deepEqual(candidate(1, 1),true);\n  assert.deepEqual(candidate(1, 12),true);\n}\n\ntest();"},{"task_id":"HumanEval_77","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/കുറിപ്പ്: ഈ ഇൻപുട്ട് എല്ലായ്പ്പോഴും സാധുവാണെന്ന് കരുതാം.\/\/ഈ ഇംഗെർ ഏതെങ്കിലുമൊരു പൂർണ്ണസംഖ്യയുടെ ക്യൂബാണെങ്കിൽ.\/\/ഒരു പൂർണ്ണസംഖ്യ a എടുക്കുകയും true തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.\/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunction iscube(a: number): boolean {\n","canonical_solution":"function iscube(a: number): boolean {\n    \/\/ Calculate the cube root of the absolute value of a\n    const cubeRoot = Math.cbrt(Math.abs(a));\n    \/\/ Check if the cube root is an integer\n    return cubeRoot === Math.round(cubeRoot);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = iscube;\n  assert.deepEqual(candidate(1),true);\n  assert.deepEqual(candidate(2),false);\n  assert.deepEqual(candidate(-1),true);\n  assert.deepEqual(candidate(64),true);\n  assert.deepEqual(candidate(180),false);\n  assert.deepEqual(candidate(1000),true);\n  assert.deepEqual(candidate(0),true);\n  assert.deepEqual(candidate(1729),false);\n}\n\ntest();"},{"task_id":"HumanEval_78","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/A, B, C, D, E, F എന്നീ ചിഹ്നങ്ങള് എല്ലായ്പ്പോഴും വലിയ അക്ഷരങ്ങളായിരിക്കും.\/\/കുറിപ്പ്: നിങ്ങള് ക്ക് എല്ലായ്പ്പോഴും ശരിയായതോ ശൂന്യമോ ആണെന്ന് കരുതാം.\/\/ബി (= ദശാംശ 11), ഡി (= ദശാംശ 13).\/\/ഇനി പറയുന്ന അക്കങ്ങളുടെ എണ്ണം കണ്ടെത്തണം: 2, 3, 5, 7, \/\/പ്രൈം നമ്പറുകൾ 2, 3, 5, 7, 11, 13, 17,...  എന്നിവയാണ്.\/\/ഹെക്സാഡെസിമൽ അക്കങ്ങൾ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, എ, ബി, സി, ഡി, ഇ, എഫ് എന്നിവയാണ്.\/\/1 ന് മുകളിലുള്ളത്, അത് രണ്ട് ചെറിയ സംഖ്യകളുടെ ഗുണനമല്ല).\/\/പ്രൈം നമ്പറുകളായ അക്കങ്ങൾ (പ്രൈം നമ്പർ, അല്ലെങ്കിൽ ഒരു പ്രൈം, ഒരു സ്വാഭാവിക സംഖ്യയാണ് \/\/ഒരു ഹെക്സാഡെസിമൽ നമ്പർ ഒരു സ്ട്രിംഗായി എണ്ണുന്നു ഹെക്സാഡെസിമൽ നമ്പറുകളുടെ എണ്ണം \/\/നിങ്ങള് ക്ക് ഒരു ഫങ്ഷൻ എഴുതാന് നിര് ദ്ദേശമുണ്ട്.\/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunction hex_key(num: string): number {\n","canonical_solution":"function hex_key(num: string): number {\n    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);\n    let count = 0;\n\n    for (let digit of num) {\n        if (primeHexDigits.has(digit)) {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = hex_key;\n  assert.deepEqual(candidate(\"AB\"),1);\n  assert.deepEqual(candidate(\"1077E\"),2);\n  assert.deepEqual(candidate(\"ABED1A33\"),4);\n  assert.deepEqual(candidate(\"2020\"),2);\n  assert.deepEqual(candidate(\"123456789ABCDEF0\"),6);\n  assert.deepEqual(candidate(\"112233445566778899AABBCCDDEEFF00\"),12);\n}\n\ntest();"},{"task_id":"HumanEval_79","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഫോർമാറ്റിനെ സഹായിക്കുന്നതിനാണ് അധിക അക്ഷരങ്ങൾ.\/\/സ്ട്രിങ്ങിന്റെ തുടക്കത്തിലും അവസാനത്തിലും ഒരു കൂട്ടം 'db' പ്രതീകങ്ങൾ ഉണ്ടാകും.\/\/സ്ട്രിംഗിലെ ഓരോ പ്രതീകവും '0' അല്ലെങ്കിൽ '1' ആയിരിക്കും.\/\/ഫങ്ഷൻ ഒരു സ്ട്രിംഗ് നൽകണം, ഓരോ പ്രതീകവും ഒരു ബൈനറി \/\/നിങ്ങള് ക്ക് ഒരു സംഖ്യ ദശാംശ രൂപത്തില് ലഭിക്കും. നിങ്ങള് ക്ക് അതിനെ  ആയി പരിവര് ത്തനം ചെയ്യണം.\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunction decimal_to_binary(decimal: number): string {\n","canonical_solution":"function decimal_to_binary(decimal: number): string {\n    const binaryString = decimal.toString(2);\n    return `db${binaryString}db`;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = decimal_to_binary;\n  assert.deepEqual(candidate(0),\"db0db\");\n  assert.deepEqual(candidate(32),\"db100000db\");\n  assert.deepEqual(candidate(103),\"db1100111db\");\n  assert.deepEqual(candidate(15),\"db1111db\");\n}\n\ntest();"},{"task_id":"HumanEval_80","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/ഒരു സ്ട്രിംഗ് ഹാപ്റ്റ്സ് ആണ്, അതിന്റെ നീളം കുറഞ്ഞത് 3 ആണെങ്കിൽ, തുടർച്ചയായ 3 അക്ഷരങ്ങൾ ഓരോന്നും വ്യത്യസ്തമാണ്.\/\/നിങ്ങളുടെ ജോലി സ്ട്രിംഗ് ഹാപ്പ്ടാണോ അല്ലയോ എന്ന് പരിശോധിക്കുക എന്നതാണ്.\/\/നിങ്ങള് ക്ക് ഒരു സ്ട്രിംഗ് ലഭിക്കുന്നു.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunction is_happy(s: string): boolean {\n","canonical_solution":"function is_happy(s: string): boolean {\n    if (s.length < 3) return false;\n\n    for (let i = 0; i <= s.length - 3; i++) {\n        const set = new Set(s.substring(i, i + 3));\n        if (set.size !== 3) {\n            return false;\n        }\n    }\n    \n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_happy;\n  assert.deepEqual(candidate(\"a\"),false);\n  assert.deepEqual(candidate(\"aa\"),false);\n  assert.deepEqual(candidate(\"abcd\"),true);\n  assert.deepEqual(candidate(\"aabb\"),false);\n  assert.deepEqual(candidate(\"adb\"),true);\n  assert.deepEqual(candidate(\"xyy\"),false);\n  assert.deepEqual(candidate(\"iopaxpoi\"),true);\n  assert.deepEqual(candidate(\"iopaxioi\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_81","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/0.0 E യും\/\/> 0.0 ഡി - \/\/> 0.7 ഡി \/\/> 1.0 ഡി + \/\/> 1.3 C- യും\/\/> 1.7 C യും\/\/> 2.0 സി + \/\/> 2.3 ബി - \/\/> 2.7 ബി \/\/> 3.0 ബി + \/\/> 3.3 എ- \/\/> 3.7 എ \/\/4.0 എ+ \/\/ജി.പി.എ. . . അക്ഷര ഗ്രേഡ്\/\/താഴെ പറയുന്ന പട്ടിക ഉപയോഗിച്ച് അക്ഷരങ്ങളുടെ ഗ്രേഡുകളുടെ ഒരു അറേ ഔട്ട്പുട്ട് ചെയ്യാൻ കഴിയുന്ന ഒരു ഫംഗ്ഷൻ: \/\/ചില വിദ്യാര് ഥികളുടെ ജി. പി. എ. കളുടെ ഒരു നിര അവൾ നിനക്ക് തന്നു. നീ എഴുതണം.\/\/പക്ഷെ, അവൾക്ക് അവളുടെ കോഡ് നഷ്ടപ്പെട്ടു.\/\/അധ്യാപിക സ്വന്തം അൽഗോരിതം വികസിപ്പിച്ചെടുത്തിട്ടുണ്ട്.\/\/സെമസ്റ്ററിന്റെ അവസാന ആഴ്ചയാണ്, അധ്യാപകന് ഗ്രേഡുകള് നല് കണം.\/\/ >>> grade_equation([4.0, 3, 1.7, 2, 3.5])\n\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunction numerical_letter_grade(grades: number[]): string[] {\n","canonical_solution":"function numerical_letter_grade(grades: number[]): string[] {\n    return grades.map(gpa => {\n        if (gpa === 4.0) return \"A+\";\n        if (gpa > 3.7) return \"A\";\n        if (gpa > 3.3) return \"A-\";\n        if (gpa > 3.0) return \"B+\";\n        if (gpa > 2.7) return \"B\";\n        if (gpa > 2.3) return \"B-\";\n        if (gpa > 2.0) return \"C+\";\n        if (gpa > 1.7) return \"C\";\n        if (gpa > 1.3) return \"C-\";\n        if (gpa > 1.0) return \"D+\";\n        if (gpa > 0.7) return \"D\";\n        if (gpa > 0.0) return \"D-\";\n        return \"E\";\n    });\n}\n\n\/\/ Example usage:\n\/\/ console.log(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5])); \/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = numerical_letter_grade;\n  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[\"A+\", \"B\", \"C-\", \"C\", \"A-\"]);\n  assert.deepEqual(candidate([1.2]),[\"D+\"]);\n  assert.deepEqual(candidate([0.5]),[\"D-\"]);\n  assert.deepEqual(candidate([0.0]),[\"E\"]);\n  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[\"D\", \"D-\", \"C-\", \"B\", \"B+\"]);\n  assert.deepEqual(candidate([0.0, 0.7]),[\"E\", \"D-\"]);\n}\n\ntest();"},{"task_id":"HumanEval_82","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/നീളം ഒരു പ്രൈം നമ്പറാണോ അതോ തെറ്റാണോ?\/\/ഒരു സ്ട്രിംഗ് എടുത്ത്  സ്ട്രിംഗ്  ആണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.\/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunction prime_length(string: string): boolean {\n","canonical_solution":"function prime_length(string: string): boolean {\n    const length = string.length;\n\n    if (length < 2) return false;\n\n    for (let i = 2; i * i <= length; i++) {\n        if (length % i === 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prime_length;\n  assert.deepEqual(candidate(\"Hello\"),true);\n  assert.deepEqual(candidate(\"abcdcba\"),true);\n  assert.deepEqual(candidate(\"kittens\"),true);\n  assert.deepEqual(candidate(\"orange\"),false);\n  assert.deepEqual(candidate(\"wow\"),true);\n  assert.deepEqual(candidate(\"world\"),true);\n  assert.deepEqual(candidate(\"MadaM\"),true);\n  assert.deepEqual(candidate(\"Wow\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"HI\"),true);\n  assert.deepEqual(candidate(\"go\"),true);\n  assert.deepEqual(candidate(\"gogo\"),false);\n  assert.deepEqual(candidate(\"aaaaaaaaaaaaaaa\"),false);\n  assert.deepEqual(candidate(\"Madam\"),true);\n  assert.deepEqual(candidate(\"M\"),false);\n  assert.deepEqual(candidate(\"0\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_83","nl":"mal_Mlym","pl":"ts","prompt":"\/\/പോസിറ്റീവ് സംഖ്യകളാണ് 1 കൊണ്ട് തുടങ്ങുന്നതും അവസാനിക്കുന്നതും.\/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n ഉണ്ടെങ്കിൽ, n-അക്ക സംഖ്യകളുടെ എണ്ണം തിരികെ നൽകുക function starts_one_ends(n: number): number {\n","canonical_solution":"function starts_one_ends(n: number): number {\n    if (n === 1) {\n        return 1; \/\/ The number '1' is the only 1-digit number starting or ending with '1'\n    }\n\n    const totalNumbers = Math.pow(10, n - 1); \/\/ Total n-digit numbers starting with any digit from 1 to 9\n    const startingWithOne = Math.pow(10, n - 1); \/\/ The n-digit numbers starting with '1'\n    const endingWithOne = Math.pow(10, n - 1); \/\/ The n-digit numbers ending with '1'\n    const startingAndEndingWithOne = Math.pow(10, n - 2); \/\/ The n-digit numbers starting and ending with '1' \n\n    \/\/ To find numbers that start or end with 1, add those starting with 1 \n    \/\/ and those ending with 1, then subtract the overlap (those both starting and ending with 1).\n    return startingWithOne + endingWithOne - startingAndEndingWithOne;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = starts_one_ends;\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(2),18);\n  assert.deepEqual(candidate(3),180);\n  assert.deepEqual(candidate(4),1800);\n  assert.deepEqual(candidate(5),18000);\n}\n\ntest();"},{"task_id":"HumanEval_84","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം \/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ N നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിന്റെ അക്കങ്ങളുടെ ആകെത്തുക ബൈനറിയിൽ നൽകുക. \/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunction solve(N: number): string {\n","canonical_solution":"function solve(N: number): string {\n    let sumOfDigits = 0;\n    while (N > 0) {\n        sumOfDigits += N % 10;\n        N = Math.floor(N \/ 10);\n    }\n    return sumOfDigits.toString(2);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(1000),\"1\");\n  assert.deepEqual(candidate(150),\"110\");\n  assert.deepEqual(candidate(147),\"1100\");\n  assert.deepEqual(candidate(333),\"1001\");\n  assert.deepEqual(candidate(963),\"10010\");\n}\n\ntest();"},{"task_id":"HumanEval_85","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഒരു നോൺ-ശൂന്യമായ അറേയിൽ ആദ്യം, ഇരട്ട സംഖ്യകളുടെ സംഖ്യകൾ കൂട്ടുക.\/\/ >>> add([4, 2, 6, 7])\n\/\/ 2\nfunction add(lst: number[]): number {\n","canonical_solution":"function add(lst: number[]): number {\n    return lst.reduce((sum, num, index) => {\n        if (index % 2 === 1 && num % 2 === 0) {\n            return sum + num;\n        }\n        return sum;\n    }, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add;\n  assert.deepEqual(candidate([4, 88]),88);\n  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);\n  assert.deepEqual(candidate([4, 0, 6, 7]),0);\n  assert.deepEqual(candidate([4, 4, 6, 8]),12);\n}\n\ntest();"},{"task_id":"HumanEval_86","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/കുറിപ്പ്: വാക്യത്തിലെ വാക്കുകളുടെയും ശൂന്യസ്ഥലങ്ങളുടെയും ക്രമം പാലിക്കണം.\/\/ASCII മൂല്യം അടിസ്ഥാനമാക്കിയുള്ള വർധന ക്രമം.\/\/യില് ക്രമീകരിച്ചിരിക്കുന്ന എല്ലാ പ്രതീകങ്ങളും അടങ്ങുന്ന പുതിയ വാക്കാണ് പകരം വയ്ക്കുന്നത്.\/\/സ്ട്രിങ്ങിന്റെ ക്രമപ്പെടുത്തിയ പതിപ്പ്, എല്ലാ വാക്കുകളും (സ്പേസ് ഉപയോഗിച്ച് വേർതിരിച്ച്) \/\/ഒരു സ്ട്രിംഗ് എടുത്ത് അതിന്റെ ക്രമീകരിച്ച പതിപ്പ് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunction anti_shuffle(s: string): string {\n","canonical_solution":"function anti_shuffle(s: string): string {\n  return s.split(' ').map(word =>\n    word.split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')\n  ).join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = anti_shuffle;\n  assert.deepEqual(candidate(\"Hi\"),\"Hi\");\n  assert.deepEqual(candidate(\"hello\"),\"ehllo\");\n  assert.deepEqual(candidate(\"number\"),\"bemnru\");\n  assert.deepEqual(candidate(\"abcd\"),\"abcd\");\n  assert.deepEqual(candidate(\"Hello World!!!\"),\"Hello !!!Wdlor\");\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n\ntest();"},{"task_id":"HumanEval_87","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/കൂടാതെ, നിരയുടെ കോർഡിനേറ്റുകളെ നിരകളുടെ ക്രമത്തിൽ ക്രമീകരിക്കുക.\/\/കോർഡിനേറ്റുകളെ ആദ്യം കയറിവരുന്ന ക്രമത്തിൽ വരികളായി അടുക്കുക.\/\/ഓരോ അറേയും ഒരു കോർഡിനേറ്റ് ആണ് - (വരി, നിരകൾ), 0 മുതൽ തുടങ്ങുന്നു.\/\/പിന്നെ arrays ന്റെ arrays തിരിച്ചു കൊടുക്കുക, [(x1, y1), (x2, y2) ...] അങ്ങനെ \/\/lst, x എന്ന സംഖ്യകൾ തന്നാൽ,  ന്റെ ശ്രേണിയിൽ x എന്ന സംഖ്യകൾ കണ്ടെത്തുക.\/\/ഓരോ വരിയിലും വ്യത്യസ്ത എണ്ണം നിരകളുണ്ടാകാം.\/\/മാട്രിക്സിനു സമാനമായ, മാട്രിക്സുകൾക്ക് വിപരീതമായി,\/\/നിങ്ങള് ക്ക് ഒരു 2 ഡി ഡാറ്റ നല് കിയിട്ടുണ്ട്, ഒരു നെസ്റ്റഡ് അറേ ആയി,\/\/ >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n\/\/ [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\/\/ >>> get_row([], 1)\n\/\/ []\n\/\/ >>> get_row([[], [1], [1, 2, 3]], 3)\n\/\/ [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n","canonical_solution":"function get_row(lst: number[][], x: number): [number, number][] {\n    const coordinates: [number, number][] = [];\n\n    \/\/ Traverse the data matrix\n    lst.forEach((row, rowIndex) => {\n        row.forEach((value, colIndex) => {\n            if (value === x) {\n                coordinates.push([rowIndex, colIndex]);\n            }\n        });\n    });\n\n    \/\/ Sort the coordinates\n    coordinates.sort(([row1, col1], [row2, col2]) => {\n        if (row1 === row2) {\n            \/\/ Sort by columns in descending order\n            return col2 - col1;\n        }\n        \/\/ Sort by rows in ascending order\n        return row1 - row2;\n    });\n\n    return coordinates;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();"},{"task_id":"HumanEval_88","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/* തന്നിരിക്കുന്ന അറേ മാറ്റരുത്. \/\/കുറിപ്പ്:\/\/അല്ലെങ്കിൽ, സംഖ്യ ((ആദ്യ സൂചിക മൂല്യം, അവസാന സൂചിക മൂല്യം) ഇരട്ടയാണെങ്കിൽ, അത് താഴേയ്ക്ക് ക്രമീകരിക്കുക.\/\/നിങ്ങള് ഈ അറേയെ ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം\/\/ഒരു അറേ നോൺ-നെഗറ്റീവ് ഇന്റഗ്രൽസ് തന്നാൽ, ക്രമീകരണത്തിനു ശേഷം നൽകിയ അറേയുടെ ഒരു കോട്ട്സ് തിരികെ നൽകുക,\/\/ >>> sort_array([])\n\/\/ []\n\/\/ >>> sort_array([5])\n\/\/ [5]\n\/\/ >>> sort_array([2, 4, 3, 0, 1, 5])\n\/\/ [0, 1, 2, 3, 4, 5]\n\/\/ >>> sort_array([2, 4, 3, 0, 1, 5, 6])\n\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunction sort_array(array: number[]): number[] {\n","canonical_solution":"function sort_array(array: number[]): number[] {\n    if (array.length === 0) {\n        return [];\n    }\n\n    const firstValue = array[0];\n    const lastValue = array[array.length - 1];\n    const sum = firstValue + lastValue;\n\n    const sortedArray = [...array].sort((a, b) => a - b);\n\n    if (sum % 2 === 0) {\n        return sortedArray.reverse();\n    } else {\n        return sortedArray;\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5]),[5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);\n  assert.deepEqual(candidate([2, 1]),[1, 2]);\n  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);\n  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);\n}\n\ntest();"},{"task_id":"HumanEval_89","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/രണ്ട് സ്ഥലത്ത് നിന്ന് താഴേക്ക് മാറുക.\/\/അക്ഷരമാലയില് അക്ഷരങ്ങള് \/\/അക്ഷരമാല തിരിക്കുമ്പോള് ഒരു എൻക്രിപ്റ്റ് ചെയ്ത സ്ട്രിംഗ് തിരിച്ചുനല്കുന്നു.\/\/ഒരു സ്ട്രിംഗ് ഒരു ആർഗ്യുമെന്റായി എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ എൻക്രിപ്റ്റ് സൃഷ്ടിക്കുക, \/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunction encrypt(s: string): string {\n","canonical_solution":"function encrypt(s: string): string {\n    const shift = 2 * 2; \/\/ Shift by 4 places\n    const alphabetSize = 26;\n    \n    return s.split('').map(char => {\n        const charCode = char.charCodeAt(0);\n        \n        \/\/ Check if the character is a lowercase letter\n        if (charCode >= 97 && charCode <= 122) {\n            let newCharCode = charCode + shift;\n            \n            \/\/ Wrap around if it goes past 'z'\n            if (newCharCode > 122) {\n                newCharCode = (newCharCode - 97) % alphabetSize + 97;\n            }\n            \n            return String.fromCharCode(newCharCode);\n        }\n\n        \/\/ Return the character unchanged if it's not a lowercase letter\n        return char;\n    }).join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = encrypt;\n  assert.deepEqual(candidate(\"hi\"),\"lm\");\n  assert.deepEqual(candidate(\"asdfghjkl\"),\"ewhjklnop\");\n  assert.deepEqual(candidate(\"gf\"),\"kj\");\n  assert.deepEqual(candidate(\"et\"),\"ix\");\n  assert.deepEqual(candidate(\"faewfawefaewg\"),\"jeiajeaijeiak\");\n  assert.deepEqual(candidate(\"hellomyfriend\"),\"lippsqcjvmirh\");\n  assert.deepEqual(candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"),\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n  assert.deepEqual(candidate(\"a\"),\"e\");\n}\n\ntest();"},{"task_id":"HumanEval_90","nl":"mal_Mlym","pl":"ts","prompt":"\/\/അത്തരം ഒരു ഘടകം ഇല്ലെങ്കിൽ undefined തിരികെ നൽകുക.\/\/ഒരു ഫങ്ഷൻ എഴുതുക, അത് അറേയിലെ രണ്ടാമത്തെ ചെറിയ എലമെന്റ് നൽകുന്നു.\/\/നിങ്ങള് ക്ക് ഒരു അറേ ഇന്റര് നമ്പര് കള് കിട്ടും.\/\/ >>> next_smallest([1, 2, 3, 4, 5])\n\/\/ 2\n\/\/ >>> next_smallest([5, 1, 4, 3, 2])\n\/\/ 2\n\/\/ >>> next_smallest([])\n\/\/ undefined\n\/\/ >>> next_smallest([1, 1])\n\/\/ undefined\nfunction next_smallest(lst: number[]): number | undefined {\n","canonical_solution":"function next_smallest(lst: number[]): number | undefined {\n    if (lst.length < 2) {\n        return undefined;\n    }\n    \n    let first: number | undefined = undefined;\n    let second: number | undefined = undefined;\n    \n    for (let num of lst) {\n        if (first === undefined || num < first) {\n            second = first;\n            first = num;\n        } else if (num > first && (second === undefined || num < second)) {\n            second = num;\n        }\n    }\n\n    return second;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = next_smallest;\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);\n  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);\n}\n\ntest();"},{"task_id":"HumanEval_91","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/വാക്യങ്ങള് ക്ക് '', '?' അഥവാ '!' എന്നീ അക്ഷരങ്ങള് ഉപയോഗിച്ച് പരിധിയുണ്ടാക്കും.\/\/\"I\" എന്ന വാക്കിൽ തുടങ്ങുന്ന ഒരു വാക്യമാണ് ബോറടിക്കൽ.\/\/നിങ്ങള് ക്ക് ഒരു വാക്ക് കിട്ടും, നിങ്ങളുടെ ജോലി അത് എണ്ണുക എന്നതാണ്.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunction is_bored(S: string): number {\n","canonical_solution":"function is_bored(S: string): number {\n    \/\/ Split the string into sentences using '.', '?' or '!' as delimiters\n    const sentences = S.split(\/[.!?]\/);\n\n    \/\/ Filter sentences that start with \"I\" and count them\n    const boredomCount = sentences.filter(sentence => sentence.trim().startsWith('I')).length;\n\n    return boredomCount;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_bored;\n  assert.deepEqual(candidate(\"Hello world\"),0);\n  assert.deepEqual(candidate(\"Is the sky blue?\"),0);\n  assert.deepEqual(candidate(\"I love It !\"),1);\n  assert.deepEqual(candidate(\"bIt\"),0);\n  assert.deepEqual(candidate(\"I feel good today. I will be productive. will kill It\"),2);\n  assert.deepEqual(candidate(\"You and I are going for a walk\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_92","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/എല്ലാ കേസുകളിലും തെറ്റാണ്.\/\/ഒരു സംഖ്യ മറ്റു രണ്ടിന്റെയും ആകെത്തുകയ്ക്ക് തുല്യമാണെങ്കിൽ, എല്ലാ സംഖ്യകളും പൂർണ്ണസംഖ്യകളാണെങ്കിൽ, ഇത് ശരിയായി നൽകുന്നു.\/\/3 സംഖ്യകൾ എടുക്കുന്ന ഒരു ഫങ്ഷൻ ഉണ്ടാക്കുക.\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunction any_int(x: number, y: number, z: number): boolean {\n","canonical_solution":"function any_int(x: number, y: number, z: number): boolean {\n    \/\/ Check if all numbers are integers\n    if (!Number.isInteger(x) || !Number.isInteger(y) || !Number.isInteger(z)) {\n        return false;\n    }\n    \/\/ Check if one of the numbers is the sum of the other two\n    if (x === y + z || y === x + z || z === x + y) {\n        return true;\n    }\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = any_int;\n  assert.deepEqual(candidate(2, 3, 1),true);\n  assert.deepEqual(candidate(2.5, 2, 3),false);\n  assert.deepEqual(candidate(1.5, 5, 3.5),false);\n  assert.deepEqual(candidate(2, 6, 2),false);\n  assert.deepEqual(candidate(4, 2, 2),true);\n  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);\n  assert.deepEqual(candidate(-4, 6, 2),true);\n  assert.deepEqual(candidate(2, 1, 1),true);\n  assert.deepEqual(candidate(3, 4, 7),true);\n  assert.deepEqual(candidate(3.0, 4, 7),false);\n}\n\ntest();"},{"task_id":"HumanEval_93","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/അക്ഷരങ്ങള് മാത്രം കരുതുക.\/\/ഇംഗ്ലീഷ് അക്ഷരമാലയിലെ സ്വരാക്ഷരം.\/\/ആ സന്ദേശത്തിന് മുന്നില് രണ്ടു സ്ഥാനങ്ങളില് വരുന്ന അക്ഷരം ഉപയോഗിച്ച്.\/\/എല്ലാ അക്ഷരങ്ങളും മാറ്റി,  യിലെ എല്ലാ സ്വരാക്ഷരങ്ങളും മാറ്റി.\/\/ഒരു സന്ദേശം എടുത്ത്,  എന്ന രീതിയിൽ എൻകോഡ് ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.\/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunction encode(message: string): string {\n","canonical_solution":"function encode(message: string): string {\n    const swapCase = (char: string): string => {\n        if (char === char.toLowerCase()) {\n            return char.toUpperCase();\n        } else {\n            return char.toLowerCase();\n        }\n    };\n\n    const replaceVowel = (char: string): string => {\n        const vowels = 'aeiou';\n        const nextVowels = 'cgkqw';\n        const index = vowels.indexOf(char.toLowerCase());\n        if (index !== -1) {\n            return char === char.toLowerCase() \n                ? nextVowels[index] \n                : nextVowels[index].toUpperCase();\n        }\n        return char;\n    };\n\n    return message\n        .split('')\n        .map(char => swapCase(replaceVowel(char)))\n        .join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = encode;\n  assert.deepEqual(candidate(\"TEST\"),\"tgst\");\n  assert.deepEqual(candidate(\"Mudasir\"),\"mWDCSKR\");\n  assert.deepEqual(candidate(\"YES\"),\"ygs\");\n  assert.deepEqual(candidate(\"This is a message\"),\"tHKS KS C MGSSCGG\");\n  assert.deepEqual(candidate(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT kNqW wHcT Tq wRkTg\");\n}\n\ntest();"},{"task_id":"HumanEval_94","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഏറ്റവും വലിയ പ്രൈം മൂല്യം കണ്ടെത്തി അതിന്റെ അക്കങ്ങളുടെ സംഖ്യ തിരികെ നൽകണം.\/\/നിങ്ങള് ക്ക് ഒരു അറേ ഇന്റര് നമ്പര് കള് കിട്ടും.\/\/ >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/ 10\n\/\/ >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/ 25\n\/\/ >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/ 13\n\/\/ >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/ 11\n\/\/ >>> skjkasdkd([0, 81, 12, 3, 1, 21])\n\/\/ 3\n\/\/ >>> skjkasdkd([0, 8, 1, 2, 1, 7])\n\/\/ 7\nfunction skjkasdkd(lst: number[]): number {\n","canonical_solution":"function isPrime(n: number): boolean {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction sumOfDigits(n: number): number {\n    let sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n = Math.floor(n \/ 10);\n    }\n    return sum;\n}\n\nfunction skjkasdkd(lst: number[]): number {\n    let maxPrime = -1;\n\n    for (const num of lst) {\n        if (isPrime(num) && num > maxPrime) {\n            maxPrime = num;\n        }\n    }\n\n    return maxPrime === -1 ? 0 : sumOfDigits(maxPrime);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = skjkasdkd;\n  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);\n  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);\n  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);\n  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);\n  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);\n  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);\n  assert.deepEqual(candidate([8191]),19);\n  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);\n  assert.deepEqual(candidate([127, 97, 8192]),10);\n}\n\ntest();"},{"task_id":"HumanEval_95","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഫങ്ഷൻ false എന്ന് റിട്ടേൺ ചെയ്യണം, കാരണം അത് ശൂന്യമാണ്.\/\/എല്ലാ കീകളും വലിയക്ഷരങ്ങളുള്ള സ്ട്രിങ്ങുകളാണെങ്കിൽ, അല്ലെങ്കിൽ false നൽകുക.\/\/ഒരു വസ്തുവിനെ കണക്കിലെടുക്കുമ്പോൾ, എല്ലാ കീകളും താഴത്തെ യിലെ സ്ട്രിങ്ങുകളാണെങ്കിൽ true തിരികെ നൽകുക.\/\/ >>> check_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunction check_dict_case(dict: {[key: string]: string}): boolean {\n","canonical_solution":"function check_dict_case(dict: { [key: string]: string }): boolean {\n    const keys = Object.keys(dict);\n    if (keys.length === 0) return false;\n\n    const allLowerCase = keys.every(key => key === key.toLowerCase());\n    const allUpperCase = keys.every(key => key === key.toUpperCase());\n\n    return allLowerCase || allUpperCase;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = check_dict_case;\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"b\": \"banana\"}),true);\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}),false);\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}),false);\n  assert.deepEqual(candidate({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}),false);\n  assert.deepEqual(candidate({\"STATE\": \"NC\", \"ZIP\": \"12345\"}),true);\n  assert.deepEqual(candidate({\"fruit\": \"Orange\", \"taste\": \"Sweet\"}),true);\n  assert.deepEqual(candidate({}),false);\n}\n\ntest();"},{"task_id":"HumanEval_96","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/യും n യും കുറവുള്ള അസംഖ്യകളാണ്.\/\/ഒരു നോൺ-നെഗറ്റീവ് ഇന്റീജർ എടുക്കുകയും ആദ്യത്തെ n ന്റെ ഒരു അറേ മടക്കുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ നടപ്പിലാക്കുക.\/\/ >>> count_up_to(5)\n\/\/ [2, 3]\n\/\/ >>> count_up_to(11)\n\/\/ [2, 3, 5, 7]\n\/\/ >>> count_up_to(0)\n\/\/ []\n\/\/ >>> count_up_to(20)\n\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/ >>> count_up_to(1)\n\/\/ []\n\/\/ >>> count_up_to(18)\n\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunction count_up_to(n: number): number[] {\n","canonical_solution":"function count_up_to(n: number): number[] {\n    function isPrime(num: number): boolean {\n        if (num < 2) return false;\n        for (let i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    }\n\n    const primes: number[] = [];\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n    }\n\n    return primes;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_up_to;\n  assert.deepEqual(candidate(5),[2, 3]);\n  assert.deepEqual(candidate(6),[2, 3, 5]);\n  assert.deepEqual(candidate(7),[2, 3, 5]);\n  assert.deepEqual(candidate(10),[2, 3, 5, 7]);\n  assert.deepEqual(candidate(0),[]);\n  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);\n  assert.deepEqual(candidate(1),[]);\n  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);\n  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n\ntest();"},{"task_id":"HumanEval_97","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഇൻപുട്ട് എല്ലായ്പ്പോഴും സാധുവാണെന്ന് കരുതുക.\/\/അവരുടെ യൂണിറ്റ് അക്കങ്ങളുടെ ഗുണനം.\/\/രണ്ട് പൂർണ്ണസംഖ്യകളെ എടുക്കുന്ന ഫങ്ഷൻ പൂര് ത്തിയാക്കുകയും \/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunction multiply(a: number, b: number): number {\n","canonical_solution":"function multiply(a: number, b: number): number {\n    const unitDigitA = Math.abs(a) % 10;\n    const unitDigitB = Math.abs(b) % 10;\n    return unitDigitA * unitDigitB;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = multiply;\n  assert.deepEqual(candidate(148, 412),16);\n  assert.deepEqual(candidate(19, 28),72);\n  assert.deepEqual(candidate(2020, 1851),0);\n  assert.deepEqual(candidate(14, -15),20);\n  assert.deepEqual(candidate(76, 67),42);\n  assert.deepEqual(candidate(17, 27),49);\n  assert.deepEqual(candidate(0, 1),0);\n  assert.deepEqual(candidate(0, 0),0);\n}\n\ntest();"},{"task_id":"HumanEval_98","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/ഒരു സ്ട്രിംഗ് s കൊടുത്താൽ, വലിയ അക്ഷരങ്ങളിലുള്ള വോക്കലുകളുടെ എണ്ണം കണക്കുകൂട്ടുക.\/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunction count_upper(s: string): number {\n","canonical_solution":"function count_upper(s: string): number {\n    const uppercaseVowels = new Set(['A', 'E', 'I', 'O', 'U']);\n    let count = 0;\n    \n    for (let i = 0; i < s.length; i += 2) {\n        if (uppercaseVowels.has(s[i])) {\n            count++;\n        }\n    }\n    \n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_upper;\n  assert.deepEqual(candidate(\"aBCdEf\"),1);\n  assert.deepEqual(candidate(\"abcdefg\"),0);\n  assert.deepEqual(candidate(\"dBBE\"),0);\n  assert.deepEqual(candidate(\"B\"),0);\n  assert.deepEqual(candidate(\"U\"),1);\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"EEEE\"),2);\n}\n\ntest();"},{"task_id":"HumanEval_99","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/രണ്ട് പൂർണ്ണസംഖ്യകളിൽ നിന്നും, അത് പൂജ്യത്തിൽ നിന്നും കുറയ്ക്കുക.\/\/യും അതിന് ഏറ്റവും അടുത്തുള്ള പൂർണ്ണസംഖ്യയും തിരികെ നൽകുന്നു.\/\/ഒരു സംഖ്യയെ പ്രതിനിധീകരിക്കുന്ന ഒരു മൂല്യം (സ്ട്രിംഗ്) എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക \/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunction closest_integer(value: string): number {\n","canonical_solution":"function closest_integer(value: string): number {\n  const num = parseFloat(value);\n  if (num > 0) {\n    return Math.floor(num + 0.5);\n  } else {\n    return Math.ceil(num - 0.5);\n  }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = closest_integer;\n  assert.deepEqual(candidate(\"10\"),10);\n  assert.deepEqual(candidate(\"14.5\"),15);\n  assert.deepEqual(candidate(\"-15.5\"),-16);\n  assert.deepEqual(candidate(\"15.3\"),15);\n  assert.deepEqual(candidate(\"0\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_100","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/i എന്നത് നിലയിലെ കല്ലുകളുടെ എണ്ണം (i+1) ആണ്.\/\/ഒരു അറേയിലെ ഓരോ ലെവലിലും ഉള്ള കല്ലുകളുടെ എണ്ണം തിരികെ നൽകുന്നു, അവിടെ ഘടകം സൂചികയിൽ \/\/- അടുത്ത ഇരട്ട സംഖ്യ n ഇരട്ട ആണെങ്കിൽ.\/\/- അടുത്ത ഇരട്ട സംഖ്യ n ഇരട്ട ആണെങ്കിൽ.\/\/അടുത്ത ലെവലിലെ കല്ലുകളുടെ എണ്ണം: \/\/ആദ്യ നിലയില് n കല്ലുകളുണ്ട്.\/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n ഉണ്ടെങ്കിൽ, നിങ്ങൾ n ലെവൽ കല്ലുകൾ ഒരു കൂമ്പാരം ഉണ്ടാക്കണം.\/\/ >>> make_a_pile(3)\n\/\/ [3, 5, 7]\nfunction make_a_pile(n: number): number[] {\n","canonical_solution":"function make_a_pile(n: number): number[] {\n    const result: number[] = [];\n    let currentStones = n;\n    for (let i = 0; i < n; i++) {\n        result.push(currentStones);\n        if (currentStones % 2 === 0) {\n            currentStones += 2; \/\/ next even number\n        } else {\n            currentStones += 2; \/\/ next odd number\n        }\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = make_a_pile;\n  assert.deepEqual(candidate(3),[3, 5, 7]);\n  assert.deepEqual(candidate(4),[4, 6, 8, 10]);\n  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);\n  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);\n  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);\n}\n\ntest();"},{"task_id":"HumanEval_101","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/സ്ട്രിംഗ് വാക്കുകളായി വിഭജിച്ച് വാക്കുകളുടെ ഒരു ശ്രേണി തിരികെ നൽകുക.\/\/നിങ്ങള് ക്ക് കോമകളോ സ്പെയ്സുകളോ ഉപയോഗിച്ച് വേര് തിരിക്കപ്പെട്ട വാക്കുകള് നല് കും.\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunction words_string(s: string): string[] {\n","canonical_solution":"function words_string(s: string): string[] {\n    return s.split(\/[\\s,]+\/).filter(word => word.length > 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = words_string;\n  assert.deepEqual(candidate(\"Hi, my name is John\"),[\"Hi\", \"my\", \"name\", \"is\", \"John\"]);\n  assert.deepEqual(candidate(\"One, two, three, four, five, six\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]);\n  assert.deepEqual(candidate(\"Hi, my name\"),[\"Hi\", \"my\", \"name\"]);\n  assert.deepEqual(candidate(\"One,, two, three, four, five, six,\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]);\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"ahmed     , gamal\"),[\"ahmed\", \"gamal\"]);\n}\n\ntest();"},{"task_id":"HumanEval_102","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/അത്തരമൊരു സംഖ്യ ഇല്ല, അപ്പോൾ ഫംഗ്ഷൻ -1 തിരികെ നൽകണം.\/\/[x, y] പരിധിയിലുള്ള ഏറ്റവും വലിയ സമസംഖ്യ.\/\/ഈ ഫങ്ഷൻ രണ്ട് പോസിറ്റീവ് നമ്പറുകളായ x, y എന്നിവ എടുക്കുകയും  എന്ന ഫലം നൽകുകയും ചെയ്യുന്നു.\/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunction choose_num(x: number, y: number): number {\n","canonical_solution":"function choose_num(x: number, y: number): number {\n    \/\/ Ensure x is less than or equal to y for proper range searching\n    if (x > y) {\n        [x, y] = [y, x];\n    }\n    \n    \/\/ Start looking from the upper bound of the range\n    for (let i = y; i >= x; i--) {\n        if (i % 2 === 0) {\n            return i;\n        }\n    }\n    \n    \/\/ If no even number is found in the range\n    return -1;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = choose_num;\n  assert.deepEqual(candidate(12, 15),14);\n  assert.deepEqual(candidate(13, 12),-1);\n  assert.deepEqual(candidate(33, 12354),12354);\n  assert.deepEqual(candidate(5234, 5233),-1);\n  assert.deepEqual(candidate(6, 29),28);\n  assert.deepEqual(candidate(27, 10),-1);\n  assert.deepEqual(candidate(7, 7),-1);\n  assert.deepEqual(candidate(546, 546),546);\n}\n\ntest();"},{"task_id":"HumanEval_103","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/n m നേക്കാൾ വലുതാണെങ്കിൽ, -1 തിരികെ നൽകുക.\/\/ഉത്തരം അടുത്തുള്ള പൂർണ്ണസംഖ്യയിലേക്ക് ചുരുക്കുക, അതിനെ ബൈനറി ആയി പരിവർത്തനം ചെയ്യുക.\/\/n മുതൽ m വരെയുള്ള (n ഉം m ഉം ഉൾപ്പെടെ) മുഴുവൻ സംഖ്യകളുടെ ശരാശരി.\/\/നിങ്ങള് ക്ക് രണ്ട് പോസിറ്റീവ് ഇന്റര് നമ്പറുകള് n ഉം m ഉം നല് കിയിട്ടുണ്ട്, നിങ്ങളുടെ ജോലി \/\/ >>> rounded_avg(1, 5)\n\/\/ \"0b11\"\n\/\/ >>> rounded_avg(7, 5)\n\/\/ -1\n\/\/ >>> rounded_avg(10, 20)\n\/\/ \"0b1111\"\n\/\/ >>> rounded_avg(20, 33)\n\/\/ \"0b11010\"\nfunction rounded_avg(n: number, m: number): string | number {\n","canonical_solution":"function rounded_avg(n: number, m: number): string | number {\n    if (n > m) {\n        return -1;\n    }\n\n    const count = m - n + 1;\n    let sum = 0;\n    \n    for (let i = n; i <= m; i++) {\n        sum += i;\n    }\n\n    const avg = sum \/ count;\n    const roundedAvg = Math.round(avg);\n    return \"0b\" + roundedAvg.toString(2);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rounded_avg;\n  assert.deepEqual(candidate(1, 5),\"0b11\");\n  assert.deepEqual(candidate(7, 13),\"0b1010\");\n  assert.deepEqual(candidate(964, 977),\"0b1111001010\");\n  assert.deepEqual(candidate(996, 997),\"0b1111100100\");\n  assert.deepEqual(candidate(560, 851),\"0b1011000010\");\n  assert.deepEqual(candidate(185, 546),\"0b101101110\");\n  assert.deepEqual(candidate(362, 496),\"0b110101101\");\n  assert.deepEqual(candidate(350, 902),\"0b1001110010\");\n  assert.deepEqual(candidate(197, 233),\"0b11010111\");\n  assert.deepEqual(candidate(7, 5),-1);\n  assert.deepEqual(candidate(5, 1),-1);\n  assert.deepEqual(candidate(5, 5),\"0b101\");\n}\n\ntest();"},{"task_id":"HumanEval_104","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/കുറിപ്പ്: മടക്കിയ അറേ ക്രമം വർദ്ധിക്കുന്ന ക്രമത്തിൽ ക്രമീകരിക്കണം.\/\/ഇരട്ട അക്കങ്ങളൊന്നും ഇല്ലാത്ത മൂലകങ്ങൾ.\/\/പോസിറ്റീവ് ഇന്റഗ്രൽസ് x ന്റെ ഒരു അറേ തന്നാൽ, എല്ലാ  ന്റെയും ഒരു സോർട്ടുചെയ്ത അറേ മടക്കിനൽകുന്നു.\/\/ >>> unique_digits([15, 33, 1422, 1])\n\/\/ [1, 15, 33]\n\/\/ >>> unique_digits([152, 323, 1422, 10])\n\/\/ []\nfunction unique_digits(x: number[]): number[] {\n","canonical_solution":"function unique_digits(x: number[]): number[] {\n    \/\/ Helper function to check if a number has any even digit\n    const hasEvenDigit = (num: number): boolean => {\n        while (num > 0) {\n            const digit = num % 10;\n            if (digit % 2 === 0) return true;\n            num = Math.floor(num \/ 10);\n        }\n        return false;\n    };\n\n    \/\/ Filter out numbers without even digits and sort them\n    return x.filter(num => !hasEvenDigit(num)).sort((a, b) => a - b);\n}\n\n\/\/ Example usage:\nconsole.log(unique_digits([15, 33, 1422, 1])); \/\/ [1, 15, 33]\nconsole.log(unique_digits([152, 323, 1422, 10])); \/\/ []","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = unique_digits;\n  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);\n  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);\n  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);\n  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);\n}\n\ntest();"},{"task_id":"HumanEval_105","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/ഒന്ന്, രണ്ട്, മൂന്ന്, നാല്, അഞ്ച്, ആറ്, ഏഴ്, എട്ട്, ഒമ്പത്.\/\/യില് നിന്നും ഓരോ അക്കം അതിന്റെ പേര് കൊണ്ട് മാറ്റി പകരം വയ്ക്കുക.\/\/ഒരു അറേയിൽ ഉള്ള സംഖ്യകളെ 1 മുതൽ 9 വരെയുള്ള സംഖ്യകളായി തരം തിരിക്കുക,\/\/ >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])\n\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/ If the array is empty, return an empty array:\n\/\/ >>> by_length([])\n\/\/ []\n\/\/ If the array has any strange number ignore it:\n\/\/ >>> by_length([1, -1, 55])\n\/\/ [\"One\"]\nfunction by_length(arr: number[]): string[] {\n","canonical_solution":"function by_length(arr: number[]): string[] {\n    const numberNames: { [key: number]: string } = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    };\n\n    return arr\n        .filter(num => num >= 1 && num <= 9)\n        .sort((a, b) => b - a)\n        .map(num => numberNames[num]);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = by_length;\n  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, -1, 55]),[\"One\"]);\n  assert.deepEqual(candidate([1, -1, 3, 2]),[\"Three\", \"Two\", \"One\"]);\n  assert.deepEqual(candidate([9, 4, 8]),[\"Nine\", \"Eight\", \"Four\"]);\n}\n\ntest();"},{"task_id":"HumanEval_106","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/i യുടെ ഫാക്ടോറിയൽ 1 മുതൽ i വരെയുള്ള സംഖ്യകളുടെ ഗുണനമാണ് (1 * 2 * . . . * i).\/\/ഞാന് 1 മുതല് തുടങ്ങുന്നു.\/\/അല്ലെങ്കിൽ 1 മുതൽ i വരെയുള്ള സംഖ്യകളുടെ ആകെത്തുക.\/\/പിന്നെ ഒരു വലിപ്പം n ന്റെ ഒരു അറേ തിരിച്ചു തരും, അങ്ങനെ i ന്റെ മൂല്യം i ന്റെ ഫാക്ടോറിയൽ ആയിരിക്കും, i ഇരട്ട ആണെങ്കിൽ \/\/n നെ പരാമീറ്ററായി എടുക്കുന്ന f ഫംഗ്ഷൻ നടപ്പിലാക്കുക, \/\/ >>> f(5)\n\/\/ [1, 2, 6, 24, 15]\nfunction f(n: number): number[] {\n","canonical_solution":"function f(n: number): number[] {\n    const result: number[] = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 2 === 0) {\n            \/\/ Calculate factorial for even i\n            let factorial = 1;\n            for (let j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push(factorial);\n        } else {\n            \/\/ Calculate sum for odd i\n            let sum = 0;\n            for (let j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push(sum);\n        }\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);\n  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);\n  assert.deepEqual(candidate(1),[1]);\n  assert.deepEqual(candidate(3),[1, 2, 6]);\n}\n\ntest();"},{"task_id":"HumanEval_107","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം 1:\/\/പരിധിയിൽ വരുന്ന പൂർണ്ണസംഖ്യകളുടെ പാലിൻഡ്രോമുകൾ ((1, n), ഉൾപ്പെടെ.\/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു അറേ തിരികെ നൽകുക, അതിൽ ഇരട്ടയും അസംഖ്യം യും ഉണ്ട്.\/\/ >>> even_odd_palindrome(3)\n\/\/ [1, 2]\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ [4, 6]\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned array has the number of even and odd integer palindromes respectively.\nfunction even_odd_palindrome(n: number): [number, number] {\n","canonical_solution":"function isPalindrome(num: number): boolean {\n    const str = num.toString();\n    return str === str.split('').reverse().join('');\n}\n\nfunction even_odd_palindrome(n: number): [number, number] {\n    let evenCount = 0;\n    let oddCount = 0;\n\n    for (let i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 === 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return [evenCount, oddCount];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = even_odd_palindrome;\n  assert.deepEqual(candidate(123),[8, 13]);\n  assert.deepEqual(candidate(12),[4, 6]);\n  assert.deepEqual(candidate(3),[1, 2]);\n  assert.deepEqual(candidate(63),[6, 8]);\n  assert.deepEqual(candidate(25),[5, 6]);\n  assert.deepEqual(candidate(19),[4, 6]);\n  assert.deepEqual(candidate(9),[4, 5]);\n  assert.deepEqual(candidate(1),[0, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_108","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്, -123 ന്റെ ചിഹ്നമുള്ള അക്കങ്ങൾ -1, 2, 3 എന്നിവയാണ്.\/\/ഒരു സംഖ്യ നെഗറ്റീവ് ആണെങ്കിൽ, അതിന്റെ ആദ്യത്തെ ചിഹ്നമുള്ള അക്കം നെഗറ്റീവ് ആയിരിക്കും: \/\/ 0 എന്ന സംഖ്യകളുടെ സംഖ്യയുള്ള ഘടകങ്ങളുടെ എണ്ണം.\/\/ഒരു ഫങ്ഷൻ count_nums എഴുതുക, അത് ഒരു അറേ എടുത്ത് \/\/ >>> count_nums([])\n\/\/ 0\n\/\/ >>> count_nums([-1, 11, -11])\n\/\/ 1\n\/\/ >>> count_nums([1, 1, 2])\n\/\/ 3\nfunction count_nums(arr: number[]): number {\n","canonical_solution":"function count_nums(arr: number[]): number {\n    function sumOfDigits(num: number): number {\n        let sum = 0;\n        let str = num.toString();\n        for (let i = 0; i < str.length; i++) {\n            let digit = parseInt(str[i]);\n            if (i === 0 && str[i] === '-') {\n                digit = -parseInt(str[i+1]);\n                i++;\n            }\n            sum += digit;\n        }\n        return sum;\n    }\n\n    let count = 0;\n    for (const num of arr) {\n        if (sumOfDigits(num) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_nums;\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([-1, -2, 0]),0);\n  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);\n  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);\n  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);\n  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);\n  assert.deepEqual(candidate([0, 1]),1);\n  assert.deepEqual(candidate([1]),1);\n}\n\ntest();"},{"task_id":"HumanEval_109","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/കുറിപ്പ്: തന്നിരിക്കുന്ന അറേയിൽ അദ്വിതീയ ഘടകങ്ങൾ ഉണ്ടെന്ന് ഉറപ്പുനൽകുന്നു.\/\/തന്നിരിക്കുന്ന അറേ ശൂന്യമാണെങ്കിൽ true തിരികെ നൽകുക.\/\/പിന്നെ ശരി തിരിച്ചു തരാം, അല്ലെങ്കിൽ തെറ്റായി തിരിച്ചു തരാം.\/\/മുകളിലുള്ള പ്രക്രിയ ചെയ്തുകൊണ്ട് തരം തിരിക്കപ്പെട്ട അറേ ലഭിക്കുമോ എന്ന്.\/\/അറേയിലെ ആരംഭ സ്ഥാനമാണ് 0-ാം സൂചിക.\/\/യിലേക്ക് നീക്കും.\/\/ഒരു വലതുവശത്തേക്കുള്ള ഷിഫ്റ്റ് ഓപ്പറേഷൻ അറേയിലെ എല്ലാ ഘടകങ്ങളും ഒന്നായി മാറ്റുന്നു എന്നാണ് അർത്ഥമാക്കുന്നത്.\/\/വലതുവശത്തേക്കുള്ള ഷിഫ്റ്റ് എത്ര തവണ വേണമെങ്കിലും ചെയ്യാം.\/\/താഴെ പറയുന്ന പ്രക്രിയ ഈ അറേയില് ചെയ്യാം:\/\/ എന്ന പ്രക്രിയയിലൂടെ ഒരു അറേ കുറയാത്ത ക്രമത്തിൽ ക്രമീകരിക്കാൻ സാധിക്കും.\/\/അറേയിലെ സംഖ്യകൾ ക്രമരഹിതമായി ക്രമീകരിക്കും. നിങ്ങളുടെ ജോലി \/\/നമുക്ക് ഒരു അറേ 'arr' ഉണ്ട് N പൂർണ്ണസംഖ്യകളുടെ arr[1], arr[2], ..., arr[N]. \/\/ >>> move_one_ball([3, 4, 5, 1, 2])\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given array.\n\/\/ >>> move_one_ball([3, 5, 4, 1, 2])\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ array by performing any number of right shift operations.\nfunction move_one_ball(arr: number[]): boolean {\n","canonical_solution":"function move_one_ball(arr: number[]): boolean {\n    if (arr.length === 0) return true;\n\n    let countDecreases = 0;\n    const n = arr.length;\n\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            countDecreases++;\n        }\n        if (countDecreases > 1) {\n            return false;\n        }\n    }\n\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = move_one_ball;\n  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);\n  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);\n  assert.deepEqual(candidate([4, 3, 1, 2]),false);\n  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);\n  assert.deepEqual(candidate([]),true);\n}\n\ntest();"},{"task_id":"HumanEval_110","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/ഇല്ലെങ്കിൽ, \"ഇല്ല\" എന്ന് തിരികെ നൽകുക.\/\/lst1 ന്റെ എല്ലാ ഘടകങ്ങളും സമമാണെങ്കിൽ, \"YES\" എന്ന് തിരികെ നൽകുക.\/\/lst1 ഉം lst2 ഉം തമ്മിലുള്ള ഘടകങ്ങൾ മാറ്റിയെടുക്കാൻ സാധിക്കുമെങ്കിൽ\/\/lst1 ഉം lst2 ഉം തമ്മിലുള്ള എക്സ്ചേഞ്ചുകളുടെ എണ്ണത്തിന് പരിധിയില്ല.\/\/lst1 എന്നത് ഇരട്ട സംഖ്യകളുടെ ഒരു ശ്രേണിയാക്കുക.\/\/ഘടകങ്ങള് കൈമാറാന് സാധിക്കുമോ എന്ന് തീരുമാനിക്കുന്നു.\/\/ഈ പ്രശ്നത്തില് നിങ്ങള് ഒരു ഫങ്ഷൻ നടപ്പിലാക്കും അത് രണ്ട് സംഖ്യകളുടെ അറേകളാണ് എടുക്കുന്നത്,\/\/ >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n\/\/ \"YES\"\n\/\/ >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n\/\/ \"NO\"\n\/\/ It is assumed that the input arrays will be non-empty.\nfunction exchange(lst1: number[], lst2: number[]): string {\n","canonical_solution":"function exchange(lst1: number[], lst2: number[]): string {\n    const isEven = (num: number) => num % 2 === 0;\n    \n    \/\/ Count the odd numbers in lst1\n    const oddCountInLst1 = lst1.reduce((count, num) => count + (isEven(num) ? 0 : 1), 0);\n\n    \/\/ Count the even numbers in lst2\n    const evenCountInLst2 = lst2.reduce((count, num) => count + (isEven(num) ? 1 : 0), 0);\n\n    \/\/ Check if number of odd numbers in lst1 can be matched by even numbers in lst2\n    return oddCountInLst1 <= evenCountInLst2 ? \"YES\" : \"NO\";\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = exchange;\n  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),\"YES\");\n  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),\"NO\");\n  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),\"YES\");\n  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),\"YES\");\n  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),\"NO\");\n  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),\"NO\");\n  assert.deepEqual(candidate([100, 200], [200, 200]),\"YES\");\n}\n\ntest();"},{"task_id":"HumanEval_111","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/ഒരേ അക്ഷരത്തില് പല അക്ഷരങ്ങള് ഉണ്ടെങ്കില് അവയെല്ലാം തിരികെ നല് കുക.\/\/ഏറ്റവും കൂടുതൽ തവണ ആവർത്തിക്കുന്നതും അതിനനുസരിച്ച് എണ്ണപ്പെടുന്നതുമായ അക്ഷരത്തിന്റെ \/\/ഒരു സ്പെയ്സ് വേർതിരിച്ച ചെറിയ അക്ഷരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു ഒബ്ജക്റ്റ് നൽകുക \/\/ >>> histogram(\"a b c\")\n\/\/ {\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ {\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ {\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ {\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ {}\nfunction histogram(test: string): {[key: string]: number} {\n","canonical_solution":"function histogram(test: string): { [key: string]: number } {\n    if (test.trim() === \"\") {\n        return {};\n    }\n\n    const letters = test.split(\" \");\n    const counts: { [key: string]: number } = {};\n\n    for (const letter of letters) {\n        if (letter in counts) {\n            counts[letter]++;\n        } else {\n            counts[letter] = 1;\n        }\n    }\n\n    let maxCount = 0;\n    for (const count of Object.values(counts)) {\n        if (count > maxCount) {\n            maxCount = count;\n        }\n    }\n\n    const result: { [key: string]: number } = {};\n    for (const [letter, count] of Object.entries(counts)) {\n        if (count === maxCount) {\n            result[letter] = count;\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = histogram;\n  assert.deepEqual(candidate(\"a b b a\"),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c a b\"),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c d g\"),{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"b b b b a\"),{\"b\": 4});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"\"),{});\n  assert.deepEqual(candidate(\"a\"),{\"a\": 1});\n}\n\ntest();"},{"task_id":"HumanEval_112","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം \/\/പരിശോധനയ്ക്കായി ഫല സ്ട്രിങ്ങും true\/false ഉം അടങ്ങിയ ഒരു അറേ നിങ്ങൾ നൽകണം.\/\/ഒരു സ്ട്രിംഗ് ഒരു പലിൻഡ്രോം എന്ന് വിളിക്കപ്പെടുന്നു, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കുന്നുവെങ്കിൽ.\/\/പിന്നെ ഫലം പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുക.\/\/നമുക്ക് രണ്ട് സ്ട്രിങ്ങുകൾ s ഉം c ഉം കിട്ടി, s യിലെ എല്ലാ പ്രതീകങ്ങളും നീക്കം ചെയ്യണം, അത് c യിലെ ഏതെങ്കിലും പ്രതീകത്തിന് തുല്യമാണ്.\/\/ചുമതല \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ [\"bcd\", false]\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ [\"acdef\", false]\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ [\"cdedc\", true]\nfunction reverse_delete(s: string, c: string): [string, boolean] {\n","canonical_solution":"function reverse_delete(s: string, c: string): [string, boolean] {\n    \/\/ Create a Set of characters to delete for faster lookup\n    const charsToDelete = new Set(c);\n\n    \/\/ Filter out characters in 's' that are in 'c'\n    const filteredString = s.split('').filter(char => !charsToDelete.has(char)).join('');\n\n    \/\/ Check if the filtered string is a palindrome\n    const isPalindrome = filteredString === filteredString.split('').reverse().join('');\n\n    return [filteredString, isPalindrome];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = reverse_delete;\n  assert.deepEqual(candidate(\"abcde\", \"ae\"),[\"bcd\", false]);\n  assert.deepEqual(candidate(\"abcdef\", \"b\"),[\"acdef\", false]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"ab\"),[\"cdedc\", true]);\n  assert.deepEqual(candidate(\"dwik\", \"w\"),[\"dik\", false]);\n  assert.deepEqual(candidate(\"a\", \"a\"),[\"\", true]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"\"),[\"abcdedcba\", true]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"v\"),[\"abcdedcba\", true]);\n  assert.deepEqual(candidate(\"vabba\", \"v\"),[\"abba\", true]);\n  assert.deepEqual(candidate(\"mamma\", \"mia\"),[\"\", true]);\n}\n\ntest();"},{"task_id":"HumanEval_113","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഇൻപുട്ടിന്റെ i-ാം സ്ട്രിങ്ങിലെ അപൂർവ്വ അക്കങ്ങളുടെ എണ്ണം.\/\/\"ഇവിടെ എല്ലാ i- കളും നമ്പർ ഉപയോഗിച്ച് മാറ്റിസ്ഥാപിക്കണം.\/\/ഔട്ട്പുട്ടിന്റെ ഓരോ ഘടകവും i യിലെ അപൂർവ്വ ഘടകങ്ങളുടെ എണ്ണം ആയിരിക്കണം.\/\/ഓരോ സ്ട്രിങ്ങും അക്കങ്ങൾ മാത്രമുള്ള ഒരു സ്ട്രിംഗ് നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു സ്ട്രിംഗ് നൽകുക.\/\/ >>> odd_count([\"1234567\"])\n\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/ >>> odd_count([\"3\", \"11111111\"])\n\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunction odd_count(lst: string[]): string[] {\n","canonical_solution":"function odd_count(lst: string[]): string[] {\n    return lst.map(str => {\n        \/\/ Count the number of odd digits in the string\n        let oddCount = Array.from(str).reduce((count, char) => {\n            let digit = parseInt(char, 10);\n            return digit % 2 !== 0 ? count + 1 : count;\n        }, 0);\n\n        \/\/ Construct the result string\n        return `the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.`;\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = odd_count;\n  assert.deepEqual(candidate([\"1234567\"]),[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]);\n  assert.deepEqual(candidate([\"3\", \"11111111\"]),[\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]);\n  assert.deepEqual(candidate([\"271\", \"137\", \"314\"]),[\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"]);\n}\n\ntest();"},{"task_id":"HumanEval_114","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം \/\/യും\/\/ഒരു അറേയിൽ ഉള്ള സംഖ്യകളുടെ സംഖ്യകളുടെ സംഖ്യകൾ, ശൂന്യമല്ലാത്ത ഏതെങ്കിലും ഉപ-അറേയുടെ ഏറ്റവും കുറഞ്ഞ സംഖ്യ കണ്ടെത്തുക \/\/ >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n\/\/ 1\n\/\/ >>> minSubArraySum([-1, -2, -3])\n\/\/ -6\nfunction minSubArraySum(nums: number[]): number {\n","canonical_solution":"function minSubArraySum(nums: number[]): number {\n    let minSum = nums[0];\n    let currentSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        currentSum = Math.min(nums[i], currentSum + nums[i]);\n        minSum = Math.min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n\n\/\/ Example usage:\n\/\/ console.log(minSubArraySum([2, 3, 4, 1, 2, 4])); \/\/ Output: 1\n\/\/ console.log(minSubArraySum([-1, -2, -3])); \/\/ Output: -6","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = minSubArraySum;\n  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);\n  assert.deepEqual(candidate([-1, -2, -3]),-6);\n  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);\n  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);\n  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);\n  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);\n  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);\n  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);\n  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);\n  assert.deepEqual(candidate([-10]),-10);\n  assert.deepEqual(candidate([7]),7);\n  assert.deepEqual(candidate([1, -1]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_115","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം 1:\/\/ബക്കറ്റുകള് താഴെയിറക്കാന് എത്ര പ്രാവശ്യം വേണമെങ്കിലും ചെയ്യണം.\/\/നിങ്ങളുടെ ജോലി കിണറുകള് ഒഴുകാന് ബക്കറ്റുകള് ഉപയോഗിക്കുക എന്നതാണ്.\/\/എല്ലാ ബക്കറ്റുകളിലും ഒരേ അളവിലുള്ള വെള്ളം ഉണ്ട്.\/\/ഓരോ കിണറിനും അതില് നിന്ന് വെള്ളം പുറത്തെടുക്കാന് ഉപയോഗിക്കാവുന്ന ഒരു ബക്കറ്റ് ഉണ്ട്,\/\/ഓരോ 1യും ഒരു യൂണിറ്റ് വെള്ളത്തെ പ്രതിനിധീകരിക്കുന്നു.\/\/നിങ്ങള് ക്ക് ഒരു ചതുരാകൃതിയിലുള്ള കിണറുകളുടെ ഒരു ഗ്രിഡ് കിട്ടും. ഓരോ വരിയും ഒരൊറ്റ കിണറിനെ പ്രതിനിധീകരിക്കുന്നു,\/\/ >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n","canonical_solution":"function max_fill(grid: number[][], capacity: number): number {\n    let totalBuckets = 0;\n\n    for (let row of grid) {\n        let waterUnits = row.reduce((sum, cell) => sum + cell, 0);\n        totalBuckets += Math.ceil(waterUnits \/ capacity);\n    }\n\n    return totalBuckets;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"},{"task_id":"HumanEval_116","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഇത് ഇങ്ങനെ നടപ്പാക്കണം:\/\/സമാനമായ എണ്ണം 1 കളുടെ, ദശാംശ മൂല്യം അടിസ്ഥാനമാക്കി അടുക്കുക.\/\/ബൈനറി പ്രാതിനിധ്യത്തിലെ 1 ന്റെ എണ്ണം വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ.\/\/ഈ കത്തയിൽ, നിങ്ങൾ ഒരു നെഗറ്റീവ് അല്ലാത്ത സംഖ്യകളുടെ അറേ  അനുസരിച്ച് ക്രമീകരിക്കണം\/\/ >>> sort_array([1, 5, 2, 3, 4])\n\/\/ [1, 2, 3, 4, 5]\n\/\/ >>> sort_array([-2, -3, -4, -5, -6])\n\/\/ [-6, -5, -4, -3, -2]\n\/\/ >>> sort_array([1, 0, 2, 3, 4])\n\/\/ [0, 1, 2, 3, 4]\nfunction sort_array(arr: number[]): number[] {\n","canonical_solution":"function sort_array(arr: number[]): number[] {\n    return arr.sort((a, b) => {\n        const countOnes = (n: number) => n.toString(2).replace(\/0\/g, \"\").length;\n        const numOnesA = countOnes(a);\n        const numOnesB = countOnes(b);\n\n        if (numOnesA !== numOnesB) {\n            return numOnesA - numOnesB;\n        } else {\n            return a - b;\n        }\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);\n  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);\n  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);\n}\n\ntest();"},{"task_id":"HumanEval_117","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/കുറിപ്പ്: ഇൻപുട്ട് സ്ട്രിങ്ങിൽ അക്ഷരങ്ങളും സ്പെയ്സുകളും മാത്രമേ ഉള്ളൂ എന്ന് കരുതാം.\/\/s ശൂന്യമാണെങ്കിൽ ഫങ്ഷൻ ഒരു ശൂന്യമായ അറേ നൽകും.\/\/n സ്വരമാലകൾ, ഈ വാക്കുകൾ s സ്ട്രിങ്ങിൽ പ്രത്യക്ഷപ്പെടുന്ന ക്രമത്തിൽ.\/\/കൃത്യമായി  അടങ്ങിയിരിക്കുന്ന സ്ട്രിംഗ് s-ലെ എല്ലാ വാക്കുകളുടെയും ഒരു അറേ മടക്കിനൽകുന്ന ഒരു ഫംഗ്ഷൻ.\/\/ഒരു സ്ട്രിംഗ് s ഉം ഒരു സ്വാഭാവിക സംഖ്യ n ഉം നല് കിയിരിക്കെ, നിങ്ങള് ക്ക് നടപ്പിലാക്കാന് നിര് ദ്ദേശമുണ്ട് \/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ [\"little\"]\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ [\"Mary\", \"lamb\"]\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ [\"world\"]\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ [\"Uncle\"]\nfunction select_words(s: string, n: number): string[] {\n","canonical_solution":"function select_words(s: string, n: number): string[] {\n    const isConsonant = (char: string): boolean => {\n        const vowels = 'aeiouAEIOU';\n        return !vowels.includes(char) && \/[a-zA-Z]\/.test(char);\n    };\n\n    const words = s.split(' ');\n    const result: string[] = [];\n\n    for (const word of words) {\n        const consonantCount = [...word].filter(isConsonant).length;\n        if (consonantCount === n) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = select_words;\n  assert.deepEqual(candidate(\"Mary had a little lamb\", 4),[\"little\"]);\n  assert.deepEqual(candidate(\"Mary had a little lamb\", 3),[\"Mary\", \"lamb\"]);\n  assert.deepEqual(candidate(\"simple white space\", 2),[]);\n  assert.deepEqual(candidate(\"Hello world\", 4),[\"world\"]);\n  assert.deepEqual(candidate(\"Uncle sam\", 3),[\"Uncle\"]);\n  assert.deepEqual(candidate(\"\", 4),[]);\n  assert.deepEqual(candidate(\"a b c d e f\", 1),[\"b\", \"c\", \"d\", \"f\"]);\n}\n\ntest();"},{"task_id":"HumanEval_118","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/നിങ്ങള് ക്ക് ഊഹിക്കാം, ഈ സ്ട്രിങ്ങിൽ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ മാത്രമേ ഉള്ളൂ എന്ന്.\/\/മുകളിലുള്ള നിബന്ധന പാലിക്കുന്ന ഏതെങ്കിലും സ്വരാക്ഷരത്തെ കണ്ടെത്തുക.\/\/തുടക്കത്തിലും അവസാനത്തിലും ഉള്ള സ്വരാക്ഷരങ്ങൾ കണക്കാക്കില്ല. ഇല്ലെങ്കിൽ ശൂന്യമായ സ്ട്രിംഗ് തിരികെ നൽകുക.\/\/വാക്കിന്റെ വലതുവശത്ത് നിന്ന് രണ്ട് സ്വരാക്ഷരങ്ങൾ (കേസ് സെൻസിറ്റീവ്).\/\/നിങ്ങള് ക്ക് ഒരു വാക്ക് കിട്ടും. നിങ്ങള് ക്ക് കിട്ടുന്ന ജോലി അടുത്തുള്ള സ്വരാക്ഷരത്തെ കണ്ടെത്തുക എന്നതാണ്.\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunction get_closest_vowel(word: string): string {\n","canonical_solution":"function get_closest_vowel(word: string): string {\n    const vowels = new Set<string>(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n    for (let i = word.length - 2; i > 0; i--) {\n        if (vowels.has(word[i]) && !vowels.has(word[i - 1]) && !vowels.has(word[i + 1])) {\n            return word[i];\n        }\n    }\n    return '';\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_closest_vowel;\n  assert.deepEqual(candidate(\"yogurt\"),\"u\");\n  assert.deepEqual(candidate(\"full\"),\"u\");\n  assert.deepEqual(candidate(\"easy\"),\"\");\n  assert.deepEqual(candidate(\"eAsy\"),\"\");\n  assert.deepEqual(candidate(\"ali\"),\"\");\n  assert.deepEqual(candidate(\"bad\"),\"a\");\n  assert.deepEqual(candidate(\"most\"),\"o\");\n  assert.deepEqual(candidate(\"ab\"),\"\");\n  assert.deepEqual(candidate(\"ba\"),\"\");\n  assert.deepEqual(candidate(\"quick\"),\"\");\n  assert.deepEqual(candidate(\"anime\"),\"i\");\n  assert.deepEqual(candidate(\"Asia\"),\"\");\n  assert.deepEqual(candidate(\"Above\"),\"o\");\n}\n\ntest();"},{"task_id":"HumanEval_119","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഒരു നല്ല സ്ട്രിംഗ് ഉണ്ടാക്കാന് ഒരു വഴിയുണ്ടെങ്കില് 'അതെ' എന്ന് തിരിച്ചുവിടുക, അല്ലാത്തപക്ഷം 'ഇല്ല' എന്ന് തിരിച്ചുവിടുക.\/\/\" (()) \" അല്ല.\/\/ഉദാഹരണത്തിന്: '(((() ' എന്ന സ്ട്രിംഗ് നല്ലതാണ്, അതേസമയം  എന്ന സ്ട്രിംഗ് നല്ലതാണ്.\/\/S യിലെ എല്ലാ പരാൻതീസിസുകളും  ആണെങ്കിൽ മാത്രമേ ഒരു സ്ട്രിംഗ് S നല്ലതായി കണക്കാക്കപ്പെടുന്നുള്ളൂ.\/\/ചില ക്രമം, തത്ഫലമായുണ്ടാകുന്ന സ്ട്രിംഗ് നല്ലതായിരിക്കും.\/\/നിങ്ങളുടെ ജോലി രണ്ടു സ്ട്രിങ്ങുകളും ഒന്നിച്ച് ചേർക്കാൻ സാധിക്കുമോ എന്ന് പരിശോധിക്കുക എന്നതാണ്.\/\/പരാൻതീസിസ് \" ((\" അല്ലെങ്കിൽ അടുത്ത പരാൻതീസിസ് \") \" മാത്രം.\/\/നിങ്ങള് ക്ക് രണ്ട് സ്ട്രിങ്ങുകളുടെ ഒരു അറേ ലഭിക്കുന്നു, രണ്ട് സ്ട്രിങ്ങുകളും അടങ്ങിയിരിക്കുന്നത് ഓപ്പൺ  യിലൂടെയാണ്.\/\/ >>> match_parens([\"()(\", \")\"])\n\/\/ \"Yes\"\n\/\/ >>> match_parens([\")\", \")\"])\n\/\/ \"No\"\nfunction match_parens(lst: string[]): string {\n","canonical_solution":"function match_parens(lst: string[]): string {\n    const canFormGoodString = (s1: string, s2: string): boolean => {\n        let balance = 0;\n\n        \/\/ Check s1 followed by s2\n        for (const char of s1 + s2) {\n            if (char === '(') balance++;\n            else if (char === ')') balance--;\n\n            if (balance < 0) return false; \/\/ More closing than opening\n        }\n        if (balance === 0) return true; \/\/ Balanced\n\n        balance = 0;\n        \/\/ Check s2 followed by s1\n        for (const char of s2 + s1) {\n            if (char === '(') balance++;\n            else if (char === ')') balance--;\n\n            if (balance < 0) return false; \/\/ More closing than opening\n        }\n\n        return balance === 0; \/\/ Balanced\n    };\n\n    return canFormGoodString(lst[0], lst[1]) ? 'Yes' : 'No';\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"},{"task_id":"HumanEval_120","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം 1:\/\/നീളം k യും പരമാവധി k സംഖ്യകളും arr യിലുണ്ട്.\/\/ഒരു അറേ arr എന്ന സംഖ്യയും ഒരു പോസിറ്റീവ് സംഖ്യ k ഉം നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു തരംതിരിക്കപ്പെട്ട അറേ  തിരിച്ചു നൽകുക.\/\/ >>> maximum([-3, -4, 5], 3)\n\/\/ [-4, -3, 5]\n\/\/ Example 2:\n\/\/ >>> maximum([4, -4, 4], 2)\n\/\/ [4, 4]\n\/\/ Example 3:\n\/\/ >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/ [2]\n\/\/ Note:\n\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunction maximum(arr: number[], k: number): number[] {\n","canonical_solution":"function maximum(arr: number[], k: number): number[] {\n    \/\/ Sort the array in descending order and then take the first k elements\n    const sortedArr = arr.sort((a, b) => b - a);\n    return sortedArr.slice(0, k).sort((a, b) => a - b);\n}\n\n\/\/ Example usage:\n\/\/ console.log(maximum([-3, -4, 5], 3)); \/\/ Output: [-4, -3, 5]\n\/\/ console.log(maximum([4, -4, 4], 2)); \/\/ Output: [4, 4]\n\/\/ console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1)); \/\/ Output: [2]","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maximum;\n  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);\n  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);\n  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);\n  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);\n  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);\n  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);\n  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);\n  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);\n  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);\n  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);\n  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);\n}\n\ntest();"},{"task_id":"HumanEval_121","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/പൂര് ണ്ണ സംഖ്യകളുടെ ഒരു ശൂന്യമല്ലാത്ത അറേ നല് കിയിട്ട്, സമസ്ഥാനങ്ങളിലുള്ള എല്ലാ ഭിന്ന മൂലകങ്ങളുടെയും സംഖ്യ തിരികെ നല് കുക.\/\/ >>> solution([5, 8, 7, 1])\n\/\/ 12\n\/\/ >>> solution([3, 3, 3, 3, 3])\n\/\/ 9\n\/\/ >>> solution([30, 13, 24, 321])\n\/\/ 0\nfunction solution(lst: number[]): number {\n","canonical_solution":"function solution(lst: number[]): number {\n    let sum: number = 0;\n    for (let i = 0; i < lst.length; i += 2) {  \/\/ Traverse even indices\n        if (lst[i] % 2 !== 0) {  \/\/ Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    return sum;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solution;\n  assert.deepEqual(candidate([5, 8, 7, 1]),12);\n  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);\n  assert.deepEqual(candidate([30, 13, 24, 321]),0);\n  assert.deepEqual(candidate([5, 9]),5);\n  assert.deepEqual(candidate([2, 4, 8]),0);\n  assert.deepEqual(candidate([30, 13, 23, 32]),23);\n  assert.deepEqual(candidate([3, 13, 2, 9]),3);\n}\n\ntest();"},{"task_id":"HumanEval_122","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/arr യിലെ ആദ്യത്തെ k മൂലകങ്ങളുടെ പരമാവധി രണ്ട് അക്കങ്ങളുള്ള മൂലകങ്ങളുടെ സംഖ്യ.\/\/ഒരു പൂർണ്ണസംഖ്യ arr യും ഒരു പൂർണ്ണസംഖ്യ k യും ഉള്ള ഒരു ശൂന്യമല്ലാത്ത അറേ നൽകിയാൽ, return \/\/ >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunction add_elements(arr: number[], k: number): number {\n","canonical_solution":"function add_elements(arr: number[], k: number): number {\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add_elements;\n  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);\n  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);\n  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);\n  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);\n  assert.deepEqual(candidate([1], 1),1);\n}\n\ntest();"},{"task_id":"HumanEval_123","nl":"mal_Mlym","pl":"ts","prompt":"\/\/get_odd_collatz(5) [1, 5] # 5 ന്റെ കോലാറ്റ്സ് ശ്രേണി [5, 16, 8, 4, 2, 1], അതിനാൽ വിചിത്ര സംഖ്യകൾ 1 ഉം 5 ഉം മാത്രമാണ്.\/\/ഉദാഹരണത്തിന്: \/\/2. മടക്കിയ അറേ ക്രമം വർദ്ധിപ്പിക്കുന്നു.\/\/1. കോലാട്സ്      ആണ് [1].\/\/കുറിപ്പ്:\/\/n ന്റെ മൂല്യം എത്രയായിരുന്നാലും, തുടക്കം എപ്പോഴും 1 ആയിരിക്കും.\/\/മുമ്പത്തെ പദം ഇരട്ട ആണെങ്കിൽ, അടുത്ത പദം മുമ്പത്തെ പദത്തിന്റെ 3 മടങ്ങ് വരും.\/\/മുമ്പത്തെ പദം ഇപ്രകാരമാണ്: മുമ്പത്തെ പദം ഇരട്ട ആണെങ്കിൽ, അടുത്ത പദം  ന്റെ പകുതി ആണ്.\/\/താഴെ പറയുന്ന രീതിയിൽ: ഏതെങ്കിലും പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n-ൽ നിന്ന് ആരംഭിക്കുക. പിന്നെ ഓരോ പദവും   ൽ നിന്നും ലഭിക്കുന്നു.\/\/കോലാറ്റ്സ് അനുമാനം ഒരു ഗണിതശാസ്ത്ര അനുമാനമാണ്, അത് നിർവചിക്കപ്പെട്ട ഒരു ശ്രേണിയെ സംബന്ധിക്കുന്നു.\/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു ക്രമീകരിച്ച അറേ തിരികെ നൽകുക, അതിൽ കോലാറ്റ്സ് ശ്രേണിയിലെ ഒറ്റ സംഖ്യകൾ അടങ്ങിയിരിക്കുന്നു.\/\/ >>> get_odd_collatz(5)\n\/\/ [1, 5]\nfunction get_odd_collatz(n: number): number[] {\n","canonical_solution":"function get_odd_collatz(n: number): number[] {\n    const collatzSequence: number[] = [];\n    while (n !== 1) {\n        if (n % 2 !== 0) {\n            collatzSequence.push(n);\n        }\n        if (n % 2 === 0) {\n            n = n \/ 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \/\/ Include 1 in the sequence if it's odd, as per standard collatz sequence\n    collatzSequence.push(1);\n    return collatzSequence.sort((a, b) => a - b);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_odd_collatz;\n  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);\n  assert.deepEqual(candidate(5),[1, 5]);\n  assert.deepEqual(candidate(12),[1, 3, 5]);\n  assert.deepEqual(candidate(1),[1]);\n}\n\ntest();"},{"task_id":"HumanEval_124","nl":"mal_Mlym","pl":"ts","prompt":"\/\/4. തീയതി എംഎം-ഡിഡി-ആയിയി എന്ന ഫോർമാറ്റിലായിരിക്കണം.\/\/3. മാസങ്ങളുടെ എണ്ണം 1ൽ കുറവോ 12ൽ കൂടുതലോ ആകരുത്.\/\/2. മാസങ്ങളായ 1,3,5,7,8,10,12 എന്നിവയുടെ ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 31 ൽ കൂടുതലോ ആയിരിക്കരുത്. മാസങ്ങളായ 4,6,9,11 എന്നിവയുടെ ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 30 ൽ കൂടുതലോ ആയിരിക്കരുത്. മാസമായ 2 ന്റെ ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 29 ൽ കൂടുതലോ ആയിരിക്കരുത്.\/\/1. തീയതി സ്ട്രിംഗ് ശൂന്യമല്ല.\/\/താഴെ പറയുന്ന എല്ലാ നിബന്ധനകളും പാലിച്ചാൽ ഈ തീയതി സാധുവാണ്:\/\/തീയതി ശരിയാണെങ്കിൽ ശരി, അല്ലാത്തപക്ഷം തെറ്റാണ്.\/\/ഒരു നിശ്ചിത തീയതി സ്ട്രിംഗ് സാധൂകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതണം.\/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunction valid_date(date: string): boolean {\n","canonical_solution":"function valid_date(date: string): boolean {\n    \/\/ Check if the date is empty\n    if (date.trim() === \"\") return false;\n\n    \/\/ Split the date string into components\n    const dateParts = date.split(\"-\");\n    if (dateParts.length !== 3) return false;\n\n    const [monthStr, dayStr, yearStr] = dateParts;\n\n    \/\/ Validate each part of the date\n    const month = parseInt(monthStr, 10);\n    const day = parseInt(dayStr, 10);\n    const year = parseInt(yearStr, 10);\n\n    \/\/ Check if all parts are valid numbers\n    if (isNaN(month) || isNaN(day) || isNaN(year)) return false;\n\n    \/\/ Check the month range\n    if (month < 1 || month > 12) return false;\n\n    \/\/ Check the day range based on the month\n    if ([1, 3, 5, 7, 8, 10, 12].includes(month)) {\n        if (day < 1 || day > 31) return false;\n    } else if ([4, 6, 9, 11].includes(month)) {\n        if (day < 1 || day > 30) return false;\n    } else if (month === 2) {\n        if (day < 1 || day > 29) return false;\n    }\n\n    \/\/ All checks passed\n    return true;\n}\n\n\/\/ Example usage\nconsole.log(valid_date(\"03-11-2000\")); \/\/ true\nconsole.log(valid_date(\"15-01-2012\")); \/\/ false\nconsole.log(valid_date(\"04-0-2040\"));  \/\/ false\nconsole.log(valid_date(\"06-04-2020\")); \/\/ true\nconsole.log(valid_date(\"06\/04\/2020\")); \/\/ false","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = valid_date;\n  assert.deepEqual(candidate(\"03-11-2000\"),true);\n  assert.deepEqual(candidate(\"15-01-2012\"),false);\n  assert.deepEqual(candidate(\"04-0-2040\"),false);\n  assert.deepEqual(candidate(\"06-04-2020\"),true);\n  assert.deepEqual(candidate(\"01-01-2007\"),true);\n  assert.deepEqual(candidate(\"03-32-2011\"),false);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"04-31-3000\"),false);\n  assert.deepEqual(candidate(\"06-06-2005\"),true);\n  assert.deepEqual(candidate(\"21-31-2000\"),false);\n  assert.deepEqual(candidate(\"04-12-2003\"),true);\n  assert.deepEqual(candidate(\"04122003\"),false);\n  assert.deepEqual(candidate(\"20030412\"),false);\n  assert.deepEqual(candidate(\"2003-04\"),false);\n  assert.deepEqual(candidate(\"2003-04-12\"),false);\n  assert.deepEqual(candidate(\"04-2003\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_125","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/അക്ഷരമാല, ഓർഡർ a) = 0, ഓർഡർ b) = 1, . . . ഓർഡർ z) = 25\/\/കോമകളായി വിഭജിക്കപ്പെടണം ',' കോമകളില്ലെങ്കിൽ,  യിൽ അപൂർവ ക്രമത്തിലുള്ള ചെറിയ അക്ഷരങ്ങളുടെ എണ്ണം നിങ്ങൾ നൽകണം.\/\/വാക്കുകളുടെ ഒരു സ്ട്രിംഗ് തന്നിരിക്കുന്ന, നിങ്ങൾ തിരയുന്ന വാചകത്തിൽ വെളുത്ത ഇടങ്ങൾ ഇല്ലെങ്കിൽ, ശൂന്യസ്ഥലങ്ങളിൽ വിഭജിച്ച വാക്കുകളുടെ ഒരു ശ്രേണി തിരികെ നൽകുക.\/\/ >>> split_words(\"Hello world!\")\n\/\/ [\"Hello\", \"world!\"]\n\/\/ >>> split_words(\"Hello,world!\")\n\/\/ [\"Hello\", \"world!\"]\n\/\/ >>> split_words(\"abcdef\")\n\/\/ 3\nfunction split_words(txt: string): string[] | number {\n","canonical_solution":"function split_words(txt: string): string[] | number {\n    if (txt.includes(\" \")) {\n        return txt.split(\" \");\n    }\n    if (txt.includes(\",\")) {\n        return txt.split(\",\");\n    }\n    const oddOrderCount = [...txt].reduce((count, char) => {\n        const charCode = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        if (char === char.toLowerCase() && charCode % 2 === 1) {\n            return count + 1;\n        }\n        return count;\n    }, 0);\n\n    return oddOrderCount;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = split_words;\n  assert.deepEqual(candidate(\"Hello world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello,world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello world,!\"),[\"Hello\", \"world,!\"]);\n  assert.deepEqual(candidate(\"Hello,Hello,world !\"),[\"Hello,Hello,world\", \"!\"]);\n  assert.deepEqual(candidate(\"abcdef\"),3);\n  assert.deepEqual(candidate(\"aaabb\"),2);\n  assert.deepEqual(candidate(\"aaaBb\"),1);\n  assert.deepEqual(candidate(\"\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_126","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/നമ്പർ, false തിരികെ നൽകുന്നു. നെഗറ്റീവ് നമ്പറുകളില്ലെന്നും പൂർണ്ണസംഖ്യകൾ മാത്രമേ ഉള്ളൂവെന്നും കരുതുക.\/\/ഒരു അറേയിൽ ഒന്നിലധികം ഡ്യൂപ്ലിക്കേറ്റുകൾ ഉണ്ടെങ്കിൽ, \/\/ഒരു അറേ നമ്പറുകൾ തന്നാൽ, അവ ക്രമീകരിച്ചാലും ഇല്ലെങ്കിലും, അത് തിരികെ നൽകുന്നു.\/\/ >>> is_sorted([5])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 3, 4, 5])\n\/\/ true\n\/\/ >>> is_sorted([1, 3, 2, 4, 5])\n\/\/ false\n\/\/ >>> is_sorted([1, 2, 3, 4, 5, 6])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 3, 4, 5, 6, 7])\n\/\/ true\n\/\/ >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n\/\/ false\n\/\/ >>> is_sorted([1, 2, 2, 3, 3, 4])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 2, 2, 3, 4])\n\/\/ false\nfunction is_sorted(lst: number[]): boolean {\n","canonical_solution":"function is_sorted(lst: number[]): boolean {\n    for (let i = 0; i < lst.length - 1; i++) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] === lst[i + 1]) {\n            let count = 1;\n            while (lst[i + count] === lst[i]) {\n                count++;\n                if (count > 2) return false;\n            }\n        }\n    }\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_sorted;\n  assert.deepEqual(candidate([5]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);\n  assert.deepEqual(candidate([]),true);\n  assert.deepEqual(candidate([1]),true);\n  assert.deepEqual(candidate([3, 2, 1]),false);\n  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4]),true);\n}\n\ntest();"},{"task_id":"HumanEval_127","nl":"mal_Mlym","pl":"ts","prompt":"\/\/[ഇൻപുട്ട്\/ഔട്ട്പുട്ട്] സാമ്പിളുകൾ: \/\/രണ്ട് ഇടവേളകളും പരസ്പരം കൂടിച്ചേരുന്നില്ലെങ്കിൽ, \"NO\" എന്ന് തിരികെ നൽകുക.\/\/ഇല്ലെങ്കിൽ \"ഇല്ല\" എന്ന് തിരികെ നൽകുക.\/\/ഇന്റർസെക്ഷന് ഒരു പ്രധാന സംഖ്യയാണെങ്കിൽ, \"YES\" എന്ന് തിരികെ നൽകുക.\/\/അതിന്റെ നീളം 1 ആണ്, അത് ഒരു പ്രൈം നമ്പർ അല്ല.\/\/ഉദാഹരണത്തിന്, ഇടവേളകളുടെ (1, 3), (2, 4) വിഭജനം (2, 3) ആണ്.\/\/ഒരു പ്രൈം നമ്പറാണ്.\/\/നിങ്ങളുടെ ജോലി ഈ രണ്ടു ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ\/\/ഓരോ ഇടവേളയുടെയും തുടക്കം അതിന്റെ അവസാനത്തെക്കാൾ കുറവോ തുല്യമോ ആണെന്ന് കരുതപ്പെടുന്നു.\/\/തുടക്കവും അവസാനവും ഉൾപ്പെടുന്നു.\/\/ഈ ഇടവേളകൾ അടച്ചവയാണ്, അതിനർത്ഥം ഇടവേള (ആരംഭം, അവസാനം) \/\/ഓരോ ഇടവേളയും ഒരു ജോടി പൂർണ്ണസംഖ്യകളാണ്. ഉദാഹരണത്തിന്, ഇടവേള = (ആരംഭം, അവസാനം) = (1, 2).\/\/നിങ്ങള് ക്ക് രണ്ടു ഇടവേളകളാണ് നല് കിയിരിക്കുന്നത്.\/\/ >>> intersection([1, 2], [2, 3])\n\/\/ \"NO\"\n\/\/ >>> intersection([-1, 1], [0, 4])\n\/\/ \"NO\"\n\/\/ >>> intersection([-3, -1], [-5, 5])\n\/\/ \"YES\"\nfunction intersection(interval1: [number, number], interval2: [number, number]): string {\n","canonical_solution":"function isPrime(num: number): boolean {\n    if (num <= 1) return false;\n    if (num <= 3) return true; \/\/ 2 and 3 are prime numbers\n    if (num % 2 === 0 || num % 3 === 0) return false;\n    for (let i = 5; i * i <= num; i += 6) {\n        if (num % i === 0 || num % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction intersection(interval1: [number, number], interval2: [number, number]): string {\n    const start = Math.max(interval1[0], interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    const length = end - start;\n\n    return isPrime(length) ? \"YES\" : \"NO\";\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = intersection;\n  assert.deepEqual(candidate([1, 2], [2, 3]),\"NO\");\n  assert.deepEqual(candidate([-1, 1], [0, 4]),\"NO\");\n  assert.deepEqual(candidate([-3, -1], [-5, 5]),\"YES\");\n  assert.deepEqual(candidate([-2, 2], [-4, 0]),\"YES\");\n  assert.deepEqual(candidate([-11, 2], [-1, -1]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [3, 5]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [1, 2]),\"NO\");\n  assert.deepEqual(candidate([-2, -2], [-3, -2]),\"NO\");\n}\n\ntest();"},{"task_id":"HumanEval_128","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/കുറിപ്പ്: ശൂന്യമായ arr ന്റെ റിട്ടേൺ നിർവചിച്ചിട്ടില്ല.\/\/അറേയിലെ ഓരോ സംഖ്യയും 1, -1 അല്ലെങ്കിൽ 0 ആയി പ്രതിനിധീകരിക്കുന്നു.\/\/ പൂര് ണ്ണസംഖ്യകളുടെ ആകെത്തുക, എല്ലാ അടയാളങ്ങളുടെയും ഗുണിതം കൊണ്ട് ഗുണിച്ചാല്\/\/നിങ്ങള് ക്ക് ഒരു അറേ കിട്ടും, നിങ്ങള് ക്ക് അത് തിരിച്ച് കൊടുക്കണം.\/\/ >>> prod_signs([1, 2, 2, -4])\n\/\/ 9\n\/\/ >>> prod_signs([0, 1])\n\/\/ 0\n\/\/ >>> prod_signs([])\n\/\/ undefined\nfunction prod_signs(arr: number[]): number | undefined {\n","canonical_solution":"function prod_signs(arr: number[]): number | undefined {\n    if (arr.length === 0) return undefined;\n\n    let sumOfMagnitudes = 0;\n    let productOfSigns = 1;\n\n    for (const num of arr) {\n        sumOfMagnitudes += Math.abs(num);\n        productOfSigns *= Math.sign(num);\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prod_signs;\n  assert.deepEqual(candidate([1, 2, 2, -4]),-9);\n  assert.deepEqual(candidate([0, 1]),0);\n  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);\n  assert.deepEqual(candidate([-1, 1, -1, 1]),4);\n  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);\n  assert.deepEqual(candidate([-1, 1, 1, 0]),0);\n}\n\ntest();"},{"task_id":"HumanEval_129","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഏറ്റവും കുറഞ്ഞ പാത കടന്നുപോകുന്ന സെല്ലുകളിലെ മൂല്യങ്ങളുടെ ഒരു ക്രമീകരിച്ച അറേ മടക്കിനൽകുന്നു.\/\/ഉത്തരം അദ്വിതീയമാണെന്ന് ഉറപ്പുനൽകുന്നു.\/\/lst_A[j] = lst_B[j]  എന്നതിനു സമാനമാണ്.\/\/lst_A[i] < lst_B[i] എന്ന തരത്തിലുള്ളതും, ഏതൊരു j (1 <= j < i) നും നമുക്ക് \/\/lst_B-നേക്കാൾ, മറ്റൊരു വാക്കിൽ പറഞ്ഞാൽ, ഒരു പൂർണ്ണസംഖ്യാ സൂചിക i (1 <= i <= k)  നിലവിലുണ്ട്.\/\/lst_A, lst_B എന്നിവയെ വിളിക്കാം. lst_A എന്നത് നിഘണ്ടുശാസ്ത്രപരമായി കുറവാണ്.\/\/A, B എന്നീ സെല്ലുകളിലെ മൂല്യങ്ങളുടെ ക്രമീകരിച്ച അറേകൾ ഉണ്ടാക്കുന്നതിനു ശേഷം \/\/ഒരു പാത A (നീളം k) ഒരു പാത B (നീളം k) നേക്കാൾ ചെറുതായി കണക്കാക്കപ്പെടുന്നു \/\/നിങ്ങള് ക്ക് ഗ്രിഡില് നിന്ന് മാറിപ്പോകാന് കഴിയില്ല.\/\/അവയൊക്കെ വേറിട്ടവയായിരിക്കണം.\/\/k നീളമുള്ള ഒരു പാത കൃത്യമായി k സെല്ലുകൾ സന്ദർശിക്കുമെന്നാണ് (അല്ല \/\/യും\/\/മറ്റൊരു വാക്കില് , നിങ്ങള് ക്ക് നിങ്ങളുടെ നിലവിലെ ഘടകങ്ങളുമായി ഒരു വശത്ത് പങ്കിടുന്ന സെല്ലുകളിലേക്ക് പോകാം.\/\/ഏത് സെല്ലിൽ നിന്നും, ഓരോ ഘട്ടത്തിലും നിങ്ങൾക്ക് അയൽ സെല്ലുകളിലേക്ക് നീങ്ങാം,\/\/ഗ്രിഡിലെ k നീളമുള്ള ഏറ്റവും കുറഞ്ഞ പാത കണ്ടെത്തണം.\/\/ഗ്രിഡിലെ സെല്ലുകളിൽ കൃത്യമായി ഒരു തവണയാണ് inclusive കാണപ്പെടുന്നത്.\/\/ഗ്രിഡിലെ ഓരോ സെല്ലിലും ഒരു മൂല്യം അടങ്ങിയിരിക്കുന്നു. [1, N * N] യിലെ ഓരോ പൂർണ്ണസംഖ്യയും\/\/N വരികളും N നിരകളും ഉള്ള ഒരു ഗ്രിഡ് (N >= 2) ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ k, \/\/ >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n\/\/ [1, 2, 1]\n\/\/ >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\/\/ [1]\nfunction minPath(grid: number[][], k: number): number[] {\n","canonical_solution":"function minPath(grid: number[][], k: number): number[] {\n    const N = grid.length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    \n    type State = {path: number[], x: number, y: number, len: number};\n    \n    \/\/ Compare two paths lexicographically\n    const isLess = (a: number[], b: number[]): boolean => {\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) return a[i] < b[i];\n        }\n        return false;\n    };\n\n    let bestPath: number[] = new Array(k).fill(Number.MAX_VALUE);\n    \n    \/\/ DFS function to explore paths of length k\n    function dfs(x: number, y: number, path: number[], len: number): void {\n        if (len === k) {\n            if (isLess(path, bestPath)) {\n                bestPath = [...path];\n            }\n            return;\n        }\n        \n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                dfs(nx, ny, [...path, grid[nx][ny]], len + 1);\n            }\n        }\n    }\n    \n    \/\/ Try starting from each cell\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            dfs(i, j, [grid[i][j]], 1);\n        }\n    }\n    \n    return bestPath;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_130","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ട്രിബൊനാച്ചി ശ്രേണിയിലെ ആദ്യത്തെ n + 1 സംഖ്യകൾ.\/\/നിങ്ങള് ക്ക് ഒരു നെഗറ്റീവ് അല്ലാത്ത സംഖ്യ n കിട്ടും, നിങ്ങള്  ന്റെ ഒരു അറേ തിരിച്ചു കൊടുക്കണം.\/\/= 2 + 3 + 3 = 8 \/\/ത്രി) = ത്രി) + ത്രി) + ത്രി)\/\/ത്രി) = 3 \/\/ത്രി2) = 1 + (2 \/ 2) = 2 \/\/ഉദാഹരണത്തിന്: \/\/n = n-1 + n-2 + n-1 ആണെങ്കിൽ n ഒരു ഒറ്റസംഖ്യയാണ്.\/\/ത്രികോണം n) = 1 + n \/ 2, n ഇരട്ട ആണെങ്കിൽ.\/\/ത്രി) = 3 \/\/ട്രിബോണാച്ചി ശ്രേണിയുടെ നിർവചനം താഴെ പറയുന്നതുമാണ്:\/\/എന്നിരുന്നാലും, ആളുകൾക്ക് അറിയാത്തത് ട്രിബൊനാച്ചി ശ്രേണിയാണ്.\/\/ഫിബോനാച്ചി ശ്രേണിയെ കുറിച്ച് എല്ലാവർക്കും അറിയാം, അത് ഗണിതശാസ്ത്രജ്ഞർ ആഴത്തിൽ പഠിച്ചു.\/\/ >>> tri(3)\n\/\/ [1, 3, 2, 8]\nfunction tri(n: number): number[] {\n","canonical_solution":"function tri(n: number): number[] {\n    const tribonacci: number[] = [1, 3]; \/\/ Initialize with first two definite values\n\n    function calculateTribonacci(index: number): number {\n        if (index < tribonacci.length) {\n            return tribonacci[index];\n        }\n\n        let result: number;\n        if (index % 2 === 0) {\n            result = 1 + index \/ 2;\n        } else {\n            result = calculateTribonacci(index - 1) + calculateTribonacci(index - 2) + calculateTribonacci(index + 1);\n        }\n\n        tribonacci[index] = result; \/\/ Memoize the result\n        return result;\n    }\n\n    for (let i = 0; i <= n; i++) {\n        calculateTribonacci(i);\n    }\n\n    return tribonacci.slice(0, n + 1);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = tri;\n  assert.deepEqual(candidate(3),[1, 3, 2, 8]);\n  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);\n  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);\n  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);\n  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);\n  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);\n  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n  assert.deepEqual(candidate(0),[1]);\n  assert.deepEqual(candidate(1),[1, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_131","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/എല്ലാ അക്കങ്ങളും ജോഡി ആണെങ്കിൽ 0 തിരികെ നൽകുക.\/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, അസമമായ അക്കങ്ങളുടെ ഗുണനം നൽകുക.\/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunction digits(n: number): number {\n","canonical_solution":"function digits(n: number): number {\n    let product = 1;\n    let hasOdd = false;\n    \n    while (n > 0) {\n        let digit = n % 10;\n        if (digit % 2 !== 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n = Math.floor(n \/ 10);\n    }\n\n    return hasOdd ? product : 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = digits;\n  assert.deepEqual(candidate(5),5);\n  assert.deepEqual(candidate(54),5);\n  assert.deepEqual(candidate(120),1);\n  assert.deepEqual(candidate(5014),5);\n  assert.deepEqual(candidate(98765),315);\n  assert.deepEqual(candidate(5576543),2625);\n  assert.deepEqual(candidate(2468),0);\n}\n\ntest();"},{"task_id":"HumanEval_132","nl":"mal_Mlym","pl":"ts","prompt":"\/\/യില് കുറഞ്ഞത് ഒരു ബ്രാക്കറ്റ് എങ്കിലും കൂട്ടിയിണക്കിയിട്ടുണ്ടാവണം.\/\/ബ്രാക്കറ്റുകളുടെ സാധുവായ ഒരു അനുക്രമം ഉണ്ടെങ്കിൽ മാത്രമേ ഫംഗ്ഷൻ true ആയി മടങ്ങുകയുള്ളൂ.\/\/ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ ഉണ്ടാക്കുക, അതിൽ ചതുരാകൃതിയിലുള്ള ബ്രാക്കറ്റുകൾ മാത്രമേ ഉള്ളൂ.\/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunction is_nested(string: string): boolean {\n","canonical_solution":"function is_nested(string: string): boolean {\n    let depth = 0;\n    let hasNesting = false;\n\n    for (let char of string) {\n        if (char === '[') {\n            depth++;\n            if (depth > 1) {\n                hasNesting = true;\n            }\n        } else if (char === ']') {\n            if (depth > 0) {\n                depth--;\n            } else {\n                \/\/ More closing brackets than opening\n                return false;\n            }\n        }\n    }\n\n    \/\/ Return true if there was at least one nested bracket and all brackets are matched\n    return hasNesting && depth === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_133","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ആദ്യം അറേയിലെ ഓരോ എലമെന്റും മുകളിലെ int (~) യിലേക്ക് ചുരുക്കുക.\/\/നിങ്ങൾ നൽകിയ ശ്രേണിയിലെ സംഖ്യകളുടെ ചതുരശ്ര സംഖ്യകളുടെ തുക തിരികെ നൽകണം, \/\/നിങ്ങള് ക്ക് ഒരു സംഖ്യാ ശ്രേണി നല് കിയിട്ടുണ്ട്.\/\/ >>> lst([1.0, 2.0, 3.0])\n\/\/ 14\n\/\/ >>> lst([1.0, 4.0, 9.0])\n\/\/ 98\n\/\/ >>> lst([1.0, 3.0, 5.0, 7.0])\n\/\/ 84\n\/\/ >>> lst([1.4, 4.2, 0.0])\n\/\/ 29\n\/\/ >>> lst([-2.4, 1.0, 1.0])\n\/\/ 6\nfunction sum_squares(lst: number[]): number {\n","canonical_solution":"function sum_squares(lst: number[]): number {\n    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);\n}\n\n\/\/ Example usage:\n\/\/ console.log(sum_squares([1.0, 2.0, 3.0])); \/\/ Output: 14\n\/\/ console.log(sum_squares([1.0, 4.0, 9.0])); \/\/ Output: 98\n\/\/ console.log(sum_squares([1.0, 3.0, 5.0, 7.0])); \/\/ Output: 84\n\/\/ console.log(sum_squares([1.4, 4.2, 0.0])); \/\/ Output: 29\n\/\/ console.log(sum_squares([-2.4, 1.0, 1.0])); \/\/ Output: 6","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);\n  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);\n  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);\n  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);\n  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);\n  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);\n  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);\n  assert.deepEqual(candidate([0.0]),0);\n  assert.deepEqual(candidate([-1.0]),1);\n  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);\n}\n\ntest();"},{"task_id":"HumanEval_134","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/കുറിപ്പ്: \"വചനം\" എന്നത് സ്പെയ്സ് കൊണ്ട് വേർതിരിക്കുന്ന പ്രതീകങ്ങളുടെ ഒരു കൂട്ടമാണ്.\/\/ഒരു വാക്കിന്റെ ഭാഗം, അല്ലാത്തപക്ഷം തെറ്റാണ്.\/\/ഒരു സ്ട്രിങ്ങിന്റെ അക്ഷരമാലയിലെ പ്രതീകമാണ് \/\/അവസാനത്തെ പ്രതീകം  ആണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ ഉണ്ടാക്കുക.\/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunction check_if_last_char_is_a_letter(txt: string): boolean {\n","canonical_solution":"function check_if_last_char_is_a_letter(txt: string): boolean {\n    if (txt.trim() === \"\") return false; \/\/ Handle empty or whitespace strings\n\n    \/\/ Trim the string to remove any trailing spaces\n    txt = txt.trim();\n\n    \/\/ Check if the last character is an alphabetical letter and ensure there's a space before it\n    const lastChar = txt.charAt(txt.length - 1);\n    const isAlpha = \/[a-zA-Z]\/.test(lastChar);\n\n    return isAlpha && txt.lastIndexOf(' ') === txt.length - 2;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = check_if_last_char_is_a_letter;\n  assert.deepEqual(candidate(\"apple\"),false);\n  assert.deepEqual(candidate(\"apple pi e\"),true);\n  assert.deepEqual(candidate(\"eeeee\"),false);\n  assert.deepEqual(candidate(\"A\"),true);\n  assert.deepEqual(candidate(\"Pumpkin pie \"),false);\n  assert.deepEqual(candidate(\"Pumpkin pie 1\"),false);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"eeeee e \"),false);\n  assert.deepEqual(candidate(\"apple pie\"),false);\n  assert.deepEqual(candidate(\"apple pi e \"),false);\n}\n\ntest();"},{"task_id":"HumanEval_135","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഇരട്ട മൂല്യങ്ങൾ\/\/അത്തരം ഒരു ഘടകം നിലവിലില്ലെങ്കിൽ -1 തിരികെ നൽകുക.\/\/തൊട്ടു മുമ്പുള്ള മൂലകത്തേക്കാൾ വലുതോ തുല്യമോ അല്ല.\/\/ഒരു ഘടകത്തിന്റെ ഏറ്റവും വലിയ സൂചിക നൽകുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക.\/\/ >>> can_arrange([1, 2, 4, 3, 5])\n\/\/ 3\n\/\/ >>> can_arrange([1, 2, 3])\n\/\/ -1\nfunction can_arrange(arr: number[]): number {\n","canonical_solution":"function can_arrange(arr: number[]): number {\n    for (let i = arr.length - 1; i > 0; i--) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = can_arrange;\n  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);\n  assert.deepEqual(candidate([1, 2, 4, 5]),-1);\n  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);\n  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);\n  assert.deepEqual(candidate([]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_136","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/പോസിറ്റീവ് ആയതോ നെഗറ്റീവ് ആയതോ ആയ സംഖ്യകളൊന്നും ഇല്ലെങ്കിൽ അവയെ undefined ആയി തിരിച്ചുവിടുക.\/\/ഒരു അറേയിലെ പോസിറ്റീവ് ഇന്ററുകളുടെ എണ്ണം.\/\/ഏറ്റവും വലിയ നെഗറ്റീവ് ഇന്റഗ്രൽ ആണ്, ഏറ്റവും ചെറിയത് b ആണ്.\/\/ഒരു ഫങ്ഷൻ ഉണ്ടാക്കുക, അത് ഒരു അറേ (a, b) റിട്ടേൺ ചെയ്യും, അവിടെ 'a'  ആണ്.\/\/ >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n\/\/ [undefined, 1]\n\/\/ >>> largest_smallest_integers([])\n\/\/ [undefined, undefined]\n\/\/ >>> largest_smallest_integers([0])\n\/\/ [undefined, undefined]\nfunction largest_smallest_integers(lst: number[]): [number | undefined, number | undefined] {\n","canonical_solution":"function largest_smallest_integers(lst: number[]): [number | undefined, number | undefined] {\n    let largestNegative: number | undefined = undefined;\n    let smallestPositive: number | undefined = undefined;\n\n    for (let num of lst) {\n        if (num < 0) {\n            if (largestNegative === undefined || num > largestNegative) {\n                largestNegative = num;\n            }\n        } else if (num > 0) {\n            if (smallestPositive === undefined || num < smallestPositive) {\n                smallestPositive = num;\n            }\n        }\n    }\n\n    return [largestNegative, smallestPositive];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined, undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_138","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം \/\/n എന്ന സംഖ്യയെ കൃത്യമായി 4 പോസിറ്റീവ് ഇരട്ട സംഖ്യകളുടെ തുകയായി എഴുതാനാകുമോ എന്ന് വിലയിരുത്തുക.\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunction is_equal_to_sum_even(n: number): boolean {\n","canonical_solution":"function is_equal_to_sum_even(n: number): boolean {\n    \/\/ The sum of 4 positive even numbers is always even and 8 is the smallest such sum (2 + 2 + 2 + 2).\n    \/\/ Hence, if n is greater than or equal to 8 and even, n can be expressed as the sum of 4 positive even numbers.\n    return (n >= 8) && (n % 2 === 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_equal_to_sum_even;\n  assert.deepEqual(candidate(4),false);\n  assert.deepEqual(candidate(6),false);\n  assert.deepEqual(candidate(8),true);\n  assert.deepEqual(candidate(10),true);\n  assert.deepEqual(candidate(11),false);\n  assert.deepEqual(candidate(12),true);\n  assert.deepEqual(candidate(13),false);\n  assert.deepEqual(candidate(16),true);\n}\n\ntest();"},{"task_id":"HumanEval_139","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/n > 0 \/\/ബ്രസീലിയൻ_ഫാക്ടോറിയൽ (n) = n! * (n-1)! * (n-2)! * . . . * 1! \/\/ബ്രസീലിയൻ ഫാക്ടോറിയൽ താഴെ പറയുന്ന രീതിയിൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു:\/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunction special_factorial(n: number): number {\n","canonical_solution":"function factorial(n: number): number {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nfunction special_factorial(n: number): number {\n    if (n <= 0) throw new Error(\"Input must be a positive integer\");\n    \n    let result = 1;\n    for (let i = n; i >= 1; i--) {\n        result *= factorial(i);\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = special_factorial;\n  assert.deepEqual(candidate(4),288);\n  assert.deepEqual(candidate(5),34560);\n  assert.deepEqual(candidate(7),125411328000);\n  assert.deepEqual(candidate(1),1);\n}\n\ntest();"},{"task_id":"HumanEval_140","nl":"mal_Mlym","pl":"ts","prompt":"\/\/പിന്നെ തുടർച്ചയായ എല്ലാ സ്പെയ്സുകളും മാറ്റി - \/\/ഒരു സ്ട്രിങിന് തുടർച്ചയായി 2 സ്പെയ്സുകളിലധികം ഉണ്ടെങ്കിൽ,\/\/ഒരു ടെക്സ്റ്റ് സ്ട്രിംഗ് തന്നാൽ, അതിലെ എല്ലാ സ്പെയ്സുകളും അടിവരയിടുക, \/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunction fix_spaces(text: string): string {\n","canonical_solution":"function fix_spaces(text: string): string {\n    \/\/ Trim leading and trailing spaces\n    let trimmedText = text.trim();\n\n    \/\/ Use a regular expression to replace all sequences of two or more spaces with \"-\"\n    let replacedText = trimmedText.replace(\/ {2,}\/g, '-');\n\n    \/\/ Replace remaining single spaces with underscores\n    replacedText = replacedText.replace(\/ \/g, '_');\n\n    return replacedText;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fix_spaces;\n  assert.deepEqual(candidate(\"Example\"),\"Example\");\n  assert.deepEqual(candidate(\"Mudasir Hanif \"),\"Mudasir_Hanif_\");\n  assert.deepEqual(candidate(\"Yellow Yellow  Dirty  Fellow\"),\"Yellow_Yellow__Dirty__Fellow\");\n  assert.deepEqual(candidate(\"Exa   mple\"),\"Exa-mple\");\n  assert.deepEqual(candidate(\"   Exa 1 2 2 mple\"),\"-Exa_1_2_2_mple\");\n}\n\ntest();"},{"task_id":"HumanEval_141","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/- ഡോട്ടിന് ശേഷം വരുന്ന സബ് സ്ട്രിംഗ് ഇവരിൽ ഒരാളായിരിക്കണം: ['txt', 'exe', 'dll'] \/\/ലാറ്റിൻ അക്ഷരമാലയിലെ അക്ഷരങ്ങൾ ('a'-'z' and 'A'-'Z').\/\/- ഡോട്ടിന് മുമ്പുള്ള സബ്സ്ട്രിംഗ് ശൂന്യമായിരിക്കരുത്, അത് തുടങ്ങുന്നത്  എന്ന അക്ഷരത്തിൽ നിന്നാണ്.\/\/- ഫയലിന്റെ പേരില് ഒരു ഡോട്ട് മാത്രമേ ഉള്ളൂ.\/\/- ഫയലിന്റെ പേരിന് മൂന്ന് അക്കങ്ങളിൽ കൂടുതലാകരുത് ('0'-'9').\/\/യും\/\/താഴെ പറയുന്ന എല്ലാ വ്യവസ്ഥകളും പാലിച്ചാൽ മാത്രമേ ഒരു ഫയലിന്റെ പേര് സാധുവായതായി കണക്കാക്കുകയുള്ളൂ.\/\/ഫയലിന്റെ പേര് സാധുവാണെങ്കിൽ 'അതെ', അല്ലാത്തപക്ഷം 'ഇല്ല' എന്ന് നൽകുന്നു.\/\/ഒരു ഫയലിന്റെ പേര് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് എടുത്ത്  എന്ന് റിട്ടേൺ ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ ഉണ്ടാക്കുക.\/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunction file_name_check(file_name: string): string {\n","canonical_solution":"function file_name_check(file_name: string): string {\n    \/\/ Split the file name into name and extension based on the dot\n    const parts = file_name.split('.');\n    \n    \/\/ Check if there's exactly one dot\n    if (parts.length !== 2) {\n        return 'No';\n    }\n    \n    const [name, extension] = parts;\n    \n    \/\/ Check if the substring before the dot is not empty and starts with a latin letter\n    if (name.length === 0 || !\/^[a-zA-Z]\/.test(name)) {\n        return 'No';\n    }\n    \n    \/\/ Check if the number of digits in the name is not more than three\n    const digitCount = (name.match(\/\\d\/g) || []).length;\n    if (digitCount > 3) {\n        return 'No';\n    }\n    \n    \/\/ Check if the extension is one of the valid options\n    const validExtensions = ['txt', 'exe', 'dll'];\n    if (!validExtensions.includes(extension)) {\n        return 'No';\n    }\n    \n    \/\/ All conditions are met, the file name is valid\n    return 'Yes';\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = file_name_check;\n  assert.deepEqual(candidate(\"example.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"1example.dll\"),\"No\");\n  assert.deepEqual(candidate(\"s1sdf3.asd\"),\"No\");\n  assert.deepEqual(candidate(\"K.dll\"),\"Yes\");\n  assert.deepEqual(candidate(\"MY16FILE3.exe\"),\"Yes\");\n  assert.deepEqual(candidate(\"His12FILE94.exe\"),\"No\");\n  assert.deepEqual(candidate(\"_Y.txt\"),\"No\");\n  assert.deepEqual(candidate(\"?aREYA.exe\"),\"No\");\n  assert.deepEqual(candidate(\"\/this_is_valid.dll\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_valid.wow\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_valid.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"this_is_valid.txtexe\"),\"No\");\n  assert.deepEqual(candidate(\"#this2_i4s_5valid.ten\"),\"No\");\n  assert.deepEqual(candidate(\"@this1_is6_valid.exe\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_12valid.6exe4.txt\"),\"No\");\n  assert.deepEqual(candidate(\"all.exe.txt\"),\"No\");\n  assert.deepEqual(candidate(\"I563_No.exe\"),\"Yes\");\n  assert.deepEqual(candidate(\"Is3youfault.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"no_one#knows.dll\"),\"Yes\");\n  assert.deepEqual(candidate(\"1I563_Yes3.exe\"),\"No\");\n  assert.deepEqual(candidate(\"I563_Yes3.txtt\"),\"No\");\n  assert.deepEqual(candidate(\"final..txt\"),\"No\");\n  assert.deepEqual(candidate(\"final132\"),\"No\");\n  assert.deepEqual(candidate(\"_f4indsartal132.\"),\"No\");\n  assert.deepEqual(candidate(\".txt\"),\"No\");\n  assert.deepEqual(candidate(\"s.\"),\"No\");\n}\n\ntest();"},{"task_id":"HumanEval_142","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/                                                                                                                                                                                                                                                      \/\/3 ന്റെ ഗുണിതവും അതിന്റെ സൂചിക 4 ന്റെ ഗുണിതമാണെങ്കിൽ പൂർണ്ണസംഖ്യ എൻട്രി ക്യൂബ് ചെയ്യും.\/\/ഈ ഫംഗ്ഷൻ ഒരു അറേ എടുക്കും. അറേയിലെ എല്ലാ എൻട്രികൾക്കും, ഫംഗ്ഷൻ അതിന്റെ ഇൻഡെക്സ് a ആണെങ്കിൽ പൂർണ്ണസംഖ്യ എൻട്രിയുടെ ചതുരശ്രണം എടുക്കും.\/\/\" \/\/ >>> lst\n\/\/ [1, 2, 3]\n\/\/ >>> lst\n\/\/ []\n\/\/ >>> lst\n\/\/ [-1, -5, 2, -1, -5]\nfunction sum_squares(lst: number[]): number {\n","canonical_solution":"function sum_squares(lst: number[]): number {\n    return lst.reduce((sum, value, index) => {\n        if (index % 3 === 0) {\n            return sum + (value * value);\n        } else if (index % 4 === 0) {\n            return sum + (value * value * value);\n        } else {\n            return sum + value;\n        }\n    }, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1, 2, 3]),6);\n  assert.deepEqual(candidate([1, 4, 9]),14);\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);\n  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);\n  assert.deepEqual(candidate([0]),0);\n  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);\n  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);\n  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);\n  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);\n  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);\n}\n\ntest();"},{"task_id":"HumanEval_143","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം 1:\/\/പുതിയ സ്ട്രിങ്ങിലെ വാക്കുകളുടെ ക്രമം ഒറിജിനലിലേതിന് സമാനമായിരിക്കണം.\/\/ന്റെ നീളം പ്രൈം നമ്പറുകളാണ്,\/\/ എന്ന വാക്യത്തിന്റെ വാക്കുകൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് തിരികെ നൽകണം.\/\/വാക്യത്തില് ചില വാക്കുകള് സ്പെയ്സ് കൊണ്ട് വേര് പിരിയുന്നു,\/\/നിങ്ങള് ക്ക് ഒരു വാക്യത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് നല് കുന്നു,\/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunction words_in_sentence(sentence: string): string {\n","canonical_solution":"function isPrime(num: number): boolean {\n    if (num < 2) return false;\n    for (let i = 2; i * i <= num; i++) {\n        if (num % i === 0) return false;\n    }\n    return true;\n}\n\nfunction words_in_sentence(sentence: string): string {\n    return sentence\n        .split(' ')\n        .filter(word => isPrime(word.length))\n        .join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = words_in_sentence;\n  assert.deepEqual(candidate(\"This is a test\"),\"is\");\n  assert.deepEqual(candidate(\"lets go for swimming\"),\"go for\");\n  assert.deepEqual(candidate(\"there is no place available here\"),\"there is no place\");\n  assert.deepEqual(candidate(\"Hi I am Hussein\"),\"Hi am Hussein\");\n  assert.deepEqual(candidate(\"go for it\"),\"go for it\");\n  assert.deepEqual(candidate(\"here\"),\"\");\n  assert.deepEqual(candidate(\"here is\"),\"is\");\n}\n\ntest();"},{"task_id":"HumanEval_144","nl":"mal_Mlym","pl":"ts","prompt":"\/\/x, n എന്നിവ സാധുവായ ഭിന്നസംഖ്യകളാണെന്നും അവയ്ക്ക് നാമകരണമായി പൂജ്യമില്ലെന്നും കരുതാം.\/\/ഇവിടെ സംഖ്യയും നാമവിശേഷണവും പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്.\/\/x ഉം n ഉം ഒരു ഭിന്നസംഖ്യയുടെ സ്ട്രിംഗ് പ്രതിനിധീകരണമാണ്, അവയ്ക്ക് ഇനിപ്പറയുന്ന ഫോർമാറ്റ് ഉണ്ട്,\/\/x * n. x * n ഒരു പൂർണ്ണസംഖ്യയായി വിലയിരുത്തുകയും false  ആയി വിലയിരുത്തുകയും ചെയ്താൽ ഫംഗ്ഷൻ true ആയി നൽകുന്നു.\/\/നിങ്ങളുടെ ജോലി ഈ എക്സ്പ്രഷനെ ലളിതമാക്കുന്ന ഒരു ഫങ്ഷൻ ഉണ്ടാക്കുക എന്നതാണ്.\/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunction simplify(x: string, n: string): boolean {\n","canonical_solution":"function simplify(x: string, n: string): boolean {\n    const parseFraction = (fraction: string): [number, number] => {\n        const [numerator, denominator] = fraction.split('\/').map(Number);\n        return [numerator, denominator];\n    };\n\n    const [xNumerator, xDenominator] = parseFraction(x);\n    const [nNumerator, nDenominator] = parseFraction(n);\n\n    \/\/ Multiply the fractions: (a\/b) * (c\/d) = (a*c) \/ (b*d)\n    const resultNumerator = xNumerator * nNumerator;\n    const resultDenominator = xDenominator * nDenominator;\n\n    \/\/ A product of fractions is a whole number if its numerator divided by denominator is an integer.\n    return resultNumerator % resultDenominator === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = simplify;\n  assert.deepEqual(candidate(\"1\/5\", \"5\/1\"),true);\n  assert.deepEqual(candidate(\"1\/6\", \"2\/1\"),false);\n  assert.deepEqual(candidate(\"5\/1\", \"3\/1\"),true);\n  assert.deepEqual(candidate(\"7\/10\", \"10\/2\"),false);\n  assert.deepEqual(candidate(\"2\/10\", \"50\/10\"),true);\n  assert.deepEqual(candidate(\"7\/2\", \"4\/2\"),true);\n  assert.deepEqual(candidate(\"11\/6\", \"6\/1\"),true);\n  assert.deepEqual(candidate(\"2\/3\", \"5\/2\"),false);\n  assert.deepEqual(candidate(\"5\/2\", \"3\/5\"),false);\n  assert.deepEqual(candidate(\"2\/4\", \"8\/4\"),true);\n  assert.deepEqual(candidate(\"2\/4\", \"4\/2\"),true);\n  assert.deepEqual(candidate(\"1\/5\", \"5\/1\"),true);\n  assert.deepEqual(candidate(\"1\/5\", \"1\/5\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_145","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/അവയെ യഥാർത്ഥ അറേയിലെ ഇൻഡെക്സിന്റെ അടിസ്ഥാനത്തിൽ ക്രമീകരിക്കുക.\/\/കുറിപ്പ്: നിരവധി ഇനങ്ങള് ഉണ്ടെങ്കില് അവയുടെ സംഖ്യകളുടെ തുക സമാനമാണെങ്കില്,\/\/അവരുടെ അക്കങ്ങളുടെ സംഖ്യ അനുസരിച്ച് ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം\/\/ഒരു ഫങ്ഷൻ എഴുതുക, അത് തന്നിരിക്കുന്ന സംഖ്യകളുടെ അറേയെ തരം തിരിക്കുക.\/\/ >>> order_by_points([1, 11, -1, -11, -12])\n\/\/ [-1, -11, 1, -12, 11]\n\/\/ >>> order_by_points([])\n\/\/ []\nfunction order_by_points(nums: number[]): number[] {\n","canonical_solution":"function order_by_points(nums: number[]): number[] {\n    const digitSum = (num: number): number => {\n        let sum = 0;\n        let value = Math.abs(num);\n        while (value > 0) {\n            sum += value % 10;\n            value = Math.floor(value \/ 10);\n        }\n        return sum;\n    };\n\n    return nums\n        .map((num, index) => ({ num, index, sumOfDigits: digitSum(num) }))\n        .sort((a, b) => {\n            if (a.sumOfDigits === b.sumOfDigits) {\n                return a.index - b.index;\n            }\n            return a.sumOfDigits - b.sumOfDigits;\n        })\n        .map(item => item.num);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = order_by_points;\n  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);\n  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);\n}\n\ntest();"},{"task_id":"HumanEval_146","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/ഒരു സംഖ്യയുടെ ആദ്യത്തെയും അവസാനത്തെയും അക്കം ഒറ്റക്കാണ് (1, 3, 5, 7, 9).\/\/അറേയിലെ 10 ലും കൂടുതലുള്ള ഘടകങ്ങളുടെ എണ്ണം, രണ്ടും \/\/ഒരു സംഖ്യകളുടെ അറേയെ ഇൻപുട്ടായി എടുത്ത് റിട്ടേൺ ചെയ്യുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.\/\/ >>> specialFilter([15, -73, 14, -15])\n\/\/ 1\n\/\/ >>> specialFilter([33, -2, -3, 45, 21, 109])\n\/\/ 2\nfunction specialFilter(nums: number[]): number {\n","canonical_solution":"function specialFilter(nums: number[]): number {\n    const isOdd = (digit: number): boolean => digit % 2 !== 0;\n\n    return nums.reduce((count, num) => {\n        const absNumStr = Math.abs(num).toString();\n        const firstDigit = parseInt(absNumStr[0]);\n        const lastDigit = parseInt(absNumStr[absNumStr.length - 1]);\n\n        if (num > 10 && isOdd(firstDigit) && isOdd(lastDigit)) {\n            return count + 1;\n        }\n\n        return count;\n    }, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = specialFilter;\n  assert.deepEqual(candidate([5, -2, 1, -5]),0);\n  assert.deepEqual(candidate([15, -73, 14, -15]),1);\n  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);\n  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);\n  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);\n  assert.deepEqual(candidate([1]),0);\n  assert.deepEqual(candidate([]),0);\n}\n\ntest();"},{"task_id":"HumanEval_147","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം:\/\/പിന്നെ a[i] + a[j] + a[k] എന്നത് 3 ന്റെ ഗുണിതമാണ്.\/\/i < j < k,  എന്നതിന്റെ ട്രിപ്പിൾ എണ്ണം (a[i], a[j], a[k]) തിരികെ നൽകുക\/\/ഓരോ i-നും (1 ≤ i ≤ n) a[i] = i * i - i + 1 ന്റെ മൂല്യം\/\/നിങ്ങള് ക്ക് ഒരു പോസിറ്റീവ് ഇന്റര് നമ്പര് n കിട്ടും. നിങ്ങള് ഒരു ഇന്റര് അറേ ഉണ്ടാക്കണം a നീളം n ന്റെ.\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunction get_max_triples(n: number): number {\n","canonical_solution":"function get_max_triples(n: number): number {\n    const a: number[] = [];\n\n    for (let i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    let count = 0;\n\n    for (let i = 0; i < n - 2; i++) {\n        for (let j = i + 1; j < n - 1; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 === 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_max_triples;\n  assert.deepEqual(candidate(5),1);\n  assert.deepEqual(candidate(6),4);\n  assert.deepEqual(candidate(10),36);\n  assert.deepEqual(candidate(100),53361);\n}\n\ntest();"},{"task_id":"HumanEval_149","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/എല്ലാ വാക്കുകളും ഒരേ നീളമുള്ളതാണെന്ന് നിങ്ങള് വിചാരിച്ചേക്കാം.\/\/ഫങ്ഷൻ ഒരു സ്ട്രിംഗ് ക്രമത്തിൽ നൽകണം.\/\/രണ്ടു വാക്കുകള് ക്ക് ഒരേ നീളം ഉണ്ടെങ്കില് , അക്ഷരമാലാ ക്രമത്തില് അറേ അടുക്കുക.\/\/ആ നിയമപ്രകാരം ക്രമീകരിച്ച അറേ തിരികെ നൽകണം.\/\/ഓരോ വാക്കിന്റെയും നീളം അനുസരിച്ച് അറേയുടെ ക്രമം ഉയരുകയും വേണം, പിന്നെ നിങ്ങള്ക്ക് \/\/ഇതില് തനിപ്പകർപ്പുകള് ഉണ്ടായിരിക്കാം.\/\/അറേ എല്ലായ്പ്പോഴും സ്ട്രിങ്ങുകളുടെ ഒരു അറേ ആണ്, ഒരിക്കലും സംഖ്യകളുടെ ഒരു അറേ അല്ല,\/\/ ഒരു ക്രമീകരിച്ച ക്രമത്തിൽ ഫലമായി ലഭിച്ച അറേ തിരികെ നൽകുന്നു,\/\/അതിൽ നിന്നും അപൂർവ്വ ദൈർഘ്യമുള്ള സ്ട്രിങ്ങുകൾ ഇല്ലാതാക്കുന്നു, \/\/ഒരു സ്ട്രിംഗ് പരാമീറ്ററായി സ്വീകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക,\/\/ >>> list_sort([\"aa\", \"a\", \"aaa\"])\n\/\/ [\"aa\"]\n\/\/ >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/ [\"ab\", \"cd\"]\nfunction sorted_list_sum(lst: string[]): string[] {\n","canonical_solution":"function sorted_list_sum(lst: string[]): string[] {\n    \/\/ Filter out strings with odd lengths\n    const filtered = lst.filter(str => str.length % 2 === 0);\n    \/\/ Sort the array by length, then alphabetically\n    const sorted = filtered.sort((a, b) => {\n        if (a.length === b.length) {\n            return a.localeCompare(b);\n        }\n        return a.length - b.length;\n    });\n    return sorted;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sorted_list_sum;\n  assert.deepEqual(candidate([\"aa\", \"a\", \"aaa\"]),[\"aa\"]);\n  assert.deepEqual(candidate([\"school\", \"AI\", \"asdf\", \"b\"]),[\"AI\", \"asdf\", \"school\"]);\n  assert.deepEqual(candidate([\"d\", \"b\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]),[\"abcd\", \"dcba\"]);\n  assert.deepEqual(candidate([\"AI\", \"ai\", \"au\"]),[\"AI\", \"ai\", \"au\"]);\n  assert.deepEqual(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),[\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\n\ntest();"},{"task_id":"HumanEval_150","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/ഒരു പ്രൈം നമ്പർ ആണ്, y ന്റെ മൂല്യം തിരികെ നൽകണം.\/\/n ന്റെ മൂല്യം  ആണെങ്കിൽ x ന്റെ മൂല്യം തിരികെ നൽകുന്ന ഒരു ലളിതമായ പ്രോഗ്രാം.\/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunction x_or_y(n: number, x: number, y: number): number {\n","canonical_solution":"function x_or_y(n: number, x: number, y: number): number {\n    function isPrime(num: number): boolean {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        \n        if (num % 2 === 0 || num % 3 === 0) return false;\n        \n        for (let i = 5; i * i <= num; i += 6) {\n            if (num % i === 0 || num % (i + 2) === 0) return false;\n        }\n        \n        return true;\n    }\n\n    return isPrime(n) ? x : y;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = x_or_y;\n  assert.deepEqual(candidate(7, 34, 12),34);\n  assert.deepEqual(candidate(15, 8, 5),5);\n  assert.deepEqual(candidate(3, 33, 5212),33);\n  assert.deepEqual(candidate(1259, 3, 52),3);\n  assert.deepEqual(candidate(7919, -1, 12),-1);\n  assert.deepEqual(candidate(3609, 1245, 583),583);\n  assert.deepEqual(candidate(91, 56, 129),129);\n  assert.deepEqual(candidate(6, 34, 1234),1234);\n  assert.deepEqual(candidate(1, 2, 0),0);\n  assert.deepEqual(candidate(2, 2, 0),2);\n}\n\ntest();"},{"task_id":"HumanEval_151","nl":"mal_Mlym","pl":"ts","prompt":"\/\/നെഗറ്റീവ് ആയതോ പൂർണ്ണസംഖ്യകളല്ലാത്തതോ ആയ സംഖ്യകളെ അവഗണിക്കുക.\/\/ഒരു സംഖ്യകളുടെ അറേ കൊടുത്താൽ, സംഖ്യകളുടെ സമചതുരങ്ങളുടെ തുക തിരിച്ചു കൊടുക്കുക.\/\/ >>> double_the_difference([1, 3, 2, 0])\n\/\/ 10\n\/\/ >>> double_the_difference([-1, -2, 0])\n\/\/ 0\n\/\/ >>> double_the_difference([9, -2])\n\/\/ 81\n\/\/ >>> double_the_difference([0])\n\/\/ 0\n\/\/ If the input array is empty, return 0.\nfunction double_the_difference(lst: number[]): number {\n","canonical_solution":"function double_the_difference(lst: number[]): number {\n    return lst\n        .filter(num => Number.isInteger(num) && num > 0 && num % 2 !== 0)\n        .reduce((sum, num) => sum + num * num, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = double_the_difference;\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([5.0, 4.0]),25);\n  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);\n  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);\n  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);\n  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);\n  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);\n}\n\ntest();"},{"task_id":"HumanEval_152","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം:\/\/മൂല്യം 0 ആണെങ്കില് , അത് ഇല്ലെങ്കില് , അത് ഊഹവും സ്കോറും തമ്മിലുള്ള അബ്സലൂട്ട് വ്യത്യാസമാണ്.\/\/ഓരോ ഊഹവും എത്ര ദൂരം അകലെയാണെന്ന് സൂചിപ്പിക്കുന്ന അതേ നീളമുള്ള ഒരു അറേ മടക്കി നൽകുക.\/\/നിങ്ങള് ക്ക് രണ്ട് സ്കോറുകളും തുല്യ നീളമുള്ള ഊഹങ്ങളും നല് കിയിട്ടുണ്ട്, ഓരോ സൂചികയും ഒരു പൊരുത്തം കാണിക്കുന്നു.\/\/നിങ്ങളുടെ ജോലി ഒരു വ്യക്തി ശരിയായി മത്സരങ്ങൾ ഒരു എണ്ണം ഫലങ്ങൾ ഊഹിച്ചു എന്ന് നിർണ്ണയിക്കാൻ ആണ്.\/\/ഇത് ശ്രദ്ധിക്കുകയും താരതമ്യം ചെയ്യുകയും ചെയ്യേണ്ടതാണ്.\/\/ആ നിമിഷം നിങ്ങള് ക്ക് തോന്നിയ വികാരങ്ങളും ചിന്തകളും\/\/നമ്മള് എല്ലാവരും ആ വികാരത്തെ ഓര് ക്കുന്നുണ്ടാവും ,\/\/ >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n\/\/ [0, 0, 0, 0, 3, 3]\n\/\/ >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n\/\/ [4, 4, 1, 0, 0, 6]\nfunction compare(game: number[], guess: number[]): number[] {\n","canonical_solution":"function compare(game: number[], guess: number[]): number[] {\n    return game.map((score, index) => Math.abs(score - guess[index]));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = compare;\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);\n  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);\n  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);\n  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_153","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/(അതിന്റെ ശക്തി - 1 ആണ്).\/\/'Slices.SERVINGSliCes' എന്ന പദം തിരിച്ചു നൽകുക, കാരണം 'SERVINGSliCes' ആണ് ഏറ്റവും ശക്തമായ എക്സ്റ്റൻഷൻ.\/\/['സെര്വിന്ഗ്സ്ലിചെസ്', 'ചീസ്', 'സ്റ്റുഫെഡ്'] എന്നിങ്ങനെ വിപുലീകരണങ്ങളുണ്ടെങ്കിൽ നിങ്ങൾ \/\/ഉദാഹരണത്തിന്, നിങ്ങൾക്ക് \"സ്ലൈസുകൾ\" എന്ന ക്ലാസും ന്റെ ഒരു അറേയും നൽകിയിട്ടുണ്ടെങ്കിൽ\/\/ആദ്യം വരുന്നത് തിരഞ്ഞെടുക്കുക.\/\/ഒരേ ശക്തി ഉള്ള രണ്ടോ അതിലധികമോ എക്സ്റ്റൻഷനുകൾ ഉണ്ടെങ്കിൽ, നിങ്ങൾ \/\/ഫോർമാറ്റ്: ക്ലാസ് നാമം. ഏറ്റവും ശക്തമായ വിപുലീകരണ നാമം. \/\/നിങ്ങള് ഏറ്റവും ശക്തമായ വിപുലീകരണം കണ്ടെത്തി ഇതില് ഒരു സ്ട്രിംഗ് തിരികെ നല് കണം.\/\/വിപുലീകരണത്തിന്റെ പേരില് , CAP - SM എന്ന സംഖ്യയില് നിന്നാണ് ശക്തി ലഭിക്കുന്നത്.\/\/എക്സ്റ്റൻഷന്റെ പേരിന്റെ അക്ഷരങ്ങൾ, SM എന്നത് ചെറിയ അക്ഷരങ്ങളുടെ എണ്ണം \/\/വിപുലീകരണത്തിന്റെ ശക്തി ഇപ്രകാരമാണ്: CAP എന്നത് വലിയ അക്ഷരങ്ങളുടെ സംഖ്യയായിരിക്കട്ടെ \/\/ക്ലാസ്സിലേക്ക് അധിക ക്ലാസുകൾ ലോഡ് ചെയ്യുന്നതിനാണ് വിപുലീകരണങ്ങൾ ഉപയോഗിക്കുന്നത്.\/\/നിങ്ങള് ക്ക് ഒരു ക്ലാസിന്റെ പേരും (ഒരു സ്ട്രിംഗ്) ഒരു കൂട്ടം എക്സ്റ്റന് ഷനുകളും ലഭിക്കും.\/\/ >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\/\/ \"my_class.AA\"\nfunction Strongest_Extension(class_name: string, extensions: string[]): string {\n","canonical_solution":"function Strongest_Extension(class_name: string, extensions: string[]): string {\n    let strongestExtension = '';\n    let maxStrength = -Infinity;\n\n    extensions.forEach(extension => {\n        const capCount = extension.split('').filter(char => char >= 'A' && char <= 'Z').length;\n        const smCount = extension.split('').filter(char => char >= 'a' && char <= 'z').length;\n        const strength = capCount - smCount;\n\n        if (strength > maxStrength) {\n            maxStrength = strength;\n            strongestExtension = extension;\n        }\n    });\n\n    return `${class_name}.${strongestExtension}`;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = Strongest_Extension;\n  assert.deepEqual(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\");\n  assert.deepEqual(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\");\n  assert.deepEqual(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\");\n  assert.deepEqual(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\");\n  assert.deepEqual(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\");\n  assert.deepEqual(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\");\n  assert.deepEqual(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\"finNNalLLly.WoW\");\n  assert.deepEqual(candidate(\"_\", [\"Bb\", \"91245\"]),\"_.Bb\");\n  assert.deepEqual(candidate(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\");\n}\n\ntest();"},{"task_id":"HumanEval_154","nl":"mal_Mlym","pl":"ts","prompt":"\/\/നിങ്ങള് ക്ക് 2 വാക്കുകള് നല് കിയിട്ടുണ്ട്. രണ്ടാമത്തെ വാക്ക് അല്ലെങ്കില് അതില് ഏതെങ്കിലും ഒരു ഭ്രമണം ആദ്യത്തെ വാക്ക് യിലെ ഒരു സബ് സ്ട്രിംഗ് ആണെങ്കില് നിങ്ങള് true തിരിച്ച് നല് കണം.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunction cycpattern_check(a: string, b: string): boolean {\n","canonical_solution":"function cycpattern_check(a: string, b: string): boolean {\n    for (let i = 0; i < b.length; i++) {\n        const rotation = b.slice(i) + b.slice(0, i);\n        if (a.includes(rotation)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\/\/ Test cases\nconsole.log(cycpattern_check(\"abcd\", \"abd\")); \/\/ false\nconsole.log(cycpattern_check(\"hello\", \"ell\")); \/\/ true\nconsole.log(cycpattern_check(\"whassup\", \"psus\")); \/\/ false\nconsole.log(cycpattern_check(\"abab\", \"baa\")); \/\/ true\nconsole.log(cycpattern_check(\"efef\", \"eeff\")); \/\/ false\nconsole.log(cycpattern_check(\"himenss\", \"simen\")); \/\/ true","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = cycpattern_check;\n  assert.deepEqual(candidate(\"xyzw\", \"xyw\"),false);\n  assert.deepEqual(candidate(\"yello\", \"ell\"),true);\n  assert.deepEqual(candidate(\"whattup\", \"ptut\"),false);\n  assert.deepEqual(candidate(\"efef\", \"fee\"),true);\n  assert.deepEqual(candidate(\"abab\", \"aabb\"),false);\n  assert.deepEqual(candidate(\"winemtt\", \"tinem\"),true);\n}\n\ntest();"},{"task_id":"HumanEval_155","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/ഒരു പൂർണ്ണസംഖ്യ ലഭിച്ചാൽ, യഥാക്രമം, ഇരട്ടയും, അസംഖ്യം അക്കങ്ങളും ഉള്ള ഒരു അറേ മടക്കിനൽകുന്നു.\/\/ >>> even_odd_count(-12)\n\/\/ [1, 1]\n\/\/ >>> even_odd_count(123)\n\/\/ [1, 2]\nfunction even_odd_count(num: number): [number, number] {\n","canonical_solution":"function even_odd_count(num: number): [number, number] {\n    const numStr = Math.abs(num).toString();\n    let evenCount = 0;\n    let oddCount = 0;\n\n    for (let char of numStr) {\n        const digit = parseInt(char);\n        if (digit % 2 === 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    return [evenCount, oddCount];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = even_odd_count;\n  assert.deepEqual(candidate(7),[0, 1]);\n  assert.deepEqual(candidate(-78),[1, 1]);\n  assert.deepEqual(candidate(3452),[2, 2]);\n  assert.deepEqual(candidate(346211),[3, 3]);\n  assert.deepEqual(candidate(-345821),[3, 3]);\n  assert.deepEqual(candidate(-2),[1, 0]);\n  assert.deepEqual(candidate(-45347),[2, 3]);\n  assert.deepEqual(candidate(0),[1, 0]);\n}\n\ntest();"},{"task_id":"HumanEval_156","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങള്: \/\/പരിമിതികൾ: 1 <= num <= 1000 \/\/ചെറിയ അക്ഷരങ്ങളില് അത് തിരിച്ചു കൊടുക്കുക.\/\/ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ ലഭിച്ചാൽ, അതിന്റെ റോമൻ സംഖ്യാ തുല്യത ഒരു സ്ട്രിംഗായി ലഭിക്കും, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunction int_to_mini_roman(number: number): string {\n","canonical_solution":"function int_to_mini_roman(number: number): string {\n    const romanNumerals: { [key: number]: string } = {\n        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c',\n        90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix',\n        5: 'v', 4: 'iv', 1: 'i'\n    };\n    \n    let result = '';\n    for (const value of Object.keys(romanNumerals).map(Number).sort((a, b) => b - a)) {\n        while (number >= value) {\n            result += romanNumerals[value];\n            number -= value;\n        }\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = int_to_mini_roman;\n  assert.deepEqual(candidate(19),\"xix\");\n  assert.deepEqual(candidate(152),\"clii\");\n  assert.deepEqual(candidate(251),\"ccli\");\n  assert.deepEqual(candidate(426),\"cdxxvi\");\n  assert.deepEqual(candidate(500),\"d\");\n  assert.deepEqual(candidate(1),\"i\");\n  assert.deepEqual(candidate(4),\"iv\");\n  assert.deepEqual(candidate(43),\"xliii\");\n  assert.deepEqual(candidate(90),\"xc\");\n  assert.deepEqual(candidate(94),\"xciv\");\n  assert.deepEqual(candidate(532),\"dxxxii\");\n  assert.deepEqual(candidate(900),\"cm\");\n  assert.deepEqual(candidate(994),\"cmxciv\");\n  assert.deepEqual(candidate(1000),\"m\");\n}\n\ntest();"},{"task_id":"HumanEval_157","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/90 ഡിഗ്രി \/\/ഒരു വലതു കോണുള്ള ത്രികോണം ഒരു കോണും വലതു കോണുള്ള ത്രികോണമാണ്.\/\/വശങ്ങള് ഒരു വലതു കോണുള്ള ത്രികോണം ഉണ്ടാക്കുന്നു, അല്ലാത്തപക്ഷം തെറ്റാണ്.\/\/ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങളുടെ നീളം കണക്കിലെടുക്കുക. ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രണം\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunction right_angle_triangle(a: number, b: number, c: number): boolean {\n","canonical_solution":"function right_angle_triangle(a: number, b: number, c: number): boolean {\n    const sides = [a, b, c].sort((x, y) => x - y);\n    return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = right_angle_triangle;\n  assert.deepEqual(candidate(3, 4, 5),true);\n  assert.deepEqual(candidate(1, 2, 3),false);\n  assert.deepEqual(candidate(10, 6, 8),true);\n  assert.deepEqual(candidate(2, 2, 2),false);\n  assert.deepEqual(candidate(7, 24, 25),true);\n  assert.deepEqual(candidate(10, 5, 7),false);\n  assert.deepEqual(candidate(5, 12, 13),true);\n  assert.deepEqual(candidate(15, 8, 17),true);\n  assert.deepEqual(candidate(48, 55, 73),true);\n  assert.deepEqual(candidate(1, 1, 1),false);\n  assert.deepEqual(candidate(2, 2, 10),false);\n}\n\ntest();"},{"task_id":"HumanEval_158","nl":"mal_Mlym","pl":"ts","prompt":"\/\/അക്ഷരങ്ങളുടെ ക്രമത്തിൽ ആദ്യം വരുന്ന അക്ഷരമാണ് തിരികെ നൽകുക.\/\/ഒന്നിലധികം സ്ട്രിങ്ങുകൾക്ക് പരമാവധി എണ്ണം ഉണ്ടെങ്കിൽ,\/\/അറേയില് വ്യത്യസ്ത പദങ്ങള് അടങ്ങിയിരിക്കുന്നു. പരമാവധി എണ്ണം ഉപയോഗിച്ച് പദം തിരികെ നല് കുക.\/\/ഒരു സ്ട്രിംഗ് അറേ സ്വീകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.\/\/ >>> find_max([\"name\", \"of\", \"string\"])\n\/\/ \"string\"\n\/\/ >>> find_max([\"name\", \"enam\", \"game\"])\n\/\/ \"enam\"\n\/\/ >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/ \"aaaaaaa\"\nfunction find_max(words: string[]): string {\n","canonical_solution":"function find_max(words: string[]): string {\n    function uniqueCharacterCount(word: string): number {\n        const uniqueChars = new Set(word);\n        return uniqueChars.size;\n    }\n\n    let maxWord = words[0];\n    let maxUniqueCount = uniqueCharacterCount(maxWord);\n\n    for (let i = 1; i < words.length; i++) {\n        const currentUniqueCount = uniqueCharacterCount(words[i]);\n        if (\n            currentUniqueCount > maxUniqueCount ||\n            (currentUniqueCount === maxUniqueCount && words[i] < maxWord)\n        ) {\n            maxWord = words[i];\n            maxUniqueCount = currentUniqueCount;\n        }\n    }\n\n    return maxWord;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = find_max;\n  assert.deepEqual(candidate([\"name\", \"of\", \"string\"]),\"string\");\n  assert.deepEqual(candidate([\"name\", \"enam\", \"game\"]),\"enam\");\n  assert.deepEqual(candidate([\"aaaaaaa\", \"bb\", \"cc\"]),\"aaaaaaa\");\n  assert.deepEqual(candidate([\"abc\", \"cba\"]),\"abc\");\n  assert.deepEqual(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"gonna\", \"rock\"]),\"gonna\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]),\"nation\");\n  assert.deepEqual(candidate([\"this\", \"is\", \"a\", \"prrk\"]),\"this\");\n  assert.deepEqual(candidate([\"b\"]),\"b\");\n  assert.deepEqual(candidate([\"play\", \"play\", \"play\"]),\"play\");\n}\n\ntest();"},{"task_id":"HumanEval_159","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണം: \/\/മതിയായ കാരറ്റ് ബാക്കിയുണ്ടെങ്കിൽ, ബാക്കിയുള്ള കാരറ്റ് മുഴുവനും കഴിക്കും, പക്ഷേ ഇപ്പോഴും വിശപ്പ് അനുഭവപ്പെടും.\/\/നിങ്ങളുടെ ഭക്ഷണത്തിനു ശേഷം അവശേഷിക്കുന്ന കാരറ്റ് എണ്ണം ] \/\/നിങ്ങള് തിന്നുകഴിഞ്ഞ കാരറ്റ് എണ്ണത്തിന്റെ ഒരു കൂട്ടം നിങ്ങള് തിരിച്ച് നല്കണം.\/\/പക്ഷേ, ഇന്ന് നീ കൂടുതൽ കാരറ്റ് കഴിക്കണം.\/\/നീ ഒരു വിശന്ന മുയലാണ്, നീ ഇതിനകം ഒരു നിശ്ചിത എണ്ണം കാരറ്റ് കഴിച്ചു,\/\/ >>> eat(5, 6, 10)\n\/\/ [11, 4]\n\/\/ >>> eat(4, 8, 9)\n\/\/ [12, 1]\n\/\/ >>> eat(1, 10, 10)\n\/\/ [11, 0]\n\/\/ >>> eat(2, 11, 5)\n\/\/ [7, 0]\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunction eat(number: number, need: number, remaining: number): number[] {\n","canonical_solution":"function eat(number: number, need: number, remaining: number): number[] {\n    const totalEaten = number + Math.min(need, remaining);\n    const carrotsLeft = Math.max(remaining - need, 0);\n    return [totalEaten, carrotsLeft];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = eat;\n  assert.deepEqual(candidate(5, 6, 10),[11, 4]);\n  assert.deepEqual(candidate(4, 8, 9),[12, 1]);\n  assert.deepEqual(candidate(1, 10, 10),[11, 0]);\n  assert.deepEqual(candidate(2, 11, 5),[7, 0]);\n  assert.deepEqual(candidate(4, 5, 7),[9, 2]);\n  assert.deepEqual(candidate(4, 5, 1),[5, 0]);\n}\n\ntest();"},{"task_id":"HumanEval_160","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഓപ്പറേറ്റർ അറേയിൽ കുറഞ്ഞത് ഒരു ഓപ്പറേറ്ററും ഓപ്പറാൻഡ് അറേയിൽ കുറഞ്ഞത് രണ്ട് ഓപ്പറാൻഡുകളും ഉണ്ടായിരിക്കും.\/\/ഓപ്പറാന്റ് എന്നത് നെഗറ്റീവ് അല്ലാത്ത സംഖ്യകളുടെ ഒരു ശ്രേണിയാണ്.\/\/ഓപ്പറേറ്റർ അറേയുടെ നീളം ഓപ്പറാന്റ് അറേയുടെ നീളം കുറച്ചാൽ ഒന്നിന് തുല്യമാണ്.\/\/കുറിപ്പ്:\/\/=> ഫലം = 9 \/\/ഫലം = 2 + 3 * 4 - 5 \/\/അറേ = [2, 3, 4, 5] \/\/ഓപ്പറേറ്റർ ['+', '*', '-'] \/\/ഉദാഹരണം: \/\/എക്സ്പോണന്ഷ്യേഷൻ (**) യും\/\/നിലവിളക്കുകൾ (\/\/ഗുണനം (*) \/\/കുറയ്ക്കല് ( - ) \/\/കൂട്ടിച്ചേര് ത്തു (+) \/\/അടിസ്ഥാന അല് ജ്ബെറ പ്രവർത്തനങ്ങൾ:\/\/ഈ എക്സ്പ്രഷന്റെ വിലയിരുത്തൽ തിരികെ നൽകുക.\/\/രണ്ടാമത്തെ അറേ ഒരു പൂർണ്ണസംഖ്യകളുടെ അറേ ആണ്.\/\/രണ്ട് അറേ ഓപ്പറേറ്ററും ഓപ്പറാന്റും നല് കിയിരിക്കുകയാണ്. ആദ്യത്തെ അറേയില് അടിസ്ഥാന അൽജെബ്രാ പ്രവർത്തനങ്ങൾ ഉണ്ട്, function do_algebra(operator: string[], operand: number[]): number {\n","canonical_solution":"function do_algebra(operator: string[], operand: number[]): number {\n    let expression = operand[0].toString();\n\n    for (let i = 0; i < operator.length; i++) {\n        expression += ` ${operator[i]} ${operand[i + 1]}`;\n    }\n\n    return Math.floor(eval(expression));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = do_algebra;\n  assert.deepEqual(candidate([\"**\", \"*\", \"+\"], [2, 3, 4, 5]),37);\n  assert.deepEqual(candidate([\"+\", \"*\", \"-\"], [2, 3, 4, 5]),9);\n  assert.deepEqual(candidate([\"\/\/\", \"*\"], [7, 3, 4]),8);\n}\n\ntest();"},{"task_id":"HumanEval_161","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണങ്ങൾ \/\/ഫങ്ഷൻ കിട്ടിയ സ്ട്രിംഗ് തിരിച്ചു കൊടുക്കണം.\/\/സ്ട്രിങ്ങിൽ അക്ഷരങ്ങളൊന്നും ഇല്ലെങ്കിൽ, സ്ട്രിങ് വിപരീതമാക്കുക.\/\/അല്ലെങ്കില് , അത് ഇങ്ങനെയായി തുടരുക.\/\/s[i] ഒരു അക്ഷരമാണെങ്കിൽ, അതിന്റെ കേസ് താഴേ നിന്ന് മുകളിലേക്ക് അല്ലെങ്കിൽ തിരിച്ചും, \/\/നിങ്ങള് ക്ക് ഒരു സ്ട്രിംഗ് ലഭിക്കുന്നു.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunction solve(s: string): string {\n","canonical_solution":"function solve(s: string): string {\n    let hasLetter = \/[a-zA-Z]\/.test(s);\n    if (hasLetter) {\n        return s.split('').map(char => {\n            if (\/[a-z]\/.test(char)) {\n                return char.toUpperCase();\n            } else if (\/[A-Z]\/.test(char)) {\n                return char.toLowerCase();\n            } else {\n                return char;\n            }\n        }).join('');\n    } else {\n        return s.split('').reverse().join('');\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(\"AsDf\"),\"aSdF\");\n  assert.deepEqual(candidate(\"1234\"),\"4321\");\n  assert.deepEqual(candidate(\"ab\"),\"AB\");\n  assert.deepEqual(candidate(\"#a@C\"),\"#A@c\");\n  assert.deepEqual(candidate(\"#AsdfW^45\"),\"#aSDFw^45\");\n  assert.deepEqual(candidate(\"#6@2\"),\"2@6#\");\n  assert.deepEqual(candidate(\"#$a^D\"),\"#$A^d\");\n  assert.deepEqual(candidate(\"#ccc\"),\"#CCC\");\n}\n\ntest();"},{"task_id":"HumanEval_162","nl":"mal_Mlym","pl":"ts","prompt":"\/\/'text' ഒരു ശൂന്യമായ സ്ട്രിംഗ് ആണെങ്കിൽ, undefined എന്ന രീതിയിലായിരിക്കും റിട്ടേൺ ചെയ്യുക.\/\/ഒരു സ്ട്രിംഗ് 'ടെക്സ്റ്റ്' നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിന്റെ md5 ഹാഷ് തുല്യമായ സ്ട്രിംഗ് നൽകുക.\/\/ >>> string_to_md5(\"Hello world\")\n\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunction string_to_md5(text: string): string | undefined {\n","canonical_solution":"import * as crypto from 'crypto';\n\nfunction string_to_md5(text: string): string | undefined {\n    if (text === \"\") {\n        return undefined;\n    }\n    return crypto.createHash('md5').update(text).digest('hex');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_to_md5;\n  assert.deepEqual(candidate(\"Hello world\"),\"3e25960a79dbc69b674cd4ec67a72c62\");\n  assert.deepEqual(candidate(\"\"),undefined);\n  assert.deepEqual(candidate(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\");\n  assert.deepEqual(candidate(\"password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n\ntest();"},{"task_id":"HumanEval_163","nl":"mal_Mlym","pl":"ts","prompt":"\/\/ഉദാഹരണത്തിന്: \/\/b, ക്രമാനുഗതമായി.\/\/രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയിട്ടുണ്ടെങ്കിൽ, a  യും b യും തമ്മിലുള്ള സംഖ്യകളുടെ സംഖ്യകൾ തിരികെ നൽകുക.\/\/ >>> generate_integers(2, 8)\n\/\/ [2, 4, 6, 8]\n\/\/ >>> generate_integers(8, 2)\n\/\/ [2, 4, 6, 8]\n\/\/ >>> generate_integers(10, 14)\n\/\/ []\nfunction generate_integers(a: number, b: number): number[] {\n","canonical_solution":"function generate_integers(a: number, b: number): number[] {\n    let result: number[] = [];\n    \n    \/\/ Get starting and ending points in sorted order\n    let start = Math.min(a, b);\n    let end = Math.max(a, b);\n    \n    \/\/ Loop through the range\n    for (let i = start; i <= end; i++) {\n        if (i % 2 === 0) {  \/\/ Check if the digit is even\n            result.push(i);\n        }\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = generate_integers;\n  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(17, 89),[]);\n}\n\ntest();"}]