[
    {
        "task_id": "HumanEval/0",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"تحقق مما إذا كانت في قائمة الأرقام المحددة، أي رقمين أقرب إلى بعضهما البعض من الحد المحدد. مثال: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) خطأ >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) صحيح \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"إدخال هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلسلات منفصلة وإرجاع قائمة تلك. المجموعات المنفصلة متوازنة (يتم إغلاق كل قوس مفتوح بشكل صحيح) وليس متداخلة داخل بعضها البعض تجاهل أي مساحات في سلسلة الإدخال. مثال: >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ['() ', '(()) ', '((()) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"مع إعطاء رقم ذي نقطة تعويم إيجابية، يمكن تفكيكه إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المحدد) وعشريات (الجزء المتبقي دائما أصغر من 1).\"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"يتم إعطائك قائمة بالعمليات الإيداعية والسحبية في حساب مصرفي تبدأ بـ صفر. مهمتك هي اكتشاف ما إذا كان رصيد الحساب في أي نقطة أقل من صفر، وفي تلك النقطة يجب أن تعيد الدالة True. وإلا يجب أن تعيد False. مثال: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"بالنسبة لقائمة معينة من الأرقام المدخلة، قم بحساب متوسط الانحراف المطلق حول متوسط مجموعة البيانات هذه. متوسط الانحراف المطلق هو متوسط الاختلاف المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة): MAD = متوسط  x - x_mean  مثال: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"أدخل رقم \"محدد\" بين كل عنصرين متتاليين من قائمة المدخلات `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"إدخال هذه الدالة هو سلسلة تمثل مجموعات متعددة للقوسين المتداخلين المفصولين عن طريق المسافات. لكل مجموعة، إخرج أعمق مستوى من التداخل بين القوسين. على سبيل المثال (() (()) لديه مستويين أقصى من التداخل بينما ((())) لديه ثلاثة. >>> parse_nested_parens('((()) ((())) () (((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"تصفية قائمة المدخلات من السلاسل فقط لأولئك الذين يحتويون على سلسلة فرعية معينة >>> filter_by_substring([]، 'a') [] >>> filter_by_substring(['abc'، 'bacd'، 'cde'، 'array']، 'a') ['abc'، 'bacd'، 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"بالنسبة لقائمة معينة من الأعداد الصحيحة، أعد توبل يتكون من مجموع ومضاعفة لجميع الأعداد الصحيحة في القائمة. يجب أن يكون المجموع الفارغ يساوي 0 والمحصول الفارغ يساوي 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"من قائمة معينة من الأعداد الصحيحة، قم بإنشاء قائمة من العناصر القصوى المتداولة التي تم العثور عليها حتى لحظة معينة في التسلسل. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"العثور على أقصر حزمة حزمة تبدأ بحزمة مقدمة. فكرة الخوارزمية بسيطة: - العثور على أطول حزمة حزمة مقدمة هي حزمة حزمة. - إضافة إلى نهاية سلسلة عكس حزمة حزمة مقدمة تأتي قبل الحزمة الحزمية. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"اختبار إذا كانت السلسلة المعطاة بالندروم\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"الإدخال هو سلسلتين a و b تتكونان فقط من 1 و 0. أداء XOR ثنائي على هذه الإدخالات وإرجاع النتيجة أيضا كسلسلة.\"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"من قائمة السلاسل، أعد الأطول. أعد الأول في حالة وجود سلسلة متعددة ذات الطول نفسه. أعد لا شيء في حالة أن القائمة الإدخالية فارغة. >>> أطول (([]) >>> أطول ((['a'، 'b'، 'c']) 'a' >>> أطول ((['a'، 'bb'، 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"يعيد أكبر مقسم مشترك لعددين صحيحين a و b >>> أكبر_مشترك_مقسوم ((3, 5) 1 >>> أكبر_مشترك_مقسوم ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"قائمة جميع البديلات من الأقصر إلى الأطول من سلسلة الإدخال >>> all_prefixes (('abc') ['a'، 'ab'، 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"يعيد سلسلة تحتوي على أرقام محددة مساحة تبدأ من 0 حتى n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"مع إعطاء سلسلة، معرفة عدد الأحرف المختلفة (بغض النظر عن الحالة) هل تتكون من >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"إدخال إلى هذه الوظيفة هو سلسلة تمثل الملاحظات الموسيقية في تنسيق ASCII خاص. مهمتك هي تحليل قائمة السلاسل من الأعداد الصحيحة المقابلة للعديد من الضربات. وهنا أسطورة: 'o' ملاحظة - آخر ضربات 'o' - نص نص ملاحظة - آخر ضربتين 'o' - نص ملاحظة - آخر ضربتين 'o' - نص ملاحظة - آخر ضربة >>> parse_music '. 'o' o .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"العثور على عدد مرات يمكن العثور على سلسلة فرعية معينة في السلسلة الأصلية. عد الحالات المتداخلة. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"الإدخال هو سلسلة محددة مساحة من الأرقام من \"صفر\" إلى \"تسعة\". الخيارات الصالحة هي \"صفر\" و \"واحد\" و \"اثنان\" و \"ثلاثة\" و \"أربعة\" و \"خمسة\" و \"ستة\" و \"سبعة\" و \"ثمانية\" و \"تسعة\". يعيد السلسلة مع الأرقام مرتبة من أصغر إلى أكبر >>> sort_numbers (('ثلاثة واحد خمسة') 'واحد ثلاثة خمسة' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"من قائمة مقدمة من الأرقام (طولها اثنان على الأقل) حدد واسترد اثنين من الأرقام الأقرب إلى بعضها البعض واستردها بالترتيب (الأعداد الأصغر، والأعداد الأكبر). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"في قائمة الأرقام (من عنصرين على الأقل) ، قم بتطبيق تحويل خطي على تلك القائمة، بحيث يصبح أصغر عدد 0 وأكبر عدد 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"تصفية قائمة معطاة من أي قيم بايثون للأعداد الصحيحة فقط >>> filter_integers ((['a'، 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc'، {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"العودة طول سلسلة معينة >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"بالنسبة لعدد معين n، ابحث عن أكبر عدد يقسم n بالتساوي، أصغر من n >>> أكبر_قاسم ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"أعد قائمة العوامل الأولية للعدد الصحيح المحدد بالترتيب من الأصغر إلى الأكبر. يجب سرد كل من العوامل عدد مرات تتوافق مع عدد مرات ظهورها في العامل. يجب أن يكون رقم الإدخال يساوي ناتج جميع العوامل >>> فاكتوريز ((8) [2, 2, 2] >>> فاكتوريز ((25) [5, 5] >>> فاكتوريز ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"من قائمة من الأعداد الصحيحة، قم بإزالة جميع العناصر التي تحدث أكثر من مرة. حافظ على ترتيب العناصر المتبقية كما هو في المدخل. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"بالنسبة لسلاسل معينة، قم بتحويل الأحرف الصغيرة إلى الأحرف الكبيرة والحروف الكبيرة إلى الأحرف الصغيرة. >>> flip_case ((('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"تسلسل قائمة من السلاسل إلى سلاسل واحدة >>> تسلسل (([]) '' >>> تسلسل ((['a'', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"تصفية قائمة المدخلات من السلاسل فقط لأولئك الذين يبدأون بواجهة معينة. >>> filter_by_prefix([]، 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"يعيد الأرقام الإيجابية فقط في القائمة. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"يعيد صحيح إذا كان عدد معين عبارة عن عدد أولي، وخاطئ خلاف ذلك. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs هي معامل للعدد المتعدد. find_zero find x مثل poly(x) = 0. find_zero يعيد فقط نقطة الصفر فقط، حتى لو كانت هناك العديد منها. علاوة على ذلك، find_zero لا يأخذ سوى قائمة xs التي تحتوي على عدد من المعاملات وأكبر معامل غير صفري لأنها تضمن حلاً. >>> round(find_zero[(1, 2] ، 2) # f(x) = 1 + 2x -0.5 >>> round(find_zero([-6, 11, -6, 1] ، 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"يقيم متعدد الحدود مع معامل xs في النقطة x. العودة xs[0] + xs[1] * x + xs[1] * x ^ 2 + .... xs[n] * x ^ n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"تأخذ هذه الدالة قائمة l وتعيد قائمة l' بحيث تكون l' متطابقة مع l في المؤشرات التي لا تقسم على ثلاثة، في حين أن قيمها في المؤشرات التي تقسم على ثلاثة تساوي قيم المؤشرات المقابلة لـ l، ولكن مرتبة. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"يعيد العناصر الفريدة المصنفة في قائمة >>> فريدة من نوعها (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"يعيد العنصر الأقصى في القائمة. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"يعيد عدد مرات ظهور الرقم 7 في الأعداد الصحيحة الأقل من n القابلة للقسمة على 11 أو 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"تأخذ هذه الدالة قائمة l وتعيد قائمة l' بحيث تكون l' متطابقة مع l في المؤشرات الفردية ، بينما تكون قيمها في المؤشرات الزوجية مساوية لقيم المؤشرات الزوجية ل l ، ولكن مرتبة. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"يأخذ كسلسلة إدخال مشفرة مع وظيفة encode_cyclic. يعيد السلسلة المفككة.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"يعيد السلسلة المشفرة بواسطة مجموعات دورية من ثلاث أحرف.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib يعيد رقم n-th وهو رقم فيبوناتشي وهو أيضاً عدد أولي. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"يستقبل triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخل. يعيد صحيح إذا كان هناك ثلاثة عناصر متميزة في القائمة التي تصل إلى الصفر، و False خلاف ذلك. >>> triples_sum_to_zero (([1, 3, 5, 0]) False >>> triples_sum_to_zero (([1, 3, -2, 1]) True >>> triples_sum_to_zero (([1, 2, 3, 7]) False >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero [1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"تخيل طريقًا مستقيمًا تمامًا، خطًا طويلًا إلى ما لا نهاية. n سيارات تقود من اليسار إلى اليمين؛ في الوقت نفسه، مجموعة مختلفة من n سيارات تقود من اليمين إلى اليسار. تبدأ مجموعتان من السيارات بعيدًا جدًا عن بعضهما البعض. كل السيارات تتحرك بنفس السرعة. يقال إن سيارتين تتصادمان عندما تصطدم سيارة تتحرك من اليسار إلى اليمين بسيارة تتحرك من اليمين إلى اليسار. ومع ذلك، فإن السيارات قوية إلى ما لا نهاية؛ ونتيجة لذلك، تستمر في التحرك في مسارها كما لو لم تتصادم. هذه الدالة تخرج عدد مثل هذه الاصطدامات.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"قائمة العودة مع عناصر زادت بنسبة 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero يأخذ قائمة من الأعداد الصحيحة كمدخل. يعيد صحيح إذا كان هناك عنصرين متميزين في القائمة يجمع إلى الصفر، و False خلاف ذلك. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"تغيير القاعدة العددية لعدد الإدخال x إلى قاعدة. العودة تمثيل السلسلة بعد التحويل. أرقام القاعدة أقل من 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"معطى طول الجانب و مساحة العودة العالية للمثلث. >>> مثلث_مساحة\"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"تسلسل الأرقام فيبوناشي هو تسلسل مشابه لسلسلة فيبوناشي والذي يتم تعريفه على النحو التالي: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). يرجى كتابة دالة لحساب العنصر n من تسلسل الأرقام فيبوناشي بكفاءة. لا تستخدم الانتكاس. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"متوسط العودة للعناصر في القائمة l. >>> متوسط (([3, 1, 2, 4, 5]) 3 >>> متوسط (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"يتحقق من أن السلسلة المحددة هي باليندروم >>> is_palindrome (('') صحيح >>> is_palindrome (('aba') صحيح >>> is_palindrome (('aaaaa') صحيح >>> is_palindrome (('zbcd') خاطئ \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"أعد 2^n modulo p (كن على دراية بالأرقام). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"يأخذ كسلسلة إدخال مشفرة مع وظيفة encode_shift. يعيد السلسلة المفككة. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"يعيد السلسلة المشفرة عن طريق تحريك كل حرف بـ 5 في الأبجدية.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels هي وظيفة تأخذ السلسلة وتعيد السلسلة بدون حروف العلة. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"يعيد صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t. >>> below_threshold (([1, 2, 4, 10], 100) صحيح >>> below_threshold (([1, 20, 4, 10], 5) خاطئ \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"اضف رقمين x و y >>> اضف ((2, 3) 5 >>> اضف ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"تحقق مما إذا كان لدى كلمتين نفس الحروف. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') صحيح >>> same_chars (('abcd', 'dddddddddabc') صحيح >>> same_chars (('dddddddabc', 'abcd') صحيح >>> same_chars (('eabcd', 'dddddddddabc') خاطئ >>> same_chars ((('abcd', 'dddddddabddce') خاطئ >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') خاطئ \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"يعيد رقم فيبوناتشي n. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"الأقواس هي سلسلة من \"<\" و \">\". return صحيح إذا كان لكل أقواس فتح أقواس مغلقة متوافقة. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") True >>> correct_bracketing(\"<><>\") True >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"العودة صحيح هو عناصر القائمة تتزايد أو تنخفض بشكل متناغم. >>> متناغم (([1, 2, 4, 20]) صحيح >>> متناغم (([1, 20, 4, 10]) كاذب >>> متناغم (([4, 1, 0, -10]) صحيح \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"يعيد العناصر المشتركة الفريدة المصنفة لقائمتين. >>> مشتركة (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> مشتركة (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"أعد أكبر عامل أولي لـ n. افترض أن n > 1 وليس أولي. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n هي وظيفة تقوم بجمع الأرقام من 1 إلى n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"الأقواس هي سلسلة من \"(\" و \")\". return صحيح إذا كان لكل أقواس فتح أقواس مغلقة. >>> correct_bracketing(\"(\") False >>> correct_bracketing(\"() True >>> correct_bracketing(\"() True >>> correct_bracketing(\") True >>> correct_bracketing(\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs تمثل معامل متعدد الحدود. xs[0] + xs[1] * x + xs[2] * x^2 + .... أعيد مشتقة هذا متعدد الحدود بنفس الشكل. >>> مشتقة (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> مشتقة (([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"تسلسل الأرقام فيب فايب هو تسلسل مشابه لسلسلة فيبوناتشي والذي يتم تعريفه على النحو التالي: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). يرجى كتابة دالة لحساب العنصر nth من تسلسل الأرقام فيب فايب بكفاءة. >>> fibfib(1) 0 >>> fib fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"اكتب دالة vowels_count التي تأخذ سلسلة تمثل كلمة كمدخل وتعيد عدد الحروف العالية في السلسلة. الحروف العالية في هذه الحالة هي 'a' و 'e' و 'i' و 'o' و 'u'. هنا، 'y' هو أيضا حروف العالية، ولكن فقط عندما يكون في نهاية الكلمة المعطاة. مثال: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"أضف المزيد من حالات الاختبار\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"حلقة حلقة حركة أرقام العدد الصحيح x، حركة الأرقام يمينًا بحركة حركة وإرجاع النتيجة كسلسلة. إذا حركة حركة > عدد الأرقام، إرجاع الأرقام معاكسة. >>> حلقة حلقة_حركة_12، 1) \"21\" >>> حلقة_حركة_12، 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"مهمة كتابة دالة تأخذ سلسلة كمدخل وتعيد مجموع الأحرف العليا فقط' رموز ASCII. أمثلة: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"في هذه المهمة، سيتم إعطائك سلسلة تمثل عدد التفاح والبرتقال الموزعة في سلة من الفواكه تحتوي هذه السلة على التفاح والبرتقال وفواكه المانجو. بالنظر إلى السلسلة التي تمثل العدد الإجمالي من البرتقال والتفاح وأعداد صحيحة تمثل العدد الإجمالي من الفواكه في السلة، أعد عدد فواكه المانجو في السلة. على سبيل المثال: fruit_distribution\"5(التفاح و6 برتقال\"، 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0التفاح و1 برتقال\"،3) -> 3 - 0 - 1 = 2 fruit_distribution\"2التفاح و3 برتقال\"، 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 التفاح و120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"منحًا صفيفًا يمثل فرعًا من شجرة تحتوي على عقد غير سالبة ، فإن مهمتك هي انتزاع أحد العقد وإعادتها. يجب أن تكون العقدة المنتزعة هي العقدة ذات القيمة الزوجية الأصغر. إذا تم العثور على عقدات متعددة ذات القيمة الزوجية الأصغر ، أعيد العقدة التي لديها أصغر مؤشر. يجب إرجاع العقدة المنتزعة في قائمة ، [smallest_value ، مؤشرها ] ، إذا لم تكن هناك قيم زوجية أو كان الصفيف المحدد فارغًا ، أعيد []. مثال 1: المدخل: [4,2,3] المخرج: [2, 1] التفسير: 2 لديه أصغر قيمة زوجية ، و 2 لديه أصغر مؤشر. مثال 2: المدخل: [1,2,3] المخرج: [2, 1] التفسير: 2 لديه أصغر قيمة زوجية ، و 2 لديه أصغر مؤشر. مثال 3: المدخل: [] المخرج: [] المدخل: [4: 5، 3، 4، 2، 0، 1] المخرج: 1، المخرج: 1، إذا كان أصغر قيمة العقدمة ، فسنخترتب أول عقدمين: الصفر ، ولكن هناك صفر.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''يتم إعطائك قائمة غير فارغة من الأعداد الصحيحة الإيجابية. أعد أكبر عدد صحيح أكبر من الصفر، وله تردد أكبر من أو يساوي قيمة العدد الصحيح نفسه. تردد العدد الصحيح هو عدد المرات التي يظهر فيها في القائمة. إذا لم تكن هناك قيمة من هذا القبيل، أعد -1.'''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''إذا أعطيت قائمة بالأعداد الصحيحة، ستعيد القائمة بترتيب غريب. الترتيب الغريب هو عندما تبدأ بالقيمة الدنيا، ثم الحد الأقصى للأعداد الصحيحة المتبقية، ثم الحد الأدنى وهكذا. أمثلة: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''مع إعطاء أطوال الجوانب الثلاثة للمثلث. إرجاع مساحة المثلث مقربة إلى نقطتين عشريتين إذا كانت الجوانب الثلاثة تشكل مثلثًا صحيحًا. خلاف ذلك إرجاع -1 ثلاثة أطراف تشكل مثلثًا صحيحًا عندما يكون مجموع أي جانبين أكبر من الجانب الثالث. مثال: مثلث_مساحة{3،4،5} == 6.00 مثلث_مساحة{1،2،10} == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''اكتب دالة تعيد صحيح إذا كان الكائن q سوف يطير، وكذب خلاف ذلك. الكائن q سوف يطير إذا كان متوازنا (إنها قائمة باليندرومية) ومجموع عناصرها أقل من أو يساوي الحد الأقصى للوزن الممكن w. مثال: will_it_fly (([1, 2]، 5) â -> False # 1+2 أقل من الحد الأقصى للوزن الممكن، ولكنه غير متوازن. will_it_fly (([3, 2, 3]، 1) â -> False # متوازن، ولكن 3+2+3 أكثر من الحد الأقصى للوزن الممكن. will_it_fly (([3, 2, 3]، 9) â -> True # 3+23 أقل من الحد الأقصى للوزن الممكن، وهو متوازن. will_it_fly ((([3], â 5) -> True # 3 أقل من الحد الأقصى للوزن الممكن، وهو متوازن '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"مع إعطاء صف صفوف من الأعداد الصحيحة، ابحث عن الحد الأدنى من العناصر التي تحتاج إلى تغيير لجعل المصفوفة باليندرومية. المصفوفة باليندرومية هي صفوف يتم قراءتها بنفس الطريقة للخلف والى الأمام. في تغيير واحد، يمكنك تغيير عنصر واحد إلى أي عنصر آخر. على سبيل المثال: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''اكتب دالة تقبل قائمتين من السلاسل وتعيد القائمة التي يقل عدد الحروف فيها عن القائمة الأخرى. إذا كان لدى القائمتين نفس عدد الحروف، أعد القائمة الأولى. أمثلة total_match (([]، []) â -> [] total_match ((['hi'', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi'], 'hi'_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"اكتب دالة تعود بالصواب إذا كان العدد المحدد هو ضرب 3 أرقام أولية و كاذبة خلاف ذلك. مع العلم أن (أ) أقل من 100.\"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"مهمتك هي كتابة دالة تعود صحيحاً إذا كان العدد x قوة بسيطة من n و كاذبة في الحالات الأخرى. x قوة بسيطة من n إذا كان n**int=x على سبيل المثال: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''اكتب دالة تأخذ عددًا صحيحًا a وتعود True إذا كان هذا ingeger مكعبًا لعدد صحيح. ملاحظة: يمكنك افتراض أن المدخل صالح دائمًا. أمثلة: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"لقد تم تكليفك بكتابة دالة تستقبل رقم عشري عشري كسلسلة وتعد عدد الأرقام عشري عشري التي هي أرقام أولية (عدد أولي أو أولي هو عدد طبيعي أكبر من 1 وليس ناتجًا عن عددين أصغر طبيعيين). الأرقام عشري عشري هي 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، أ، ب، ج، د، إي، ف. الأرقام الأولية هي 2، 3، 5، 7، 11، 13، 17، ... لذلك عليك تحديد عدد من الأرقام التالية: 2، 3، 5، 7، 7، ب (= عشري 11) ، د (= عشري 13). ملاحظة: قد تفترض أن المدخل صحيح دائمًا أو فارغ، والرموز A،B،C،D،E،F هي دائمًا بحروف كبيرة. أمثلة: بالنسبة لـ num \"AB\" يجب أن يكون الناتج num = 1. بالنسبة لـ \"10E\" يجب أن يكون الناتج 2. بالنسبة لـ num \"AB\" يجب أن يكون num = 1، و\" يجب أن يكون num = 4. \"ABC\" يجب أن يكون num = 6.067 و\" يجب أن يكون الناتج num = 2.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"سوف تعطى لك رقم في شكل عشري ومهمتك هي تحويله إلى شكل ثنائي. يجب أن تعيد الدالة سلسلة، مع كل حرف يمثل رقم ثنائي. كل حرف في السلسلة سيكون '0' أو '1'. سيكون هناك زوجين إضافيين من الأحرف 'db' في بداية ونهاية السلسلة. الأحرف الإضافية موجودة للمساعدة في التنسيق. أمثلة: decimal_to_binary ((15) # يعيد \"db1111db\" decimal_to_binary32) # يعيد \"db100000db\"\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"يتم إعطائك سلسلة s. مهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا. السلسلة سعيدة إذا كان طولها 3 على الأقل وكل 3 أحرف متتالية متميزة على سبيل المثال: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy)) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"في الأسبوع الأخير من الفصل الدراسي، يجب على المعلم إعطاء الدرجات للطلاب. لقد كان المعلم يصنع خوارزمية خاصة به للتصنيف. المشكلة الوحيدة هي أنها فقدت الشفرة التي استخدمتها للتصنيف. لقد أعطتك قائمة بمعدلات التأهيل لبعض الطلاب، وعليك كتابة دالة يمكنها إعطاء قائمة بمعدلات التأهيل باستخدام الجدول التالي:\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"اكتب دالة تأخذ سلسلة وتعود صحيحاً إذا كان طول السلسلة عدداً أولياً أو خاطئاً خلاف ذلك. أمثلة prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"مع إعطاء عدد صحيح إيجابي n، أعد عدداً من أرقام الأعداد الصحيحة الإيجابية من n خانة تبدأ أو تنتهي بـ 1.\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"مع إعطاء عدد صحيح إيجابي N، أعد مجموع أرقامه في النموذج الثنائي. مثال N = 1000، سيكون مجموع الأرقام 1 يجب أن يكون الناتج \"1\". لN = 150، سيكون مجموع الأرقام 6 يجب أن يكون الناتج \"110\". لN = 147، سيكون مجموع الأرقام 12 يجب أن يكون الناتج \"1100\". متغيرات: @N عدد صحيح قيود: 0 â‰¤ N â‰¤ 10000. الناتج: سلسلة من الأرقام الثنائية \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"مع إعطاء قائمة غير فارغة من الأعداد الصحيحة lst. أضف العناصر الزوجية التي هي في مؤشرات فريدة.. أمثلة: إضافة (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"اكتب دالة تأخذ سلسلة من الأحرف وتعيد نسخة مرتبة منها. النسخة المنظمة من السلسلة، هي سلسلة يتم فيها استبدال جميع الكلمات (مفصولة عن طريق الفراغ) بكلمة جديدة حيث يتم ترتيب جميع الأحرف بترتيب تصاعدي بناءً على قيمة ascii. ملاحظة: يجب الاحتفاظ بترتيب الكلمات والفراغات الفارغة في الجملة. على سبيل المثال: anti_shuffle ((('Hi') يعيد 'Hi' anti_shuffle ((('hello') يعيد 'ehllo' anti_shuffle (('Hello World!!!') يعيد 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"يتم إعطائك بيانات ثنائية الأبعاد ، كقوائم متداخلة ، مماثلة للمصفوفة ، ومع ذلك ، على عكس المصفوفات ، يمكن أن يحتوي كل صف على عدد مختلف من الأعمدة. مع إعطاء lst ، والعدد الصحيح x ، ابحث عن الأعداد الصحيحة x في القائمة ، وإرجاع قائمة من المجموعات ، [(x1 ، y1 ، (x2 ، y2) ...) بحيث يكون كل توبل هو إحداثي - (صف ، أعمدة) ، بدءًا من 0. قم بترتيب الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي. أيضًا ، رتب إحداثيات الصف حسب الأعمدة بترتيب هبوطي. الأمثلة: get_row [1,2,3,4,5,6 ] ، [1,2,3,4,1,6 ] ، [1,2,3,4,5,1] ، 1) == [0,0, 0, 0 ] ، (1, 4), 0 ، (2, 5), (2, 0) get_((1 ] ، [] ==_[[صف ، 1 ، 2 ، 3]] ، [2, 2]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"مع إعطاء صف من الأعداد الصحيحة غير السالبة، أعد نسخة من المصفوفة المحددة بعد الترتيب، ستقوم بترتيب المصفوفة المحددة بالترتيب الصاعد إذا كانت المجموعة ((قيمة المؤشر الأولى، قيمة المؤشر الأخيرة) فريدة، أو ترتيبها بالترتيب الهبوطي إذا كانت المجموعة ((قيمة المؤشر الأولى، قيمة المؤشر الأخيرة) زوجية. ملاحظة: * لا تغير المصفوفة المحددة. أمثلة: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"إنشاء وظيفة تشفير التي تأخذ سلسلة كحجة ويعود سلسلة مشفرة مع الأبجدية يجري تدوير. يجب تدوير الأبجدية بطريقة بحيث تتحول الحروف إلى أسفل اثنين مضروبة إلى مكانين. على سبيل المثال: تشفير (('hi') يعود 'lm' تشفير (('asdfghjkl') يعود 'ewhjklnop' تشفير (('gf') يعود 'kj' تشفير (('et') يعود 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"تم إعطائك قائمة من الأعداد الصحيحة. اكتب دالة next_smallest (() التي تعيد ثاني أصغر عنصر في القائمة. تعيد لا شيء إذا لم يكن هناك عنصر من هذا القبيل. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == لا شيء next_smallest (([1, 1]) == لا شيء \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"ستعطى لك سلسلة من الكلمات، ومهمتك هي أن تحسب عدد الملل. الملل هو جملة تبدأ بالكلمة \"أنا\". يتم تقسيم الجمل بواسطة \"\"، \"؟ \" أو \"! \" . على سبيل المثال: >>> is_bored ((\"مرحباً يا عالم\") 0 >>> is_bored ((\"السماء زرقاء. الشمس مشرقة. أحب هذا الطقس\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''قم بإنشاء دالة تأخذ 3 أرقام. تعيد صحيحاً إذا كان أحد الأرقام يساوي مجموع الأرقام الأخرى، وجميع الأرقام صحيحة. تعيد خطأ في أي حالات أخرى. أمثلة أي_مجموعة{5, 2, 7}:> صحيح أي_مجموعة{3, 2, 2}:> خطأ أي_مجموعة{3, -2, 1}:> صحيح أي_مجموعة{3, -2, 1}:> خطأ '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"اكتب دالة تأخذ رسالة، وتقوم بتشفيرها بطريقة تغير الحروف الكبيرة، وتستبدل جميع الحروف العلوية في الرسالة بالحرف الذي يظهر 2 أماكن أمام تلك الحروف العلوية في الأبجدية الإنجليزية. افترض الحروف فقط. أمثلة: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"تم إعطائك قائمة بالأعداد الصحيحة. تحتاج إلى العثور على أكبر قيمة رئيسية وإرجاع مجموع أرقامها. أمثلة: لـ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] يجب أن يكون الإخراج 10 لـ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] يجب أن يكون الإخراج 25 لـ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] يجب أن يكون الإخراج 13 لـ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] يجب أن يكون الإخراج 11 لـ lst = [0,81,12,31,21] يجب أن يكون الإخراج 3 لـ lst = [0,1,8,1,2,1,7] يجب أن يكون الإخراج 7 لـ lst = [0,1,8,1,2,1,7] يجب أن يكون الإخراج 7 لـ lst = [0,1,2,2,1] يجب أن يكون الإخراج 7 لـ lst = [0,1,1,2,2,7] يجب أن يكون الإخراج 7 لـ lst = lst = [0,1,1,1,1,1,1,2,7] يجب أن يكون الإخراج 7 لـ lst = 0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"مع إعطاء قاموس، أعيد صحيح إذا كانت جميع المفاتيح سلسلة من الحروف الصغيرة أو جميع المفاتيح سلسلة من الحروف الكبيرة، وإلا أعيد خطأ. يجب أن تعيد الدالة خطأ إذا كان القاموس المحدد فارغًا. أمثلة: check_dict_case{\"a\":\"apple\"، \"b\":\"banana\"}) يجب أن تعيد صحيح. check_dict_case{\"a\":\"apple\"، \"A\":\"banana\"، \"B\":\"banana\"}) يجب أن تعيد خطأ. check_dict_case{\"a\":\"apple\"، 8:\"banana\"، \"a\":\"apple\"}) يجب أن تعيد خطأ. check_dict_case{\"Name\":\"John\", \"Age\":\"36\"، \"City\":\"Houston\"}) يجب أن تعيد خطأ. check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"12345\"}) يجب أن تعيد صحيح.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"تنفيذ دالة تأخذ عدداً صحيحاً غير سلبي وتعيد صفيفاً من أول n أعداد صحيحة هي أرقام أولية وأقل من n. على سبيل المثال: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"أكمل الدالة التي تأخذ عددين صحيحين وتعيد ناتج أرقام وحدتهم. افترض أن المدخل صالح دائمًا. أمثلة: ضرب ((148، 412) يجب أن يعود 16. ضرب ((19، 28) يجب أن يعود 72. ضرب ((2020، 1851) يجب أن يعود 0. ضرب ((14، 15) يجب أن يعود 20. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"مع إعطاء سلسلة s، عد عدد الحروف العلوية الكبيرة في المؤشرات الزوجية. على سبيل المثال: count_upper (('aBCdEf') يعيد count_upper 1 (('abcdefg') يعيد count_upper 0 (('dBBE') يعيد 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''إنشاء دالة تأخذ قيمة (سلسلة) تمثل عدداً وتعيد أقرب عدد صحيح له. إذا كان العدد متساوياً بين عددين صحيحين، قم بتدويره بعيداً عن الصفر. أمثلة >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 ملاحظة: التدوير بعيداً عن الصفر يعني أنه إذا كان العدد المعطى متساوياً بين عددين صحيحين، فإن العدد الذي يجب إرجاعه هو الأقصى عن الصفر.'''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"مع وجود عدد صحيح إيجابي n، عليك أن تصنع كومة من n مستويات من الحجارة. المستوى الأول يحتوي على n حجر. عدد الحجارة في المستوى التالي هو: - العدد الفري بعد إذا كان n فريًا. - العدد الزوج التالي إذا كان n زوجيًا. أعد عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i+1). الأمثلة: >>> make_a_pile ((3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"سوف تعطى لك سلسلة من الكلمات مفصولة بالفواصل أو الفراغات. مهمتك هي تقسيم السلسلة إلى كلمات وإعادة مجموعة من الكلمات. على سبيل المثال: words_string ((\"مرحبا، اسمي هو جون\") == [\"مرحبا\"، \"ي\"، \"الاسم\"، \"هو\"، \"جون\"] words_string ((\"واحد، اثنان، ثلاثة، أربعة، خمسة، ستة\") == [\"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"هذه الدالة تأخذ عددان إيجابيين x و y وتعيد أكبر عدد صحيح زوج في النطاق [x, y] شمولاً. إذا لم يكن هناك مثل هذا العدد، فيجب أن تعيد الدالة -1. على سبيل المثال: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"تم إعطائك عددين صحيحين إيجابيين n و m، ومهمتك هي حساب متوسط الأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الجواب إلى أقرب عدد صحيح وتحويله إلى ثنائي. إذا كان n أكبر من m، أعد -1.\"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"مع إعطاء قائمة من الأعداد الصحيحة الإيجابية x. إرجاع قائمة مرتبة من جميع العناصر التي لا تحتوي على أي رقم زوج. ملاحظة: يجب فرز القائمة المرجعة بترتيب متزايد. على سبيل المثال: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"مع إعطاء صف من الأعداد الصحيحة، قم بتصنيف الأعداد الصحيحة التي تتراوح بين 1 و 9، وعكس المصفوفة الناتجة، ثم استبدل كل رقم باسمه المقابل من \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\"، \"تسعة\". على سبيل المثال: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ترتيب arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> ترتيب arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"ثمانية\"، \"أربعة\"، \"ثلاثة\"، \"اثنان\"، \"اثنان\"، \"اثنان\"، \"واحد\"، \"واحد\"] إذا كانت المصفوفة فارغة، إرجاع صف: arr = [] return [] إذا كان المصفوفة تحتوي على أي رقم غريب تجاهله: arr = [1, -1، 55] -> arr -> [1, 1، 55] -> arr = [5، 5] - return ['One' 1] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"قم بتنفيذ الدالة f التي تأخذ n كمعلم، وتعيد قائمة بحجم n، بحيث تكون قيمة العنصر في المؤشر i هي عامل i إذا كان i زوجياً أو مجموع الأرقام من 1 إلى i خلاف ذلك. i تبدأ من 1. عامل i هو ضرب الأرقام من 1 إلى i (1 * 2 * ... * i).\"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"مع إعطاء عدد صحيح إيجابي n، أعد توبلًا يحتوي على عدد من الحلاليين الرقميين المتعددين والغريبين الذين يقعون في النطاق ((1، n) ، بما في ذلك. مثال1: المدخل: 3 المخرج: (1, 2) التفسير: الحلاليين الرقميين هم 1، 2، 3. أحدهما زوج، واثنان منهم غريبين. مثال2: المدخل: 12 المخرج: (4, 6) التفسير: الحلاليين الرقميين هم 1، 2، 3، 4، 5، 6، 7، 8، 9، 11. أربعة منهم زوج، و 6 منهم غريب. ملاحظة: 1 <= n <= 10^3 2. العودة توبل عدد الحلاليين الرقميين المتعددين والغريبين على التوالي. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"اكتب دالة count_nums التي تأخذ صف من الأعداد الصحيحة وتعيد عدد العناصر التي لديها مجموع من الأرقام > 0. إذا كان العدد سلبيًا ، فسيكون أول رقم موقّع له سلبيًا: على سبيل المثال -123 لديه أرقام موقّعة -1 و 2 و 3. >>> count_nums (([]) == 0 >>> count_nums (([-1 ، 11 ، -11]) == 1 >>> count_nums ([(1 ، 1 ، 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"لدينا صف 'arr' من N عدد صحيح arr[1], arr[2], ..., arr[N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على صف مرتبة في ترتيب غير متناقص عن طريق إجراء العملية التالية على المصفوفة المعطاة: يسمح لك بإجراء عملية التحول يميناً أي عدد من المرات. عملية التحول يميناً واحدة تعني تحريك جميع عناصر المصفوفة بموقع واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير من المصفوفة إلى الموضع الأولي في المصفوفة أي المؤشر 0. إذا كان من الممكن الحصول على المصفوفة المصنفة من خلال إجراء العملية أعلاه ثم العودة صحيحة وإلا العودة كاذبة. إذا كان المصفوفة المعطاة فارغة ثم العودة صحيحة. ملاحظة: يضمن أن يكون لدى القائمة المعطاة عناصر فريدة. على سبيل المثال: move_one_(ball_[3, 4, 5, 2]=== True Explan: من خلال إجراء عمليات rightmin 2، يمكن تحقيق ترتيب غير متناقص للمصفوفة للمصفوفة.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن إجراء تبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 متساوية، أعد \"نعم\". وإلا، أعد \"لا\". على سبيل المثال: تبادل [(1, 2, 3, 4]، [1, 2, 3, 4]) => \"نعم\" تبادل [(1, 2, 3, 4]، [1, 5, 3, 4]) => \"لا\" من المفترض أن تكون القوائم المدخلة غير فارغة. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"إذا أعطيت سلسلة تمثل حروف صغيرة منفصلة عن الفراغات، أعد قاموسًا للحرف الذي يتكرر أكثر ويحتوي على العدد المقابل. إذا كان هناك عدة حروف ذات الحدوث نفسه، أعد جميعها. مثال: هستوغرام ((('a b c') == {'a': 1، 'b': 1، 'c': 1} هستوغرام ((('a b b a') == {'a': 2، 'b': 2} هستوغرام ((('a b c a b') == {'a': 2، 'b': 2} هستوغرام ((('b b a b') == {'b 4}: هستوغرام (((')) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"مهمة تم إعطائنا سلسلتين s و c، عليك حذف جميع الأحرف في s التي تساوي أي حرف في c ثم تحقق إذا كانت سلسلة النتيجة هي باليندروم. تسمى السلسلة باليندروم إذا كانت تقرأ نفس الطريقة للخلف والى الأمام. يجب عليك إرجاع توبل تحتوي على سلسلة النتيجة والصحيح/الخاطئ للتحقق. مثال لـ s = \"abcde\"، c = \"ae\"، يجب أن تكون النتيجة ('bcd'، False) لـ s = \"abcdef\"، c = \"b\" يجب أن تكون النتيجة ('acdef'، False) لـ s = \"abcdedcba\"، c = \"abc\", يجب أن تكون النتيجة ('cdedc'، True)\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"مع إعطاء قائمة من السلاسل، حيث يتكون كل سلسلة من الأرقام فقط، أعيد قائمة. يجب أن يكون كل عنصر i من الناتج \"عدد العناصر الفردية في سلسلة i من المدخل\". حيث يجب استبدال جميع is بعدد الأرقام الفردية في السلسلة i من المدخل. >>> odd_count['1234567']) [\"عدد العناصر الفردية 4n the str4ng 4 of the 4nput.\"] >>> odd_count['3'،\"111111\"]) [\"عدد العناصر الفردية 1n the str1ng 1 of the 1nput.\"، \"عدد العناصر الفردية 8n the str8ng 8 of the 8nput.\"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"مع إعطاء صف من الأعداد الصحيحة n، ابحث عن الحد الأدنى من مجموع أي صف فرعي غير فارغ من الأعداد. مثال minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"يتم إعطائك شبكة مستطيلة من الآبار. يمثل كل صف بئر واحد، ويمثل كل 1 في صف وحدة واحدة من الماء. كل بئر لديه دلو مماثل يمكن استخراج الماء منه، وكل الدلوين لها نفس القدرة. مهمتك هي استخدام الدلوين لتفريغ الآبار. إخراج عدد المرات التي تحتاج إلى خفض الدلوين. مثال 1: المدخل: الشبكة: [[0,0,1,0]، [0,1,0,0]، [1,1,1,1]] سعة الدلو: 1 الناتج: 6 مثال 2: المدخل: الشبكة: [[0,0,1,1]، [0,0,0,0]، [1,1,1]، [0,1,1]] سعة الدلو: 2 الناتج: 5 مثال 3: المدخل: [[:0,0,0]، [0,0,0]] سعة الدلو: 5 سعة الدلو: 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"في هذه الكاتا، عليك فرز صفيف من الأعداد الصحيحة غير السالبة حسب عدد الأعداد في التمثيل الثنائي لها بالترتيب الصاعد. بالنسبة لعدد مماثل من الأعداد، فرز على أساس القيمة العشرية. يجب تنفيذها على النحو التالي: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"مع إعطاء سلسلة s ورقم طبيعي n، تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من سلسلة s التي تحتوي على ن مصافات بالضبط، لكي تظهر هذه الكلمات في سلسلة s. إذا كانت السلسلة s فارغة، فيجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: قد تفترض أن سلسلة الإدخال تحتوي فقط على أحرف وفراغات. أمثلة: select_words (((\"Mary had a little lamb\", 4) ==> [\"little\"] select_words (((\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words\" (((simple white space\", 2) ==> [] select_words (((\"Hello world\", 4) ==> [\"world\"] select_words (((\"Uncle sam\", 3) ==> [\"Uncle\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"يتم إعطائك كلمة. مهمتك هي العثور على أقرب حرف صوتي يقف بين اثنين من الحروف الساكنة من الجانب الأيمن من الكلمة (حساس للقاعدة). لا يتم احتساب الحروف الصوتية في البداية والنهاية. أعد السلسلة الفارغة إذا لم تجد أي حرف صوتي يلبي الشرط أعلاه. يمكنك افتراض أن السلسلة المحددة تحتوي على حرف إنجليزي فقط. مثال: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''يتم إعطائك قائمة من سلسلتين، كلتا السلسلتين تتكون من قوسين مفتوحين '(' أو قوسين مغلقين ') ' فقط. مهمتك هي التحقق من إمكانية ربط السلسلتين في بعض الترتيبات، بحيث يكون السلسلة الناتجة جيدة. يعتبر السلسلة S جيدة إذا كانت جميع القوسين في S متوازنة. على سبيل المثال: السلسلة '((()) ' جيدة، بينما السلسلة '()) ' ليست كذلك. إرجاع 'نعم' إذا كان هناك طريقة لصنع سلسلة جيدة، وإرجاع 'لا' خلاف ذلك. الأمثلة: match_parens[('() ', ') ']) == 'نعم' match_parens[(') ', ') ']) == 'لا' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"مع إعطاء صف صفوف من الأعداد الصحيحة والعدد الصحيح الإيجابي k، أعد قائمة مرتبة بطول k مع أقصى عدد k في صفوف. مثال1: المدخل: arr = [-3, -4, 5]، k = 3 المخرج: [-4, -3, 5] مثال2: المدخل: arr = [4, -4, 4]، k = 2 المخرج: [4, 4] مثال3: المدخل: arr = [-3, 2, 1, 2, -1, -2, 1]، k = 1 المخرج: [2] ملاحظة: 1. طول المصفوفة سيكون في نطاق [1, 1000]. 2. العناصر في المصفوفة ستكون في نطاق [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"مع إعطاء قائمة غير فارغة من الأعداد الصحيحة، أعد مجموع جميع العناصر الفردية التي هي في مواقع زوجية.\"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"مع إعطاء صف غير فارغ من الأعداد الصحيحة arr والعدد الصحيح k، أعد مجموع العناصر التي تحتوي على رقمين على الأكثر من العناصر الأولى k من arr. مثال: المدخلات: arr = [111,21,3,4000,5,6,7,8,9], k = 4 الناتج: 24 # مجموع 21 + 3 القيود: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"إذا أعطيت عدداً صحيحاً إيجابياً n، أعد قائمة مرتبة تحتوي على الأرقام الغير عادلة في تسلسل كولاتز. تخمين كولاتز هو تخمين في الرياضيات يتعلق بتسلسل محدد على النحو التالي: ابدأ بأي عدد صحيح إيجابي n. ثم يتم الحصول على كل مصطلح من المصطلح السابق على النحو التالي: إذا كانت المصطلحة السابقة زوجية، فإن المصطلح التالي هو نصف المصطلح السابق. إذا كانت المصطلحة السابقة فريدة، فإن المصطلح التالي هو 3 أضعاف المصطلح السابق زائد 1. التخمين هو أنه بغض النظر عن قيمة n، فإن التسلسل سيصل دائمًا إلى 1. ملاحظة: 1. Collatz (((1) هو [1] 2. القائمة المرجعة مرتبة بترتيب متزايد. على سبيل المثال: get_odd_collatz ((5) يعود [1, 5] # تسلسل كولاتز لـ 5 هو [5, 8, 16, 4, 2, 1] ، لذلك الأرقام الغير عادلة هي فقط 1 و 5.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"يجب عليك كتابة دالة تقوم بتصديق سلسلة تاريخ معينة وتعيد صحيح إذا كان التاريخ صالحًا وإلا خطأ. يكون التاريخ صالحًا إذا تم الوفاء بجميع القواعد التالية: 1. سلسلة التاريخ ليست فارغة. 2. عدد الأيام ليس أقل من 1 أو أكبر من 31 يومًا للأشهر 1,3,5,7,8,10,12. وعدد الأيام ليس أقل من 1 أو أكبر من 30 يومًا للأشهر 4,6,9,11. وعدد الأيام ليس أقل من 1 أو أكبر من 29 يومًا للشهر 2. 3. الأشهر يجب ألا تكون أقل من 1 أو أكبر من 12. 4. يجب أن يكون التاريخ في النموذج: mm-dd-yyyy على سبيل المثال: valid_date (('03-11-2000') => صحيح_date (('15-01-2012') => خطأ صحيح_date (('04-01-2040') => خطأ_date (('06-04-2020') => صحيح_date (('06/04/2020') => خطأ\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''مع إعطاء سلسلة من الكلمات، أعد قائمة من الكلمات مقسمة على المساحات البيضاء، إذا لم تكن هناك مساحات بيضاء في النص يجب أن تقسم على الفواصل '، إذا لم تكن هناك فواصل يجب أن تعيد عدد الحروف الصغيرة مع ترتيب غريب في الأبجدية، ord (('a') = 0، ord ((('b') = 1، ... ord ((('z') = 25 أمثلة split_words ((\"مرحبا العالم!\") â -> [\"مرحبا العالم!\"] split_words ((\"مرحبا العالم!\") â -> [\"مرحبا العالم!\"] split_words (((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''إذا أعطيت قائمة بالأرقام، أعد سواء تم فرزها أو لم يتم فرزها بترتيب تصاعدي. إذا كانت القائمة تحتوي على أكثر من نسخة واحدة من نفس الرقم، أعد False. افترض عدم وجود أرقام سلبية وأعداد صحيحة فقط. أمثلة is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"يتم إعطائك فترتين، حيث كل فترة هي زوج من الأعداد الصحيحة. على سبيل المثال، فترة = (بداية، نهاية) = (1, 2). فترات معينة مغلقة مما يعني أن الفاصل (بداية، نهاية) يشمل كل من بداية ونهاية. لكل فترة معينة، يفترض أن بدايتها أقل من أو تساوي نهايتها. مهمتك هي تحديد ما إذا كان طول تقاطع هذه الفاصلين هو عدد أولي. على سبيل المثال، تقاطع الفاصلين (1, 3) ، (2، 4) هو (2، 3) الذي طوله هو 1، وهو ليس عدد أولي. إذا كان طول التقاطع هو عدد أولي، أعيد \"نعم\"، وإلا أعيد \"لا\". إذا كانت الفاصلين لا تتقاطع، أعيد \"لا\". [إدخال / إخراج] عينات: تقاطع (((1، 2، 2، 3) ==> \"تقاطع-1، (((1، 4) ==> \"تقاطع (0,\" - (((1، 5، 5، 5، 5، 6)) ==> \"نعم\"\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"يتم إعطائك صف صفوف من الأعداد الصحيحة وتحتاج إلى إرجاع مجموع مقادير الأعداد الصحيحة مضروبة في ناتج جميع علامات كل رقم في المصفوفة، ممثلة بـ 1، -1 أو 0. ملاحظة: إرجاع لا شيء لصفوف فارغة. مثال: >>> prod_signs (([1، 2، 2، -4]) == -9 >>> prod_signs (([0، 1]) == 0 >>> prod_signs (([]) == لا شيء\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"إذا كان لديك شبكة من N صفوف وN أعمدة (N >= 2) وكل خلية من الخلية تحتوي على قيمة. كل عدد صحيح في النطاق [1, N * N] يشمل يظهر مرة واحدة بالضبط على خلايا الشبكة. يجب عليك العثور على الحد الأدنى من المسار طول k في الشبكة. يمكنك البدء من أي خلية، وفي كل خطوة يمكنك الانتقال إلى أي من الخلايا المجاورة، وبعبارة أخرى، يمكنك الذهاب إلى الخلايا التي تتشارك حافة مع الخلية الحالية. يرجى ملاحظة أن مسار طول k يعني زيارة بالضبط k خلايا (ليس بالضرورة متميزة). لا يمكنك الخروج من الشبكة. مسار A (طول k) يعتبر أقل من مسار B (طول k) إذا بعد إجراء القوائم الترتيبية للقيم على الخلايا التي تمر من خلال A و B (دعونا نسميها l_st و l_stA) ، فإن l_stA هي أقل من المسار المفرد الجغرافي من l_stB، وبعبارة أخرى، في الشبكة، يمكنك الذهاب إلى أي من الخلايا المجاورة، وبعبارة الأخرى، يمكنك الذهاب إلى خلية التي تتشارك فيها الحد الأد الأدنى من الخلايا.\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"يعرف الجميع تسلسل فيبوناتشي، وقد درسها الرياضيون بعمق في القرنين الماضيين. ومع ذلك، ما لا يعرفه الناس هو تسلسل تريبوناتشي. يتم تعريف تسلسل تريبوناتشي من خلال التكرار: tri(1) = 3 tri(n) = 1 + n / 2، إذا كان n زوجًا. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، إذا كان n فردًا. على سبيل المثال: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 يتم إعطائك عدد صحيح غير سالب n، عليك إرجاع قائمة بأول n + 1 أرقام تسلسل تريبوناتشي. أمثلة: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"مع إعطاء عدد صحيح إيجابي n، أعد ناتج الأرقام الفردية. أعد 0 إذا كانت جميع الأرقام زوجية. على سبيل المثال: أرقام ((1) == 1 أرقام ((4) == 0 أرقام ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''إنشاء دالة تأخذ سلسلة كمدخلات تحتوي على أقواس مربعة فقط. يجب أن تعيد الدالة True إذا كان هناك سلسلة فرعية صالحة من الأقواس حيث يوجد أقواس واحد على الأقل في التسلسل الفرعي. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"يتم إعطائك قائمة بالأرقام. تحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المقدمة، ثم تقريب كل عنصر في القائمة إلى العنصر العلوي. أمثلة: لـ lst = [1,2,3] يجب أن يكون الإخراج 14 لـ lst = [1,4,9] يجب أن يكون الإخراج 98 لـ lst = [1,3,5,7] يجب أن يكون الإخراج 84 لـ lst = [1.4,4.2,0] يجب أن يكون الإخراج 29 لـ lst = [-2.4,1,1] يجب أن يكون الإخراج 6 \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''إنشاء دالة تعيد صحيح إذا كانت الحرف الأخير من سلسلة معينة حرفيًا أبجديًا وليست جزءًا من كلمة ، وإلا فالز. ملاحظة: \"كلمة\" هي مجموعة من الأحرف مفصولة عن طريق الفراغ. أمثلة: check_if_last_char_is_a_letter (((\"كعكة التفاح\") â -> False check_if_last_char_is_a_letter (((\"تفاح pi e\") â -> True check_if_last_char_is_a_letter (((\"تفاح pi e\") â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"إنشاء دالة تعيد أكبر مؤشر لعنصر لا يكون أكبر من أو يساوي العنصر الذي يسبقه مباشرة. إذا لم يكن هناك عنصر من هذا القبيل ، فاسترد -1. لن يحتوي المصفوفة المحددة على قيم مكررة. أمثلة: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''إنشاء دالة تعيد توبل (a, b) ، حيث يكون 'a' أكبر عدد صحيح سلبي، و'b' أصغر عدد صحيح إيجابي في القائمة. إذا لم يكن هناك عدد صحيح سلبي أو إيجابي، أعده باسم None. أمثلة: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (لا يوجد، 1) largest_smallest_integers([]) == (لا يوجد، لا يوجد) largest_smallest_integers[0]) == (لا يوجد، لا يوجد) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"إنشاء دالة تأخذ الأعداد الصحيحة أو العائمة أو السلاسل التي تمثل الأعداد الحقيقية، وتعيد المتغير الأكبر في نوع المتغير المعطى. لا تعيد أي شيء إذا كانت القيم متساوية. ملاحظة: إذا تم تمثيل عدد حقيقي كسلسلة، قد يكون النقطة العائمة . أو ، compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> لا شيء \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"تقييم ما إذا كان يمكن كتابة العدد n كمجموع 4 أرقام زوجية إيجابية بالضبط. مثال is_equal_to_sum_even ({4) } == خطأ is_equal_to_sum_even ({6) } == خطأ is_equal_to_sum_even ({8) } == صحيح \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"يتم تعريف الفاعلي البرازيلي على النحو التالي: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! حيث n > 0 على سبيل المثال: >>> special_factorial ((4) 288 ستتلقى الدالة عدداً صحيحاً كمدخل ويجب أن تعيد الفاعلي الخاص لهذا العدد الصحيح. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_مثال-3، قم باستبدال جميع المساحات فيها بالخطوط السفلية، وإذا كانت سلسلة تحتوي على أكثر من 2 مساحات متتالية، قم باستبدال جميع المساحات المتتالية بـ - fix_spaces (((\"مثال\") == \"مثال\" fix_spaces (((\"مثال1\") == \"مثال1\" fix_spaces (((\"مثال2\") == \"_مثال_2\" fix_spaces (((\"مثال 3\") == \"_مثال-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"إنشاء دالة تأخذ سلسلة تمثل اسم الملف، وتعود \"نعم\" إذا كان اسم الملف صالحا، وتعود \"لا\" خلاف ذلك. يُعتبر اسم الملف صالحا إذا و فقط إذا تم استيفاء جميع الشروط التالية: - يجب ألا يكون هناك أكثر من ثلاثة أرقام ('0'-'9') في اسم الملف. - اسم الملف يحتوي على نقطة واحدة بالضبط '.' - يجب ألا يكون السلسلة الفرعية قبل النقطة فارغة، ويجب أن تبدأ بحرف من الحروف الأبجدية اللاتينية ('a'-'z' و 'A''-Z'). - يجب أن تكون السلسلة الفرعية بعد النقطة واحدة من هذه: ['txt'، 'exe'، 'll'd] الأمثلة: file_name_check\"{example.txt.t\") # => 'نعم'_name_file_check\"{example.dll1\") => 'لا' (يجب أن يبدأ الاسم بحرف الأبجدية اللاتينية) # => 'لا' (يجب أن يبدأ الاسم بالحرف الأبجدية اللاتينية)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" هذه الدالة ستأخذ قائمة من الأعداد الصحيحة. بالنسبة لجميع الإدخالات في القائمة، يجب على الدالة تربيع إدخال العدد الصحيح إذا كان مؤشرها مضاعف لـ 3 وستقوم بتثني إدخال العدد الصحيح إذا كان مؤشرها مضاعف لـ 4 وليس مضاعف لـ 3. لن تغير الدالة الإدخالات في القائمة التي لا تكون مؤشراتها مضاعفة لـ 3 أو 4. ثم يجب على الدالة إرجاع مجموع جميع الإدخالات. أمثلة: لـ lst = [1,2,3] يجب أن يكون الإخراج 6 لـ lst = [] يجب أن يكون الإخراج 0 لـ lst = [-1,-5,2,-1,-5] يجب أن يكون الإخراج -126 \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"يتم إعطائك سلسلة تمثل جملة، تحتوي الجملة على بعض الكلمات مفصولة بمسافة، ويجب عليك إرجاع سلسلة تحتوي على كلمات من الجملة الأصلية، التي تكون أطوالها أرقام أولية، يجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفسه الذي كان في الأصل. مثال1: المدخل: جملة = \"هذا اختبار\" الناتج: \"هو\" مثال2: المدخل: جملة = \"دعنا نذهب للسباحة\" الناتج: \"نذهب لل\" قيود: * 1 <= len(الفرضية) <= 100 * الجملة تحتوي على الحروف فقط \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"مهمتك هي تنفيذ وظيفة من شأنها تبسيط التعبير x * n. وتعود الوظيفة صحيحا إذا x * n تقيم إلى عدد صحيح و كاذبة خلاف ذلك. كل من x و n ، هي تمثيل سلسلة من الكسر ، ولها الشكل التالي ، <مقام> / <مقام> حيث كل من المقام والمقام هي أرقام صحيحة. يمكنك افتراض أن x و n هي كسور صالحة ، وليس لها صفر كمقام. تبسيط (((\"1/5\" ، \"5/1\") = صحيح تبسيط (((\"1/6\" ، \"2/1\") = كاذبة تبسيط (((\"7/10\" ، \"10/2\") = كاذبة \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"اكتب دالة تقوم بترتيب قائمة الأعداد الصحيحة بالترتيب الصاعد حسب مجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر ذات مجموع أرقام مماثل، رتبها بناءً على مؤشرها في القائمة الأصلية. على سبيل المثال: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"اكتب دالة تأخذ صفوف من الأرقام كمدخل وتعيد عدد العناصر في المصفوفة التي أكبر من 10 والعدد الأول والأخير من العدد هو فردي (1, 3, 5, 7, 9). على سبيل المثال: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"يتم إعطائك عدد صحيح إيجابي n. يجب عليك إنشاء صف صفائي a بطول n. لكل i (1 ‰¤ i ‰¤ n) ، قيمة a[i] = i * i - i + 1. أعيد عدد الثلاثيات (a[i] ، a[j] ، a[k]) من a حيث i < j < k ، و a[i] + a[j] + a[k] مضاعف ل 3. مثال: المدخلات: n = 5 المخرجات: 1 التفسير: a = [1, 3, 7, 13, 21] الثلاثية الوحيدة الصحيحة هي (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''هناك ثمانية كواكب في نظامنا الشمسي: أقرب كوكب إلى الشمس هو عطارد، والقمر هو القمر التالي، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون. اكتب وظيفة تأخذ اثنين من أسماء الكواكب كسلسلة كوكب1 وكوكب2. يجب أن تعيد الوظيفة توبل يحتوي على جميع الكواكب التي تقع مداراتها بين مدار الكوكب1 ومدار الكوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الوظيفة توبل فارغ إذا كان الكوكب1 أو الكوكب2 ليست أسماء الكواكب الصحيحة. أمثلة bf \"(المشتري\"، \"نبتون\") ==> (\"زحل\"، \"أورانوس\") bf (((\"الأرض\"، \"زئبق\") ==> (\"الزهرة\") bf (((\"الزئبق\"، \"أورانوس\") ==> (\"الزهرة\"، \"الأرض\"، \"المريخ\"، \"المشتري\"، \"الزهرة\"، \"الشمس\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"اكتب دالة تقبل قائمة من السلاسل كمعلم، وتحذف السلاسل التي لها أطوال غير متطابقة منها، وتعيد القائمة الناتجة مع ترتيب مرتب، القائمة هي دائما قائمة من السلاسل وليس أبدا مصفوفة من الأرقام، وقد تحتوي على نسخ مكررة. يجب أن يكون ترتيب القائمة صعوديًا حسب طول كل كلمة، ويجب عليك إرجاع القائمة مرتبة من خلال هذه القاعدة. إذا كان للكلمتين نفس الطول، قم بترتيب القائمة أبجديًا. يجب أن تعيد الدالة قائمة من السلاسل بترتيب مرتب. قد تفترض أن جميع الكلمات سيكون لها نفس الطول. على سبيل المثال: assert list_sort[\"aa\"\"، \"a\"\"، \"aaa\"]) => assert list_sort[\"ab\"\"، \"aaaa\"\"، \"cd\" => \"abd\")\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"برنامج بسيط يجب أن يعيد قيمة x إذا كان n عدداً أولياً ويجب أن يعيد قيمة y خلاف ذلك. أمثلة: لـ x_or_y{7، 34، 12) == 34 لـ x_or_y{15، 8، 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''مع إعطاء قائمة من الأرقام، أعد مجموع مربعات الأرقام في القائمة التي هي فردية. تجاهل الأرقام التي هي سلبية أو غير صحيحة. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 إذا كانت قائمة الإدخال فارغة، أعد 0. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"أعتقد أننا جميعا نتذكر هذا الشعور عندما تكون نتيجة بعض الأحداث التي طال انتظارها معروفة أخيرا. المشاعر والأفكار التي لديك في تلك اللحظة تستحق بالتأكيد أن تلاحظها وتقارنها. مهمتك هي تحديد ما إذا كان الشخص قد خمّن بشكل صحيح نتائج عدد من المباريات. يتم إعطائك صفيفين من النتائج والخمّنات ذات الطول المتساوي، حيث يظهر كل مؤشر تطابق. إرجاع صفيف بنفس الطول يشير إلى مدى الخلاف في كل تخمين. إذا كان قد خمّن بشكل صحيح، فإن القيمة هي 0، وإذا لم يكن، فإن القيمة هي الفرق المطلق بين التخمين والنتيجة. مثال: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,1,0,2,4]) -> [4,4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"ستعطى لك اسم الفئة (سلسلة) وقائمة من الإضافات. يجب استخدام الإضافات لتحميل فئات إضافية إلى الفئة. قوة الإضافة هي كما يلي: دعوا CAP يكون عدد الحروف الكبيرة في اسم الإضافة، ودعوا SM يكون عدد الحروف الصغيرة في اسم الإضافة، وتعطى القوة من خلال كسر CAP - SM. يجب عليك العثور على أقوى إضافة وإعادة سلسلة في هذا التنسيق: ClassName.StrongestExtensionName. إذا كان هناك اثنين أو أكثر من الإضافات بنفس القوة، يجب عليك اختيار أول واحد في القائمة. على سبيل المثال، إذا تم إعطائك \"Slices\" كفئة وقائمة من الإضافات: ['SEviRNGSliCes'، 'Cheese'، 'StuFfed'] ثم يجب عليك إرجاع 'Slices.SEviRNGSliCes'، لأن 'SviRNGSliCes' هو أقوى إضافة (مثال: 'AA'_Beast'، 'AA'_Class'= Strongest_Extension_Class').\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"تم إعطائك كلمتين. يجب عليك إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي سلسلة فرعية في الكلمة الأولى cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"مع إعطاء عدد صحيح. يعيد توبل يحتوي على عدد من الأرقام الزوجية والفردية على التوالي. مثال: حتى_فرد_عدد ((-12) ==> (1, 1) حتى_فرد_عدد ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"مع إعطاء عدد صحيح إيجابي، احصل على ما يعادله من الأرقام الرومانية كسلسلة، واستردها بحروف صغيرة. القيود: 1 <= num <= 1000 الأمثلة: >>> int_to_mini_roman{19} == 'xix' >>> int_to_mini_roman{152} == 'clii' >>> int_to_mini_roman{426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''مع إعطاء أطوال الجوانب الثلاثة للمثلث. إرجاع صحيح إذا شكلت الجوانب الثلاثة مثلثًا زاويًا مستقيمًا، خطأ في حالة أخرى. المثلث ذي الزاوية المستقيمة هو مثلث يكون فيه زاوية واحدة زاوية مستقيمة أو 90 درجة. مثال: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"اكتب دالة تقبل قائمة من السلاسل. تحتوي القائمة على كلمات مختلفة. أعد الكلمة التي تحتوي على أقصى عدد من الأحرف الفريدة. إذا كان لدى السلاسل المتعددة أقصى عدد من الأحرف الفريدة، أعد تلك التي تأتي أولاً بالترتيب المفرد.\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"أنت أرنب جائع، وقد أكلت بالفعل عددًا معينًا من الجزر، ولكن الآن تحتاج إلى أكل المزيد من الجزر لإكمال وجبات اليوم. يجب عليك إرجاع صف [العدد الإجمالي للجزر الذي أكلته بعد وجباتك، وعدد الجزر المتبقي بعد وجباتك] إذا لم يكن هناك ما يكفي من الجزر المتبقي، فستأكل كل الجزر المتبقي، ولكنك ستظل جائعًا. مثال: * أكل ((5, 6, 10) -> [11, 4] * أكل ((4, 8, 9) -> [12, 1] * أكل ((1, 10, 10) -> [11, 0] * أكل ((2, 11, 5) -> [7, 0] المتغيرات: @number: عدد الجزر الذي أكلته. @need: عدد الجزر الذي تحتاج إلى أكله. @remaining: عدد الجزر المتبقي في المخزون. Constrain: *= 0 <= 0 * 1000 <= 0 * 0 <= 1000 = 0 المتبقي = 1000 <= 1000 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"مع إعطاء قائمتين للعميل، والعميل. القائمة الأولى تحتوي على عمليات الجبر الأساسية، والقائمة الثانية هي قائمة بالأعداد الصحيحة. استخدم القائمتين المقدمتين لبناء التعبير الجبري وإعادة تقييم هذا التعبير. عمليات الجبر الأساسية: الجمع (+) الخصم ( - ) الضرب ( * ) القسمة الأرضية ( // ) الأسبقية ( ** مثال ): العميل['+'، '*'، '-'] صف = [2, 3, 4, 5] النتيجة = 2 + 3 * 4 - 5 => النتيجة = 9 ملاحظة: طول قائمة العميل يساوي طول قائمة العميل ناقص واحد. العميل هو قائمة من الأعداد الصحيحة غير السالبة. لدى العميل قائمة واحدة على الأقل من العملاء، ولدى قائمة العميل على الأقل اثنين من العملاء.\"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"يتم إعطائك سلسلة s. إذا كانت s[i] حرفًا ، فقم بإعادتها من أسفل إلى أعلى أو العكس بالعكس ، وإلا فلتبقيها كما هي. إذا لم تحتوي السلسلة على أحرف ، فقم بإعادتها. يجب أن تعيد الدالة السلسلة الناتجة. أمثلة حل ((\"1234\") = \"4321\" حل ((\"ab\") = \"AB\" حل ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"إذا أعطيت سلسلة 'text'، أعد سلسلة ما يعادلها من تشكيلات md5. إذا كانت 'text' سلسلة فارغة، أعد None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "arb_Arab",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"مع إعطاء عددين صحيحين إيجابيين a و b، أعد الأرقام الزوجية بين a و b، بالترتيب الصاعد. على سبيل المثال: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]