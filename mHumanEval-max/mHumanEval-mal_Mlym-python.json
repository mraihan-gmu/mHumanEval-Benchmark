[
    {
        "task_id": "HumanEval/0",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"തന്നിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയിൽ, തന്നിരിക്കുന്ന പരിധിയേക്കാൾ പരസ്പരം അടുത്തുള്ള രണ്ട് സംഖ്യകൾ ഉണ്ടോ എന്ന് പരിശോധിക്കുക. ഉദാഹരണംഃ >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) തെറ്റാണ് >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) ശരിയാണ് \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"ഈ ഫംഗ്ഷനിലെ ഇൻപുട്ട് ഒന്നിലധികം കൂട്ടം കൂട്ടിച്ചേർത്ത പരാൻതീസിസ് അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്. ആ ഗ്രൂപ്പുകളെ പ്രത്യേക സ്ട്രിംഗുകളായി വേർതിരിച്ച് അവയുടെ പട്ടിക തിരികെ നൽകുക എന്നതാണ് നിങ്ങളുടെ ലക്ഷ്യം. പ്രത്യേക ഗ്രൂപ്പുകൾ സന്തുലിതമാണ് (ഓരോ തുറന്ന ബ്രാക്കറ്റും ശരിയായി അടച്ചിരിക്കുന്നു) പരസ്പരം കൂട്ടിച്ചേർക്കപ്പെടുന്നില്ല. ഇൻപുട്ട് സ്ട്രിംഗിലെ ഏതെങ്കിലും സ്പെയ്സുകൾ അവഗണിക്കുക. ഉദാഹരണംഃ >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ) ' ['() ', '(()) ', '(() '))\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് നമ്പർ നൽകിയിട്ടുണ്ടെങ്കിൽ, അത് പൂർണ്ണസംഖ്യാ ഭാഗമായും (നൽകിയ സംഖ്യയേക്കാൾ വലുത്) ദശാംശ ഭാഗമായും (ഇടത് ഭാഗം എല്ലായ്പ്പോഴും 1 നേക്കാൾ ചെറുതാണ്) വിഭജിക്കാം. സംഖ്യയുടെ ദശാംശ ഭാഗം തിരികെ നൽകുക. ഉദാഹരണംഃ >>> truncate_number(3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"നിങ്ങൾക്ക് ഒരു ബാങ്ക് അക്കൌണ്ടിലെ നിക്ഷേപ, പിൻവലിക്കൽ പ്രവർത്തനങ്ങളുടെ ഒരു ലിസ്റ്റ് നൽകിയിരിക്കുന്നു. അത് ആരംഭിക്കുന്നത് പൂജ്യം ബാലൻസുമായിട്ടാണ്. നിങ്ങളുടെ ജോലി അക്കൌണ്ട് ബാലൻസ് പൂജ്യം എന്നതിനേക്കാൾ താഴെയാണെങ്കിൽ അത് കണ്ടെത്തുക എന്നതാണ്, ആ സമയത്ത് ഫംഗ്ഷൻ True നൽകണം. അല്ലാത്തപക്ഷം False നൽകണം. ഉദാഹരണം: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"നൽകിയിരിക്കുന്ന ഇൻപുട്ട് നമ്പറുകളുടെ പട്ടികയ്ക്കായി, ഈ ഡാറ്റാ സെറ്റിന്റെ ശരാശരിയെ ചുറ്റിപ്പറ്റിയുള്ള ശരാശരി സമ്പൂർണ്ണ വ്യതിയാനം കണക്കാക്കുക. ഓരോ ഘടകവും ഒരു സെന്റർ പോയിന്റും തമ്മിലുള്ള ശരാശരി സമ്പൂർണ്ണ വ്യത്യാസമാണ് ശരാശരി സമ്പൂർണ്ണ വ്യതിയാനം (ഈ സാഹചര്യത്തിൽ ശരാശരി): MAD = ശരാശരി ∙ x - x_mean ∙ ഉദാഹരണം: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"ഇൻപുട്ട് ലിസ്റ്റിലെ തുടർച്ചയായ രണ്ട് ഘടകങ്ങൾക്കിടയിൽ ഒരു 'ഡിലിമിറ്റർ' ചേർക്കുക `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"ഈ ഫംഗ്ഷന്റെ ഇൻപുട്ട് സ്പെയ്സുകളാൽ വേർതിരിച്ചിരിക്കുന്ന നെസ്റ്റഡ് പരാൻതീസിനു വേണ്ടി ഒന്നിലധികം ഗ്രൂപ്പുകളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് ആണ്. ഓരോ ഗ്രൂപ്പിനും, പരാൻതീസിൻറെ ഏറ്റവും ആഴത്തിലുള്ള നെസ്റ്റിംഗ് ലെവൽ ഔട്ട്പുട്ട് ചെയ്യുക. ഉദാഹരണത്തിന് (() (()) ന് പരമാവധി രണ്ട് ലെവൽ നെസ്റ്റിംഗ് ഉണ്ട്, അതേസമയം ((())) ന് മൂന്ന് ഉണ്ട്. >>> parse_nested_parens('((()) ((())) () (((()) ((((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"സ്ട്രിങ്ങുകളുടെ ഒരു ഇൻപുട്ട് ലിസ്റ്റ് ഫിൽട്ടർ ചെയ്യുക, അതിൽ സബ് സ്ട്രിംഗ് ഉള്ളവ മാത്രം ഫിൽട്ടർ ചെയ്യുക >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"ഒരു നിശ്ചിത പട്ടികയിൽ, ഒരു സംഖ്യയുടെ സംഖ്യയും പട്ടികയിലെ എല്ലാ സംഖ്യകളുടെയും ഗുണിതവും അടങ്ങിയ ഒരു ടാപ്ൾ നൽകുക. ശൂന്യ സംഖ്യ 0 ന് തുല്യവും ശൂന്യ ഉൽപ്പന്നം 1 ന് തുല്യവുമാണ്. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"ഒരു നിശ്ചിത പട്ടികയിൽ നിന്ന്, പരമ്പരയിലെ ഒരു നിശ്ചിത നിമിഷം വരെ കണ്ടെത്തിയ റോളിംഗ് പരമാവധി മൂലകങ്ങളുടെ ഒരു പട്ടിക സൃഷ്ടിക്കുക. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"ഒരു സപ്ലൈഡ് സ്ട്രിങ്ങിൽ ആരംഭിക്കുന്ന ഏറ്റവും ചെറിയ പാലിൻഡ്രോം കണ്ടെത്തുക. അൽഗോരിതം ആശയം ലളിതമാണ്: - സപ്ലൈഡ് സ്ട്രിംഗിന്റെ ഏറ്റവും ദൈർഘ്യമേറിയ പോസ്റ്റ്ഫിക്സ് ഒരു പാലിൻഡ്രോം കണ്ടെത്തുക. - പാലിൻഡ്രോമിക് സഫിക്സിന് മുമ്പുള്ള ഒരു സ്ട്രിംഗ് പ്രിഫിക്സിന്റെ സ്ട്രിംഗ് റിവേഴ്സ് സ്ട്രിംഗിന്റെ അവസാനത്തിൽ ചേർക്കുക. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') ' 'catac' >>> make_palindrome ((('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"കൊടുത്തിരിക്കുന്ന സ്ട്രിംഗ് ഒരു പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുക \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"ഇൻപുട്ട് എന്നത് 1s, 0s എന്നിവ മാത്രം അടങ്ങിയ രണ്ട് സ്ട്രിങ്ങുകളാണ്. ഈ ഇൻപുട്ടുകളിൽ ബൈനറി XOR നടത്തുകയും ഫലം ഒരു സ്ട്രിംഗായി മടക്കിനൽകുകയും ചെയ്യുക. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"സ്ട്രിങ്ങുകളുടെ പട്ടികയിൽ നിന്ന്, ഏറ്റവും ദൈർഘ്യമേറിയത് തിരികെ നൽകുക. ഒരേ നീളമുള്ള ഒന്നിലധികം സ്ട്രിങ്ങുകൾ ഉണ്ടെങ്കിൽ ആദ്യത്തേത് തിരികെ നൽകുക. ഇൻപുട്ട് ലിസ്റ്റ് ശൂന്യമാണെങ്കിൽ None തിരികെ നൽകുക. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"രണ്ട് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവയുടെ ഏറ്റവും വലിയ പൊതുവിഭജനം തിരിച്ചുനൽകുന്നു >>> ഏറ്റവും വലിയ_സാധാരണ_വിഭജകൻ (, ) 1 >>> ഏറ്റവും വലിയ_സാധാരണ_വിഭജകൻ (, ) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"എല്ലാ പ്രിഫിക്സുകളുടെയും പട്ടിക തിരികെ നൽകുന്നു.\"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"0 മുതൽ n വരെ സ്പേസ് ഡെലിമിറ്റഡ് നമ്പറുകൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകുക. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"ഒരു സ്ട്രിംഗ് തന്നിരിക്കുന്ന, എത്ര വ്യത്യസ്ത പ്രതീകങ്ങൾ (കേസ് പരിഗണിക്കാതെ) അത് അടങ്ങിയിരിക്കുന്നു കണ്ടെത്തുക >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('ജെറി') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"ഈ ഫംഗ്ഷനിലേക്ക് ഇൻപുട്ട് ചെയ്യുന്നത് ഒരു പ്രത്യേക ASCII ഫോർമാറ്റിലുള്ള സംഗീത കുറിപ്പുകൾ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് ആണ്. നിങ്ങളുടെ ചുമതല നിരവധി ബീറ്റുകളുമായി പൊരുത്തപ്പെടുന്ന പൂർണ്ണസംഖ്യകളുടെ സ്ട്രിംഗ് ലിസ്റ്റ് പാഴ്സ് ചെയ്യുക എന്നതാണ്. ഇവിടെ ഒരു ലെജന്റ് ഉണ്ട്: 'o' കുറിപ്പ്, അവസാന നാല് ബീറ്റുകൾ 'o' പകുതി കുറിപ്പ്, അവസാന രണ്ട് ബീറ്റുകൾ 'o' ക്വാട്ടർ കുറിപ്പ്, അവസാന ഒരു ബീറ്റ് >>> parse_music '. 'o o . o o . o . o . o . o . o . o . o . o . o . o . o ' [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4] ഓരോന്നും എങ്ങനെ പൂർണ്ണ സംഖ്യകളല്ലെന്നും ഈ മടങ്ങിവരികയും ചെയ്യുന്നു\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"ഒരു സബ് സ്ട്രിംഗ് എത്ര തവണ ഒറിജിനൽ സ്ട്രിംഗിൽ കണ്ടെത്താം എന്ന് കണ്ടെത്തുക. ഒന്നിനൊന്ന് ചേരുന്ന കേസുകൾ എണ്ണുക. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"'പൂജ്യം' മുതൽ 'ഒൻപത്' വരെയുള്ള സംഖ്യകളുടെ സ്പേസ്-ഡെലിമിനേറ്റഡ് സ്ട്രിംഗ് ആണ് ഇൻപുട്ട്. സാധുവായ ചോയ്സുകൾ 'പൂജ്യം', 'ഒന്ന്', 'രണ്ട്', 'മൂന്ന്', 'നാല്', 'അഞ്ച്', 'ആറ്', 'ഏഴ്', 'എട്ട്' , 'ഒൻപത്' എന്നിവയാണ്. ഏറ്റവും ചെറിയതിൽ നിന്ന് ഏറ്റവും വലിയതിലേക്ക് അടുക്കിയ നമ്പറുകളുള്ള സ്ട്രിംഗ് നൽകുക >>> sort_numbers (('മൂന്ന് ഒന്ന് അഞ്ച്') 'ഒന്ന് മൂന്ന് അഞ്ച്' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"നൽകിയിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയിൽ നിന്ന് (കുറഞ്ഞത് രണ്ട് നീളമുള്ളത്) പരസ്പരം ഏറ്റവും അടുത്തുള്ള രണ്ട് എണ്ണം തിരഞ്ഞെടുത്ത് അവയെ ക്രമത്തിൽ (ചെറിയ സംഖ്യ, വലിയ സംഖ്യ) നൽകുക. >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"ഒരു സംഖ്യകളുടെ പട്ടിക (കുറഞ്ഞത് രണ്ട് ഘടകങ്ങൾ), ആ പട്ടികയിൽ ഒരു ലീനിയർ പരിവർത്തനം പ്രയോഗിക്കുക, ഏറ്റവും ചെറിയ സംഖ്യ 0 ആയിത്തീരുകയും ഏറ്റവും വലിയത് 1 ആകുകയും ചെയ്യും >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"പൂർണ്ണസംഖ്യകൾക്കു മാത്രം നൽകിയിരിക്കുന്ന പൈത്തൺ മൂല്യങ്ങളുടെ പട്ടിക ഫിൽട്ടർ ചെയ്യുക >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"നൽകിയ സ്ട്രിങ്ങിന്റെ മടക്ക ദൈർഘ്യം >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"n എന്ന സംഖ്യയെ തുല്യമായി വിഭജിക്കുന്ന ഏറ്റവും വലിയ സംഖ്യ കണ്ടെത്തുക, n നേക്കാൾ ചെറുത് >>> വലിയ_വിഭജകൻ (_BAR_) 15 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"നൽകിയ പൂർണ്ണസംഖ്യയുടെ പ്രൈം ഫാക്ടറുകളുടെ പട്ടിക ഏറ്റവും ചെറിയതിൽ നിന്ന് ഏറ്റവും വലിയതിലേക്ക് ക്രമത്തിൽ നൽകുക. ഓരോ ഘടകങ്ങളും ഘടകവൽക്കരണത്തിൽ എത്ര തവണ പ്രത്യക്ഷപ്പെടുന്നു എന്നതിന് തുല്യമായ എണ്ണം നൽകണം. ഇൻപുട്ട് നമ്പർ എല്ലാ ഘടകങ്ങളുടെയും ഗുണനത്തിന് തുല്യമായിരിക്കണം >>> ഘടകവൽക്കരിക്കുക () [2, 2, 2] >>> ഘടകവൽക്കരിക്കുക () [5, 5] >>> ഘടകവൽക്കരിക്കുക () [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"ഒരു സംഖ്യകളുടെ പട്ടികയിൽ നിന്ന് ഒന്നിൽ കൂടുതൽ തവണ വരുന്ന എല്ലാ ഘടകങ്ങളും നീക്കം ചെയ്യുക. ഘടകങ്ങളുടെ ക്രമം ഇൻപുട്ടിൽ ഉള്ളതുപോലെ തന്നെ നിലനിർത്തുക. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"ഒരു സ്ട്രിങിന്, ചെറിയ അക്ഷരങ്ങളെ വലിയ അക്ഷരങ്ങളാക്കി മാറ്റുക. >>> flip_case (('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"ഒരു സ്ട്രിങ്ങിൽ സ്ട്രിങ്ങുകളുടെ പട്ടിക കൂട്ടിച്ചേർക്കുക >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"ഒരു നിശ്ചിത പ്രിഫിക്സുമായി തുടങ്ങുന്ന സ്ട്രിങ്ങുകളുടെ ഒരു ഇൻപുട്ട് ലിസ്റ്റ് ഫിൽട്ടർ ചെയ്യുക. >>> ഫിൽട്ടർ_ബൈ_പ്രിഫിക്സ് (അ) ([], 'എ') (] >>> ഫിൽട്ടർ_ബൈ_പ്രിഫിക്സ് (അ) (['എബിസി', 'ബിസിഡി', 'സിഡി', 'അറേ'], 'എ') (അബിസി', 'അറേ']\"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"പട്ടികയിലെ പോസിറ്റീവ് സംഖ്യകൾ മാത്രം മടക്കിനൽകുക. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"ഒരു സംഖ്യ പ്രൈം ആണെങ്കിൽ ശരിയായി നൽകുക, അല്ലെങ്കിൽ തെറ്റായി നൽകുക. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs ഒരു പോളിനോമിയുടെ ഗുണകങ്ങളാണ്. find_zero find x പോലുള്ള poly (((x) = 0. find_zero ഒരു പരിഹാരം ഉറപ്പാക്കുന്നതിനാൽ, നിരവധി ഗുണകങ്ങളുടെയും ഏറ്റവും വലിയ നോൺ-സീറോ ഗുണകത്തിന്റെയും എണ്ണം മാത്രമുള്ള xs മാത്രമേ തിരികെ നൽകൂ. >>> round (((find_zero[(1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> round (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"xs എന്ന പോയിന്റിൽ xs എന്ന ഗുണകങ്ങളുള്ള ഒരു പോളിനോമൽ വിലയിരുത്തുന്നു. xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"ഈ ഫംഗ്ഷൻ ഒരു ലിസ്റ്റ് l എടുക്കുകയും ഒരു ലിസ്റ്റ് l' തിരികെ നൽകുകയും ചെയ്യുന്നു, അങ്ങനെ l' എന്നത് l- ന് തുല്യമാണ്, മൂന്ന് കൊണ്ട് ഹരിക്കാത്ത സൂചികകളിൽ, മൂന്ന് കൊണ്ട് ഹരിക്കാവുന്ന സൂചികകളിലെ അതിന്റെ മൂല്യങ്ങൾ l- ന്റെ അനുബന്ധ സൂചികകളുടെ മൂല്യങ്ങൾക്ക് തുല്യമാണ്, പക്ഷേ അടുക്കിയിരിക്കുന്നു. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"ഒരു പട്ടികയിലെ തരം തിരിക്കപ്പെട്ട അദ്വിതീയ ഘടകങ്ങൾ >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] യിൽ തിരികെ നൽകുന്നു.\"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"പട്ടികയിലെ പരമാവധി മൂലകം തിരികെ നൽകുന്നു. >>> max_element([1, 2, 3]) 3 >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"11 അല്ലെങ്കിൽ 13 കൊണ്ട് ഹരിക്കാവുന്ന n ൽ കുറവുള്ള സംഖ്യകളിൽ 7 എന്ന അക്കം എത്ര പ്രാവശ്യം ദൃശ്യമാകുന്നു എന്നതിന്റെ സംഖ്യ നൽകുക. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"ഈ ഫംഗ്ഷൻ ഒരു ലിസ്റ്റ് l എടുക്കുകയും ഒരു ലിസ്റ്റ് l' നൽകുകയും ചെയ്യുന്നു, അങ്ങനെ l' l ന് തുല്യമാണ്, അതേസമയം l ന്റെ ഇരട്ട സൂചികകളിലെ മൂല്യങ്ങൾ l ന്റെ ഇരട്ട സൂചികകളുടെ മൂല്യങ്ങൾക്ക് തുല്യമാണ്, പക്ഷേ അടുക്കിയിരിക്കുന്നു. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"എൻകോഡ്_സൈക്ലിക് ഫംഗ്ഷനിലൂടെ എൻകോഡ് ചെയ്ത ഒരു ഇൻപുട്ട് സ്ട്രിംഗ് ആയി എടുക്കുന്നു. ഡീകോഡ് ചെയ്ത സ്ട്രിംഗ് നൽകുന്നു.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\" മൂന്ന് പ്രതീകങ്ങളുടെ സൈക്ലിംഗ് ഗ്രൂപ്പുകളിലൂടെ എൻകോഡ് ചെയ്ത സ്ട്രിംഗ് നൽകുന്നു.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib ഫിബോനാച്ചി സംഖ്യയായ n-ആം സംഖ്യയെ നൽകുന്നു. അത് ഒരു പ്രൈം നമ്പർ കൂടിയാണ്. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക ഇൻപുട്ടായി എടുക്കുന്നു. പട്ടികയിൽ മൂന്ന് വ്യത്യസ്ത ഘടകങ്ങൾ ഉണ്ടെങ്കിൽ അത് ശരി എന്ന് നൽകുന്നു, അല്ലാത്തപക്ഷം False. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"ഒരു തികച്ചും നേരായ അനന്തമായ നീളമുള്ള വരയാണ് ഒരു റോഡ് സങ്കൽപ്പിക്കുക. n കാറുകൾ ഇടത്തുനിന്ന് വലത്തോട്ട് ഓടുന്നു; ഒരേ സമയം, n കാറുകളുടെ മറ്റൊരു സെറ്റ് വലത്തുനിന്ന് ഇടത്തോട്ട് ഓടുന്നു. രണ്ട് സെറ്റ് കാറുകൾ പരസ്പരം വളരെ അകലെയാണ് ആരംഭിക്കുന്നത്. എല്ലാ കാറുകളും ഒരേ വേഗതയിൽ നീങ്ങുന്നു. ഇടത്തുനിന്ന് വലത്തോട്ട് നീങ്ങുന്ന ഒരു കാർ വലത്തുനിന്ന് ഇടത്തോട്ട് നീങ്ങുന്ന ഒരു കാറിനെ തട്ടുമ്പോൾ രണ്ട് കാറുകൾ കൂട്ടിയിടിക്കുന്നുവെന്ന് പറയപ്പെടുന്നു. എന്നിരുന്നാലും, കാറുകൾ അനന്തമായി കരുത്തുറ്റതും ശക്തവുമാണ്; തൽഫലമായി, അവ കൂട്ടിയിടിക്കാത്തതുപോലെ അവയുടെ പാതയിൽ നീങ്ങുന്നു. ഈ ഫംഗ്ഷൻ അത്തരം കൂട്ടിയിടികളുടെ എണ്ണം നൽകുന്നു. \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] കൊണ്ട് വർദ്ധിപ്പിച്ച മൂലകങ്ങളുള്ള ഒരു പട്ടിക തിരികെ നൽകുക\"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക ഇൻപുട്ടായി എടുക്കുന്നു. പട്ടികയിൽ രണ്ട് വ്യത്യസ്ത ഘടകങ്ങൾ ഉണ്ടെങ്കിൽ അത് ശൂന്യമായി സംഖ്യ ചെയ്യുകയും, അല്ലെങ്കിൽ False നൽകുകയും ചെയ്യുന്നു. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"ഇൻപുട്ട് നമ്പർ x ന്റെ സംഖ്യാ അടിത്തറയെ അടിസ്ഥാനത്തിലേക്ക് മാറ്റുക. പരിവർത്തനത്തിനുശേഷം സ്ട്രിംഗ് പ്രാതിനിധ്യം മടക്കിനൽകുക. അടിസ്ഥാന സംഖ്യകൾ 10 ൽ കുറവാണ്. >>> മാറ്റം_അടിസ്ഥാനം (8, 3) '22' >>> മാറ്റം_അടിസ്ഥാനം (8, 2) '1000' >>> മാറ്റം_അടിസ്ഥാനം (7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"ഒരു ത്രികോണത്തിന്റെ ഒരു വശത്തിന്റെ നീളവും ഉയർന്ന റിട്ടേൺ ഏരിയയും നൽകിയിട്ടുണ്ട്. >>> ത്രികോണം_ഏരിയ\"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"ഫിബൊനാച്ചി അനുക്രമത്തിന് സമാനമായ ഒരു അനുക്രമമാണ് ഫിബൊനാച്ചി സംഖ്യാ ശ്രേണി. ഇത് താഴെ പറയുന്ന രീതിയിൽ നിർവചിച്ചിരിക്കുന്നു: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4 സംഖ്യാ ശ്രേണിയുടെ n-ആം ഘടകം കാര്യക്ഷമമായി കണക്കാക്കാൻ ഒരു ഫംഗ്ഷൻ എഴുതുക. ആവർത്തനം ഉപയോഗിക്കരുത്. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"പട്ടികയിലെ മൂലകങ്ങളുടെ റിട്ടേൺ മീഡിയൻ l. >>> മീഡിയൻ (([3, 1, 2, 4, 5]) 3 >>> മീഡിയൻ (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"നൽകിയിരിക്കുന്ന സ്ട്രിംഗ് ഒരു പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുന്നു >>> is_palindrome('') True >>> is_palindrome('aba') True >>> is_palindrome('aaaaa') True >>> is_palindrome('zbcd') False \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2^n മോഡുലോ പി (നമ്പറുകളെക്കുറിച്ച് ബോധവാനായിരിക്കുക) നൽകുക. >>> മോഡ്പ് (, ) 3 >>> മോഡ്പ് (, ) 2 >>> മോഡ്പ് (, ) 1 >>> മോഡ്പ് (, ) 3, 11) 8 >>> മോഡ്പ് (, ) 1\"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"എൻകോഡ്_ഷിഫ്റ്റ് ഫംഗ്ഷനിലൂടെ എൻകോഡ് ചെയ്ത ഒരു ഇൻപുട്ട് സ്ട്രിംഗ് ആയി എടുക്കുന്നു. ഡീകോഡ് ചെയ്ത സ്ട്രിംഗ് നൽകുന്നു.\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"അക്ഷരമാലയിലെ ഓരോ അക്ഷരവും 5 കൊണ്ട് മാറ്റിക്കൊണ്ട് എൻകോഡ് ചെയ്ത സ്ട്രിംഗ് നൽകുന്നു.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels എന്നത് സ്ട്രിംഗ് എടുക്കുകയും സ്വരാക്ഷരങ്ങളില്ലാത്ത സ്ട്രിംഗ് നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷനാണ്. >>> remove_vowels('') ' ' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') ' ' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"ലിസ്റ്റിലെ എല്ലാ സംഖ്യകളും പരിധി t ന് താഴെയാണെങ്കിൽ True തിരികെ നൽകുക. >>> below_threshold([1, 2, 4, 10], 100) True >>> below_threshold([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"x, y എന്നീ രണ്ട് സംഖ്യകൾ കൂട്ടിച്ചേര് ക്കുക.\"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"രണ്ട് വാക്കുകളിൽ ഒരേ പ്രതീകങ്ങൾ ഉണ്ടോ എന്ന് പരിശോധിക്കുക. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') ശരിയാണ് >>> same_chars (('abcd', 'dddddddabc') ശരിയാണ് >>> same_chars (('dddddddabc', 'abcd') ശരിയാണ് >>> same_chars (('eabcd', 'dddddddabc') തെറ്റാണ് >>> same_chars ((('abcd', 'dddddddabce') തെറ്റാണ് >>> same_chars ((eabcdzzzz', 'dddzzzzzzdddabc') തെറ്റാണ് \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-ആം ഫിബോനാച്ചി സംഖ്യ തിരികെ നൽകുക. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets എന്നത് \"<\" ഉം \">\" ഉം അടങ്ങുന്ന ഒരു സ്ട്രിംഗ് ആണ്. ഓരോ തുറക്കുന്ന ബ്രാക്കറ്റിനും അനുയോജ്യമായ ഒരു അടയ്ക്കുന്ന ബ്രാക്കറ്റ് ഉണ്ടെങ്കിൽ True എന്ന് റിട്ടേൺ ചെയ്യുക. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") True >>> correct_bracketing(\"<<><>\") True >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"True എന്നത് ലിസ്റ്റ് എലമെന്റുകൾ ഏകതാനമായി വർദ്ധിക്കുകയോ കുറയ്ക്കുകയോ ചെയ്യുന്നു. >>> ഏകതാനമായി ([1, 2, 4, 20]) True >>> ഏകതാനമായി ([1, 20, 4, 10]) False >>> ഏകതാനമായി ([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"രണ്ട് ലിസ്റ്റുകൾക്കായുള്ള തരം തിരിക്കപ്പെട്ട സവിശേഷമായ പൊതുവായ ഘടകങ്ങൾ മടക്കി നൽകുന്നു. >>> സാധാരണ (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> സാധാരണ (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"n ന്റെ ഏറ്റവും വലിയ പ്രൈം ഫാക്ടർ തിരികെ നൽകുക. n > 1 ആണെന്ന് കരുതുക, അത് പ്രൈം അല്ല. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n എന്നത് 1 മുതൽ n വരെയുള്ള സംഖ്യകളുടെ സംഖ്യയായി കണക്കാക്കുന്ന ഒരു ഫംഗ്ഷനാണ്.\"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets എന്നത് \"(\"ഉം \"\") ഉം അടങ്ങുന്ന ഒരു സ്ട്രിംഗ് ആണ്. ഓരോ തുറക്കുന്ന ബ്രാക്കറ്റിനും അനുയോജ്യമായ ഒരു അടയ്ക്കുന്ന ബ്രാക്കറ്റ് ഉണ്ടെങ്കിൽ True എന്ന് മടക്കിനൽകുക. >>> correct_bracketing(\"(\") False >>> correct_bracketing(\"() True >>> correct_bracketing(\"() True >>> correct_bracketing(\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs ഒരു പോളിനോമിയുടെ ഗുണിതങ്ങളെ പ്രതിനിധീകരിക്കുന്നു. xs[0] + xs[1] * x + xs[2] * x^2 + .... ഈ പോളിനോമിയുടെ ഡെറിവേറ്റീവ് അതേ രൂപത്തിൽ നൽകുക. >>> ഡെറിവേറ്റീവ് (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> ഡെറിവേറ്റീവ് (([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"ഫിബ്ബോനാച്ചി അനുക്രമത്തിന് സമാനമായ ഒരു അനുക്രമമാണ് ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി. ഇത് താഴെ പറയുന്ന രീതിയിൽ നിർവചിച്ചിരിക്കുന്നു: ഫിബ്ബോനാച്ചി അനുക്രമം: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാച്ചി സംഖ്യാ ശ്രേണി: ഫിബ്ബബോനാക് സംഖ്യാ ശ്രേണി: ഫിബ്ബോനാക്ഷിഃ ഫിബ്ബോനാക്ഷിഃ ഫിബ്ബോണിയുടെ n-ആധം ഫിബ്ബം ഫിബ്ബോണിയുടെ n-ആം ഫിബ്ബം ഫിബ്ബം ഫിബ്ബം ഫിബ്ബം ഫിബ്ബം ഫിബ്ബം ഫിബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്ബ്\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"ഒരു വാക്ക് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുത്ത് സ്ട്രിംഗിലെ സ്വരാക്ഷരങ്ങളുടെ എണ്ണം നൽകുന്ന ഒരു ഫംഗ്ഷൻ vowels_count എഴുതുക. ഈ കേസിലെ സ്വരാക്ഷരങ്ങൾ 'a', 'e', 'i', 'o', 'u' എന്നിവയാണ്. ഇവിടെ, 'y' ഒരു സ്വരാക്ഷരമാണ്, പക്ഷേ അത് നൽകിയ വാക്കിന്റെ അവസാനം ആയിരിക്കുമ്പോൾ മാത്രം. ഉദാഹരണംഃ >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"കൂടുതൽ കേസുകൾ ചേര് ക്കൂ.\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"സർക്കുലർ നീക്കം x എന്ന സംഖ്യയുടെ അക്കങ്ങൾ, നീക്കം ചെയ്തുകൊണ്ട് അക്കങ്ങൾ വലത്തേക്ക് നീക്കി ഫലം ഒരു സ്ട്രിംഗായി നൽകുക. Shift > അക്കങ്ങളുടെ എണ്ണം ആണെങ്കിൽ, അക്കങ്ങൾ വിപരീതമായി നൽകുക. >>> circular_shift ((12, 1) \"21\" >>> circular_shift ((12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"ടാസ്ക് ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുക്കുകയും മുകളിലെ പ്രതീകങ്ങളുടെ ആകെത്തുക മാത്രം ASCII കോഡുകൾ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. ഉദാഹരണങ്ങൾ: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"ഈ ടാസ്ക്, നിങ്ങൾ ആപ്പിൾ, ഓറഞ്ച്, മാംഗോ പഴങ്ങൾ അടങ്ങുന്ന ഒരു ഫലം കൊട്ടയിൽ വിതരണം ആ ആപ്പിളും ഓറഞ്ചും ഒരു എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് ലഭിക്കും. ആപ്പിൾ, ആപ്പിൾ, മാംഗോ പഴങ്ങൾ മൊത്തം എണ്ണം പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗ് കൊടുത്തിരിക്കുന്നു കൊട്ടയിൽ പഴങ്ങൾ മൊത്തം എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ കൊട്ടയിൽ മാംഗോ പഴങ്ങൾ എണ്ണം മടങ്ങുക. ഉദാഹരണത്തിന്ഃ ഫലം_വിതരണം \"5 ആപ്പിൾ 6 ഓറഞ്ച്\", 19) -> 19 - 5 - 6 = 8 ഫലം_വിതരണം\"0 ആപ്പിൾ 1 ഓറഞ്ച്\", 3) -> 3 - 0 - 1 = 2 ഫലം_വിതരണം\"2 ആപ്പിൾ 3 ഓറഞ്ച്\", 100) -> 100 - 2 - 3 = 95 ഫലം_വിതരണം\"100 ആപ്പിൾ 1 ഓറഞ്ച്\",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"നല്ല നെഗറ്റീവ് ഇന്ററൽ നോഡുകളുള്ള ഒരു വൃക്ഷത്തിന്റെ ഒരു ശാഖയെ പ്രതിനിധീകരിക്കുന്ന ഒരു അറേ നൽകിയാൽ നിങ്ങളുടെ ചുമതല നോഡുകളിൽ ഒന്ന് പിഴുതെടുത്ത് അത് തിരികെ നൽകുക എന്നതാണ്. പിഴുതെടുത്ത നോഡ് ഏറ്റവും ചെറിയ ഇരട്ട മൂല്യമുള്ള നോഡായിരിക്കണം. ഒരേ ചെറിയ ഇരട്ട മൂല്യമുള്ള ഒന്നിലധികം നോഡുകൾ കണ്ടെത്തിയാൽ ഏറ്റവും ചെറിയ സൂചികയുള്ള നോഡ് തിരികെ നൽകുക. പിഴുതെടുത്ത നോഡ് ഒരു പട്ടികയിൽ നൽകണം, [smallest_value, അതിന്റെ സൂചിക ], ഇരട്ട മൂല്യങ്ങളില്ലെങ്കിലോ നൽകിയ അറേ ശൂന്യമാണെങ്കിലോ, മടങ്ങുക []. ഉദാഹരണം 1: ഇൻപുട്ട്ഃ [4,2,3] output: [2, 1] വിശദീകരണംഃ 2 ഏറ്റവും ചെറിയ ഇരട്ട മൂല്യവും 2 ഏറ്റവും ചെറിയ സൂചികയും ഉണ്ട്. ഉദാഹരണം 2: ഇൻപുട്ട്ഃ [1,2,3] output: [2, 1] വിശദീകരണംഃ 2 ഏറ്റവും ചെറിയ മൂല്യവും 2 ഏറ്റവും ചെറിയ സൂചികയും ഉണ്ട്. ഉദാഹരണം 3: ഇൻപുട്ട്ഃ [] output: [] input: [4: [5, 3, 4] input: [0, 2] output: 1 output: ഏറ്റവും ചെറിയ മൂല്യം ഉള്ള നോഡ്, എന്നാൽ ഏറ്റവും ചെറിയ സൂചികയുള്ള മൂല്യം 1 ആണ്, അതിനാൽ ഞങ്ങൾ ആദ്യത്തേത് തിരഞ്ഞെടുക്കുന്നു, അതിൽ രണ്ട് പൂജ്യങ്ങൾ ഉണ്ട്. ഉദാഹരണത്തിന്ഃ * 1 = 0 = 0\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''നിങ്ങൾക്ക് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ ഒരു ശൂന്യമല്ലാത്ത പട്ടിക നൽകിയിരിക്കുന്നു. പൂജ്യത്തേക്കാൾ വലുതും പൂർണ്ണസംഖ്യയുടെ മൂല്യത്തേക്കാൾ വലുതോ തുല്യമോ ആയ ഏറ്റവും വലിയ പൂർണ്ണസംഖ്യ തിരികെ നൽകുക. ഒരു പൂർണ്ണസംഖ്യയുടെ ആവൃത്തി പട്ടികയിൽ ദൃശ്യമാകുന്ന സമയങ്ങളുടെ എണ്ണമാണ്. അത്തരം മൂല്യം ഇല്ലെങ്കിൽ, -1 തിരികെ നൽകുക. ഉദാഹരണങ്ങൾ: search (([4, 1, 2, 2, 3, 1]) == 2 search ([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3 search ([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''പൂർണ്ണസംഖ്യകളുടെ പട്ടിക നൽകിയാൽ, പട്ടിക വിചിത്രമായ ക്രമത്തിൽ മടങ്ങുക. വിചിത്രമായ അടുക്കൽ, നിങ്ങൾ ഏറ്റവും കുറഞ്ഞ മൂല്യത്തോടെ ആരംഭിക്കുമ്പോൾ, ശേഷിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പരമാവധി, പിന്നെ മിനിമം തുടങ്ങിയവയാണ്. ഉദാഹരണങ്ങൾ: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''ഒരു ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങളുടെ നീളം നൽകിയിട്ടുണ്ട്. ത്രികോണത്തിന്റെ മൂലധനം 2 ദശാംശ പോയിന്റിലേക്ക് തിരിക്കുക. മൂന്നും മൂന്നും മൂന്നും മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലധനം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം മൂലകം'''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''വസ്തു q പറക്കുകയാണെങ്കിൽ True, അല്ലാത്തപക്ഷം False എന്ന് നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. വസ്തു q സന്തുലിതമാണെങ്കിൽ (ഇത് ഒരു പാലിൻഡ്രോമിക് ലിസ്റ്റാണ്) അതിന്റെ ഘടകങ്ങളുടെ ആകെത്തുക പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കുറവോ തുല്യമോ ആണെങ്കിൽ അത് പറക്കും. ഉദാഹരണം: will_it_fly (([1, 2], 5) â -> False # 1+2 പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കുറവാണ്, പക്ഷേ അത് അസന്തുലിതമാണ്. will_it_fly (([3, 2, 3], 1) â -> False # ഇത് സന്തുലിതമാണ്, പക്ഷേ 3+2+3 പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കൂടുതലാണ്. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കുറവാണ്, അത് സന്തുലിതമാണ്. will_it_fly ((([3], â 5) -> True # 3 പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കുറവാണ്, അത് സന്തുലിതമാണ്.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"ഒരു അറേയിൽ പൂർണ്ണസംഖ്യകൾ നൽകിയിട്ടുണ്ടെങ്കിൽ, അറേ പാലിൻഡ്രോമിക് ആക്കുന്നതിന് മാറ്റേണ്ട ഏറ്റവും കുറഞ്ഞ എണ്ണം ഘടകങ്ങൾ കണ്ടെത്തുക. ഒരു പാലിൻഡ്രോമിക് അറേ എന്നത് ഒരേപോലെ മുന്നോട്ടും പിന്നോട്ടും വായിക്കുന്ന ഒരു അറേയാണ്. ഒരു മാറ്റത്തിൽ, നിങ്ങൾക്ക് ഒരു ഘടകം മറ്റേതെങ്കിലും ഘടകത്തിലേക്ക് മാറ്റാൻ കഴിയും. ഉദാഹരണത്തിന്ഃ smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''രണ്ട് സ്ട്രിങ്ങുകളുടെ ലിസ്റ്റുകൾ സ്വീകരിക്കുകയും ലിസ്റ്റിലെ എല്ലാ സ്ട്രിങ്ങുകളിലും മറ്റ് ലിസ്റ്റുകളേക്കാൾ കുറവ് പ്രതീകങ്ങളുടെ എണ്ണം ഉള്ള ലിസ്റ്റ് തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. രണ്ട് ലിസ്റ്റുകൾക്കും ഒരേ എണ്ണം പ്രതീകങ്ങളുണ്ടെങ്കിൽ, ആദ്യ പട്ടിക തിരികെ നൽകുക. ഉദാഹരണങ്ങൾ total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hI', 'hi', 'hi]) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"നൽകിയിരിക്കുന്ന സംഖ്യ 3 പ്രൈം സംഖ്യകളുടെ ഗുണനമാണെങ്കിൽ ശരി എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. അല്ലാത്തപക്ഷം തെറ്റാണ്. (a) 100 ൽ കുറവാണെന്ന് അറിയുന്നത്. ഉദാഹരണം: is_multiply_prime(30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"ഒരു സംഖ്യ x n ന്റെ ഒരു ലളിതമായ പവറാണെങ്കിൽ, മറ്റ് കേസുകളിൽ തെറ്റാണെങ്കിൽ, അത് true ആയി നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക എന്നതാണ് നിങ്ങളുടെ ചുമതല. x n ന്റെ ലളിതമായ പവറാണ് n **int = x ഉദാഹരണത്തിന്: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''ഒരു പൂർണ്ണസംഖ്യ a എടുക്കുകയും ഈ ingeger ചില പൂർണ്ണസംഖ്യകളുടെ ക്യൂബ് ആണെങ്കിൽ True തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. കുറിപ്പ്ഃ ഇൻപുട്ട് എല്ലായ്പ്പോഴും സാധുവാണെന്ന് നിങ്ങൾ അനുമാനിക്കാം. ഉദാഹരണങ്ങൾ: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"ഹെക്സാഡെസിമൽ സംഖ്യകളെ ഒരു സ്ട്രിംഗായി സ്വീകരിക്കുകയും പ്രൈം സംഖ്യകളായ ഹെക്സാഡെസിമൽ അക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതാൻ നിങ്ങളോട് ആവശ്യപ്പെട്ടു (പ്രൈം നമ്പർ, അല്ലെങ്കിൽ ഒരു പ്രൈം, രണ്ട് ചെറിയ പ്രകൃതി സംഖ്യകളുടെ ഗുണിതമല്ലാത്ത 1 നേക്കാൾ വലിയ ഒരു സ്വാഭാവിക സംഖ്യയാണ്). ഹെക്സാഡെസിമൽ അക്കങ്ങൾ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. പ്രൈം നമ്പറുകൾ 2, 3, 5, 7, 11, 13, 17,... അതിനാൽ നിങ്ങൾ ഇനിപ്പറയുന്ന അക്കങ്ങളുടെ എണ്ണം നിർണ്ണയിക്കേണ്ടതുണ്ട്ഃ 2, 3, 5, 7, B (= ദശാംശ 11), D (= ദശാംശ 13). കുറിപ്പ്ഃ ഇൻപുട്ട് എല്ലായ്പ്പോഴും ശരിയോ ശൂന്യമോ ആണെന്ന് നിങ്ങൾ അനുമാനിക്കാം, കൂടാതെ ചിഹ്നങ്ങൾ A, B, C, D, E, F എല്ലായ്പോഴും വലിയ അക്ഷരങ്ങളാണ്. ഉദാഹരണങ്ങൾഃ \"num = AB\" എന്നതിന് output num = 1. \"1077E\" എന്നതിന് output = 2. \"num = AB33\" എന്നതിന് num = 1. \"num\" എന്നതിന് num = 4. \"num = A\" എന്നതിന് num = 6.0128945 \"A\" എന്നതിന് output = 2. \"num = 6.0\" എന്നതിന് output = \"2020\"\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"നിങ്ങൾക്ക് ദശാംശ രൂപത്തിലുള്ള ഒരു സംഖ്യ ലഭിക്കും. അത് ബൈനറി ഫോർമാറ്റിലേക്ക് പരിവർത്തനം ചെയ്യുക എന്നതാണ് നിങ്ങളുടെ ചുമതല. ഫംഗ്ഷൻ ഒരു സ്ട്രിംഗ് നൽകണം, ഓരോ പ്രതീകവും ഒരു ബൈനറി നമ്പറിനെ പ്രതിനിധീകരിക്കുന്നു. സ്ട്രിംഗിലെ ഓരോ പ്രതീകവും '0' അല്ലെങ്കിൽ '1' ആയിരിക്കും. സ്ട്രിംഗിന്റെ തുടക്കത്തിലും അവസാനത്തിലും ഒരു അധിക ജോഡി പ്രതീകങ്ങൾ 'db' ഉണ്ടാകും. ഫോർമാറ്റിനെ സഹായിക്കുന്നതിന് അധിക പ്രതീകങ്ങൾ അവിടെയുണ്ട്. ഉദാഹരണങ്ങൾ: decimal_to_binary(15) # \"db1111db\" decimal_to_binary32) # \"db100000db\" നൽകുന്നു\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"നിങ്ങൾക്ക് ഒരു സ്ട്രിംഗ് s നൽകിയിരിക്കുന്നു. സ്ട്രിംഗ് സന്തുഷ്ടമാണോ അല്ലയോ എന്ന് പരിശോധിക്കുക എന്നതാണ് നിങ്ങളുടെ ചുമതല. ഒരു സ്ട്രിംഗ് സന്തുഷ്ടമാണെങ്കിൽ അതിന്റെ നീളം കുറഞ്ഞത് 3 ആണെങ്കിൽ ഓരോ 3 തുടർച്ചയായ അക്ഷരങ്ങളും വ്യത്യസ്തമാണ് ഉദാഹരണത്തിന്: is_happy (a) => False is_happy (a) => False is_happy (bcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"സെമസ്റ്ററിന്റെ അവസാന ആഴ്ചയാണ്, അധ്യാപിക വിദ്യാർത്ഥികൾക്ക് ഗ്രേഡുകൾ നൽകണം. അധ്യാപിക സ്വന്തം ഗ്രേഡിംഗ് അൽഗോരിതം ഉണ്ടാക്കുകയാണ്. ഗ്രേഡിംഗിനായി ഉപയോഗിച്ച കോഡ് അവൾ നഷ്ടപ്പെടുത്തിയിരിക്കുന്നു എന്നതാണ് പ്രശ്നം. അവൾ ചില വിദ്യാർത്ഥികൾക്കുള്ള ജിപിഎകളുടെ ഒരു ലിസ്റ്റ് നിങ്ങൾക്ക് നൽകിയിട്ടുണ്ട്, ഇനിപ്പറയുന്ന പട്ടിക ഉപയോഗിച്ച് അക്ഷര ഗ്രേഡുകളുടെ ഒരു ലിസ്റ്റ് output ട്ട്പുട്ട് ചെയ്യാൻ കഴിയുന്ന ഒരു ഫംഗ്ഷൻ നിങ്ങൾ എഴുതണംഃ ജിപിഎ  ലെറ്റർ ഗ്രേഡ് 4.0 എ + > 3.7 എ > 3.3 എ- > 3.0 ബി + > 2.7 ബി > 2.3 ബി- > 2.3 ബി + > 2.0 സി + > 1.7 സി > 1.3 സി- > 1.0 ഡി + > 0.7 ഡി > 0.0 ഡി- 0.0 ഇഃ ഗ്രേഡ്_ സമവാക്യം ഉദാഹരണം (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"ഒരു സ്ട്രിംഗ് എടുക്കുകയും സ്ട്രിംഗ് ദൈർഘ്യം ഒരു പ്രൈം നമ്പർ ആണെങ്കിൽ True അല്ലെങ്കിൽ False എന്ന് നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക ഉദാഹരണങ്ങൾ prime_length (('ഹലോ') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('ഓറഞ്ച്') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"ഒരു പോസിറ്റീവ് ഇന്റഗ്രൽ n കൊടുത്താൽ, 1 കൊണ്ട് തുടങ്ങുന്നതോ അവസാനിക്കുന്നതോ ആയ n- അക്ക പോസിറ്റീവ് ഇന്റഗ്രൽ സംഖ്യകളുടെ എണ്ണം തിരികെ നൽകുക.\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ N നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിന്റെ അക്കങ്ങളുടെ ആകെ തുക ബൈനറിയിൽ നൽകുക. ഉദാഹരണം N = 1000 ന്, അക്കങ്ങളുടെ ആകെത്തുക 1 ആയിരിക്കും, ഔട്ട്പുട്ട് \"1\" ആയിരിക്കണം. N = 150 ന്, അക്കങ്ങളുടെ ആകെത്തുക 6 ആയിരിക്കും, ഔട്ട്പുട്ട് \"110\" ആയിരിക്കണം. N = 147 ന്, അക്കങ്ങളുടെ ആകെത്തുക 12 ആയിരിക്കും, ഔട്ട്പുട്ട് \"1100\" ആയിരിക്കണം. വേരിയബിളുകൾ: @N പൂർണ്ണസംഖ്യ നിയന്ത്രണങ്ങൾഃ 0 â‰¤ N â‰¤ 10000. ഔട്ട്പുട്ട്ഃ ബൈനറി സംഖ്യകളുടെ ഒരു സ്ട്രിംഗ് \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"പൂർണ്ണസംഖ്യകളുടെ ഒരു ശൂന്യമല്ലാത്ത പട്ടിക നൽകിയിരിക്കുമ്പോൾ ആദ്യം, അപൂർവ സൂചികകളിലുള്ള ഇരട്ട മൂലകങ്ങൾ ചേർക്കുക. ഉദാഹരണങ്ങൾഃ ചേർക്കുക ([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"ഒരു സ്ട്രിംഗ് എടുത്ത് അതിന്റെ ക്രമീകരിച്ച പതിപ്പ് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. എല്ലാ വാക്കുകളും (സ്പെയ്സ് ഉപയോഗിച്ച് വേർതിരിച്ച്) ഒരു പുതിയ വാക്ക് ഉപയോഗിച്ച് മാറ്റിസ്ഥാപിക്കുന്ന ഒരു സ്ട്രിംഗാണ് സ്ട്രിംഗിന്റെ ക്രമീകരിച്ച പതിപ്പ്. ശ്രദ്ധിക്കുകഃ വാക്യത്തിലെ എല്ലാ പ്രതീകങ്ങളും വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നു. ഉദാഹരണത്തിന്ഃ anti_shuffle ((('Hi') 'Hi' anti_shuffle (('hello') 'ehllo' anti_shuffle (('Hello World!!!') 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"നിങ്ങൾക്ക് ഒരു 2 ഡൈമൻഷണൽ ഡാറ്റ നൽകിയിരിക്കുന്നു, ഒരു നെസ്റ്റഡ് ലിസ്റ്റുകൾ, ഇത് മാട്രിക്സിന് സമാനമാണ്, എന്നിരുന്നാലും, മാട്രിക്സുകളിൽ നിന്ന് വ്യത്യസ്തമായി, ഓരോ വരിയിലും വ്യത്യസ്ത എണ്ണം നിരകൾ അടങ്ങിയിരിക്കാം. lst, ഇന്റീജർ x എന്നിവ നൽകിയിട്ടുണ്ടെങ്കിൽ, പട്ടികയിൽ പൂർണ്ണസംഖ്യ x കണ്ടെത്തുക, കൂടാതെ ട്യൂപ്പുകളുടെ പട്ടിക തിരികെ നൽകുക, [(x1, y1), (x2, y2) ...] ഓരോ ടപ്പലും ഒരു കോർഡിനേറ്റാണ് - (വരി, നിരകൾ), 0 മുതൽ ആരംഭിക്കുന്നു. തുടക്കത്തിൽ നിരകൾ ക്രമത്തിൽ ക്രമീകരിക്കുക. കൂടാതെ, നിരയുടെ കോർഡിനേറ്റുകൾ നിരകളുടെ ക്രമത്തിൽ ക്രമീകരിക്കുക. ഉദാഹരണങ്ങൾഃ get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0, 0, 0, 0, 1, 4], 0 (1, 4), (2, 5), (2, 0, 0] get_(1), [] == [_row [1], [1, 3, 2, 2], [2, 3] ]]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യകളുടെ അറേ നൽകിയിട്ടുണ്ടെങ്കിൽ, ക്രമീകരണത്തിനുശേഷം നൽകിയിരിക്കുന്ന അറേയുടെ ഒരു പകർപ്പ് തിരികെ നൽകുക, തുക ((ആദ്യ സൂചിക മൂല്യം, അവസാന സൂചിക മൂല്യം) ഒറ്റയടിക്ക് ആണെങ്കിൽ നൽകിയ അറേ ക്രമീകരിക്കും, അല്ലെങ്കിൽ തുക ((ആദ്യ സൂചിക മൂല്യം, അവസാന സൂചിക മൂല്യം) ആണെങ്കിൽ അത് താഴേയ്ക്ക് ക്രമീകരിക്കും. കുറിപ്പ്ഃ * നൽകിയ അറേ മാറ്റരുത്. ഉദാഹരണങ്ങൾഃ * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"ഒരു സ്ട്രിംഗ് ഒരു ആർഗ്യുമെന്റായി എടുക്കുകയും അക്ഷരമാല തിരിക്കുകയും ചെയ്ത ഒരു സ്ട്രിംഗ് എൻക്രിപ്റ്റ് ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എൻക്രിപ്റ്റ് സൃഷ്ടിക്കുക. അക്ഷരമാലകൾ രണ്ട് സ്ഥലങ്ങളിലേക്ക് രണ്ട് തവണ താഴേക്ക് നീങ്ങുന്ന തരത്തിൽ തിരിക്കണം. ഉദാഹരണത്തിന്: encrypt('hi') 'lm' encrypt('asdfghjkl') 'ewhjklnop' encrypt('gf') 'kj' encrypt('et') 'ix' നൽകുന്നു\"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"നിങ്ങൾക്ക് ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക നൽകിയിരിക്കുന്നു. പട്ടികയിലെ രണ്ടാമത്തെ ഏറ്റവും ചെറിയ മൂലകം തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ next_smallest () എഴുതുക. അത്തരം ഒരു മൂലകം ഇല്ലെങ്കിൽ None തിരികെ നൽകുക. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == None next_smallest () [1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"നിങ്ങൾക്ക് ഒരു വാക്ക് സ്ട്രിംഗ് നൽകും, നിങ്ങളുടെ ചുമതല വിരസതകളുടെ എണ്ണം കണക്കാക്കുക എന്നതാണ്. \"ഞാൻ\" എന്ന വാക്കിൽ ആരംഭിക്കുന്ന ഒരു വാക്യമാണ് വിരസത. വാക്യങ്ങൾ '.', '? അല്ലെങ്കിൽ '! ' ഉപയോഗിച്ച് വേർതിരിക്കുന്നു. ഉദാഹരണത്തിന്ഃ >>> is_bored(\"ഹലോ വേൾഡ്\") 0 >>> is_bored(\"ആകാശം നീലയാണ്. സൂര്യൻ പ്രകാശിക്കുന്നു. ഞാൻ ഈ കാലാവസ്ഥയെ സ്നേഹിക്കുന്നു\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''3 സംഖ്യകൾ എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക. സംഖ്യകളിൽ ഒന്ന് മറ്റേ രണ്ടിന്റെയും ആകെത്തുകയ്ക്ക് തുല്യമാണെങ്കിൽ ശരിയായി നൽകുന്നു, എല്ലാ സംഖ്യകളും പൂർണ്ണസംഖ്യകളാണ്. മറ്റെല്ലാ സാഹചര്യങ്ങളിലും തെറ്റായി നൽകുന്നു. ഉദാഹരണങ്ങൾ any_int{5, 2, 7} -> True any_int{3, 2, 2}) -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"ഒരു സന്ദേശം എടുക്കുകയും, എല്ലാ അക്ഷരങ്ങളുടെയും കേസ് സ്വാപ്പ് ചെയ്യുകയും, സന്ദേശത്തിലെ എല്ലാ സ്വരാക്ഷരങ്ങളും ഇംഗ്ലീഷ് അക്ഷരമാലയിലെ ആ സ്വരാക്ഷരത്തിന് 2 സ്ഥാനങ്ങൾ മുന്നിലുള്ള അക്ഷരത്താൽ മാറ്റിസ്ഥാപിക്കുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. അക്ഷരങ്ങൾ മാത്രം കരുതുക. ഉദാഹരണങ്ങൾ: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"നിങ്ങൾക്ക് ഒരു സംഖ്യകളുടെ പട്ടിക ലഭിക്കുന്നു. നിങ്ങൾ ഏറ്റവും വലിയ പ്രൈം മൂല്യം കണ്ടെത്തി അതിന്റെ അക്കങ്ങളുടെ സംഖ്യ തിരികെ നൽകണം. ഉദാഹരണങ്ങൾ: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ഔട്ട്പുട്ട് 10 ആയിരിക്കണം lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ഔട്ട്പുട്ട് 25 ആയിരിക്കണം lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ഔട്ട്പുട്ട് 13 ആയിരിക്കണം lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ഔട്ട്പുട്ട് 11 ആയിരിക്കണം lst = [0,81,12,31,21] ഔട്ട്പുട്ട് 3 ആയിരിക്കണം lst = [0,1,8,1,2,7] ഔട്ട്പുട്ട് 7 ആയിരിക്കണം \"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"ഒരു നിഘണ്ടു നൽകിയിട്ടുണ്ടെങ്കിൽ, എല്ലാ കീകളും ചെറിയക്ഷരങ്ങളോ എല്ലാ കീകളും വലിയക്ഷരങ്ങളോ ആണെങ്കിൽ True തിരികെ നൽകുക, അല്ലെങ്കിൽ False തിരികെ നൽകുക. ഫംഗ്ഷൻ False തിരികെ നൽകണം. തന്നിരിക്കുന്ന നിഘണ്ടു ശൂന്യമാണ്. ഉദാഹരണങ്ങൾ: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) True തിരികെ നൽകണം. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) False തിരികെ നൽകണം. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) False തിരികെ നൽകണം. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False തിരികെ നൽകണം. check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"12345}) True തിരികെ നൽകണം.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"ഒരു നോൺ-നെഗറ്റീവ് ഇന്റഗ്രൽ എടുത്ത്, പ്രൈം നമ്പറുകളായ n ൽ കുറവുള്ള ആദ്യത്തെ n ഇന്റഗ്രലുകളുടെ ഒരു അറേ മടക്കിനൽകുന്ന ഒരു ഫംഗ്ഷൻ നടപ്പിലാക്കുക. ഉദാഹരണത്തിന്: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"രണ്ട് പൂർണ്ണസംഖ്യകളെ എടുത്ത് അവയുടെ യൂണിറ്റ് അക്കങ്ങളുടെ ഗുണിതം നൽകുന്ന ഫംഗ്ഷൻ പൂർത്തിയാക്കുക. ഇൻപുട്ട് എല്ലായ്പ്പോഴും സാധുവാണെന്ന് കരുതുക. ഉദാഹരണങ്ങൾ: ഗുണനം ((148, 412) 16 മടക്കിനൽകണം. ഗുണനം ((19, 28) 72. ഗുണനം ((2020, 1851) 0 മടക്കിനൽകണം. ഗുണനം ((14,-15) 20 മടക്കിനൽകണം. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"ഒരു സ്ട്രിംഗ് s നൽകിയിട്ടുണ്ടെങ്കിൽ, ഇരട്ട സൂചികകളിലെ വലിയ അക്ഷര സ്വരാക്ഷരങ്ങളുടെ എണ്ണം കണക്കാക്കുക. ഉദാഹരണത്തിന്: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 നൽകുന്നു \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''ഒരു സംഖ്യയെ പ്രതിനിധീകരിക്കുന്ന ഒരു മൂല്യം (സ്ട്രിംഗ്) എടുക്കുകയും അതിന് ഏറ്റവും അടുത്തുള്ള പൂർണ്ണസംഖ്യ തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക. രണ്ട് പൂർണ്ണസംഖ്യകളിൽ നിന്ന് സംഖ്യ തുല്യമാണെങ്കിൽ, അത് പൂജ്യത്തിൽ നിന്ന് ചുറ്റിപ്പിടിക്കുക. ഉദാഹരണങ്ങൾ >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 കുറിപ്പ്: പൂജ്യത്തിൽ നിന്ന് ചുറ്റിപ്പിടിക്കുന്നത് അർത്ഥമാക്കുന്നത് രണ്ട് പൂർണ്ണസംഖ്യകളിൽ നിന്ന് തന്നിരിക്കുന്ന സംഖ്യ തുല്യമാണെങ്കിൽ, നിങ്ങൾ മടക്കിനൽകേണ്ടത് പൂജ്യത്തിൽ നിന്ന് ഏറ്റവും അകലെയുള്ള ഒന്നാണ്. ഉദാഹരണത്തിന് closest_integer \" ((14.5\") 15 ഉം closest_integer \" ((-14.5\") ഉം -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, നിങ്ങൾ n ലെവൽ കല്ലുകൾ ഒരു കൂമ്പാരം ഉണ്ടാക്കണം. ആദ്യ ലെവലിൽ n കല്ലുകൾ ഉണ്ട്. അടുത്ത ലെവലിലെ കല്ലുകളുടെ എണ്ണം ഇതാണ്: - n വിചിത്രമാണെങ്കിൽ അടുത്ത ഇരട്ട സംഖ്യ. - n ഇരട്ട ആണെങ്കിൽ അടുത്ത ഇരട്ട സംഖ്യ. ഒരു ലിസ്റ്റിലെ ഓരോ ലെവലിലെയും കല്ലുകളുടെ എണ്ണം നൽകുക, അവിടെ സൂചികയിലെ ഘടകം i ലെവലിലെ കല്ലുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്നു (i + 1). ഉദാഹരണങ്ങൾ: >>> make_a_pile (i + 1) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"നിങ്ങൾക്ക് കോമകളോ സ്പെയ്സുകളോ ഉപയോഗിച്ച് വേർതിരിക്കുന്ന ഒരു സ്ട്രിംഗ് വാക്കുകൾ നൽകും. നിങ്ങളുടെ ചുമതല സ്ട്രിംഗ് വാക്കുകളായി വിഭജിച്ച് വാക്കുകളുടെ ഒരു അറേ തിരികെ നൽകുക എന്നതാണ്. ഉദാഹരണത്തിന്: words_string ((\"ഹായ്, എന്റെ പേര് ജോൺ\") == [\"ഹായ്\", \"എന്റെ\", \"പേര്\", \"is\", \"ജോൺ\"] words_string ((\"ഒന്ന്, രണ്ട്, മൂന്ന്, നാല്, അഞ്ച്, ആറ്\") == [\"ഒന്ന്\", \"രണ്ട്\", \"മൂന്ന്\", \"നാല്\", \"അഞ്ച്\", \"ആറ്\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"ഈ ഫംഗ്ഷൻ രണ്ട് പോസിറ്റീവ് നമ്പറുകളായ x, y എന്നിവ എടുക്കുകയും [x, y] പരിധിയിലുള്ള ഏറ്റവും വലിയ ഇരട്ട സംഖ്യ തിരികെ നൽകുകയും ചെയ്യുന്നു. അത്തരം ഒരു സംഖ്യ ഇല്ലെങ്കിൽ, ഫംഗ്ഷൻ -1 നൽകണം. ഉദാഹരണത്തിന്: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"നിങ്ങൾക്ക് രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായ n, m എന്നിവ നൽകിയിട്ടുണ്ട്, നിങ്ങളുടെ ചുമതല n മുതൽ m വരെയുള്ള (n, m ഉൾപ്പെടെ) പൂർണ്ണസംഖ്യകളുടെ ശരാശരി കണക്കാക്കുക എന്നതാണ്. ഉത്തരം ഏറ്റവും അടുത്തുള്ള പൂർണ്ണസംഖ്യയിലേക്ക് ചുറ്റിപ്പിടിക്കുക, അത് ബൈനറി ആയി പരിവർത്തനം ചെയ്യുക. n m നേക്കാൾ വലുതാണെങ്കിൽ, -1. മടക്കുക. ഉദാഹരണംഃ rounded_avg(1, 5) => \"0b11\" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => \"0b1111\" rounded_avg(20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"പോസിറ്റീവ് സംഖ്യകളുടെ ഒരു പട്ടിക x. എല്ലാ ഘടകങ്ങളുടെയും ഒരു അടുക്കിയ പട്ടിക മടക്കി നൽകുക. അതിൽ ഒരു സംഖ്യയും ഇല്ല. കുറിപ്പ്: മടക്കിയ പട്ടിക വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ അടുക്കണം. ഉദാഹരണത്തിന്: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"ഒരു അറേയിൽ 1 മുതൽ 9 വരെയുള്ള സംഖ്യകൾ ക്രമീകരിക്കുക, ഫലമായി ലഭിക്കുന്ന അറേ റിവേഴ്സ് ചെയ്യുക, തുടർന്ന് ഓരോ അക്കവും \"ഒന്ന്\", \"രണ്ട്\", \"മൂന്ന്\", \"നാല്\", \"അഞ്ച്\", \"ആറ്\", \"ഏഴ്\", \"എട്ട്\", \"ഒൻപത്\" എന്നതിൽ നിന്ന് അതിന്റെ അനുബന്ധ നാമം ഉപയോഗിച്ച് മാറ്റിസ്ഥാപിക്കുക. ഉദാഹരണത്തിന്: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"എട്ട്\", \"അഞ്ച്\", \"മൂന്ന്\", \"രണ്ട്\", \"രണ്ട്\", \"രണ്ട്\", \"ഒന്ന്\", \"ഒന്ന്\"] അറേ ശൂന്യമാണെങ്കിൽ, ഒരു ശൂന്യമായ അറേ നൽകുക: arr = [] return [] അറേയിൽ ഏതെങ്കിലും വിചിത്ര സംഖ്യ ഉണ്ടെങ്കിൽ അത് അവഗണിക്കുക: arr = [1, -1 , 55] -> arr -> [1, 55] -> reverse arr = [51] return - 'One' 1 \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"n നെ ഒരു പാരാമീറ്ററായി എടുക്കുകയും, n വലുപ്പമുള്ള ഒരു പട്ടിക നൽകുകയും ചെയ്യുന്ന f ഫംഗ്ഷൻ നടപ്പിലാക്കുക, i സൂചികയിലെ മൂല്യം i യുടെ ഫാക്ടോറിയൽ ആണെങ്കിൽ i ഇരട്ടയോ അല്ലെങ്കിൽ 1 മുതൽ i വരെയുള്ള സംഖ്യകളുടെ ആകെത്തുകയാണോ. i 1 മുതൽ ആരംഭിക്കുന്നു. i യുടെ ഫാക്ടോറിയൽ 1 മുതൽ i വരെയുള്ള സംഖ്യകളുടെ ഗുണനമാണ് (1 * 2 * . . . * i). ഉദാഹരണം: f ((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, പരിധിയിൽ വരുന്ന പാര, പാര ഇംതെർ പാലിൻഡ്രോമുകളുടെ എണ്ണം അടങ്ങിയ ഒരു ടപ്പിൾ നൽകുക. ഉദാഹരണം 1: ഇൻപുട്ട്ഃ 3 ഔട്ട്പുട്ട്ഃ (1, 2) വിശദീകരണം: ഇന്റീജർ പാലിൻഡ്രോം 1, 2, 3. അവയിൽ ഒന്ന് പാരും രണ്ടെണ്ണം പാരും ആണ്. ഉദാഹരണം 2: ഇൻപുട്ട്ഃ 12 ഔട്ട്പുട്ട്ഃ (4, 6) വിശദീകരണം: ഇന്റീജർ പാലിൻഡ്രോം 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. അവയിൽ നാല് പാരും 6 പാരും ആണ്. കുറിപ്പ്ഃ 1. 1 <= n <= 10^3 2. ടപ്പിൾ യഥാക്രമം പാര, പാര ഇംതെർ പാലിൻഡ്രോമുകളുടെ എണ്ണം നൽകി. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"ഒരു സംഖ്യ നെഗറ്റീവ് ആണെങ്കിൽ, അതിന്റെ ആദ്യത്തെ ഒപ്പിട്ട അക്കം നെഗറ്റീവ് ആയിരിക്കും: ഉദാഹരണത്തിന് -123 ന് -1, 2, 3 എന്നീ അക്കം ഉണ്ടായിരിക്കും.\"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"N പൂർണ്ണസംഖ്യകളുടെ ഒരു ശ്രേണി 'arr' നമുക്കുണ്ട് arr[1], arr[2], ..., arr[N]. ശ്രേണിയിലെ സംഖ്യകൾ ക്രമരഹിതമായി ക്രമീകരിക്കും. നൽകിയിരിക്കുന്ന ശ്രേണിയിൽ ഇനിപ്പറയുന്ന പ്രവർത്തനം നടത്തുന്നതിലൂടെ ഒരു ശ്രേണി ക്രമീകരിക്കാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുക എന്നതാണ് നിങ്ങളുടെ ചുമതല: നിങ്ങൾക്ക് എത്ര തവണ വേണമെങ്കിലും വലത്തേക്ക് നീങ്ങാൻ കഴിയും. ഒരു വലത്തേക്ക് നീങ്ങുന്ന പ്രവർത്തനം അർത്ഥമാക്കുന്നത് ശ്രേണിയിലെ എല്ലാ ഘടകങ്ങളും വലതുവശത്ത് ഒരു സ്ഥാനം മാറ്റുക എന്നാണ്. ശ്രേണിയിലെ അവസാന ഘടകം ശ്രേണിയിലെ ആരംഭ സ്ഥാനത്തേക്ക് നീങ്ങും, അതായത് 0th സൂചിക. മുകളിൽ പറഞ്ഞ പ്രവർത്തനം നടത്തുന്നതിലൂടെ ക്രമീകരിച്ച ശ്രേണി നേടാൻ കഴിയുമെങ്കിൽ True തിരികെ നൽകുക അല്ലെങ്കിൽ False തിരികെ നൽകുക. നൽകിയിരിക്കുന്ന ശ്രേണി ശൂന്യമാണെങ്കിൽ True തിരികെ നൽകുക. കുറിപ്പ്ഃ നൽകിയിരിക്കുന്ന പട്ടികയിൽ അദ്വിതീയ ഘടകങ്ങൾ ഉണ്ടെന്ന് ഉറപ്പുനൽകുന്നു. ഉദാഹരണത്തിന്ഃ move_one_(ball[3, 4, 5, 1]=== True വിശദീകരണംഃ നൽകിയിരിക്കുന്ന ശ്രേണിയിലെ വലതുവശത്തേക്ക് നീങ്ങാത്ത ക്രമത്തിൽ ഒരു ശ്രേണി ക്രമത്തിൽ ക്രമീകരിക്കാൻ നിങ്ങൾക്ക് അനുവാദമുണ്ട്. ഒരു വലതുവശൂന്ന നീക്ക പ്രവർത്തനം പ്രവർത്തനം നടത്താൻ നിങ്ങൾക്ക് അനുവാദമുണ്ട്. ഒരു വലതുവശേണിയിലെ എല്ലാ ഘടകങ്ങളും ഒരു സ്ഥാനം മാറ്റുക, അതായത് 0th സൂചെയ്താൽ ശ്രേണിയുടെ അവസാന ഘടകം 0th, മുകളിലേക്ക് നീങ്ങുന്നു, മുകളിലേക്ക് നീങ്ങുന്നു. മുകളിലെ അവസാന ഘടകം True, True, True, True, false, True, false, false, false, false, false എന്നിവ ക്രമം, false എന്നിവ ക്രമം, false എന്നിവ ക്രമം എന്നിവ ക്രമത്തിൽ ക്രമപ്പെടുത്തുന്നു.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"ഈ പ്രശ്നത്തിൽ, നിങ്ങൾ രണ്ട് സംഖ്യകളുടെ പട്ടിക എടുക്കുകയും അവയ്ക്കിടയിൽ ഒരു എക്സ്ചേഞ്ച് നടത്താൻ സാധിക്കുമോ എന്ന് നിർണ്ണയിക്കുകയും ചെയ്യും. lst1 എന്നത് ഇരട്ട സംഖ്യകളുടെ പട്ടികയാക്കുക. lst1 നും lst2 നും ഇടയിൽ കൈമാറ്റം ചെയ്യപ്പെടുന്ന ഘടകങ്ങളുടെ എണ്ണത്തിന് പരിധിയില്ല. lst1 ന്റെ എല്ലാ ഘടകങ്ങളും ഇരട്ടയാക്കുന്നതിന് lst1 നും lst2 നും ഇടയിൽ ഘടകങ്ങൾ കൈമാറ്റം ചെയ്യാൻ കഴിയുമെങ്കിൽ, \"YES\" എന്ന് നൽകുക. അല്ലെങ്കിൽ, \"NO\" എന്ന് നൽകുക. ഉദാഹരണത്തിന്: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" ഇൻപുട്ട് ലിസ്റ്റുകൾ ശൂന്യമല്ലെന്ന് കരുതപ്പെടുന്നു.\"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"സ്പെയ്സ് വേർതിരിച്ച ചെറിയ അക്ഷരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് നൽകിയിട്ടുണ്ടെങ്കിൽ, ഏറ്റവും കൂടുതൽ ആവർത്തനമുള്ള അക്ഷരത്തിന്റെ ഒരു നിഘണ്ടു തിരികെ നൽകുക. നിരവധി അക്ഷരങ്ങൾ ഒരേ സംഭവമുണ്ടെങ്കിൽ അവയെല്ലാം തിരികെ നൽകുക. ഉദാഹരണംഃ ഹിസ്റ്റോഗ്രാം (('a b c') == {'a': 1, 'b': 1, 'c': 1} ഹിസ്റ്റോഗ്രാം (('a b b a') == {'a': 2, 'b': 2} ഹിസ്റ്റോഗ്രാം (('a b c a b') == {'a': 2, 'b': 2} ഹിസ്റ്റോഗ്രാം (('b b a b') == {'b 4}': ഹിസ്റ്റോഗ്രാം (('a') == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"ടാസ്ക് നമുക്ക് രണ്ട് സ്ട്രിങ്ങുകൾ s, c എന്നിവ നൽകിയിരിക്കുന്നു, s ലെ ഏതെങ്കിലും പ്രതീകത്തിന് തുല്യമായ എല്ലാ പ്രതീകങ്ങളും നിങ്ങൾ ഇല്ലാതാക്കണം, തുടർന്ന് ഫല സ്ട്രിംഗ് പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുക. ഒരു സ്ട്രിംഗ് മുന്നോട്ട് പോലെ പിന്നോട്ട് വായിക്കുകയാണെങ്കിൽ അതിനെ പാലിൻഡ്രോം എന്ന് വിളിക്കുന്നു. ഫല സ്ട്രിംഗും True/False ഉം അടങ്ങിയ ഒരു ടപ്പിൾ നിങ്ങൾ പരിശോധനയ്ക്കായി നൽകണം. ഉദാഹരണം s = \"abcde\", c = \"ae\", ഫലം ('bcd', False) ആയിരിക്കണം s = \"abcdef\", c = \"b\" ഫലം ('acdef', False) ആയിരിക്കണം s = \"abcdedcba\", c = \"ab\", ഫലം ('cdedc', True) ആയിരിക്കണം\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"ഓരോ സ്ട്രിങ്ങും അക്കങ്ങൾ മാത്രമുള്ള സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റ് നൽകിയാൽ, ഒരു ലിസ്റ്റ് നൽകുക. ഔട്ട്പുട്ടിന്റെ ഓരോ ഘടകവും i എന്നത് \"ഇൻപുട്ടിന്റെ സ്ട്രിംഗ് i ലെ ഒറ്റപ്പെട്ട ഘടകങ്ങളുടെ എണ്ണം\" ആയിരിക്കണം. അവിടെ എല്ലാ i കളും ഇൻപുട്ടിന്റെ i-ആം സ്ട്രിംഗിലെ ഒറ്റപ്പെട്ട അക്കങ്ങളുടെ എണ്ണം ഉപയോഗിച്ച് മാറ്റിസ്ഥാപിക്കണം. >>> odd_count['1234567']) [\"odd_elements 4n the str4ng 4 of the 4nput.\"] >>> odd_count['3',\"11111111\"]) [\"odd_elements 1n the str1ng 1 of the 1nput. \", \"odd elements 8n the str8ng 8 of the 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"ഒരു അറേയിൽ പൂർണ്ണസംഖ്യകൾ n ഉണ്ടെങ്കിൽ, n ന്റെ ഏതെങ്കിലും ശൂന്യമല്ലാത്ത ഉപ-അറേയുടെ ഏറ്റവും കുറഞ്ഞ തുക കണ്ടെത്തുക. ഉദാഹരണം minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"നിങ്ങൾക്ക് കിണറുകളുടെ ഒരു ചതുരാകൃതിയിലുള്ള ഗ്രിഡ് നൽകിയിരിക്കുന്നു. ഓരോ വരിയും ഒരു കിണറിനെ പ്രതിനിധീകരിക്കുന്നു, ഓരോ വരിയിലും 1 ഒരു യൂണിറ്റ് വെള്ളത്തെ പ്രതിനിധീകരിക്കുന്നു. ഓരോ കിണറിനും അതിൽ നിന്ന് വെള്ളം വേർതിരിച്ചെടുക്കാൻ ഉപയോഗിക്കാവുന്ന ഒരു ബക്കറ്റ് ഉണ്ട്, എല്ലാ ബക്കറ്റുകളും ഒരേ ശേഷിയുള്ളവയാണ്. നിങ്ങളുടെ ചുമതല കിണറുകൾ ശൂന്യമാക്കാൻ ബക്കറ്റുകൾ ഉപയോഗിക്കുക എന്നതാണ്. ബക്കറ്റുകൾ താഴ്ത്താൻ ആവശ്യമായ തവണ എണ്ണം output ട്ട്പുട്ട് ചെയ്യുക. ഉദാഹരണം 1: ഇൻപുട്ട്ഃ ഗ്രിഡ്ഃ [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 output: 6 Example 2: ഇൻപുട്ട്ഃ ഗ്രിഡ്ഃ [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 output: 5 Example: Input: [[0,0,0], [0,0,0]] bucket_capacity: 5 output: 0 * constraints: 1 * output: 1 * all the lengths of the buckets are <= 10 * * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 2 * 2 * 2 * 3 * 2 * 2 * 3 * 2 * 2 * 3 * 4 * 4 * 4 * 5 * 5 * 6 * 6 * 6 * 6 * 7 * 7 * 7 * 7 * 7 * 7 * 9 * 9 * 9 * 9 * 9 * 9 * 10 * 10 * 10 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 11 * 12 * 11 * 11 * 12 * 11 * 11 * 12 * 11 * 12 * 12 * 11 * 11 * 12 * 12 * 12 * 12 * 12 * 12 * 12 * 12 * 12 * 13 * 13 * 13 * 13 * 13 * 13 * 13 * 13 * 13 * 13 *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"ഈ കത്തയിൽ, ബൈനറി പ്രാതിനിധ്യത്തിലെ ഒന്നുകളുടെ എണ്ണം അനുസരിച്ച് ഒരു നെഗറ്റീവ് അല്ലാത്ത സംഖ്യകളുടെ ഒരു ശ്രേണി വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ അടുക്കണം. സമാനമായ എണ്ണം ഒന്നുകളുടെ ദശാംശ മൂല്യത്തെ അടിസ്ഥാനമാക്കി അടുക്കുക. ഇത് ഇതുപോലെ നടപ്പിലാക്കണംഃ >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"ഒരു സ്ട്രിംഗ് s ഉം ഒരു സ്വാഭാവിക സംഖ്യ n ഉം നൽകിയിട്ടുണ്ടെങ്കിൽ, ഈ വാക്കുകൾ സ്ട്രിംഗ് s ൽ പ്രത്യക്ഷപ്പെടുന്നതിന് കൃത്യമായി n സ്വരാക്ഷരങ്ങൾ അടങ്ങിയിരിക്കുന്ന സ്ട്രിംഗ് s യിൽ നിന്നുള്ള എല്ലാ വാക്കുകളുടെയും ഒരു ലിസ്റ്റ് നൽകുന്ന ഒരു ഫംഗ്ഷൻ നടപ്പിലാക്കാൻ നിങ്ങളെ ചുമതലപ്പെടുത്തിയിട്ടുണ്ട്. സ്ട്രിംഗ് s ശൂന്യമാണെങ്കിൽ ഫംഗ്ഷൻ ഒരു ശൂന്യമായ ലിസ്റ്റ് നൽകണം. കുറിപ്പ്ഃ ഇൻപുട്ട് സ്ട്രിംഗിൽ അക്ഷരങ്ങളും സ്പെയ്സുകളും മാത്രമേ ഉള്ളൂവെന്ന് നിങ്ങൾ അനുമാനിക്കാം. ഉദാഹരണങ്ങൾഃ select_words \"മറിയയ്ക്ക് ഒരു ചെറിയ ആട്ടിൻകുട്ടി ഉണ്ടായിരുന്നു\", 4) ==> [\"little\"] select_words \"മറിയയ്ക്ക് ഒരു ചെറിയ ആട്ടിൻകുട്ടി ഉണ്ടായിരുന്നു\", 3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\", 2) ==> [] select_words \"ഹലോ വേൾഡ്\", 4) ==> [\"world\"] select_words \"അങ്കിൾ സാം\", 3) ==> [\"Uncle\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"നിങ്ങൾക്ക് ഒരു വാക്ക് നൽകിയിരിക്കുന്നു. നിങ്ങളുടെ ചുമതല വാക്കിന്റെ വലതുവശത്ത് നിന്ന് രണ്ട് സ്വരാക്ഷരങ്ങൾക്കിടയിൽ നിൽക്കുന്ന ഏറ്റവും അടുത്ത സ്വരാക്ഷരം കണ്ടെത്തുക എന്നതാണ് (കേസ് സെൻസിറ്റീവ്). തുടക്കത്തിലും അവസാനത്തിലും ഉള്ള സ്വരാക്ഷരങ്ങൾ കണക്കാക്കില്ല. മുകളിലുള്ള വ്യവസ്ഥ പാലിക്കുന്ന ഒരു സ്വരാക്ഷരവും കണ്ടെത്തിയില്ലെങ്കിൽ ശൂന്യമായ സ്ട്രിംഗ് മടക്കുക. തന്നിരിക്കുന്ന സ്ട്രിംഗിൽ ഇംഗ്ലീഷ് അക്ഷരം മാത്രമേ ഉള്ളൂവെന്ന് നിങ്ങൾ അനുമാനിക്കാം. ഉദാഹരണംഃ get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"UULL\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''നിങ്ങൾക്ക് രണ്ട് സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റ് നൽകിയിരിക്കുന്നു, രണ്ട് സ്ട്രിങ്ങുകളും തുറന്ന പരാൻതീസിസ് '(' അല്ലെങ്കിൽ അടച്ച പരാൻതീസിസ് ') ' മാത്രമാണ്. രണ്ട് സ്ട്രിങ്ങുകളും ഏതെങ്കിലും ക്രമത്തിൽ ബന്ധിപ്പിക്കാൻ കഴിയുമോ എന്ന് പരിശോധിക്കുക എന്നതാണ് നിങ്ങളുടെ ജോലി, തത്ഫലമായുണ്ടാകുന്ന സ്ട്രിംഗ് നല്ലതായിരിക്കും. എസ് ലെ എല്ലാ പരാൻതീസിസുകളും സന്തുലിതമാണെങ്കിൽ മാത്രമേ ഒരു സ്ട്രിംഗ് എസ് നല്ലതായി കണക്കാക്കൂ. ഉദാഹരണത്തിന്ഃ സ്ട്രിംഗ് '((()) ' നല്ലതാണെങ്കിലും സ്ട്രിംഗ് '()) ' അല്ല. ഒരു നല്ല സ്ട്രിംഗ് നിർമ്മിക്കാൻ ഒരു മാർഗമുണ്ടെങ്കിൽ 'അതെ' എന്ന് മടങ്ങുക, അല്ലാത്തപക്ഷം 'ഇല്ല' എന്ന് മടങ്ങുക. ഉദാഹരണങ്ങൾഃ match_parens[('() ', ') ']) == 'അതെ' match_parens[(']) == 'ഇല്ല' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"ഒരു ശ്രേണി arr എന്ന സംഖ്യയും ഒരു നല്ല സംഖ്യ k ഉം നൽകിയിട്ടുണ്ടെങ്കിൽ, arr ലെ പരമാവധി k സംഖ്യകളുള്ള k നീളമുള്ള ഒരു അടുക്കിയ പട്ടിക തിരികെ നൽകുക. ഉദാഹരണം 1: ഇൻപുട്ട്: arr = [-3, -4, 5], k = 3 ഔട്ട്പുട്ട്: [-4, -3, 5] ഉദാഹരണം 2: ഇൻപുട്ട്: arr = [4, -4, 4], k = 2 ഔട്ട്പുട്ട്: [4, 4] ഉദാഹരണം 3: ഇൻപുട്ട്: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 ഔട്ട്പുട്ട്: [2] കുറിപ്പ്: 1. ശ്രേണിയുടെ നീളം [1, 1000] പരിധിയിലായിരിക്കും. 2. ശ്രേണിയിലെ ഘടകങ്ങൾ [-1000, 1000] പരിധിയിലായിരിക്കും. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"ഒരു നോൺ-ശൂന്യമായ പൂർണ്ണസംഖ്യകളുടെ പട്ടിക നൽകിയിട്ടുണ്ടെങ്കിൽ, സമ സ്ഥാനങ്ങളിലുള്ള എല്ലാ ഒറ്റപ്പെട്ട ഘടകങ്ങളുടെയും തുക നൽകുക. ഉദാഹരണങ്ങൾ പരിഹാരം (([5, 8, 7, 1]) ==> 12 പരിഹാരം (([3, 3, 3, 3, 3]) ==> 9 പരിഹാരം (([30, 13, 24, 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"ഒരു പൂർണ്ണസംഖ്യ arr ഉം ഒരു പൂർണ്ണസംഖ്യ k ഉം ഉള്ള ഒരു ശൂന്യമല്ലാത്ത അറേ നൽകിയിട്ടുണ്ടെങ്കിൽ, arr ന്റെ ആദ്യ k ഘടകങ്ങളിൽ നിന്ന് പരമാവധി രണ്ട് അക്കങ്ങളുള്ള മൂലകങ്ങളുടെ തുക നൽകുക. ഉദാഹരണംഃ ഇൻപുട്ട്ഃ arr = [111,21,3,4000,5,6,7,8,9], k = 4 ഔട്ട്പുട്ട്ഃ 24 # sum of 21 + 3 നിയന്ത്രണങ്ങൾഃ 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, ക്ലോട്ട്സ് ശ്രേണിയിൽ അസമമായ സംഖ്യകൾ അടങ്ങിയ ഒരു അടുക്കിയ പട്ടിക തിരികെ നൽകുക. ഏതെങ്കിലും പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n ഉപയോഗിച്ച് ആരംഭിക്കുക. തുടർന്ന് ഓരോ പദവും മുമ്പത്തെ പദത്തിൽ നിന്ന് ഇനിപ്പറയുന്ന രീതിയിൽ ലഭിക്കുന്നുഃ മുമ്പത്തെ പദം ഇരട്ടയാണെങ്കിൽ, അടുത്ത പദം മുമ്പത്തെ പദത്തിന്റെ പകുതിയാണ്. മുമ്പത്തെ പദം വിചിത്രമാണെങ്കിൽ, അടുത്ത പദം മുമ്പത്തെ പദത്തിന്റെ 3 മടങ്ങ് + 1. n ന്റെ മൂല്യം എന്തുതന്നെയായാലും, ശ്രേണി എല്ലായ്പ്പോഴും 1 ൽ എത്തുമെന്ന് അനുമാനം. കുറിപ്പ്ഃ 1. കോൾട്ട്സ് ((1) [1] ആണ്. 2. വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ അടുക്കിയ പട്ടിക തിരികെ നൽകുന്നു. ഉദാഹരണത്തിന്: get_odd_collatz ((5) [1, 5] നൽകുന്നു. 5 നുള്ള കോൾട്ട്സ് ശ്രേണി [5, 8, 16, 4, 2, 1], അതിനാൽ വിചിത്ര സംഖ്യകൾ 1, 5 എന്നിവ മാത്രമാണ്.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"ഒരു നിശ്ചിത തീയതി സ്ട്രിംഗ് സാധൂകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ നിങ്ങൾ എഴുതണം, കൂടാതെ തീയതി സാധുവാണെങ്കിൽ True നൽകും. അല്ലാത്തപക്ഷം False. ഇനിപ്പറയുന്ന എല്ലാ നിയമങ്ങളും പാലിച്ചാൽ തീയതി സാധുവായിരിക്കും: 1. തീയതി സ്ട്രിംഗ് ശൂന്യമല്ല. 2. മാസങ്ങൾ 1,3,5,7,8,10,12 ന് ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 31 ദിവസത്തിൽ കൂടുതലോ അല്ല. 4,6,9,11 മാസങ്ങൾക്ക് ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 30 ദിവസത്തിൽ കൂടുതലോ അല്ല. കൂടാതെ, മാസത്തിന് 29 ന് ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 1 ൽ കൂടുതലോ അല്ല. 2. 3. മാസങ്ങൾ 1 ൽ കുറവോ 12 ൽ കൂടുതലോ ആയിരിക്കരുത്. 4. തീയതി ഫോർമാറ്റിലായിരിക്കണംഃ mm-dd-yyyy ഉദാഹരണത്തിന്ഃ valid_date (('03-11-2000') => valid_date (('15-01-2012') => false (valid_date (('04-01-2040') => false (valid_date (('06-04-2020') => true (valid_date (('06/04/2020')  => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''വാക്കുകളുടെ ഒരു സ്ട്രിംഗ് നൽകിയിട്ടുണ്ടെങ്കിൽ, ശൂന്യതയിൽ വിഭജിച്ച വാക്കുകളുടെ ഒരു ലിസ്റ്റ് മടക്കിനൽകുക, ടെക്സ്റ്റിൽ ശൂന്യതകളൊന്നും നിലവിലില്ലെങ്കിൽ നിങ്ങൾ കോമകളായി വിഭജിക്കണം ',' കോമകളില്ലെങ്കിൽ നിങ്ങൾ അക്ഷരമാലയിലെ വിചിത്രമായ ക്രമത്തിൽ ചെറിയ അക്ഷരങ്ങളുടെ എണ്ണം മടക്കിനൽകണം, ord (('a') = 0, ord (('b') = 1, . . . ord (('z') = 25 ഉദാഹരണങ്ങൾ split_words ((\"ഹലോ വേൾഡ്! \") â -> [\"ഹലോ\", \"വേൾഡ്! \"] split_words ((\"ഹലോ, വേൾഡ്! \") â -> [\"ഹലോ\", \"വേൾഡ്! \"] split_words ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''ഒരു സംഖ്യകളുടെ പട്ടിക നൽകിയിട്ടുണ്ടെങ്കിൽ, അവ ക്രമത്തിൽ ക്രമീകരിച്ചിട്ടുണ്ടോ ഇല്ലയോ എന്ന് തിരികെ നൽകുക. പട്ടികയിൽ ഒരേ സംഖ്യയുടെ ഒന്നിൽ കൂടുതൽ തനിപ്പകർപ്പുകൾ ഉണ്ടെങ്കിൽ, False തിരികെ നൽകുക. നെഗറ്റീവ് സംഖ്യകളില്ലെന്നും പൂർണ്ണസംഖ്യകൾ മാത്രമേ ഉള്ളൂവെന്നും കരുതുക. ഉദാഹരണങ്ങൾ is_sorted (ആകെ) [1] (ആകെ) -> True is_sorted (ആകെ) [1, 2, 3, 4, 5, 5]) (ആകെ) -> True is_sorted (ആകെ) [1, 2, 3, 4, 5, 6]) (ആകെ) -> True is_sorted (ആകെ) [1, 2, 3, 4, 5, 6, 7]) (ആകെ) -> True is_sorted (ആകെ) [1, 3, 2, 4, 5, 6, 7]) (ആകെ) -> False is_sorted (ആകെ) [1, 2, 2, 2, 3, 4 (ആകെ) -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"നിങ്ങൾക്ക് രണ്ട് ഇടവേളകൾ നൽകിയിരിക്കുന്നു, ഓരോ ഇടവേളയും ഒരു ജോടി പൂർണ്ണസംഖ്യകളാണ്. ഉദാഹരണത്തിന്, ഇടവേള = (ആരംഭം, അവസാനം) = (1, 2). നൽകിയിരിക്കുന്ന ഇടവേളകൾ അടച്ചതാണ്, അതായത് ഇടവേള (ആരംഭം, അവസാനം) ആരംഭവും അവസാനവും ഉൾക്കൊള്ളുന്നു. ഓരോ നിശ്ചിത ഇടവേളയ്ക്കും, അതിന്റെ ആരംഭം അതിന്റെ അവസാനത്തേക്കാൾ ചെറുതാണെന്ന് കരുതപ്പെടുന്നു. ഈ രണ്ട് ഇടവേളകളുടെ കവലയുടെ ദൈർഘ്യം ഒരു പ്രൈം നമ്പറാണോ എന്ന് നിർണ്ണയിക്കുക എന്നതാണ് നിങ്ങളുടെ ചുമതല. ഉദാഹരണത്തിന്, ഇടവേളകളുടെ കവല (1, 3), (2, 4) എന്നിവയുടെ (2, 3) ആണ്, അതിന്റെ ദൈർഘ്യം 1 ആണ്, അത് ഒരു പ്രൈം നമ്പറല്ല. കവലയുടെ ദൈർഘ്യം ഒരു പ്രൈം നമ്പറാണെങ്കിൽ, \"YES\" മടങ്ങുക, അല്ലെങ്കിൽ \"NO\" മടങ്ങുക. രണ്ട് ഇടവേളകൾ കവലിക്കുന്നില്ലെങ്കിൽ, \"NO\" മടങ്ങുക. [input/output] സാമ്പിളുകൾഃ intersection (((1, 2), (2, 3) ==> \"intersection (-1), \"intersection (-1), \"intersection (-1), \"intersection (-1), \"intersection (-1), \"intersection (-1), \"intersection (-1\", \"intersection (-1), \"intersection (-1\", \"intersection (-1), \"intersection (-1), \"intersection (\", \"intersection) \"), \"intersection (\", \"intersection (\", \"intersection (\",), \"intersection (\",), \"intersection (\",), \"intersection (\",), \"intersection (\",), \"intersection (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\", (\",), \" (\",), \" (\",), \" (\",), \" (\",), \" (\", (), \" (), \" (), \" (), \" (\",), \" (), \" (), \" (\", (), \" (), \" (), (), (), (), (), (), (), (), (), (\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"നിങ്ങൾക്ക് ഒരു അറേ നൽകിയിരിക്കുന്നു, അതിൽ നിങ്ങൾ സംഖ്യകളുടെ ആകെത്തുക നൽകണം, അത് അറേയിലെ ഓരോ സംഖ്യയുടെയും എല്ലാ ചിഹ്നങ്ങളുടെയും ഗുണിതത്താൽ ഗുണിച്ചിരിക്കണം, ഇത് 1, -1 അല്ലെങ്കിൽ 0 ആയി പ്രതിനിധീകരിക്കുന്നു. ശ്രദ്ധിക്കുക: ശൂന്യമായ അറേയ്ക്ക് ഒന്നും നൽകരുത്. ഉദാഹരണംഃ >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None \"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"N വരികളും N നിരകളും (N >= 2) ഉള്ള ഒരു ഗ്രിഡും k എന്ന പോസിറ്റീവ് ഇന്റീജറും ഉള്ള ഗ്രിഡിന്റെ ഓരോ സെല്ലിലും ഒരു മൂല്യം അടങ്ങിയിരിക്കുന്നു. [1, N * N] പരിധിയിലെ ഓരോ ഇന്റീജറും ഗ്രിഡിലെ സെല്ലുകളിൽ കൃത്യമായി ഒരിക്കൽ ദൃശ്യമാകുന്നു. ഗ്രിഡിലെ k എന്ന ദൈർഘ്യമുള്ള ഏറ്റവും കുറഞ്ഞ പാത നിങ്ങൾ കണ്ടെത്തണം. നിങ്ങൾക്ക് ഏത് സെല്ലിൽ നിന്നും ആരംഭിക്കാം, ഓരോ ഘട്ടത്തിലും നിങ്ങൾക്ക് അയൽ സെല്ലുകളിലേക്ക് നീങ്ങാം, മറ്റൊരു വിധത്തിൽ പറഞ്ഞാൽ, നിങ്ങൾക്ക് നിലവിലെ സെല്ലുമായി ഒരു അരികു പങ്കിടുന്ന സെല്ലുകളിലേക്ക് പോകാം. k എന്ന ദൈർഘ്യമുള്ള ഒരു പാത അർത്ഥമാക്കുന്നത് k സെല്ലുകൾ സന്ദർശിക്കുക (നിർബന്ധമായും വ്യത്യസ്തമല്ല). നിങ്ങൾക്ക് ഗ്രിഡിൽ നിന്ന് പുറത്തുപോകാൻ കഴിയില്ല. A (k നീളമുള്ള) ഒരു പാത B (k) എന്ന പാതയേക്കാൾ ചെറുതായി കണക്കാക്കപ്പെടുന്നു, A, B (ആകും) എന്ന സെല്ലുകളിലൂടെ കടന്നുപോകുന്ന മൂല്യങ്ങളുടെ ക്രമപ്പെടുത്തിയ ലിസ്റ്റുകൾ നിർമ്മിച്ചതിനുശേഷം (നമുക്ക് അവയെ l_stA, l_stB എന്ന് വിളിക്കാം), l_stA, l_stB എന്നിവയെ ഉൾപ്പെടെ), l_st_st_A എന്ന ശ്രേണിന്റെ ഓരോ ഇന്റവും ഗ്രിടെയുള്ള ഓരോ സെല്ലിലും ഒരു മൂല്യം അടങ്ങിയിരിക്കുന്നു. ഗ്രിഡിൽ [1, l_st_A, k, k, k, k, k, k, k, k, k, k, k, k, k, k, j_, j, j_, j_, j_, j_, j_, j_, j_, j_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"ഫിബോനാച്ചി ശ്രേണി എല്ലാവർക്കും അറിയാം, കഴിഞ്ഞ രണ്ട് നൂറ്റാണ്ടുകളായി ഗണിതശാസ്ത്രജ്ഞർ ഇത് ആഴത്തിൽ പഠിച്ചു. എന്നിരുന്നാലും, ആളുകൾക്ക് അറിയാത്തത് ട്രിബോനാച്ചി ശ്രേണിയാണ്. ട്രിബോനാച്ചി ശ്രേണി ആവർത്തനത്താൽ നിർവചിക്കപ്പെടുന്നുഃ tri(1) = 3 tri(n) = 1 + n / 2, n ആണെങ്കിൽ പോലും. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), n ആണെങ്കിൽ അപൂർവമാണ്. ഉദാഹരണത്തിന്: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 നിങ്ങൾക്ക് ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ട്, ട്രിബോനാച്ചി ശ്രേണിയിലെ ആദ്യത്തെ n + 1 സംഖ്യകളുടെ ഒരു പട്ടിക നിങ്ങൾ നൽകണം. ഉദാഹരണങ്ങൾ: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, അസമമായ അക്കങ്ങളുടെ ഗുണിതം നൽകുക. എല്ലാ അക്കങ്ങളും ഇരട്ടയാണെങ്കിൽ 0 നൽകുക. ഉദാഹരണത്തിന്: അക്കങ്ങൾ ((1) == 1 അക്കങ്ങൾ ((4) == 0 അക്കങ്ങൾ ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക, അതിൽ സ്ക്വയർ ബ്രാക്കറ്റുകൾ മാത്രമേ അടങ്ങിയിട്ടുള്ളൂ. ബ്രാക്കറ്റുകളുടെ സാധുവായ ഒരു അനുക്രമം ഉണ്ടെങ്കിൽ മാത്രമേ ഫംഗ്ഷൻ True നൽകൂ. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]][[]]') â -> True'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"നിങ്ങൾക്ക് ഒരു സംഖ്യകളുടെ പട്ടിക നൽകിയിരിക്കുന്നു. നിങ്ങൾ നൽകിയ പട്ടികയിലെ സംഖ്യകളുടെ ചതുരശ്ര സംഖ്യകൾ മടക്കിനൽകണം, പട്ടികയിലെ ഓരോ ഘടകവും മുകളിലെ int വരെ വൃത്താകൃതിയിലാക്കുക. ഉദാഹരണങ്ങൾ: lst = [1,2,3] എന്നതിന് ഔട്ട്പുട്ട് 14 ആയിരിക്കണം lst = [1,4,9] എന്നതിന് ഔട്ട്പുട്ട് 98 ആയിരിക്കണം lst = [1,3,5,7] എന്നതിന് ഔട്ട്പുട്ട് 84 ആയിരിക്കണം lst = [1.4,4.2,0] എന്നതിന് ഔട്ട്പുട്ട് 29 ആയിരിക്കണം lst = [-2.4,1,1] എന്നതിന് ഔട്ട്പുട്ട് 6 ആയിരിക്കണം \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''ഒരു സ്ട്രിംഗിന്റെ അവസാന പ്രതീകം അക്ഷരമാലയിലെ പ്രതീകമാണെങ്കിൽ True എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക, അല്ലാത്തപക്ഷം False. ശ്രദ്ധിക്കുക: \"വചനം\" എന്നത് സ്പെയ്സ് ഉപയോഗിച്ച് വേർതിരിക്കുന്ന പ്രതീകങ്ങളുടെ ഒരു കൂട്ടമാണ്. ഉദാഹരണങ്ങൾ: check_if_last_char_is_a_letter\" (ഉദാഹരണത്തിന്, \"ആപ്പിൾ പൈ\") â -> False check_if_last_char_is_a_letter\" (ഉദാഹരണത്തിന്, \"ആപ്പിൾ പൈ\") â -> True check_if_last_char_is_a_letter\" (ഉദാഹരണത്തിന്, \"ആപ്പിൾ പൈ\") â -> False check_if_last_char_is_a_letter\" (ഉദാഹരണത്തിന്, \"ആപ്പിൾ പൈ\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"ഒരു മൂലകത്തിന്റെ ഏറ്റവും വലിയ സൂചിക മടക്കിനൽകുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക, അത് അതിന് തൊട്ടുമുമ്പുള്ള മൂലകത്തേക്കാൾ വലുതോ തുല്യമോ അല്ല. അത്തരം ഒരു മൂലകം നിലവിലില്ലെങ്കിൽ -1. നൽകിയിരിക്കുന്ന അറേയിൽ തനിപ്പകർപ്പ് മൂല്യങ്ങൾ അടങ്ങിയിരിക്കില്ല. ഉദാഹരണങ്ങൾ: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''ഒരു ട്യൂപ്പൽ (a, b) റിട്ടേൺ ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക, അവിടെ 'a' നെഗറ്റീവ് പൂർണ്ണസംഖ്യകളിൽ ഏറ്റവും വലുതും 'b' ഒരു ലിസ്റ്റിലെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളിൽ ഏറ്റവും ചെറുതുമാണ്. നെഗറ്റീവ് അല്ലെങ്കിൽ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളില്ലെങ്കിൽ, അവയെ None ആയി റിട്ടേൺ ചെയ്യുക. ഉദാഹരണങ്ങൾ: ഏറ്റവും വലിയ_ഏറ്റവും ചെറിയ_പൂർണ്ണസംഖ്യകൾ[2, 4, 1, 3, 5, 7]) == (ഒന്നും ഇല്ല) ഏറ്റവും വലിയ_ഏറ്റവും ചെറിയ_പൂർണ്ണസംഖ്യകൾ (([]) == (ഒന്നും ഇല്ല) ഏറ്റവും വലിയ_ഏറ്റവും ചെറിയ_പൂർണ്ണസംഖ്യകൾ (([0]) == (ഒന്നും ഇല്ല)'''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക, അത് റിയൽ നമ്പറുകൾ, ഫ്ലോട്ടുകൾ, അല്ലെങ്കിൽ റിയൽ നമ്പറുകൾ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിങ്ങുകൾ എന്നിവ എടുക്കുകയും അതിന്റെ നൽകിയ വേരിയബിൾ തരത്തിൽ വലിയ വേരിയബിൾ നൽകുകയും ചെയ്യുന്നു. മൂല്യങ്ങൾ തുല്യമാണെങ്കിൽ None നൽകുക. കുറിപ്പ്ഃ ഒരു റിയൽ നമ്പർ ഒരു സ്ട്രിംഗായി പ്രതിനിധീകരിക്കുകയാണെങ്കിൽ, ഫ്ലോട്ടിംഗ് പോയിന്റ് . അല്ലെങ്കിൽ , compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"n എന്ന സംഖ്യയെ കൃത്യമായി 4 പോസിറ്റീവ് ഇരട്ട സംഖ്യകളുടെ ആകെത്തുകയായി എഴുതാൻ കഴിയുമോ എന്ന് വിലയിരുത്തുക ഉദാഹരണം is_equal_to_sum_even () == False is_equal_to_sum_even () == False is_equal_to_sum_even () == True \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"ബ്രസീലിയൻ ഫാക്ടോറിയൽ നിർവചിച്ചിരിക്കുന്നത് ഇങ്ങനെയാണ്: ബ്രസീലിയൻ_ഫാക്ടോറിയൽ ((n) = n! * (n-1)! * (n-2)! * . . . * 1! ഇവിടെ n > 0 ഉദാഹരണത്തിന്: >>> സ്പെഷ്യൽ_ഫാക്ടോറിയൽ ((4) 288 ഫംഗ്ഷന് ഒരു പൂർണ്ണസംഖ്യ ഇൻപുട്ടായി ലഭിക്കും, ഈ പൂർണ്ണസംഖ്യയുടെ പ്രത്യേക ഫാക്ടോറിയൽ തിരികെ നൽകണം. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_ഉദാഹരണം-3ക്സ്റ്റ് നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിലെ എല്ലാ സ്പെയ്സുകളും അടിവരയിടുക, ഒരു സ്ട്രിംഗിൽ തുടർച്ചയായി 2 ലധികം സ്പെയ്സുകൾ ഉണ്ടെങ്കിൽ, തുടർച്ചയായി എല്ലാ സ്പെയ്സുകളും - fix_spaces ((\"ഉദാഹരണം\") == \"ഉദാഹരണം\" fix_spaces ((\"ഉദാഹരണം1\") == \"ഉദാഹരണം1\" fix_spaces ((\"ഉദാഹരണം2\") == \"_Example_2\" fix_spaces ((\"ഉദാഹരണം 3\") == \"_Example-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"ഒരു ഫയലിന്റെ പേര് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക, ഫയലിന്റെ പേര് സാധുവാണെങ്കിൽ 'അതെ' എന്ന് മടക്കിനൽകുന്നു, അല്ലാത്തപക്ഷം 'ഇല്ല' എന്ന് മടക്കിനൽകുന്നു. ഇനിപ്പറയുന്ന എല്ലാ വ്യവസ്ഥകളും പാലിച്ചാൽ മാത്രമേ ഒരു ഫയലിന്റെ പേര് സാധുവായി കണക്കാക്കുകയുള്ളൂ: - ഫയലിന്റെ പേരിൽ മൂന്ന് അക്കങ്ങളിൽ കൂടുതൽ ('0'-'9') ഉണ്ടാകരുത്. - ഫയലിന്റെ പേരിൽ കൃത്യമായി ഒരു ഡോട്ട് '.' അടങ്ങിയിരിക്കണം. - ഡോട്ടിന് മുമ്പുള്ള സബ്സ്ട്രിംഗ് ശൂന്യമായിരിക്കരുത്, കൂടാതെ ഇത് ലാറ്റിൻ അക്ഷരങ്ങളിൽ നിന്നുള്ള ഒരു അക്ഷരത്തിൽ ആരംഭിക്കണം ('a'-'z' ഉം 'A'Z'). - ഡോട്ടിന് ശേഷമുള്ള സബ്സ്ട്രിംഗ് ഇവയിൽ ഒന്നായിരിക്കണംഃ ['txt', 'exe', 'lld'] ഉദാഹരണങ്ങൾഃ file_name_check\"(example.txt.t\") # => 'അതെ' file_name_check\"{example.dll1\") => 'ഇല്ല' # (പേര് ഒരു ലാറ്റിൻ അക്ഷരത്തിൽ ആരംഭിക്കണം)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" ഈ ഫംഗ്ഷൻ പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ് എടുക്കും. ലിസ്റ്റിലെ എല്ലാ എൻട്രികൾക്കും, ഫംഗ്ഷൻ അതിന്റെ ഇൻഡെക്സ് 3 ന്റെ ഗുണിതമാണെങ്കിൽ പൂർണ്ണസംഖ്യ എൻട്രി സ്ക്വയർ ചെയ്യണം, കൂടാതെ അതിന്റെ ഇൻഡെക്സ് 4 ന്റെ ഗുണിതമാണെങ്കിൽ പൂർണ്ണസംഖ്യ എൻട്രി ക്യൂബ് ചെയ്യും. 3 ന്റെ ഗുണിതമല്ല, 3 ന്റെ ഗുണിതമല്ല. ഫംഗ്ഷൻ ലിസ്റ്റിലെ എൻട്രികൾ മാറ്റില്ല, അവയുടെ സൂചികകൾ 3 അല്ലെങ്കിൽ 4 ന്റെ ഗുണിതമല്ല. ഫംഗ്ഷൻ എല്ലാ എൻട്രികളുടെയും തുക നൽകും. ഉദാഹരണങ്ങൾ: lst = [1,2,3] എന്നതിന് ഔട്ട്പുട്ട് 6 ആയിരിക്കണം lst = [] എന്നതിന് ഔട്ട്പുട്ട് 0 ആയിരിക്കണം lst = [-1,-5,2,-1,-5] എന്നതിന് ഔട്ട്പുട്ട് -126 ആയിരിക്കണം \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"ഒരു വാക്യത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് നിങ്ങൾക്ക് നൽകിയിട്ടുണ്ട്, വാക്യത്തിൽ ഒരു സ്പെയ്സ് ഉപയോഗിച്ച് വേർതിരിച്ച ചില വാക്കുകൾ അടങ്ങിയിരിക്കുന്നു, കൂടാതെ യഥാർത്ഥ വാക്യത്തിൽ നിന്നുള്ള വാക്കുകൾ അടങ്ങിയിരിക്കുന്ന ഒരു സ്ട്രിംഗ് നിങ്ങൾ മടക്കിനൽകണം, അവയുടെ ദൈർഘ്യം പ്രൈം നമ്പറുകളാണ്, പുതിയ സ്ട്രിംഗിലെ വാക്കുകളുടെ ക്രമം യഥാർത്ഥത്തിൽ സമാനമായിരിക്കണം. ഉദാഹരണം 1: ഇൻപുട്ട്ഃ വാചകം = \"ഇത് ഒരു പരിശോധനയാണ്\" ഔട്ട്പുട്ട്ഃ \"is\" ഉദാഹരണം 2: ഇൻപുട്ട്ഃ വാചകം = \"നമുക്ക് നീന്താൻ പോകാം\" ഔട്ട്പുട്ട്ഃ \"go for\" നിയന്ത്രണങ്ങൾഃ * 1 <= len(sentence) <= 100 * വാചകം അക്ഷരങ്ങൾ മാത്രം അടങ്ങിയിരിക്കുന്നു \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"x * n എന്ന എക്സ്പ്രഷനെ ലളിതമാക്കുന്ന ഒരു ഫംഗ്ഷൻ നടപ്പിലാക്കുക എന്നതാണ് നിങ്ങളുടെ ചുമതല. x * n ഒരു പൂർണ്ണസംഖ്യയായി വിലയിരുത്തുകയും അല്ലാത്തപക്ഷം False ആയി വിലയിരുത്തുകയും ചെയ്താൽ ഫംഗ്ഷൻ True ആയി നൽകുന്നു. x, n എന്നിവ ഒരു ഭിന്നസംഖ്യയുടെ സ്ട്രിംഗ് പ്രാതിനിധ്യമാണ്, കൂടാതെ ഇനിപ്പറയുന്ന ഫോർമാറ്റ് ഉണ്ട്, <numerator>/<denominator>, അവിടെ സംഖ്യയും നാമകരണവും പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്. x, n എന്നിവ സാധുവായ ഭിന്നസംഖ്യകളാണെന്നും അവയ്ക്ക് നാമകരണമായി പൂജ്യം ഇല്ലെന്നും നിങ്ങൾക്ക് അനുമാനിക്കാം. ലളിതമാക്കുക \" 1 / 5\", \"5 / 1\") = True ലളിതമാക്കുക \" 1/6\", \"2 / 1\") = False ലളിതമാക്കുക \" 7 / 10\", \"10 / 2\") = False \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"ഒരു ഫംഗ്ഷൻ എഴുതുക, അത് നൽകിയിരിക്കുന്ന സംഖ്യകളുടെ പട്ടിക അവരുടെ അക്കങ്ങളുടെ ആകെത്തുക അനുസരിച്ച് വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ അടുക്കുന്നു. കുറിപ്പ്: സമാനമായ അക്കങ്ങളുടെ സംഖ്യയുള്ള നിരവധി ഇനങ്ങളുണ്ടെങ്കിൽ, അവയുടെ സൂചിക അടിസ്ഥാനമാക്കി യഥാർത്ഥ പട്ടികയിൽ ക്രമീകരിക്കുക. ഉദാഹരണത്തിന്ഃ >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"ഒരു സംഖ്യയുടെ ആദ്യ, അവസാന അക്കം പത്തിൽ കൂടുതലുള്ളതും പത്തിൽ കൂടുതലുള്ളതുമായ എലമെന്റുകളുടെ എണ്ണം നൽകുന്നു. ഉദാഹരണത്തിന്: specialFilter ([15, -73, 14, -15]) => 1 specialFilter ([33, -2, -3, 45, 21, 109]) => 2\"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"നിങ്ങൾക്ക് ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിരിക്കുന്നു. നീളം n ഉള്ള ഒരു പൂർണ്ണസംഖ്യ അറേ സൃഷ്ടിക്കണം. ഓരോ i (1 ‰¤ i ‰¤ n) നും, a[i] = i * i - i + 1 ന്റെ മൂല്യം. a ന്റെ ട്രിപ്പിൾസ് (a[i], a[j], a[k]) എണ്ണം തിരികെ നൽകുക, അവിടെ i < j < k, a[i] + a[j] + a[k] എന്നത് 3 ന്റെ ഗുണിതമാണ്. ഉദാഹരണംഃ ഇൻപുട്ട്: n = 5 ഔട്ട്പുട്ട്ഃ 1 വിശദീകരണംഃ a = [1, 3, 7, 13, 21] സാധുവായ ട്രിപ്പിൾ മാത്രമാണ് (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''നമ്മുടെ സൌരയൂഥത്തിൽ എട്ട് ഗ്രഹങ്ങളുണ്ട്: സൂര്യനോട് ഏറ്റവും അടുത്തുള്ളത് ബുധൻ, അടുത്തത് ശുക്രൻ, പിന്നെ ഭൂമി, ചൊവ്വ, വ്യാഴം, ശനിയും, യുറാനസും, നെപ്റ്റ്യൂണും. ഒരു ഫംഗ്ഷൻ എഴുതുക, അതിൽ രണ്ട് ഗ്രഹനാമങ്ങൾ സ്ട്രിംഗുകളായി ഗ്രഹം 1 ഉം ഗ്രഹം 2 ഉം എടുക്കുന്നു. ഗ്രഹത്തിന്റെ ഭ്രമണപഥവും ഗ്രഹത്തിന്റെ ഭ്രമണപഥവും തമ്മിലുള്ള എല്ലാ ഗ്രഹങ്ങളും അടങ്ങിയ ഒരു ടപ്പിൾ ഫംഗ്ഷൻ നൽകണം, സൂര്യനോട് അടുത്തുള്ള അടുപ്പം അനുസരിച്ച് അടുക്കുന്നു. ഗ്രഹം 1 അല്ലെങ്കിൽ ഗ്രഹം 2 ശരിയായ ഗ്രഹനാമങ്ങളല്ലെങ്കിൽ ഫംഗ്ഷൻ ഒരു ശൂന്യമായ ടപ്പിൾ നൽകണം. ഉദാഹരണങ്ങൾ bf \"(ജൂപ്പൈറ്റർ\", \"നെപ്റ്റ്യൂൺ\") ==> (\"ശുക്രൻ\", \"യുറാനസ്\") bf \"(ഭൂമി\", \"മെർക്കുറി\") ==> (\"ശുക്രൻ\", \"യൂപ്പൈറ്റർ\", \"ജൂപ്പൈറ്റർ\", \"ശുര്യൻ\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"ഒരു പരാമീറ്ററായി സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റ് സ്വീകരിക്കുകയും അതിൽ നിന്ന് odd ദൈർഘ്യമുള്ള സ്ട്രിങ്ങുകൾ ഇല്ലാതാക്കുകയും ഫലമായി ലഭിക്കുന്ന പട്ടിക ഒരു അടുക്കിയ ക്രമത്തിൽ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. പട്ടിക എല്ലായ്പ്പോഴും സ്ട്രിങ്ങുകളുടെ ഒരു പട്ടികയാണ്, ഒരിക്കലും സംഖ്യകളുടെ ഒരു അറേ അല്ല, അതിൽ തനിപ്പകർപ്പുകൾ അടങ്ങിയിരിക്കാം. പട്ടികയുടെ ക്രമം ഓരോ വാക്കിന്റെയും ദൈർഘ്യത്തിൽ വർദ്ധിച്ചിരിക്കണം, ആ നിയമപ്രകാരം അടുക്കിയ പട്ടിക നിങ്ങൾ നൽകണം. രണ്ട് വാക്കുകൾക്ക് ഒരേ നീളം ഉണ്ടെങ്കിൽ, പട്ടിക അക്ഷരമാലാക്രമത്തിൽ അടുക്കുക. ഫംഗ്ഷൻ അടുക്കിയ ക്രമത്തിൽ സ്ട്രിംഗുകളുടെ ഒരു പട്ടിക നൽകണം. എല്ലാ വാക്കുകളും ഒരേ നീളം ഉണ്ടായിരിക്കുമെന്ന് നിങ്ങൾ അനുമാനിക്കാം. ഉദാഹരണത്തിന്: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => \"ab\", \"cd ])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"n ഒരു പ്രൈം നമ്പർ ആണെങ്കിൽ x ന്റെ മൂല്യം നൽകുകയും y ന്റെ മൂല്യം നൽകുകയും ചെയ്യുന്ന ഒരു ലളിതമായ പ്രോഗ്രാം. ഉദാഹരണങ്ങൾ: x_or_y(7, 34, 12) == 34 x_or_y(15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''ഒരു സംഖ്യകളുടെ പട്ടിക നൽകിയിട്ടുണ്ടെങ്കിൽ, പട്ടികയിലെ അസംഖ്യം സംഖ്യകളുടെ സ്ക്വയറുകളുടെ തുക നൽകുക. നെഗറ്റീവ് അല്ലെങ്കിൽ പൂർണ്ണസംഖ്യകളല്ലാത്ത സംഖ്യകളെ അവഗണിക്കുക. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 ഇൻപുട്ട് ലിസ്റ്റ് ശൂന്യമാണെങ്കിൽ, 0 നൽകുക. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"ഒരു നീണ്ട കാത്തിരിപ്പിന്റെ ഫലം ഒടുവിൽ അറിയപ്പെടുമ്പോൾ ആ വികാരം നമുക്കെല്ലാവർക്കും ഓർമ്മയുണ്ടെന്ന് ഞാൻ കരുതുന്നു. ആ നിമിഷത്തിൽ നിങ്ങൾക്കുള്ള വികാരങ്ങളും ചിന്തകളും തീർച്ചയായും ശ്രദ്ധിക്കുകയും താരതമ്യം ചെയ്യുകയും ചെയ്യുന്നു. ഒരു വ്യക്തി നിരവധി പൊരുത്തങ്ങളുടെ ഫലങ്ങൾ ശരിയായി ഊഹിച്ചിട്ടുണ്ടോ എന്ന് നിർണ്ണയിക്കുക എന്നതാണ് നിങ്ങളുടെ ചുമതല. നിങ്ങൾക്ക് രണ്ട് സ്കോറുകളും തുല്യ നീളമുള്ള guesses- കളും നൽകിയിട്ടുണ്ട്, ഓരോ സൂചികയും ഒരു പൊരുത്തം കാണിക്കുന്നു. ഓരോ guess എത്ര ദൂരെയാണെന്ന് സൂചിപ്പിക്കുന്ന ഒരേ നീളമുള്ള ഒരു array മടക്കുക. അവർ ശരിയായി ഊഹിച്ചിട്ടുണ്ടെങ്കിൽ, മൂല്യം 0 ആണ്, ഇല്ലെങ്കിൽ, മൂല്യം guess ഉം സ്കോർ തമ്മിലുള്ള കേവല വ്യത്യാസമാണ്. ഉദാഹരണം: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare (([0,5,0,0,4],[4,1,0,-2]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"നിങ്ങൾക്ക് ഒരു ക്ലാസിന്റെ പേരും (ഒരു സ്ട്രിംഗ്) വിപുലീകരണങ്ങളുടെ പട്ടികയും ലഭിക്കും. വിപുലീകരണങ്ങൾ ഉപയോഗിച്ച് ക്ലാസ്സിലേക്ക് കൂടുതൽ ക്ലാസുകൾ ലോഡ് ചെയ്യാം. വിപുലീകരണത്തിന്റെ ശക്തി താഴെ പറയുന്നതാണ്: CAP എന്നത് വിപുലീകരണത്തിന്റെ പേരിന്റെ വലിയ അക്ഷരങ്ങളുടെ എണ്ണവും SM എന്നത് വിപുലീകരണത്തിന്റെ പേരിന്റെ ചെറിയ അക്ഷരങ്ങളുടെ എണ്ണവും ആയിരിക്കട്ടെ, വിപുലീകരണത്തിന്റെ ശക്തി CAP - SM എന്ന ഭിന്നസംഖ്യയാണ് നൽകുന്നത്. നിങ്ങൾ ഏറ്റവും ശക്തമായ വിപുലീകരണം കണ്ടെത്തി ഈ ഫോർമാറ്റിലുള്ള ഒരു സ്ട്രിംഗ് നൽകണം: ClassName.StrongestExtensionName. ഒരേ ശക്തിയിൽ രണ്ടോ അതിലധികമോ വിപുലീകരണങ്ങൾ ഉണ്ടെങ്കിൽ, നിങ്ങൾ പട്ടികയിൽ ആദ്യം വരുന്ന ഒന്ന് തിരഞ്ഞെടുക്കണം. ഉദാഹരണത്തിന്, നിങ്ങൾക്ക് \"Slices\" എന്ന ക്ലാസും വിപുലീകരണങ്ങളുടെ പട്ടികയും നൽകിയിട്ടുണ്ടെങ്കിൽ: ['SEviviRNGCliES', 'Cheese', 'StuFfed'] അപ്പോൾ നിങ്ങൾ 'Slices.SEviRNGCliES' എന്ന് നൽകണം, കാരണം 'SEviRNGCliES' എന്നത് വിപുലീകരണത്തിന്റെ പേര്, വിപുലീകരണത്തിന്റെ ശക്തി 'AA' (ഉദാഹരണത്തിന്ഃ '_AA'_Strongest_class' ആണ്) ആണ്.\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"നിങ്ങൾക്ക് 2 വാക്കുകൾ നൽകിയിരിക്കുന്നു. രണ്ടാമത്തെ വാക്ക് അല്ലെങ്കിൽ അതിന്റെ ഏതെങ്കിലും ഭ്രമണം ആദ്യ വാക്കിലെ ഒരു ഉപസ്ട്രിംഗ് ആണെങ്കിൽ നിങ്ങൾ True തിരികെ നൽകേണ്ടതുണ്ട് cycpattern_check(\"abcd\",\"abd\") => False cycpattern_check(\"hello\",\"ell\") => True cycpattern_check(\"whassup\",\"psus\") => False cycpattern_check\"abab\",\"baa\") => True cycpattern_check(\"efef\",\"eeff\") => False cycpattern_check\"(hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"ഒരു പൂർണ്ണസംഖ്യ നൽകിയിട്ടുണ്ടെങ്കിൽ, യഥാക്രമം, ഇരട്ടയും, ഭിന്നവുമായ അക്കങ്ങളുടെ എണ്ണം ഉള്ള ഒരു ടപ്പിൾ നൽകുക. ഉദാഹരണം: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിന്റെ റോമൻ സംഖ്യാ തുല്യത ഒരു സ്ട്രിംഗായി നേടുക, അത് ചെറിയ അക്ഷരങ്ങളിൽ നൽകുക. നിയന്ത്രണങ്ങൾ: 1 <= num <= 1000 ഉദാഹരണങ്ങൾ: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''ഒരു ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങളുടെ നീളം നൽകുക. മൂന്നു വശങ്ങളും ഒരു വലതു കോണുള്ള ത്രികോണം രൂപപ്പെടുത്തിയാൽ True തിരികെ നൽകുക, അല്ലാത്തപക്ഷം False. വലതു കോണുള്ള ത്രികോണം ഒരു കോണിന് വലതു കോണോ 90 ഡിഗ്രിയോ ഉള്ള ഒരു ത്രികോണമാണ്. ഉദാഹരണം: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റ് സ്വീകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക. ലിസ്റ്റിൽ വ്യത്യസ്ത പദങ്ങൾ അടങ്ങിയിരിക്കുന്നു. പരമാവധി അദ്വിതീയ പ്രതീകങ്ങളുടെ എണ്ണം ഉപയോഗിച്ച് വാക്ക് മടക്കിനൽകുക. ഒന്നിലധികം സ്ട്രിങ്ങുകൾക്ക് പരമാവധി അദ്വിതീയ പ്രതീകങ്ങളുടെ എണ്ണം ഉണ്ടെങ്കിൽ, ലെക്സിക്കോഗ്രാഫിക്കൽ ക്രമത്തിൽ ആദ്യം വരുന്ന ഒന്ന് മടക്കിനൽകുക. find_max (([\"name\", \"of\", \"string\"]) == \"string\" find_max (([\"name\", \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"നിങ്ങൾ ഒരു വിശന്ന മുയലാണ്, നിങ്ങൾ ഇതിനകം ഒരു നിശ്ചിത എണ്ണം കാരറ്റ് കഴിച്ചു, എന്നാൽ ഇപ്പോൾ നിങ്ങൾ കൂടുതൽ കാരറ്റ് കഴിക്കേണ്ടതുണ്ട്. നിങ്ങൾ ഒരു അറേ നൽകണം [നിങ്ങളുടെ ഭക്ഷണത്തിനുശേഷം കഴിച്ച കാരറ്റ് എണ്ണം, നിങ്ങളുടെ ഭക്ഷണത്തിനുശേഷം ശേഷിക്കുന്ന കാരറ്റ് എണ്ണം ] മതിയായ ശേഷിക്കുന്ന കാരറ്റ് ഇല്ലെങ്കിൽ, നിങ്ങൾ ശേഷിക്കുന്ന എല്ലാ കാരറ്റുകളും കഴിക്കും, പക്ഷേ ഇപ്പോഴും വിശപ്പുണ്ടാകും. ഉദാഹരണംഃ * തിന്നുക (, 5, 6, 10) -> [11, 4] * തിന്നുക (, 4, 8, 9) -> [12, 1] * തിന്നുക (, 1, 10, 10) -> [11, 0] * തിന്നുക (, 2, 11, 5) -> [7, 0] വേരിയബിളുകൾ: @number: നിങ്ങൾ കഴിച്ച കാരറ്റ് എണ്ണം. @need: നിങ്ങൾ കഴിക്കേണ്ട കാരറ്റ് എണ്ണം. @remaining: സ്റ്റോക്കിൽ ശേഷിക്കുന്ന കാരറ്റ് എണ്ണം. Constrain: * 0 = <= 0 * 1000 = <= 1000 * 0 = <= 1000 = ബാക്കിയുള്ള കാരറ്റ് എണ്ണം.\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"രണ്ട് ലിസ്റ്റുകൾ ഓപ്പറേറ്ററും ഓപ്പറാൻഡും. ആദ്യ ലിസ്റ്റിൽ അടിസ്ഥാന ആൽജെബ്രിക് പ്രവർത്തനങ്ങൾ ഉണ്ട്, രണ്ടാമത്തെ ലിസ്റ്റ് പൂർണ്ണസംഖ്യകളുടെ പട്ടികയാണ്. ആൽജെബ്രിക് എക്സ്പ്രഷൻ നിർമ്മിക്കാനും ഈ എക്സ്പ്രഷന്റെ മൂല്യനിർണ്ണയം തിരികെ നൽകാനും നൽകിയ രണ്ട് ലിസ്റ്റുകൾ ഉപയോഗിക്കുക. അടിസ്ഥാന ആൽജെബ്രിക് പ്രവർത്തനങ്ങൾഃ കൂട്ടിച്ചേർക്കൽ (+) കുറയ്ക്കൽ ( - ) ഗുണനം ( * ) ഫ്ലോർ ഡിവിഷൻ ( // ) എക്സ്പോണൻഷ്യേഷൻ ( ** ഉദാഹരണം): ഓപ്പറേറ്റർ['+', '*', '-'] അറേ = [2, 3, 4, 5] ഫലം = 2 + 3 * 4 - 5 => ഫലം = 9 കുറിപ്പ്ഃ ഓപ്പറേറ്റർ പട്ടികയുടെ നീളം ഓപ്പറാൻഡ് ലിസ്റ്റിന്റെ നീളത്തിന് തുല്യമാണ്. ഓപ്പറാൻഡ് നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യകളുടെ പട്ടികയാണ്. ഓപ്പറേറ്റർ ലിസ്റ്റിൽ കുറഞ്ഞത് ഒരു ഓപ്പറേറ്ററുമുണ്ട്, ഓപ്പറാൻഡ് ലിസ്റ്റിൽ കുറഞ്ഞത് രണ്ട് ഓപ്പറാൻഡുകളുണ്ട്. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"നിങ്ങൾക്ക് ഒരു സ്ട്രിംഗ് s നൽകിയിരിക്കുന്നു. s[i] ഒരു അക്ഷരമാണെങ്കിൽ, അതിന്റെ കേസ് താഴേ നിന്ന് മുകളിലേക്ക് അല്ലെങ്കിൽ വിപരീതമായി മാറ്റുക, അല്ലെങ്കിൽ അത് പോലെ തന്നെ സൂക്ഷിക്കുക. സ്ട്രിംഗിൽ അക്ഷരങ്ങളൊന്നും അടങ്ങിയിട്ടില്ലെങ്കിൽ, സ്ട്രിംഗ് വിപരീതമാക്കുക. ഫംഗ്ഷൻ ഫലമായി സ്ട്രിംഗ് നൽകണം. ഉദാഹരണങ്ങൾ solve(\"1234\") = \"4321\" solve(\"ab\") = \"AB\" solve(\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"ഒരു സ്ട്രിംഗ് 'text' തന്നാൽ, അതിന്റെ md5 ഹാഷ് തുല്യമായ സ്ട്രിംഗ് മടക്കി നൽകുക. 'text' ഒരു ശൂന്യ സ്ട്രിംഗ് ആണെങ്കിൽ, None മടക്കി നൽകുക. >>> string_to_md5('ഹലോ വേൾഡ്') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "mal_Mlym",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയിട്ടുണ്ടെങ്കിൽ, a, b എന്നിവയ്ക്കിടയിലുള്ള സംഖ്യകളുടെ എണ്ണം വർദ്ധിക്കുന്ന ക്രമത്തിൽ നൽകുക. ഉദാഹരണത്തിന്: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]