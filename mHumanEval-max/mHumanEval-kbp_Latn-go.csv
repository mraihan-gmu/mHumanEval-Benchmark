task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,kbp_Latn,go_test.go,"package has_close_elements_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ kɩlɛmʋʋ yɔɔ.//Cɔnɩ se paa mayaɣ ŋga lɛ, kɛwɛna mayaɣ ŋga kɛwɛna kɩ-cɔlɔ yɔ nɛ pɩɖɛɛ  yɔɔ.// >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)
// false
// >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
// true
func has_close_elements(numbers []float64, threshold float64) bool {
","package has_close_elements_test

import (
	""math""
	""sort""
	""testing""
)

// Check if in given list of numbers, are any two numbers closer to each other than
// given threshold.
func has_close_elements(numbers []float64, threshold float64) bool {
	sort.Float64s(numbers)
	for i := 0; i < len(numbers)-1; i++ {
		if math.Abs(numbers[i+1]-numbers[i]) < threshold {
			return true
		}
	}
	return false
}

func TestHasCloseElements(t *testing.T) {
	testCases := []struct {
		numbers   []float64
		threshold float64
		expected  bool
	}{
		{[]float64{1.0, 2.0, 3.0}, 0.5, false},
		{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},
		{[]float64{1.5, 1.8, 2.2}, 0.3, true},
		{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},
	}

	for i, tc := range testCases {
		t.Run(fmt.Sprintf(""TestCase%d"", i+1), func(t *testing.T) {
			result := has_close_elements(tc.numbers, tc.threshold)
			if result != tc.expected {
				t.Errorf(""expected %v, got %v"", tc.expected, result)
			}
		})
	}
}","func TestHas_Close_Elements(t *testing.T) {
  candidate := has_close_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_1,kbp_Latn,go_test.go,"package separate_paren_groups_test

import (
    ""testing""
    ""fmt""
)

//Taawɛɛna kɩ-tɛ matʋ natʋyʋ.//Kpɛndɩɣna ɖama nɛ pɩfɛyɩna ɖama taa nɛ pɩfɛyɩna ɖama taa nɛ pɩfɛyɩna ɖama taa.//Pɩwɛɛ se ɖɩlɩzɩ tɔm ndʋ tɩ-taa nɛ ɖɩpɩsɩ-tʋ tɔm kɩsɔzɩtʋ.//Tʊma ana a-tɛ pɩlɩna ɛyʊ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm.// >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// []string{""()"", ""(())"", ""(()())""}
func separate_paren_groups(paren_string string) []string {
","package separate_paren_groups

func separate_paren_groups(paren_string string) []string {
	var result []string
	var currentGroup []rune
	openCount := 0

	for _, char := range paren_string {
		if char == '(' {
			openCount++
			currentGroup = append(currentGroup, char)
		} else if char == ')' {
			openCount--
			currentGroup = append(currentGroup, char)

			if openCount == 0 {
				result = append(result, string(currentGroup))
				currentGroup = nil
			}
		}
	}

	return result
}","func TestSeparate_Paren_Groups(t *testing.T) {
  candidate := separate_paren_groups
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""(()()) ((())) () ((())()())""), expected: []string{""(()())"", ""((()))"", ""()"", ""((())()())""} },
     { actual: candidate(""() (()) ((())) (((())))""), expected: []string{""()"", ""(())"", ""((()))"", ""(((())))""} },
     { actual: candidate(""(()(())((())))""), expected: []string{""(()(())((())))""} },
     { actual: candidate(""( ) (( )) (( )( ))""), expected: []string{""()"", ""(())"", ""(()())""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_2,kbp_Latn,go_test.go,"package truncate_number_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ: (C.1)//(Paa ɛzɩmtaa lɛ, pɩkazɩ hɔɔlʋʋ ŋgʋ kɩkɩlɩɣ 1 yɔ).//nɛ ɛyʊ hɔɔlʊʊ (ɛyʊ kɩlɩm hɔɔlʊʊ ŋgʊ kɩ-taa ɛfɛyɩ yɔ) nɛ decimals //Ye ɖɩkpaɣ nɛ ɖɩkpaɣ floatɩyɔm nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ.// >>> truncate_number(3.5)
// 0.5
func truncate_number(number float64) float64 {
","package truncate_number_test

import (
    ""testing""
    ""fmt""
)

// Given a positive floating point number, it can be decomposed into
// an integer part (largest integer smaller than given number) and decimals
// (leftover part always smaller than 1).
// Return the decimal part of the number.
// >>> truncate_number(3.5)
// 0.5
func truncate_number(number float64) float64 {
    integerPart := int(number)
    return number - float64(integerPart)
}

func TestTruncateNumber(t *testing.T) {
    testCases := []struct {
        input float64
        expected float64
    }{
        {3.5, 0.5},
        {0.0, 0.0},
        {7.25, 0.25},
        {4.99, 0.99},
        {2.0, 0.0},
    }

    for _, tc := range testCases {
        result := truncate_number(tc.input)
        if result != tc.expected {
            t.Errorf(""Expected %.2f, got %.2f"", tc.expected, result)
        }
    }
}

func main() {
    fmt.Println(truncate_number(3.5)) // Should print 0.5
    fmt.Println(truncate_number(7.25)) // Should print 0.25
}","func TestTruncate_Number(t *testing.T) {
  candidate := truncate_number
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3.5), expected: 0.5 },
     { actual: candidate(1.25), expected: 0.25 },
     { actual: candidate(123.0), expected: 0.0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_3,kbp_Latn,go_test.go,"package below_zero_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, pɩpɩsɩɣ false.//Pɩwɛɛ se ŋtɩlɩ mbʋ pɩ-yɔɔ ŋtɩŋna nɛ ŋla tʋmɩyɛ nɖɩ yɔ.//Pʊtɔbʊʊ se ŋwɛna liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ liidiye nɖɩ ɖɩ-tɛ.// >>> below_zero([]int{1, 2, 3})
// false
// >>> below_zero([]int{1, 2, -4, 5})
// true
func below_zero(operations []int) bool {
","package below_zero_test

import (
    ""testing""
    ""fmt""
)

func below_zero(operations []int) bool {
    balance := 0
    for _, op := range operations {
        balance += op
        if balance < 0 {
            return true
        }
    }
    return false
}

func TestBelowZero(t *testing.T) {
    testCases := []struct {
        operations []int
        expected   bool
    }{
        {[]int{1, 2, 3}, false},
        {[]int{1, 2, -4, 5}, true},
        {[]int{0, -1, 1}, true},
        {[]int{}, false},
        {[]int{-1, 1, -1, 1}, true},
    }
    for _, tc := range testCases {
        result := below_zero(tc.operations)
        if result != tc.expected {
            t.Errorf(""below_zero(%v) = %v; want %v"", tc.operations, result, tc.expected)
        }
    }
}","func TestBelow_Zero(t *testing.T) {
  candidate := below_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: false },
     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },
     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },
     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },
     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },
     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_4,kbp_Latn,go_test.go,"package mean_absolute_deviation_test

import (
    ""testing""
    ""fmt""
)

//MAD = average. x - x_mean. //Ɛyʊ nɛ ɛ-tɛ cɛcɛsɩ (ɛzɩma pɩwɛ yɔ, pɩkɛna ɛ-tɛ cɛcɛsɩ): //Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Pɩtɛ tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ yɔ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ yɔ.//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.// >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})
// 1.0
func mean_absolute_deviation(numbers []float64) float64 {
","package mean_absolute_deviation_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func mean_absolute_deviation(numbers []float64) float64 {
    var sum float64
    for _, num := range numbers {
        sum += num
    }
    mean := sum / float64(len(numbers))

    var madSum float64
    for _, num := range numbers {
        madSum += math.Abs(num - mean)
    }
    return madSum / float64(len(numbers))
}

func TestMeanAbsoluteDeviation(t *testing.T) {
    tests := []struct {
        input []float64
        want  float64
    }{
        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},
        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},
        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""mean_absolute_deviation(%v)"", test.input), func(t *testing.T) {
            got := mean_absolute_deviation(test.input)
            if got != test.want {
                t.Errorf(""mean_absolute_deviation(%v) = %v; want %v"", test.input, got, test.want)
            }
        })
    }
}","func TestMean_Absolute_Deviation(t *testing.T) {
  candidate := mean_absolute_deviation
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_5,kbp_Latn,go_test.go,"package intersperse_test

import (
    ""testing""
    ""fmt""
)

//Tɩŋgaŋ naalɛ weyi ɩ-taa paa weyi ɛ-hɩɖɛ wɛɛ yɔ, ŋpɩzɩɣ ŋma-ɩ nɛ ŋsɩɩ-ɩ ""delimite""// >>> intersperse([]int{}, 4)
// []int{}
// >>> intersperse([]int{1, 2, 3}, 4)
// []int{1, 4, 2, 4, 3}
func intersperse(numbers []int, delimeter int) []int {
","package intersperse_test

import (
    ""testing""
    ""fmt""
)

func intersperse(numbers []int, delimiter int) []int {
    if len(numbers) == 0 {
        return []int{}
    }

    result := make([]int, 0, len(numbers)*2-1)
    for i, num := range numbers {
        if i > 0 {
            result = append(result, delimiter)
        }
        result = append(result, num)
    }
    return result
}

func TestIntersperse(t *testing.T) {
    testCases := []struct{
        input []int
        delimiter int
        expected []int
    }{
        {[]int{}, 4, []int{}},
        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},
        {[]int{1}, 4, []int{1}},
        {[]int{1, 2}, 4, []int{1, 4, 2}},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf(""%v, %d"", tc.input, tc.delimiter), func(t *testing.T) {
            result := intersperse(tc.input, tc.delimiter)
            if !equal(result, tc.expected) {
                t.Errorf(""Expected %v, but got %v"", tc.expected, result)
            }
        })
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    
    return true
}","func TestIntersperse(t *testing.T) {
  candidate := intersperse
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}, 7), expected: []int{} },
     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },
     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_6,kbp_Latn,go_test.go,"package parse_nested_parens_test

import (
    ""testing""
    ""fmt""
)

//Ɖɩkpaɣ ɛzɩ (() (()) yɔ, pɩtalɩɣ nabʊlɛ nɛ pɩtalɩ nabʊlɛ nɛ ((())) lɛ, nabʊlɛ.//Paa samaɣ ŋga lɛ, ka-taa lɛ, ŋlɩzɩ ka-taa tɔm kɩcɛyɩtʋ ndʋ tɩ-taa ŋpɩzɩɣ nɛ ŋla yɔ.//Tʊma ana a-tɛ pɩlɩna ɛyʊ kʊyʊmʊm yɔɔ nɛ ɛ-tɛ kʊyʊmʊm tɛ kʊyʊmʊm yɔɔ.// >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// []int{2, 3, 1, 3}
func parse_nested_parens(paren_string string) []int {
","func parse_nested_parens(paren_string string) []int {
    groups := strings.Fields(paren_string)
    depths := make([]int, len(groups))

    for i, group := range groups {
        maxDepth, currentDepth := 0, 0
        for _, char := range group {
            if char == '(' {
                currentDepth++
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == ')' {
                currentDepth--
            }
        }
        depths[i] = maxDepth
    }

    return depths
}","func TestParse_Nested_Parens(t *testing.T) {
  candidate := parse_nested_parens
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""(()()) ((())) () ((())()())""), expected: []int{2, 3, 1, 3} },
     { actual: candidate(""() (()) ((())) (((())))""), expected: []int{1, 2, 3, 4} },
     { actual: candidate(""(()(())((())))""), expected: []int{4} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_7,kbp_Latn,go_test.go,"package filter_by_substring_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ takayɩhayʋʋ kɩfalʋʋ nakʋyʋ yɔɔ nɛ ŋna-ɩ kɩ-tɛɛ.// >>> filter_by_substring([]string{}, ""a"")
// []string{}
// >>> filter_by_substring([]string{""abc"", ""bacd"", ""cde"", ""array""}, ""a"")
// []string{""abc"", ""bacd"", ""array""}
func filter_by_substring(strings []string, substring string) []string {
","package filter_by_substring_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func filter_by_substring(strings []string, substring string) []string {
    var result []string
    for _, str := range strings {
        if strings.Contains(str, substring) {
            result = append(result, str)
        }
    }
    return result
}

func TestFilterBySubstring(t *testing.T) {
    tests := []struct {
        input    []string
        substring string
        expected []string
    }{
        {[]string{}, ""a"", []string{}},
        {[]string{""abc"", ""bacd"", ""cde"", ""array""}, ""a"", []string{""abc"", ""bacd"", ""array""}},
    }

    for _, test := range tests {
        result := filter_by_substring(test.input, test.substring)
        if fmt.Sprintf(""%q"", result) != fmt.Sprintf(""%q"", test.expected) {
            t.Errorf(""filter_by_substring(%q, %q) = %q; expected %q"", test.input, test.substring, result, test.expected)
        }
    }
}","func TestFilter_By_Substring(t *testing.T) {
  candidate := filter_by_substring
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, ""john""), expected: []string{} },
     { actual: candidate([]string{""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xxx""), expected: []string{""xxx"", ""xxxAAA"", ""xxx""} },
     { actual: candidate([]string{""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xx""), expected: []string{""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""} },
     { actual: candidate([]string{""grunt"", ""trumpet"", ""prune"", ""gruesome""}, ""run""), expected: []string{""grunt"", ""prune""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_8,kbp_Latn,go_test.go,"package sum_product_test

import (
    ""testing""
    ""fmt""
)

//Pɩwɛɛ se pɛtɛyɩ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ.//Pɩtɛ lɛ, ŋtɛzɩna-ɩ nɛ ŋtɛ lɛ, ŋtɛzɩ-ɩ nɛ ŋtɛ lɛ, ŋtɛ lɛ, ŋtɛ lɛ, ŋtɛ lɛ, ŋtɛ lɛ, ŋtɛ lɛ.// >>> sum_product([]int{})
// []interface{}{0, 1}
// >>> sum_product([]int{1, 2, 3, 4})
// []interface{}{10, 24}
func sum_product(numbers []int) []interface{} {
","func sum_product(numbers []int) []interface{} {
    sum := 0
    product := 1
    for _, number := range numbers {
        sum += number
        product *= number
    }
    return []interface{}{sum, product}
}","func TestSum_Product(t *testing.T) {
  candidate := sum_product
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []interface{}{0, 1} },
     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },
     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },
     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },
     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_9,kbp_Latn,go_test.go,"package rolling_max_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɩmʋna se ŋla mbʋ.//Pɩlɩʋ taa lɛ, pamaɣna ɛyʊ ɛ-tʊmɩyɛ labʊ nɛ pɩkɔɔ pɩtalɩ alɩwaatʋ ndʋ tɩ-taa ɛ-tʊmɩyɛ labʊ paɣzɩ yɔ.// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})
// []int{1, 2, 3, 3, 3, 4, 4}
func rolling_max(numbers []int) []int {
","package rolling_max_test

import (
    ""testing""
    ""fmt""
)

// From a given list of integers, generate a list of rolling maximum element found until given moment
// in the sequence.
// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})
// []int{1, 2, 3, 3, 3, 4, 4}
func rolling_max(numbers []int) []int {
    if len(numbers) == 0 {
        return []int{}
    }
    result := make([]int, len(numbers))
    maxSoFar := numbers[0]
    for i, num := range numbers {
        if num > maxSoFar {
            maxSoFar = num
        }
        result[i] = maxSoFar
    }
    return result
}

func TestRollingMax(t *testing.T) {
    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) // should output []int{1, 2, 3, 3, 3, 4, 4}
}","func TestRolling_Max(t *testing.T) {
  candidate := rolling_max
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },
     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },
     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_10,kbp_Latn,go_test.go,"package make_palindrome_test

import (
    ""testing""
    ""fmt""
)

//- Tɩŋgaɣ nɛ ŋtɛzɩna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.//- Wɩlɩ ɛzɩma ŋpɩzɩɣ ŋla nɛ ŋtɛzɩna tɔmpiye nɖɩ ɖɩ-taa ŋtɩŋna yɔ.//Pɩtɛ lɛ, ɛyʊ ɛ-tɛ tɔm kpɛlɛkʊʊ tʊmɩyɛ kɛlɛ://Ñɩnɩ palindrome kɩpɩɣlʋʋ ŋgʋ kɩpaɣzɩɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ.// >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
func make_palindrome(myString string) string {
","package make_palindrome_test

import (
    ""testing""
)

func make_palindrome(myString string) string {
    if len(myString) <= 1 {
        return myString
    }
    
    // Helper function to check if a string is a palindrome
    isPalindrome := func(s string) bool {
        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
            if s[i] != s[j] {
                return false
            }
        }
        return true
    }

    // Start from the whole string and reduce until we find a palindrome
    for i := len(myString); i > 0; i-- {
        if isPalindrome(myString[len(myString)-i:]) {
            prefix := myString[:len(myString)-i]
            // Reverse the prefix and append to original string
            reversedPrefix := reverse(prefix)
            return myString + reversedPrefix
        }
    }

    // If no palindromic suffix is found, return original string with reverse appended
    return myString + reverse(myString)
}

// Helper function to reverse a string
func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func TestMakePalindrome(t *testing.T) {
    tests := []struct {
        input    string
        expected string
    }{
        {"""", """"},
        {""cat"", ""catac""},
        {""cata"", ""catac""},
    }

    for _, test := range tests {
        result := make_palindrome(test.input)
        if result != test.expected {
            t.Errorf(""make_palindrome(%q) = %q; expected %q"", test.input, result, test.expected)
        }
    }
}","func TestMake_Palindrome(t *testing.T) {
  candidate := make_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""x""), expected: ""x"" },
     { actual: candidate(""xyz""), expected: ""xyzyx"" },
     { actual: candidate(""xyx""), expected: ""xyx"" },
     { actual: candidate(""jerry""), expected: ""jerryrrej"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_11,kbp_Latn,go_test.go,"package string_xor_test

import (
    ""testing""
    ""fmt""
)

//Palakɩ XOR binary tɔm nɛ pɩpɩsɩɣ ɖɔɖɔ pɩ-tɛ lɩmaɣzɩyɛ ɛzɩ tɔmpiye yɔ.//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.// >>> string_xor(""010"", ""110"")
// ""100""
func string_xor(a string, b string) string {
","result := make([]byte, len(a))
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			result[i] = '0'
		} else {
			result[i] = '1'
		}
	}
	return string(result)
}","func TestString_Xor(t *testing.T) {
  candidate := string_xor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""111000"", ""101010""), expected: ""010010"" },
     { actual: candidate(""1"", ""1""), expected: ""0"" },
     { actual: candidate(""0101"", ""0000""), expected: ""0101"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_13,kbp_Latn,go_test.go,"package greatest_common_divisor_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ// >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
func greatest_common_divisor(a int, b int) int {
","package greatest_common_divisor_test

import (
    ""testing""
    ""fmt""
)

// Return a greatest common divisor of two integers a and b
// >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
func greatest_common_divisor(a int, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func TestGreatestCommonDivisor(t *testing.T) {
    tests := []struct {
        a, b   int
        expect int
    }{
        {3, 5, 1},
        {25, 15, 5},
        {54, 24, 6},
        {48, 18, 6},
        {101, 103, 1},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d,%d"", test.a, test.b), func(t *testing.T) {
            result := greatest_common_divisor(test.a, test.b)
            if result != test.expect {
                t.Errorf(""expected %d, got %d"", test.expect, result)
            }
        })
    }
}","func TestGreatest_Common_Divisor(t *testing.T) {
  candidate := greatest_common_divisor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 7), expected: 1 },
     { actual: candidate(10, 15), expected: 5 },
     { actual: candidate(49, 14), expected: 7 },
     { actual: candidate(144, 60), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_14,kbp_Latn,go_test.go,"package all_prefixes_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:// >>> all_prefixes(""abc"")
// []string{""a"", ""ab"", ""abc""}
func all_prefixes(myString string) []string {
","package all_prefixes_test

import (
    ""testing""
    ""fmt""
)

// Return list of all prefixes from shortest to longest of the input string
// >>> all_prefixes(""abc"")
// []string{""a"", ""ab"", ""abc""}
func all_prefixes(myString string) []string {
    var prefixes []string
    for i := 1; i <= len(myString); i++ {
        prefixes = append(prefixes, myString[:i])
    }
    return prefixes
}

func TestAllPrefixes(t *testing.T) {
    result := all_prefixes(""abc"")
    expected := []string{""a"", ""ab"", ""abc""}
    for i, v := range result {
        if v != expected[i] {
            t.Errorf(""Test failed, expected %v, got %v"", expected[i], v)
        }
    }
    fmt.Println(""Test passed"")
}","func TestAll_Prefixes(t *testing.T) {
  candidate := all_prefixes
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: []string{} },
     { actual: candidate(""asdfgh""), expected: []string{""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""} },
     { actual: candidate(""WWW""), expected: []string{""W"", ""WW"", ""WWW""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_15,kbp_Latn,go_test.go,"package string_sequence_test

import (
    ""testing""
    ""fmt""
)

//Pɩpɩsɩɣ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ.// >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
func string_sequence(n int) string {
","package string_sequence_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
func string_sequence(n int) string {
    var parts []string
    for i := 0; i <= n; i++ {
        parts = append(parts, fmt.Sprintf(""%d"", i))
    }
    return strings.Join(parts, "" "")
}

func TestStringSequence(t *testing.T) {
    result := string_sequence(0)
    expected := ""0""
    if result != expected {
        t.Errorf(""Expected %s, got %s"", expected, result)
    }
    
    result = string_sequence(5)
    expected = ""0 1 2 3 4 5""
    if result != expected {
        t.Errorf(""Expected %s, got %s"", expected, result)
    }
}","func TestString_Sequence(t *testing.T) {
  candidate := string_sequence
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0), expected: ""0"" },
     { actual: candidate(3), expected: ""0 1 2 3"" },
     { actual: candidate(10), expected: ""0 1 2 3 4 5 6 7 8 9 10"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_16,kbp_Latn,go_test.go,"package count_distinct_characters_test

import (
    ""testing""
    ""fmt""
)

//Ye ŋha-ɖʋ tɔm piye naɖɩyɛ lɛ, ɖɩpɔzɩ-ŋ se ɛzɩma ɖɩ-taa wɛ tɔm pee ndɩ ndɩ yɔ.// >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
func count_distinct_characters(myString string) int {
","package count_distinct_characters_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func count_distinct_characters(myString string) int {
    characterMap := make(map[rune]bool)
    for _, char := range strings.ToLower(myString) {
        characterMap[char] = true
    }
    return len(characterMap)
}

func TestCountDistinctCharacters(t *testing.T) {
    testCases := []struct{
        input string
        expected int
    }{
        {""xyzXYZ"", 3},
        {""Jerry"", 4},
        {"""", 0},
        {""Hello, World!"", 10},
    }

    for _, testCase := range testCases {
        result := count_distinct_characters(testCase.input)
        if result != testCase.expected {
            t.Errorf(""For input '%s', expected %d but got %d"", testCase.input, testCase.expected, result)
        } else {
            fmt.Printf(""Test passed for input '%s': got %d\n"", testCase.input, result)
        }
    }
}","func TestCount_Distinct_Characters(t *testing.T) {
  candidate := count_distinct_characters
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""abcde""), expected: 5 },
     { actual: candidate(""abcdecadeCADE""), expected: 5 },
     { actual: candidate(""aaaaAAAAaaaa""), expected: 1 },
     { actual: candidate(""Jerry jERRY JeRRRY""), expected: 5 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_17,kbp_Latn,go_test.go,"package parse_music_test

import (
    ""testing""
    ""fmt""
)

//'Nɔɔ kʋɖʋmaɣ' - Nɔɔ kʋɖʋmaɣ ŋga kɛwɛ hɔɔlɩŋ naanza taa yɔ, kɛwɛ tam kʋɖʋm.//'O sa' - hɔɔlɩŋ naalɛ, pɩlakɩ tam naalɛ.//'O' - hendu tɩŋa, pɩlakɩ tam naanza //Kɩɖaʋ kʋnɛ kɩ-tɔm pɔyɔɔdʋʋ://Pɩtɩkɛ kɛdɛzaɣ ñɩŋga.//Ña-tʋmɩyɛ lɛ se ŋtazɩ tɔmpiye ɖɩnɛ nɛ ŋpɩsɩna nimero waa mba pa-taa paa weyi ɛ-taa ɛ-tɛ tɔmpiye nɖɩ ɖɩ-taa yɔ.//Tʊma ana a-taa lɛ, pɔcɔna nɛ pana se a-taa lɛ, minziiki wondu wɛna nɛ tɩwɛɛna ASCII.// >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
func parse_music(music_string string) []int {
","package parse_music_test

import (
    ""strings""
)

func parse_music(music_string string) []int {
    notes := strings.Fields(music_string)
    beats := make([]int, len(notes))
    for i, note := range notes {
        switch note {
        case ""o"":
            beats[i] = 4
        case ""o|"":
            beats[i] = 2
        case "".|"":
            beats[i] = 1
        }
    }
    return beats
}","func TestParse_Music(t *testing.T) {
  candidate := parse_music
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: []int{} },
     { actual: candidate(""o o o o""), expected: []int{4, 4, 4, 4} },
     { actual: candidate("".| .| .| .|""), expected: []int{1, 1, 1, 1} },
     { actual: candidate(""o| o| .| .| o o o o""), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },
     { actual: candidate(""o| .| o| .| o o| o o|""), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_18,kbp_Latn,go_test.go,"package how_many_times_test

import (
    ""testing""
    ""fmt""
)

//Ñɩnɩ tam ɛzɩma pɩpɩzɩɣ nɛ pana tɔmpiye naɖɩyɛ kajalaɣ tɔmpiye taa yɔ.// >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
func how_many_times(myString string, substring string) int {
","func how_many_times(myString string, substring string) int {
    if len(substring) == 0 {
        return 0
    }

    count := 0
    for i := 0; i <= len(myString)-len(substring); i++ {
        if myString[i:i+len(substring)] == substring {
            count++
        }
    }
    return count
}

func TestHowManyTimes(t *testing.T) {
    tests := []struct {
        myString  string
        substring string
        expected  int
    }{
        {"""", ""a"", 0},
        {""aaa"", ""a"", 3},
        {""aaaa"", ""aa"", 3},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%s in %s"", test.substring, test.myString), func(t *testing.T) {
            result := how_many_times(test.myString, test.substring)
            if result != test.expected {
                t.Errorf(""Expected %d but got %d"", test.expected, result)
            }
        })
    }
}","func TestHow_Many_Times(t *testing.T) {
  candidate := how_many_times
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate("""", ""x""), expected: 0 },
     { actual: candidate(""xyxyxyx"", ""x""), expected: 4 },
     { actual: candidate(""cacacacac"", ""cac""), expected: 4 },
     { actual: candidate(""john doe"", ""john""), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_19,kbp_Latn,go_test.go,"package sort_numbers_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ takayɩhayʋʋ kɩgbanzɩ ñɩŋgʋ yɔɔ .//Pɩpɩzɩɣ nɛ pɩla se ŋlɩzɩ ""zéro"", ""un"", ""deux"", ""trois"", ""quatre"", ""cinq"", ""six"", ""sept"", ""huit"" nɛ ""neuf"".//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.// >>> sort_numbers(""three one five"")
// ""one three five""
func sort_numbers(numbers string) string {
","package sort_numbers_test

import (
    ""strings""
    ""sort""
)

func sort_numbers(numbers string) string {
    wordsToNumbers := map[string]int{
        ""zero"":  0,
        ""one"":   1,
        ""two"":   2,
        ""three"": 3,
        ""four"":  4,
        ""five"":  5,
        ""six"":   6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"":  9,
    }
    
    numbersToWords := []string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""}
    
    words := strings.Fields(numbers)
    numberInts := make([]int, len(words))
    
    for i, word := range words {
        numberInts[i] = wordsToNumbers[word]
    }
    
    sort.Ints(numberInts)
    
    sortedWords := make([]string, len(words))
    for i, num := range numberInts {
        sortedWords[i] = numbersToWords[num]
    }
    
    return strings.Join(sortedWords, "" "")
}","func TestSort_Numbers(t *testing.T) {
  candidate := sort_numbers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""three""), expected: ""three"" },
     { actual: candidate(""three five nine""), expected: ""three five nine"" },
     { actual: candidate(""five zero four seven nine eight""), expected: ""zero four five seven eight nine"" },
     { actual: candidate(""six five four three two one zero""), expected: ""zero one two three four five six"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_20,kbp_Latn,go_test.go,"package find_closest_elements_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, ŋpɩzɩɣ nɛ ŋlɩzɩ-wɛ nɛ ŋyele nɛ patɩŋnɩ pa-taa paa weyi ɛ-yɔɔ.//Pɩtɛ nimero waa mba pa-taa lɛ, (mba pa-taa lɛ, pa-taa naalɛ fɛyɩ kɩmaŋ yɔ) palɩzɩ nɛ papɩsɩnɩ naalɛ mba pɔñɔtɩnɩ paa weyi yɔ.// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})
// []interface{}{2.0, 2.2}
// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})
// []interface{}{2.0, 2.0}
func find_closest_elements(numbers []float64) []interface{} {
","package find_closest_elements_test

import (
    ""math""
    ""sort""
)

func find_closest_elements(numbers []float64) []interface{} {
    if len(numbers) < 2 {
        return nil
    }
    
    // Create a sorted copy of the numbers
    sortedNumbers := make([]float64, len(numbers))
    copy(sortedNumbers, numbers)
    sort.Float64s(sortedNumbers)
    
    // Initialize the minimum difference and result
    minDiff := math.MaxFloat64
    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}
    
    // Iterate over the sorted numbers to find the closest pair
    for i := 1; i < len(sortedNumbers); i++ {
        diff := sortedNumbers[i] - sortedNumbers[i-1]
        if diff < minDiff {
            minDiff = diff
            result[0] = sortedNumbers[i-1]
            result[1] = sortedNumbers[i]
        }
    }
    
    return result
}","func TestFind_Closest_Elements(t *testing.T) {
  candidate := find_closest_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_21,kbp_Latn,go_test.go,"package rescale_to_unit_test

import (
    ""testing""
    ""fmt""
)

//mbʊ pʊyɔɔ yɔ, pʊtʊ weyi ɛkɩlɩ tɔyʊʊ yɔ ɛkaɣ pɩsʋʋ 0 nɛ weyi ɛkɩlɩ tɔyʊʊ yɔ ɛkaɣ pɩsʋʋ 1 .//Ye ŋwɛna nimbrɩwaa mba pa-taa kɔyɔ, ŋpɩzɩɣ ŋlabɩnɩ tʋmɩyɛ nimbrɩwaa mba pa-taa lɛ, // >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})
// []float64{0.0, 0.25, 0.5, 0.75, 1.0}
func rescale_to_unit(numbers []float64) []float64 {
","package rescale_to_unit_test

import (
	""testing""
	""fmt""
)

func rescale_to_unit(numbers []float64) []float64 {
	if len(numbers) < 2 {
		return numbers
	}
	
	minVal := numbers[0]
	maxVal := numbers[0]
	for _, num := range numbers {
		if num < minVal {
			minVal = num
		} else if num > maxVal {
			maxVal = num
		}
	}

	scale := maxVal - minVal
	if scale == 0 {
		return make([]float64, len(numbers))
	}

	rescaled := make([]float64, len(numbers))
	for i, num := range numbers {
		rescaled[i] = (num - minVal) / scale
	}

	return rescaled
}

func TestRescaleToUnit(t *testing.T) {
	tests := []struct {
		input    []float64
		expected []float64
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},
		{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},
		{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},
		{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},
	}

	for _, test := range tests {
		result := rescale_to_unit(test.input)
		for i, v := range result {
			if v != test.expected[i] {
				t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
				break
			}
		}
	}
}","func TestRescale_To_Unit(t *testing.T) {
  candidate := rescale_to_unit
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },
     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },
     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },
     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_22,kbp_Latn,go_test.go,"package filter_integers_test

import (
    ""testing""
    ""fmt""
)

//Pɩlɩʋ \\ Lɩmaɣza \\ takayɩhatʋ \\ takayɩhatʋ// >>> filter_integers([]float64{""a"", 3.14, 5})
// []int{5}
// >>> filter_integers([]interface{}{1, 2, 3, ""abc"", map[interface{}]interface{}{}, []interface{}{}})
// []int{1, 2, 3}
func filter_integers(values []interface{}) []int {
","func filter_integers(values []interface{}) []int {
    var result []int
    for _, v := range values {
        if intValue, ok := v.(int); ok {
            result = append(result, intValue)
        }
    }
    return result
}

func TestFilterIntegers(t *testing.T) {
    cases := []struct {
        input    []interface{}
        expected []int
    }{
        {
            input:    []interface{}{1, 2, 3, ""abc"", map[interface{}]interface{}{}, []interface{}{}},
            expected: []int{1, 2, 3},
        },
        {
            input:    []interface{}{""a"", 3.14, 5},
            expected: []int{5},
        },
    }

    for _, c := range cases {
        result := filter_integers(c.input)
        if !equal(result, c.expected) {
            t.Errorf(""filter_integers(%v) == %v, expected %v"", c.input, result, c.expected)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}","func TestFilter_Integers(t *testing.T) {
  candidate := filter_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]interface{}{}), expected: []int{} },
     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, ""adasd""}), expected: []int{4, 9} },
     { actual: candidate([]interface{}{3, ""c"", 3, 3, ""a"", ""b""}), expected: []int{3, 3, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_23,kbp_Latn,go_test.go,"package strlen_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ takayɩhayʋʋ Kpɩnɛ ñɩŋgʋ yɔɔ // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
func strlen(myString string) int {
","return len(myString)
}","func TestStrlen(t *testing.T) {
  candidate := strlen
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""x""), expected: 1 },
     { actual: candidate(""asdasnakj""), expected: 9 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_24,kbp_Latn,go_test.go,"package largest_divisor_test

import (
    ""testing""
    ""fmt""
)

//Pɩcɔ nɛ ŋtɩlɩ n mayaɣ kɔyɔ, ŋñɩnɩɣ mayaɣ ŋga kɛwɛna n yɔɔ yɔ, ŋga kakɩlɩ n yɔɔ yɔ.// >>> largest_divisor(15)
// 5
func largest_divisor(n int) int {
","package largest_divisor_test

import (
    ""testing""
    ""fmt""
)

// For a given number n, find the largest number that divides n evenly, smaller than n
// >>> largest_divisor(15)
// 5
func largest_divisor(n int) int {
    for i := n/2; i > 0; i-- {
        if n%i == 0 {
            return i
        }
    }
    return 1
}

func TestLargestDivisor(t *testing.T) {
    cases := []struct {
        input    int
        expected int
    }{
        {15, 5},
        {100, 50},
        {49, 7},
        {81, 27},
        {1, 1},
    }

    for _, c := range cases {
        result := largest_divisor(c.input)
        if result != c.expected {
            t.Errorf(""largest_divisor(%d) == %d, expected %d"", c.input, result, c.expected)
        }
    }
}

func main() {
    fmt.Println(largest_divisor(15))
}","func TestLargest_Divisor(t *testing.T) {
  candidate := largest_divisor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: 1 },
     { actual: candidate(7), expected: 1 },
     { actual: candidate(10), expected: 5 },
     { actual: candidate(100), expected: 50 },
     { actual: candidate(49), expected: 7 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_25,kbp_Latn,go_test.go,"package factorize_test

import (
    ""testing""
    ""fmt""
)

//Pɩwɛɛ se ɖɩkpaɣ kɩ-tɛ tɔmpiye nɛ ɖɩkpaɣ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ.//Pɩwɛɛ se pamaɣ paa tɔmpiye nɖɩ lɛ tam sakɩyɛ ɛzɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ.//Ɛtɛyɩɣ ɛ-tɛ kajalaɣ hɔɔlɩŋ weyi ɛ-taa ɛ-tɛ hɔɔlɩŋ sɔsɔŋ wɛɛ yɔ.// >>> factorize(8)
// []int{2, 2, 2}
// >>> factorize(25)
// []int{5, 5}
// >>> factorize(70)
// []int{2, 5, 7}
func factorize(n int) []int {
","package factorize

func factorize(n int) []int {
	var factors []int
	for i := 2; i*i <= n; i++ {
		for n%i == 0 {
			factors = append(factors, i)
			n /= i
		}
	}
	if n > 1 {
		factors = append(factors, n)
	}
	return factors
}","func TestFactorize(t *testing.T) {
  candidate := factorize
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: []int{2} },
     { actual: candidate(4), expected: []int{2, 2} },
     { actual: candidate(8), expected: []int{2, 2, 2} },
     { actual: candidate(57), expected: []int{3, 19} },
     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },
     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },
     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },
     { actual: candidate(18), expected: []int{2, 3, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_26,kbp_Latn,go_test.go,"package remove_duplicates_test

import (
    ""testing""
    ""fmt""
)

//Pɩwɛɛ se ɖɩɖɔkɩ mbʋ ɖɩɖʋwa yɔ, mbʋ ɖɔɖɔ ɖɩɖʋwa yɔ.//Pɩtɛ lɛ, ɖɩkpaɣ kɩlɛmʋʋ ŋgʋ kɩ-taa ɖɩnaɣ kɩlɛmʋʋ kʋnɛ yɔ nɛ ɖɩlɩzɩ kɩ-taa tɔm ndʋ tɩ-tɩŋa payɩ tɩ-taa ɖɩnaɣ kɩlɛmʋʋ kʋnɛ yɔ.// >>> remove_duplicates([]int{1, 2, 3, 2, 4})
// []int{1, 3, 4}
func remove_duplicates(numbers []int) []int {
","package remove_duplicates_test

import (
	""testing""
	""fmt""
)

func remove_duplicates(numbers []int) []int {
	counts := make(map[int]int)
	for _, num := range numbers {
		counts[num]++
	}

	result := []int{}
	for _, num := range numbers {
		if counts[num] == 1 {
			result = append(result, num)
		}
	}
	return result
}

func TestRemoveDuplicates(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},
		{[]int{1, 1, 1, 1}, []int{}},
		{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},
		{[]int{5, 5, 5, 6}, []int{6}},
		{[]int{9, 8, 9, 8, 7}, []int{7}},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""remove_duplicates(%v)"", test.input), func(t *testing.T) {
			result := remove_duplicates(test.input)
			if len(result) != len(test.expected) {
				t.Errorf(""Expected length %d, got %d"", len(test.expected), len(result))
			}
			for i, v := range result {
				if v != test.expected[i] {
					t.Errorf(""Expected %v, got %v"", test.expected, result)
					break
				}
			}
		})
	}
}","func TestRemove_Duplicates(t *testing.T) {
  candidate := remove_duplicates
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },
     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_27,kbp_Latn,go_test.go,"package flip_case_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ matʋ ndʋ tɩ-taa, ŋlɛɣzɩ matʋ cikpetu nɛ ŋlɛɣzɩ matʋ sɔsɔtʋ nɛ ŋlɛɣzɩ matʋ sɔsɔtʋ nɛ ŋlɛɣzɩ matʋ cikpetu.// >>> flip_case(""Hello"")
// ""hELLO""
func flip_case(myString string) string {
","func flip_case(myString string) string {
	var result []rune
	for _, char := range myString {
		if char >= 'a' && char <= 'z' {
			result = append(result, char-('a'-'A'))
		} else if char >= 'A' && char <= 'Z' {
			result = append(result, char+('a'-'A'))
		} else {
			result = append(result, char)
		}
	}
	return string(result)
}","func TestFlip_Case(t *testing.T) {
  candidate := flip_case
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""Hello!""), expected: ""hELLO!"" },
     { actual: candidate(""These violent delights have violent ends""), expected: ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_28,kbp_Latn,go_test.go,"package concatenate_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ takayɩhayʋʋ Kpaŋʊʊ kʊyʊmaɣ ñɩŋgʋ yɔɔ// >>> concatenate([]string{})
// """"
// >>> concatenate([]string{""a"", ""b"", ""c""})
// ""abc""
func concatenate(strings []string) string {
","result := """"
    for _, str := range strings {
        result += str
    }
    return result
}","func TestConcatenate(t *testing.T) {
  candidate := concatenate
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}), expected: """" },
     { actual: candidate([]string{""x"", ""y"", ""z""}), expected: ""xyz"" },
     { actual: candidate([]string{""x"", ""y"", ""z"", ""w"", ""k""}), expected: ""xyzwk"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_29,kbp_Latn,go_test.go,"package filter_by_prefix_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.// >>> filter_by_prefix([]string{}, ""a"")
// []string{}
// >>> filter_by_prefix([]string{""abc"", ""bcd"", ""cde"", ""array""}, ""a"")
// []string{""abc"", ""array""}
func filter_by_prefix(strings []string, prefix string) []string {
","package filter_by_prefix_test

import (
    ""testing""
)

// Filter an input list of strings only for ones that start with a given prefix.
func filter_by_prefix(strings []string, prefix string) []string {
    var result []string
    for _, str := range strings {
        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {
            result = append(result, str)
        }
    }
    return result
}

func TestFilterByPrefix(t *testing.T) {
    tests := []struct {
        input    []string
        prefix   string
        expected []string
    }{
        {[]string{}, ""a"", []string{}},
        {[]string{""abc"", ""bcd"", ""cde"", ""array""}, ""a"", []string{""abc"", ""array""}},
        {[]string{""hello"", ""helium"", ""world""}, ""he"", []string{""hello"", ""helium""}},
        {[]string{""banana"", ""band"", ""bandana""}, ""ban"", []string{""banana"", ""band"", ""bandana""}},
        {[]string{""apple"", ""ape"", ""apricot""}, ""ap"", []string{""apple"", ""ape"", ""apricot""}},
    }

    for _, test := range tests {
        result := filter_by_prefix(test.input, test.prefix)
        if !equal(result, test.expected) {
            t.Errorf(""filter_by_prefix(%v, %s) = %v; expected %v"", test.input, test.prefix, result, test.expected)
        }
    }
}

func equal(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestFilter_By_Prefix(t *testing.T) {
  candidate := filter_by_prefix
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, ""john""), expected: []string{} },
     { actual: candidate([]string{""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xxx""), expected: []string{""xxx"", ""xxxAAA"", ""xxx""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_30,kbp_Latn,go_test.go,"package get_positive_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ tɔm kɩsɔzɩtʋ// >>> get_positive([]int{-1, 2, -4, 5, 6})
// []int{2, 5, 6}
// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// []int{5, 3, 2, 3, 9, 123, 1}
func get_positive(l []int) []int {
","package get_positive_test

import (
    ""testing""
    ""fmt""
)

// Return only positive numbers in the list.
func get_positive(l []int) []int {
    var positiveNumbers []int
    for _, num := range l {
        if num > 0 {
            positiveNumbers = append(positiveNumbers, num)
        }
    }
    return positiveNumbers
}

func TestGetPositive(t *testing.T) {
    tests := []struct {
        input  []int
        output []int
    }{
        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},
        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},
    }
    
    for _, test := range tests {
        result := get_positive(test.input)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", test.output) {
            t.Errorf(""Expected %v, got %v"", test.output, result)
        }
    }
}","func TestGet_Positive(t *testing.T) {
  candidate := get_positive
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },
     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },
     { actual: candidate([]int{-1, -2}), expected: []int{} },
     { actual: candidate([]int{}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_31,kbp_Latn,go_test.go,"package is_prime_test

import (
    ""testing""
    ""fmt""
)

//Ye nimero waa nabɛyɛ ɩkɛ kajalaɣ mba yɔ, pɩpɩsɩɣ toovenim nɛ ye pɩtɛkɛ mbʋ yɔ, pɩkɛ cɛtɩm.// >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
func is_prime(n int) bool {
","package is_prime_test

import (
    ""testing""
    ""fmt""
)

func is_prime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func TestIsPrime(t *testing.T) {
    testCases := []struct {
        number   int
        expected bool
    }{
        {6, false},
        {101, true},
        {11, true},
        {13441, true},
        {61, true},
        {4, false},
        {1, false},
    }

    for _, testCase := range testCases {
        result := is_prime(testCase.number)
        if result != testCase.expected {
            t.Errorf(""is_prime(%d) = %v; want %v"", testCase.number, result, testCase.expected)
        } else {
            fmt.Printf(""Test Passed: is_prime(%d) = %v\n"", testCase.number, result)
        }
    }
}","func TestIs_Prime(t *testing.T) {
  candidate := is_prime
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(6), expected: false },
     { actual: candidate(101), expected: true },
     { actual: candidate(11), expected: true },
     { actual: candidate(13441), expected: true },
     { actual: candidate(61), expected: true },
     { actual: candidate(4), expected: false },
     { actual: candidate(1), expected: false },
     { actual: candidate(5), expected: true },
     { actual: candidate(11), expected: true },
     { actual: candidate(17), expected: true },
     { actual: candidate(85), expected: false },
     { actual: candidate(77), expected: false },
     { actual: candidate(255379), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_33,kbp_Latn,go_test.go,"package sort_third_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, pɛtɛyɩ-ɩ nɛ ɛ-tɛ lɛɣtʋ kɩfatʋ.//l' wɛ ɛzɩ l yɔ, yee ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ//Tʊma ana a-taa lɛ, pakpaɣ mayaɣ l nɛ papɩsɩna mayaɣ l' ŋgʊ kɩ-taa // >>> sort_third([]int{1, 2, 3})
// []int{1, 2, 3}
// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})
// []int{2, 6, 3, 4, 8, 9, 5}
func sort_third(l []int) []int {
","package sort_third_test

import (
    ""sort""
)

func sort_third(l []int) []int {
    type pair struct {
        index int
        value int
    }

    // Collect the pairs where indices are divisible by 3
    sortSection := []pair{}

    for i := 0; i < len(l); i++ {
        if i%3 == 0 {
            sortSection = append(sortSection, pair{index: i, value: l[i]})
        }
    }

    // Sort this section based on the values
    sort.Slice(sortSection, func(i, j int) bool {
        return sortSection[i].value < sortSection[j].value
    })

    // Generate result slice
    result := make([]int, len(l))
    copy(result, l)

    // Fill the sorted values back to the result
    for _, p := range sortSection {
        result[p.index] = p.value
    }

    return result
}","func TestSort_Third(t *testing.T) {
  candidate := sort_third
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },
     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },
     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },
     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_34,kbp_Latn,go_test.go,"package unique_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ takayɩhayʋʋ kɩfalʋʋ nakʋyʋ yɔɔ .// >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{0, 2, 3, 5, 9, 123}
func unique(l []int) []int {
","package unique_test

import (
    ""sort""
)

func unique(l []int) []int {
    uniqueMap := make(map[int]bool)
    for _, value := range l {
        uniqueMap[value] = true
    }

    uniqueSlice := make([]int, 0, len(uniqueMap))
    for key := range uniqueMap {
        uniqueSlice = append(uniqueSlice, key)
    }

    sort.Ints(uniqueSlice)
    return uniqueSlice
}","func TestUnique(t *testing.T) {
  candidate := unique
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_35,kbp_Latn,go_test.go,"package max_element_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ// >>> max_element([]int{1, 2, 3})
// 3
// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// 123
func max_element(l []int) int {
","package max_element_test

import (
    ""testing""
    ""fmt""
)

// Return maximum element in the list.
// >>> max_element([]int{1, 2, 3})
// 3
// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// 123
func max_element(l []int) int {
    if len(l) == 0 {
        panic(""Empty list has no maximum value"")
    }
    max := l[0]
    for _, value := range l {
        if value > max {
            max = value
        }
    }
    return max
}

func TestMaxElement(t *testing.T) {
    testCases := []struct {
        input    []int
        expected int
    }{
        {[]int{1, 2, 3}, 3},
        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},
        {[]int{-1, -2, -3, -4}, -1},
        {[]int{9, 9, 9, 9}, 9},
    }

    for _, testCase := range testCases {
        result := max_element(testCase.input)
        if result != testCase.expected {
            t.Errorf(""For input %v, expected %d, got %d"", testCase.input, testCase.expected, result)
        }
    }
}","func TestMax_Element(t *testing.T) {
  candidate := max_element
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: 3 },
     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_36,kbp_Latn,go_test.go,"package fizz_buzz_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:// >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
func fizz_buzz(n int) int {
","package fizz_buzz_test

import (
    ""testing""
    ""fmt""
    ""strconv""
)

func fizz_buzz(n int) int {
    count := 0
    for i := 0; i < n; i++ {
        if i % 11 == 0 || i % 13 == 0 {
            count += countSevens(i)
        }
    }
    return count
}

func countSevens(num int) int {
    strNum := strconv.Itoa(num)
    count := 0
    for _, c := range strNum {
        if c == '7' {
            count++
        }
    }
    return count
}

func TestFizzBuzz(t *testing.T) {
    tests := []struct {
        input int
        expected int
    }{
        {50, 0},
        {78, 2},
        {79, 3},
    }

    for _, test := range tests {
        result := fizz_buzz(test.input)
        if result != test.expected {
            t.Errorf(""fizz_buzz(%d) = %d; expected %d"", test.input, result, test.expected)
        }
    }
}

func main() {
    fmt.Println(fizz_buzz(50)) // 0
    fmt.Println(fizz_buzz(78)) // 2
    fmt.Println(fizz_buzz(79)) // 3
}","func TestFizz_Buzz(t *testing.T) {
  candidate := fizz_buzz
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(50), expected: 0 },
     { actual: candidate(78), expected: 2 },
     { actual: candidate(79), expected: 3 },
     { actual: candidate(100), expected: 3 },
     { actual: candidate(200), expected: 6 },
     { actual: candidate(4000), expected: 192 },
     { actual: candidate(10000), expected: 639 },
     { actual: candidate(100000), expected: 8026 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_37,kbp_Latn,go_test.go,"package sort_even_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, pɛtɛzɩ-ɩ kpaɣʋ nɛ pɛtɛzɩ-ɩ kpaɣʋ nɛ pɛtɛzɩɣ-ɩ kpaɣʋ nɛ pɛtɛzɩɣ-ɩ kpaɣʋ nɛ pɛtɛzɩɣ-ɩ kpaɣʋ.//l' wɛ ɛzɩ l yɔ, ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛyʊ ɛ-tɛ ɛyʊ ɛyʊ ɛ-tɛ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ//Tʊma ana a-taa lɛ, pakpaɣ mayaɣ l nɛ papɩsɩna mayaɣ l' ŋgʊ kɩ-taa // >>> sort_even([]int{1, 2, 3})
// []int{1, 2, 3}
// >>> sort_even([]int{5, 6, 3, 4})
// []int{3, 6, 5, 4}
func sort_even(l []int) []int {
","package sort_even_test

import (
    ""sort""
)

func sort_even(l []int) []int {
    if len(l) < 2 {
        return l
    }
    
    // Extract even indices
    evens := []int{}
    for i := 0; i < len(l); i += 2 {
        evens = append(evens, l[i])
    }
    
    // Sort even-indexed elements
    sort.Ints(evens)
    
    // Merge sorted evens back into the original list
    j := 0
    for i := 0; i < len(l); i += 2 {
        l[i] = evens[j]
        j++
    }

    return l
}","func TestSort_Even(t *testing.T) {
  candidate := sort_even
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },
     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },
     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_39,kbp_Latn,go_test.go,"package prime_fib_test

import (
    ""testing""
    ""fmt""
)

//prime_fib pɩlɩɣna n-tɛ n̄ɩnɖɛ nɖɩ ɖɩkɛ Fibonacci n̄ɩnɖɛ nɛ ɖɩkɛ ɖɔɖɔ kajalaɣ n̄ɩnɖɛ yɔ.// >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
func prime_fib(n int) int {
","package prime_fib_test

import (
    ""testing""
    ""fmt""
)

// isPrime checks if a number is prime
func isPrime(num int) bool {
    if num <= 1 {
        return false
    }
    if num <= 3 {
        return true
    }
    if num%2 == 0 || num%3 == 0 {
        return false
    }
    for i := 5; i*i <= num; i += 6 {
        if num%i == 0 || num%(i+2) == 0 {
            return false
        }
    }
    return true
}

// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
func prime_fib(n int) int {
    if n <= 0 {
        return 0
    }
    a, b := 1, 1
    count := 0
    for count < n {
        a, b = b, a+b
        if isPrime(a) {
            count++
        }
    }
    return a
}

func TestPrimeFib(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {1, 2},
        {2, 3},
        {3, 5},
        {4, 13},
        {5, 89},
    }

    for _, test := range tests {
        result := prime_fib(test.input)
        if result != test.expected {
            t.Errorf(""prime_fib(%d) = %d; expected %d"", test.input, result, test.expected)
        } else {
            fmt.Printf(""prime_fib(%d) = %d\n"", test.input, result)
        }
    }
}","func TestPrime_Fib(t *testing.T) {
  candidate := prime_fib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 2 },
     { actual: candidate(2), expected: 3 },
     { actual: candidate(3), expected: 5 },
     { actual: candidate(4), expected: 13 },
     { actual: candidate(5), expected: 89 },
     { actual: candidate(6), expected: 233 },
     { actual: candidate(7), expected: 1597 },
     { actual: candidate(8), expected: 28657 },
     { actual: candidate(9), expected: 514229 },
     { actual: candidate(10), expected: 433494437 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_40,kbp_Latn,go_test.go,"package triples_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, kɩ-tɛ tɔm kɛ cɛtɩm.//Pɩpɩsɩɣ tɔmpiye true yee tɔmpiye nɖɩ ɖɩ-taa wɛ tɔmpiye ndɩ ndɩ naadozo yɔ nɛ //triple_sum_to_zero kpaɣ ɛyʊ hɔɔlʊʊ taa ɛyʊ hɔɔlʊʊ taa ɛyʊ hɔɔlʊʊ taa.// >>> triples_sum_to_zero([]int{1, 3, 5, 0})
// false
// >>> triples_sum_to_zero([]int{1, 3, -2, 1})
// true
// >>> triples_sum_to_zero([]int{1, 2, 3, 7})
// false
// >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})
// true
// >>> triples_sum_to_zero([]int{1})
// false
func triples_sum_to_zero(l []int) bool {
","func triples_sum_to_zero(l []int) bool {
    n := len(l)
    if n < 3 {
        return false
    }
    
    for i := 0; i < n-2; i++ {
        for j := i + 1; j < n-1; j++ {
            for k := j + 1; k < n; k++ {
                if l[i]+l[j]+l[k] == 0 {
                    return true
                }
            }
        }
    }
    
    return false
}

func TestTriplesSumToZero(t *testing.T) {
    tests := []struct {
        input  []int
        output bool
    }{
        {[]int{1, 3, 5, 0}, false},
        {[]int{1, 3, -2, 1}, true},
        {[]int{1, 2, 3, 7}, false},
        {[]int{2, 4, -5, 3, 9, 7}, true},
        {[]int{1}, false},
    }

    for _, test := range tests {
        result := triples_sum_to_zero(test.input)
        if result != test.output {
            t.Errorf(""For input %v, expected %v, got %v"", test.input, test.output, result)
        }
    }
}

func main() {
    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    // false
    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   // true
    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    // false
    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) // true
    fmt.Println(triples_sum_to_zero([]int{1}))              // false
}","func TestTriples_Sum_To_Zero(t *testing.T) {
  candidate := triples_sum_to_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 3, 5, 0}), expected: false },
     { actual: candidate([]int{1, 3, 5, -1}), expected: false },
     { actual: candidate([]int{1, 3, -2, 1}), expected: true },
     { actual: candidate([]int{1, 2, 3, 7}), expected: false },
     { actual: candidate([]int{1, 2, 5, 7}), expected: false },
     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },
     { actual: candidate([]int{1}), expected: false },
     { actual: candidate([]int{1, 3, 5, -100}), expected: false },
     { actual: candidate([]int{100, 3, 5, -100}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_41,kbp_Latn,go_test.go,"package car_race_collision_test

import (
    ""testing""
    ""fmt""
)

//Kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ.//Pɩwɛ ɛzɩ patɩkatɩ ɖama yɔ.//Ɛlɛ, lɔɔɖa ana awɛ ɖoŋ nɛ awɛ ɖɔɖɔ kpɩzɩŋ nɛ pʋyɔɔ lɛ, awɛɛ nɛ awɛɛ nɛ awɛɛ.//Alɩwaatʋ ndʋ lɔɔɖɩyɛ nɖɩ ɖɩɖɛɣ nɛ ɖɩlɩɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩkɔŋʋʋ lɔɔɖɩyɛ nɖɩ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ yɔ.//Pɩkɛna mbʋ se, yee ɖɩkpaɣ se ɖɩcaɣ ɖɩ-tɩ yɔɔ kɔyɔ, ɖɩnaɣ se ɖɩtɩŋɩɣna nɛ ɖɩlakɩ mbʋ.//Kpɛndɩɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna.//lɔɔɖa n wɛɛ nɛ pɔɖɔŋ nɛ pɛɖɛɣna n-nɩmɩyɛ nɛ n-nɩmɩyɛ.//Maɣzɩ se ŋwɛ habɩyɛ nɖɩ ɖɩtɩŋʋʋ camɩyɛ yɔ ɖɩ-yɔɔ.func car_race_collision(n int) int {
","package car_race_collision_test

import (
    ""testing""
)

func car_race_collision(n int) int {
    return n
}

func TestCarRaceCollision(t *testing.T) {
    cases := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 2},
        {3, 3},
        {10, 10},
        {0, 0},
    }

    for _, c := range cases {
        result := car_race_collision(c.n)
        if result != c.expected {
            t.Errorf(""car_race_collision(%d) == %d, expected %d"", c.n, result, c.expected)
        }
    }
}","func TestCar_Race_Collision(t *testing.T) {
  candidate := car_race_collision
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: 4 },
     { actual: candidate(3), expected: 9 },
     { actual: candidate(4), expected: 16 },
     { actual: candidate(8), expected: 64 },
     { actual: candidate(10), expected: 100 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_42,kbp_Latn,go_test.go,"package incr_list_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ takayɩhayʋʋ 1 ñɩŋgʋ yɔɔ.// >>> incr_list([]int{1, 2, 3})
// []int{2, 3, 4}
// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}
func incr_list(l []int) []int {
","package incr_list_test

import (
    ""testing""
    ""fmt""
)

// Return list with elements incremented by 1.
// >>> incr_list([]int{1, 2, 3})
// []int{2, 3, 4}
// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}
func incr_list(l []int) []int {
    result := make([]int, len(l))
    for i, val := range l {
        result[i] = val + 1
    }
    return result
}

func TestIncrList(t *testing.T) {
    cases := []struct {
        input    []int
        expected []int
    }{
        {[]int{1, 2, 3}, []int{2, 3, 4}},
        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},
    }

    for _, c := range cases {
        result := incr_list(c.input)
        for i := range result {
            if result[i] != c.expected[i] {
                t.Errorf(""incr_list(%v) == %v, expected %v"", c.input, result, c.expected)
            }
        }
    }
}

func main() {
    fmt.Println(incr_list([]int{1, 2, 3}))          // should print [2, 3, 4]
    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) // should print [6, 4, 6, 3, 4, 4, 10, 1, 124]
}","func TestIncr_List(t *testing.T) {
  candidate := incr_list
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },
     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_43,kbp_Latn,go_test.go,"package pairs_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, kɩ-tɛ tɔm kɛ cɛtɩm.//Pɩpɩsɩɣ tɔmpiye true yee tɔmpiye naalɛ wɛna ɛyʊ yɔɔ kɔyɔ, //pairs_sum_to_zero kpaɣ ɛyʊ kʊyʊm hɔɔlʊʊ taa lɛ, kɩwɛ ɛzɩ kɩ-tɛ tɔm yɔ.// >>> pairs_sum_to_zero([]int{1, 3, 5, 0})
// false
// >>> pairs_sum_to_zero([]int{1, 3, -2, 1})
// false
// >>> pairs_sum_to_zero([]int{1, 2, 3, 7})
// false
// >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})
// true
// >>> pairs_sum_to_zero([]int{1})
// false
func pairs_sum_to_zero(l []int) bool {
","package pairs_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

func pairs_sum_to_zero(l []int) bool {
    numSet := make(map[int]struct{})
    for _, num := range l {
        if _, found := numSet[-num]; found {
            return true
        }
        numSet[num] = struct{}{}
    }
    return false
}

func TestPairsSumToZero(t *testing.T) {
    testCases := []struct {
        input    []int
        expected bool
    }{
        {[]int{1, 3, 5, 0}, false},
        {[]int{1, 3, -2, 1}, false},
        {[]int{1, 2, 3, 7}, false},
        {[]int{2, 4, -5, 3, 5, 7}, true},
        {[]int{1}, false},
    }

    for _, tc := range testCases {
        result := pairs_sum_to_zero(tc.input)
        if result != tc.expected {
            t.Errorf(""pairs_sum_to_zero(%v) = %v; expected %v"", tc.input, result, tc.expected)
        } else {
            fmt.Printf(""Test passed for input: %v, result: %v\n"", tc.input, result)
        }
    }
}","func TestPairs_Sum_To_Zero(t *testing.T) {
  candidate := pairs_sum_to_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 3, 5, 0}), expected: false },
     { actual: candidate([]int{1, 3, -2, 1}), expected: false },
     { actual: candidate([]int{1, 2, 3, 7}), expected: false },
     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },
     { actual: candidate([]int{1}), expected: false },
     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },
     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },
     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },
     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_44,kbp_Latn,go_test.go,"package change_base_test

import (
    ""testing""
    ""fmt""
)

//Kɩ-tɛ kɩlɛmɩŋ wɛ ɛzɩ 10 yɔ.//Pɩpɩsɩɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye lɛɣzʋʋ.//Pɩsɩ takayɩhayʋʋ kɩsɔzɩtʋ taa.// >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
func change_base(x int, base int) string {
","package change_base_test

import (
    ""strconv""
    ""testing""
    ""fmt""
)

func change_base(x int, base int) string {
    if base < 2 || base > 9 {
        return """"
    }

    result := """"
    for x > 0 {
        remainder := x % base
        result = strconv.Itoa(remainder) + result
        x = x / base
    }
    
    if result == """" {
        return ""0""
    }
    return result
}

func TestChangeBase(t *testing.T) {
    tests := []struct {
        x      int
        base   int
        result string
    }{
        {8, 3, ""22""},
        {8, 2, ""1000""},
        {7, 2, ""111""},
        {0, 2, ""0""},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d to base %d"", test.x, test.base), func(t *testing.T) {
            res := change_base(test.x, test.base)
            if res != test.result {
                t.Errorf(""expected %s, got %s"", test.result, res)
            }
        })
    }
}","func TestChange_Base(t *testing.T) {
  candidate := change_base
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(8, 3), expected: ""22"" },
     { actual: candidate(9, 3), expected: ""100"" },
     { actual: candidate(234, 2), expected: ""11101010"" },
     { actual: candidate(16, 2), expected: ""10000"" },
     { actual: candidate(8, 2), expected: ""1000"" },
     { actual: candidate(7, 2), expected: ""111"" },
     { actual: candidate(2, 3), expected: ""2"" },
     { actual: candidate(3, 4), expected: ""3"" },
     { actual: candidate(4, 5), expected: ""4"" },
     { actual: candidate(5, 6), expected: ""5"" },
     { actual: candidate(6, 7), expected: ""6"" },
     { actual: candidate(7, 8), expected: ""7"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_45,kbp_Latn,go_test.go,"package triangle_area_test

import (
    ""testing""
    ""fmt""
)

//Pɩkɛna hɔɔlɩŋ weyi ɛ-taa pʊcɔ nɛ pʊcɔ nɛ pʊcɔ nɛ pʊcɔ nɛ pʊcɔ nɛ pʊcɔ yɔ.// >>> triangle_area(5, 3)
// 7.5
func triangle_area(a int, h int) float64 {
","package triangle_area_test

import (
    ""testing""
    ""fmt""
)

// Given length of a side and height return area for a triangle.
// >>> triangle_area(5, 3)
// 7.5
func triangle_area(a int, h int) float64 {
    return 0.5 * float64(a) * float64(h)
}

func TestTriangleArea(t *testing.T) {
    cases := []struct {
        a, h int
        expected float64
    }{
        {5, 3, 7.5},
        {6, 4, 12.0},
        {10, 2, 10.0},
        {8, 5, 20.0},
    }
    
    for _, c := range cases {
        result := triangle_area(c.a, c.h)
        if result != c.expected {
            t.Errorf(""triangle_area(%d, %d) == %f, expected %f"", c.a, c.h, result, c.expected)
        } else {
            fmt.Printf(""triangle_area(%d, %d) == %f\n"", c.a, c.h, result)
        }
    }
}","func TestTriangle_Area(t *testing.T) {
  candidate := triangle_area
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5, 3), expected: 7.5 },
     { actual: candidate(2, 2), expected: 2.0 },
     { actual: candidate(10, 8), expected: 40.0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_46,kbp_Latn,go_test.go,"package fib4_test

import (
    ""testing""
    ""fmt""
)

//Pɩsa nɛ ŋpɩzɩ ŋla tʋmɩyɛ nɛ ŋla akɔnta camɩyɛ nɛ ŋtɩlɩ fib4 tɛ n̄ɩŋgʋ. Taawɛɛkɩɣ kɩ-tɩ yɔɔ.//Fɛyɩtʊ ndʊ tɩ-taa lɛ, pʊtɔbʊʊ se fɩdɩyɔm wɛna fɩdɩyɔm tɛtʊ ndʊ tɩ-taa nɛ fɩdɩyɔm tɛtʊ ndʊ tɩ-taa nɛ fɩdɩyɔm tɛtʊ ndʊ tɩ-taa nɛ fɩdɩyɔm tɛtʊ ndʊ tɩ-taa.//(Cɔnɩ tayʋʋ 4)//(Cɔnɩ tayʋʋ 2) -> 2 //(Cɔnɩ tayʋʋ 1) -> 0 //(Cɔnɩ tayʋʋ 4)//Fib4 kɛna mbʊ payaɣ se Fibbonacci yɔ, pɩlɩna ɛ-tɛ ɛyʊ yɔɔ nɛ pɩlɩna ɛ-tɛ ɛyʊ yɔɔ.// >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
func fib4(n int) int {
","func fib4(n int) int {
    if n < 0 {
        return 0
    }
    
    seq := []int{0, 0, 2, 0}
    
    if n < 4 {
        return seq[n]
    }
    
    for i := 4; i <= n; i++ {
        next := seq[0] + seq[1] + seq[2] + seq[3]
        seq[0] = seq[1]
        seq[1] = seq[2]
        seq[2] = seq[3]
        seq[3] = next
    }
    
    return seq[3]
}","func TestFib4(t *testing.T) {
  candidate := fib4
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 4 },
     { actual: candidate(8), expected: 28 },
     { actual: candidate(10), expected: 104 },
     { actual: candidate(12), expected: 386 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_47,kbp_Latn,go_test.go,"package median_test

import (
    ""testing""
    ""fmt""
)

//Pɩlɩʋ \\ Mɛdinaa \\ takayɩhatʋ// >>> median([]int{3, 1, 2, 4, 5})
// 3
// >>> median([]int{-10, 4, 6, 1000, 10, 20})
// 15.0
func median(l []int) float64 {
","package median_test

import (
    ""sort""
)

func median(l []int) float64 {
    sort.Ints(l)
    n := len(l)
    if n%2 == 1 {
        return float64(l[n/2])
    }
    mid1, mid2 := l[(n/2)-1], l[n/2]
    return float64(mid1+mid2) / 2.0
}","func TestMedian(t *testing.T) {
  candidate := median
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },
     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },
     { actual: candidate([]int{5}), expected: 5 },
     { actual: candidate([]int{6, 5}), expected: 5.5 },
     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_48,kbp_Latn,go_test.go,"package is_palindrome_test

import (
    ""testing""
    ""fmt""
)

//Pɩcɔ nɛ pana se tɔmpiye nɖɩ ɖɩ-taa pama tɔm yɔ, ɖɩkɛ palindrome yaa we ?// >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
func is_palindrome(text string) bool {
","package is_palindrome_test

import (
    ""testing""
)

// Checks if given string is a palindrome
func is_palindrome(text string) bool {
    n := len(text)
    for i := 0; i < n/2; i++ {
        if text[i] != text[n-i-1] {
            return false
        }
    }
    return true
}

func TestIsPalindrome(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {"""", true},
        {""aba"", true},
        {""aaaaa"", true},
        {""zbcd"", false},
    }

    for _, test := range tests {
        result := is_palindrome(test.input)
        if result != test.expected {
            t.Errorf(""For input '%s', expected %v, but got %v"", test.input, test.expected, result)
        }
    }
}","func TestIs_Palindrome(t *testing.T) {
  candidate := is_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: true },
     { actual: candidate(""aba""), expected: true },
     { actual: candidate(""aaaaa""), expected: true },
     { actual: candidate(""zbcd""), expected: false },
     { actual: candidate(""xywyx""), expected: true },
     { actual: candidate(""xywyz""), expected: false },
     { actual: candidate(""xywzx""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_49,kbp_Latn,go_test.go,"package modp_test

import (
    ""testing""
    ""fmt""
)

//Pɩpɩsɩɣ 2^n modulo p (ɩtɩlɩɣ nimerikɩwaa).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
func modp(n int, p int) int {
","package modp_test

import (
    ""testing""
    ""fmt""
)

// Return 2^n modulo p (be aware of numerics).
func modp(n int, p int) int {
    if n == 0 {
        return 1
    }
    result := 1
    base := 2
    for n > 0 {
        if n%2 == 1 {
            result = (result * base) % p
        }
        base = (base * base) % p
        n /= 2
    }
    return result
}

func TestModp(t *testing.T) {
    tests := []struct {
        n, p int
        expected int
    }{
        {3, 5, 3},
        {1101, 101, 2},
        {0, 101, 1},
        {3, 11, 8},
        {100, 101, 1},
    }

    for _, test := range tests {
        result := modp(test.n, test.p)
        if result != test.expected {
            t.Errorf(""modp(%d, %d) = %d; expected %d"", test.n, test.p, result, test.expected)
        } else {
            fmt.Printf(""modp(%d, %d) = %d; passed\n"", test.n, test.p, result)
        }
    }
}","func TestModp(t *testing.T) {
  candidate := modp
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 5), expected: 3 },
     { actual: candidate(1101, 101), expected: 2 },
     { actual: candidate(0, 101), expected: 1 },
     { actual: candidate(3, 11), expected: 8 },
     { actual: candidate(100, 101), expected: 1 },
     { actual: candidate(30, 5), expected: 4 },
     { actual: candidate(31, 5), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_51,kbp_Latn,go_test.go,"package remove_vowels_test

import (
    ""testing""
    ""fmt""
)

//remove_vowels kɛna tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩfɛyɩna tɔmpiye yɔ.// >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
func remove_vowels(text string) string {
","package remove_vowels_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func remove_vowels(text string) string {
    vowels := ""aeiouAEIOU""
    var result strings.Builder
    for _, char := range text {
        if !strings.ContainsRune(vowels, char) {
            result.WriteRune(char)
        }
    }
    return result.String()
}

func TestRemoveVowels(t *testing.T) {
    var tests = []struct {
        input    string
        expected string
    }{
        {"""", """"},
        {""abcdef"", ""bcdf""},
        {""aaaaa"", """"},
        {""aaBAA"", ""B""},
        {""zbcd"", ""zbcd""},
    }

    for _, test := range tests {
        if output := remove_vowels(test.input); output != test.expected {
            t.Errorf(""remove_vowels(%q) = %q; expected %q"", test.input, output, test.expected)
        }
    }
}

func main() {
    test := &testing.T{}
    TestRemoveVowels(test)
    if test.Failed() {
        fmt.Println(""Tests failed!"")
    } else {
        fmt.Println(""All tests passed!"")
    }
}","func TestRemove_Vowels(t *testing.T) {
  candidate := remove_vowels
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""abcdef\nghijklm""), expected: ""bcdf\nghjklm"" },
     { actual: candidate(""fedcba""), expected: ""fdcb"" },
     { actual: candidate(""eeeee""), expected: """" },
     { actual: candidate(""acBAA""), expected: ""cB"" },
     { actual: candidate(""EcBOO""), expected: ""cB"" },
     { actual: candidate(""ybcd""), expected: ""ybcd"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_52,kbp_Latn,go_test.go,"package below_threshold_test

import (
    ""testing""
    ""fmt""
)

//Pɩpɩsɩɣ true yee nimbrɩwaa mba pɛwɛ lɩmaɣza taa yɔ, pa-tɩŋa pɛwɛ pɩ-tɛɛ t.// >>> below_threshold([]int{1, 2, 4, 10}, 100)
// true
// >>> below_threshold([]int{1, 20, 4, 10}, 5)
// false
func below_threshold(l []int, t int) bool {
","package below_threshold_test

import (
    ""testing""
    ""fmt""
)

// Return true if all numbers in the list l are below threshold t.
func below_threshold(l []int, t int) bool {
    for _, num := range l {
        if num >= t {
            return false
        }
    }
    return true
}

// Example test cases
func TestBelowThreshold(t *testing.T) {
    if !below_threshold([]int{1, 2, 4, 10}, 100) {
        t.Error(""Expected true, got false"")
    }
    if below_threshold([]int{1, 20, 4, 10}, 5) {
        t.Error(""Expected false, got true"")
    }
}

func main() {
    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) // true
    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  // false
}","func TestBelow_Threshold(t *testing.T) {
  candidate := below_threshold
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },
     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },
     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },
     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_53,kbp_Latn,go_test.go,"package add_test

import (
    ""testing""
    ""fmt""
)

//Ɖɩkpaɣ x nɛ y pa-naalɛ nɛ ɖɩkpɛndɩna.// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
func add(x int, y int) int {
","package add_test

import (
    ""testing""
    ""fmt""
)

// Add two numbers x and y
// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
func add(x int, y int) int {
    return x + y
}

func TestAdd(t *testing.T) {
    testCases := []struct {
        x, y, expected int
    }{
        {2, 3, 5},
        {5, 7, 12},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf(""add(%d,%d)"", tc.x, tc.y), func(t *testing.T) {
            result := add(tc.x, tc.y)
            if result != tc.expected {
                t.Errorf(""Expected %d, got %d"", tc.expected, result)
            }
        })
    }
}","func TestAdd(t *testing.T) {
  candidate := add
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0, 1), expected: 1 },
     { actual: candidate(1, 0), expected: 1 },
     { actual: candidate(2, 3), expected: 5 },
     { actual: candidate(5, 7), expected: 12 },
     { actual: candidate(7, 5), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_54,kbp_Latn,go_test.go,"package same_chars_test

import (
    ""testing""
    ""fmt""
)

//Ñɩnɩ tɔm pee wena awɛ kɩmaŋ yɔ.// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
func same_chars(s0 string, s1 string) bool {
","package same_chars_test

import (
	""testing""
	""fmt""
)

func same_chars(s0 string, s1 string) bool {
	countChars := func(s string) map[rune]int {
		count := make(map[rune]int)
		for _, char := range s {
			count[char]++
		}
		return count
	}

	count0 := countChars(s0)
	count1 := countChars(s1)

	for char := range count0 {
		if count1[char] < count0[char] {
			return false
		}
	}

	for char := range count1 {
		if count0[char] < count1[char] {
			return false
		}
	}

	return true
}

func TestSameChars(t *testing.T) {
	tests := []struct {
		s0     string
		s1     string
		result bool
	}{
		{""eabcdzzzz"", ""dddzzzzzzzddeddabc"", true},
		{""abcd"", ""dddddddabc"", true},
		{""dddddddabc"", ""abcd"", true},
		{""eabcd"", ""dddddddabc"", false},
		{""abcd"", ""dddddddabce"", false},
		{""eabcdzzzz"", ""dddzzzzzzzddddabc"", false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%s vs %s"", test.s0, test.s1), func(t *testing.T) {
			if got := same_chars(test.s0, test.s1); got != test.result {
				t.Errorf(""same_chars(%q, %q) = %v; want %v"", test.s0, test.s1, got, test.result)
			}
		})
	}
}","func TestSame_Chars(t *testing.T) {
  candidate := same_chars
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""), expected: true },
     { actual: candidate(""abcd"", ""dddddddabc""), expected: true },
     { actual: candidate(""dddddddabc"", ""abcd""), expected: true },
     { actual: candidate(""eabcd"", ""dddddddabc""), expected: false },
     { actual: candidate(""abcd"", ""dddddddabcf""), expected: false },
     { actual: candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""), expected: false },
     { actual: candidate(""aabb"", ""aaccc""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_55,kbp_Latn,go_test.go,"package fib_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ tɔm pɔzʋʋ:// >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
func fib(n int) int {
","if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}","func TestFib(t *testing.T) {
  candidate := fib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(10), expected: 55 },
     { actual: candidate(1), expected: 1 },
     { actual: candidate(8), expected: 21 },
     { actual: candidate(11), expected: 89 },
     { actual: candidate(12), expected: 144 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_56,kbp_Latn,go_test.go,"package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩɣna nɛ ŋtɩlɩ se paa tɔmpiye nɖɩ lɛ, ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ.//""parenthes"" kɛna ""<"" nɛ "">"" pa-taa mayaɣ.// >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
func correct_bracketing(brackets string) bool {
","package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

func correct_bracketing(brackets string) bool {
    balance := 0
    for _, char := range brackets {
        if char == '<' {
            balance++
        } else if char == '>' {
            balance--
            if balance < 0 {
                return false
            }
        }
    }
    return balance == 0
}

func TestCorrectBracketing(t *testing.T) {
    testCases := []struct {
        input    string
        expected bool
    }{
        {input: ""<"", expected: false},
        {input: ""<>"", expected: true},
        {input: ""<<><>>"", expected: true},
        {input: ""><<>"", expected: false},
        {input: ""<<>>"", expected: true},
        {input: ""><"", expected: false},
    }

    for _, tc := range testCases {
        result := correct_bracketing(tc.input)
        if result != tc.expected {
            t.Errorf(""correct_bracketing(%q) = %v; expected %v"", tc.input, result, tc.expected)
        } else {
            fmt.Printf(""Test passed for input: %q\n"", tc.input)
        }
    }
}","func TestCorrect_Bracketing(t *testing.T) {
  candidate := correct_bracketing
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""<>""), expected: true },
     { actual: candidate(""<<><>>""), expected: true },
     { actual: candidate(""<><><<><>><>""), expected: true },
     { actual: candidate(""<><><<<><><>><>><<><><<>>>""), expected: true },
     { actual: candidate(""<<<><>>>>""), expected: false },
     { actual: candidate(""><<>""), expected: false },
     { actual: candidate(""<""), expected: false },
     { actual: candidate(""<<<<""), expected: false },
     { actual: candidate("">""), expected: false },
     { actual: candidate(""<<>""), expected: false },
     { actual: candidate(""<><><<><>><>><<>""), expected: false },
     { actual: candidate(""<><><<><>><>>><>""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_57,kbp_Latn,go_test.go,"package monotonic_test

import (
    ""testing""
    ""fmt""
)

//Pɩpɩsɩɣ tɔm ndʋ tɩkɛ toovenim yɔ, pɩkɛna tɔm ndʋ tɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ nɛ ɖɩpaɣlɩɣ yaa ɖɩtɛzɩɣ ɖɔʋ yɔ.// >>> monotonic([]int{1, 2, 4, 20})
// true
// >>> monotonic([]int{1, 20, 4, 10})
// false
// >>> monotonic([]int{4, 1, 0, -10})
// true
func monotonic(l []int) bool {
","package monotonic_test

import (
    ""testing""
    ""fmt""
)

// Return true if list elements are monotonically increasing or decreasing.
func monotonic(l []int) bool {
    if len(l) < 2 {
        return true
    }
    increasing := true
    decreasing := true

    for i := 1; i < len(l); i++ {
        if l[i] > l[i-1] {
            decreasing = false
        }
        if l[i] < l[i-1] {
            increasing = false
        }
    }

    return increasing || decreasing
}

func TestMonotonic(t *testing.T) {
    fmt.Println(monotonic([]int{1, 2, 4, 20})) // true
    fmt.Println(monotonic([]int{1, 20, 4, 10})) // false
    fmt.Println(monotonic([]int{4, 1, 0, -10})) // true
}","func TestMonotonic(t *testing.T) {
  candidate := monotonic
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 10}), expected: true },
     { actual: candidate([]int{1, 2, 4, 20}), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}), expected: false },
     { actual: candidate([]int{4, 1, 0, -10}), expected: true },
     { actual: candidate([]int{4, 1, 1, 0}), expected: true },
     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },
     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },
     { actual: candidate([]int{9, 9, 9, 9}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_58,kbp_Latn,go_test.go,"package common_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩɣnɩ-ŋ nɛ ŋhiɣ tɔm kɩcɛyɩtʋ ndʋ tɩ-taa ŋpɩzɩɣ ŋtɩŋna nɛ ŋla ɖʋtʋ yɔ.// >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})
// []int{1, 5, 653}
// >>> common([]int{5, 3, 2, 8}, []int{3, 2})
// []int{2, 3}
func common(l1 []int, l2 []int) []int {
","package common_test

import (
    ""testing""
    ""fmt""
    ""sort""
)

func common(l1 []int, l2 []int) []int {
    set1 := make(map[int]struct{})
    set2 := make(map[int]struct{})
    commonSet := make(map[int]struct{})
    
    // Fill set1 with elements of l1
    for _, num := range l1 {
        set1[num] = struct{}{}
    }
    
    // Fill set2 with elements of l2
    for _, num := range l2 {
        if _, found := set1[num]; found {
            commonSet[num] = struct{}{}
        }
        set2[num] = struct{}{}
    }
    
    result := make([]int, 0, len(commonSet))
    
    // Collect common elements
    for num := range commonSet {
        result = append(result, num)
    }
    
    // Sort the result
    sort.Ints(result)
    
    return result
}

func TestCommon(t *testing.T) {
    cases := []struct {
        l1, l2 []int
        expected []int
    }{
        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},
        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},
    }
    
    for _, c := range cases {
        result := common(c.l1, c.l2)
        if !equal(result, c.expected) {
            t.Errorf(""common(%v, %v) == %v, expected %v"", c.l1, c.l2, result, c.expected)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestCommon(t *testing.T) {
  candidate := common
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },
     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },
     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },
     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_59,kbp_Latn,go_test.go,"package largest_prime_factor_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ.// >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
func largest_prime_factor(n int) int {
","package largest_prime_factor_test

import (
	""testing""
	""fmt""
)

func largest_prime_factor(n int) int {
	largestFactor := 1
	div := 2

	for n > 1 {
		if n%div == 0 {
			largestFactor = div
			n /= div
		} else {
			div++
		}
	}

	return largestFactor
}

func TestLargestPrimeFactor(t *testing.T) {
	tests := []struct{
		n int
		expected int
	} {
		{13195, 29},
		{2048, 2},
		{123456, 643},
		{100, 5},
		{999, 37},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""n=%d"", test.n), func(t *testing.T) {
			if result := largest_prime_factor(test.n); result != test.expected {
				t.Errorf(""largest_prime_factor(%d) = %d; expected %d"", test.n, result, test.expected)
			}
		})
	}
}","func TestLargest_Prime_Factor(t *testing.T) {
  candidate := largest_prime_factor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(15), expected: 5 },
     { actual: candidate(27), expected: 3 },
     { actual: candidate(63), expected: 7 },
     { actual: candidate(330), expected: 11 },
     { actual: candidate(13195), expected: 29 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_60,kbp_Latn,go_test.go,"package sum_to_n_test

import (
    ""testing""
    ""fmt""
)

//sum_to_n kɛna tʋmɩyɛ nɖɩ ɖɩtɔyɩɣ 1 nɛ puwolo n yɔ.// >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
func sum_to_n(n int) int {
","func sum_to_n(n int) int {
    return n * (n + 1) / 2
}

func TestSumToN(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {30, 465},
        {100, 5050},
        {5, 15},
        {10, 55},
        {1, 1},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""sum_to_n(%d)"", test.input), func(t *testing.T) {
            result := sum_to_n(test.input)
            if result != test.expected {
                t.Errorf(""Expected %d, got %d"", test.expected, result)
            }
        })
    }
}","func TestSum_To_N(t *testing.T) {
  candidate := sum_to_n
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 1 },
     { actual: candidate(6), expected: 21 },
     { actual: candidate(11), expected: 66 },
     { actual: candidate(30), expected: 465 },
     { actual: candidate(100), expected: 5050 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_61,kbp_Latn,go_test.go,"package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩɣna nɛ ŋtɩlɩ se paa tɔmpiye nɖɩ lɛ, ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ.//'parenthes' kɛna ""("" nɛ """") pa-taa tɔm.// >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
func correct_bracketing(brackets string) bool {
","package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

func correct_bracketing(brackets string) bool {
    balance := 0
    for _, char := range brackets {
        if char == '(' {
            balance++
        } else if char == ')' {
            balance--
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}

func TestCorrectBracketing(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {""("", false},
        {""()"", true},
        {""(()())"", true},
        {"")(()"", false},
        {"""", true},
        {""((()))"", true},
        {""(()"", false},
        {""())"", false},
    }

    for _, tt := range tests {
        result := correct_bracketing(tt.input)
        if result != tt.expected {
            t.Errorf(""correct_bracketing(%q) = %v; want %v"", tt.input, result, tt.expected)
        } else {
            fmt.Printf(""correct_bracketing(%q) = %v\n"", tt.input, result)
        }
    }
}","func TestCorrect_Bracketing(t *testing.T) {
  candidate := correct_bracketing
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""()""), expected: true },
     { actual: candidate(""(()())""), expected: true },
     { actual: candidate(""()()(()())()""), expected: true },
     { actual: candidate(""()()((()()())())(()()(()))""), expected: true },
     { actual: candidate(""((()())))""), expected: false },
     { actual: candidate("")(()""), expected: false },
     { actual: candidate(""(""), expected: false },
     { actual: candidate(""((((""), expected: false },
     { actual: candidate("")""), expected: false },
     { actual: candidate(""(()""), expected: false },
     { actual: candidate(""()()(()())())(()""), expected: false },
     { actual: candidate(""()()(()())()))()""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_62,kbp_Latn,go_test.go,"package derivative_test

import (
    ""testing""
    ""fmt""
)

//Pɩpɩsɩ polinomiye ɖɩnɛ ɖɩ-tɛ derivative nɛ ɖɩ-wɛtʋ kɩlɩna ɖama.//xs[0] + xs[1] * x + xs[2] * x^2 + .... //xs kɛna polinomiye naɖɩyɛ tɛ coefficient waa.// >>> derivative([]int{3, 1, 2, 4, 5})
// []int{1, 4, 12, 20}
// >>> derivative([]int{1, 2, 3})
// []int{2, 6}
func derivative(xs []int) []int {
","package derivative_test

import (
    ""testing""
    ""fmt""
)

// xs represent coefficients of a polynomial.
// xs[0] + xs[1] * x + xs[2] * x^2 + ....
// Return derivative of this polynomial in the same form.
func derivative(xs []int) []int {
    if len(xs) <= 1 {
        return []int{}
    }
    
    derived := make([]int, len(xs)-1)
    for i := 1; i < len(xs); i++ {
        derived[i-1] = xs[i] * i
    }
    return derived
}

func TestDerivative(t *testing.T) {
    testCases := []struct{
        input []int
        expected []int
    }{
        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},
        {[]int{1, 2, 3}, []int{2, 6}},
        {[]int{1}, []int{}},
        {[]int{}, []int{}},
    }

    for _, testCase := range testCases {
        result := derivative(testCase.input)
        if !equal(result, testCase.expected) {
            t.Errorf(""For input %v, expected %v, but got %v"", 
                     testCase.input, testCase.expected, result)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestDerivative(t *testing.T) {
  candidate := derivative
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },
     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },
     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },
     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },
     { actual: candidate([]int{1}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_63,kbp_Latn,go_test.go,"package fibfib_test

import (
    ""testing""
    ""fmt""
)

//Pɩsa nɛ ŋtɩlɩ ɛzɩma ŋpɩzɩɣ ŋla nɛ ŋlɩzɩ ɛ-tɛ n-tɛ hɔɔlɩŋ weyi ɛ-taa ɛ-tɛ hɔɔlɩŋ wɛɛ yɔ.//Fibɔrɩyɔm (n) == Fibɔrɩyɔm (n-1) + Fibɔrɩyɔm (n-2) + Fibɔrɩyɔm (n-3). //(Cɔnɩ tayʋʋ 1)//(Cɔnɩ tayʋʋ 1)//fɩfɩfɩ ((0) == 0 //FibFib n̄ɩnʋʋ n̄ɩnʋʋ kɛ n̄ɩnʋʋ ŋgʋ kɩwɛ ɛzɩ Fibbonacci n̄ɩnʋʋ yɔ nɛ kɩ-tɔm n̄ɩnʋʋ kɔyɔ:// >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
func fibfib(n int) int {
","func fibfib(n int) int {
    if n == 0 || n == 1 {
        return 0
    } else if n == 2 {
        return 1
    }

    a, b, c := 0, 0, 1
    for i := 3; i <= n; i++ {
        next := a + b + c
        a = b
        b = c
        c = next
    }
    return c
}","func TestFibfib(t *testing.T) {
  candidate := fibfib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: 1 },
     { actual: candidate(1), expected: 0 },
     { actual: candidate(5), expected: 4 },
     { actual: candidate(8), expected: 24 },
     { actual: candidate(10), expected: 81 },
     { actual: candidate(12), expected: 274 },
     { actual: candidate(14), expected: 927 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_64,kbp_Latn,go_test.go,"package vowels_count_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Tɔm piye nɖɩ ɖɩ-tɛ matʋ kɔyɔ://Tɔmpiye nɖɩ ɖɩ-taa pamaɣna tɔmpiye nɖɩ yɔ, ɖɩ-taa lɛ, ""a"", ""e"", ""i"", ""o"", ""u"".//Ɛ-tɛ tɔm piye nɖɩ ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ yɔ, ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ nɛ ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ.//Maʋ tʋmɩyɛ nɖɩ payaɣ se vowels_count yɔ ɖɩ-taa tɔmpiye nɖɩ ɖɩwɩlɩɣ se // >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
func vowels_count(s string) int {
","package vowels_count_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func vowels_count(s string) int {
    count := 0
    s = strings.ToLower(s)
    vowels := ""aeiou""
    for i, char := range s {
        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {
            count++
        }
    }
    return count
}

func TestVowelsCount(t *testing.T) {
    tests := []struct {
        input  string
        output int
    }{
        {""abcde"", 2},
        {""ACEDY"", 3},
        {""xyz"", 1},
        {""plenty"", 1},
        {""queue"", 3},
    }

    for _, test := range tests {
        result := vowels_count(test.input)
        if result != test.output {
            t.Errorf(""Expected %d, but got %d for input %s"", test.output, result, test.input)
        } else {
            fmt.Printf(""Success: got %d for input %s\n"", result, test.input)
        }
    }
}","func TestVowels_Count(t *testing.T) {
  candidate := vowels_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""abcde""), expected: 2 },
     { actual: candidate(""Alone""), expected: 3 },
     { actual: candidate(""key""), expected: 2 },
     { actual: candidate(""bye""), expected: 1 },
     { actual: candidate(""keY""), expected: 2 },
     { actual: candidate(""bYe""), expected: 1 },
     { actual: candidate(""ACEDY""), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_65,kbp_Latn,go_test.go,"package circular_shift_test

import (
    ""testing""
    ""fmt""
)

//Ye shift > nimero waa yɔ, pɩpɩsɩɣ nimero waa mba pɛlɛɣzɩ-wɛ yɔ.//nɛ pɩpɩsɩɣ pɩ-tɛ lɩmaɣzɩyɛ ɛzɩ tɔmpiye yɔ. //Pɩcɔ nɛ ɖɩna kɔyɔ, ɖɩnaɣ se x kɛ ɛyʊ ɛyʊ, ɛyʊ ɛyʊ ɛyʊ, ɛyʊ ɛyʊ ɛyʊ.// >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
func circular_shift(x int, shift int) string {
","package circular_shift_test

import (
    ""strconv""
)

func circular_shift(x int, shift int) string {
    strX := strconv.Itoa(x)
    numDigits := len(strX)

    if shift > numDigits {
        // Reverse the digits if shift is greater than the number of digits
        reversed := make([]byte, numDigits)
        for i := 0; i < numDigits; i++ {
            reversed[i] = strX[numDigits-i-1]
        }
        return string(reversed)
    } else {
        // Perform a circular shift
        shift = shift % numDigits
        return strX[numDigits-shift:] + strX[:numDigits-shift]
    }
}","func TestCircular_Shift(t *testing.T) {
  candidate := circular_shift
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(100, 2), expected: ""001"" },
     { actual: candidate(12, 2), expected: ""12"" },
     { actual: candidate(97, 8), expected: ""79"" },
     { actual: candidate(12, 1), expected: ""21"" },
     { actual: candidate(11, 101), expected: ""11"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_66,kbp_Latn,go_test.go,"package digitSum_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //ASCII mayaɣ.//Ma tʋmɩyɛ naɖɩyɛ nɛ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa tɔm pee kɩkpaɖaa yɔ, ɖɩ-ñɔɔzʋʋ yem.'//Tʋmɩyɛ // >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
func digitSum(s string) int {
","func digitSum(s string) int {
    sum := 0
    for _, char := range s {
        if char >= 'A' && char <= 'Z' {
            sum += int(char)
        }
    }
    return sum
}","func TestDigitsum(t *testing.T) {
  candidate := digitSum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""abAB""), expected: 131 },
     { actual: candidate(""abcCd""), expected: 67 },
     { actual: candidate(""helloE""), expected: 69 },
     { actual: candidate(""woArBld""), expected: 131 },
     { actual: candidate(""aAaaaXa""), expected: 153 },
     { actual: candidate("" How are yOu?""), expected: 151 },
     { actual: candidate(""You arE Very Smart""), expected: 327 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_67,kbp_Latn,go_test.go,"package fruit_distribution_test

import (
    ""testing""
    ""fmt""
)

//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ: //Mango pee wena awɛ kaɖaɣ taa yɔ, a-taa lɛ, ŋpɩzɩɣ ŋlɩzɩ a-taa pee wena awɛ kaɖaɣ taa yɔ.//Lɛɛlɛyɔ, pɔmbɔɔ nɛ pɔmbɔɔ nɛ pɩtasɩna nimero entier ŋgʋ kɩwɩlɩɣ pee tɩŋa yɔ //Ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ.//Pɩkɛna tɩŋ pee wena awɛ ɖɔmbɛɛ taa yɔ.//Pɩtɛ tʋmɩyɛ ɖɩnɛ ɖɩ-taa, pakaɣ-ŋ haʋ tɔmpiye nɖɩ ɖɩwɩlɩɣ tɔlɩm ndɩ ndɩ yɔ.// >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
func fruit_distribution(s string, n int) int {
","package fruit_distribution_test

import (
    ""fmt""
    ""regexp""
    ""strconv""
    ""testing""
)

func fruit_distribution(s string, n int) int {
    re := regexp.MustCompile(`(\d+) apples and (\d+) oranges`)
    matches := re.FindStringSubmatch(s)
    
    if len(matches) != 3 {
        return -1 // Could return an error or a sentinel value if input format is incorrect
    }

    apples, _ := strconv.Atoi(matches[1])
    oranges, _ := strconv.Atoi(matches[2])

    mangoes := n - (apples + oranges)
    return mangoes
}

func TestFruitDistribution(t *testing.T) {
    var tests = []struct {
        description string
        inputString string
        totalFruits int
        expected    int
    }{
        {""Test case 1"", ""5 apples and 6 oranges"", 19, 8},
        {""Test case 2"", ""0 apples and 1 oranges"", 3, 2},
        {""Test case 3"", ""2 apples and 3 oranges"", 100, 95},
        {""Test case 4"", ""100 apples and 1 oranges"", 120, 19},
    }

    for _, tt := range tests {
        t.Run(tt.description, func(t *testing.T) {
            result := fruit_distribution(tt.inputString, tt.totalFruits)
            if result != tt.expected {
                t.Errorf(""got %d, want %d"", result, tt.expected)
            }
        })
    }
}

func main() {
    fmt.Println(fruit_distribution(""5 apples and 6 oranges"", 19)) // 8
    fmt.Println(fruit_distribution(""0 apples and 1 oranges"", 3))  // 2
    fmt.Println(fruit_distribution(""2 apples and 3 oranges"", 100)) // 95
    fmt.Println(fruit_distribution(""100 apples and 1 oranges"", 120)) // 19
}","func TestFruit_Distribution(t *testing.T) {
  candidate := fruit_distribution
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""5 apples and 6 oranges"", 19), expected: 8 },
     { actual: candidate(""5 apples and 6 oranges"", 21), expected: 10 },
     { actual: candidate(""0 apples and 1 oranges"", 3), expected: 2 },
     { actual: candidate(""1 apples and 0 oranges"", 3), expected: 2 },
     { actual: candidate(""2 apples and 3 oranges"", 100), expected: 95 },
     { actual: candidate(""2 apples and 3 oranges"", 5), expected: 0 },
     { actual: candidate(""1 apples and 100 oranges"", 120), expected: 19 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_68,kbp_Latn,go_test.go,"package pluck_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ 1://Yee ɛyʊ ɛfɛyɩna ɛ-tɛ kɩlabʊ yaa ɛ-tɛ kɩlabʊ kɔyɔ, ɛpɩsɩɣ [].//Pɩwɛɛ se patasɩ haʋ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ, [small_value, its index] taa, //Yee panaa nɩŋgbaŋgʊʊ ndɩ ndɩ nɛ kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna.//Pɩwɛɛ se pʊtʊ weyi ɛ-taa ɛ-tɛ ɛyʊ wɛ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ, ɛwɛna ɛyʊ kɩkpɛdʊ.//Pɩwɛɛ se ŋlɩzɩ-kɛ nɛ ŋyele-kɛ nɛ ŋpɩsɩ-kɛ.//""Ye ɖɩkpaɣ kɩ-taa kɔyɔ, tɩʋ nakʋyʋ piliŋa ŋga kɛwɛna nimero waa kɩmaŋ nɛ pɩfɛyɩ kɩmaŋ yɔ, // >>> pluck([]int{4, 2, 3})
// []int{2, 1}
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([]int{1, 2, 3})
// []int{2, 1}
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([]int{})
// []int{}
// Example 4:
// >>> pluck([]int{5, 0, 3, 0, 4, 2})
// []int{0, 1}
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
func pluck(arr []int) []int {
","package pluck_test

import (
	""testing""
)

// pluck function that implements the solution as described in the problem
func pluck(arr []int) []int {
	if len(arr) == 0 {
		return []int{}
	}

	smallestEvenValue := -1
	index := -1

	for i, val := range arr {
		if val%2 == 0 {
			if smallestEvenValue == -1 || val < smallestEvenValue {
				smallestEvenValue = val
				index = i
			}
		}
	}

	if index == -1 {
		return []int{}
	}

	return []int{smallestEvenValue, index}
}

// Example unit tests can be implemented by using the testing package
func TestPluck(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{[]int{4, 2, 3}, []int{2, 1}},
		{[]int{1, 2, 3}, []int{2, 1}},
		{[]int{}, []int{}},
		{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},
	}

	for _, test := range tests {
		result := pluck(test.input)
		if len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {
			t.Errorf(""pluck(%v) = %v; expected %v"", test.input, result, test.expected)
		}
	}
}","func TestPluck(t *testing.T) {
  candidate := pluck
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },
     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },
     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },
     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },
     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },
     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_69,kbp_Latn,go_test.go,"package search_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Yee pɩfɛyɩ kɔyɔ, pɩpɩsɩɣ -1.//Ɛyʊ kʊyʊm kpɛlɛkʊʊ taa lɛ, ɛ-tɛ kʊyʊm kpɛlɛkʊʊ taa lɛ, pɩkɛ tam ɛzɩma ɛ-tɛ kʊyʊm kpɛlɛkʊʊ taa wɛʊ yɔ.//Pɩtɛ lɛ, ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ.//Pʊtɔbʊʊ se ɛyʊ ɛ-ñʊʊ taa lɛ, ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna// >>> search([]int{4, 1, 2, 2, 3, 1})
// 2
// >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})
// 3
// >>> search([]int{5, 5, 4, 4, 4})
// -1
func search(lst []int) int {
","package search_test

import ""sort""

func search(lst []int) int {
	frequency := make(map[int]int)

	for _, num := range lst {
		frequency[num]++
	}

	candidates := []int{}
	for num, count := range frequency {
		if count >= num {
			candidates = append(candidates, num)
		}
	}

	if len(candidates) == 0 {
		return -1
	}

	sort.Ints(candidates)
	return candidates[len(candidates)-1]
}","func TestSearch(t *testing.T) {
  candidate := search
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },
     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },
     { actual: candidate([]int{3, 3}), expected: -1 },
     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },
     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },
     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },
     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },
     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },
     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },
     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },
     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },
     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },
     { actual: candidate([]int{1}), expected: 1 },
     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },
     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },
     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },
     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },
     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },
     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },
     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },
     { actual: candidate([]int{10}), expected: -1 },
     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },
     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },
     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },
     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_70,kbp_Latn,go_test.go,"package strange_sort_list_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩtɛ lɛ, ɛtɛyɩɣ ɛ-tɛ kɩlɩm nɛ ɛtɛyɩɣ ɛ-tɛ kɩlɩm nɛ pɩtɛ lɛ, ɛtɛyɩɣ ɛ-tɛ kɩlɩm nɛ pɩtɛ lɛ, ɛtɛyɩɣ ɛ-tɛ kɩlɩm.//Pɩwɛ ɛzɩ ŋpaɣzɩɣnɩ kɩjɛyʊʊ yɔ, //Ye ŋha-ɩ nimero waa tɩŋa yɔ, ɛɖaɣnɩɣ-ŋ haʋ nimero waa mba pa-tɩŋa pa-ñɩm yɔ.// >>> strange_sort_list([]int{1, 2, 3, 4})
// []int{1, 4, 2, 3}
// >>> strange_sort_list([]int{5, 5, 5, 5})
// []int{5, 5, 5, 5}
// >>> strange_sort_list([]int{})
// []int{}
func strange_sort_list(lst []int) []int {
","package strange_sort_list_test

import (
	""testing""
	""fmt""
	""sort""
)

func strange_sort_list(lst []int) []int {
	if len(lst) == 0 {
		return lst
	}
	
	sort.Ints(lst)
	res := make([]int, len(lst))
	left, right := 0, len(lst)-1
	i := 0

	for left <= right {
		if i%2 == 0 {
			res[i] = lst[left]
			left++
		} else {
			res[i] = lst[right]
			right--
		}
		i++
	}

	return res
}

func TestStrangeSortList(t *testing.T) {
	tests := []struct {
		input  []int
		output []int
	}{
		{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},
		{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},
		{[]int{}, []int{}},
		{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},
	}
	for _, test := range tests {
		if res := strange_sort_list(test.input); !equal(res, test.output) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.output, res)
		}
	}
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func main() {
	fmt.Println(strange_sort_list([]int{1, 2, 3, 4})) // Should print [1 4 2 3]
}","func TestStrange_Sort_List(t *testing.T) {
  candidate := strange_sort_list
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },
     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },
     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },
     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },
     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },
     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },
     { actual: candidate([]int{111111}), expected: []int{111111} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_71,kbp_Latn,go_test.go,"package triangle_area_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Ɛlɛ, hɔɔlʋʋ naadozo ñɩŋgʋ taa lɛ, pɩcɛzɩ mbʋ.//Hɔɔlɩŋ naadozo wɛna tam nabudozo taa yee ɛ-hɔɔlɩŋ naalɛ ɩ-taa ɛ-tɛ ɖɔʊ ɛkɩlɩ kɔyɔ.//Pɩtɛkɛ mbʋ yɔ, pɩpɩsɩɣ -1 //Pɩtɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa.//Ye ɖɩkpaɣ ɛzɩ pʊtʊnaa mba pɛtɛyɩɣ ɖama yɔ, ɖɩkpaɣ pʊtʊnaa mba pɛtɛyɩɣ ɖama yɔ nɛ ɖɩpɩsɩ pʊtʊnaa mba pɛtɛyɩɣ ɖama yɔ.// >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
func triangle_area(a int, b int, c int) float64 {
","package triangle_area_test

import (
    ""math""
)

func triangle_area(a int, b int, c int) float64 {
    // Check for the validity of the triangle
    if a+b <= c || a+c <= b || b+c <= a {
        return -1
    }
    // Calculate the semi-perimeter
    s := float64(a+b+c) / 2
    // Calculate the area using Heron's formula
    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))
    // Round the result to 2 decimal places
    return math.Round(area*100) / 100.0
}","func TestTriangle_Area(t *testing.T) {
  candidate := triangle_area
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 4, 5), expected: 6.0 },
     { actual: candidate(1, 2, 10), expected: -1 },
     { actual: candidate(4, 8, 5), expected: 8.18 },
     { actual: candidate(2, 2, 2), expected: 1.73 },
     { actual: candidate(1, 2, 3), expected: -1 },
     { actual: candidate(10, 5, 7), expected: 16.25 },
     { actual: candidate(2, 6, 3), expected: -1 },
     { actual: candidate(1, 1, 1), expected: 0.43 },
     { actual: candidate(2, 2, 10), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_72,kbp_Latn,go_test.go,"package will_it_fly_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Pɩkɛ palindromie takayaɣ ŋga ka-taa tɔm pee kpeekpe wɛ ndɩ nɛ kpɩnɛ sɔsɔyɛ w.//Ma tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm ndʋ tɩkɛ toovenim yɔ, ye tɔm ndʋ tɩ-taa tɔm kɩlɩʋ ɛlɩwa yɔ, tɩkɛ toovenim nɛ ye tɩtɩkɛ toovenim yɔ, tɩkɛ cɛtɩm.// >>> will_it_fly([]int{1, 2}, 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([]int{3, 2, 3}, 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([]int{3, 2, 3}, 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([]int{3}, 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q []int, w int) bool {
","func will_it_fly(q []int, w int) bool {
    sum := 0
    n := len(q)

    // Calculate the sum of the elements in q
    for _, value := range q {
        sum += value
    }

    // Check if sum is greater than the maximum possible weight
    if sum > w {
        return false
    }

    // Check if the list is a palindrome
    for i := 0; i < n/2; i++ {
        if q[i] != q[n-i-1] {
            return false
        }
    }

    // If the list is balanced and sum is less than or equal to w
    return true
}","func TestWill_It_Fly(t *testing.T) {
  candidate := will_it_fly
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 2, 3}, 9), expected: true },
     { actual: candidate([]int{1, 2}, 5), expected: false },
     { actual: candidate([]int{3}, 5), expected: true },
     { actual: candidate([]int{3, 2, 3}, 1), expected: false },
     { actual: candidate([]int{1, 2, 3}, 6), expected: false },
     { actual: candidate([]int{5}, 5), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_73,kbp_Latn,go_test.go,"package smallest_change_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ŋpɩzɩɣ nɛ ŋlɛɣzɩ hɔɔlʋʋ nakʋyʋ nɛ ŋla lɛɛbʋ.//Pɩwɛɛ se pɛlɛɣzɩ-kɛ nɛ pɩsa nɛ kɛwɛɛna tɔm kɩlɩʋ.//Ye ŋha-ɖʋ intɛrɩjɛrɩ waa mba pa-tɩŋa pa-hɩla yɔ, ŋñɩnɩɣ nɛ ŋtɩlɩ mbʋ pɩ-taa pɩ-taa pɩ-taa kɩlɛmɩŋ kɩlɩna tɔyʋʋ yɔ.// >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})
// 4
// >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})
// 1
// >>> smallest_change([]int{1, 2, 3, 2, 1})
// 0
func smallest_change(arr []int) int {
","package smallest_change_test

import (
    ""testing""
    ""fmt""
)

func smallest_change(arr []int) int {
    n := len(arr)
    changes := 0
    for i := 0; i < n/2; i++ {
        if arr[i] != arr[n-i-1] {
            changes++
        }
    }
    return changes
}

func TestSmallestChange(t *testing.T) {
    tests := []struct{
        input []int
        expected int
    }{
        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},
        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},
        {[]int{1, 2, 3, 2, 1}, 0},
    }

    for _, test := range tests {
        result := smallest_change(test.input)
        if result != test.expected {
            t.Errorf(""For input %v, expected %d but got %d"", test.input, test.expected, result)
        } else {
            fmt.Printf(""Test passed for input %v\n"", test.input)
        }
    }
}","func TestSmallest_Change(t *testing.T) {
  candidate := smallest_change
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },
     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },
     { actual: candidate([]int{1, 4, 2}), expected: 1 },
     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },
     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },
     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },
     { actual: candidate([]int{1}), expected: 0 },
     { actual: candidate([]int{0, 1}), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_74,kbp_Latn,go_test.go,"package total_match_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Yee nimasi naalɛ ɩwɛna nimasi kʋɖʋmɩŋ kɔyɔ, pɩpɔzʋʋ se papɩsɩnɩ kajalaɣ nimasi.//Takayɩhatʋ ndʋ tɩ-taa paayɔɔdɩ tɔm hɔɔlɩŋ tɩŋa taa yɔ, tɩ-taa lɛ, tɔm hɔɔlɩŋ weyi ɩ-taa paayɔɔdɩ tɔm hɔɔlɩŋ lɛɛŋ taa yɔ, ɩ-taa lɛ, tɔm hɔɔlɩŋ weyi ɩ-taa paayɔɔdɩ tɔm hɔɔlɩŋ lɛɛŋ taa yɔ, ɩ-taa lɛ, tɔm hɔɔlɩŋ weyi ɩ-taa paayɔɔdɩ tɔm hɔɔlɩŋ lɛɛŋ yɔ, ɩ-taa.//Maʋ tʋmɩyɛ nɖɩ ɖɩmʋɣna tɔmpiye naalɛ nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ.// >>> total_match([]string{}, []string{})
// []string{}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hI"", ""Hi""})
// []string{""hI"", ""Hi""}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""})
// []string{""hi"", ""admin""}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""})
// []string{""hI"", ""hi"", ""hi""}
// >>> total_match([]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""})
// []string{""4""}
func total_match(lst1 []string, lst2 []string) []string {
","package total_match_test

import (
    ""testing""
    ""fmt""
)

// total_match function returns the list with the smaller total character count.
// If both lists have the same character count, it returns the first list.
func total_match(lst1 []string, lst2 []string) []string {
    sumChars := func(lst []string) int {
        total := 0
        for _, str := range lst {
            total += len(str)
        }
        return total
    }
    
    sum1 := sumChars(lst1)
    sum2 := sumChars(lst2)

    if sum1 <= sum2 {
        return lst1
    } else {
        return lst2
    }
}

// Test functions can go below to verify the behavior of total_match.
func TestTotalMatch(t *testing.T) {
    cases := []struct {
        lst1      []string
        lst2      []string
        expected  []string
    }{
        {[]string{}, []string{}, []string{}},
        {[]string{""hi"", ""admin""}, []string{""hI"", ""Hi""}, []string{""hI"", ""Hi""}},
        {[]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""}, []string{""hi"", ""admin""}},
        {[]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""}, []string{""hI"", ""hi"", ""hi""}},
        {[]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""}, []string{""4""}},
    }

    for _, c := range cases {
        result := total_match(c.lst1, c.lst2)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", c.expected) {
            t.Errorf(""total_match(%v, %v) == %v, expected %v"", c.lst1, c.lst2, result, c.expected)
        }
    }
}","func TestTotal_Match(t *testing.T) {
  candidate := total_match
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, []string{}), expected: []string{} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hi"", ""hi""}), expected: []string{""hi"", ""hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""}), expected: []string{""hi"", ""admin""} },
     { actual: candidate([]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""}), expected: []string{""4""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""Hi""}), expected: []string{""hI"", ""Hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""}), expected: []string{""hI"", ""hi"", ""hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hii""}), expected: []string{""hi"", ""admin""} },
     { actual: candidate([]string{}, []string{""this""}), expected: []string{} },
     { actual: candidate([]string{""this""}, []string{}), expected: []string{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_75,kbp_Latn,go_test.go,"package is_multiply_prime_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Ɖɩtɩlɩɣ se a) kɛ 100 ɛlɛ pɩtaatalɩ 100.//Pɩtasɩ lɛ, tɔm ndʋ tɩtɩkɛ toovenim.//Maɣna se ɛyʊ ɛpɩzɩ ɛlɩzɩ ɛ-tɛ ɛyʊ tɔm kɔyɔ, ɛ-tɛ ɛyʊ tɔm kɛ 3 taa ɛyʊ tɔm.// >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
func is_multiply_prime(a int) bool {
","func is_multiply_prime(a int) bool {
	if a < 2 {
		return false
	}

	primeNumbers := generatePrimesUpTo(100)
	
	for i := 0; i < len(primeNumbers); i++ {
		for j := i; j < len(primeNumbers); j++ {
			for k := j; k < len(primeNumbers); k++ {
				if primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {
					return true
				}
			}
		}
	}
	return false
}

func generatePrimesUpTo(max int) []int {
	isPrime := make([]bool, max+1)
	for i := 2; i <= max; i++ {
		isPrime[i] = true
	}
	for i := 2; i*i <= max; i++ {
		if isPrime[i] {
			for j := i * i; j <= max; j += i {
				isPrime[j] = false
			}
		}
	}
	var primes []int
	for i := 2; i <= max; i++ {
		if isPrime[i] {
			primes = append(primes, i)
		}
	}
	return primes
}","func TestIs_Multiply_Prime(t *testing.T) {
  candidate := is_multiply_prime
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: false },
     { actual: candidate(30), expected: true },
     { actual: candidate(8), expected: true },
     { actual: candidate(10), expected: false },
     { actual: candidate(125), expected: true },
     { actual: candidate(105), expected: true },
     { actual: candidate(126), expected: false },
     { actual: candidate(729), expected: false },
     { actual: candidate(891), expected: false },
     { actual: candidate(1001), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_76,kbp_Latn,go_test.go,"package is_simple_power_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //x kɛ n tɛ ɖoŋ mbʊ pʊyɔɔ yɔ n**int=x //Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Pɩwɛɛ se ŋma function ŋgʋ kɩpɩsɩɣ true yee x kɛ ɛyʊ yem yɔ.// >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
func is_simple_power(x int, n int) bool {
","package is_simple_power_test

import (
    ""testing""
    ""fmt""
)

func is_simple_power(x int, n int) bool {
    if n <= 1 {
        return x == 1
    }
    
    current := n
    for current <= x {
        if current == x {
            return true
        }
        current *= n
    }
    return false
}

func TestIsSimplePower(t *testing.T) {
    tests := []struct {
        x, n     int
        expected bool
    }{
        {1, 4, true},
        {2, 2, true},
        {8, 2, true},
        {3, 2, false},
        {3, 1, false},
        {5, 3, false},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d,%d"", test.x, test.n), func(t *testing.T) {
            result := is_simple_power(test.x, test.n)
            if result != test.expected {
                t.Errorf(""Expected %v, but got %v"", test.expected, result)
            }
        })
    }
}","func TestIs_Simple_Power(t *testing.T) {
  candidate := is_simple_power
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(16, 2), expected: true },
     { actual: candidate(143214, 16), expected: false },
     { actual: candidate(4, 2), expected: true },
     { actual: candidate(9, 3), expected: true },
     { actual: candidate(16, 4), expected: true },
     { actual: candidate(24, 2), expected: false },
     { actual: candidate(128, 4), expected: false },
     { actual: candidate(12, 6), expected: false },
     { actual: candidate(1, 1), expected: true },
     { actual: candidate(1, 12), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_77,kbp_Latn,go_test.go,"package iscube_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Tɔzɩ se ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm ndʋ ŋma yɔ tɩkɛ toovenim paa ɛzɩmtaa.//Yee ɛyʊ ɛnɛ ɛkɛ ɛyʊ ɛyʊ tɛ kʊyʊm yɔ.//Maɣna tʋmɩyɛ nɖɩ ɖɩkpaɣɣ ɛyʊ hɔɔlɩŋ tɩŋa taa a nɛ ɖɩpɩsɩɣ ɛ-tɛ tɔm yɔ .// >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
func iscube(a int) bool {
","package iscube_test

import (
	""testing""
	""math""
)

func iscube(a int) bool {
	if a < 0 {
		a = -a
	}
	cubeRoot := math.Cbrt(float64(a))
	return cubeRoot == float64(int(cubeRoot))
}

func TestIsCube(t *testing.T) {
	tests := []struct {
		input    int
		expected bool
	}{
		{1, true},
		{2, false},
		{-1, true},
		{64, true},
		{0, true},
		{180, false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""iscube(%d)"", test.input), func(t *testing.T) {
			result := iscube(test.input)
			if result != test.expected {
				t.Errorf(""expected %v, got %v"", test.expected, result)
			}
		})
	}
}","func TestIscube(t *testing.T) {
  candidate := iscube
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: true },
     { actual: candidate(2), expected: false },
     { actual: candidate(-1), expected: true },
     { actual: candidate(64), expected: true },
     { actual: candidate(180), expected: false },
     { actual: candidate(1000), expected: true },
     { actual: candidate(0), expected: true },
     { actual: candidate(1729), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_78,kbp_Latn,go_test.go,"package hex_key_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //nɛ matʋ A,B,C,D,E,F wɛ ɖoŋ ɖoŋ.//Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ: Ŋpɩzɩɣ ŋmaɣzɩ se tɔm ndʋ ŋɖʋwa yɔ tɩkɛ toovenim yaa tɩkɛ cɛjɛsɩ.//B (= decimal 11), D (= decimal 13) //Pʋ-tɔbʋʋ se ŋñɩnɩɣ se ŋtɩlɩ hɔɔlɩŋ weyi ɩ-taa lɛ, 2, 3, 5, 7, //Kɩ-tɛ kajalaɣ hɔɔlɩŋ kɔyɔ: 2, 3, 5, 7, 11, 13, 17...//Hexadecimal waa kɔyɔ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Kɩ-tɛ lɛɣtʊ takayaɣ taa lɛ, pamaɣ se pɩlɩna ɛyʊ yɔɔ lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ.//Ɛkɛ hexadecimalɩ mayaɣ ŋga kɛwɛ ɛzɩ ɛyʊ yɔ nɛ ɛmakɩ ɛ-tɛ hexadecimalɩ mayaɣ //Payaɣ-mɩ se ŋma tʋmɩyɛ nɖɩ ɖɩmʋyaa yɔ.// >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
func hex_key(num string) int {
","func hex_key(num string) int {
    primeDigits := map[rune]struct{}{
        '2': {},
        '3': {},
        '5': {},
        '7': {},
        'B': {},
        'D': {},
    }

    count := 0
    for _, digit := range num {
        if _, found := primeDigits[digit]; found {
            count++
        }
    }
    return count
}

func TestHexKey(t *testing.T) {
    tests := []struct {
        input    string
        expected int
    }{
        {""AB"", 1},
        {""1077E"", 2},
        {""ABED1A33"", 4},
        {""123456789ABCDEF0"", 6},
        {""2020"", 2},
        {"""", 0},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""hex_key(%s)"", test.input), func(t *testing.T) {
            result := hex_key(test.input)
            if result != test.expected {
                t.Errorf(""expected %d, got %d"", test.expected, result)
            }
        })
    }
}","func TestHex_Key(t *testing.T) {
  candidate := hex_key
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""AB""), expected: 1 },
     { actual: candidate(""1077E""), expected: 2 },
     { actual: candidate(""ABED1A33""), expected: 4 },
     { actual: candidate(""2020""), expected: 2 },
     { actual: candidate(""123456789ABCDEF0""), expected: 6 },
     { actual: candidate(""112233445566778899AABBCCDDEEFF00""), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_79,kbp_Latn,go_test.go,"package decimal_to_binary_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩwɛɛ se pama tɔm pee ana nɛ pɩkpaɖɩ mbʋ pamaɣ yɔ.//Pɩkaɣ kɛʋna tɔmpiye 'db' pazɩyɛ nɛ ɖɩtɛ lɛɣtʋ ñɩnɩyaa.//Paa mayaɣ ŋga lɛ, kɛwɛɣ "" 0 "" yaa "" 1 "".//Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye, nɛ paa mayaɣ ŋga lɛ kɛwɛna binɛɛrɩ tɔmpiye //Pʊtɔbʊʊ se ŋwɛna ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ.// >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
func decimal_to_binary(decimal int) string {
","package decimal_to_binary_test

import (
    ""testing""
    ""fmt""
    ""strconv""
)

// You will be given a number in decimal form and your task is to convert it to
// binary format. The function should return a string, with each character representing a binary
// number. Each character in the string will be '0' or '1'.
// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
// The extra characters are there to help with the format.
// Examples:
// >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
func decimal_to_binary(decimal int) string {
    binary := strconv.FormatInt(int64(decimal), 2)
    return ""db"" + binary + ""db""
}

func TestDecimalToBinary(t *testing.T) {
    tests := []struct {
        input  int
        output string
    }{
        {15, ""db1111db""},
        {32, ""db100000db""},
        {0, ""db0db""},
        {1, ""db1db""},
        {255, ""db11111111db""},
    }

    for _, test := range tests {
        result := decimal_to_binary(test.input)
        if result != test.output {
            t.Errorf(""For input %d, expected %s, but got %s"", test.input, test.output, result)
        }
    }
}

func main() {
    fmt.Println(decimal_to_binary(15))  // Output: db1111db
    fmt.Println(decimal_to_binary(32))  // Output: db100000db
    fmt.Println(decimal_to_binary(255)) // Output: db11111111db
}","func TestDecimal_To_Binary(t *testing.T) {
  candidate := decimal_to_binary
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0), expected: ""db0db"" },
     { actual: candidate(32), expected: ""db100000db"" },
     { actual: candidate(103), expected: ""db1100111db"" },
     { actual: candidate(15), expected: ""db1111db"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_80,kbp_Latn,go_test.go,"package is_happy_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Pɩtɛ tɔmpiye naɖɩyɛ wɛna hɩla kɩpanzɩ naadozo nɛ paa mayaɣ ŋga lɛ kɛwɛna hɩla naatozo nɛ pɩtɛ lɛ, pamaɣ-kɛ nɛ hɩla kɩpanzɩ naadozo.//Pɩwɛɛ se ŋtazɩ nɛ ŋna se tɔm ndʋ tɩ-taa ŋwɛɛ yɔ, tɩkɛ toovenim yaa tɩkɛ cɛtɩm.//Pʊtɔbʊʊ se ŋwɛna ñʊʊ mayaɣ kʊyʊmʊ.// >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
func is_happy(s string) bool {
","func is_happy(s string) bool {
    if len(s) < 3 {
        return false
    }
    for i := 0; i <= len(s)-3; i++ {
        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {
            return false
        }
    }
    return true
}","func TestIs_Happy(t *testing.T) {
  candidate := is_happy
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""a""), expected: false },
     { actual: candidate(""aa""), expected: false },
     { actual: candidate(""abcd""), expected: true },
     { actual: candidate(""aabb""), expected: false },
     { actual: candidate(""adb""), expected: true },
     { actual: candidate(""xyy""), expected: false },
     { actual: candidate(""iopaxpoi""), expected: true },
     { actual: candidate(""iopaxioi""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_81,kbp_Latn,go_test.go,"package numerical_letter_grade_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //0.0 E //> 0.0 D- //> 0.7 D //> 1.0 D+ //> 1.3 C- //> 1.7 C //> 2.0 C+ //> 2.3 B- //> 2.7 B //> 3.0 B+ //> 3.3 A- //> 3.7 A //4.0 A+ //Kpɛlɩ kpɛlɛkʋʋ.//tʊmɩyɛ nɖɩ papɩzɩɣ nɛ palɩzɩ ɖɩ-tɛ tɔmpiye ndɩ ɖɩ-tɛ tɔmpiye nɛ pɩlɩɩna takayɩhatʋ ndʋ tɩwɛ pɩ-tɛɛ yɔ tɩ-yɔɔ: //Ɛha-ŋ sukulibiya nasɩyɩ yɔɔ tɔm kɩfatʋ nɛ pɩwɛɛ se ŋma-ɩ .//Ɛlɛ, ɛ-tɛ lɛɣtʋ ñɩnʋʋ mbʋ pɩ-yɔɔ ɛlɩwa yɔ, pɩfɛyɩ ɛ-cɔlɔ.//Tɔm wɩlɩyʋ ɛnʋ ɛ-maɣmaɣ ɛlɩzaa nɛ ɛlabɩnɩ ɛ-tɩ takayɩsɩ nzɩ sɩ-taa ɛmaɣzɩɣ se ɛ-tɔm ɛkpɛlɩkɩɣ yɔ.//Pɩkɛ fenasɩ kʊɖʊmɖɩyɛ tɛ kpɩtaʊ kɛtɛzaɣ taa nɛ wɩlɩyʊ wɛɛ nɛ ɛwɩlɩɣ ɛ-takayɩsɩ taa.// >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})
// []string{""A+"", ""B"", ""C-"", ""C"", ""A-""}
func numerical_letter_grade(grades []float64) []string {
","func numerical_letter_grade(grades []float64) []string {
    letterGrades := []string{}
    for _, grade := range grades {
        if grade == 4.0 {
            letterGrades = append(letterGrades, ""A+"")
        } else if grade > 3.7 {
            letterGrades = append(letterGrades, ""A"")
        } else if grade > 3.3 {
            letterGrades = append(letterGrades, ""A-"")
        } else if grade > 3.0 {
            letterGrades = append(letterGrades, ""B+"")
        } else if grade > 2.7 {
            letterGrades = append(letterGrades, ""B"")
        } else if grade > 2.3 {
            letterGrades = append(letterGrades, ""B-"")
        } else if grade > 2.0 {
            letterGrades = append(letterGrades, ""C+"")
        } else if grade > 1.7 {
            letterGrades = append(letterGrades, ""C"")
        } else if grade > 1.3 {
            letterGrades = append(letterGrades, ""C-"")
        } else if grade > 1.0 {
            letterGrades = append(letterGrades, ""D+"")
        } else if grade > 0.7 {
            letterGrades = append(letterGrades, ""D"")
        } else if grade > 0.0 {
            letterGrades = append(letterGrades, ""D-"")
        } else {
            letterGrades = append(letterGrades, ""E"")
        }
    }
    return letterGrades
}","func TestNumerical_Letter_Grade(t *testing.T) {
  candidate := numerical_letter_grade
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{""A+"", ""B"", ""C-"", ""C"", ""A-""} },
     { actual: candidate([]float64{1.2}), expected: []string{""D+""} },
     { actual: candidate([]float64{0.5}), expected: []string{""D-""} },
     { actual: candidate([]float64{0.0}), expected: []string{""E""} },
     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{""D"", ""D-"", ""C-"", ""B"", ""B+""} },
     { actual: candidate([]float64{0.0, 0.7}), expected: []string{""E"", ""D-""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_82,kbp_Latn,go_test.go,"package prime_length_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Pɩtɛ lɛ, kɩ-kɩɖaʋ kɛna kɩjɛyʊʊ yaa kɩfɛyɩ ɖeu.//Maʋ tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ, ye tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ.// >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
func prime_length(myString string) bool {
","package prime_length_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func prime_length(myString string) bool {
    length := len(myString)
    return isPrime(length)
}

func TestPrimeLength(t *testing.T) {
    testCases := []struct{
        input string
        expected bool
    }{
        {""Hello"", true},
        {""abcdcba"", true},
        {""kittens"", true},
        {""orange"", false},
    }

    for _, testCase := range testCases {
        result := prime_length(testCase.input)
        if result != testCase.expected {
            t.Errorf(""prime_length(%v) returned %v, expected %v"", testCase.input, result, testCase.expected)
        }
    }
}

func main() {
    fmt.Println(prime_length(""Hello""))  // true
    fmt.Println(prime_length(""abcdcba""))  // true
    fmt.Println(prime_length(""kittens""))  // true
    fmt.Println(prime_length(""orange""))  // false
}","func TestPrime_Length(t *testing.T) {
  candidate := prime_length
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hello""), expected: true },
     { actual: candidate(""abcdcba""), expected: true },
     { actual: candidate(""kittens""), expected: true },
     { actual: candidate(""orange""), expected: false },
     { actual: candidate(""wow""), expected: true },
     { actual: candidate(""world""), expected: true },
     { actual: candidate(""MadaM""), expected: true },
     { actual: candidate(""Wow""), expected: true },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""HI""), expected: true },
     { actual: candidate(""go""), expected: true },
     { actual: candidate(""gogo""), expected: false },
     { actual: candidate(""aaaaaaaaaaaaaaa""), expected: false },
     { actual: candidate(""Madam""), expected: true },
     { actual: candidate(""M""), expected: false },
     { actual: candidate(""0""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_83,kbp_Latn,go_test.go,"package starts_one_ends_test

import (
    ""testing""
    ""fmt""
)

//Kɩwɛna nimasɩ kɩbana sakɩyɛ nɛ sɩpaɣzɩɣ yaa sɩtɛzɩɣna 1.//Ye paha-ɖʋ nimero intérieur positif n yɔ, ɖitiyini-i nimero intérieur n waa mba pa-taa lɛ, ɖɩkpaɣ nimero intérieur waa mba pa-taa lɛ, ɖɩkpaɣ nimero intérieur waa mba pa-taa lɛ, ɖɩkpaɣ nimero intérieur waa mba.func starts_one_ends(n int) int {
","package starts_one_ends_test

import (
    ""testing""
    ""fmt""
)

// Given a positive integer n, return the count of the numbers of n-digit
// positive integers that start or end with 1.
func starts_one_ends(n int) int {
    if n == 1 {
        return 1
    }

    countStart1 := 1 * pow(10, n-1)
    countEnd1 := 9 * pow(10, n-2)
    
    return countStart1 + countEnd1
}

func pow(base, exp int) int {
    if exp == 0 {
        return 1
    }
    result := 1
    for i := 0; i < exp; i++ {
        result *= base
    }
    return result
}

func TestStartsOneEnds(t *testing.T) {
    tests := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 19},
        {3, 189},
        {4, 1899},
        {5, 18999},
    }

    for _, tt := range tests {
        testname := fmt.Sprintf(""n=%d"", tt.n)
        t.Run(testname, func(t *testing.T) {
            result := starts_one_ends(tt.n)
            if result != tt.expected {
                t.Errorf(""got %d, want %d"", result, tt.expected)
            }
        })
    }
}","func TestStarts_One_Ends(t *testing.T) {
  candidate := starts_one_ends
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 1 },
     { actual: candidate(2), expected: 18 },
     { actual: candidate(3), expected: 180 },
     { actual: candidate(4), expected: 1800 },
     { actual: candidate(5), expected: 18000 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_84,kbp_Latn,go_test.go,"package solve_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ //Pɩkɛna ɛyʊ kʊyʊm N, ɛ-tɛ kʊyʊm kʊyʊm tɔmpiye taa lɛ, pɩpɩsɩ ɛ-tɛ kʊyʊm kʊyʊm tɔmpiye taa.// >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
func solve(N int) string {
","func solve(N int) string {
    sum := 0
    for N > 0 {
        sum += N % 10
        N /= 10
    }
    return fmt.Sprintf(""%b"", sum)
}","func TestSolve(t *testing.T) {
  candidate := solve
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1000), expected: ""1"" },
     { actual: candidate(150), expected: ""110"" },
     { actual: candidate(147), expected: ""1100"" },
     { actual: candidate(333), expected: ""1001"" },
     { actual: candidate(963), expected: ""10010"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_85,kbp_Latn,go_test.go,"package add_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Ye ɖɩhaɣ ɛyʊ hɩla wena awɛ ñɩɩɩ yɔ, ɖɩcalɩɣna ɛyʊ hɩla wena awɛ ñɩɩɩ yɔ.// >>> add([]int{4, 2, 6, 7})
// 2
func add(lst []int) int {
","sum := 0
    for i := 1; i < len(lst); i += 2 {
        if lst[i]%2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","func TestAdd(t *testing.T) {
  candidate := add
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{4, 88}), expected: 88 },
     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },
     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },
     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_86,kbp_Latn,go_test.go,"package anti_shuffle_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Tɔzɩ se: Pɩwɛɛ se ŋɖɔ tɔm pee nɛ hɔɔlɩŋ weyi ɩ-taa ŋtɩŋ yɔ ɩ-yɔɔ.//Pɩtɛ kɩlɛmʋʋ yɔɔ lɛ, ŋnaɣ mbʋ payaɣ se "" ascii value "" yɔ.//Pɩsɩ nɛ ŋna-ɩ tɔm kɩfatʋ://Tɔmpiye nɖɩ ɖɩ-taa tɔm pee tɩŋa (pɩlɩna tɔm pee ndɩ ndɩ yɔɔ)//Ma tʋmɩyɛ naɖɩyɛ nɛ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩ-ɖɩ nɛ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ.// >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
func anti_shuffle(s string) string {
","package anti_shuffle_test

import (
    ""strings""
    ""sort""
)

func anti_shuffle(s string) string {
    // Split the input string into words based on spaces
    words := strings.Fields(s)

    // Iterate over each word
    for i, word := range words {
        // Convert the word to a slice of runes for sorting
        runes := []rune(word)
        // Sort the runes using custom comparison
        sort.Slice(runes, func(i, j int) bool {
            return runes[i] < runes[j]
        })
        // Reassign the sorted runes back to the word
        words[i] = string(runes)
    }

    // Rejoin the words into a single string, keeping original spaces
    result := """"
    inputIndex := 0

    for _, word := range words {
        // Add the spaces prior to the current word
        for inputIndex < len(s) && s[inputIndex] == ' ' {
            result += "" ""
            inputIndex++
        }
        // Add the current sorted word
        result += word
        inputIndex += len(word)
    }

    // Add trailing spaces, if any.
    for inputIndex < len(s) && s[inputIndex] == ' ' {
        result += "" ""
        inputIndex++
    }

    return result
}","func TestAnti_Shuffle(t *testing.T) {
  candidate := anti_shuffle
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hi""), expected: ""Hi"" },
     { actual: candidate(""hello""), expected: ""ehllo"" },
     { actual: candidate(""number""), expected: ""bemnru"" },
     { actual: candidate(""abcd""), expected: ""abcd"" },
     { actual: candidate(""Hello World!!!""), expected: ""Hello !!!Wdlor"" },
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""Hi. My name is Mister Robot. How are you?""), expected: "".Hi My aemn is Meirst .Rboot How aer ?ouy"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_87,kbp_Latn,go_test.go,"package get_row_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩtasɩ lɛ, ŋpɩzɩɣ nɛ ŋlɩzɩ tɔm ndʋ tɩ-taa ŋcaɣ yɔ nɛ ŋyele nɛ tɩ-taa tɔm pee wɛɛ ndɩ ndɩ.//Pɩwɛɛ se pacalɩ ñɔɔzʋʋ coordonnées waa nɛ pɩkpazɩɣ-sɩ.//paa mayaɣ ŋga lɛ, kɛwɛna ɛ-tɛ coordonnées (sɩɩyɛ, tilima), sɩpaɣzɩɣna 0.//nɛ pɩpɩsɩɣ kɩ-tɛ matʋ [(x1, y1), (x2, y2) ...] nɛ pɩwɩlɩɣ se //Ye ŋha-ɖʋ lst nɛ x, ɖɩñɩnɩ x ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ//paa n̄ɩŋgʋ ŋgʋ kɩ-taa lɛ, pɩpɩzɩɣ nɛ pɩla se pilinzi ndɩ ndɩ wɛɛ kɩ-taa.//Pɩwɛ ɛzɩ matrix yɔ, ɛlɛ pɩtɛkɛ ɛzɩ matrix yɔ, //Pʊtɔbʊʊ se ŋwɛna 2 dimensions taa, ɛzɩ nʊmɔʊ ŋgʊ kɩwɛna yɔ, // >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)
// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}
// >>> get_row([][]int{}, 1)
// [][]interface{}{}
// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)
// [][]int{[]interface{}{2, 2}}
func get_row(lst [][]int, x int) [][]interface{} {
","package get_row_test

import (
	""sort""
)

func get_row(lst [][]int, x int) [][]interface{} {
	var result [][]interface{}

	for i, row := range lst {
		var temp []interface{}
		for j, value := range row {
			if value == x {
				temp = append(temp, []interface{}{i, j})
			}
		}
		// Sort columns in descending order for the current row
		sort.Slice(temp, func(a, b int) bool {
			return temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)
		})
		result = append(result, temp...)
	}

	// result is already sorted by rows since we've traversed `lst` row by row
	return result
}","func TestGet_Row(t *testing.T) {
  candidate := get_row
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },
     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },
     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },
     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_88,kbp_Latn,go_test.go,"package sort_array_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //* Taapɩsɩnɩ tɔm ndʋ pama-ŋ yɔ tɩ-taa natʋyʋ.//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ://Yaa ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ.//Ŋkaɣ ñɔɔzʋʋ tɔm kɩkalasɩ nzɩ sɩ-hɩɖɛ sɛwa yɔ sɩ-tɛ hɔɔlɩŋ weyi ɩ-taa yɔ, yee pɩ-tɛ hɔɔlɩŋ weyi ɩ-taa lɛ, kajalaɣ ñɩŋgʋ nɛ kɛtɛ ñɩŋgʋ pɛwɛ ndɩ yɔ, //Ye ŋha-ɖʋ nimero waa mba pɛfɛyɩ kamaɣ yɔ, pɩpɔzʋʋ se ɖɩpɩsɩna nimero waa mba pɛfɛyɩ kamaɣ yɔ, pa-taa lɛ, ɖɩkpaɣ nimero waa mba pɛfɛyɩ kamaɣ yɔ nɛ ɖɩpɩsɩna nimero ŋgʋ kɩ-taa lɛ, ɖɩkpaɣ nimero ŋgʋ kɩ-taa lɛ, ɖɩkpaɣ nimero ŋgʋ kɩ-taa lɛ, ɖɩpɩsɩna nimero ŋgʋ kɩ-taa lɛ.// >>> sort_array([]int{})
// []int{}
// >>> sort_array([]int{5})
// []int{5}
// >>> sort_array([]int{2, 4, 3, 0, 1, 5})
// []int{0, 1, 2, 3, 4, 5}
// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})
// []int{6, 5, 4, 3, 2, 1, 0}
func sort_array(array []int) []int {
","package sort_array_test

import (
    ""sort""
)

func sort_array(array []int) []int {
    if len(array) <= 1 {
        return append([]int{}, array...)
    }

    result := append([]int{}, array...) // Copy the array to avoid mutating the input
    if (result[0]+result[len(result)-1])%2 == 0 {
        sort.Sort(sort.Reverse(sort.IntSlice(result))) // Sort in descending order
    } else {
        sort.Ints(result) // Sort in ascending order
    }

    return result
}","func TestSort_Array(t *testing.T) {
  candidate := sort_array
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{5}), expected: []int{5} },
     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },
     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },
     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },
     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },
     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_89,kbp_Latn,go_test.go,"package encrypt_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Pɩtɛ lɛ, ɖɩkpaɣ ɛzɩ ɛyaa naalɛ yɔ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ lona naalɛ.//Pɩwɛɛ se pɛlɛɣzɩ alfabbɛɛtɩ ŋgʋ nɛ pama-kʋ nɛ pamaɣna se //pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ alɩbɛɛtɩ wɛʊ yɔ.//Kpaɣ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɛ // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
func encrypt(s string) string {
","func encrypt(s string) string {
    result := []rune(s)
    for i, char := range result {
        if char >= 'a' && char <= 'z' {
            result[i] = 'a' + (char-'a'+4)%26
        } else if char >= 'A' && char <= 'Z' {
            result[i] = 'A' + (char-'A'+4)%26
        }
    }
    return string(result)
}","func TestEncrypt(t *testing.T) {
  candidate := encrypt
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""hi""), expected: ""lm"" },
     { actual: candidate(""asdfghjkl""), expected: ""ewhjklnop"" },
     { actual: candidate(""gf""), expected: ""kj"" },
     { actual: candidate(""et""), expected: ""ix"" },
     { actual: candidate(""faewfawefaewg""), expected: ""jeiajeaijeiak"" },
     { actual: candidate(""hellomyfriend""), expected: ""lippsqcjvmirh"" },
     { actual: candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""), expected: ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" },
     { actual: candidate(""a""), expected: ""e"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_91,kbp_Latn,go_test.go,"package is_bored_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Tɔm hɔɔlɩŋ taa lɛ, pamaɣna-ɩ nɛ mayaɣ '.', '?' yaa '!'.//Tɔm piye ""m"" ɖɩlɩna tɔm piye ""m"" taa.//Pɔkɔŋ-ŋ haʋ tɔm pee sakɩyɛ nɛ ña-tʋmɩyɛ lɛ se ŋkalɩ-yɛ.// >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
func is_bored(S string) int {
","package is_bored_test

import (
    ""strings""
    ""testing""
    ""fmt""
)

func is_bored(S string) int {
    sentences := strings.FieldsFunc(S, func(r rune) bool {
        return r == '.' || r == '?' || r == '!'
    })
    count := 0
    for _, sentence := range sentences {
        trimmed := strings.TrimSpace(sentence)
        if strings.HasPrefix(trimmed, ""I "") {
            count++
        }
    }
    return count
}

func TestIsBored(t *testing.T) {
    tests := []struct {
        input string
        want  int
    }{
        {""Hello world"", 0},
        {""The sky is blue. The sun is shining. I love this weather"", 1},
        {""I am here. I am there. I am everywhere"", 3},
        {""What's up? Are you ok? Yes, I am!"", 1},
        {"""", 0},
        {""I."", 1},
        {""I! am excited. I? am curious"", 2},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf(""is_bored(%q)"", tt.input), func(t *testing.T) {
            got := is_bored(tt.input)
            if got != tt.want {
                t.Errorf(""got %d, want %d"", got, tt.want)
            }
        })
    }
}","func TestIs_Bored(t *testing.T) {
  candidate := is_bored
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hello world""), expected: 0 },
     { actual: candidate(""Is the sky blue?""), expected: 0 },
     { actual: candidate(""I love It !""), expected: 1 },
     { actual: candidate(""bIt""), expected: 0 },
     { actual: candidate(""I feel good today. I will be productive. will kill It""), expected: 2 },
     { actual: candidate(""You and I are going for a walk""), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_92,kbp_Latn,go_test.go,"package any_int_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Pɩpɩsɩɣ false paa ɛzɩmtaa.//Ɛpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa lɛ, yee tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ.//Lɩzɩ tʋmɩyɛ nɖɩ ɖɩmʋɣna nimbrɩwaa naadozo yɔ.// >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
func any_int(x float64, y float64, z float64) bool {
","package any_int_test

import (
    ""testing""
)

func any_int(x float64, y float64, z float64) bool {
    // Check if x, y, and z are integers
    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {
        return false
    }

    // Check if one of the numbers is the sum of the other two
    if x == y+z || y == x+z || z == x+y {
        return true
    }

    return false
}

func TestAnyInt(t *testing.T) {
    if !any_int(5, 2, 7) {
        t.Errorf(""Expected true for any_int(5, 2, 7)"")
    }
    if any_int(3, 2, 2) {
        t.Errorf(""Expected false for any_int(3, 2, 2)"")
    }
    if !any_int(3, -2, 1) {
        t.Errorf(""Expected true for any_int(3, -2, 1)"")
    }
    if any_int(3.6, -2.2, 2) {
        t.Errorf(""Expected false for any_int(3.6, -2.2, 2)"")
    }
}","func TestAny_Int(t *testing.T) {
  candidate := any_int
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2, 3, 1), expected: true },
     { actual: candidate(2.5, 2, 3), expected: false },
     { actual: candidate(1.5, 5, 3.5), expected: false },
     { actual: candidate(2, 6, 2), expected: false },
     { actual: candidate(4, 2, 2), expected: true },
     { actual: candidate(2.2, 2.2, 2.2), expected: false },
     { actual: candidate(-4, 6, 2), expected: true },
     { actual: candidate(2, 1, 1), expected: true },
     { actual: candidate(3, 4, 7), expected: true },
     { actual: candidate(3.0, 4, 7), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_93,kbp_Latn,go_test.go,"package encode_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Maɣzɩ se masɩ ɖeke tɔm.//Tɔm piye nɖɩ ɖɩlɩnɩ tɔm piye nɖɩ ɖɩ-taa?//Tɔm ndʋ tɩ-taa lɛ , pama takayaɣ ŋga ka-taa pama tɔm pee naalɛ yɔ .//Ɛlɛɣzɩna matʋ tɩŋa nɛ ɛtɛzɩna matʋ ndʋ tɩ-taa paayɔɔdɩ yɔ.//Maʋ tʋmɩyɛ nɖɩ ɖɩmʋɣ tɔm natʋyʋ nɛ ɖɩɖʋ-tʋ takayaɣ nakɛyɛ taa yɔ.// >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
func encode(message string) string {
","package encode_test

import (
	""strings""
	""unicode""
)

func encode(message string) string {
	var encodedMessage strings.Builder

	// Mapping of vowels to the letter appearing 2 places ahead
	vowelReplacement := map[rune]rune{
		'a': 'c',
		'A': 'C',
		'e': 'g',
		'E': 'G',
		'i': 'k',
		'I': 'K',
		'o': 'q',
		'O': 'Q',
		'u': 'w',
		'U': 'W',
	}

	for _, char := range message {
		if unicode.IsLetter(char) {
			// Swap case of the character
			if unicode.IsUpper(char) {
				char = unicode.ToLower(char)
			} else {
				char = unicode.ToUpper(char)
			}

			// Replace vowel if the character is a vowel
			if replacement, isVowel := vowelReplacement[char]; isVowel {
				char = replacement
			}
		}

		encodedMessage.WriteRune(char)
	}

	return encodedMessage.String()
}","func TestEncode(t *testing.T) {
  candidate := encode
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""TEST""), expected: ""tgst"" },
     { actual: candidate(""Mudasir""), expected: ""mWDCSKR"" },
     { actual: candidate(""YES""), expected: ""ygs"" },
     { actual: candidate(""This is a message""), expected: ""tHKS KS C MGSSCGG"" },
     { actual: candidate(""I DoNt KnOw WhAt tO WrItE""), expected: ""k dQnT kNqW wHcT Tq wRkTg"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_94,kbp_Latn,go_test.go,"package skjkasdkd_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩwɛɛ se ɖɩñɩnɩ mayaɣ ŋga kɛwɛ ñɩm siŋŋ yɔ nɛ ɖɩpɩsɩ ka-taa mayaɣ ŋga kɛwɛ ñɩm siŋŋ yɔ.//Pʊtɔbʊʊ se ŋwɛna nimero waa tɩŋa.// >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})
// 10
// >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})
// 25
// >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})
// 13
// >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})
// 11
// >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})
// 3
// >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})
// 7
func skjkasdkd(lst []int) int {
","package skjkasdkd_test

import (
	""testing""
)

// Helper function to check if a number is prime
func isPrime(n int) bool {
	if n < 2 {
		return false
	}
	for i := 2; i*i <= n; i++ {
		if n%i == 0 {
			return false
		}
	}
	return true
}

// Function to calculate the sum of digits of a number
func sumOfDigits(n int) int {
	sum := 0
	for n > 0 {
		sum += n % 10
		n /= 10
	}
	return sum
}

// Function to find the largest prime and return the sum of its digits
func skjkasdkd(lst []int) int {
	maxPrime := -1
	for _, num := range lst {
		if isPrime(num) && num > maxPrime {
			maxPrime = num
		}
	}
	if maxPrime == -1 {
		return 0
	}
	return sumOfDigits(maxPrime)
}

func TestSkjkasdkd(t *testing.T) {
	tests := []struct {
		input    []int
		expected int
	}{
		{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},
		{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},
		{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},
		{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},
		{[]int{0, 81, 12, 3, 1, 21}, 3},
		{[]int{0, 8, 1, 2, 1, 7}, 7},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
			result := skjkasdkd(test.input)
			if result != test.expected {
				t.Errorf(""got %v, want %v"", result, test.expected)
			}
		})
	}
}","func TestSkjkasdkd(t *testing.T) {
  candidate := skjkasdkd
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },
     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },
     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },
     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },
     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },
     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },
     { actual: candidate([]int{8191}), expected: 19 },
     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },
     { actual: candidate([]int{127, 97, 8192}), expected: 10 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_95,kbp_Latn,go_test.go,"package check_dict_case_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩwɛɛ se tʋmɩyɛ nɖɩ ɖɩpɩsɩ false yee pɩtɛkɛ mayaɣ ŋga pama-kɛ yɔ.//Pɩtɛkɛ mbʋ yɔ, pɩpɩsɩɣ false.//Pɩkɛna ɛyʊ lɛlʊ, ɛ-tɛ ɛyʊ lɛlʊ tɩŋa wɛna ɛyʊ lɛlʊ.// >>> check_dict_case(map[string]string{""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case(map[string]string{""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case(map[interface{}]string{""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case(map[string]string{""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case(map[string]string{""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
func check_dict_case(dict map[string]string) bool {
","func check_dict_case(dict map[string]string) bool {
    if len(dict) == 0 {
        return false
    }

    var allLowercase, allUppercase bool
    for k := range dict {
        if k != strings.ToLower(k) && k != strings.ToUpper(k) {
            return false
        }
        if k == strings.ToLower(k) {
            if allUppercase {
                return false
            }
            allLowercase = true
        }
        if k == strings.ToUpper(k) {
            if allLowercase {
                return false
            }
            allUppercase = true
        }
    }

    return allLowercase || allUppercase
}","func TestCheck_Dict_Case(t *testing.T) {
  candidate := check_dict_case
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""b"": ""banana""}), expected: true },
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}), expected: false },
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}), expected: false },
     { actual: candidate(map[string]string{""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}), expected: false },
     { actual: candidate(map[string]string{""STATE"": ""NC"", ""ZIP"": ""12345""}), expected: true },
     { actual: candidate(map[string]string{""fruit"": ""Orange"", ""taste"": ""Sweet""}), expected: true },
     { actual: candidate(map[string]string{}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_96,kbp_Latn,go_test.go,"package count_up_to_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ɛyʊ ɛ-tɛ ɛyʊtʊ ndʊ tɩ-tɛ ɛyʊtʊ ndʊ tɩkɩlɩɣ yɔ.//Palakɩ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ ɛyʊ kʊyʊm nɛ ɖɩpɩsɩɣ kajalaɣ n waa yɔ.// >>> count_up_to(5)
// []int{2, 3}
// >>> count_up_to(11)
// []int{2, 3, 5, 7}
// >>> count_up_to(0)
// []int{}
// >>> count_up_to(20)
// []int{2, 3, 5, 7, 11, 13, 17, 19}
// >>> count_up_to(1)
// []int{}
// >>> count_up_to(18)
// []int{2, 3, 5, 7, 11, 13, 17}
func count_up_to(n int) []int {
","func count_up_to(n int) []int {
	primes := []int{}
	for num := 2; num < n; num++ {
		if isPrime(num) {
			primes = append(primes, num)
		}
	}
	return primes
}

func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	for i := 2; i*i <= num; i++ {
		if num%i == 0 {
			return false
		}
	}
	return true
}","func TestCount_Up_To(t *testing.T) {
  candidate := count_up_to
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: []int{2, 3} },
     { actual: candidate(6), expected: []int{2, 3, 5} },
     { actual: candidate(7), expected: []int{2, 3, 5} },
     { actual: candidate(10), expected: []int{2, 3, 5, 7} },
     { actual: candidate(0), expected: []int{} },
     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },
     { actual: candidate(1), expected: []int{} },
     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },
     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },
     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_97,kbp_Latn,go_test.go,"package multiply_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩwɛɛ se ɖɩmaɣzɩ se tɔm ndʋ ɖɩyɔɔdaa yɔ, tɩkɛ toovenim paa ɛzɩmtaa.//Kɩ-tɛ n̄ɩɣyʋʋ kɛ ɛ-tɛ n̄ɩɣyʋʋ mayaɣ.//Kpaɣ kɩ-tɛ ɛyʊ nɛ ɛɖaɣnɩ pɩsʋʋ ɛ-tɛ ɛyʊ.// >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
func multiply(a int, b int) int {
","package multiply_test

import (
    ""testing""
    ""fmt""
)

// Complete the function that takes two integers and returns 
// the product of their unit digits.
// Assume the input is always valid.
func multiply(a int, b int) int {
    unitA := abs(a) % 10
    unitB := abs(b) % 10
    return unitA * unitB
}

func abs(n int) int {
    if n < 0 {
        return -n
    }
    return n
}

func TestMultiply(t *testing.T) {
    fmt.Println(multiply(148, 412)) // 16
    fmt.Println(multiply(19, 28))   // 72
    fmt.Println(multiply(2020, 1851)) // 0
    fmt.Println(multiply(14, -15))  // 20
}","func TestMultiply(t *testing.T) {
  candidate := multiply
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(148, 412), expected: 16 },
     { actual: candidate(19, 28), expected: 72 },
     { actual: candidate(2020, 1851), expected: 0 },
     { actual: candidate(14, -15), expected: 20 },
     { actual: candidate(76, 67), expected: 42 },
     { actual: candidate(17, 27), expected: 49 },
     { actual: candidate(0, 1), expected: 0 },
     { actual: candidate(0, 0), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_98,kbp_Latn,go_test.go,"package count_upper_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ye ŋwɛna masɩ nzɩ sɩ-taa pama hɩla kɩsɛsɛna yɔ, kalɩ masɩ nzɩ sɩ-taa pama hɩla kɩsɛna yɔ.// >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
func count_upper(s string) int {
","package count_upper_test

import (
    ""testing""
)

func count_upper(s string) int {
    uppercaseVowels := ""AEIOU""
    count := 0
    
    for i := 0; i < len(s); i += 2 {
        if contains(uppercaseVowels, s[i]) {
            count++
        }
    }
    
    return count
}

func contains(vowels string, ch byte) bool {
    for i := 0; i < len(vowels); i++ {
        if vowels[i] == ch {
            return true
        }
    }
    return false
}

func TestCountUpper(t *testing.T) {
    tests := []struct {
        input    string
        expected int
    }{
        {""aBCdEf"", 1},
        {""abcdefg"", 0},
        {""dBBE"", 0},
    }

    for _, test := range tests {
        result := count_upper(test.input)
        if result != test.expected {
            t.Errorf(""For input '%s', expected %d but got %d"", test.input, test.expected, result)
        }
    }
}","func TestCount_Upper(t *testing.T) {
  candidate := count_upper
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""aBCdEf""), expected: 1 },
     { actual: candidate(""abcdefg""), expected: 0 },
     { actual: candidate(""dBBE""), expected: 0 },
     { actual: candidate(""B""), expected: 0 },
     { actual: candidate(""U""), expected: 1 },
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""EEEE""), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_99,kbp_Latn,go_test.go,"package closest_integer_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Ɛlɩna ɛyʊ ɛ-tɛ ɛyʊtʊ naalɛ yɔɔ, ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ.//Ɛtɛyɩɣ ɛ-tɛ ɛyʊ kɩfalʊ nɛ ɛ-tɛ ɛyʊ kɩfalʊ.//Lɩzɩ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ kɩjɛyɩɣ (ŋgbɛyɛ) nɛ ɖɩwɩlɩɣ mayaɣ nakɛyɛ yɔ // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value string) int {
","package closest_integer_test

import (
	""strconv""
	""math""
)

func closest_integer(value string) int {
	num, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return 0 // handle error appropriately in real scenarios
	}
	if num > 0 {
		return int(math.Ceil(num - 0.5))
	}
	return int(math.Floor(num + 0.5))
}","func TestClosest_Integer(t *testing.T) {
  candidate := closest_integer
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""10""), expected: 10 },
     { actual: candidate(""14.5""), expected: 15 },
     { actual: candidate(""-15.5""), expected: -16 },
     { actual: candidate(""15.3""), expected: 15 },
     { actual: candidate(""0""), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_100,kbp_Latn,go_test.go,"package make_a_pile_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //i kɛna pɩyɛ ndɩ ɖɩ-tɛ wɛtʊ (i+1).//Pɩsɩ nɛ ŋna-ɩ tɔm kɩsɔzɩtʋ//- ɛtɛyɩɣ ɛtɛyɩɣ lɛ, ɛtɛyɩɣ ɖɔɖɔ. //- ɛtɛyɩɣ nabʊyʊ taa yee n ɛtɛyɩɣ kɔyɔ. //Pɩtɛ pɩyɛ nɖɩ ɖɩ-taa pɩcɩɩcɩɩ yɔ, ɖɩ-taa://Kajalaɣ n̄ɩɣyʋʋ taa lɛ, n̄ɩɣlɩm n̄ɩmbʋ.//Ye ŋha-ɖʋ ɛyʊ kʊyʊmʊm n kɔyɔ, pɩwɛɛ se ŋñɔɔzɩ ɛ-tɩ nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa.// >>> make_a_pile(3)
// []int{3, 5, 7}
func make_a_pile(n int) []int {
","package make_a_pile_test

import (
    ""testing""
    ""fmt""
)

func make_a_pile(n int) []int {
    pile := make([]int, n)
    currentStones := n

    for i := 0; i < n; i++ {
        pile[i] = currentStones
        if n%2 == 0 {
            currentStones += 2
        } else {
            currentStones += 2
        }
    }

    return pile
}

func TestMakeAPile(t *testing.T) {
    cases := []struct {
        input    int
        expected []int
    }{
        {3, []int{3, 5, 7}},
        {4, []int{4, 6, 8, 10}},
        {1, []int{1}},
        {5, []int{5, 7, 9, 11, 13}},
    }

    for _, c := range cases {
        res := make_a_pile(c.input)
        if fmt.Sprintf(""%v"", res) != fmt.Sprintf(""%v"", c.expected) {
            t.Errorf(""make_a_pile(%d) == %v, expected %v"", c.input, res, c.expected)
        }
    }
}","func TestMake_A_Pile(t *testing.T) {
  candidate := make_a_pile
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: []int{3, 5, 7} },
     { actual: candidate(4), expected: []int{4, 6, 8, 10} },
     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },
     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },
     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_101,kbp_Latn,go_test.go,"package words_string_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ://Ŋkaɣ wɛnʋʋ tɔm pee sakɩyɛ nɛ ŋtayɩ-yɛ nɛ hɩlaɣ yaa tɩyɛ.// >>> words_string(""Hi, my name is John"")
// []string{""Hi"", ""my"", ""name"", ""is"", ""John""}
// >>> words_string(""One, two, three, four, five, six"")
// []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""}
func words_string(s string) []string {
","package words_string_test

import (
    ""testing""
    ""strings""
    ""fmt""
    ""regexp""
)

func words_string(s string) []string {
    re := regexp.MustCompile(`[,\s]+`)
    return re.Split(s, -1)
}

func TestWordsString(t *testing.T) {
    tests := []struct{
        input string
        expected []string
    }{
        {""Hi, my name is John"", []string{""Hi"", ""my"", ""name"", ""is"", ""John""}},
        {""One, two, three, four, five, six"", []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""}},
        {""a,b,c"", []string{""a"", ""b"", ""c""}},
        {""hello world"", []string{""hello"", ""world""}},
    }

    for _, test := range tests {
        result := words_string(test.input)
        if !equal(result, test.expected) {
            t.Errorf(""Expected %v, but got %v"", test.expected, result)
        }
    }
}

func equal(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestWords_String(t *testing.T) {
  candidate := words_string
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hi, my name is John""), expected: []string{""Hi"", ""my"", ""name"", ""is"", ""John""} },
     { actual: candidate(""One, two, three, four, five, six""), expected: []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""} },
     { actual: candidate(""Hi, my name""), expected: []string{""Hi"", ""my"", ""name""} },
     { actual: candidate(""One,, two, three, four, five, six,""), expected: []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""} },
     { actual: candidate(""""), expected: []string{} },
     { actual: candidate(""ahmed     , gamal""), expected: []string{""ahmed"", ""gamal""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_102,kbp_Latn,go_test.go,"package choose_num_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ye pɩfɛyɩ kɔyɔ, pɩpɔzʋʋ se ɖɩpɩsɩɣ -1.//Ɛjaɖɛ nɖɩ ɖɩ-taa lɛ, ɛyaa mba pɛtɛyɩɣ ɖama yɔ, pa-taa lɛ, mba kɩlɩna ɖɔʊ.//Tʊmɩyɛ ɖɩnɛ ɖɩkpaɣ ɛyʊ kʊdɔŋ naalɛ x nɛ y nɛ ɖɩpɩsɩ ɛyʊ kʊdɔŋ // >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
func choose_num(x int, y int) int {
","func choose_num(x int, y int) int {
	if x > y {
		return -1
	}
	// Start from y and move backwards looking for the largest even number
	for i := y; i >= x; i-- {
		if i%2 == 0 {
			return i
		}
	}
	return -1
}

func TestChooseNum(t *testing.T) {
	tests := []struct {
		x, y, expected int
	}{
		{12, 15, 14},
		{13, 12, -1},
		{4, 10, 10},
		{5, 5, -1},
		{6, 6, 6},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""x=%d_y=%d"", test.x, test.y), func(t *testing.T) {
			result := choose_num(test.x, test.y)
			if result != test.expected {
				t.Errorf(""For choose_num(%d, %d), expected %d, but got %d"", test.x, test.y, test.expected, result)
			}
		})
	}
}","func TestChoose_Num(t *testing.T) {
  candidate := choose_num
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(12, 15), expected: 14 },
     { actual: candidate(13, 12), expected: -1 },
     { actual: candidate(33, 12354), expected: 12354 },
     { actual: candidate(5234, 5233), expected: -1 },
     { actual: candidate(6, 29), expected: 28 },
     { actual: candidate(27, 10), expected: -1 },
     { actual: candidate(7, 7), expected: -1 },
     { actual: candidate(546, 546), expected: 546 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_104,kbp_Latn,go_test.go,"package unique_digits_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Pɩwɛɛ se patasɩ-ɩ tɔm ndʋ tɩ-yɔɔ tɔm pɔzʋʋ yɔ, tɩ-taa tɔm ndɩ ndɩ.//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Ɛtɛyɩ ɛtɛrɩ waa x nɛ ɛtɛrɩ waa tɩŋa payɩ lɛ, ɛtɛyɩ-wɛ nɛ ɛtɛrɩ waa tɩŋa.// >>> unique_digits([]int{15, 33, 1422, 1})
// []int{1, 15, 33}
// >>> unique_digits([]int{152, 323, 1422, 10})
// []int{}
func unique_digits(x []int) []int {
","package unique_digits_test

import (
    ""sort""
)

// unique_digits returns a sorted list of all elements that don't have any even digit.
func unique_digits(x []int) []int {
    result := []int{}
    for _, num := range x {
        if hasEvenDigit(num) == false {
            result = append(result, num)
        }
    }
    sort.Ints(result)
    return result
}

// hasEvenDigit checks if a given number contains any even digit.
func hasEvenDigit(num int) bool {
    for num > 0 {
        digit := num % 10
        if digit%2 == 0 {
            return true
        }
        num /= 10
    }
    return false
}","func TestUnique_Digits(t *testing.T) {
  candidate := unique_digits
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },
     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },
     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },
     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_105,kbp_Latn,go_test.go,"package by_length_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //""Kʋyʋm"", ""Ɛyaa naalɛ"", ""Naadozo"", ""Naanza"", ""Lima"", ""Lamamɩŋ"", ""Lazɩm"", ""Lamɩŋ lutozo"", ""Lamɩŋ lutozo"", ""Lamɩŋ nakʋ"".//Pɩtɛ lɛ, ŋlɛɣzɩna mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga nɛ ŋyele mayaɣ ŋga.//Ye ŋwɛna nimero waa tɩŋa yɔ, kpaɣ nimero waa tɩŋa nɛ ŋtɛzɩna 1 nɛ 9 pɛ-hɛkʋ taa.// >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})
// []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""}
// If the list is empty, return an empty list:
// >>> by_length([]int{})
// []string{}
// If the list has any strange number ignore it:
// >>> by_length([]int{1, -1, 55})
// []string{""One""}
func by_length(arr []int) []string {
","package by_length_test

import (
    ""testing""
    ""sort""
)

func by_length(arr []int) []string {
    // Filter numbers between 1 and 9
    filtered := []int{}
    for _, num := range arr {
        if num >= 1 && num <= 9 {
            filtered = append(filtered, num)
        }
    }

    // Sort in ascending order
    sort.Ints(filtered)

    // Reverse the sorted slice
    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {
        filtered[i], filtered[j] = filtered[j], filtered[i]
    }

    // Map numbers to their corresponding names
    numToString := map[int]string{
        1: ""One"", 2: ""Two"", 3: ""Three"",
        4: ""Four"", 5: ""Five"", 6: ""Six"",
        7: ""Seven"", 8: ""Eight"", 9: ""Nine"",
    }

    // Create the result slice with names
    result := []string{}
    for _, num := range filtered {
        result = append(result, numToString[num])
    }

    return result
}

func TestByLength(t *testing.T) {
    tests := []struct {
        input []int
        want  []string
    }{
        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""}},
        {[]int{}, []string{}},
        {[]int{1, -1, 55}, []string{""One""}},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
            got := by_length(test.input)
            if !equals(got, test.want) {
                t.Errorf(""got = %v; want %v"", got, test.want)
            }
        })
    }
}

func equals(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestBy_Length(t *testing.T) {
  candidate := by_length
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""} },
     { actual: candidate([]int{}), expected: []string{} },
     { actual: candidate([]int{1, -1, 55}), expected: []string{""One""} },
     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{""Three"", ""Two"", ""One""} },
     { actual: candidate([]int{9, 4, 8}), expected: []string{""Nine"", ""Eight"", ""Four""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_106,kbp_Latn,go_test.go,"package f_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Kɩ-tɛ tɔmpiye i kɛna 1 nɛ i pɛ-tɛ tɔmpiye (1 * 2 * ... * i).//Maɣzɩnɩ 1 yɔɔ.//yaa lɛɛna taa lɛ, pɩlɩɣna 1 nɛ piwolo i pɛ-hɛkʊ taa.//Ɛtɛyɩɣ ɛ-tɛ n ñɩɣlɩm pɩyʊ nɛ ɛ-tɛ pʊtʊ weyi ɛ-tɛ pʊtʊnaa wɛtʊ wɛ i yɔ, ɛ-tɛ pʊtʊnaa wɛtʊ lɛɛtʊ taa, yee i ɛ-tɛ pʊtʊnaa ɛfɛyɩ kɔyɔ.//Ɖɩkpaɣ f kɛ ɛ-tɛ lɛɣtʊ tʊmɩyɛ, // >>> f(5)
// []int{1, 2, 6, 24, 15}
func f(n int) []int {
","package f_test

import (
    ""testing""
    ""fmt""
)

func f(n int) []int {
    result := make([]int, n)
    for i := 1; i <= n; i++ {
        if i%2 == 0 {
            result[i-1] = factorial(i)
        } else {
            result[i-1] = sum(i)
        }
    }
    return result
}

func factorial(num int) int {
    if num <= 1 {
        return 1
    }
    return num * factorial(num-1)
}

func sum(num int) int {
    s := 0
    for i := 1; i <= num; i++ {
        s += i
    }
    return s
}

func TestF(t *testing.T) {
    expected := []int{1, 2, 6, 24, 15}
    result := f(5)
    if !equals(expected, result) {
        t.Errorf(""Expected %v, got %v"", expected, result)
    }
}

func equals(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}

func main() {
    fmt.Println(f(5)) // Output: []int{1, 2, 6, 24, 15}
}","func TestF(t *testing.T) {
  candidate := f
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },
     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },
     { actual: candidate(1), expected: []int{1} },
     { actual: candidate(3), expected: []int{1, 2, 6} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_107,kbp_Latn,go_test.go,"package even_odd_palindrome_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ 1://Palindromes waa mba pɛwɛ hɔɔlɩŋ weyi ɩ-taa yɔ, mba payaɣ se ((1, n), nɛ pɩkpɛndɩnɩ.//Ye ŋha-ɩ nimero intérieur positif n, pɩsɩna nɛ ŋha-ɩ nimero waa mba pɛtɛyɩɣ nɛ mba pɛtɛyɩɣ yɔ.// >>> even_odd_palindrome(3)
// []interface{}{1, 2}
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// []interface{}{4, 6}
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned list has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n int) []interface{} {
","func isPalindrome(num int) bool {
    original := num
    reversed := 0
    for num > 0 {
        reversed = reversed*10 + num%10
        num /= 10
    }
    return original == reversed
}

func even_odd_palindrome(n int) []interface{} {
    evenCount, oddCount := 0, 0
    for i := 1; i <= n; i++ {
        if isPalindrome(i) {
            if i%2 == 0 {
                evenCount++
            } else {
                oddCount++
            }
        }
    }
    return []interface{}{evenCount, oddCount}
}","func TestEven_Odd_Palindrome(t *testing.T) {
  candidate := even_odd_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(123), expected: []interface{}{8, 13} },
     { actual: candidate(12), expected: []interface{}{4, 6} },
     { actual: candidate(3), expected: []interface{}{1, 2} },
     { actual: candidate(63), expected: []interface{}{6, 8} },
     { actual: candidate(25), expected: []interface{}{5, 6} },
     { actual: candidate(19), expected: []interface{}{4, 6} },
     { actual: candidate(9), expected: []interface{}{4, 5} },
     { actual: candidate(1), expected: []interface{}{0, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_108,kbp_Latn,go_test.go,"package count_nums_test

import (
    ""testing""
    ""fmt""
)

//Ɖɩkpaɣ ɛzɩ -123 lɛ, ɛ-tɛ mayaɣ kɔyɔ -1, 2 nɛ 3.//Yee nimero nakʋyʋ ɛwɛ kɩjɛyʊʊ kɔyɔ, ɛ-tɛ kajalaɣ nimero kɩjɛyʊʊ kɔyɔ: //Takayɩhatʋ ndʋ tɩtamsɩna \\ 0 \\ yɔ//Ma tʋmɩyɛ nɖɩ payaɣ se count_nums yɔ nɛ ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa pamaɣ hɔɔlɩŋ cikpeŋ yɔ nɛ ɖɩpɩsɩɣ // >>> count_nums([]int{})
// 0
// >>> count_nums([]int{-1, 11, -11})
// 1
// >>> count_nums([]int{1, 1, 2})
// 3
func count_nums(arr []int) int {
","package count_nums_test

import (
    ""testing""
    ""fmt""
)

func count_nums(arr []int) int {
    count := 0
    for _, num := range arr {
        digits := num
        sum := 0

        if digits < 0 {
            sum = digits % 10
            digits = -digits / 10
        }

        for digits > 0 {
            sum += digits % 10
            digits /= 10
        }

        if sum > 0 {
            count++
        }
    }
    return count
}

func TestCountNums(t *testing.T) {
    testCases := []struct {
        input    []int
        expected int
    }{
        {[]int{}, 0},
        {[]int{-1, 11, -11}, 1},
        {[]int{1, 1, 2}, 3},
    }

    for _, tc := range testCases {
        result := count_nums(tc.input)
        if result != tc.expected {
            t.Errorf(""Expected %v, got %v"", tc.expected, result)
        }
    }
}

func main() {
    fmt.Println(count_nums([]int{-1, 11, -11})) // Output: 1
    fmt.Println(count_nums([]int{1, 1, 2}))    // Output: 3
}","func TestCount_Nums(t *testing.T) {
  candidate := count_nums
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: 0 },
     { actual: candidate([]int{-1, -2, 0}), expected: 0 },
     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },
     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },
     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },
     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },
     { actual: candidate([]int{0, 1}), expected: 1 },
     { actual: candidate([]int{1}), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_109,kbp_Latn,go_test.go,"package move_one_ball_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Pɩkɛna kɩjɛyʋʋ se ŋtɩlɩ se tɔmpiye nɖɩ ɖɩ-taa ŋcaɣ yɔ, ɖɩ-taa tɔm pee kɩbana wɛna.//Ye ŋtɩna mayaɣ ŋga yɔ, pɩsɩna nɛ ŋtɩlɩ se ŋtɩna mayaɣ ŋga.//Pɩtɛ lɛ, pɩpɩsɩɣ true yaa false.//Ye pɩsaŋ yɔ, ŋpɩzɩɣ nɛ ŋla tʋmɩyɛ nɖɩ ɖɩ-yɔɔ nɛ ŋhiɣ takayaɣ ŋga ka-taa tɔm pɔyɔɔdɩ pɩ-tɔm yɔ.//Takayɩhatʋ ndʋ tɩtamsɩna \\ Nɔɔɖɛyaa Ɛgbɛyɛ \\ yɔ//Pɩtɛ lɛ, ɖɩtɛzɩɣna-ɖɩ nɛ ɖɩɖɛɣnɩ lone nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ.//Kɩ-tɛ kɩ-tɩ yɔɔ wɛʊ tɔbʋʋ se kɩ-tɛ kɩ-tɩ yɔɔ wɛʊ tɔbʋʋ se kɩ-tɛ kɩ-tɩ yɔɔ wɛʊ tɔbʋʋ se kɩ-tɛ kɩ-tɩ yɔɔ wɛʊ tɔbʋʋ.//Ŋpɩzɩɣ ŋla tʋmɩyɛ nɖɩ tam sakɩyɛ ɛzɩ ŋsɔɔlʋʋ yɔ.//Takayɩhatʋ ndʋ tɩwɛ pɩ-tɛɛ yɔ tɩwɛna kpasɩ Tɛtʊ yɔɔ://papɩzɩɣ nɛ palɩzɩ tɔmpiye nɖɩ nɛ paɖʊ-ɖɩ nɛ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩfɛyɩ ñamsʊʊ taa pɩtɩŋna tʊmɩyɛ nɖɩ ɖɩ-yɔɔ.//Pɩwɛɛ se ŋtɩlɩ se ye ŋtɩtɩlɩ mbʋ ŋsɔɔlaa se ŋla yɔ, ŋpɩzɩɣ nɛ ŋlɩzɩ mbʋ ŋsɔɔlaa se ŋla yɔ.//Ɖɩwɛna nimero waa ndɩ ndɩ nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa nɛ nimero waa tɩŋa.// >>> move_one_ball([]int{3, 4, 5, 1, 2})
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given list.
// >>> move_one_ball([]int{3, 5, 4, 1, 2})
// false
// Explanation:It is not possible to get non-decreasing order for the given
// list by performing any number of right shift operations.
func move_one_ball(arr []int) bool {
","func move_one_ball(arr []int) bool {
    n := len(arr)
    if n == 0 {
        return true
    }

    // Detect the point where the order breaks
    countBreaks := 0
    index := -1

    for i := 0; i < n; i++ {
        if arr[i] > arr[(i+1)%n] {
            countBreaks++
            index = i
        }
    }

    // If there is at most one point where the order breaks
    if countBreaks <= 1 {
        return true
    }

    return false
}","func TestMove_One_Ball(t *testing.T) {
  candidate := move_one_ball
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },
     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },
     { actual: candidate([]int{4, 3, 1, 2}), expected: false },
     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },
     { actual: candidate([]int{}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_110,kbp_Latn,go_test.go,"package exchange_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ye pɩtɛkɛ mbʋ yɔ, ŋpɩsɩɣ ""Aayɩ"".//Pɩwɛɛ se lst1 tɛ wondu tɩŋa ɩwɛɛ kɩmaŋ, pɩpɩsɩ ""ƐƐƐ"".//Yee pɩsaŋ se pɛlɛɣzɩ wondu lst1 nɛ lst2 pɛ-hɛkʋ taa nɛ pɩsaŋ nɛ pala //Pɩfɛyɩ se pakpaɣ kɩmaŋ weyi ɛ-tɛ lst1 nɛ lst2 pɛ-hɛkʋ taa yɔ.//Pɩwɛɛ se ɖɩkpaɣ kɩlɛmʋʋ kʋnɛ nɛ ɖɩmaɣzɩ kɩ-yɔɔ nɛ ɖɩna se kɩ-taa tɔm ndʋ tɩ-tɩŋa tɩkɛ tɔm pee kɩbana na.//Nɛ kɩwɩlɩɣ se papɩzɩɣ nɛ pɛlɛɣzɩ wondu natʋyʋ yaa paapɩzɩɣ .//Tɔmpiye ɖɩnɛ ɖɩ-taa, ŋkaɣ labʊ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ nimero waa naalɛ yɔ, // >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})
// ""YES""
// >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})
// ""NO""
// It is assumed that the input lists will be non-empty.
func exchange(lst1 []int, lst2 []int) string {
","func exchange(lst1 []int, lst2 []int) string {
    hasEvenInLst2 := false
    
    for _, num := range lst2 {
        if num%2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasEvenInLst2 {
        return ""NO""
    }
    
    for _, num := range lst1 {
        if num%2 != 0 {
            return ""YES""
        }
    }

    return ""YES""
}","func TestExchange(t *testing.T) {
  candidate := exchange
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: ""YES"" },
     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: ""NO"" },
     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: ""YES"" },
     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: ""YES"" },
     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: ""NO"" },
     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: ""NO"" },
     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: ""YES"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_111,kbp_Latn,go_test.go,"package histogram_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Ye tɔm pee naayɛ ɛkpɛndɩ yɔ, pɩpɔzʋʋ se papɩsɩna-yɛ tɩŋa.//Takayaɣ ŋga ka-taa pama tɔm pee sakɩyɛ nɛ pama-yɛ ɖɔɖɔ sakɩyɛ yɔ.//Ye ŋwɛna tɔmpiye nɖɩ ɖɩwɩlɩɣ mayaɣ cikpelaɣ ŋga kɛwɛna mayaɣ cikpelaɣ yɔ, pɩsɩna nɛ ŋlɩzɩ mayaɣ ŋga kɛwɛna mayaɣ cikpelaɣ yɔ.// >>> histogram(""a b c"")
// map[string]int{""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// map[string]int{""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// map[string]int{""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// map[string]int{""b"": 4}
// >>> histogram("""")
// map[string]int{}
func histogram(test string) map[string]int {
","package histogram_test

import (
    ""strings""
)

func histogram(test string) map[string]int {
    if test == """" {
        return map[string]int{}
    }

    counts := make(map[string]int)
    words := strings.Fields(test)
    
    var maxCount int
    for _, word := range words {
        counts[word]++
        if counts[word] > maxCount {
            maxCount = counts[word]
        }
    }

    result := make(map[string]int)
    for key, count := range counts {
        if count == maxCount {
            result[key] = count
        }
    }

    return result
}","func TestHistogram(t *testing.T) {
  candidate := histogram
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""a b b a""), expected: map[string]int{""a"": 2, ""b"": 2} },
     { actual: candidate(""a b c a b""), expected: map[string]int{""a"": 2, ""b"": 2} },
     { actual: candidate(""a b c d g""), expected: map[string]int{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1} },
     { actual: candidate(""r t g""), expected: map[string]int{""r"": 1, ""t"": 1, ""g"": 1} },
     { actual: candidate(""b b b b a""), expected: map[string]int{""b"": 4} },
     { actual: candidate(""r t g""), expected: map[string]int{""r"": 1, ""t"": 1, ""g"": 1} },
     { actual: candidate(""""), expected: map[string]int{} },
     { actual: candidate(""a""), expected: map[string]int{""a"": 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_112,kbp_Latn,go_test.go,"package reverse_delete_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ //Pɩwɛɛ se ŋyele nɛ pama-ŋ tɔm pee wena a-taa tɔm pee lɩnaa yɔ nɛ ŋyele nɛ pama-ŋ ɖɔɖɔ tɔm pee wena awɛ toovenim nɛ cɛtɩm yɔ.//Ɛyʋ pɩzɩɣ nɛ ɛyɔɔdɩ se ɛ-tɔm kɛ palindrome, ye ɛ-tɔm ɛkalɩɣ ɛzɩ ɛkalɩɣ ɛ-tɔm nɛ pɩɖɛɛ yɔ.//Pɩtɛ lɛ, ŋcɔna se pɩlɩna mbʊ yɔ palindrome.//Pʊtɔbʊʊ se ɖɩkpaɣ tɔmpiye s nɛ c nɛ ɖɩɖɩzɩ tɔmpiye s nɛ ɖɩɖɩzɩ tɔmpiye c.//Tʋmɩyɛ // >>> reverse_delete(""abcde"", ""ae"")
// []interface{}{""bcd"", false}
// >>> reverse_delete(""abcdef"", ""b"")
// []interface{}{""acdef"", false}
// >>> reverse_delete(""abcdedcba"", ""ab"")
// []interface{}{""cdedc"", true}
func reverse_delete(s string, c string) []interface{} {
","func reverse_delete(s string, c string) []interface{} {
    // Create a map to store the characters to be deleted
    deleteMap := make(map[rune]bool)
    for _, ch := range c {
        deleteMap[ch] = true
    }
    
    // Filter the string s by removing characters present in deleteMap
    var filteredString []rune
    for _, ch := range s {
        if !deleteMap[ch] {
            filteredString = append(filteredString, ch)
        }
    }
    
    // Check if the filtered string is a palindrome
    n := len(filteredString)
    isPalindrome := true
    for i := 0; i < n/2; i++ {
        if filteredString[i] != filteredString[n-1-i] {
            isPalindrome = false
            break
        }
    }
    
    // Convert filteredString to a string and prepare result
    resultString := string(filteredString)
    return []interface{}{resultString, isPalindrome}
}","func TestReverse_Delete(t *testing.T) {
  candidate := reverse_delete
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""abcde"", ""ae""), expected: []interface{}{""bcd"", false} },
     { actual: candidate(""abcdef"", ""b""), expected: []interface{}{""acdef"", false} },
     { actual: candidate(""abcdedcba"", ""ab""), expected: []interface{}{""cdedc"", true} },
     { actual: candidate(""dwik"", ""w""), expected: []interface{}{""dik"", false} },
     { actual: candidate(""a"", ""a""), expected: []interface{}{"""", true} },
     { actual: candidate(""abcdedcba"", """"), expected: []interface{}{""abcdedcba"", true} },
     { actual: candidate(""abcdedcba"", ""v""), expected: []interface{}{""abcdedcba"", true} },
     { actual: candidate(""vabba"", ""v""), expected: []interface{}{""abba"", true} },
     { actual: candidate(""mamma"", ""mia""), expected: []interface{}{"""", true} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_113,kbp_Latn,go_test.go,"package odd_count_test

import (
    ""testing""
    ""fmt""
)

//Ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ.//Pɩwɛɛ se pɛlɛɣzɩ i waa tɩŋa nɛ //Paa wonuu ŋgʋ kɩ-taa lɛ, pɩwɛɛ se kɩwɛɛ ɛzɩ kɩ-tɛ wondu ndɩ ndɩ ndɩ ndʋ tɩwɛ kɩ-taa yɔ.//Ye ŋwɛna tɔm hɩla wena a-taa paa tɔm hɩla wena lɛ, awɛ nimasɩ ɖeke yɔ, pɩsɩna nɛ ŋlɩzɩ tɔm hɩla.// >>> odd_count([]string{""1234567""})
// []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""}
// >>> odd_count([]string{""3"", ""11111111""})
// []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""}
func odd_count(lst []string) []string {
","package odd_count_test

import (
	""fmt""
	""testing""
)

func odd_count(lst []string) []string {
	result := []string{}
	for _, str := range lst {
		oddCount := 0
		for _, char := range str {
			if char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {
				oddCount++
			}
		}
		output := fmt.Sprintf(""the number of odd elements %dn the str%1ng %d of the %dnput."", oddCount, oddCount, oddCount)
		result = append(result, output)
	}
	return result
}

func TestOddCount(t *testing.T) {
	tests := []struct {
		input    []string
		expected []string
	}{
		{[]string{""1234567""}, []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""}},
		{[]string{""3"", ""11111111""}, []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""}},
	}

	for _, test := range tests {
		if result := odd_count(test.input); !equals(result, test.expected) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
		}
	}
}

func equals(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestOdd_Count(t *testing.T) {
  candidate := odd_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""1234567""}), expected: []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""} },
     { actual: candidate([]string{""3"", ""11111111""}), expected: []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""} },
     { actual: candidate([]string{""271"", ""137"", ""314""}), expected: []string{""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_114,kbp_Latn,go_test.go,"package minSubArraySum_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ //Takayɩsɩ nzɩ sɩ-taa tɔm pee wɛ ndɩ ndɩ yɔ//Ye ŋwɛna nimero waa tɩŋa yɔ, ŋñɩnɩɣ nimero waa tɩŋa taa lɛ, nimero waa tɩŋa taa lɛ, ŋñɩnɩɣ nimero waa tɩŋa taa lɛ, ŋñɩnɩɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ, ŋnaɣ nimero waa tɩŋa taa lɛ,// >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})
// 1
// >>> minSubArraySum([]int{-1, -2, -3})
// -6
func minSubArraySum(nums []int) int {
","if len(nums) == 0 {
        return 0
    }
    
    minEndingHere := nums[0]
    minSoFar := nums[0]

    for _, num := range nums[1:] {
        if minEndingHere > 0 {
            minEndingHere = num
        } else {
            minEndingHere += num
        }
        
        if minEndingHere < minSoFar {
            minSoFar = minEndingHere
        }
    }
    
    return minSoFar
}","func TestMinsubarraysum(t *testing.T) {
  candidate := minSubArraySum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },
     { actual: candidate([]int{-1, -2, -3}), expected: -6 },
     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },
     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },
     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },
     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },
     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },
     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },
     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },
     { actual: candidate([]int{-10}), expected: -10 },
     { actual: candidate([]int{7}), expected: 7 },
     { actual: candidate([]int{1, -1}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_115,kbp_Latn,go_test.go,"package max_fill_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ 1://Wɩlɩ tam ɛzɩma ŋpɩzɩɣ nɛ ŋlabɩnɩ-yɛ tʋmɩyɛ yɔ.//Ña-tʋmɩyɛ lɛ se ŋlabɩnɩ tʋmɩyɛ pɔŋ nɛ ŋhɛzɩ pɔŋ taa.//Nɛ pɔpɔŋ tɩŋa taa lɛ, lɩm ɖɔŋ kʋɖʋm.//Paa lɔkɔ ŋgʋ lɛ, kɩwɛna pɔʋ ŋgʋ kɩ-taa papɩzɩɣ nɛ palɩzɩ lɩm yɔ.//Nɛ paa 1 ŋgʊ lɛ kɩkɛ lɩm pʊtʊ kʋɖʋm.//Paha-ŋ lɔkɔnaa mba pa-taa paa weyi lɛ ɛwɛ ɛzɩ ɛ-tɩ yɔ.// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)
// 6
// Example 2:
// >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)
// 5
// Example 3:
// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
func max_fill(grid [][]int, capacity int) int {
","package max_fill_test

import (
    ""testing""
    ""fmt""
)

func max_fill(grid [][]int, capacity int) int {
    totalLowerings := 0

    for _, row := range grid {
        waterInRow := 0
        
        for _, cell := range row {
            if cell == 1 {
                waterInRow++
            }
        }

        totalLowerings += (waterInRow + capacity - 1) / capacity
    }

    return totalLowerings
}

func TestMaxFill(t *testing.T) {
    tests := []struct {
        grid     [][]int
        capacity int
        expected int
    }{
        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},
        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},
        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},
    }

    for _, test := range tests {
        result := max_fill(test.grid, test.capacity)
        if result != test.expected {
            t.Errorf(""For grid %v with capacity %d, expected %d but got %d"", test.grid, test.capacity, test.expected, result)
        }
    }
}

func main() {
    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) // Output: 6
    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) // Output: 5
    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) // Output: 0
}","func TestMax_Fill(t *testing.T) {
  candidate := max_fill
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },
     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },
     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },
     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },
     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_116,kbp_Latn,go_test.go,"package sort_array_test

import (
    ""testing""
    ""fmt""
)

//Pɩwɛɛ se pala-ɖɩ nɛ ɖɩwɛɛ ɛzɩ ɖɩyɔɔdʋʋ yɔ://Ye ɛyʊ ɛfɛyɩna ɛ-ñʊʊ taa kɔyɔ, ɛ-tɛ ɛyʊtʊ wɛʊ lɛ, ɛ-tɛ ɛyʊtʊ wɛʊ lɛ, ɛ-tɛ ɛyʊtʊ wɛʊ lɛ.//Pɩtɛ lɛ, ɛyʊ ɛ-tɛ ɛyʊtʊmɩyɛ taa lɛ, ɛ-tɛ ɛyʊtʊmɩyɛ taa lɛ, ɛ-tɛ ɛyʊtʊmɩyɛ taa lɛ, ɛ-tɛ ɛyʊtʊmɩyɛ taa.//Pɩtɛ kataɣ kanɛ ka-taa, pɩwɛɛ se ŋñɔɔzɩ hɔɔlɩŋ weyi ɩ-taa nimero waa mba pɛfɛyɩ kamaɣ yɔ, nɛ ŋmaɣzɩna // >>> sort_array([]int{1, 5, 2, 3, 4})
// []int{1, 2, 3, 4, 5}
// >>> sort_array([]int{-2, -3, -4, -5, -6})
// []int{-6, -5, -4, -3, -2}
// >>> sort_array([]int{1, 0, 2, 3, 4})
// []int{0, 1, 2, 3, 4}
func sort_array(arr []int) []int {
","package sort_array_test

import (
    ""sort""
)

func sort_array(arr []int) []int {
    sort.Slice(arr, func(i, j int) bool {
        countOnes := func(x int) int {
            count := 0
            for x != 0 {
                count += x & 1
                x >>= 1
            }
            return count
        }

        countI := countOnes(arr[i])
        countJ := countOnes(arr[j])

        if countI == countJ {
            return arr[i] < arr[j]
        }
        return countI < countJ
    })
    return arr
}","func TestSort_Array(t *testing.T) {
  candidate := sort_array
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },
     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },
     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },
     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },
     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },
     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_117,kbp_Latn,go_test.go,"package select_words_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ: Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm ndʋ ŋtiyaa yɔ, tɩ-taa lɛ, masɩ nɛ tɔm hɔɔlɩŋ ɖeke wɛna.//Yee tɔmpiye s ɖɩfɛyɩ kɔyɔ, pɩpɔzʋʋ se ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩfɛyɩ yɔ.//n tɔmpiye, nɛ tɔm pee ana awɛɛ nɛ awɛɣ tɔmpiye s taa. //tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee kpeekpe listɩ nɛ pɩlɩna tɔmpiye s taa nɛ pɩ-taa wɛ tɔmpiye  ɖeyi ɖeyi yɔ//Ye ŋha-ɖʋ tɔmpiye s nɛ natʊyʊ n kɔyɔ, paɖʊ-ŋ tʋmɩyɛ se ŋlabɩnɩ tʊmɩyɛ // >>> select_words(""Mary had a little lamb"", 4)
// []string{""little""}
// >>> select_words(""Mary had a little lamb"", 3)
// []string{""Mary"", ""lamb""}
// >>> select_words(""simple white space"", 2)
// []string{}
// >>> select_words(""Hello world"", 4)
// []string{""world""}
// >>> select_words(""Uncle sam"", 3)
// []string{""Uncle""}
func select_words(s string, n int) []string {
","package select_words_test

import (
	""strings""
	""testing""
)

func select_words(s string, n int) []string {
	// Define a helper function to check if a character is a consonant.
	isConsonant := func(c rune) bool {
		c = rune(strings.ToLower(string(c))[0])
		return c >= 'a' && c <= 'z' && !strings.ContainsRune(""aeiou"", c)
	}

	// Split the string into words.
	words := strings.Fields(s)
	var result []string

	// Iterate over each word.
	for _, word := range words {
		consonantCount := 0
		// Count the consonants in the word.
		for _, char := range word {
			if isConsonant(char) {
				consonantCount++
			}
		}
		// If the number of consonants matches n, add the word to the result.
		if consonantCount == n {
			result = append(result, word)
		}
	}

	return result
}

func TestSelectWords(t *testing.T) {
	testCases := []struct {
		s        string
		n        int
		expected []string
	}{
		{""Mary had a little lamb"", 4, []string{""little""}},
		{""Mary had a little lamb"", 3, []string{""Mary"", ""lamb""}},
		{""simple white space"", 2, []string{}},
		{""Hello world"", 4, []string{""world""}},
		{""Uncle sam"", 3, []string{""Uncle""}},
	}

	for _, testCase := range testCases {
		result := select_words(testCase.s, testCase.n)
		if !equal(result, testCase.expected) {
			t.Errorf(""For input '%s' with n=%d, expected %v, but got %v"", testCase.s, testCase.n, testCase.expected, result)
		}
	}
}

func equal(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestSelect_Words(t *testing.T) {
  candidate := select_words
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Mary had a little lamb"", 4), expected: []string{""little""} },
     { actual: candidate(""Mary had a little lamb"", 3), expected: []string{""Mary"", ""lamb""} },
     { actual: candidate(""simple white space"", 2), expected: []string{} },
     { actual: candidate(""Hello world"", 4), expected: []string{""world""} },
     { actual: candidate(""Uncle sam"", 3), expected: []string{""Uncle""} },
     { actual: candidate("""", 4), expected: []string{} },
     { actual: candidate(""a b c d e f"", 1), expected: []string{""b"", ""c"", ""d"", ""f""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_118,kbp_Latn,go_test.go,"package get_closest_vowel_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔmpiye nɖɩ ɖɩ-taa ŋnaɣ-ɩ yɔ, ɖɩ-taa wɛ aŋglɛɛ kʋnʋŋ taa masɩ ɖeke.//Pɩwɛɛ se pamaɣna nɛ pana se tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ yɔ.//Ye ŋtɩtasɩ mayaɣ nakɛyɛ yɔ, yele nɛ ɖɩpɩsɩ mayaɣ ŋga ka-taa ŋtɩyɔɔdɩ natʋyʋ yɔ.//Tɔmpiye nɖɩ ɖɩlɩna tɔmpiye nɖɩ ɖɩ-nɩwaŋ yɔɔ (ɖɩ-tɛ tɔmpiye).//Payaɣ-mɩ se tɔm piye nɛ ɩñɩnɩ tɔm piye nɖɩ ɖɩñɔtɩnɩ-mɩ nɛ pɩkɩlɩ yɔ.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
func get_closest_vowel(word string) string {
","package get_closest_vowel_test

import (
    ""testing""
    ""fmt""
)

func get_closest_vowel(word string) string {
    vowels := ""aeiouAEIOU""
    isVowel := make(map[rune]bool)
    for _, v := range vowels {
        isVowel[v] = true
    }
    
    n := len(word)
    for i := n-2; i > 0; i-- {
        if isVowel[rune(word[i])] && 
           !isVowel[rune(word[i-1])] && 
           !isVowel[rune(word[i+1])] {
            return string(word[i])
        }
    }
    return """"
}

// Test functions
func TestGetClosestVowel(t *testing.T) {
    var tests = []struct {
        input    string
        expected string
    }{
        {""yogurt"", ""u""},
        {""FULL"", ""U""},
        {""quick"", """"},
        {""ab"", """"},
    }
    
    for _, test := range tests {
        result := get_closest_vowel(test.input)
        if result != test.expected {
            t.Errorf(""get_closest_vowel(%q) = %q; want %q"", test.input, result, test.expected)
        }
    }
}

func main() {
    fmt.Println(get_closest_vowel(""yogurt"")) // Output: ""u""
    fmt.Println(get_closest_vowel(""FULL""))   // Output: ""U""
    fmt.Println(get_closest_vowel(""quick""))  // Output: """"
    fmt.Println(get_closest_vowel(""ab""))     // Output: """"
}","func TestGet_Closest_Vowel(t *testing.T) {
  candidate := get_closest_vowel
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""yogurt""), expected: ""u"" },
     { actual: candidate(""full""), expected: ""u"" },
     { actual: candidate(""easy""), expected: """" },
     { actual: candidate(""eAsy""), expected: """" },
     { actual: candidate(""ali""), expected: """" },
     { actual: candidate(""bad""), expected: ""a"" },
     { actual: candidate(""most""), expected: ""o"" },
     { actual: candidate(""ab""), expected: """" },
     { actual: candidate(""ba""), expected: """" },
     { actual: candidate(""quick""), expected: """" },
     { actual: candidate(""anime""), expected: ""i"" },
     { actual: candidate(""Asia""), expected: """" },
     { actual: candidate(""Above""), expected: ""o"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_119,kbp_Latn,go_test.go,"package match_parens_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Ye pɩsaŋ se ɖɩlɩzɩ tɔmpiye nɖɩ ɖɩ-taa tɔm kɩlɩ ɖeu yɔ, ɖɩpɩsɩɣ tɔm piye ""ɛɛɛ"" nɛ ye pɩsaŋ se ɖɩlɩzɩ tɔm kɩlɩ ɖeu yɔ, ɖɩpɩsɩɣ tɔm piye ""ɛɛɛ"".//^ "" ()) "" pɩtɩkɛ mbʋ.//Ɖɩkpaɣ ɛzɩ: tɔmpiye '(())))' wɛ ɖeu, ɛlɛ tɔmpiye //Pɩkɛna tɔmpiye S nɛ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, yee pɩ-taa tɔmpiye S  ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye S  ɖɩ-taa lɛ, tɔmpiye S  ɖɩ-taa lɛ, tɔmpiye S  ɖɩ-taa lɛ.//Pɩwɛɛ se ɖɩtɩlɩ se paa ɖɩtɩla mbʋ yɔ, pɩkaɣ yebu nɛ ɖɩpɩzɩ nɛ ɖɩlɩzɩ tɔm pee kɩbana.//Ña-tʋmɩyɛ lɛ se ŋtazɩ nɛ ŋna se ŋpɩzɩɣ nɛ ŋkpɛndɩ tɔm pee wena awɛ kɩ-taa yɔ nɛ ŋla-yɛ nɛ ɩwɛɛ nɔɔ kʋɖʋmaɣ taa yaa we.//Pɩsɩ takayɩhayʋʋ ""[[Special:UserLogin_Special:UserLogin]]"" ñɩŋgʋ yɔɔ.//Pɩtɛ lɛ, ŋnaɣ se ŋwɛna tɔmpiye naalɛ, nɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, ŋnaɣ se ŋwɛna tɔmpiye nɖɩ ɖɩ-taa lɛ, ŋnaɣ ɖɔɖɔ tɔmpiye nɖɩ ɖɩ-taa lɛ, ŋnaɣ tɔmpiye nɖɩ ɖɩ-taa lɛ.// >>> match_parens([]string{""()("", "")""})
// ""Yes""
// >>> match_parens([]string{"")"", "")""})
// ""No""
func match_parens(lst []string) string {
","func match_parens(lst []string) string {
	left1, right1 := countParens(lst[0])
	left2, right2 := countParens(lst[1])

	if left1+left2 == right1+right2 {
		return ""Yes""
	}

	if left1-right1+left2-right2 == 0 {
		return ""Yes""
	}

	return ""No""
}

func countParens(s string) (left int, right int) {
	for _, c := range s {
		if c == '(' {
			left++
		} else if c == ')' {
			right++
		}
	}
	return
}

func TestMatchParens(t *testing.T) {
	tests := []struct {
		input    []string
		expected string
	}{
		{[]string{""()("", "")""}, ""Yes""},
		{[]string{"")"", "")""}, ""No""},
		{[]string{""((("", "")))""}, ""Yes""},
		{[]string{""("", "")""}, ""Yes""},
		{[]string{""))("", ""(""}, ""No""},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
			if got := match_parens(test.input); got != test.expected {
				t.Errorf(""match_parens(%v) = %v; want %v"", test.input, got, test.expected)
			}
		})
	}
}","func TestMatch_Parens(t *testing.T) {
  candidate := match_parens
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""()("", "")""}), expected: ""Yes"" },
     { actual: candidate([]string{"")"", "")""}), expected: ""No"" },
     { actual: candidate([]string{""(()(())"", ""())())""}), expected: ""No"" },
     { actual: candidate([]string{"")())"", ""(()()(""}), expected: ""Yes"" },
     { actual: candidate([]string{""(())))"", ""(()())((""}), expected: ""Yes"" },
     { actual: candidate([]string{""()"", ""())""}), expected: ""No"" },
     { actual: candidate([]string{""(()("", ""()))()""}), expected: ""Yes"" },
     { actual: candidate([]string{""(((("", ""((())""}), expected: ""No"" },
     { actual: candidate([]string{"")(()"", ""(()(""}), expected: ""No"" },
     { actual: candidate([]string{"")("", "")(""}), expected: ""No"" },
     { actual: candidate([]string{""("", "")""}), expected: ""Yes"" },
     { actual: candidate([]string{"")"", ""(""}), expected: ""Yes"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_120,kbp_Latn,go_test.go,"package maximum_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ 1://Kʋ-ɖaɣlɩkɩŋ k nɛ kɩ-tɛ kʊnʊŋ taa lɛ, kɩkɩlɩɣna k.//Ɛyʊ ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ tɔm ndʊ tɩ-taa lɛ.// >>> maximum([]int{-3, -4, 5}, 3)
// []int{-4, -3, 5}
// Example 2:
// >>> maximum([]int{4, -4, 4}, 2)
// []int{4, 4}
// Example 3:
// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)
// []int{2}
// Note:
// 1. The length of the list will be in the range of [1, 1000].
// 2. The elements in the list will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
func maximum(arr []int, k int) []int {
","package maximum_test

import (
    ""sort""
)

func maximum(arr []int, k int) []int {
    if k == 0 {
        return []int{}
    }
    
    // Sort the array
    sort.Ints(arr)
    
    // Get the last k elements, which are the largest
    return arr[len(arr)-k:]
}","func TestMaximum(t *testing.T) {
  candidate := maximum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },
     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },
     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },
     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },
     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },
     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },
     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },
     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },
     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },
     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },
     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_121,kbp_Latn,go_test.go,"package solution_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Ye ŋha-ɖʋ intɛrɩjɛrɩwaa mba pɛfɛyɩ kɩ-tɩ yɔɔ yɔ, pɩsɩna nɛ ɖɩna intɛrɩjɛrɩwaa mba pɛfɛyɩ kɩ-tɩ yɔɔ yɔ, pa-tɩŋa pɛ-tɛ tɔm kɩfatʋ.// >>> solution([]int{5, 8, 7, 1})
// 12
// >>> solution([]int{3, 3, 3, 3, 3})
// 9
// >>> solution([]int{30, 13, 24, 321})
// 0
func solution(lst []int) int {
","sum := 0
    for i := 0; i < len(lst); i++ {
        if i%2 == 0 && lst[i]%2 != 0 {
            sum += lst[i]
        }
    }
    return sum
}","func TestSolution(t *testing.T) {
  candidate := solution
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },
     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },
     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },
     { actual: candidate([]int{5, 9}), expected: 5 },
     { actual: candidate([]int{2, 4, 8}), expected: 0 },
     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },
     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_122,kbp_Latn,go_test.go,"package add_elements_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Kɩ-tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ//Yee pamaɣna ɛyʊ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ nɛ ɛ-hɩɖɛ yɔ.// >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
func add_elements(arr []int, k int) int {
","func add_elements(arr []int, k int) int {
    sum := 0
    for i := 0; i < k; i++ {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","func TestAdd_Elements(t *testing.T) {
  candidate := add_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },
     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },
     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },
     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },
     { actual: candidate([]int{1}, 1), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_123,kbp_Latn,go_test.go,"package get_odd_collatz_test

import (
    ""testing""
    ""fmt""
)

//get_odd_collatz(5) pɩsɩna [1, 5] # Kollatz tɛtʊ taa lɛ 5 kɛ [5, 16, 8, 4, 2, 1], mbʊ pʊyɔɔ yɔ, ɛyʊ ɛ-ñʊʊ mayaɣ kɔyɔ 1 nɛ 5. //Kɩɖaʋ nakʋyʋ yɔ: //2. kɩ-tɛ tɔm kɩfatʋ//1. Collatz(1) kɛna [1].//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ://Tɔmpiye nɖɩ ɖɩ-taa lɛ, paa n ɛ-tɛ wazaɣ ŋga lɛ, tɔmpiye nɖɩ ɖɩ-tɛ wɛtʊ kaɣ talʋʋ 1.//Yee tɔmpiye nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ ɖɩkɛ tɔmpiye nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ, tɔmpiye nɖɩ ɖɩ-wayɩ yɔ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3//Ɖooo lɛ, yee tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye.//Pɩtɛ lɛ, paa tɔmpiye nɖɩ lɛ, ɖɩlɩɣ  cɔlɔ.//Collatz tɛ maɣzɩm kɛ maɣzɩm pɩlɩna matʋ taa nɛ pɩlɩna tɔmpiye nɖɩ ɖɩ-taa pama-ɖɩ yɔ.//Ye paha-ɩ nimero waa kɩmaŋ n yɔ, pɩpɩsɩɣna nimero waa mba pa-taa pa-taa fɛyɩ nimero waa yɔ nɛ pa-taa lɛ, nimero waa mba pa-taa wɛ nimero waa mba pa-taa pa-taa fɛyɩ nimero waa yɔ.// >>> get_odd_collatz(5)
// []int{1, 5}
func get_odd_collatz(n int) []int {
","package get_odd_collatz_test

import (
    ""sort""
)

func get_odd_collatz(n int) []int {
    oddNumbers := make(map[int]bool)

    for n != 1 {
        if n%2 != 0 {
            oddNumbers[n] = true
        }
        if n%2 == 0 {
            n /= 2
        } else {
            n = 3*n + 1
        }
    }

    // Add 1 to the set of odd numbers because the sequence always ends at 1
    oddNumbers[1] = true

    // Extract the keys, which represent the odd numbers
    result := make([]int, 0, len(oddNumbers))
    for num := range oddNumbers {
        result = append(result, num)
    }

    // Sort the result
    sort.Ints(result)

    return result
}","func TestGet_Odd_Collatz(t *testing.T) {
  candidate := get_odd_collatz
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },
     { actual: candidate(5), expected: []int{1, 5} },
     { actual: candidate(12), expected: []int{1, 3, 5} },
     { actual: candidate(1), expected: []int{1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_124,kbp_Latn,go_test.go,"package valid_date_test

import (
    ""testing""
    ""fmt""
)

//4. Pɩwɛɛ se pama kɩyakʋ ŋgʋ nɛ kɩwɛɛ ɛzɩ: f-y-y-y-y.//Pɩfɛyɩ se fenasɩ nzɩ sɩtɛŋ fenaɣ kʋɖʋmaɣ yaa sɩtɛzɩ fenasɩ hiu nɛ naalɛ.//Pɩtasɩ lɛ, kɩyakɩŋ weyi ɩwɛ fenaɣ 1, 3, 5, 7, 8, 10, 12 taa yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ yɔ, ɩfɛyɩ 1 yaa ɩkɩlɩ 31 nɛ fenaɣ 4, 6, 9, 11 taa lɛ, ɩfɛyɩ 1 yaa ɩkɩlɩ 30 nɛ fenaɣ 2 taa lɛ, ɩfɛyɩ 1 yaa ɩkɩlɩ 29.//1. Pɩtɩkɛ kɩyakʋ ŋgʋ kɩ-taa palɩzɩ-kʋ yɔ, kɩ-taa tɔm.//Kɩyakʋ ŋgʋ kɩ-taa lɛ, paa paɣtʋ ndʋ tɩ-tɩŋa payɩ tɩwɛɛ yɔ, tɩ-taa natʋyʋ fɛyɩ: //Pɩsɩɣnɩ-ŋ nɛ ŋtɩlɩ mbʋ pɩ-yɔɔ ŋpɩzɩɣ nɛ ŋtɩŋnɩ nɛ ŋla ɖʋtʋ ndʋ yɔ.//Pɩwɛɛ se ŋma tʋmɩyɛ nɖɩ ɖɩñɔɔzʋʋ kɩyakʋ nakʋyʋ yɔ nɛ // >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
func valid_date(date string) bool {
","func valid_date(date string) bool {
    if len(date) == 0 {
        return false
    }

    var month, day, year int
    n, err := fmt.Sscanf(date, ""%02d-%02d-%04d"", &month, &day, &year)

    if err != nil || n != 3 {
        return false
    }

    if month < 1 || month > 12 {
        return false
    }

    if month == 2 {
        if day < 1 || day > 29 {
            return false
        }
    } else if month == 4 || month == 6 || month == 9 || month == 11 {
        if day < 1 || day > 30 {
            return false
        }
    } else {
        if day < 1 || day > 31 {
            return false
        }
    }

    return true
}","func TestValid_Date(t *testing.T) {
  candidate := valid_date
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""03-11-2000""), expected: true },
     { actual: candidate(""15-01-2012""), expected: false },
     { actual: candidate(""04-0-2040""), expected: false },
     { actual: candidate(""06-04-2020""), expected: true },
     { actual: candidate(""01-01-2007""), expected: true },
     { actual: candidate(""03-32-2011""), expected: false },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""04-31-3000""), expected: false },
     { actual: candidate(""06-06-2005""), expected: true },
     { actual: candidate(""21-31-2000""), expected: false },
     { actual: candidate(""04-12-2003""), expected: true },
     { actual: candidate(""04122003""), expected: false },
     { actual: candidate(""20030412""), expected: false },
     { actual: candidate(""2003-04""), expected: false },
     { actual: candidate(""2003-04-12""), expected: false },
     { actual: candidate(""04-2003""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_126,kbp_Latn,go_test.go,"package is_sorted_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛyʊ ɛfɛyɩna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ.//Ye tɔm ndʋ tɩ-taa nɔɔyʋ ɛlaba nabʋyʋ yɔ, pɩwɛɛ se pama-tʋ nɛ pɩkpaɖɩ mbʋ pɩ-taa lɛlʋ wɛɛ yɔ.//Ye ŋwɛna nimbrɩwaa yɔ, ŋpɩsɩɣ-wɛ paa patɩlɩ-wɛ yaa pataana-wɛ yɔ.// >>> is_sorted([]int{5})
// true
// >>> is_sorted([]int{1, 2, 3, 4, 5})
// true
// >>> is_sorted([]int{1, 3, 2, 4, 5})
// false
// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})
// true
// >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})
// true
// >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})
// false
// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})
// true
// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})
// false
func is_sorted(lst []int) bool {
","func is_sorted(lst []int) bool {
    if len(lst) <= 1 {
        return true
    }
    
    duplicateCount := make(map[int]int)

    for i := 0; i < len(lst)-1; i++ {
        if lst[i] > lst[i+1] {
            return false
        }
        duplicateCount[lst[i]]++
        if duplicateCount[lst[i]] > 1 {
            return false
        }
    }
    
    // Check the last element for duplicate
    duplicateCount[lst[len(lst)-1]]++
    if duplicateCount[lst[len(lst)-1]] > 1 {
        return false
    }

    return true
}","func TestIs_Sorted(t *testing.T) {
  candidate := is_sorted
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },
     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },
     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },
     { actual: candidate([]int{}), expected: true },
     { actual: candidate([]int{1}), expected: true },
     { actual: candidate([]int{3, 2, 1}), expected: false },
     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },
     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },
     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_127,kbp_Latn,go_test.go,"package intersection_test

import (
    ""testing""
    ""fmt""
)

//[Input/output] kɩɖaŋ: //Ye tɔm naalɛ ɩtɩkpɛndɩ yɔ, pɩpɩsɩɣ ""Aayɩ"".//Ye pɩtɛkɛ mbʋ yɔ, ŋpɩsɩɣ ""Aayɩ"".//Yee kɩ-tɛ matʊ kɔyɔ, pɩtɛzɩna ""YES""//Ɛ-hɛkʊ taa lɛ, ɛyʊ ɛ-hɛkʊ taa lɛ, ɛ-tɛ hɛkʊ taa lɛ, ɛ-tɛ hɛkʊ taa lɛ, ɛ-tɛ hɛkʊ taa lɛ.//Kɩɖaʋ lɛ, hɔɔlɩŋ weyi ɩ-taa (1, 3), (2, 4) nɛ (2, 3) pɛtɛyɩɣ ɖama yɔ.//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Ña-tʋmɩyɛ lɛ se ŋtɩlɩ se ɛzɩmtaa pɩtɛŋna nɛ pɩtalɩna-ŋ.//Paa alɩwaatʊ ndʊ tɩ-taa lɛ, pamaɣzɩɣ se tɩ-paɣtʊ wɛna kɩmaŋ yaa tɩ-tɛ.//Pɩ-taa lɛ, pamaɣzɩɣ kɩ-paɣzʋʋ nɛ kɩ-tɛtʋ.//Pɩtɛ alɩwaatʊ taa lɛ, alɩwaatʊ ndʊ tɩ-taa (paɣzɩ, tɩtɛ)//paa alɩwaatʊ ndʊ lɛ, tɩ-taa lɛ, kɩkɛna ɛyʊ kʊyʊm. Ɖɩkpaɣ ɛzɩ alɩwaatʊ ndʊ tɩ-taa lɛ, alɩwaatʊ ndʊ tɩ-taa lɛ, (kpazɩyɛ, tɛm) = (1, 2).//Paha-ŋ alɩwaatʋ naalɛ.// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})
// ""NO""
// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})
// ""NO""
// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})
// ""YES""
func intersection(interval1 []interface{}, interval2 []interface{}) string {
","package intersection_test

import (
	""testing""
)

// Helper function to determine if a number is prime
func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	if num == 2 {
		return true
	}
	if num%2 == 0 {
		return false
	}
	for i := 3; i*i <= num; i += 2 {
		if num%i == 0 {
			return false
		}
	}
	return true
}

func intersection(interval1 []interface{}, interval2 []interface{}) string {
	start1, end1 := interval1[0].(int), interval1[1].(int)
	start2, end2 := interval2[0].(int), interval2[1].(int)

	// Determine the intersection of two intervals
	intersectStart := max(start1, start2)
	intersectEnd := min(end1, end2)

	if intersectStart > intersectEnd {
		return ""NO""
	}

	// The length of intersection is end - start
	lengthOfIntersection := intersectEnd - intersectStart
	if isPrime(lengthOfIntersection) {
		return ""YES""
	}
	return ""NO""
}

// Helper function to find the maximum of two integers
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Helper function to find the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func TestIntersection(t *testing.T) {
	if intersection([]interface{}{1, 2}, []interface{}{2, 3}) != ""NO"" {
		t.Error(""Expected NO"")
	}
	if intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != ""NO"" {
		t.Error(""Expected NO"")
	}
	if intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != ""YES"" {
		t.Error(""Expected YES"")
	}
}","func TestIntersection(t *testing.T) {
  candidate := intersection
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: ""NO"" },
     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: ""NO"" },
     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: ""YES"" },
     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: ""YES"" },
     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: ""NO"" },
     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: ""NO"" },
     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: ""NO"" },
     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: ""NO"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_129,kbp_Latn,go_test.go,"package minPath_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩsɩɣnɩ-ŋ nɛ ŋhiɣ tɔm kɩmamatʋ ndʋ tɩ-taa ŋpɩzɩɣ ŋtɩŋnɩ tɩ-yɔɔ nɛ ŋwɩlɩ-tʋ yɔ.//Pɩtʋʋ fɛyɩ se tɔm ndʋ tɩ-yɔɔ cosuu wɛ ndɩ.//Lɩmaɣzɩyɛ nɖɩ ɖɩ-taa lɛ, ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ yɔ.//Ɖɩkpaɣ ɛzɩ lst_A[i] < lst_B[i] nɛ j (1 <= j < i) kɔyɔ ɖɩnaɣ se//Pɩtɛ lɛ, ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛlʊ taa lɛlʊ.//Pɩtɛ lɛ, ɖɩkpaɣ se ɖɩyaɣ-wɛ se lst_A nɛ lst_B.//Pɩtɛ lɛ, ŋpɩzɩɣ nɛ ŋlɩzɩ takayɩhayʋʋ ŋgʋ kɩ-taa ŋnaɣ takayɩhayʋʋ A nɛ B yɔ.//Kɩɖaʋ kʋnɛ kɩ-taa lɛ, pɩwɩlɩɣ se ɛyʊ ɛ-tɩ yɔɔ wɛʊ yɔ, pɩfɛyɩ ɖeu se ɛ-tɩ yɔɔ wɛʊ ɛɖʊ nɔɔyʊ yɔɔ.//ŊYƐƐƐ se ŋtaatasɩ naʋ nɔɔyʋ.//Pɩtɩcɛyɩ se patɩlɩ-wɛ).//Ɖɩcɔna kɔyɔ, ɖɩnaɣ se nʋmɔʋ ŋgʋ kɩwɛna k yɔ, kɩ-taa lɛ, ɖɩnaɣ se ɖɩcɔna k pilinzi ɖeyi ɖeyi (ɛtɛkɛ //Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ//Pʋ-tɔbʋʋ se ŋpɩzɩɣ nɛ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛna yɔ nɛ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛna yɔ.//paa lone nɖɩ ɖɩ-taa nɛ paa nʋmɔʋ ŋgʋ kɩ-taa lɛ, ŋpɩzɩɣ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛɛ yɔ.//Pɩwɛɛ se ŋñɩnɩ n̄ɩɣyʋʋ cikpeluu ŋgʋ kɩwɛna n̄ɩɣyʋʋ k yɔ, nɛ ŋpaɣzɩna.//Pɩtɛ tɔmpiye inclusive lɩzɩɣna tam kʋɖʋmʋʋ kɛ matʊ hɔɔlʊʊ taa.//paa ɛyʊ weyi lɛ ɛ-tɛ ɛyʊ kɩlaʊ taa.//Pɩkɛna matʊ ndʊ tɩ-taa wɛ ñʊŋ nɛ matʊ ndʊ tɩ-taa wɛ ñʊŋ nɛ pɩ-taa wɛ ñʊŋ nɛ pɩ-taa wɛ ñʊŋ nɛ pɩ-taa wɛ ñʊŋ nɛ pɩ-taa wɛ ñʊŋ nɛ pɩ-taa wɛ ñʊŋ nɛ pɩ-taa wɛ ñʊŋ.// >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)
// []int{1, 2, 1}
// >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)
// []int{1}
func minPath(grid [][]int, k int) []int {
","package minPath_test

import (
    ""sort""
)

func minPath(grid [][]int, k int) []int {
    n := len(grid)
    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}
    
    var dfs func(x, y, length int, path []int)
    var minPath []int
    minPath = make([]int, k)
    for i := 0; i < k; i++ {
        minPath[i] = n*n + 1
    }

    dfs = func(x, y, length int, path []int) {
        if length == k {
            if isLess(path, minPath) {
                copy(minPath, path)
            }
            return
        }
        
        for _, dir := range directions {
            nx, ny := x+dir[0], y+dir[1]
            if nx >= 0 && ny >= 0 && nx < n && ny < n {
                path[length] = grid[nx][ny]
                dfs(nx, ny, length+1, path)
            }
        }
    }
    
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            path := make([]int, k)
            path[0] = grid[i][j]
            dfs(i, j, 1, path)
        }
    }
    
    return minPath
}

func isLess(a, b []int) bool {
    for i := 0; i < len(a); i++ {
        if a[i] < b[i] {
            return true
        }
        if a[i] > b[i] {
            return false
        }
    }
    return false
}","func TestMinpath(t *testing.T) {
  candidate := minPath
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },
     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },
     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },
     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },
     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },
     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },
     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },
     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },
     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },
     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_130,kbp_Latn,go_test.go,"package tri_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Nɔɔɖɛyaa Ɛgbɛyɛ taa ɛzʋtʋyaa mba pa-taa nabɛyɛ lɛ://Pʊtɔbʊʊ se ŋwɛna ɛyʊ kʊyʊmʊm nɛ ɛfɛyɩ kʊyʊmʊm, nɛ pɩwɛɛ se ŋpɩsɩ ɛyʊ kʊyʊmʊm //= 2 + 3 + 3 = 8 //3 = 3 + 3 + 4//3 = 4 //(Tri) = 1 + (2 / 2) = 2 //Kɩɖaʋ nakʋyʋ yɔ: //(n) = (n - 1) + (n - 2) + (n + 1) ye n ɛfɛyɩ ndɩ yɔ.//tri (n) = 1 + n / 2, yee n ɛtɛyɩ yɔ.//3 = 1 //Tribonacci tɛ kʊyʊmʊʊ wɛna tɔbʊʊ se: //Ɛlɛ, ɛyaa ɩɩsɩŋ Tribonacci tɔm piye nɖɩ.//Paa anɩ ɛsɩm Fibonacci tɛ n̄ɩɣyʋʋ, pama-kʋ nɛ pɔcɔna siŋŋ kɛ maɣzɩm takayasɩ taa n̄ɩma cɔlɔ pɩnaɣ 1854 taa.// >>> tri(3)
// []int{1, 3, 2, 8}
func tri(n int) []int {
","func tri(n int) []int {
    if n < 0 {
        return []int{}
    }
    sequence := make([]int, n+1)
    sequence[0] = 1 // tri(0) is not defined in problem, let's start with tri(1)
    if n >= 1 {
        sequence[1] = 3
    }
    for i := 2; i <= n; i++ {
        if i%2 == 0 {
            sequence[i] = 1 + i/2
        } else {
            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)
        }
    }
    return sequence
}

func getNextTribonacci(n int) int {
    if n%2 == 0 {
        return 1 + n/2
    }
    return getNextTribonacciRec(n+1)
}

func getNextTribonacciRec(n int) int {
    triNext := make([]int, n+1)
    triNext[0] = 1 // again assuming some base start
    if n >= 1 {
        triNext[1] = 3
    }
    for i := 2; i <= n; i++ {
        if i%2 == 0 {
            triNext[i] = 1 + i/2
        } else {
            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)
        }
    }
    return triNext[n]
}","func TestTri(t *testing.T) {
  candidate := tri
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: []int{1, 3, 2, 8} },
     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },
     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },
     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },
     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },
     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },
     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },
     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },
     { actual: candidate(0), expected: []int{1} },
     { actual: candidate(1), expected: []int{1, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_131,kbp_Latn,go_test.go,"package digits_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ye nimasɩ tɩŋa ɩkɛ kɩkpɛndɩna yɔ, pɩsɩɣnɩ-ɩ nɛ ɛkɔɔ nɛ ɛkɔɔ lɛ, ɛkɔɔ nɛ 0.//Ye paha-ɖʋ nimero intérieur positif n yɔ, ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩlɩna nimero waa mba pa-taa pa-taa pa-taa pa-taa yɔ.// >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
func digits(n int) int {
","product := 1
    hasOdd := false

    for n > 0 {
        digit := n % 10
        if digit%2 != 0 {
            product *= digit
            hasOdd = true
        }
        n /= 10
    }

    if hasOdd {
        return product
    }
    return 0
}","func TestDigits(t *testing.T) {
  candidate := digits
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 5 },
     { actual: candidate(54), expected: 5 },
     { actual: candidate(120), expected: 1 },
     { actual: candidate(5014), expected: 5 },
     { actual: candidate(98765), expected: 315 },
     { actual: candidate(5576543), expected: 2625 },
     { actual: candidate(2468), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_132,kbp_Latn,go_test.go,"package is_nested_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ tɔmpiye true yee nɛ yee pɛtɛyɩ-ɖɩ nɛ tɔmpiye kʊɖʊmɖɩyɛ yɔ.//Lɩzɩ tʋmɩyɛ nɖɩ ɖɩkpaɣna tɔmpiye naɖɩyɛ nɛ ɖɩ-taa wɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa wɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ.// >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
func is_nested(myString string) bool {
","func is_nested(myString string) bool {
	stack := []rune{}
	nestingFound := false

	for _, char := range myString {
		if char == '[' {
			stack = append(stack, char)
		} else if char == ']' {
			if len(stack) > 0 {
				stack = stack[:len(stack)-1]
				if len(stack) > 0 {
					nestingFound = true
				}
			}
		}
	}

	return nestingFound
}","func TestIs_Nested(t *testing.T) {
  candidate := is_nested
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""[[]]""), expected: true },
     { actual: candidate(""[]]]]]]][[[[[]""), expected: false },
     { actual: candidate(""[][]""), expected: false },
     { actual: candidate(""[]""), expected: false },
     { actual: candidate(""[[[[]]]]""), expected: true },
     { actual: candidate(""[]]]]]]]]]]""), expected: false },
     { actual: candidate(""[][][[]]""), expected: true },
     { actual: candidate(""[[]""), expected: false },
     { actual: candidate(""[]]""), expected: false },
     { actual: candidate(""[[]][[""), expected: true },
     { actual: candidate(""[[][]]""), expected: true },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""[[[[[[[[""), expected: false },
     { actual: candidate(""]]]]]]]]""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_133,kbp_Latn,go_test.go,"package sum_squares_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩtɛ lɛ, ŋcalɩɣna kpaɣʋ nɛ ŋmaɣzɩɣna hɔɔlɩŋ weyi ɩwɛ kɩ-taa yɔ nɛ ŋmaɣzɩɣna hɔɔlɩŋ weyi ɩ-taa lɛ, ŋcalɩɣna kpaɣʋ nɛ ŋmaɣzɩɣna hɔɔlɩŋ weyi ɩ-taa lɛ, ŋmaɣzɩɣna hɔɔlɩŋ weyi ɩ-taa lɛ.//Pɩwɛɛ se ŋyele nɛ ɖɩna se hɔɔlɩŋ weyi ɩwɛ takayaɣ ŋga ka-taa yɔ, ɩ-taa lɛ, hɔɔlɩŋ weyi ɩ-taa pama-ɩ yɔ, ɩ-taa lɛ, hɔɔlɩŋ weyi ɩ-taa pama-ɩ yɔ, ɩ-taa lɛ, hɔɔlɩŋ weyi ɩ-taa pama-ɩ yɔ.//Payaɣ-ŋ se ""Ɛyaa"".// >>> lst([]float64{1.0, 2.0, 3.0})
// 14
// >>> lst([]float64{1.0, 4.0, 9.0})
// 98
// >>> lst([]float64{1.0, 3.0, 5.0, 7.0})
// 84
// >>> lst([]float64{1.4, 4.2, 0.0})
// 29
// >>> lst([]float64{-2.4, 1.0, 1.0})
// 6
func sum_squares(lst []float64) int {
","package sum_squares_test

import (
	""math""
)

func sum_squares(lst []float64) int {
	sum := 0
	for _, num := range lst {
		ceiledNum := math.Ceil(num)
		sum += int(ceiledNum * ceiledNum)
	}
	return sum
}","func TestSum_Squares(t *testing.T) {
  candidate := sum_squares
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },
     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },
     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },
     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },
     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },
     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },
     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },
     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },
     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },
     { actual: candidate([]float64{0.0}), expected: 0 },
     { actual: candidate([]float64{-1.0}), expected: 1 },
     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_134,kbp_Latn,go_test.go,"package check_if_last_char_is_a_letter_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩsɩ nɛ ŋna-ɩ tɔm kɩsɔzɩtʋ: ""tɔm"" kɛna matʋ cabɩ kpou nakʋyʋ.//Tɔm piye naɖɩyɛ hɔɔlʋʋ, nɛ lɛɛbʋ taa lɛ, pɩkɛ cɛtɩm tɔm.//Pɩtɛ alɩwaatʊ taa lɛ, tɔmpiye nɖɩ ɖɩkɛ alɩbɛɛtɩ tɔmpiye nɛ ɖɩfɛyɩ ɛzɩ  yɔ.//Lɩzɩ tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye true yee tɔmpiye kɛdɛzaɣ ñɩnɖɛ kɔyɔ .// >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
func check_if_last_char_is_a_letter(txt string) bool {
","package check_if_last_char_is_a_letter_test

import (
    ""testing""
    ""unicode""
)

func check_if_last_char_is_a_letter(txt string) bool {
    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {
        return false
    }
    
    lastCharIndex := len(txt) - 1
    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {
        lastCharIndex--
    }
    
    if lastCharIndex < 0 {
        return false
    }

    if !unicode.IsLetter(rune(txt[lastCharIndex])) {
        return false
    }
    
    // Check if it's part of a word by looking at the previous character
    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {
        return false
    }

    return true
}

func TestCheckIfLastCharIsALetter(t *testing.T) {
    cases := []struct {
        input    string
        expected bool
    }{
        {""apple pie"", false},
        {""apple pi e"", true},
        {""apple pi e "", false},
        {"""", false},
        {""hello world"", true},
        {""a "", true},
        {"" a"", true},
        {""abc"", false},
        {""abc "", false},
    }

    for _, c := range cases {
        t.Run(c.input, func(t *testing.T) {
            result := check_if_last_char_is_a_letter(c.input)
            if result != c.expected {
                t.Errorf(""Expected %v, got %v for input \""%s\"""", c.expected, result, c.input)
            }
        })
    }
}","func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {
  candidate := check_if_last_char_is_a_letter
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""apple""), expected: false },
     { actual: candidate(""apple pi e""), expected: true },
     { actual: candidate(""eeeee""), expected: false },
     { actual: candidate(""A""), expected: true },
     { actual: candidate(""Pumpkin pie ""), expected: false },
     { actual: candidate(""Pumpkin pie 1""), expected: false },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""eeeee e ""), expected: false },
     { actual: candidate(""apple pie""), expected: false },
     { actual: candidate(""apple pi e ""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_135,kbp_Latn,go_test.go,"package can_arrange_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Kɩ-taa wɛ tɔm kɩfatʋ.//Pɩtɛ lɛ, pɩpɩsɩɣ -1.//Pɩfɛyɩ pɩdɩɩfɛyɩ yaa pɩfɛyɩ ɖɔɖɔ ɛzɩ pɩdɩɩfɛyɩ yɔ.//Lɩzɩ tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ ɛyʊ kʊyʊmʊm sɔsɔm yɔ nɛ ɖɩ-tɛ lɛɣtʊ ndʊ tɩ-taa // >>> can_arrange([]int{1, 2, 4, 3, 5})
// 3
// >>> can_arrange([]int{1, 2, 3})
// -1
func can_arrange(arr []int) int {
","package can_arrange_test

func can_arrange(arr []int) int {
    for i := len(arr) - 1; i > 0; i-- {
        if arr[i] < arr[i-1] {
            return i
        }
    }
    return -1
}","func TestCan_Arrange(t *testing.T) {
  candidate := can_arrange
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },
     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },
     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },
     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },
     { actual: candidate([]int{}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_136,kbp_Latn,go_test.go,"package largest_smallest_integers_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Yee ɛyʊ ɛfɛyɩna ɛyʊ kʊyʊm yaa ɛyʊ kɩlɛyʊ kɔyɔ, pɩpɩsɩɣ ɛyʊ kʊyʊm.//Pɩtɛ lɛ, ɖɩnaɣ se ɛyʊ ɛ-tɔm wɛ ndɩ nɛ ɛ-tɛ lɛɣtʊ takayaɣ.//Ɛyʊ ɛ-ñʊʊ taa lɛ, pʊtɔbʊʊ se ɛ-ñʊʊ taa lɛ, pʊtɔbʊʊ se ɛ-ñʊʊ taa lɛ, pʊtɔbʊʊ se ɛ-ñʊʊ taa lɛ.//Pɩsɩ nɛ ŋna-ɩ kɩlɛmʋʋ yɔɔ.// >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})
// []interface{}{nil, 1}
// >>> largest_smallest_integers([]int{})
// []interface{}{nil, nil}
// >>> largest_smallest_integers([]int{0})
// []interface{}{nil, nil}
func largest_smallest_integers(lst []int) []interface{} {
","func largest_smallest_integers(lst []int) []interface{} {
    var largestNegative *int
    var smallestPositive *int

    for _, num := range lst {
        if num < 0 {
            if largestNegative == nil || num > *largestNegative {
                largestNegative = new(int)
                *largestNegative = num
            }
        } else if num > 0 {
            if smallestPositive == nil || num < *smallestPositive {
                smallestPositive = new(int)
                *smallestPositive = num
            }
        }
    }

    var result = []interface{}{nil, nil}
    if largestNegative != nil {
        result[0] = *largestNegative
    }
    if smallestPositive != nil {
        result[1] = *smallestPositive
    }

    return result
}","func TestLargest_Smallest_Integers(t *testing.T) {
  candidate := largest_smallest_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },
     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },
     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },
     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },
     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },
     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },
     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },
     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },
     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },
     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },
     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_138,kbp_Latn,go_test.go,"package is_equal_to_sum_even_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ //Pɩwɛɛ se ɖɩtɩlɩ se paa mayaɣ ŋga lɛ, kɛwɛna hɔɔlɩŋ naanza nɛ hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa.// >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
func is_equal_to_sum_even(n int) bool {
","package is_equal_to_sum_even_test

import (
    ""testing""
    ""fmt""
)

// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
// Example
// >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
func is_equal_to_sum_even(n int) bool {
    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8
    // Therefore, n must be at least 8 and n must be even
    return n >= 8 && n%2 == 0
}

// Testing the function
func TestIsEqualToSumEven(t *testing.T) {
    cases := []struct {
        n      int
        expect bool
    }{
        {4, false},
        {6, false},
        {8, true},
        {10, true},
        {12, true},
        {14, true},
        {16, true},
    }

    for _, c := range cases {
        result := is_equal_to_sum_even(c.n)
        if result != c.expect {
            t.Errorf(""is_equal_to_sum_even(%d) == %v, expect %v"", c.n, result, c.expect)
        } else {
            fmt.Printf(""Success: is_equal_to_sum_even(%d) == %v\n"", c.n, result)
        }
    }
}","func TestIs_Equal_To_Sum_Even(t *testing.T) {
  candidate := is_equal_to_sum_even
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(4), expected: false },
     { actual: candidate(6), expected: false },
     { actual: candidate(8), expected: true },
     { actual: candidate(10), expected: true },
     { actual: candidate(11), expected: false },
     { actual: candidate(12), expected: true },
     { actual: candidate(13), expected: false },
     { actual: candidate(16), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_139,kbp_Latn,go_test.go,"package special_factorial_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //le n > 0 //brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! //Payaɣ Brasiiili ɛjaɖɛ taa tɔmpiye nɖɩ se: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
func special_factorial(n int) int {
","package special_factorial_test

import (
    ""testing""
    ""fmt""
)

func special_factorial(n int) int {
    if n <= 0 {
        return 1
    }
    
    result := 1
    for i := 1; i <= n; i++ {
        result *= factorial(i)
    }
    
    return result
}

func factorial(x int) int {
    if x == 0 {
        return 1
    }
    prod := 1
    for i := 1; i <= x; i++ {
        prod *= i
    }
    return prod
}

func TestSpecialFactorial(t *testing.T) {
    cases := []struct {
        input    int
        expected int
    }{
        {4, 288},      // 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288
        {3, 12},       // 3! * 2! * 1! = 6 * 2 * 1 = 12
        {2, 2},        // 2! * 1! = 2 * 1 = 2
        {1, 1},        // 1! = 1
        {0, 1},        // Edge case for n=0, considered as 1 for special factorial
    }

    for _, c := range cases {
        result := special_factorial(c.input)
        if result != c.expected {
            t.Errorf(""special_factorial(%d) == %d, want %d"", c.input, result, c.expected)
        }
    }
}

func main() {
    fmt.Println(special_factorial(4)) // Output: 288
    fmt.Println(special_factorial(3)) // Output: 12
}","func TestSpecial_Factorial(t *testing.T) {
  candidate := special_factorial
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(4), expected: 288 },
     { actual: candidate(5), expected: 34560 },
     { actual: candidate(7), expected: 125411328000 },
     { actual: candidate(1), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_140,kbp_Latn,go_test.go,"package fix_spaces_test

import (
    ""testing""
    ""fmt""
)

//Pɩtɛ lɛ, pɛlɛɣzɩ matʋ ndʋ tɩ-tɩŋa nɛ - //nɛ yee pɩcɛzɩ nabʊlɛ mbʊ yɔ, //Ye ŋwɛna tɔm pee kɩmanzɩ yɔ, kpaɣ-yɛ nɛ ŋlɛɣzɩna ɖenɖe pɩfɛyɩ yɔ nɛ pɩ-tɛɛ mayaɣ, // >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
func fix_spaces(text string) string {
","package fix_spaces_test

import (
    ""strings""
    ""testing""
)

func fix_spaces(text string) string {
    var result string
    spaceCount := 0

    for _, char := range text {
        if char == ' ' {
            spaceCount++
        } else {
            if spaceCount == 1 {
                result += ""_""
            } else if spaceCount > 1 {
                result += ""-""
            }
            result += string(char)
            spaceCount = 0
        }
    }

    // Handle trailing spaces
    if spaceCount == 1 {
        result += ""_""
    } else if spaceCount > 1 {
        result += ""-""
    }

    return result
}

func TestFixSpaces(t *testing.T) {
    cases := []struct {
        input    string
        expected string
    }{
        {"" Example"", ""Example""},
        {"" Example 1"", ""Example_1""},
        {"" Example 2"", ""_Example_2""},
        {"" Example 3"", ""_Example-3""},
        {"" Hello    world"", ""_Hello-world""},
        {""   Leading spaces"", ""-Leading_spaces""},
    }

    for _, c := range cases {
        result := fix_spaces(c.input)
        if result != c.expected {
            t.Errorf(""fix_spaces(%q) == %q, expected %q"", c.input, result, c.expected)
        }
    }
}","func TestFix_Spaces(t *testing.T) {
  candidate := fix_spaces
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Example""), expected: ""Example"" },
     { actual: candidate(""Mudasir Hanif ""), expected: ""Mudasir_Hanif_"" },
     { actual: candidate(""Yellow Yellow  Dirty  Fellow""), expected: ""Yellow_Yellow__Dirty__Fellow"" },
     { actual: candidate(""Exa   mple""), expected: ""Exa-mple"" },
     { actual: candidate(""   Exa 1 2 2 mple""), expected: ""-Exa_1_2_2_mple"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_141,kbp_Latn,go_test.go,"package file_name_check_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //- Pɩwɛɛ se tɔmpiye nɖɩ ɖɩtɩŋɩɣ tɩʋ yɔɔ yɔ ɖɩkɛ tɔmpiye nɖɩ ɖɩ-taa: ['txt', 'exe', 'dll'] //Latɛŋ masɩ taa lɛ, payaɣ se ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""//- Kajalaɣ ñɩŋgʋ lɛ, pɩfɛyɩ se ŋyele nɛ tɔm pee wena awɛ tɩ-yɔɔ yɔ, awɛɛ falaa, nɛ kacalaɣ ñɩŋgʋ lɛ //- Takayaɣ ŋga ka-hɩɖɛ wɛna tɩʋ kʋɖʋmʋʋ ɖeyi ɖeyi.//- Takayaɣ ŋga ka-hɩɖɛ taa lɛ, ka-taa mayaɣ ɛfɛyɩna tam nabudozo nɛ pɩkɩlɩ ('0' - '9'). //pɔ-tɔm taa: //Payaɣ takayaɣ nakɛyɛ hɩɖɛ se takayaɣ kɩkalaɣ ye ka-taa tɔm tʋnɛ tɩ-tɩŋa tɩwɛɛ yɔ.//Yee tɔmpiye nɖɩ ɖɩ-hɩɖɛ ɛwɛ camɩyɛ yɔ, ɖɩ-taa lɛ, pamaɣ se ""Ɛɛɛ"" nɛ yee pɩtɛkɛ mbʋ yɔ, pamaɣ se ""Aayɩ"".//Lɩzɩ tʋmɩyɛ nɖɩ ɖɩkpaɣna tɔmpiye nɖɩ ɖɩkɛ takayaɣ nakɛyɛ hɩɖɛ yɔ nɛ ɖɩpɩsɩ // >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
func file_name_check(file_name string) string {
","package file_name_check_test

import (
    ""strings""
    ""unicode""
)

func file_name_check(file_name string) string {
    if len(file_name) == 0 {
        return ""No""
    }

    // Condition 2: Check for exactly one dot
    dotIndex := strings.LastIndex(file_name, ""."")
    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {
        return ""No""
    }

    // Split the file name into two parts
    namePart := file_name[:dotIndex]
    extension := file_name[dotIndex+1:]

    // Condition 4: Check the extension
    validExtensions := map[string]bool{
        ""txt"": true,
        ""exe"": true,
        ""dll"": true,
    }
    if !validExtensions[extension] {
        return ""No""
    }

    // Condition 3: Check the first character before the dot
    if !unicode.IsLetter(rune(namePart[0])) {
        return ""No""
    }

    // Condition 1: Count the digits in the file name
    digitCount := 0
    for _, char := range namePart {
        if unicode.IsDigit(char) {
            digitCount++
        }
    }
    if digitCount > 3 {
        return ""No""
    }

    // If all conditions are met, return ""Yes""
    return ""Yes""
}","func TestFile_Name_Check(t *testing.T) {
  candidate := file_name_check
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""example.txt""), expected: ""Yes"" },
     { actual: candidate(""1example.dll""), expected: ""No"" },
     { actual: candidate(""s1sdf3.asd""), expected: ""No"" },
     { actual: candidate(""K.dll""), expected: ""Yes"" },
     { actual: candidate(""MY16FILE3.exe""), expected: ""Yes"" },
     { actual: candidate(""His12FILE94.exe""), expected: ""No"" },
     { actual: candidate(""_Y.txt""), expected: ""No"" },
     { actual: candidate(""?aREYA.exe""), expected: ""No"" },
     { actual: candidate(""/this_is_valid.dll""), expected: ""No"" },
     { actual: candidate(""this_is_valid.wow""), expected: ""No"" },
     { actual: candidate(""this_is_valid.txt""), expected: ""Yes"" },
     { actual: candidate(""this_is_valid.txtexe""), expected: ""No"" },
     { actual: candidate(""#this2_i4s_5valid.ten""), expected: ""No"" },
     { actual: candidate(""@this1_is6_valid.exe""), expected: ""No"" },
     { actual: candidate(""this_is_12valid.6exe4.txt""), expected: ""No"" },
     { actual: candidate(""all.exe.txt""), expected: ""No"" },
     { actual: candidate(""I563_No.exe""), expected: ""Yes"" },
     { actual: candidate(""Is3youfault.txt""), expected: ""Yes"" },
     { actual: candidate(""no_one#knows.dll""), expected: ""Yes"" },
     { actual: candidate(""1I563_Yes3.exe""), expected: ""No"" },
     { actual: candidate(""I563_Yes3.txtt""), expected: ""No"" },
     { actual: candidate(""final..txt""), expected: ""No"" },
     { actual: candidate(""final132""), expected: ""No"" },
     { actual: candidate(""_f4indsartal132.""), expected: ""No"" },
     { actual: candidate("".txt""), expected: ""No"" },
     { actual: candidate(""s.""), expected: ""No"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_142,kbp_Latn,go_test.go,"package sum_squares_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩtɛ lɛ, tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee wena awɛ kɩ-taa yɔ a-tɩŋa.//Pɩtɛ ɛyʊ ɛ-tɛ ɛyʊ kʊyʊm 3 nɛ ɛkaɣ ɛ-tɛ ɛyʊ kʊyʊm ɛ-tɛ ɛyʊ kʊyʊm 4 nɛ ɛ-tɛ ɛyʊ kʊyʊm 3 yɔ.//Pɩtɛ lɛ, ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ weyi ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ ɛnʊ.//"" // >>> lst
// []int{1, 2, 3}
// >>> lst
// int{}
// >>> lst
// []int{-1, -5, 2, -1, -5}
func sum_squares(lst []int) int {
","package sum_squares_test

import (
    ""testing""
)

func sum_squares(lst []int) int {
    sum := 0
    for i, val := range lst {
        if i%3 == 0 {
            sum += val * val
        } else if i%4 == 0 {
            sum += val * val * val
        } else {
            sum += val
        }
    }
    return sum
}

func TestSumSquares(t *testing.T) {
    tests := []struct {
        lst      []int
        expected int
    }{
        {[]int{1, 2, 3}, 10},   // 1^2 + 2 + 3 = 10
        {[]int{}, 0},           // empty list
        {[]int{-1, -5, 2, -1, -5}, 0}, // (-1)^2 + (-5)^3 + 2 + (-1) = -118
    }

    for _, test := range tests {
        result := sum_squares(test.lst)
        if result != test.expected {
            t.Errorf(""sum_squares(%v) = %d; expected %d"", test.lst, result, test.expected)
        }
    }
}","func TestSum_Squares(t *testing.T) {
  candidate := sum_squares
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: 6 },
     { actual: candidate([]int{1, 4, 9}), expected: 14 },
     { actual: candidate([]int{}), expected: 0 },
     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },
     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },
     { actual: candidate([]int{0}), expected: 0 },
     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },
     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },
     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },
     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },
     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_143,kbp_Latn,go_test.go,"package words_in_sentence_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ 1://Pɩwɛɛ se tɔm pee wena awɛ tɔm pee kɩfana taa yɔ, aɖɔ ɛzɩ a-tɛ kajalaɣ tɔm pee yɔ.//nɛ ɛ-kɩɖaʊ kɛ ɛyʊ kɩlɩm, //Nɛ pɩwɛɛ se ŋyele nɛ tɔm pee wena awɛ kajalaɣ tɔm piye taa yɔ, //tɔm pee naayɛ wɛ tɔm hʊyaa taa nɛ pɔhɔkɩ ɖama nɛ kʊɖʊmɩŋ, //Pɩɩha-ŋ tɔm pee wena awɛ ɛzɩ tɔm loyaɣ yɔ.// >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
func words_in_sentence(sentence string) string {
","package words_in_sentence_test

import (
    ""strings""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n == 2 {
        return true
    }
    if n%2 == 0 {
        return false
    }
    for i := 3; i*i <= n; i += 2 {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func words_in_sentence(sentence string) string {
    words := strings.Split(sentence, "" "")
    var result []string

    for _, word := range words {
        if isPrime(len(word)) {
            result = append(result, word)
        }
    }

    return strings.Join(result, "" "")
}","func TestWords_In_Sentence(t *testing.T) {
  candidate := words_in_sentence
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""This is a test""), expected: ""is"" },
     { actual: candidate(""lets go for swimming""), expected: ""go for"" },
     { actual: candidate(""there is no place available here""), expected: ""there is no place"" },
     { actual: candidate(""Hi I am Hussein""), expected: ""Hi am Hussein"" },
     { actual: candidate(""go for it""), expected: ""go for it"" },
     { actual: candidate(""here""), expected: """" },
     { actual: candidate(""here is""), expected: ""is"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_144,kbp_Latn,go_test.go,"package simplify_test

import (
    ""testing""
    ""fmt""
)

//Ŋpɩzɩɣ ŋmaɣzɩ se x nɛ n pɛkɛ hɔɔlɩŋ weyi ɩwɛ ɖeu yɔ, nɛ pɛfɛyɩnɩ zéro ɛzɩ pɛ-hɩɖɛ yɔ.//Ɛyʊ kʊyʊm nɛ ɛ-tɛ kʊyʊm pɛkpɛnda ɛ-tɛ kʊyʊm nɛ ɛ-tɛ kʊyʊm pɛkpɛnda ɛ-tɛ kʊyʊm.//Pɩtasɩna mbʋ yɔ, x nɛ n, pɛtɛyɩɣ tɔmpiye nɖɩ nɛ tɔmpiye nɖɩ ɖɩ-tɛ lɛɣtʊ, nɛ ɖɩ-tɛ lɛɣtʊ wɛ ɛzɩ mbʊ yɔ://x * n. Kɩ-tɛ lɛɣtʊ tʊmɩyɛ pɩsɩɣna toovenim yee x * n ɛ-tɛ lɛɣtʊ tʊmɩyɛ ɛtɛ lɛɣtʊ tʊmɩyɛ kɔyɔ nɛ false //Ña-tʋmɩyɛ lɛ se ŋlabɩnɩ tʋmɩyɛ tʋmɩyɛ nɖɩ ɖɩkaɣ kɛlɛʋ pɩ-yɔɔ yɔ .// >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
func simplify(x string, n string) bool {
","package simplify_test

import (
    ""strconv""
    ""strings""
    ""testing""
)

func simplify(x string, n string) bool {
    // Split the input strings into numerators and denominators
    xParts := strings.Split(x, ""/"")
    nParts := strings.Split(n, ""/"")

    // Convert the string parts to integers
    xNumerator, _ := strconv.Atoi(xParts[0])
    xDenominator, _ := strconv.Atoi(xParts[1])
    nNumerator, _ := strconv.Atoi(nParts[0])
    nDenominator, _ := strconv.Atoi(nParts[1])

    // Perform the multiplication (x * n) = (xNumerator/nDenominator) * (nNumerator/nDenominator)
    resultNumerator := xNumerator * nNumerator
    resultDenominator := xDenominator * nDenominator

    // Check if the result is a whole number
    return resultNumerator%resultDenominator == 0
}

func TestSimplify(t *testing.T) {
    if !simplify(""1/5"", ""5/1"") {
        t.Fatalf(""Expected true, got false"")
    }
    if simplify(""1/6"", ""2/1"") {
        t.Fatalf(""Expected false, got true"")
    }
    if simplify(""7/10"", ""10/2"") {
        t.Fatalf(""Expected false, got true"")
    }
}","func TestSimplify(t *testing.T) {
  candidate := simplify
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""1/5"", ""5/1""), expected: true },
     { actual: candidate(""1/6"", ""2/1""), expected: false },
     { actual: candidate(""5/1"", ""3/1""), expected: true },
     { actual: candidate(""7/10"", ""10/2""), expected: false },
     { actual: candidate(""2/10"", ""50/10""), expected: true },
     { actual: candidate(""7/2"", ""4/2""), expected: true },
     { actual: candidate(""11/6"", ""6/1""), expected: true },
     { actual: candidate(""2/3"", ""5/2""), expected: false },
     { actual: candidate(""5/2"", ""3/5""), expected: false },
     { actual: candidate(""2/4"", ""8/4""), expected: true },
     { actual: candidate(""2/4"", ""4/2""), expected: true },
     { actual: candidate(""1/5"", ""5/1""), expected: true },
     { actual: candidate(""1/5"", ""1/5""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_145,kbp_Latn,go_test.go,"package order_by_points_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Pɔɖɔkʋʋ-wɛ nɛ pa-hɩla ɛzɩ pamaʋ-wɛ kajalaɣ takayaɣ taa yɔ.//Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ: ye wondu ndɩ ndɩ ɩwɛna ɖama yɔɔ mayaɣ kʋɖʋmaɣ yɔ, //Pɩlɩʋ ŋgʋ kɩ-taa pamaɣna tɔm pee ana yɔ, kɩ-taa lɛ, pamaɣna-yɛ nɛ sɩ-hɩla.//Maɣzɩ nɛ ŋna ɛzɩma papɩzɩɣ nɛ pama tɔm pee wena awɛ tɔm pee kɩbana taa yɔ.// >>> order_by_points([]int{1, 11, -1, -11, -12})
// []int{-1, -11, 1, -12, 11}
// >>> order_by_points([]int{})
// []int{}
func order_by_points(nums []int) []int {
","package order_by_points_test

import (
	""testing""
	""fmt""
	""sort""
	""strconv""
)

func digitSum(n int) int {
	n = abs(n) // Consider the absolute value for digit sum
	sum := 0
	for n > 0 {
		sum += n % 10
		n /= 10
	}
	return sum
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func order_by_points(nums []int) []int {
	type numWithIndex struct {
		num   int
		index int
	}

	numsWithIndex := make([]numWithIndex, len(nums))
	for i, num := range nums {
		numsWithIndex[i] = numWithIndex{num, i}
	}

	sort.Slice(numsWithIndex, func(i, j int) bool {
		sumI := digitSum(numsWithIndex[i].num)
		sumJ := digitSum(numsWithIndex[j].num)
		if sumI == sumJ {
			return numsWithIndex[i].index < numsWithIndex[j].index
		}
		return sumI < sumJ
	})

	sortedNums := make([]int, len(nums))
	for i, nwi := range numsWithIndex {
		sortedNums[i] = nwi.num
	}

	return sortedNums
}

func TestOrderByPoints(t *testing.T) {
	testCases := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},
		{[]int{}, []int{}},
	}

	for _, tc := range testCases {
		result := order_by_points(tc.input)
		if !equal(result, tc.expected) {
			t.Errorf(""Expected %v, but got %v"", tc.expected, result)
		}
	}
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestOrder_By_Points(t *testing.T) {
  candidate := order_by_points
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },
     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },
     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_146,kbp_Latn,go_test.go,"package specialFilter_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Kajalaɣ nɛ kɛtɛzaɣ mayaɣ kɛna ɛyʊ kʊyʊm (1, 3, 5, 7, 9).//Takayɩhatʋ ndʋ tɩ-taa pɩpɔzʋʋ se pama takayɩhayʋʋ kʋnɛ yɔ//Maɣna se pamaɣna kɩkalʋʋ nakʋyʋ nɛ kɩpɩsɩɣ kɩ-tɛ tɔm.// >>> specialFilter([]int{15, -73, 14, -15})
// 1
// >>> specialFilter([]int{33, -2, -3, 45, 21, 109})
// 2
func specialFilter(nums []int) int {
","package specialFilter_test

import (
	""testing""
)

func specialFilter(nums []int) int {
	count := 0
	for _, num := range nums {
		// Consider the absolute value of the number
		absNum := abs(num)
		if absNum > 10 {
			strNum := fmt.Sprintf(""%d"", absNum)
			firstDigit := strNum[0]
			lastDigit := strNum[len(strNum)-1]
			if isOdd(firstDigit) && isOdd(lastDigit) {
				count++
			}
		}
	}
	return count
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func isOdd(digit byte) bool {
	return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'
}

func TestSpecialFilter(t *testing.T) {
	tests := []struct {
		input    []int
		expected int
	}{
		{[]int{15, -73, 14, -15}, 1},
		{[]int{33, -2, -3, 45, 21, 109}, 2},
		{[]int{8, 4, 12, 55, 99, 111}, 1},
		{[]int{-11, -22, -33, -44, -55}, 1},
	}

	for _, test := range tests {
		result := specialFilter(test.input)
		if result != test.expected {
			t.Errorf(""specialFilter(%v) = %d; want %d"", test.input, result, test.expected)
		}
	}
}","func TestSpecialfilter(t *testing.T) {
  candidate := specialFilter
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },
     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },
     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },
     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },
     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },
     { actual: candidate([]int{1}), expected: 0 },
     { actual: candidate([]int{}), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_147,kbp_Latn,go_test.go,"package get_max_triples_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ://nɛ a[i] + a[j] + a[k] kɛ 3 tam nabʊyʊ. //Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ://Paa i (1 ≤ i ≤ n) lɛ, a[i] = i * i - i + 1 wɛna wazaɣ.//Pʊtɔbʊʊ se ŋwɛna ɛyʊ kʊyʊmʊm n. Pɩwɛɛ se ŋñɔɔzɩ ɛyʊ kʊyʊmʊm a weyi ɛ-ɖaɣlɩkɩŋ talɩɣ ɛzɩ n yɔ.// >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
func get_max_triples(n int) int {
","package get_max_triples_test

import (
    ""testing""
)

func get_max_triples(n int) int {
    a := make([]int, n)
    for i := 1; i <= n; i++ {
        a[i-1] = i*i - i + 1
    }
    
    count := 0
    
    for i := 0; i < n-2; i++ {
        for j := i + 1; j < n-1; j++ {
            for k := j + 1; k < n; k++ {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count++
                }
            }
        }
    }
    
    return count
}

func TestGetMaxTriples(t *testing.T) {
    if get_max_triples(5) != 1 {
        t.Errorf(""Expected 1 but got %d"", get_max_triples(5))
    }
}","func TestGet_Max_Triples(t *testing.T) {
  candidate := get_max_triples
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 1 },
     { actual: candidate(6), expected: 4 },
     { actual: candidate(10), expected: 36 },
     { actual: candidate(100), expected: 53361 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_148,kbp_Latn,go_test.go,"package bf_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Pɩtɩkɛ tɛtʋ wandamm hɩla.//Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ ɛyʊ yɔɔ tɔm ndʊ tɩfɛyɩ yɔ yee pɩkɛ planet1 yaa planet2 //Pɩtɩkɛ wɩsɩ cɔlɔ pɩlɩnaa.//Pɩkɛna tɛtʊ ndʊ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna.//Pɩwɛɛ se tʋmɩyɛ nɖɩ ɖɩpɩsɩna kedeŋa kpeekpe tɛtʋ wandamm ndɩ ndɩ nɛ tɩ-tɛ lɛɣtʋ ndɩ ndɩ.//Ma tʋmɩyɛ nɖɩ ɖɩkpaɣ kpɩnɛ naalɛ hɩla ɛzɩ kpɩnɛ 1 nɛ kpɩnɛ 2 yɔ.//Uranɩ nɛ Neptuni.//Pɩtɛ lɛ, ɖɩnaɣ tɛtʋ, Maarɩsɩ, Jupitɛɛrɩ, Saturn, nɛ pɩtɛ lɛ, Vénus.//Wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ.// >>> bf(""Jupiter"", ""Neptune"")
// []interface{}{""Saturn"", ""Uranus""}
// >>> bf(""Earth"", ""Mercury"")
// ""Venus""
// >>> bf(""Mercury"", ""Uranus"")
// []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}
func bf(planet1 string, planet2 string) []interface{} {
","package bf_test

import (
    ""testing""
    ""fmt""
)

// Define the solar system slice with planets ordered by their proximity to the Sun
var solarSystem = []string{""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""}

func bf(planet1 string, planet2 string) []interface{} {
    index1 := -1
    index2 := -1

    // Find the indices of the given planet names in the solarSystem slice
    for i, planet := range solarSystem {
        if planet == planet1 {
            index1 = i
        }
        if planet == planet2 {
            index2 = i
        }
    }

    // If either planet name is incorrect, return an empty list
    if index1 == -1 || index2 == -1 {
        return []interface{}{}
    }

    // Ensure index1 is less than index2 to find planets between them
    if index1 > index2 {
        index1, index2 = index2, index1
    }

    // Collect and return planets that are located between the two indices
    var planetsBetween []interface{}
    for i := index1 + 1; i < index2; i++ {
        planetsBetween = append(planetsBetween, solarSystem[i])
    }
    
    return planetsBetween
}

func TestBf(t *testing.T) {
    fmt.Println(bf(""Jupiter"", ""Neptune"")) // Should print: []interface{}{""Saturn"", ""Uranus""}
    fmt.Println(bf(""Earth"", ""Mercury""))  // Should print: []interface{}{""Venus""}
    fmt.Println(bf(""Mercury"", ""Uranus"")) // Should print: []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}
}","func TestBf(t *testing.T) {
  candidate := bf
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Jupiter"", ""Neptune""), expected: []interface{}{""Saturn"", ""Uranus""} },
     { actual: candidate(""Earth"", ""Mercury""), expected: []interface{}{""Venus""} },
     { actual: candidate(""Mercury"", ""Uranus""), expected: []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""} },
     { actual: candidate(""Neptune"", ""Venus""), expected: []interface{}{""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""} },
     { actual: candidate(""Earth"", ""Earth""), expected: []interface{}{} },
     { actual: candidate(""Mars"", ""Earth""), expected: []interface{}{} },
     { actual: candidate(""Jupiter"", ""Makemake""), expected: []interface{}{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_149,kbp_Latn,go_test.go,"package sorted_list_sum_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm pee tɩŋa wɛna kɩmaŋ.//Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ ɛyʊ tɔm ndʊ tɩ-tɛ tɔm yɔ tɩ-takayaɣ.//Ye tɔm pee naalɛ ɩwɛna kɩmaŋ kʋɖʋmʋʋ yɔ, ɖiyini-yɛ paa mayaɣ ŋga ka-taa.//Pɩwɛɛ se papɩsɩnɩ-ɩ tɔm ndʋ tɩ-taa pama paɣtʋ ndʋ tɩ-yɔɔ yɔ.//Pɩwɛɛ se ŋñɔɔzɩ tɔm pee wena ŋkaɣ maʋ yɔ nɛ ŋpaɣlɩɣ-yɛ nɛ ŋpaɣlɩɣ ɛzɩ tɔm pee wena ŋkaɣ maʋ yɔ.//Pɩpɩzɩɣ nɛ pɩla se kɩ-taa tɔm kɩlɛlʋʋ wɛɛ.//Takayɩhayʋʋ kʋnɛ kɩ-taa wɛ tam nɛ kɩtɩkɛ nimero waa tɛ takayɩhayʋʋ.//nɛ pɩpɩsɩɣ kɩ-tɛ tɔm kɩmamatʋ nɛ kɩ-tɛ tɔm kɩmamatʋ, //ɛtɛzɩɣ kɩ-taa tɔmpiye nɖɩ ɖɩ-tɛ kɩɖaɣlɩm fɛyɩ yɔ, //Ma tʋmɩyɛ nɖɩ ɖɩmʋɣ tɔmpiye ndɩ ndɩ yɔ, // >>> list_sort([]string{""aa"", ""a"", ""aaa""})
// []string{""aa""}
// >>> list_sort([]string{""ab"", ""a"", ""aaa"", ""cd""})
// []string{""ab"", ""cd""}
func sorted_list_sum(lst []string) []string {
","package sorted_list_sum_test

import (
    ""sort""
)

func sorted_list_sum(lst []string) []string {
    // Filter out strings with odd lengths
    filtered := []string{}
    for _, str := range lst {
        if len(str)%2 == 0 {
            filtered = append(filtered, str)
        }
    }

    // Sort the filtered list by length, then alphabetically
    sort.Slice(filtered, func(i, j int) bool {
        if len(filtered[i]) == len(filtered[j]) {
            return filtered[i] < filtered[j]
        }
        return len(filtered[i]) < len(filtered[j])
    })

    return filtered
}","func TestSorted_List_Sum(t *testing.T) {
  candidate := sorted_list_sum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""aa"", ""a"", ""aaa""}), expected: []string{""aa""} },
     { actual: candidate([]string{""school"", ""AI"", ""asdf"", ""b""}), expected: []string{""AI"", ""asdf"", ""school""} },
     { actual: candidate([]string{""d"", ""b"", ""c"", ""a""}), expected: []string{} },
     { actual: candidate([]string{""d"", ""dcba"", ""abcd"", ""a""}), expected: []string{""abcd"", ""dcba""} },
     { actual: candidate([]string{""AI"", ""ai"", ""au""}), expected: []string{""AI"", ""ai"", ""au""} },
     { actual: candidate([]string{""a"", ""b"", ""b"", ""c"", ""c"", ""a""}), expected: []string{} },
     { actual: candidate([]string{""aaaa"", ""bbbb"", ""dd"", ""cc""}), expected: []string{""cc"", ""dd"", ""aaaa"", ""bbbb""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_150,kbp_Latn,go_test.go,"package x_or_y_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩwɛɛ se ɛpɩzɩ nɛ ɛlɩzɩ y tɛ mayaɣ ŋga ka-taa ɛyʊ wɛɛ yɔ.//Pɩkɛna kɩlɛmʋʋ kɩlɛmʋʋ kɩlɛmʋʋ ŋgʋ kɩ-taa papɩzɩɣ nɛ patɩlɩ x yee n ɛ-tɛ lɛlʊ kɔyɔ.// >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
func x_or_y(n int, x int, y int) int {
","package x_or_y_test

import (
    ""testing""
    ""math""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func x_or_y(n int, x int, y int) int {
    if isPrime(n) {
        return x
    }
    return y
}

func TestXOrY(t *testing.T) {
    cases := []struct{
        n, x, y, want int
    }{
        {7, 34, 12, 34},
        {15, 8, 5, 5},
        {2, 10, 20, 10},
        {1, 5, 15, 15},
    }

    for _, c := range cases {
        got := x_or_y(c.n, c.x, c.y)
        if got != c.want {
            t.Errorf(""x_or_y(%d, %d, %d) == %d, want %d"", c.n, c.x, c.y, got, c.want)
        }
    }
}","func TestX_Or_Y(t *testing.T) {
  candidate := x_or_y
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(7, 34, 12), expected: 34 },
     { actual: candidate(15, 8, 5), expected: 5 },
     { actual: candidate(3, 33, 5212), expected: 33 },
     { actual: candidate(1259, 3, 52), expected: 3 },
     { actual: candidate(7919, -1, 12), expected: -1 },
     { actual: candidate(3609, 1245, 583), expected: 583 },
     { actual: candidate(91, 56, 129), expected: 129 },
     { actual: candidate(6, 34, 1234), expected: 1234 },
     { actual: candidate(1, 2, 0), expected: 0 },
     { actual: candidate(2, 2, 0), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_151,kbp_Latn,go_test.go,"package double_the_difference_test

import (
    ""testing""
    ""fmt""
)

//Pɩfɛyɩ ɖeu se ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa lɛ.//Ye ŋha-ɖʋ nimbrɩwaa mba pa-hɩla yɔ, ŋpɩzɩɣ nɛ ŋlɩzɩ pa-nɩŋgbanzɩ nɛ ŋyele nɛ sɩkpɛndɩ nɛ sɩpɩsɩ nimbrɩwaa mba pa-hɩla yɔ.// >>> double_the_difference([]int{1, 3, 2, 0})
// 10
// >>> double_the_difference([]int{-1, -2, 0})
// 0
// >>> double_the_difference([]int{9, -2})
// 81
// >>> double_the_difference([]int{0})
// 0
// If the input list is empty, return 0.
func double_the_difference(lst []float64) int {
","package double_the_difference_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func double_the_difference(lst []float64) int {
    sum := 0
    for _, num := range lst {
        if num >= 0 && math.Mod(num, 1) == 0 {
            intNum := int(num)
            if intNum%2 != 0 {
                sum += intNum * intNum
            }
        }
    }
    return sum
}

func TestDoubleTheDifference(t *testing.T) {
    cases := []struct {
        input []float64
        expected int
    }{
        {input: []float64{1, 3, 2, 0}, expected: 10},
        {input: []float64{-1, -2, 0}, expected: 0},
        {input: []float64{9, -2}, expected: 81},
        {input: []float64{0}, expected: 0},
        {input: []float64{}, expected: 0},
    }

    for _, c := range cases {
        result := double_the_difference(c.input)
        if result != c.expected {
            t.Errorf(""double_the_difference(%v) == %d, want %d"", c.input, result, c.expected)
        } else {
            fmt.Printf(""Test passed for input %v. Result: %d\n"", c.input, result)
        }
    }
}","func TestDouble_The_Difference(t *testing.T) {
  candidate := double_the_difference
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{}), expected: 0 },
     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },
     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },
     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },
     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },
     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },
     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_152,kbp_Latn,go_test.go,"package compare_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Pɩtɛ lɛ, kɩ-tɛ wɛtʊ lɛɣzʊʊ lɛɣzʊʊ nɛ kɩ-tɛ wɛtʊ lɛɣzʊʊ lɛɣzʊʊ.//Ɛpɩsɩɣ tɔm kɩmamatʋ ndʋ tɩ-ɖaɣlɩkɩŋ kɩlɩna ɖama yɔ nɛ ɛwɩlɩɣ ɛzɩma ɛ-ɛzɩdaa wɛɛ yɔ.//Pʊtɔbʊʊ se ŋwɛna takayasɩ naalɛ nɛ paa takayasɩ nzɩ lɛ, sɩwɛna kɩmaŋ.//Pɩwɛɛ se ŋtɩlɩ se ɛyʋ nɔɔyʋ maɣzaɣ se ɛ-tɔm kɛ toovenim.//Pɩwɛɣ ɖeu se ɖɩmaɣzɩ nɛ ɖɩna.//Pɩtasɩ lɛ, ye ŋcaɣ se ŋtɩlɩ mbʋ pɩ-taa ŋwɛɛ yɔ, ŋpɩzɩɣ nɛ ŋmaɣzɩ mbʋ pɩ-taa ŋwɛɛ yɔ pɩ-yɔɔ.//Maɣzɩ se ɖa-tɩŋa ɖɩtɔzʋʋ ɛzɩma pɩlakaɣ ɛyʋ alɩwaatʋ ndʋ ɛ-taa lakɩ leleŋ nɛ ɛ-kɩcɛyɩm yɔ pɩ-yɔɔ.// >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})
// []int{0, 0, 0, 0, 3, 3}
// >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})
// []int{4, 4, 1, 0, 0, 6}
func compare(game []int, guess []int) []int {
","package compare_test

import (
    ""math""
    ""testing""
    ""fmt""
)

func compare(game []int, guess []int) []int {
    result := make([]int, len(game))
    for i := 0; i < len(game); i++ {
        if game[i] == guess[i] {
            result[i] = 0
        } else {
            result[i] = int(math.Abs(float64(game[i] - guess[i])))
        }
    }
    return result
}

func TestCompare(t *testing.T) {
    tests := []struct {
        game  []int
        guess []int
        want  []int
    }{
        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},
        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf(""%v vs %v"", tt.game, tt.guess), func(t *testing.T) {
            got := compare(tt.game, tt.guess)
            for i := range got {
                if got[i] != tt.want[i] {
                    t.Errorf(""compare(%v, %v) = %v; want %v"", tt.game, tt.guess, got, tt.want)
                }
            }
        })
    }
}","func TestCompare(t *testing.T) {
  candidate := compare
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },
     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },
     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },
     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_153,kbp_Latn,go_test.go,"package Strongest_Extension_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //(Ɛ-tɛ ɖoŋ wɛ -1).//return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension //Pɩtɛ lɛ, ŋpɩzɩɣ nɛ ŋpɔzɩ-ɩ se://Ɖɩkpaɣ ɛzɩ, ye paha-ŋ ""Slices"" ɛzɩ sukuli nɛ //Lɩzɩ mbʋ pɩ-tɔm kɩlɩ cɛyʋʋ yɔ.//Ye ŋwɛnɩ kɩɖaɣlʋʋ naalɛ yaa kɩɖaɣlʋʋ sakɩyɛ nɛ ɩwɛ ɖoŋ kʋɖʋmʋʋ yɔ, pɩwɛɛ se ŋñɔɔzɩ- ɩ nɛ ŋlabɩnɩ tʋmɩyɛ.//Pɩsɩ takayɩhayʋʋ: ClassName.StrongestExtensionName ñɩŋgʋ yɔɔ. //Pɩwɛɛ se ŋñɩnɩ kɩwalʊʊ ŋgʊ kɩkɩlɩ ɖoŋ yɔ nɛ ŋpɩsɩ ɛ-tɛ tɔmpiye naɖɩyɛ.//Pɩtɛ lɛ, pɛtɛzɩɣ-ɩ yaʋ se CAP - SM.//Takayɩhatʋ ndʋ tɩtamsɩna \\ Ɛntɛrnɛtɩ \\ yɔ//Pɩtɛ ɖoŋ tɔmpiye nɖɩ ɖɩ-taa lɛ: CAP kɛna mayaɣ sɔsɔɣa ŋga pama-kɛ yɔ.//Pɩtɛ kɩwalʊʊ ŋgʊ kɩ-taa papɩzɩɣ patasɩ kpaɣʊ takayasɩ lɛɛsɩ.//Pʊkɔŋna-ŋ haʊ takayaɣ ŋga payaɣ-kɛ se class yɔ (kɛkɛdaɣ) nɛ ŋnaɣ ɖɔɖɔ kɩwalɩtʊ ndʊ tɩ-yɔɔ ŋpɩzɩɣ ŋtɩŋna yɔ.// >>> Strongest_Extension(""my_class"", []string{""AA"", ""Be"", ""CC""})
// ""my_class.AA""
func Strongest_Extension(class_name string, extensions []string) string {
","func Strongest_Extension(class_name string, extensions []string) string {
    strongestExtension := """"
    maxStrength := -1 << 31

    for _, extension := range extensions {
        capCount, smCount := 0, 0
        for _, char := range extension {
            if char >= 'A' && char <= 'Z' {
                capCount++
            } else if char >= 'a' && char <= 'z' {
                smCount++
            }
        }
        strength := capCount - smCount
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = extension
        }
    }

    return fmt.Sprintf(""%s.%s"", class_name, strongestExtension)
}","func TestStrongest_Extension(t *testing.T) {
  candidate := Strongest_Extension
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Watashi"", []string{""tEN"", ""niNE"", ""eIGHt8OKe""}), expected: ""Watashi.eIGHt8OKe"" },
     { actual: candidate(""Boku123"", []string{""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""}), expected: ""Boku123.YEs.WeCaNe"" },
     { actual: candidate(""__YESIMHERE"", []string{""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""}), expected: ""__YESIMHERE.NuLl__"" },
     { actual: candidate(""K"", []string{""Ta"", ""TAR"", ""t234An"", ""cosSo""}), expected: ""K.TAR"" },
     { actual: candidate(""__HAHA"", []string{""Tab"", ""123"", ""781345"", ""-_-""}), expected: ""__HAHA.123"" },
     { actual: candidate(""YameRore"", []string{""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""}), expected: ""YameRore.okIWILL123"" },
     { actual: candidate(""finNNalLLly"", []string{""Die"", ""NowW"", ""Wow"", ""WoW""}), expected: ""finNNalLLly.WoW"" },
     { actual: candidate(""_"", []string{""Bb"", ""91245""}), expected: ""_.Bb"" },
     { actual: candidate(""Sp"", []string{""671235"", ""Bb""}), expected: ""Sp.671235"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_154,kbp_Latn,go_test.go,"package cycpattern_check_test

import (
    ""testing""
    ""fmt""
)

//Ŋwɛna tɔm naalɛ nɛ pɩwɛɛ se ŋpɩsɩ tɔm ndʋ tɩkɛ toovenim yɔ, ye tɔm naalɛ ñɩndʋ yaa tɩ-tɛ lɛɛtʋ tɩkɛ kajalaɣ tɔm piye taa tɔm piye cikpeɖe yɔ.// >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
func cycpattern_check(a string, b string) bool {
","package cycpattern_check_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func cycpattern_check(a string, b string) bool {
    n := len(b)
    
    // Generate all rotations of b
    for i := 0; i < n; i++ {
        rotated := b[i:] + b[:i]
        if strings.Contains(a, rotated) {
            return true
        }
    }
    
    return false
}","func TestCycpattern_Check(t *testing.T) {
  candidate := cycpattern_check
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""xyzw"", ""xyw""), expected: false },
     { actual: candidate(""yello"", ""ell""), expected: true },
     { actual: candidate(""whattup"", ""ptut""), expected: false },
     { actual: candidate(""efef"", ""fee""), expected: true },
     { actual: candidate(""abab"", ""aabb""), expected: false },
     { actual: candidate(""winemtt"", ""tinem""), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_155,kbp_Latn,go_test.go,"package even_odd_count_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Ye ɖɩha-ɩ nimero waa tɩŋa yɔ, ɛkaɣ pɩsʋʋ takayaɣ ŋga ka-taa ɛnaɣ nimero waa mba pɛtɛyɩɣ yɔ nɛ mba pɛtɛyɩɣ yɔ.// >>> even_odd_count(-12)
// []interface{}{1, 1}
// >>> even_odd_count(123)
// []interface{}{1, 2}
func even_odd_count(num int) []interface{} {
","func even_odd_count(num int) []interface{} {
    // Handle negative numbers by taking the absolute value
    if num < 0 {
        num = -num
    }
    
    evenCount, oddCount := 0, 0

    // Iterate over each digit in the number
    for num > 0 {
        digit := num % 10
        if digit%2 == 0 {
            evenCount++
        } else {
            oddCount++
        }
        num /= 10
    }

    return []interface{}{evenCount, oddCount}
}

func TestEvenOddCount(t *testing.T) {
    testCases := []struct {
        input    int
        expected []interface{}
    }{
        {-12, []interface{}{1, 1}},
        {123, []interface{}{1, 2}},
        {2468, []interface{}{4, 0}},
        {1357, []interface{}{0, 4}},
        {0, []interface{}{1, 0}},
    }

    for _, testCase := range testCases {
        result := even_odd_count(testCase.input)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", testCase.expected) {
            t.Errorf(""even_odd_count(%d) = %v; expected %v"", testCase.input, result, testCase.expected)
        }
    }
}","func TestEven_Odd_Count(t *testing.T) {
  candidate := even_odd_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(7), expected: []interface{}{0, 1} },
     { actual: candidate(-78), expected: []interface{}{1, 1} },
     { actual: candidate(3452), expected: []interface{}{2, 2} },
     { actual: candidate(346211), expected: []interface{}{3, 3} },
     { actual: candidate(-345821), expected: []interface{}{3, 3} },
     { actual: candidate(-2), expected: []interface{}{1, 0} },
     { actual: candidate(-45347), expected: []interface{}{2, 3} },
     { actual: candidate(0), expected: []interface{}{1, 0} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_156,kbp_Latn,go_test.go,"package int_to_mini_roman_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ: //Pɩtɛ kɩlɛmɩŋ: 1 <= num <= 1000 //Nɛ ŋyele nɛ pama-kʋ nɛ tɔm pee cikpeŋ.//Ye paha-ɖʋ kɩmaŋ mayaɣ kɔyɔ, ɖɩkpaɣ kɩmaŋ mayaɣ ŋga nɛ ɖɩkpaɣ Roma n̄ɩnzɩ taa yɔ nɛ ɖɩlɩzɩ-kɛ nɛ ɖɩlabɩnɩ tʋmɩyɛ.// >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
func int_to_mini_roman(number int) string {
","package int_to_mini_roman_test

import (
	""strings""
	""testing""
)

func int_to_mini_roman(number int) string {
	vals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
	symbols := []string{""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""}

	var roman strings.Builder

	for i := 0; i < len(vals); i++ {
		for number >= vals[i] {
			number -= vals[i]
			roman.WriteString(symbols[i])
		}
	}
	return roman.String()
}

func TestIntToMiniRoman(t *testing.T) {
	tests := []struct {
		input    int
		expected string
	}{
		{19, ""xix""},
		{152, ""clii""},
		{426, ""cdxxvi""},
		{1000, ""m""},
		{1, ""i""},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf(""%d"", tt.input), func(t *testing.T) {
			result := int_to_mini_roman(tt.input)
			if result != tt.expected {
				t.Fatalf(""expected %v, but got %v"", tt.expected, result)
			}
		})
	}
}","func TestInt_To_Mini_Roman(t *testing.T) {
  candidate := int_to_mini_roman
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(19), expected: ""xix"" },
     { actual: candidate(152), expected: ""clii"" },
     { actual: candidate(251), expected: ""ccli"" },
     { actual: candidate(426), expected: ""cdxxvi"" },
     { actual: candidate(500), expected: ""d"" },
     { actual: candidate(1), expected: ""i"" },
     { actual: candidate(4), expected: ""iv"" },
     { actual: candidate(43), expected: ""xliii"" },
     { actual: candidate(90), expected: ""xc"" },
     { actual: candidate(94), expected: ""xciv"" },
     { actual: candidate(532), expected: ""dxxxii"" },
     { actual: candidate(900), expected: ""cm"" },
     { actual: candidate(994), expected: ""cmxciv"" },
     { actual: candidate(1000), expected: ""m"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_157,kbp_Latn,go_test.go,"package right_angle_triangle_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Pɩcɛzɩ ɛzɩ 90 mbʋ yɔ.//Hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ.//Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.//Ye ɖɩkpaɣ tɔmpiye nɖɩ ɖɩ-tɛ hɔɔlɩŋ naadozo yɔ, ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ toovenim tɔm kɔyɔ, tɔmpiye nɖɩ ɖɩ-tɛ hɔɔlɩŋ naadozo yɔ, ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ toovenim tɔm yɔ.// >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
func right_angle_triangle(a int, b int, c int) bool {
","package right_angle_triangle_test

import (
    ""testing""
    ""fmt""
)

func right_angle_triangle(a int, b int, c int) bool {
    // Squaring the sides
    a2, b2, c2 := a*a, b*b, c*c
    // Check the Pythagorean theorem for the combination of sides
    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2
}","func TestRight_Angle_Triangle(t *testing.T) {
  candidate := right_angle_triangle
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 4, 5), expected: true },
     { actual: candidate(1, 2, 3), expected: false },
     { actual: candidate(10, 6, 8), expected: true },
     { actual: candidate(2, 2, 2), expected: false },
     { actual: candidate(7, 24, 25), expected: true },
     { actual: candidate(10, 5, 7), expected: false },
     { actual: candidate(5, 12, 13), expected: true },
     { actual: candidate(15, 8, 17), expected: true },
     { actual: candidate(48, 55, 73), expected: true },
     { actual: candidate(1, 1, 1), expected: false },
     { actual: candidate(2, 2, 10), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_158,kbp_Latn,go_test.go,"package find_max_test

import (
    ""testing""
    ""fmt""
)

//Takayɩhatʋ ndʋ tɩtamsɩna \\ Takayɩhatʋ ndʋ tɩtɩkɛ takayaɣ nakɛyɛ yɔ \\ yɔ//Yee tɔm pee kɩkpɛdɩŋ ɛɖɔwa kɔyɔ, tɔm pee kɩkpɛdɩŋ sakɩyɛ wɛna.//Tɔm pee ndɩ ndɩ wɛ tɔmpiye nɖɩ ɖɩ-taa.//Ma tʋmɩyɛ nɖɩ ɖɩmʋɣ tɔmpiye ndɩ ndɩ yɔ.// >>> find_max([]string{""name"", ""of"", ""string""})
// ""string""
// >>> find_max([]string{""name"", ""enam"", ""game""})
// ""enam""
// >>> find_max([]string{""aaaaaaa"", ""bb"", ""cc""})
// ""aaaaaaa""
func find_max(words []string) string {
","package find_max_test

import (
    ""testing""
    ""fmt""
    ""sort""
)

func find_max(words []string) string {
    maxWord := """"
    maxUnique := 0
    
    for _, word := range words {
        uniqueChars := countUniqueChars(word)
        if uniqueChars > maxUnique {
            maxUnique = uniqueChars
            maxWord = word
        } else if uniqueChars == maxUnique {
            if maxWord == """" || word < maxWord {
                maxWord = word
            }
        }
    }
    
    return maxWord
}

func countUniqueChars(word string) int {
    charSet := make(map[rune]struct{})
    for _, c := range word {
        charSet[c] = struct{}{}
    }
    return len(charSet)
}

// Test case runs to verify the solution
func TestFindMax(t *testing.T) {
    testCases := []struct {
        input []string
        expected string
    }{
        {[]string{""name"", ""of"", ""string""}, ""string""},
        {[]string{""name"", ""enam"", ""game""}, ""enam""},
        {[]string{""aaaaaaa"", ""bb"", ""cc""}, ""aaaaaaa""},
    }

    for _, tc := range testCases {
        result := find_max(tc.input)
        if result != tc.expected {
            t.Errorf(""For input %v, expected %s, but got %s"", tc.input, tc.expected, result)
        } else {
            fmt.Printf(""Test passed for input %v\n"", tc.input)
        }
    }
}","func TestFind_Max(t *testing.T) {
  candidate := find_max
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""name"", ""of"", ""string""}), expected: ""string"" },
     { actual: candidate([]string{""name"", ""enam"", ""game""}), expected: ""enam"" },
     { actual: candidate([]string{""aaaaaaa"", ""bb"", ""cc""}), expected: ""aaaaaaa"" },
     { actual: candidate([]string{""abc"", ""cba""}), expected: ""abc"" },
     { actual: candidate([]string{""play"", ""this"", ""game"", ""of"", ""footbott""}), expected: ""footbott"" },
     { actual: candidate([]string{""we"", ""are"", ""gonna"", ""rock""}), expected: ""gonna"" },
     { actual: candidate([]string{""we"", ""are"", ""a"", ""mad"", ""nation""}), expected: ""nation"" },
     { actual: candidate([]string{""this"", ""is"", ""a"", ""prrk""}), expected: ""this"" },
     { actual: candidate([]string{""b""}), expected: ""b"" },
     { actual: candidate([]string{""play"", ""play"", ""play""}), expected: ""play"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_159,kbp_Latn,go_test.go,"package eat_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ: //Ye ŋfɛyɩnɩ kaarooti sakɩyɛ yɔ, ŋkaɣ tɔɔʋ kaarooti tɩŋa, ɛlɛ ñɔɔsɩ kaɣ-ŋ kpaʋ.//[Yele nɛ paɖʋ video ŋgʋ kɩ-tɛɛ tɔm pɔzʋʋ.]//Pɩwɛɛ se ŋma [ ɛzɩma ŋtɔɔ mɩ-tɛ karɩbɔɔnɩ yɔ, pɩ-tɩŋa pʋ-tɔm nɛ ŋyele nɛ [//Ɛlɛ lɛɛlɛɛyɔ lɛ, pɩwɛɛ se ŋtɔɔ karɩbɔɔnɩ nɛ pɩsa nɛ ŋtɛ ña-kɩyakʋ taa tɔɔnaɣ.//Ŋkɛ kpɩnɛ nɖɩ ɖɩwɛnɩ ñɔɔsɩ yɔ, nɛ ŋtɛm tɔɔʋ kaarooti sakɩyɛ.// >>> eat(5, 6, 10)
// []int{11, 4}
// >>> eat(4, 8, 9)
// []int{12, 1}
// >>> eat(1, 10, 10)
// []int{11, 0}
// >>> eat(2, 11, 5)
// []int{7, 0}
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
func eat(number int, need int, remaining int) []int {
","package eat_test

import (
    ""testing""
    ""fmt""
)

// eat calculates the total number of eaten carrots after meals and the number of carrots left.
func eat(number int, need int, remaining int) []int {
    if need <= remaining {
        return []int{number + need, remaining - need}
    }
    return []int{number + remaining, 0}
}

func TestEat(t *testing.T) {
    tests := []struct {
        number, need, remaining int
        expected                []int
    }{
        {5, 6, 10, []int{11, 4}},
        {4, 8, 9, []int{12, 1}},
        {1, 10, 10, []int{11, 0}},
        {2, 11, 5, []int{7, 0}},
    }

    for _, test := range tests {
        result := eat(test.number, test.need, test.remaining)
        if result[0] != test.expected[0] || result[1] != test.expected[1] {
            t.Errorf(""eat(%d, %d, %d) = %v; expected %v"", test.number, test.need, test.remaining, result, test.expected)
        }
    }
}","func TestEat(t *testing.T) {
  candidate := eat
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5, 6, 10), expected: []int{11, 4} },
     { actual: candidate(4, 8, 9), expected: []int{12, 1} },
     { actual: candidate(1, 10, 10), expected: []int{11, 0} },
     { actual: candidate(2, 11, 5), expected: []int{7, 0} },
     { actual: candidate(4, 5, 7), expected: []int{9, 2} },
     { actual: candidate(4, 5, 1), expected: []int{5, 0} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_160,kbp_Latn,go_test.go,"package do_algebra_test

import (
    ""testing""
    ""fmt""
)

//Ɛyʊ weyi ɛ-tɛ tɔm wɛʊ yɔ, ɛ-tɛ tɔm wɛʊ kɔyɔ, ɛ-tɛ tɔm wɛʊ kɔyɔ, ɛ-tɛ tɔm wɛʊ kɔyɔ, ɛ-tɛ tɔm wɛʊ kɔyɔ, ɛ-tɛ tɔm wɛʊ kɔyɔ.//Ɛkɛ nimero waa mba pɛfɛyɩ kɩmaŋ yɔ pa-takayaɣ.//Ɛyʊ kʊyʊm kpɛlɛkʊʊ tʊmɩyɛ taa lɛ, ɛ-tʊmɩyɛ labʊ taa lɛ, ɛ-tʊmɩyɛ labʊ taa lɛ, ɛ-tʊmɩyɛ labʊ taa lɛ, ɛ-tʊmɩyɛ labʊ taa lɛ, ɛ-tʊmɩyɛ labʊ taa lɛ, ɛ-tʊmɩyɛ labʊ taa.//Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ://=> Kɩ-tɛ lɩmaɣzɩyɛ = 9 //Pɩwɩlɩɣ se 2 + 3 * 4 - 5 .//Takayɩhatʋ ndʋ tɩtamsɩna \\ [2, 3, 4, 5] \\ yɔ//ɛyʊ weyi ɛ-tɛ tɔm wɛ ndɩ yɔ['+', '*', '-'] //Kɩɖaʋ: //Kpɛlɩ kpɛlɛkʋʋ (**) //Tɛtʊ tʊma ( //) //Kɩwalʋʋ (*) //Kpaɣtʋ ( - ) //Pɩtɛ (+) //Algebra taa tʋma kɩbana: //Ɛ-tɔm pee nɛ ɛɖaɣnɩ pɩsʋʋ tɔm pee ana a-tɔm pee.//Takayɩhatʋ naalɛ ñɩŋgʋ lɛ, ɛyʊ ɛ-tɛ ɛyʊ kɩlɩm.//Ɛ-tɛ algebra tʊma wɛna kajalaɣ ñɩna taa nɛ func do_algebra(operator []string, operand []int) int {
","package do_algebra_test

import (
    ""fmt""
    ""testing""
)

func do_algebra(operator []string, operand []int) int {
    if len(operator) != len(operand)-1 {
        return 0
    }

    result := operand[0]
    for i := 0; i < len(operator); i++ {
        switch operator[i] {
        case ""+"":
            result += operand[i+1]
        case ""-"":
            result -= operand[i+1]
        case ""*"":
            result *= operand[i+1]
        case ""//"":
            result /= operand[i+1]
        case ""**"":
            result = intPow(result, operand[i+1])
        }
    }

    return result
}

func intPow(base, exp int) int {
    result := 1
    for exp != 0 {
        if exp%2 == 1 {
            result *= base
        }
        exp /= 2
        base *= base
    }
    return result
}

func TestDoAlgebra(t *testing.T) {
    operators := []string{""+"", ""*"", ""-""}
    operands := []int{2, 3, 4, 5}
    expectedResult := 9
    result := do_algebra(operators, operands)
    if result != expectedResult {
        t.Errorf(""expected %d but got %d"", expectedResult, result)
    }

    fmt.Println(""All tests passed."")
}","func TestDo_Algebra(t *testing.T) {
  candidate := do_algebra
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""**"", ""*"", ""+""}, []int{2, 3, 4, 5}), expected: 37 },
     { actual: candidate([]string{""+"", ""*"", ""-""}, []int{2, 3, 4, 5}), expected: 9 },
     { actual: candidate([]string{""//"", ""*""}, []int{7, 3, 4}), expected: 8 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_161,kbp_Latn,go_test.go,"package solve_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaŋ //Pɩwɛɛ se tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee wena awɛ pɩ-taa yɔ.//Ye tɔmpiye nɖɩ ɖɩfɛyɩna masɩ nasɩyɛ kɔyɔ, pɛlɛɣzɩ-ɖɩ nɛ ɖɩpɩsɩ.//Ye pɩtɛkɛ mbʋ yɔ, yele-kʋ nɛ kɩwɛɛ mbʋ.//Yee s[i] ɛkɛ mayaɣ kɔyɔ, ɛ-tɛ tɔmpiye ɛlɩɣna pɩ-tɛɛ nɛ pɩkɔɔ pɩtalɩ pɩ-yɔɔ yaa pɩ-tɛɛ nɛ pɩ-yɔɔ.//Pʊtɔbʊʊ se ŋwɛna ñʊʊ mayaɣ kʊyʊmʊ.// >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
func solve(s string) string {
","package solve_test

import (
    ""unicode""
)

func solve(s string) string {
    hasLetter := false
    result := []rune(s)

    for i, char := range result {
        if unicode.IsLetter(char) {
            hasLetter = true
            if unicode.IsUpper(char) {
                result[i] = unicode.ToLower(char)
            } else {
                result[i] = unicode.ToUpper(char)
            }
        }
    }

    if !hasLetter {
        // reverse the string
        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
            result[i], result[j] = result[j], result[i]
        }
    }

    return string(result)
}","func TestSolve(t *testing.T) {
  candidate := solve
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""AsDf""), expected: ""aSdF"" },
     { actual: candidate(""1234""), expected: ""4321"" },
     { actual: candidate(""ab""), expected: ""AB"" },
     { actual: candidate(""#a@C""), expected: ""#A@c"" },
     { actual: candidate(""#AsdfW^45""), expected: ""#aSDFw^45"" },
     { actual: candidate(""#6@2""), expected: ""2@6#"" },
     { actual: candidate(""#$a^D""), expected: ""#$A^d"" },
     { actual: candidate(""#ccc""), expected: ""#CCC"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_163,kbp_Latn,go_test.go,"package generate_integers_test

import (
    ""testing""
    ""fmt""
)

//Kɩɖaʋ nakʋyʋ yɔ: //nɛ b, pɩlɩɣna ɛzɩma pɩpaɣlɩɣ yɔ.//Ye ŋha-ɖʋ ɛtɛyɩŋ naalɛ a nɛ b, ɖitiyele nɛ ɖɩna hɔɔlɩŋ weyi ɩ-taa a nɛ b pɛtɛyɩɣ ɖama yɔ.// >>> generate_integers(2, 8)
// []int{2, 4, 6, 8}
// >>> generate_integers(8, 2)
// []int{2, 4, 6, 8}
// >>> generate_integers(10, 14)
// []int{}
func generate_integers(a int, b int) []int {
","package generate_integers_test

import (
    ""testing""
    ""fmt""
)

func generate_integers(a int, b int) []int {
    start, end := a, b
    if a > b {
        start, end = b, a
    }
    
    result := []int{}
    for i := start; i <= end; i++ {
        if i%2 == 0 {
            result = append(result, i)
        }
    }
    return result
}

func TestGenerateIntegers(t *testing.T) {
    tests := []struct {
        a, b int
        want []int
    }{
        {2, 8, []int{2, 4, 6, 8}},
        {8, 2, []int{2, 4, 6, 8}},
        {10, 14, []int{}},
    }
    
    for _, tt := range tests {
        t.Run(fmt.Sprintf(""generate_integers(%d, %d)"", tt.a, tt.b), func(t *testing.T) {
            got := generate_integers(tt.a, tt.b)
            if len(got) != len(tt.want) {
                t.Errorf(""expected %v, got %v"", tt.want, got)
                return
            }
            for i := range got {
                if got[i] != tt.want[i] {
                    t.Errorf(""expected %v, got %v"", tt.want, got)
                    return
                }
            }
        })
    }
}","func TestGenerate_Integers(t *testing.T) {
  candidate := generate_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },
     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },
     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },
     { actual: candidate(17, 89), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
