[
    {
        "task_id": "HumanEval/0",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་འདི་ནས་གྲངས་ཆ་གང་རུང་གཉིས་གཅིག་གཞན་དང་ཉེ་བར་ཡོད་མེད་ལ་བརྟག་དཔྱད་བྱེད་དགོས། >>> has_close_elements{\\displaystyle \\mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm {mathrm } } }}}}}} (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) དང་། (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདིའི་ནང་འཇུག་ནི་ འབྲེལ་མཐུད་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་སྡེ་ཚན་མང་པོ་ཡོད་པའི་ཐིག་ཁྲམ་ཡིན། ཁྱོད་ཀྱི་དམིགས་ཡུལ་ནི་ སྡེ་ཚན་དེ་དག་སོ་སོར་དབྱེ་ནས་ཐིག་ཁྲམ་སོ་སོར་དབྱེ་ནས་དེའི་བེ་ཊར་ཕྱིར་སློག་བྱ་རྒྱུ་ཡིན། སྡེ་ཚན་སོ་སོར་དབྱེ་ན་ (སྒམ་ཚིགས་སོ་སོར་སྒོ་ཕྱེས་ཡོད་ན་དེ་ཡང་འོས་འཚམས་སུ་སྒོ་ཕྱེས་ཡོད།) 并且彼此之间没有嵌套 输入字符串中的任何空格都忽略. >>> separate_paren_groups (((\"( ) (() (()))))) (std::vector<std::string>({(std::string) \")\", ((((())\", (std::string) \"((()))))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་ལྡོག་པའི་ཐིག་ཁྲམ་གྲངས་ཤིག་ཡིན་ན། དེའི་ཆ་ཤས་ནི་ཧྲིལ་གྲངས་དང་ (གྲངས་ཀ་ཆེ་བས་གྲངས་ཀ་ཉུང་བ་) བཅུ་ཚིགས་ཀྱི་ཆ་ཤས་ (ལྷག་ལུས་ཆ་ཤས་ནི་ 1 ལས་ཆུང་བ་) བཅུ་ཚིགས་ཀྱི་ཆ་ཤས་ཕྱིར་སློག་བྱ་ཐུབ། >>> truncate_number{\\displaystyle {\\frac {{{{3}}}{\\displaystyle {\\frac {3}}}{\\displaystyle {\\frac {3}}}{\\frac {3}}}{\\displaystyle {\\frac {3}}}{\\frac {3}}}{\\frac {3}}}{\\frac {3}}}{\\frac {3}}}{\\frac {3}}}{\\frac {3}}}{3}}}{3}}}{3}}}{3}}}{3}}}{3}}}{4}}}{4}}}{4}}}{4}}}{5}}}{5}}}{5}}}{5}}}{5}}}\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཤོག་ངོས་འདི་ལ་ ཤོག་ངོས་དང་པོ་ནས་ ཤོག་ངོས་དང་པོ་བར་གྱི་ནང་དོན་གཞན་དག་ཡོད་པ་བཞིན་གཤམ་གསལ་ལྟར་བཀོད་ཡོད། ཤོག་ངོས་དང་པོ་ནས་ ཤོག་ངོས་དང་པོ་བར་གྱི་ནང་དོན་གཞན་དག་ཡོད་པ་བཞིན་གཤམ་གསལ་ལྟར་བཀོད་ཡོད།\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་གྲངས་ཀྱི་བེ་ཊར་གང་ཞིག་ལ་གཞི་གྲངས་ཀྱི་བར་ཚད་ཀྱི་མཐའ་འཁོར་ནས་བར་ཚད་ཀྱི་ཚད་གཏན་འབེབས་དགོས། ཚད་ཀྱི་བར་ཚད་ནི་ཆ་རྐྱེན་རེ་རེ་དང་བར་དོའི་བར་གྱི་བར་ཚད་གཏན་འབེབས་ཡིན། MAD = average དང་། x - x_mean དང་། >>> mean_absolute_deviation (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་གི་བེ་ཊར་ནང་འཇུག་གི་རིམ་པ་གཉིས་རེ་རེའི་བར་ལ་གྲངས་ཀྱི་ཚད་མཚམས་ཞིག་བཅུག་དགོས། `numbers' >>> intersperse((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1, (long) 2, (long) 3})), (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདིའི་ནང་འཇུག་ནི་སྐུད་པ་གང་ཞིག་ཡིན་ན་དེའི་ནང་སྦྲེལ་ཡོད་པའི་ parentheses ཀྱི་སྡེ་ཚན་མང་པོ་ཞིག་ཡོད་པའི་ནང་ spaces ཀྱིས་དབྱེ་བའི་ཐོག་ནས་འཇུག་དགོས། ཕྱོགས་རེར་སྡེ་ཚན་རེ་རེའི་ནང་སྦྲེལ་ཡོད་པའི་ parentheses ཀྱི་ཚད་མཐོའི་ཚད་གཞི་དེ་ཕྱིར་འདོན་བྱེད་དགོས། དཔེར་ན། (() (()) ནང་སྦྲེལ་ཚད་མཐོའི་ཚད་གཉིས་ཡོད་ན་ ((())) ནང་སྦྲེལ་ཚད་མཐོའི་ཚད་ནི་གསུམ་ཡོད། >>> parse_nested_parens (((\"(())) ((())) () ((()))))))) (std::vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་གི་ཕྲེང་བ་ཞིག་ནི་ string གྱི་ནང་འཇུག་གི་ཕྲེང་བ་ཞིག་ཡིན་ན་དེའི་ནང་ substring ཡོད་ན་ filter_by_substring (((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_substring ((((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) abc\", (std::string) \"bacd\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་གྲངས་ཚང་གི་གྲངས་ཐང་དང་གྲངས་ཚང་གི་འབྲས་བུ་ལས་གྲུབ་པའི་གྲངས་ཐང་ཡིན། གྲངས་ཐང་སྟོང་པ་ནི་ 0 དང་གྲངས་ཐང་སྟོང་པ་ནི་ 1 ཡིན་པར་ངེས་པ་ཡོད། >>> sum_product (((std::vector<long>())) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple ((10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་གྲངས་ཀྱི་བེ་ཊར་ནས་རིམ་པ་དེའི་ནང་གཏན་འབེབས་དུས་ཚིགས་བར་ཐོབ་པའི་ བེ་ཊར་གྱི་ཚད་མཐོའི་ཆ་ཤས་ཤིག་བསྐྲུན་དགོས། >>> rolling_max ((((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་འདི་ལས་ལྷག་པའི་ཡིག་འབྲུ་ཆུང་བ་ཞིག་འཚོལ་དགོས། ཨལ་གོར་ཊི་མེའི་འཆར་གཞི་ནི་དྭངས་གསལ་ཡིན། - ཚད་གཞི་དེ་ལས་ལྷག་པའི་ཡིག་འབྲུ་རིང་བ་ཞིག་འཚོལ་དགོས། - ཚད་གཞི་དེ་མཇུག་ཏུ་ཁ་ཕྱོགས་ཀྱི་ཡིག་འབྲུ་སྔོན་འཇུག་ཅིག་བཙུགས་དགོས། >>> make_palindrome (((\"\")) (\"\") >>> make_palindrome (((\"cat\")) (\"catac\") >>> make_palindrome (((\"cata\")) (\"catac\")\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་ནི་ string a དང་ b གཉིས་ཡིན་ཏེ། དེ་གཉིས་ནི་ 1 དང་ 0 ཙམ་ལས་གྲུབ་པ་ཡིན། སྦྲེལ་རྟགས་ XOR འདི་དག་ནང་འཇུག་བྱས་རྗེས་ string སྦེ་ཕྱིར་སློག་བྱེད་སྟངས། >>> string_xor((\"010\"), (\"110\")) (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string གྱི་བེ་ཊར་ནས་རིང་ཤོས་དེ་ཕྱིར་སློག་བྱེད་དགོས། ཚད་གཅིག་མཚུངས་ཀྱི་བེ་ཊར་མང་པོ་ཡོད་ན་སྔོན་ཤོས་དེ་ཕྱིར་སློག་བྱེད་དགོས། ཚད་མེད་ཡིན་ན་སླར་ལོག་བྱ་དགོས། >>> longest((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) \"a\" >>> longest((std::vector<std::string>({(std::string) \"a\", (std::string) \"bb\", (stdstring) \"ccc\"}))) \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཆ་ a དང་ b གཉིས་ཀྱི་ཆེ་ཆུང་གི་ཆ་སྙོམས་གྲངས་ཆ་ཤས་ཤིག་ཕྱིར་སློག་བྱ་རྒྱུ་དེ་ >>> greatest_common_divisor (((3), (5)) (1) >>> greatest_common_divisor (((25), (15)) (5)\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་ཐིག་གི་སྔོན་འཇུག་ཆུང་ཤོས་ནས་རིང་ཤོས་བར་གྱི་སྔོན་འཇུག་ཐམས་ཅད་ཀྱི་སྔོན་འཇུག་གི་བེ་ཊར་ཕྱིར་ལོག་བྱེད། >>> all_prefixes (((\"abc\")) (std::vector<std::string> ((({std::string) \"a\", (std::string) \"ab\", (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་ནང་གནས་ཚད་ཀྱི་གྲངས་གྲངས་ 0 ནས་ n བར་གྱི་གྲངས་གྲངས་ཀྱི་གྲངས། >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string ཞིག་ཡོད་ན། དེ་ནང་ཁྱད་ཆོས་ཅན་གྱི་ཡིག་འབྲུ་ག་ཚོད་ཡོད་མེད་འཚོལ་དགོས། (ཁེ་སར་དང་ཁེ་སར་མིན་པར་) >>> count_distinct_characters (((\"xyzXYZ\")) (3) >>> count_distinct_characters ((((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འདིར་ཡིག་གཟུགས་ཤིག་ཡོད། 'o' note, lasts four beats 'o' dak' - half note, lasts two beats 'o' - quater note, lasts one beat >>> parse_music. (o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' o' dak' dak' o dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak' dak\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་འོག་གི་ཐིག་ཁྲམ་ནང་ཐིག་ཁྲམ་ཇི་ཙམ་རྙེད་ཐུབ་པ་འཚོལ་དགོས། གྱངས་ཁ་ལྡོག་པའི་གནད་དོན་གྲངས་རྩིས་དགོས། >>> how_many_times((\"\"), (\"a\")) (0) >>> how_many_times(\"aaa\"), (\"a\")) (3) >>> how_many_times(\"aaaa\"), (\"aa\") (3)\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་ནི་སྟོང་པ་ཉིད་ཀྱིས་ཚད་འཛིན་བྱས་པའི་གྲངས་ཀྱི་ཐིག་ལེ་ཞིག་ཡིན། གྲངས་ཀྱི་ཐིག་ལེ་ནི་ ' ༠' ནས་ ' ༩' བར་ཡིན། འདེམས་ཁོངས་འོས་ལྡན་ནི་ ' ༠', ' ༡', ' ༢', ' ༣', ' ༤', ' ༥', ' ༦', ' ༧', ' ༨' དང་ ' ༩' རྣམས་ཡིན། ཐིག་ལེ་དེ་ཆུང་ཤོས་ནས་ཆེ་བར་རིམ་སྒྲིག་བྱས་ཡོད། >>> sort_numbers (((\"three one five\")) (\" one three five \")\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་མ་གཉིས་ལས་ལྷག་པའི་གྲངས་ཀྱི་བེ་ཊར་ནས་གཉིས་འདེམས་ནས་ཉེར་ཉེར་གཉིས་ཕྱིར་སློག་བྱ་དགོས། དེ་ནས་རིམ་བཞིན་ཕྱིར་སློག་བྱ་དགོས། (གྲངས་ཆུང་བ་དང་གྲངས་ཆེ་བ་) >>> find_closest_elements (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) དང་། (_f) རྣམས་ནས་ཉེར་ཉེར་གཉིས་ཕྱིར་སློག་བྱ་དགོས།\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཀྱི་བེ་ཊར་ (ཉུང་མཐར་ཆ་ཤས་གཉིས་ལས་) ཤིག་ཡོད་ན། བེ་ཊར་དེ་ལ་ཐིག་ལེ་སྒྱུར་བཅོས་བྱེད་དུ་འཇུག་དགོས། དེ་ལྟ་སྟེ། གྲངས་ཆུང་ཤོས་ནི་ 0 དང་། ཆེ་ཤོས་ནི་ 1 ཏུ་འགྱུར་ངེས་སོ།\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་གྱི་ཚད་ལྡན་\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string_length (_\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་གྲངས་ n ཆེད་ n ལས་ཆུང་བའི་གྲངས་ཆེན་ n ལ་ཆ་བགོས་བྱེད་པ། >>> largest_divisor ((((15)) (5)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་གྲངས་ཀྱི་གཞི་གྲངས་ཐོག་མའི་གྲངས་ཀྱི་གྲངས་ཐིག་སླར་ལོག་བྱ་དགོས། ཚད་ལྡན་གྲངས་ནི་གཞི་གྲངས་ཀྱི་གྲངས་ཐིག་ནང་ཇི་ཙམ་ཐེངས་མང་བ་མངོན་པའི་གྲངས་དང་མཚུངས་པའི་གྲངས་ཐིག་ཡིན། ནང་འཇུག་གྲངས་ནི་གཞི་གྲངས་ཚང་མའི་འབྲས་བུ་དང་མཚུངས་པའི་གྲངས་ཐིག་ཡིན།\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཆ་གྲངས་ཀའི་ཐིག་ཁྲམ་ནས་ཐེངས་གཅིག་ལས་མང་བ་བྱུང་བའི་ཆ་ཤས་ཚང་མ་ཕྱིར་འདོན་བྱ་དགོས། སྐར་ཆ་གྲངས་ཀའི་རིམ་པ་སྔོན་གྱི་ནང་བཞིན་བཞག་དགོས། >>> remove_duplicates ((((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string ཆེད་ཡིག་གཟུགས་ཆུང་ཆུང་རྣམས་ཡིག་གཟུགས་ཆེན་པོ་དང་ཡིག་གཟུགས་ཆེན་པོ་ནས་ཡིག་གཟུགས་ཆུང་ཆུང་དུ་བསྒྱུར་བ། >>> flip_case ((((\"Hello\")) (\"hELLO\")\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string གྱི་ལྡེ་མིག་གཅིག་ཏུ་འདུས་ནས་འདུས་པའི་ལྡེ་མིག་ >>> concatenate ((((std::vector<std::string>())) (\"\") >>> concatenate ((((std::vector<std::string>({(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་གི་ཐིག་ཡིག་ལ་གཤམ་གསལ་གྱི་སྔོན་འཇུག་ཐོག་ནས་འགོ་འཛུགས་བྱེད་རྒྱུའི་སྔོན་འཇུག་ལ་བརྟག་དཔྱད་བྱེད་དགོས། >>> filter_by_prefix((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string)::\"cde\", (stdstring) \"array\"})), (\"a\") (std::vector<std::string>({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཕྲེང་བ་ནང་གྲངས་ཆ་རྐྱང་པ་ལོག་འཇུག་བྱེད། >>> get_positive((std::vector<long>({long)-1, (long) 2, (long)-4, (long) 5, (long) 6}))) (std::vector<long>({long) 2, (long) 5, (long) 6})) >>> get_positive((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) 10}))) (std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 3, (long) 9, (long) 123, (long) 1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཤིག་སྔོན་གྲངས་ཡིན་ན་ true སླར་ལོག་བྱེད་དང་གཞན་ན་ false སླར་ལོག་བྱེད་ཡོད། >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1)) (false)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདི་ནི་ vector l དང་ vector l' དེ་འདྲ་མཚུངས་པ་ཞིག་ཕྱིར་ལོག་བྱེད་ཅིང་། l' ནི་ 3 ལ་བགོས་མི་ཐུབ་པའི་རྟགས་གྲངས་ནང་ l དང་མཚུངས་པ་དང་། དེའི་གནས་གོང་ནི་ 3 ལ་བགོས་པའི་རྟགས་གྲངས་ནང་ l གྱི་གནས་གོང་དང་མཚུངས་ཀྱང་། དབྱེ་བ་ཕྱེ་ཡོད།\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་གྱི་དབྱེ་བ་མེད་པའི་ཆ་ཤས་ལོག་འཇུག་བྱེད་པ། >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཕྲེང་བ་ནང་ཕྲེང་བ་མང་ཤོས་ཕྱིར་ལོག་བྱེད་པ། >>> max_element (((std::vector<long>({(long) 1, (long) 2, (long) 3}))) (3) >>> max_element (((std::vector<long>({(long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྱངས་ཁ་ 7 ནི་ 11 དང་ 13 བཅས་ཀྱི་གྲངས་སུ་བགོས་པའི་ n ལས་ཆུང་བའི་ཧྲིལ་གྲངས་སུ་ཐེངས་ཇི་ཙམ་བྱུང་བའི་གྲངས་ཐང་ཕྱིར་ལོག་བྱེད་པ། >>> fizz_buzz(((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདི་ནི་ vector l དང་ vector l' དེ་འདྲ་ཞིག་ཕྱིར་ལོག་བྱེད་དེ་ l' ནི་ l དང་མཚུངས་པ་འདྲ་མཚུངས་ཡིན་པའི་ཆ་ནས་ཉེར་གྱི་གནས་གོང་ནི་ l གི་ཉེར་གྱི་གནས་གོང་དང་མཚུངས་པ་ཡིན་ཀྱང་རིམ་སྒྲིག་བྱས་ཡོད། >>> sort_even: vector<long>{(long) 1, (long) 2, (long) 3}))) (std: vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even: vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std: vector<(long>{(long) 3, (long) 6, (long) 5, (long) 4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib ནི་ཨང་གྲངས་ n-th དེ་ཕི་བོ་ན་ཅིའི་གྲངས་ཀ་ཡིན་པ་དང་དེ་ཡང་ཨང་གྲངས་ prime ཡིན་པ་ཕྱིར་ལོག་བྱེད་ཡོད། >>> prime_fib (༡) (༢) >>> prime_fib (༢) (༣) >>> prime_fib (༣) (༥) >>> prime_fib (༤) (༡༣) >>> prime_fib (༥) (༨༩)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triple_sum_to_zero ནང་འཇུག་ལྟར་གྲངས་ཀྱི་བེ་ཊར་ཞིག་ལེན་ཡོད། གལ་ཏེ་བེ་ཊར་ནང་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་གྲངས་སུ་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་རྩིས་\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་མེད་རིང་བའི་ཕྲེང་བ་ཞིག་ཡིན་པ་བསམ་བློ་བཏང་དགོས། ཕྲེང་བ་ n ཅན་གྱིས་གཡས་གཡོན་ནས་འགྲོ་བ་དང་། ཕྲེང་བ་ n ཅན་གྱིས་གཡས་གཡོན་ནས་འགྲོ་བ་རེད། ཕྲེང་བ་གཉིས་ནི་ཕན་ཚུན་ནས་ཐག་རིང་ནས་འགྲོ་བ་རེད། ཕྲེང་བ་གཉིས་ནི་འདྲ་མཉམ་དུ་འགྲོ་བ་རེད། ཕྲེང་བ་གཉིས་ནི་གཡས་གཡོན་ནས་འགྲོ་བ་ཞིག་གཡས་གཡོན་ནས་འགྲོ་བ་ཞིག་དང་ཐུག་འཕྲད་བྱས་ན་ཕྲེང་བ་གཉིས་བརྡབ་སྐྱོན་བྱུང་ཞེས་བརྗོད་ཀྱི་ཡོད། ཡིན་ན་ཡང་ཕྲེང་བ་གཉིས་ནི་ཚད་མེད་བརྟན་པོ་དང་ཤུགས་ཆེ་རེད། དེའི་རྐྱེན་གྱི་ཕྲེང་བ་གཉིས་མ་བརྡབ་པ་ལྟ་བུར་མུ་མཐུད་དུ་འགྲོ་བ་རེད། ཕྲེང་བ་གཉིས་ནི་ཕྲེང་བ་གཉིས་དང་ཕྲེང་བ་གཉིས་བར་གྱི་ཕྲེང་བ་གཉིས་སུ་བརྡབ་སྐྱོན་བྱུང་བའི་གྲངས་འབོར་རྩིས་ཀྱི་ཡོད།\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་དང་ཆ་ཤས་ལ་ 1 ཀྱིས་ཡར་སེང་བྱས་པའི་ལོག་ཕྱོགས་ཞེང་། >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>({long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>({long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero ནང་འཇུག་ལྟར་གྲངས་ཚང་གི་ཕྲེང་བ་ཞིག་ལེན་ཡོད། གལ་ཏེ་ཕྲེང་བ་དེའི་ནང་ཕྲེང་བ་གཉིས་ཡོད་ན་ཕྲེང་བ་དེའི་ནང་ཕྲེང་བ་ནི་ 0 དང་། གལ་ཏེ་ཕྲེང་བ་གཞན་ན་ཕྲེང་བ་ནི་ false ཡིན་ན་ཕྲེང་བ་ true སླར་ལོག་བྱེད། >>> pairs_sum_to_zero (long) དང་། འོག་ངོས།: vector<long> (long) 1, (long) 3, (long) 5, (long) 0)) (false) >>> pairs_sum_to_zero (long) དང་། འོག་ངོས།: vector<long> (long) 1, (long) 3, (long) 2, (long) 1 >>> (false) pairs_sum_to_zero (long)\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ནང་འཇུག་གྲངས་ x གི་གྲངས་གཞི་གཞི་བསྒྱུར་བྱེད། བསྒྱུར་བཅོས་བྱས་རྗེས་ string ངོ་ཚབ་ཕྱིར་སློག་བྱེད། གཞི་གྲངས་ནི་ 10 ལས་ཉུང་བ་ཡིན། >>> change_base((8), (3)) (\"22\") >>> change_base(8), (2)) (\"1000\") >>> change_base((7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གཡོན་པའི་རིང་ཚད་དང་མཐོ་ཚད་ཀྱི་ས་ཆ་དེ་གསུམ་ཟུར་གྱི་ཆེད་དུ་སྤྲོད་པ། >>> triangle_area (7.5f)\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Fib4གྲངས་རིམ་ནི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན་ཏེ། fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4གྲངས་རིམ་གྱི་ n-th ཅན་གྱི་ཆ་ཤས་ལ་ཕན་པའི་ཆེད་ལས་འགན་ཞིག་བཀོད་རོགས། སླར་ལོག་མི་གཏོང་། >>> fib4((5)) (4) >>> fib4(6)) (8) >>> fib4(7)) (14)\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་ནང་ཡོད་ཆ་ཤས་ཀྱི་བར་མཚམས་སླར་ལོག་བྱེད། l. >>> སྐར་ཁུང་ནང་ཡོད་ཆ་ཤས་ཀྱི་བར་མཚམས་ ((((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (float(3)) >>> སྐར་ཁུང་ནང་ཡོད་ཆ་ཤས་ཀྱི་བར་མཚམས་ (((std::vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་འཛིན་བྱེད་སྟངས་ནི་ཁ་ཕྱོགས་ཀྱི་རྟགས་མཚན་ཞིག་ཡིན་ན་བརྟག་དཔྱད་བྱེད་སྟངས་ནི་ >>> is_palindrome (((\"\")) (true) >>> is_palindrome (((\"aba\")) (true) >>> is_palindrome (((\"aaaaa\")) (true) >>> is_palindrome (((\"zbcd\")) (false)\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics) >>> modp((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101)) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels ནི་ string དང་ vowels མེད་པའི་ string སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་ཡིན། >>> remove_vowels (((\"\")) (\"\") >>> remove_vowels (((\"abcdef\")) (\"bcdf\") >>> remove_vowels (((\"aaaaa\")) (\"\") >>> remove_vowels (((\"aaBAA\")) (\"B\") >>> remove_vowels (((\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཕྲེང་བ་ནང་གྲངས་ཚང་མ་ཐིག་ཚད་tལས་དམའ་ན་ true སླར་ལོག་བྱེད། >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ x དང་ y གཉིས་བསྡུར་ནས་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་་\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚིག་གཉིས་ནང་ཡིག་འབྲུ་འདྲ་མཚུངས་ཡོད་མེད་ལ་བརྟག་དཔྱད་བྱེད། >>> same_chars (((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) (true) >>> same_chars (((\"abcd\"), (\"dddddddabc\")) (true) >>> same_chars (((\"dddddddabc\"), (\"abcd\")) (true) >>> same_chars (((\"eabcd\"), (\"dddddddabc\")) (false) same_chars >>> (((\"abcd\"), (\"dddddddddabce\") (false) >>> same_chars (((\"eabcd\"), (\"ddddzzzzzdzzdddabc\")) (false)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཕི་བོ་ན་ཅིའི་གྲངས་ཀ་ n-th སླར་ལོག་བྱེད། >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets ནི་ \"<\" དང་ \">\" ཀྱི་ཡིག་འབྲུ་ཡིན། གལ་ཏེ་ཁ་ཕྱེས་པའི་ bracket ནང་འཇུག་པའི་ bracket ཡོད་ན་ true སླར་ལོག་བྱེད། >>> correct_bracketing (((\"<\")) (false) >>> correct_bracketing (((\"<>\")) (true) >>> correct_bracketing (((\"<>>>\")) (true) >>> correct_bracketing (((\">(<>\")) (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing. >>> monotonic (monotonic) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) དང་། (long) (long) དང་། (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཕྱོགས་སྟོན་གཉིས་ཀྱི་ཆེད་དུ་དབྱེ་བ་ཕྱེ་བའི་གཅིག་མཚུངས་གྱི་མཐུན་རྐྱེན་ལོག་འཇུག་བྱེད། >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// n གི་གྲངས་ཐང་ཆེ་ཆུང་གི་གཞི་གྲངས་ཕྱིར་ལོག་བྱེད་པ། n > 1 དང་དེ་གྲངས་ཐང་ཆེ་ཆུང་མིན་པར་བསམ་པ། >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n ནི་ 1 ནས་ n བར་གྱི་གྲངས་ཐང་རྩིས་པའི་ལས་འགན་ཞིག་ཡིན། >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets ནི་ \"(\" དང་ \"\") གི་ཡིག་འབྲུ་ཞིག་ཡིན། གལ་ཏེ་ཁ་ཕྱེས་པའི་ bracket ནང་འཇུག་པའི་ bracket ཡོད་ན་ true སླར་ལོག་བྱེད། >>> correct_bracketing (((\"(\")) (false) >>> correct_bracketing (((\"())) (true) >>> correct_bracketing (((\"(()))) (true) >>> correct_bracketing (((\") ((()) (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs ནི་མང་གྲངས་ཀྱི་འབྲས་བུ་ཡིན། xs[0] + xs[1] * x + xs[2] * x^2 + .... ཚད་གཞི་འདི་ཡི་གཞི་རྟེན་དེ་འདྲ་མཚུངས་སུ་ཕྱིར་ལོག་བྱེད། >>> derivative((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> derivative::std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// FibFibགྲངས་རིམ་ནི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན་ཏེ། fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) ཐབས་ལམ་འདི་བཞིན་ཨང་གྲངས་རིམ་པའི་ n-th ཅན་གྱི་ཆ་ཤས་ལ་རྩིས་རྒྱག་བྱེད་རྒྱུའི་ལས་འགན་ཞིག་བཀོད་རོགས། >>> fibfib(1)) (0) >>> fib((5)) (4) >>> fib(8)) (24)\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲི་ཐབས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས། ཤོག་གྲངས་ནང་ཚིག་ཡིག་གང་ཞིག་ཡོད་པའི་གྲངས་ཀ་དེ་ཕྱིར་སློག་བྱེད་སྟངས།\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འཁོར་བའི་གྲངས་ཐང་ x གི་ཨང་གྲངས་རྣམས་ཕྱོགས་བསྒྱུར་ནས་གཡས་སུ་ཕྱོགས་སྒྱུར་གྱིས་འབྲས་བུ་ནི་ string སྦེ་ཕྱིར་ལོག་བྱེད། གལ་ཏེ་ shift > ཨང་གྲངས་གྲངས་ཐང་ཡིན་ན་ཨང་གྲངས་འཁོར་བ་ཕྱིར་ལོག་བྱེད། >>> circular_shift (((12), (1)) (\"21\") >>> circular_shift (((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདི་ནི་ཡིག་འབྲུ་ཞིག་ནང་འཇུག་བྱེད་ནས་ ASCII ཡིག་རྟགས་སྟེང་གི་གྲངས་ཀ་གཅིག་པུ་ཕྱིར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་འབྲི་དགོས། དཔེ་གཞི་འདི་ནི་: >>> digitSum (((\"\")) (0) >>> digitSum (((\"abAB\")) (131) >>> digitSum (((\"abcCd\")) (67) >>> digitSum (((\"helloE\")) (69) >>> digitSum (((\"woArBld\")) (131) >>> digitSum (((\"aAXaaaa\")) (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདིའི་ནང་ཁྱོད་ཚོར་ འབྲས་བུ་ཡོད་པའི་སླེ་བོར་ཁ་བ་དང་ཁམ་བུ་སོགས་ཀྱི་གྲངས་ཆ་མཚོན་བྱེད་པའི་ཡིག་འབྲུ་ཞིག་གནང་ཡོད། འབྲས་བུ་ཡོད་པའི་སླེ་བོར་ཁ་བ་དང་ཁམ་བུ་དང་ཁམ་བུ་བཅས་ཀྱི་གྲངས་ཆ་མཚོན་བྱེད་པའི་ཡིག་འབྲུ་དེ་དང་སླེ་བོར་ནང་ཡོད་པའི་འབྲས་བུ་ཚང་མའི་གྲངས་ཆ་མཚོན་བྱེད་པའི་གྲངས་ཆ་གང་རུང་དེ་ཕྱིར་སློག་བྱེད། དཔེར་ན།: >>> fruit_distribution (((((\"ཁ་བ་ ༦ དང་ཁམ་བུ་ ༦\") ཞེས་པ་ལྟ་བུ། (19)) (8) >>> fruit_distribution ((((\"ཁ་བ་ ༠ དང་ཁམ་བུ་ ༡\") ཞེས་པ་ལྟ་བུ། (3)) (2) >>> fruit_distribution (((((\"ཁ་བ་ ༢ དང་ཁམ་བུ་ ༣\") ཞེས་པ་ལྟ་བུ། (100)) (95) >>> fruit_distribution (((\"ཁ་བ་ ༡༠༠ དང་ཁམ་བུ་ ༡\") ཞེས་པ་ལྟ་བུ། (120)) (19)\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་ཆུང་ཤོས་ཡོད་པའི་ཚད་གཞི་དེ་སླར་ལོག་བྱེད་དགོས། ཚད་གཞི་ཆུང་ཤོས་ཡོད་པའི་ཚད་གཞི་དེ་སླར་ལོག་བྱེད་དགོས། ཚད་གཞི་ཆུང་ཤོས་ཡོད་པའི་ཚད་གཞི་དེ་སླར་ལོག་བྱེད་དགོས། ཚད་གཞི་ཆུང་ཤོས་ཡོད་པའི་ཚད་གཞི་དེ་སླར་ལོག་བྱེད་དགོས། ཚད་གཞི་ཆུང་ཤོས་ཡོད་པའི་ཚད་གཞི་དེ་སླར་ལོག་བྱེད་དགོས། དཔེར་ན་ ༡: >>> pluck((stdvector<<(long>{(long) 4, (long) 2, (long) 3}))) (stdvector::<(long>{(long) 2, (long) 1})) འགྲེལ་བཤད་ནི། ༢: ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ་དང་ ༢: ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། དཔེར་ན་ ༢: >>> pluck (((stdvector::<(long>{(long>) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། དཔེར་ན་ ༣: (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡིན་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡོད་པ། (long) ཆུང་ཤོས་ཡིན་པ། (long) ཚད་གཞི་ཆུང་ཤོས་ཡིན་པ། (long) ཆུང་ཤོས་ཡིན་པ། (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) ཆུང་ཤོས་ཡིན་ (long) (long) (long) (long) (long) (long) (long) (long) (long\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ལ་ཆ་སྙོམས་གྲངས་ཀྱི་སྟོང་པ་མིན་པའི་བེ་ཊར་ཞིག་སྤྲད་ཡོད། གྲངས་ཆ་ཆ་ཚང་ལས་མང་བ་ 0 དང་། དེའི་མང་ཚད་ནི་གྲངས་ཆ་ཆ་ཚང་གི་ཐང་དང་མཚུངས་པའམ་དེ་ལས་མང་བ་ཡིན། གྲངས་ཆ་ཆ་ཚང་གི་མང་ཚད་ནི་གྲངས་ཆ་དེའི་ནང་ཇི་ཙམ་མངོན་པའི་གྲངས་ཀ་ཡིན། གལ་ཏེ་དེ་ལྟ་བུའི་ཐང་མེད་ན་ - 1 སླར་ལོག་བྱེད་དགོས། དཔེ་གཞི་: >>> search:{((std::vector<long>{(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search:{(std::vector<(long>1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>> >>> search:{(std::vector<(long>5, (long) 5, (long) 5, (long) 4, (long) 4, (long) 4} (long-1))\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་དྲ་བའི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་ཁུང་གི་ནང་། སྐར་མ་\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གཡོན་གསུམ་གྱི་རིང་ཚད་ལ་གཞི་ནས་མཚོན་ན། གཡོན་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཡིན། ཕྱོགས་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་གྱི་ཟུར་གཉིས་སུ་བསྡུ་བའི་རྗེས་སུ། ཕྱོགས་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་གྱི་ཟུར་གཉིས་སུ་བསྡུ་བའི་རྗེས་སུ། དེ་མིན་ཕྱོགས་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་ལས་ཆེ་བ་ཡིན་ན་ཟུར་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་ཡིན། དཔེ་གཞི་: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་དངོས་ཡོད་ q ཀྱིས་འཕུར་ཐུབ་པ་ཡིན་ན་ true སླར་ལོག་བྱ་རྒྱུའི་ལས་འགན་ཞིག་བྲིས་ནས་གཞན་ན་ false སླར་ལོག་བྱ་དགོས། དངོས་པོ་ q གྱིས་འཕུར་ཐུབ་པ་ཡིན་ན་ true སླར་ལོག་བྱ་རྒྱུ་ཡིན། དངོས་པོ་ q གྱིས་འཕུར་ཐུབ་པ་ཡིན་ན་ (དེ་ནི་ཚད་ལྡན་བེ་ཊར་ཞིག་ཡིན་) དེའི་ཆ་ཤས་ཀྱི་བསྡོམས་ནི་ནུས་ལྡན་ཚད་ལྡན་ཚད་ལྡན་ལས་ཆུང་བ་ཡང་ན་མཚུངས་པ་ཡིན། དཔེ་གཞི་: >>> will_it_fly (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_ (_) (_) (_) (_) (_) (_ (_) (_) (_) (_) (_ (_) (_) (_) (_) (_) (_ (_) (_) (_) (_) (_ (_) (_) (_) (_) (_ (_) (_) (_) (_) (_) (_) (_) (_) (_) (_ (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་སྐར་ཆ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་ཡིན། སྐར་ཆ་གྲངས་ཐང་ནི་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་གི་མཐའ་གྲངས་ཐང་ཡིན།\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲི་རྩོལ་ངོས་ལེན་བྱེད་ཐིག་ཡིག་གི་ཐིག་ཡིག་གཉིས་དང་ཐིག་ཡིག་གཞན་ལས་ཉུང་བའི་ཐིག་ཡིག་ཚང་གྲངས་ཡོད་མཁན་ཐིག་ཡིག་ཕྱིར་ལོག་བྱེད་པ། གལ་ཏེ་ཐིག་ཡིག་གཉིས་ཐིག་ཡིག་འདྲ་མཚུངས་ཡོད་ན་ཐིག་ཡིག་དང་པོ་ཕྱིར་ལོག་བྱེད་པ། དཔེ་གཞི་ >>> total_match (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_) vector (_ (_) vector (_) vector (_) vector (_) (_ (_) vector (_) (_) (_) (_) (_) (_) (_ (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_) (_\"\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཀ་འདི་ནི་གྲངས་ཀ་གསུམ་གྱི་འབྲས་བུ་ཡིན་ན་ true སླར་ལོག་བྱེད་པ་དང་གཞན་ན་ false སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་འབྲི་དགོས། (a) ནི་ 100 ལས་ཆུང་བ་ཡིན་པར་ཤེས་པ་དགོས། དཔེ་གཞི་: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཀྱི་ལས་འགན་ནི་གྲངས་ x ནི་ n གི་ནུས་པ་གཅིག་ཡིན་ན་ true དང་གཞན་ན་ false སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་རྒྱུ་ཡིན། x ནི་ n གི་ནུས་པ་གཅིག་ཡིན་ན་ n**int=x དཔེར་ན་: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཆ་ཧྲིལ་པོ་ a དང་གནས་གོང་དངོས་ཡོད་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་དགོས། ལྟོས་དང་། ནང་འཇུག་གཏན་ནས་བདེན་པ་ཡིན་པར་ངེས་པ་ཡོད། དཔེ་གཞི་འདི་ལྟ་སྟེ། >>> iscube (((1)) (true) >>> iscube (((2)) (false) >>> iscube (((-1)) (true) >>> iscube (((64)) (true) >>> iscube (((0)) (true) >>> iscube (((180)) (false)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ཧེ་ཁེ་ཌེ་སི་མལ་གྲངས་ཤིག་རྩིས་གཞི་ལྟར་ལེན་པའི་ལས་འགན་ཞིག་འབྲི་དགོས་པའི་འགན་འཁུར་སྤྲད་ཡོད་ཅིང་། དེ་ནི་ཧེ་ཁེ་ཌེ་སི་མལ་ཨང་གྲངས་ནི་སྔོན་གྲངས་ཡིན་པའི་གྲངས་གྲངས་གྲངས་རྩིས་ཀྱི་ལས་འགན་ཡིན། (སྔོན་གྲངས་ནི་ 1 ལས་ལྷག་པའི་རང་བྱུང་གྲངས་གྲངས་ཤིག་ཡིན་པ་དང་དེ་གཉིས་ལས་ཆུང་བའི་རང་བྱུང་གྲངས་ཀྱི་འབྲས་བུ་མིན་པ་ཡིན།) ཧེ་ཁེ་ཌེ་སི་མལ་ཨང་གྲངས་ནི་ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ཡིན། སྔོན་གྲངས་ནི་ 2, 3, 5, 7, 11, 13, 17... ཡིན་པས། ཁྱོད་ཚོར་གཤམ་གསལ་ཨང་གྲངས་ཀྱི་གྲངས་གྲངས་ངེས་དགོས་པ་ཡིན། ༢, ༣, ༥, ༧, ༧, B (=ཨང་གྲངས་བཅུ་པའི་གྲངས་ 11), D (=ཨང་གྲངས་བཅུ་པའི་གྲངས་ 13) དྲན་གསོ།: ཁྱོད་ཚོར་གཏན་ནས་ནང་འཇུག་ནི་བདེན་པའམ་སྟོང་པ་རེད་བསམ་སྲིད་ཅིང་། རྟགས་རྟགས་ A,B,C,D,E,F འདི་ཚོ་གཏན་ནས་ཡིག་འབྲུ་ཆེ་ཆུང་ཡིན་པར་ངེས་སོ། དཔེ་གཞི་: >>> hex_((AB\"key\") (1) >>> hex_((10\"E77\") (2) >>> hex_(AB\"1\") >>>ABC\" (4) hex_33\") >>>((ABC\" (6\") >>>033\") >>>ABC\" (67) >>>67\" (<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ཨང་གྲངས་བཅུ་གྲངས་ཀྱི་རྣམ་པ་ཐོབ་པ་དང་ཁྱོད་ཀྱི་ལས་འགན་ནི་དེ་གཉིས་ལྡན་གྱི་རྣམ་པ་དུ་བསྒྱུར་བ་ཡིན། ལས་འགན་གྱིས་ཡིག་འབྲུ་རེ་རེ་བཞིན་གཉིས་ལྡན་གྱི་གྲངས་མཚོན་བྱེད་པའི་ཐག་པ་ཕྱིར་ལོག་བྱེད་དགོས། ཐག་པའི་ཡིག་འབྲུ་རེ་རེ་ནི་ '0' ཡང་ན་ '1' ཡིན། ཐག་པའི་འགོ་དང་མཇུག་ཏུ་ཡིག་འབྲུ་གཉིས་པོ་ 'db' ཡིན། ཤོག་གྲངས་ཀྱི་རྣམ་པ་སྒྲིག་རྒྱུར་རོགས་བྱེད་ཆེད་ཡིག་འབྲུ་ལྷག་པ་ཡོད། དཔེ་གཞི་: >>> decimal_to_binary (((15)) (\"db1111db\") >>> decimal_to_binary (((32)) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ string s ཞིག་སྤྲད་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ string ནི་ hapcpp ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱེད་རྒྱུ་ཡིན། string ནི་ hapcpp ཡིན་ན་དེའི་རིང་ཚད་ནི་ཉུང་ཤོས་ 3 ཡིན། ཡང་ 3 ཡི་གེ་རེ་རེ་ནི་སོ་སོར་ཡིན་ན་ཡིན། དཔེར་ན་: >>> is_happy (((\"a\")) (false) >>> is_happy (((\"aa\")) (false) >>> is_happy (((\"abcd\")) (true) >>> is_happy (((\"aabb\")) (false) >>> is_happy (((\"adb\")) (true) >>> is_happy (((\"xyy\")) (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྟོན་པའི་སློབ་དུས་ཀྱི་བདུན་ཕྲག་མཇུག་གི་སྐབས་སློབ་དཔོན་གྱིས་སློབ་ཕྲུག་རྣམས་ལ་རྟགས་རག་སྤྲོད་དགོས་ཀྱི་ཡོད། སློབ་དཔོན་གྱིས་རྟགས་རག་སྤྲོད་པའི་ཆེད་རང་རང་གི་ཨལ་གོར་ཊི་མིར་བཟོས་ཡོད། སྐྱོན་ནི་ཁོང་གིས་རྟགས་རག་སྤྲོད་པའི་ཆེད་ལག་ལེན་འཐབ་པའི་ཡིག་གཟུགས་བརྗེད་སོང་བ་རེད། ཁོང་གིས་སློབ་ཕྲུག་འགའ་ཞིག་གི་ GPAs གྱི་བེ་ཊར་སྤྲད་ཡོད་པ་དང་ཁྱེད་རང་ཚོས་གཤམ་གསལ་ཐིག་ཁྲམ་ལ་ཡི་གེ་རྟགས་རག་སྤྲོད་པའི་བེ་ཊར་བཀོད་ཐུབ་པའི་ལས་འགན་ཞིག་འབྲི་དགོས་ཀྱི་འདུག GPA གྱི་ཡི་གེ་རྟགས་རག་ 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E དཔེ་གཞི་: >>>_grade equation: (((std::vector<float>{(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f)) (d\"d\" (d\" vector::std::std::string::std\" (d\"d\"):string::d\"d\"A+ (d\"string:d\"A\" (C) \" (string) (C) \")) (string) (C) (string) (string)\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཡིག་འབྲུ་ཞིག་ལེན་ནས་ string ཡི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན་ན་ true ཡང་ན་ false སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་དགོས། དཔེ་གཞི་ >>> prime_length (((\"Hello\")) (true) >>> prime_length (((\"abcdcba\")) (true) >>> prime_length (((\"kittens\")) (true) >>> prime_length (((\"orange\")) (false)\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ལྡན་གྲངས་ n ཡོད་པ་ལ། 1 ཐོག་འམ་མཐའ་མཇུག་གི་གྲངས་ལྡན་གྲངས་ n ཡི་གྲངས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་གྲངས་ཆ་མཉམ་ N ཞིག་ཡོད་ན། དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་གྲངས་ནི་གཉིས་ལྡན་གྲངས་སུ་ཕྱིར་ལོག་བྱེད་པ། དཔེ་གཞི་ >>> solve((1000)) (\"1\") >>> solve((150)) (\"110\") >>> solve((147)) (\"1100\") འགྱུར་བ་: @N integer Constraints: 0 ≤ N ≤ 10000. ཐོན་སྐྱེད་: གཉིས་ལྡན་གྲངས་ཀྱི་ཐིག་ཁྲམ་\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཆ་གྲངས་མེད་ཀྱི་སྐར་ཆ་གྲངས་མེད་ཡོད་ན། lst. སྐར་ཆ་གྲངས་མེད་ཀྱི་སྐར་ཆ་གྲངས་མེད་རྣམས་རྩིས་རྒྱག་དགོས། དཔེ་གཞི་: >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཡིག་འབྲུ་ཞིག་ལེན་ནས་དེའི་རིམ་སྒྲིག་ཅན་གྱི་རྣམ་པ་ཕྱིར་སློག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་དགོས། བཀའ་སྒྲིག་ཅན་གྱི་རྣམ་པ་ནི་ཡིག་འབྲུ་གང་རུང་ (བར་སྟོང་གིས་དབྱེ་) རྣམས་ཚིག་གསར་པ་ཞིག་གིས་ཚབ་ཏུ་འཇོག་པའི་ཡིག་འབྲུ་ཡིན། འདི་ལ་ཡིག་འབྲུ་ཚང་མ་རིམ་བཞིན་ཡར་འཕུར་དུ་སྒྲིག་གཞི་ ascii གྱི་ཐང་གི་གཞི་རྟེན་དུ་བཞག་ཡོད། དྲན་གསོ། ཁྱོད་ཀྱིས་ཚིག་ཡིག་དང་སྟོང་པའི་གོ་རིམ་དེ་འཇུག་འཇུག་དགོས། དཔེར་ན་: >>> anti_shuffle (((\"Hi\")) (\"Hi\") >>> anti_shuffle (((\"hello\")) (\"ehllo\") >>> anti_shuffle (((\"Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་གཉིས་ལྡན་གྱི་ཡིག་ཆ་ཞིག་ནི་ སྦྲེལ་ཡོད་པའི་ ཝི་ཅཊ་ (vectors) གྱི་རྣམ་པ་ལྟ་བུ་ཡིན་ཏེ། ཕྲ་རིང་དང་མ་འདྲ་བར་ ཐིག་ཁྲམ་ལ་གྲལ་རིམ་རེ་རེར་ཀ་བའི་གྲངས་ཁྱད་པར་ཅན་ཞིག་ཡོད་སྲིད་དོ། ཕྲ་རིང་ (lst) དང་ཧྲིལ་གྲངས་ (x) ཡོད་པའི་ ཝི་ཅཊ་ (vector) ནང་ཧྲིལ་གྲངས་ (x) འཚོལ་དགོས། ཝི་ཅཊ་ (vector) ནང་གི་ ཝི་ཅཊ་ (vector) སླར་ལོག་བྱ་བའི་ ཝི་ཅཊ་ (vector) རྣམས་ནི་ [(x1, y1), (x2, y2) ...] འདྲ་མཚུངས་ཡིན་ཏེ། ཐིག་ཁྲམ་རེ་རེར་ ཕྱོགས་སྒྲིག་ - (row, columns) ཡོད་པ་ནི་ 0 ཡིན། ཐོག་མར་གྲལ་རིམ་ཡར་རྒྱས་པའི་ཐོག་ནས་ཕྱོགས་སྒྲིག་སྒྲིག་སྒྲིག་སྒྲིག་དགོས། ཡང་གྲལ་རིམ་གྱི་ཕྱོགས་སྒྲིག་རྣམས་རིམ་བཞིན་མར་འབབ་པའི་ཐོག་སྒྲིག་དགོས། དཔེ་གཞི་: >>> get_row(std::vector<std::vector><d1, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long)\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་ལྡན་གྱི་གྲངས་ཆ་མེད་མེད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// function encrypt ཞིག་བཟོས་ནས་ཡིག་འབྲུ་ཞིག་རྟགས་སུ་ལེན་ནས་ཡིག་འབྲུ་ཞིག་ཨང་རྟགས་ཀྱི་ཚུལ་དུ་ཕྱིར་སློག་བྱ་དགོས། ཨང་ཡིག་དེ་ཨང་རྟགས་ཀྱི་རིམ་པ་གཉིས་སུ་སྤོ་བ་བྱ་དགོས་པ་ཡིན། དཔེར་ན།: >>> encrypt (((\"hi\")) (\"lm\") >>> encrypt (((\"asdfghjkl\")) (\"ewhjklnop\") >>> encrypt (((\"gf\")) (\"kj\") >>> encrypt (((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ལ་གྲངས་ཆ་དག་གི་བེ་ཊར་ཞིག་སྤྲད་ཡོད། འབྲི་རྩོལ་ next_smallest ((() འདི་བེ་ཊར་གྱི་ཆ་ཤས་ཆུང་ཤོས་གཉིས་པ་ཕྱིར་སློག་བྱེད། དེ་མིན་ཆ་ཤས་དེ་མེད་ན་ None སླར་ལོག་བྱེད། >>> next_smallest (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest (((std::vector<long>(long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest (((std::vector<long>())) std::nullopt >>> next_smallest (((stdvector<long>{(long) 1, (long) 1))) std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ཚིག་ཡིག་གི་རིམ་པ་ཞིག་སྤྲོད་རྒྱུ་དང་ཁྱོད་ཀྱི་ལས་འགན་ནི་དགུན་གྱི་གྲངས་རྩིས་བྱེད་རྒྱུ་ཡིན། དགུན་ནི་ཚིག་ཡིག་ \"I\" གྱིས་འགོ་འཛུགས་པ་ཞིག་ཡིན། ཚིག་ཡིག་ལ་ \"I\" དང་ \"?\" དང་ \"! \" ཀྱི་བར་མཚམས་འཇོག་བྱེད་ཡོད། དཔེར་ན། >>> is_bored (དགུན་གྱི་) ((\"Hello world\")) (0) >>> is_bored ((\"གནམ་ནི་སྔོན་པོ་རེད། ཉི་མ་ཤར་འདུག། ངས་གནམ་གཤིས་འདི་ལ་དགའ་བསུ་ཡོད།\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ ༣ ཡོད་པའི་ལས་འགན་ཞིག་བཟོས་དགོས། གྲངས་གཅིག་ནི་གཞན་གཉིས་གྱི་བསྡོམས་དང་མཚུངས་པ་ཡིན་ན་ true སླར་ལོག་བྱེད། གྲངས་གཞན་གང་རུང་ལ་ false སླར་ལོག་བྱེད། དཔེ་གཞི་འདི་རྣམས་ནི། >>> any_int (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float)) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float)) (float) (float) (float) (float)) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float (float) (float) (float (float) (float) (float (float) (float (float)) (float) (float (float) (float (float)) (float) (float (float) (float (flo) (flo) (float (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo)\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཡིག་རྟགས་གང་རུང་ཞིག་ལེན་ནས་ཡིག་རྟགས་ཚང་མ་བརྗེ་སྒྱུར་བྱེད་ནས་ཡིག་རྟགས་ནང་གི་སྒྲ་རིགས་ཚང་མ་དབྱིན་ཡིག་གི་ཡིག་རྟགས་དེའི་སྔོན་ལ་གནས་གཉིས་ཡོད་པའི་ཡིག་རྟགས་ཀྱིས་བརྗེ་སྒྱུར་བྱེད་ནས་ཡིག་རྟགས་ཤིག་བཀོད་དགོས། དཔེ་གཞི་: >>> encode (((\"test\")) (\"TGST\") >>> encode (((\"This is a message\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ལ་གྲངས་ཆ་དག་པའི་བེ་ཊར་ཞིག་སྤྲད་ཡོད། ཁྱོད་ཀྱིས་གྲངས་ཆ་མང་ཤོས་ཀྱི་སྔོན་གྲངས་འཚོལ་བ་དང་དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་ཕྱིར་ལོག་བྱ་དགོས། དཔེ་གཞི་: >>> skjkasdkdd((std::vector<long>((long) ༠, (long) ༣, (long) ༢, (long) ༡, (long) ༣, (long) ༤, (long) ༥, (long) ༦, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨, (long) ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨ ༨\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་འདི་ནི་གཞི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་གཞི་ནི་གཞི་གཞི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ནི་གཞི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ནི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ནི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ནི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ནི་གཞི་ཡིན། ཚད་གཞི་ནི་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་ ཚད་གཞི་\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཤོག་གྲངས་དང་པོ་ n ཡི་སྔོན་གྲངས་དང་ n ལས་ཆུང་བའི་གྲངས་ཀྱི་བེ་ཊར་ཞིག་ཕྱིར་སློག་བྱ་བའི་ལས་འགན་ཞིག་ལག་ལེན་དུ་འཇུག་པ། དཔེར་ན།: >>> count_up_to((5)) (std::vector<long>({long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>({long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 13, (long) 17, (long) 19} >>> count_up_1) (std::vector<long> >>> count_up_to_8) (std:vector<long> (long) 3, (long) 11, (long) 5, (long) 17, (long) 11, (long) 2, (long) 1\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་གྲངས་ཆ་གཉིས་དང་དེའི་ཆ་ཤས་ཀྱི་འབྲས་བུ་ཡིན། དཔེར་ན་: >>> multiply (((148), (412)) (16) >>> multiply (((19), (28)) (72) >>> multiply (((2020), (1851)) (0) >>> multiply (((14), (-15)) (20)\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string s ཤིག་ཡོད་ན། ཚད་ལྡན་ཡིག་འབྲུ་ནང་ཡིག་འབྲུ་ཆེན་པོའི་སྒྲ་གྲངས་རྩིས་དགོས། དཔེར་ན།: >>> count_upper (((\"aBCdEf\")) (1) >>> count_upper (((\"abcdefg\")) (0) >>> count_upper (((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་གྲངས་ཐང་ (string) ཞིག་ (string) ཞིག་ (string) ཞིག་ (string) ཞིག་ (string)\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་གྲངས་ཆ་མཉམ་ n ཞིག་ཡོད་ན། ཁྱོད་ཚོར་རྡོའི་ཚད་ n ཡི་རྡོ་བྲིས་དགོས། ཐོག་མའི་ཚད་ལ་རྡོའི་ཚད་ n ཡོད། ཤུལ་མའི་ཚད་ལ་རྡོའི་གྲངས་ནི་: - རྗེས་མའི་གྲངས་ཆ་མི་མཚུངས་པ་ n ཡན་ན་ཡིན་ན་ - རྗེས་མའི་གྲངས་ཆ་ཆ་མཚུངས་པ་ n ཡན་ཡིན་ན་ཡིན། ཚད་རེ་རེའི་རྡོའི་གྲངས་ནི་བེ་ཊར་ནང་ཕྱིར་ལོག་བྱེད་ཅིང་། དེར་གཞི་གྲངས་ i ཡི་ནང་ཡོད་པའི་ཆ་ཤས་ནི་ཚད་ (i+1) ནང་རྡོའི་གྲངས་ཐང་ཡིན། དཔེ་གཞི་: >>> make_a_pile((3)) (std::vector<long>{long) 3, (long) 5, (long) 7}))\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་དབྱེ་རྟོག་དང་བར་སྟོང་གིས་དབྱེ་བའི་ཚིག་ཡིག་ཐིག་ཞིག་ཐོབ་ཡོང་། ཁྱོད་ཚོར་བྱ་བའི་ལས་འགན་ནི་ཐིག་དེ་ཚིག་ལ་དབྱེ་ནས་ཚིག་གི་ཕྲེང་བ་ཞིག་ཕྱིར་སློག་བྱ་རྒྱུ་ཡིན། དཔེར་ན།: >>> words_string (རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།:རིགས།\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་འདི་ནི་གྲངས་ཆ་ལྡོག་གཉིས་ x དང་ y དང་གྲངས་ཆ་ལྡོག་གཉིས་ x དང་ y ནང་ཡོད་པའི་གྲངས་ཆ་ལྡོག་གྲངས་ཆ་ཤས་ཆེ་ཤོས་ཕྱིར་ལོག་བྱེད་པ་ཡིན། གལ་ཏེ་གྲངས་ཆ་ལྡོག་དེ་མེད་ན་ལས་འགན་འདི་ནི་ -1 སླར་ལོག་བྱེད་དགོས། དཔེར་ན།: >>> choose_num (((12), (15)) (14) >>> choose_num (((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// ཁྱོད་ཚོར་ n དང་ m གཉིས་ཀྱི་གྲངས་ཆ་ཚིམས་པ་ཐོབ་ཡོད། ཁྱོད་ཚོར་ n ནས་ m བར་གྱི་གྲངས་ཆ་ཚིམས་པའི་བར་གྲངས་རྩིས་རྒྱག་དགོས་པ་ཡིན། འབྲས་བུ་ལ་མཐའ་འཁོར་ནས་ཉེར་མཁོ་ཆེ་བའི་གྲངས་ཆ་ཚིམས་པར་སྒྱུར་ནས་ binary ཏུ་བསྒྱུར་དགོས། གལ་ཏེ་ n མཆོག་ལས་མང་བ་ཡིན་ན་ - 1 སླར་ལོག་བྱེད་དགོས། དཔེ་གཞི་: >>> rounded_avg (((1), (5)) \"0b11\" >>> rounded_avg (((7), (5)) -1 >>> rounded_avg (((10), (20)) \"0b1111\" >>> rounded_avg (((20), (33) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་ x ཅན་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་སླར་ལོག་བྱེད། ཟུར་ཐོ་: སླར་ལོག་བྱས་པའི་གྲངས་ཆ་ནི་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་གོ་རིམ་སྒྲིག་དགོས། དཔེར་ན།: >>> unique_digits(std::vector<long>({(long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་ 1 དང་ 9 བར་གྱི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 བར་གྱི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་ཡིན། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་། འབྲས་བུ་ནི་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་། འབྲས་བུ་ནི་ 1 དང་ 9 འབྲས་བུ་ 1 དང་ 9 ནང་དུ་ཚུད་པའི་གྲངས་ཐང་། འབྲས་བུ་ 1 དང་ 2 འབྲས་བུ་ 1 དང་ 2 འབྲས་བུ་ 1 འབྲས་བུ་ 1 འབྲས་བུ་ 1 འབྲས་བུ་ 2 འབྲས་བུ་ 1 འབྲས་བུ་ 2 འབྲས་བུ་ 1 འབྲས་བུ་ 2 འབྲས་བུ་ 2 འབྲས་བུ་ 3 འབྲས་བུ་ 3 འབྲས་བུ་ 3 འབྲས་བུ་ 3 འབྲས་བུ་ 4 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 འབྲས་བུ་ 5 \nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// f ནི་ n གྱི་ཚད་གཞི་ཡིན་པའི་ལས་འགན་ཞིག་ཡིན་པའི་ལས་འགན་ཞིག་ཡིན། ཚད་གཞི་ n གྱི་བེ་ཊར་ཞིག་ཕྱིར་ལོག་བྱེད་ཅིང་། གལ་སྲིད་ i ནི་ཆ་སྙོམས་ཡིན་ན་ i གྱི་གཞི་གྲངས་ཀྱི་ཐང་ནི་ i གྱི་གཞི་གྲངས་ཡིན་པའམ། ཡང་ན་ 1 ནས་ i བར་གྱི་གྲངས་ཀྱི་བསྡོམས་ཡིན་ན་ i གྱི་གཞི་གྲངས་ནི་ 1 ནས་ 1 བར་གྱི་གྲངས་ཀྱི་འབྲས་བུ་ཡིན། དཔེར་ན། >>> f (((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15})\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་གྲངས་ཆ་ལྡན་ n ཡོད་པ་ཚེ། ཚད་གཞི་དང་གྲངས་ཆ་ལྡན་རྣམ་གྲངས་ཀྱི་གྲངས་ཆ་དང་གྲངས་ཆ་མེད་པའི་རྣམ་གྲངས་ཀྱི་གྲངས་ཆ་དང་གྲངས་ཆ་མེད་པའི་རྣམ་གྲངས་ཀྱི་གྲངས་ཆ་བཅས་སླར་ལོག་བྱེད། དཔེ་གཞི་ 1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) འགྲེལ་བཤད་: ཚད་གཞི་དང་གྲངས་ཆ་ལྡན་རྣམ་གྲངས་ནི་ 1, 2, 3. དེའི་ནང་ནས་གཅིག་ནི་རྣམ་གྲངས་ཡིན་པ་དང་གཉིས་ནི་རྣམ་གྲངས་ཡིན། དཔེ་གཞི་ 2: >>> even_odd_palindrome (((12)) (std::make_tuple ((4, 6)) འགྲེལ་བཤད་: Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. དེའི་ནང་ནས་བཞི་ནི་རྣམ་གྲངས་ཡིན་པ་དང་དྲུག་ནི་རྣམ་གྲངས་ཡིན། དྲན་གསོ།: 1 <= n = 10^3 <^3 2. tuple ནང་ལ་རིམ་བཞིན་རྣམ་གྲངས་དང་རྣམ་གྲངས་ཀྱི་རྣམ་གྲངས་རྣམ་གྲངས་ཀྱི་གྲངས་ཆ་ཡོད།\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཀ count_nums ལས་འགན་ཞིག་བྲིས་ནས་གྲངས་ཆ་མཉམ་གྱི་བེ་ཊར་ཞིག་ལེན་ནས་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཆ་ཡོད་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་གྲངས་ཀྱི་\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ང་ཚོས་ N ཡི་གྲངས་ཐང་གི་བེ་ཊར་ 'arr' ཡོད་ arr[1], arr[2], ..., arr[N] ཀྱི་བེ་ཊར་ནང་གི་གྲངས་ཐང་རྣམས་གོ་རིམ་ལྟར་གོ་རིམ་སྒྲིག་བྱ་རྒྱུ་ཡིན། ཁྱོད་ཀྱི་ལས་འགན་ནི་བེ་ཊར་ཞིག་རིམ་བཞིན་ཡར་མར་མི་འགྲོ་བ་ལྟར་གོ་རིམ་སྒྲིག་ཐུབ་མིན་ངེས་གཏན་བྱ་རྒྱུ་ཡིན། ཇི་ཡོད་བེ་ཊར་ལ་གཤམ་གསལ་བྱ་གཞག་འདི་ལག་ལེན་བྱ་ཆོག། ཕྱོགས་སོར་བྱ་གཞག་གང་རུང་ཐེངས་མང་བ་ལག་ལེན་བྱ་ཆོག། ཕྱོགས་སོར་བྱ་གཞག་གཅིག་ནི་བེ་ཊར་གྱི་ཆ་ཤས་ཚང་མ་ཕྱོགས་ཕྱོགས་གཅིག་ཏུ་ཕྱོགས་གཅིག་ཏུ་སྤོ་བཞིན་དུ་ཡིན། བེ་ཊར་གྱི་ཆ་ཤས་མཐའ་མ་ནི་བེ་ཊར་གྱི་འགོ་ཐོག་གི་གནས་སྟངས་ལ་སྤོ་བཞིན་དུ་ཡོད། དཔེར་ན། 0th index ན། གལ་ཏེ་གོ་རིམ་སྒྲིག་པའི་བེ་ཊར་ཐོབ་ཐུབ་ན་ true return false སླར་ལོག་དགོས། གལ་ཏེ་བེ་ཊར་དེ་སྟོང་པ་ཡིན་ན་ true སླར་ལོག་དགོས། ལྟོས་དང་། བེ་ཊར་ནང་ཆ་ཤས་གཅིག་མཚུངས་ཡོད་ངེས་གཏན་བྱ་ཐུབ། དཔེར་ན།: move_plan_one_ball_{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འདིར་ང་ཚོས་ function ཞིག་ལག་ལེན་བྱ་རྒྱུ་དང་དེར་གྲངས་ཀྱི་ vector གཉིས་ནས་ lst1 ལ་གྲངས་ཆ་རྐྱང་གི་ vector ཞིག་བཟོས་ནས་དེའི་ནང་ element རྣམས་བརྗེ་བསྒྱུར་བྱ་ཐུབ་མིན་ལ་ངེས་གཏན་བྱ་རྒྱུ་ཡིན། lst1 དང་ lst2 བར་གྱི་ element གྱི་གྲངས་ཆ་བརྗེ་བསྒྱུར་བྱ་ཐུབ་པའི་ཚད་མ་མེད། lst1 དང་ lst2 བར་གྱི་ element རྣམས་བརྗེ་བསྒྱུར་བྱས་ན་ lst1 ནང་གི་ element ཚང་མ་ཉེར་ལྡོག་ཡོང་བའི་ཆེད་དུ་ \"YES\" སླར་ལོག་བྱ་དགོས། གལ་ཏེ་དེ་ལྟར་མིན་ན་ \"NO\" སླར་ལོག་བྱ་དགོས། དཔེར་ན།: >>> exchange((std::vector<>(long) {1, (long) 2, (long) 3, (long) 4})), (std::vector<>(long) {1, (long) 2, (long) 3, (long) 4}) (\"YES\") >>>((std::vector<>{1, (long) 2, (long) 3, (long) 4}), (std::vector<>(long) NO:<> (long) 3, (long) 5} (long) ཞེས་པ་ལྟ་བུ། ནང་འཇུག་བྱེད་དེ་ནང་འཇུག་བྱེད་རྒྱུ་ནི་ \"longty-long\" ཟེར་བ་ལས་མེད་པ་ཞིག་ཡིན།\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་གི་དྲ་ལམ་ནས་དྲ་ལམ་ཁ་པར་གྱི་ནང་ལ་ཡིག་འབྲུ་ཆུང་ཆུང་ཞིག་བཀོད་ནས་ཡིག་འབྲུ་མང་ཤོས་ཅིག་སླར་ལོག་བྱེད་པ་དང་དེའི་གྲངས་རྩིས་རྩིས་སྤྲོད་དགོས། གལ་ཏེ་ཡིག་འབྲུ་མང་ཤོས་ཅིག་འདྲ་མཚུངས་བྱུང་ན་ཡིག་འབྲུ་ཚང་མ་སླར་ལོག་བྱེད་དགོས། དཔེ་གཞི་: >>> histogram (((\"a b c\")) (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}})) >>> histogram (((\"a b b a\")) (std::map<std::string,>(({{\"a\", 2}, {\"b\", 2}})) >>> histogram (((\"a b c a b\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> histogram (b b a\") (std::string, 4\" ({{\"b\", 4}}) >>> (std:string,long>) >>> (std) (std::string, 4\") (std) (long))\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་ང་ཚོར་ཐིག་ལེ་གཉིས་སྩལ་ཡོད། s དང་ c ནང་གི་ཡིག་འབྲུ་ཚང་མ་སུབ་དགོས། དེ་ནས་ཐིག་ལེ་དེ་སྔོན་འགྲོའི་འདྲ་མཚུངས་ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱེད་དགོས། ཐིག་ལེ་དེ་སྔོན་འགྲོའི་འདྲ་མཚུངས་ཡིན་ན་དེ་རྒྱབ་འགྲོའི་འདྲ་མཚུངས་ཡིན་པར་བརྟག་དཔྱད་བྱེད་དགོས། ཁྱོད་ཀྱིས་ཐིག་ལེ་དེ་སྔོན་འགྲོའི་འདྲ་མཚུངས་ཡིན་ན་དེ་རྒྱབ་འགྲོའི་འདྲ་མཚུངས་ཡིན་པར་བརྟག་དཔྱད་བྱ་དགོས། དཔེ་གཞི་ >>> reverse_delete (((\"abcde\"), (\"ae\")) (std::make_tuple (((bcd\", false)) >>> reverse_delete (((\"abcdef\"), (\"b\") (std::make_tuple (((acdef\",)) >>> reverse_delete (((abcded\", false)) (std::make_tuple (((abcdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string གྱི་བེ་ཊར་ཞིག་ཡོད་ན་ string ཚང་མ་ནི་ཨང་གྲངས་ལས་གྲུབ་པ་ཞིག་ཡིན་ན། vector སླར་ལོག་བྱེད་དགོས། ཕྱིར་ཐོན་གྱི་ཆ་ཤས་ i དེ་ནང་ \"i གྱི་ནང་གྲངས་ཀྱི་གྲངས་ཆ་མི་འདྲ་བ་\" བྱེད་དགོས་པ་དང་། དེར་ i ཚང་མ་ནི་ i གྱི་ནང་གྲངས་ཀྱི་ནང་གྲངས་ཆ་མི་འདྲ་བ་ \"i\" གྱི་ནང་གྲངས་ཆ་མི་འདྲ་བ་ \"1234567\" བྱེད་དགོས་པ་རེད་འདུག\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་ integer nums གི་བེ་ཊར་ཡིན་པའི་ཚེ། nums གི་བེ་ཊར་ཆུང་ཤོས་ཀྱི་བསྡོམས་གྲངས་འཚོལ་དགོས། དཔེ་གཞི་ >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3}))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འདིར་ཆུ་མིག་གི་དབྱིབས་གྲུ་བཞི་ཞིག་ཡོད། རེའུ་མིག་རེ་རེར་ཆུ་མིག་གཅིག་རང་ཡོད་པ་དང་ རེའུ་མིག་རེ་རེའི་ནང་ 1 ཀྱིས་ཆུ་ཕྲན་གཅིག་རང་བསྟན་ཡོད། ཆུ་མིག་རེ་རེར་ཆུ་ལེན་པའི་བེག་ཡོད་པ་དང་བེག་ཚང་མའི་ཁོར་ཡུག་ནི་འདྲ་མཚུངས་ཡིན། ཁྱོད་ཀྱི་ལས་འགན་ནི་བེག་རྣམས་བེག་རྣམས་ཁུ་སུ་གཏོང་རྒྱུ་ཡིན། ཁྱོད་ཀྱིས་བེག་རྣམས་ཐེངས་ག་ཚོད་ཕབ་དགོས་ཀྱི་ཚད་གཞི་དེ་ཕྱིར་འདོན་བྱེད་དགོས། དཔེ་གཞི་ 1: >>> max_fill((long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་འདི་ནང་། ཁྱོད་ཀྱིས་ཨང་གྲངས་གཉིས་ལྡན་གྱི་གྲངས་སུ་ 1 ཀྱི་གྲངས་སུ་རྩིས་པའི་རྩིས་གཞི་དང་བསྟུན་པའི་རྩིས་གཞི་རིམ་བཞིན་རིམ་སྒྲིག་བྱེད་དགོས་པ་ཡིན། དེ་འདྲ་མཚུངས་གྲངས་སུ་རྩིས་པའི་རྩིས་གཞི་རིམ་སྒྲིག་བྱེད་སྐབས་བཅུ་ཚུའི་གྲངས་སུ་རྩིས་དགོས། ཚད་གཞི་འདི་བཞིན་ལག་ལེན་བྱ་དགོས། >>> sort_array (long) 1, (long) 2, (long) 2, (long) 3, (long) 4 (long) 5 (long) 2, (long) 3, (long) 3, (long) 4, (long) 5 (long) >>> sort_array (long) 5, (long) 6 (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long))\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string s དང་ natural number n ཞིག་ཡོད་ན། ཁྱོད་ལ་ལས་འགན་ཞིག་སྤྲོད་རྒྱུ་ཡོད་དེ། string s ནང་གི་ཚིག་ཡིག་ཚང་མ་ནས་ consonant ཆ་ཚང་ n ཡོད་པའི་ཚིག་ཡིག་ཚང་གི་བེ་ཊར་ཕྱིར་སློག་བྱ་དགོས། གལ་ཏེ་ string s གྱི་ནང་ཚིག་ཡིག་རྣམས་ཡོད་ན་ལས་འགན་གྱིས་བེ་ཊར་སྟོང་པ་ཕྱིར་སློག་བྱ་དགོས། ལྟོས་དང་། ཁྱོད་ཀྱིས་ནང་འཇུག་ string ནང་ཡི་གེ་དང་བར་སྟོང་རང་ཡོད་པར་ངེས་པ་དགོས། དཔེ་གཞི་: >>> select_words (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string))\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ཚིག་ཅིག་སྤྲོད་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ཚིག་དེའི་གཡས་ཕྱོགས་ནས་སྒྲ་གཉིས་བར་གྱི་ཉེ་བའི་སྒྲ་ཞིག་འཚོལ་དགོས་ (ཆེ་ཆུང་དང་ཆུང་ཆུང་ལ་དྭངས་གསལ་) ཐོག་དང་མཇུག་གི་སྒྲ་རྣམས་རྩིས་མི་དགོས། གལ་ཏེ་ཁྱོད་ཀྱིས་སྟེང་གི་དགོས་ངེས་ལ་ཆ་མཐུན་པའི་སྒྲ་མ་རྙེད་ན་ string སྟོང་པ་ཕྱིར་ལོག་བྱེད་ཅིག string ནང་དབྱིན་ཡིག་གི་ཡི་གེ་གཅིག་པུ་ཡོད་པར་ངེས་གཏན་བྱེད་དགོས། དཔེ་: >>> get_closest_vowel (((\"yogurt\")) (\"u\") >>> get_closest_vowel (((\"FULL\")) (\"U\") >>> get_closest_vowel (((\"quick\")) (\"\") >>> get_closest_vowel (((ab\") (\"\")\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ལ་ཐིག་ལེ་གཉིས་ཡོད་པའི་བེ་ཊར་ཞིག་སྤྲད་ཡོད་ཅིང་། ཐིག་ལེ་གཉིས་ཀ་སྒོ་སྒྲིག་གི་སྒོ་སྒྲིག་ '(' ཡང་ན་ སྒོ་སྒྲིག་གི་སྒོ་སྒྲིག་ ') 'ལས་གྲུབ་པ་ཡིན། ཁྱོད་ཀྱི་ལས་འགན་ནི་ཐིག་ལེ་གཉིས་རིམ་བཞིན་འབྲེལ་མཐུད་བྱེད་ཐུབ་མིན་ལ་བརྟག་དཔྱད་བྱེད་རྒྱུ་དེ་ཡིན། འབྲས་བུ་ཐིག་ལེ་དེ་ལེགས་པོ་ཡོང་ངེས་ཡིན། ཐིག་ལེ་ S ནི་ལེགས་པོ་ཡིན་པར་ངོས་འཛིན་བྱ་རྒྱུ་ནི་ཐིག་ལེ་ S ནང་གི་སྒོ་སྒྲིག་ཚང་མ་མཉམ་གནས་ན་དེ་ཁོ་ན་ཡིན། དཔེར་ན། ཐིག་ལེ་ '(())) ' ལེགས་པོ་ཡིན་པའི་སྐབས་ཐིག་ལེ་ '()) ' ལེགས་པོ་མིན་པ་ལྟ་བུ། ཐིག་ལེ་ལེགས་པོ་བཟོ་རྒྱུའི་ཐབས་ལམ་ཡོད་ན་ 'Yes' སླར་ལོག་བྱེད་ནས་གཞན་ན་ 'No' སླར་ལོག་བྱེད་པ། དཔེར་ན། >>> match_parens(std::vector<std::string>{((stdstring) \") \", ((std::string) \")) \"Yes\" >>> match_parens<std::vector<std>{(stdstring>\" (\"No\") \" (string))\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་གི་དྲ་ལམ་ནས་དྲ་ལམ་གྱི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་ལ་དཔྱད་པ། སྐར་ཁུང་གི་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་གཞི་དང་ཚད་ལྡན་པ་དང་གཉིས་པ་བཅས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་གཉིས་པ་དང་\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྟབས་ཀྱིས་སྟོང་པ་མིན་པའི་གྲངས་ཆ་མཉམ་པའི་ཐིག་ཁྲམ་ཞིག་ཡོད་ན། ཕྲད་གྲངས་ཆ་མཉམ་གྱི་གོ་གནས་ཆ་སྙོམས་ལ་ཕྱིར་ལོག་བྱེད་པ། དཔེ་གཞི་ >>> ཐབས་ལམ་ ((((std::vector<long>({(long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> ཐབས་ལམ་ ((((std::vector<long>({(long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> ཐབས་ལམ་ ((((std::vector<>((long) 30, (long) 13, (long) 24, (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་གྲངས་ཆ་མཉམ་ arr དང་གྲངས་ཆ་མཉམ་ k གི་གྲངས་ཆ་མཉམ་ k ཐོག་མའི་གྲངས་ཆ་ k ལས་ལྷག་པའི་གྲངས་ཆ་གཉིས་ཡོད་པའི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་ཕྱིར་ལོག་བྱེད་པ། དཔེ་གཞི་: >>> add_elements{\\ std::vector<long>{\\ long>{\\ long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) ཚད་འཛིན་: 1. 1 <= len{arr) <= 100 2. 1 <= k <= lenarr)\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་གྲངས་ n ཡོད་པ་ཞིག་ཡིན་ན། འབྲས་བུ་གྲངས་ནི་གོ་རིམ་སྒྲིག་ནས་གོ་རིམ་སྒྲིག་ནས་གོ་རིམ་སྒྲིག་ནས་གོ་རིམ་སྒྲིག་དགོས། དཔེར་ན་ get_odd_collatz (5) གྱིས་ [1, 5] སླར་ལོག་བྱས་ན། 5 གྱི་གོ་རིམ་ནི་ [5, 8, 16, 4, 2, 1] ཡིན་པས་གོ་རིམ་མ་ལྡན་པ་ནི་ 1 དང་ 5 ཡིན་པ་དང།\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་གཏན་འབེབས་ཟིན་པའི་ཚེས་གྲངས་ཀྱི་ཐིག་ཁྲམ་ཞིག་ validate བྱེད་པ་དང་ཚེས་གྲངས་ valid བྱུང་ན་ true སླར་ལོག་བྱེད་དགོས། གལ་ཏེ་ཚེས་གྲངས་ false བྱུང་ན་ date ནི་ valid བྱུང་དགོས། གལ་ཏེ་གཤམ་གསལ་སྒྲིག་གཞི་ཚང་མ་འདུན་ན་ date ནི་ valid བྱུང་དགོས། 1. ཚེས་གྲངས་ཀྱི་ཐིག་ཁྲམ་ནི་སྟོང་པ་མིན་དགོས། 2. ཉིན་གྲངས་ནི་ཟླ་བ་ 1,3,5,7,8,10,12 ནང་ཉིན་གྲངས་ 1 ལས་ཉུང་བ་ཡང་ན་ཉིན་གྲངས་ 31 ལས་མང་བ་མིན་དགོས། ཡང་ཉིན་གྲངས་ནི་ཟླ་བ་ 4,6,9,11 ནང་ཉིན་གྲངས་ 1 ལས་ཉུང་བ་ཡང་ན་ཉིན་གྲངས་ 30 ལས་མང་བ་མིན་དགོས། ཡང་ཉིན་གྲངས་ནི་ཟླ་བ་ 2 ནང་ཉིན་གྲངས་ 1 ལས་ཉུང་བ་ཡང་ན་ཉིན་གྲངས་ 29 ལས་མང་བ་མིན་དགོས། 3. ཟླ་བ་ 1 ལས་ཉུང་བ་ཡང་ན་ཉིན་གྲངས་ 12 ལས་མང་བ་མིན་དགོས། 4. ཚེས་གྲངས་ནི་གཤམ་གསལ་རྣམ་པ་ནང་དགོས་: mm-dd-yyyy >>> valid_(date((103-11-2000\")) (true >>> valid_date((15-01-2012\")) (false >>> valid_date (((04-040\") (false) valid >>> valid_((date_(06-2020) (true >>> valid_date\"06/04/2020) (false))\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ཞིག་ཡོད་ན། ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ཞིག་ཕྱིར་སློག་བྱ་དགོས། གལ་ཏེ་དཀར་ཆག་མེད་ན་ཡིག་ཆ་ནང་ཀམ་པེ་སིར་ཁ་གྱེས་དགོས་ ',' གལ་ཏེ་ཀམ་པེ་སིར་མེད་ན་ཡིག་གཟུགས་ནང་ཡིག་ཆུང་གི་རིམ་པ་རྣམ་རྟོག་ཅན་ཡོད་པའི་ཡིག་འབྲུ་གྲངས་ཕྱིར་ལོག་བྱ་དགོས། ord (a) = 0 ord (b) = 1 ... ord (z) = 25 དཔེ་གཞི་ >>> split_words (de) >>> split_words (de) (3)\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་གི་དྲ་ལམ་ནས་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་གྱི་དྲ་ལམ་ཁ་པར་དྲ་ལམ་ཁ་པར་དྲ་ལམ་ཁ་པར་དྲ་ལམ་ཁ་པར་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་ལམ་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་རྒྱའི་དྲ་\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་གཉིས་ནི་གྲངས་ཆ་དང་མཚུངས་པ་ཞིག་ཡིན། དཔེར་ན། བར་མཚམས་ = (མགོ་, མཇུག་) = (1, 2) ཟེར་བ་ཡིན། བར་མཚམས་དེ་ཁ་ཕྱེཝ་ལས་ བར་མཚམས་ (མགོ་, མཇུག་) གྱིས་འགོ་དང་མཇུག་གཉིས་ཀྱང་མཉམ་པར་ཡོད། བར་མཚམས་རེ་རེ་ལ་དེའི་འགོ་ནི་མཐའ་དང་མཚུངས་པའམ་ཉུང་བ་ཞིག་ཡིན་པར་ངེས་པ་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ བར་མཚམས་གཉིས་ཀྱི་ཕྲད་ཚད་ནི་སྔོན་གྲངས་ཞིག་ཡིན་མིན་ངེས་པ་དགོས། དཔེར་ན། བར་མཚམས་ (1, 3), (2, 4) གྱི་ཕྲད་ཚད་ནི་ (2, 3) ཟེར་བ་དེའི་ཕྲད་ཚད་ནི་ 1ཡིན་པ་དང་དེ་ནི་སྔོན་གྲངས་མིན་པ་ངེས་པ་དགོས། གལ་ཏེ་ཕྲད་ཚད་ནི་སྔོན་གྲངས་ཞིག་ཡིན་ན་ \"YES\" སླར་ལོག་བྱ་དགོས། གལ་ཏེ་ཕྲད་ཚད་གཉིས་མ་འདྲ་ན་ \"NO\" སླར་ལོག་བྱ་དགོས། [input/output] samples: >>>intersection::((dmake_tuple1, 2)), (dmake_tuple2, 3) (\"NOsection::(dmake_tuple\", (dmake_tuple-1, 4) (\"YES-\", \"dmake_tuple-1, 4)), (dmake_tuple-1, 4) (\"dmake_tuple-1\", (dmake_tuple-5))\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཆ་གྲངས་ཆ་མཉམ་གྱི་མཐའ་གྲངས་ཤིག་ཡོད་ལ། གྲངས་ཆ་ཚང་མ་མང་དུ་བཏང་ནས་དེའི་ནང་ཡོད་པའི་གྲངས་ཆ་ཚང་མ་མང་དུ་བཏང་བའི་གྲངས་ཆ་མཉམ་གྱི་གྲངས་ཆ་མང་གྲངས་ཐང་སླར་ལོག་བྱེད་དགོས་ཤིང་། གྲངས་ཆ་དེ་ 1 དང་ -1 དང་ 0 ཀྱི་ཚབ་ཏུ་མཚོན་ན་སླར་ལོག་བྱ་དགོས། སྟོང་པའི་མཐའ་གྲངས་གྲངས་གྲངས་ཀྱི་གྲངས་ཆ་མེད་ཡིན། དཔེ་གཞི་: >>> prod_signs{(std::vector<long>{(long) 1, (long) 2, (long) 2, (long) -4}))) 9 >>> prod_signs{(std::vector<long>{(long) 0, (long) 1}))) 0 >>> prod_signs{(std::vector<long>(long>))) std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་འཛིན་གྱི་དྲ་མིག་ནང་གྲལ་རིམ་དང་ཀ་བ་ N (N >= 2) དང་གྲངས་ཆ་ k ཡོད་པའི་ཚེག་དང་དྲ་མིག་གི་དྲ་མིག་རེ་རེར་གྲངས་ཐང་ཞིག་ཡོད། [1, N * N] ནང་ཡོད་པའི་གྲངས་ཆ་ཚང་མ་དྲ་མིག་གི་དྲ་མིག་རེ་རེར་ཐེངས་གཅིག་རང་མངོན་པར་བྱེད། དྲ་མིག་ནང་ཚད་ k ཡི་ཉུང་མཐའི་ལམ་དེ་འཚོལ་དགོས། དྲ་མིག་གང་རུང་ནས་འགོ་འཛུགས་དང་རིམ་པ་རེ་རེར་ཉེ་བའི་དྲ་མིག་གང་རུང་དུ་འགྲོ་ཐུབ། གཞན་སྐད་དུ་བརྗོད་ན་དྲ་མིག་དང་དྲ་མིག་གི་ཟུར་མཚམས་འདྲ་མཚུངས་ཡོད་སའི་དྲ་མིག་གང་རུང་དུ་འགྲོ་ཐུབ། དྲ་མིག་ནས་ཕྱིར་ཐོན་མི་ཆོག དྲ་མིག་ A (རིང་ཚད་ k) ནི་དྲ་མིག་ B (རིང་ཚད་ k) ལས་ཆུང་བ་ཞིག་ཡིན་པར་རྩིས་ཐུབ། གལ་ཏེ་དྲ་མིག་ A དང་ B (དེ་དག་ལ་ lA_st དང་ lA_st) ཞེས་མིང་བཏགས་རྗེས་དྲ་མིག་གི་དྲ་མིག་ནས་ཕྱིར་ཐོན་པའི་དྲ་ལམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་ཡིན་ན་དྲ་ལམ་ A (རིང་ཚད་ k) ནི་དྲ་ལམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་ཞིག་ཡིན་པར་རྩིས་ཐུབ། གལ་ཏེ་དྲ་མིག་ནང་ཚད་ལྡན་གྱི་དྲ་མིག་ A དང་ B (རིང་ཚད་ k) ཡི་གོ་རིམ་སྒྲིག་བྱས་རྗེས་དྲ་མིག་གི་དྲ་མིག་ནས་དྲ་མིག་ j_st དང་ lA_st_st_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_i_\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཐིག་ཁྲམ་ནང་ཡོད་པའི་གྲངས་ཀ་ནི་ tri (n) = 1+n/2,n=1+n/2,n=2+n+1,n=2+n+1,n=2+3+2+3+4+3+3+3+3+3+3+4+8ཡིན། གྲངས་ཀ་དེའི་ནང་གྲངས་ཀ་ n+1+1+1+1+8ཡོད་ལ། གྲངས་ཀ་ n+1+1+8 ཡོད་པའི་གྲངས་ཀ་ལ་རྩིས་རྒྱག་དགོས་པ་ཡིན།\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་ n ཡིན་ན་གྲངས་ཆ་རྐྱང་གི་འབྲས་བུ་ཕྱིར་སློག་དགོས། གྲངས་ཆ་ཚང་མ་ཆ་སྙོམས་ཡིན་ན་ 0 སླར་ལོག་བྱེད། དཔེར་ན།: >>> གྲངས་ཆ་ (((1)) (1) >>> གྲངས་ཆ་ (((4)) (0) >>> གྲངས་ཆ་ (((235)) (15)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ལས་འགན་ཞིག་བཟོས་ནས་ནང་འཇུག་ལྟར་དྲ་བའི་ནང་ཁེ་བཞི་ཅན་གྱི་ལྡེ་མིག་གཅིག་ལས་མེད་ན་ true སླར་ལོག་བྱེད་དགོས། ལས་འགན་དེ་ true སླར་ལོག་བྱེད་དགོས་པ་ནི། གལ་ཏེ་ལྡེ་མིག་ནང་ཉུང་མཐར་ལྡེ་མིག་གཅིག་ཡོད་པའི་ལྡེ་མིག་འོག་མ་ཞིག་ཡོད་ན་དེ་ true ཡིན་ན་དེ་ true ཡིན་དགོས། >>> is_nested\" (_) \" ([[]]\")) (true) >>> is_nested\" (_) \" ([[]]\")) (false) >>> is_nested\" (_) \" ([[]]\")) (false) >>> is_nested\" (_) \" (]]\") (false) >>> is_nested\" (_) \" (]]\") (true) >>> is_nested\" ([[]]\") (true)\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་གྲངས་ཀྱི་བེ་ཊར་ཞིག་སྤྲད་ཡོད། ཁྱོད་ཀྱིས་གྲངས་ཀྱི་བེ་ཊར་གྱི་གྲུ་བཞི་གྲངས་ཀྱི་བསྡོམས་ཕྱིར་ལོག་བྱེད་དགོས་ཤིང་། བེ་ཊར་གྱི་ཆ་ཤས་རེ་རེར་ཐོག་མར་སྟེང་གི་ int{\\ ལྡེག}ལ་འཁོར་དགོས། དཔེ་གཞི་: >>> lst{\\ ལྡེག }:: vector<float>{\\ ལྡེག }1.0f, (float)2.0f, (float)3.0f}))) (14) >>> lst{\\ ལྡེག }:: vector<float>{\\ ལྡེག }1.0f, (float)4.0f, (float)9.0f}))) (98) lst{\\ ལྡེག }:: vector<float>{\\ ལྡེག }1.0f, (float)3.0f, (float)5.0f, (float)7.0f} (84) >>> lst{\\ ལྡེག }:: vector<\\ ལྡེག }{\\ ལྡེག }1.0f, (float)2.0f, (float) 2.0f} (float) (6) >>> lst{\\ ལྡེག }1.0f, (float) 2.0f)\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་ཁུང་གི་དྲ་ལམ་ནས་དྲ་ལམ་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་གྱི་ནང་དོན་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་ཁ་པར་\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་མང་ཤོས་ཕྱིར་ལོག་བྱེད་ནུས་པའི་ལས་འགན་ཞིག་བཟོ་དགོས། གལ་ཏེ་ཚད་གཞི་དེ་འདྲ་མེད་ན་ -1 སླར་ལོག་བྱེད་དགོས། ཚད་གཞི་དེ་འདྲ་མེད་ན་ ཚད་གཞི་དེ་འདྲ་གཉིས་ལྡན་མི་ཡོང་། དཔེ་གཞི་: >>> can_arrange{(std::vector<long>{(long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་ (a, b) ཞིག་ཕྱིར་སློག་བྱ་བའི་ལས་འགན་ཞིག་བཟོ་དགོས། དེར་ 'a' ནི་ནད་པ་ཚང་མའི་ནང་ནས་ཆེ་ཆུང་ཡིན་པ་དང་། 'b' ནི་བེ་ཊར་ནང་གི་བདེ་བའི་ཚང་མའི་ནང་ནས་ཆུང་ཆུང་ཡིན། ནེ་གེ་རེ་དང་བདེ་བའི་ཚང་མའི་ནང་ནས་ཆུང་ཆུང་ཡིན་ན་ None སྦེ་ཕྱིར་སློག་བྱ་དགོས། དཔེ་གཞི་: >>> largest_smallest_integers(((std::vector<long>{long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7)) std::make_tuplestd::optional<long>{long>), std::optional<long> (long) 1) >>> largest_smallest_integers{long>{long>), std::optional<long>{long>)\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// ལས་འགན་ཞིག་བཟོས་ནས་གྲངས་ཆ་ཆ་ཚང་དང་ལྡོག་ལྡོག་དང་ཡང་ན་གྲངས་ཆ་དངོས་ཡོད་ཀྱི་གྲངས་རིམ་ལ་མཚོན་པའི་གྲངས་རིམ་ལ་འཇུག་པ། དེ་ལས་གྲངས་ཆ་ཆེ་བས་ལྡོག་ལྡོག་གི་གྲངས་རིམ་ལ་འཇུག་པ། གནས་ཚད་འདྲ་མཚུངས་ཡོད་ན་ None སླར་ལོག་བྱེད། དྲན་གསོ། གྲངས་ཆ་དངོས་ཡོད་ཀྱི་གྲངས་རིམ་ལ་མཚོན་ན་ལྡོག་ལྡོག་གི་གོ་རིམ་ནི་ . or , >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, \"2,3\") \"2,3\" >>> compare_one(\"5,1\", \"6\") \"6\" >>> compare_one(\"1\", 1) std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// བྱིན་ཡོད་པའི་གྲངས་ n ནི་གྲངས་ཆ་ཆ་མཚུངས་ 4 གི་བསྡོམས་ཤིག་ཡིན་པར་ངེས་མེད་ལ་དཔྱད་པ། དཔེ་གཞི་ >>> is_equal_to_sum_even ((4)) (རྫུན་མིན།) >>> is_equal_to_sum_even ((6)) (རྫུན་མིན།) >>> is_equal_to_sum_even ((8) (བདེན་པ་ཡིན།)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// བརཱ་ཛིལ་གྱི་གནས་སྡུད་ནི་ brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! གང་ཡིན་ཟེར་ན། n > 0 དཔེར་ན་: >>> special_factorial (((4)) (288) ལས་འགན་འདི་ནི་གྲངས་ཀ་ཧྲིལ་པོ་ཞིག་རྩིས་སྤྲོད་བྱེད་པ་དང་གྲངས་ཀ་ཧྲིལ་པོ་འདིའི་གནས་སྡུད་དམིགས་བསལ་ཕྱིར་ལོག་བྱེད་དགོས།\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚིག་ཡིག་ཡིག་རྒྱུན་ཅིག་ཡོད་ན་དེའི་ནང་ཡོད་པའི་བར་སྟོང་ཚང་མ་འོག་ཡིག་དང་བརྗེ་སྒྱུར་བྱེད་དགོས། གལ་ཏེ་ཡིག་རྒྱུན་ནང་བར་སྟོང་གཉིས་ལས་མང་བ་ཡོད་ན་བར་སྟོང་ཚང་མ་བརྗེ་སྒྱུར་བྱེད་དེ་ - >>> fix_spaces (((\"དཔེ་ཚོགས།\")) (\"དཔེ་ཚོགས།\") >>> fix_spaces (((\"དཔེ་ཚོགས། 1\")) (\"དཔེ་ཚོགས།_1\") >>> fix_spaces (((\"དཔེ་ཚོགས། 2\")) (\"_Example_2\") >>> fix_spaces (((\"དཔེ་ཚོགས། 3\")) (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཡིག་སྣོད་མིང་རྟགས་ཀྱི་སྔོན་དུ་ཡིག་སྣོད་འོག་གི་ཐིག་ཡིག་ནི་སྟོང་པ་མི་དགོས། དེ་སྔོན་གྱི་ཐིག་ཡིག་འོག་གི་ཐིག་ཡིག་ནི་དབྱིན་ཡིག་གི་ཡི་གེ་ (a'-z' and 'A'-Z') ཅན་ཞིག་ལས་འགོ་འཛུགས་དགོས། ཐིག་ཡིག་འོག་གི་ཐིག་ཡིག་འོག་གི་ཐིག་ཡིག་འོག་གི་ཐིག་ཡིག་ནི་གཤམ་གསལ་རྣམས་ལས་གཅིག་ཡིན་དགོས། དཔེ་གཞི་: >>> file_name_check_d\"(example.txt\") (\"Yes\") >>> file_name_check_d\"(example.d1\") (\"No\")\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \" ལས་འགན་འདི་ནི་གྲངས་ཚང་གི་བེ་ཊར་ཞིག་ལེན་ངེས་ཡིན། བེ་ཊར་ནང་གི་ནང་འཇུག་ཚང་མ་ལ། ལས་འགན་འདི་ནི་གྲངས་ཚང་གི་ནང་འཇུག་ལ་གྲུ་བཞི་པར་འཇོག་ངེས་ཡིན། གལ་ཏེ་དེའི་ནང་འཇུག་ནི་ 3 ཀྱི་ལྡབ་གྲངས་ཡིན་ན་དང་ གྲངས་ཚང་གི་ནང་འཇུག་ལ་གྲུ་བཞི་པར་འཇོག་ངེས་ཡིན། གལ་ཏེ་དེའི་ནང་འཇུག་ནི་ 4 ཀྱི་ལྡབ་གྲངས་ཡིན་ན་དང་ 3 ཀྱི་ལྡབ་གྲངས་མིན་ན་ལས་འགན་འདི་ནི་བེ་ཊར་ནང་གི་ནང་འཇུག་ལ་འགྱུར་བ་མི་གཏོང་ངེས་ཡིན། དེའི་ནང་འཇུག་ནི་ 3 དང་ 4 ཀྱི་ལྡབ་གྲངས་མིན་ན་ལས་འགན་འདི་ནི་ནང་འཇུག་ཐམས་ཅད་ཀྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་ངེས་ཡིན། དཔེ་གཞི་: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst ((long)) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ཚིག་ཡིག་ཅིག་མཚོན་པའི་ string ཞིག་གནང་ཡོད་ཅིང་། sentences ནང་ལ་ space ཀྱིས་དབྱེ་བའི་ཚིག་འགའ་ཞིག་ཡོད་ཅིང་། ཁྱོད་ཀྱིས་ string ནང་འཇུག་བྱེད་དེ་ནང་ཐོག་མའི་ཚིག་ཡིག་གི་ཚིག་ཡིག་ཡོད་ཅིང་། དེའི་རིང་ཚད་ནི་ prime number རྣམས་ཡིན། string ནང་གི་ཚིག་ཡིག་གི་རིམ་པ་སྔོན་གྱི་ཚིག་ཡིག་དང་མཚུངས་པར་དགོས་པ་ཡིན། དཔེ་གཞི་ ༡: >>> words_in_sentence (((\"This is a test\")) (\"is\") དཔེ་གཞི་ ༢: >>> words_in_sentence (((\"let go for swimming\")) (\"go for\") Constraints: * ༡ <= len= (((sentence) <= ༡༠༠ * sentence ནང་ཡི་གེ་གཅིག་པུ་ཡོད།\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཀྱི་ལས་འགན་ནི་ x*n ཟེར་བའི་ཚིག་ཡིག་དེ་དྭངས་གསལ་བཟོ་རྒྱུའི་ལས་འགན་ཞིག་བྱེད་རྒྱུ་ཡིན། གལ་ཏེ་ x*n ཟེར་བའི་ཚིག་ཡིག་ནི་ཧྲིལ་གྲངས་ཡིན་ན་ལས་འགན་དེ་ true སླར་ལོག་བྱེད་ཅིང་། གལ་ཏེ་ x*n ཟེར་བའི་ཚིག་ཡིག་ནི་ཧྲིལ་གྲངས་ཡིན་ན་ལས་འགན་དེ་ false སླར་ལོག་བྱེད་རྒྱུ་ཡིན། x དང་ n གཉིས་ནི་ཧྲིལ་གྲངས་ཀྱི་ཡིག་འབྲུ་ཡིན་པ་དང་གཤམ་གསལ་རྣམ་པ་ཡོད་ལ། <numerator>/<denominator> ནང་གི་ཧྲིལ་གྲངས་དང་མིང་ཚིག་གཉིས་ཆ་ནི་ཧྲིལ་གྲངས་ཀྱི་གྲངས་ཆ་ལྡན་ཡིན། ཁྱོད་ཀྱིས་ x དང་ n གཉིས་ནི་ཧྲིལ་གྲངས་ཀྱི་གྲངས་ཆ་ལྡན་ཡིན་པར་ངོས་འཛིན་བྱེད་ཆོག སྦྲེལ་གྲངས་ནི་ 0 ཡིན་པ་མ་ཡིན། >>> simplify (((\"1/5\") (\"5/1\")) (true) >>> simplify (((\"1/6\") (\"2/1\")) (false) >>> simplify (((\"7/10\") (\"10/2\")) (false)\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲི་བྱ་འདི་ནི་གྲངས་ཚང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་ཐང་གི་གྲངས་\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཀྱི་བེ་ཊར་ལ་ཨང་གྲངས་ཀྱི་ནང་འཇུག་ལྟར་ལེན་པའི་ལས་འགན་ཞིག་བྲིས་ནས་གྲངས་ཀྱི་བེ་ཊར་ནང་ཡོད་པའི་ཆ་ཤས་གྲངས་ 10 ལས་མང་བ་ཡོད་པ་དང་གྲངས་ཀྱི་ཨང་གྲངས་དང་པོ་དང་མཐའ་མ་གཉིས་ཆ་གཅིག་མཚུངས་ཡིན་པའི་གྲངས་གྲངས་ཕྱིར་ལོག་བྱེད་པ། དཔེར་ན། >>> specialFilter((std::vector<long>({(long) 15, (long) -73, (long) -14, (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) 33, (long) -2, (long) -3, (long) -4, (long) 21, (long) -109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ལ་གྲངས་ཆ་ཚིགས་ཚིགས་ n ཞིག་ཐོབ་ཡོད། ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིགས་ཚིགས་ a ཡི་རིང་ཚད་ n བཟོ་དགོས། i (1 ≤ i ≤ n) རེ་རེ་ལ་ a[i] = i * i - i + 1 གྱི་ཐང་ནི་ a[i], a[j], a[k]) གྱི་གྲངས་ཆ་གསུམ་གྱི་གྲངས་ཐང་ནི་ a < j < k དང་། a[i] + a[j] + a[k]ནི་ 3 གྱི་ལྡབ་གྲངས་ཡིན། དཔེ་གཞི་: >>> get_max_triples((5)) (1) འགྲེལ་བཤད་ནི། a = [1, 3, 7, 13, 21] གསུམ་ལྡབ་གཅིག་ནི་ (1, 7, 13) ཡིན།\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཉི་མའི་ལམ་ལུགས་ནང་སྐར་ཆེན་བརྒྱད་ཡོད། ཉི་མའི་ཉེ་བའི་སྐར་ཆེན་ནི་མེ་ཁུ་རི་ཡིན། དེའི་རྗེས་ལ་སྐར་ཆེན་ཨུ་རུ་ནུ། དེའི་རྗེས་ལ་འཛམ་གླིང་། མགོན་པོ། མཁའ་འགྲོ། སངས་རྒྱས་པ། ཨུ་རུ་ནུ། ནེ་པུ་ཊིན་བཅས་ཡིན། ལས་འགན་འདི་ལ་སྐར་ཆེན་གཉིས་ཟེར་བ་གཉིས་ཡོད། ལས་འགན་འདི་ནི་སྐར་ཆེན་1དང་སྐར་ཆེན་2གི་བར་ལ་ཡོད་པའི་སྐར་ཆེན་ཚང་མ་ཡོད་པའི་སྐར་ཆེན་གྱི་མིང་གི་ཐིག་ཁྲམ་ཞིག་ཕྱིར་སློག་བྱ་དགོས་ཤིང་། སྐར་ཆེན་1དང་སྐར་ཆེན་2གྱི་འཁོར་ལམ་གྱི་བར་ལ་ཡོད་པའི་སྐར་ཆེན་ཚང་མ་ཉི་མ་དང་ཉེ་བར་ཡོད་ཚད་ལ་གཞིགས་ནས་དབྱེ་དགོས། ལས་འགན་འདི་ནི་སྐར་ཆེན་1དང་སྐར་ཆེན་2ནི་སྐར་ཆེན་གྱི་མིང་དང་མཐུན་པ་མིན་ན་ཐིག་ཁྲམ་སྟོང་པ་ཅིག་ཕྱིར་སློག་བྱ་དགོས། དཔེ་གཞི་འདི་ནི་ >>> bf(\"Jupiter\"), (\"Neptune\")) (std::vector<std::string>{(std::string) \" (Saturn\", (std::vector) (Uranus) \"} (Uranus) >>> bf (((\"Earth\"), (\"Mercury\") (std) (std::vector:Venus\" (std::string) (Jup) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (str) (str)\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚད་གཞི་ལྟར་ string གྱི་ vector ཞིག་ལེན་ནས་ odd ཚད་ལྡན་གྱི་ string རྣམས་ཕྱིར་འདོན་བྱེད་ནས་གོ་རིམ་སྒྲིག་ནས་ vector སླར་ལོག་བྱེད་པ། ཚད་ལྡན་ནི་ string གྱི་ vector ཡིན་པ་ལས་གྲངས་ཀྱི་ vector ཡིན་པ་མ་ཡིན། དེའི་ནང་ཡང་འདྲ་མཚུངས་ཡོད་སྲིད་དོ། ཚད་ལྡན་གྱི་ vector གྱི་གོ་རིམ་ནི་ཚིག་རེ་རེ་བཞིན་གྱི་རིང་ཚད་ལ་གཞིགས་ནས་ཡར་འགྲོ་དགོས་པ་དང་། ཁྱོད་ཀྱིས་ཚད་ལྡན་གྱི་ vector དེ་ལུགས་དེ་དང་བསྟུན་ནས་གོ་རིམ་སྒྲིག་ནས་ཕྱིར་ལོག་བྱེད་དགོས། ཚིག་གཉིས་རིང་ཚད་གཅིག་མཚུངས་ཡོད་ན་ vector དེ་ཡི་ཡི་ཡི་ཡིག་རིམ་བཞིན་གོ་རིམ་སྒྲིག་དགོས། ལས་འགན་གྱིས་ string གྱི་ vector དེ་གོ་རིམ་སྒྲིག་ནས་ཕྱིར་ལོག་བྱེད་དགོས། ཁྱོད་ཀྱིས་ཚིག་ཚང་མ་རིང་ཚད་གཅིག་མཚུངས་ཡོད་པར་ངེས་གཏན་བྱེད་ཆོག དཔེར་ན།: >>> list_sort{\"}std::vector<stdstring>{\"}{\"}{\"}{\"} (a\"} (a\"} (a\"a\"a\"a) (aaa\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྟབས་བདེ་བའི་ལས་རིམ་ཤིག་སྟེ། གལ་ཏེ་ n ནི་གྲངས་ཀ་མང་པོ་ཡིན་ན་ x གི་ཐང་ཕྱིར་ལོག་བྱེད་པ་དང་གཞན་ན་ y གི་ཐང་ཕྱིར་ལོག་བྱེད་པ། དཔེར་ན། >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གྲངས་ཀྱི་བེ་ཊར་ཞིག་ཡོད་ན། བེ་ཊར་ནང་ཡོད་པའི་གྲངས་ཀྱི་གྲུ་བཞི་གྲངས་ཀྱི་བསྡོམས་ལོག་འཇུག་དགོས། ནུས་མེད་དང་གྲངས་ཆ་མ་ཡིན་པ་ལ་སྣང་མེད་བྱེད་ཅིག ། >>> double_the_difference (_) std::vector<float> (_) long (long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference (_) std::vector<float> (_) long (-1, (long) 2, (long) 0}))) (0) >>> double_the_difference (_) std::vector<float> (_) long (9, (long) - 2}))) (81) >>> double_the_difference (_) std::vector<float> (_) long (_) 0))) (0) ནང་འཇུག་བེ་ཊར་ནི་སྟོང་པ་ཡིན་ན་ 0 སླར་སྤྲོད་དགོས།\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཚོད་རྩིས་དང་ཚོད་དཔག་ཚད་འདྲ་མཉམ་གྱི་བེ་ཊར་གཉིས་སྤྲོད་པ། ཚོད་དཔག་ཚད་འདྲ་མཉམ་གྱི་བེ་ཊར་ཕྱིར་ལོག་བྱེད། ཚོད་དཔག་ཚད་འདྲ་མཉམ་གྱི་བེ་ཊར་དེ་ཚོད་དཔག་ཚད་དང་ཚོད་དཔག་ཚད་ཀྱི་བར་གྱི་ཁྱད་པར་གཏན་ཚིགས་ཡིན། དཔེ་གཞི་: >>>(longd::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5, (long) 1}) ཚོད་དཔག་ཚད་ (long) 0, (long) 2, (long) 2, (long) 2, (long) 2, (long) 3, (long) 4, (long) 0 (long) 0 (long) 0 (long) 0 (long) 3, (long) 4 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 3 (long) 4 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 0 (long) 4 (long) 0 (long) 0 (long) (long) 0 (long) (long) 0 (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ class (string) དང་ extension གྱི་ vector ཞིག་ཐོབ་ཡོང་། ཚད་གཞི་ནི་ class ནང་གི་ class གཞན་ཞིག་སྣོན་ཆེད་བེད་སྤྱོད་བྱེད། ཚད་གཞི་ཀྱི་ནུས་པ་ནི་ CAP ནི་ཚད་གཞི་ཀྱི་མིང་གི་ཡིག་འབྲུ་ཆེ་ཆུང་གི་གྲངས་ཡིན་དང་། SM ནི་ཚད་གཞི་ཀྱི་མིང་གི་ཡིག་འབྲུ་ཆུང་ཆུང་གི་གྲངས་ཡིན་ན། ཚད་གཞི་ནི་ CAP - SM བཅའ་ཡིག་གི་སྒོ་ནས་ཐོབ་པ་ཡིན། ཁྱོད་ཀྱིས་ཚད་གཞི་ཤུགས་ཆེ་ཤོས་འཚོལ་ནས་ string འདི་འདྲ་བའི་རྣམ་པ་ནང་ཕྱིར་ལོག་བྱེད་དགོས། ClassName.StrongestExtensionName. གལ་ཏེ་ཚད་གཞི་གཉིས་སམ་དེ་ལས་མང་བ་ཞིག་ཡོད་ན་ vector ནང་ཐོག་མར་ཐོན་པ་དེ་འདེམས་དགོས། དཔེར་ན་ class དང་ extension གྱི་ vector ཞིག་ \"Slices\" ཟེར་བ་ཡིན་ན། ཁྱོད་ཚོར་ 'Slices.SEviviSliCes' 'Cheese', 'StufedF' ཟེར་བ་ཡོད་ན་ 'SviSliCes.SEviCes' 'myst:::::::myst:SEviCes:::::myst:SEviCes::::::myst:SviCes:d' (extension:Strongest_string) ཟེར་བ་ལས་ 'String_string' (<d>) ཤུགས་ཆེ་ཤོས་ཡིན་པས་ཁྱོད་ཀྱིས་ 'Slices.Slices.SliCliCliCliCes.SliCliC::myst:myst:SliC::::string:myst:SliC::string:d' (d) ཟེར་བ་ཕྱིར་སློག་དགོས། (<string:d) ཚད་གཞི་དེ་ strongest_string_string (d) ཤུགས་ཆེ་ཤོས་ཡིན་པས་ཁྱོད་ཀྱིས་ (<\"String_string_class\" (String_string_string_string\"> (String_string_string\"<\") ཤུགས་ཆེ་ཤོས་\" (<\">) ཤུགས་ཆེ་ཤོས་\" (String\"<\">) ཤུགས་ཆེ་ཤོས་\" (String\" class\"> (String\">) ཤུགས་ཆེ་ཤོས་\") ཆེད་སྒྲིག་གཞི་\"<\"<\"> (String\" strongest\"<\">\">\"<\">\">\" (String\">\">\"<\">\">\" (String\">\">\">\"<\">\"\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ཚོར་ཚིག་གཉིས་སྤྲོད་ཡོད། གལ་ཏེ་ཚིག་གཉིས་པ་ཡང་ན་དེའི་འཁོར་ལོའི་ཆ་ཤས་གང་ཞིག་ནི་ཚིག་དང་པོའི་ནང་འོག་རིམ་ཡིན་ན་ true སླར་ལོག་བྱེད་དགོས་པ་ཡོད། >>> cycpattern_check((\"abcd\"), (\"abd\")) (false) >>> cycpattern_check((\"hello\"), (\"ell\")) (true) >>> cycpattern_check(\"whassup\"), (\"psus\")) (false) >>> cycpattern_check((\"abab\"), (\"baa\")) (true) >>> cycpattern_(check\"efef\"), (\"eeff\") cy (false) >>> cycpattern_check_(\"himens\"), (\"simen\") (true)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ནི་གྲངས་ཆ་མཉམ་ཡིན་པའི་ཚིགས་སུ་བཟུང་སྟེ་གྲངས་ཆ་ཆ་དང་གྲངས་ཆ་མ་ལྡན་པའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་བའི་ཚིགས་སུ་བཟུང་གི་ཚིགས་སུ་བཟུང་།\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་ལྡན་གྲངས་ཤིག་ཡོད་ན། རོམ་གྲངས་ཀྱི་ཆ་སྙོམས་དེ་ string སྦེ་ཐོབ་ནས་ཡིག་ཆུང་དུ་ཕྱིར་ལོག་བྱེད་པ། ཚད་འཛིན་: 1 <= num <= 1000 དཔེ་གཞི་: >>> int_to_mini_roman((19)) (\"xix\") >>> int_to_mini_roman((152)) (\"clii\") >>> int_to_mini_roman((426)) (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// གཡོན་གསུམ་གྱི་རིང་ཚད་ལ་གཞི་ནས་མཚོན་ན། ཕྱོགས་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་དྲང་པོ་ཡིན་ན་ true སླར་ལོག་བྱེད། ཕྱོགས་གསུམ་གྱི་རིང་ཚད་ནི་ཟུར་གསུམ་དྲང་པོ་ཡིན་ན་ false སླར་ལོག་བྱེད། ཟུར་གསུམ་དྲང་པོ་ནི་ཟུར་གསུམ་གྱི་ཟུར་གཅིག་ནི་ཟུར་གསུམ་དྲང་པོ་ཡང་ན་ 90 ཙམ་ཡིན་པའི་ཟུར་གསུམ་ཡིན། དཔེ་གཞི་: >>> right_angle_triangle (((3), (4), (5)) (true) >>> right_angle_triangle (((1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཡིག་འབྲུ་གི་བེ་ཊར་ལ་ངོས་ལེན་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག བེ་ཊར་ནང་ཚིག་ཚིག་མི་འདྲ་བ་ཞིག་ཡོད། ཚིག་ཡིག་ལ་ཁྱད་ཆོས་ཅན་གྱི་ཡིག་འབྲུ་མང་ཤོས་ཡོད་ན་ཚིག་ཡིག་ཐོག་མར་ཐོན་པ་དེ་ཕྱིར་སློག་བྱེད་དགོས། >>> find_max{\\displaystyle {\\text{{{{{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text}}}}}}}}}}}}}}} (string) \"name\", (std::string) \"of\", (std::string) \"string\"}))) (\"string\") >>> find_max{\\text{\\text{\\text{\\text{\\text{\\text{\\text}}}}}}}\"name\", (std::string) \"string\"} (string) \"string\")) >>> find_max{\\text{\\text{\\text{\\text{{{{{{{{{{string}}}}}}}}\"string}\"string\"}\"string\"}\"}\"string\"}\"}\"string\"}\"string\"}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ནི་ལྟོ་བ་ཚ་བའི་རྭ་བ་ཞིག་ཡིན་པས་ཉིན་རེའི་ཟས་རིགས་ཆ་ཚང་བཟོ་བའི་ཆེད་ཤིང་འབྲས་མང་པོ་ཟ་དགོས་ཡོད། གལ་ཏེ་ཟས་རིགས་ཆ་ཚང་ཟ་ཟིན་པའི་རྗེས་ལ་ཤིང་འབྲས་ལྷག་ཡོད་ཀྱི་གྲངས་ཆ་ཡོད་མེད་ན། ཟས་རིགས་ལྷག་ཡོད་ཚང་མ་ཟ་ནའང་མུ་གེ་མི་འབྱུང་བའི་རྒྱུ་མཚན་ནི་ [ ཟས་རིགས་ཚང་མ་ཟ་ཟིན་པའི་རྗེས་ལ་ཤིང་འབྲས་ཚང་མའི་གྲངས་ཆ་] ཟེར་བའི་རྒྱུ་མཚན་ཡིན་པའི་དཔེ་མཚོན་ཡིན། དཔེར་ན་: >>> eat((5), (6), (10)) (std::vector<long>{(()11, (long)4}) >>> eat(4), (8), (9) (std::vector<long>{()12, ( (1})) >>> eat(1), (10), (10) (std::vector<long>{()11, (long) 0)) >>> (((2), (5) (std::vector<long>{()7, (long) 0)) V: integer number of carrots remaining that you need to eat in the stock: 1000 = = 0 ཟ་དགོས་པའི་གྲངས་ཆ་ཆ་ཚང་ཡིན།\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// སྐར་རྩིས་དང་སྐར་རྩིས་གཉིས་ལྡན་གྱི་ལག་ལེན་པ་དང་སྐར་རྩིས་ཀྱི་འཇུག་ཚུལ་ཡིན། སྐར་རྩིས་དང་པོ་ལ་གཞི་རྟེན་ཨལ་ཇི་བེར་གྱི་བྱ་གཞག་ཡོད་པ་དང་སྐར་རྩིས་གཉིས་པ་དེ་ནི་གྲངས་ཆ་མེད་ཀྱི་སྐར་རྩིས་ཡིན། སྐར་རྩིས་དང་སྐར་རྩིས་གཉིས་ལྡན་གྱི་ལག་ལེན་པ་ལས་ཨལ་ཇི་བེར་གྱི་ཚིག་དོན་བཟོས་ནས་དེའི་ངེས་དོན་ཕྱིར་སློག་བྱ་དགོས། སྐར་རྩིས་དང་སྐར་རྩིས་ཀྱི་ལག་ལེན་པ་ལས་ཨལ་ཇི་བེར་གྱི་ཚིག་དོན་བཟོས་ནས་དེའི་ངེས་དོན་ཕྱིར་སློག་བྱ་དགོས། སྐར་རྩིས་དང་སྐར་རྩིས་ཀྱི་ལག་ལེན་པ་ལས་ཨལ་ཇི་བེར་གྱི་ཚིག་དོན་བཟོས་ནས་དེའི་ངེས་དོན་ཕྱིར་སློག་བྱ་དགོས། སྐར་རྩིས་དང་སྐར་རྩིས་ཀྱི་ལག་ལེན་པ་ལས་ཨལ་ཇི་བེར་གྱི་ཚིག་དོན་བཟོས་ནས་དེའི་ངེས་དོན་ཕྱིར་སློག་བྱ་དགོས། སྐར་རྩིས་དང་སྐར་རྩིས་ཀྱི་ལག་ལེན་པ་ལས་ཨལ་ཇི་བེར་གྱི་ཚིག་དོན་ཕྱིར་སློག་བྱ་དགོས།\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ཁྱོད་ལ་ string s ཞིག་སྤྲད་ཡོད། གལ་ཏེ་ s[i] ནི་ཡིག་རྟགས་ཞིག་ཡིན་ན་ དེའི་ཡིག་ཆུང་འོག་ནས་གོང་དུ་བསྒྱུར་ནས་གཞན་ན་དེ་འདྲ་བཞག་དགོས། གལ་ཏེ་ string ནང་ཡིག་རྟགས་གང་ཡང་མེད་ན་ string དེ་ཕྱིར་བསྒྱུར་དགོས། ལས་འགན་གྱིས་ string གྱི་འབྲས་བུ་ཕྱིར་སློག་དགོས། དཔེ་གཞི་ >>> solve (((\"1234\")) (\"4321\") >>> solve (((\"ab\")) (\"AB\") >>> solve (((\"#a@C\")) (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string 'text' ཤིག་ཡོད་ན་ md5 ཧེཤི་འདྲ་མཉམ་གྱི་ཐག་པ་ཕྱིར་ལོག་བྱེད། གལ་ཏེ་ 'text' ནི་སྟོང་པ་ཡིན་ན་ None སླར་ལོག་བྱེད། >>> string_to_md5((\"Hello world\")) \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "bod_Tibt",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// འབྲས་བུ་གྲངས་ཆ་མཉམ་ a དང་ b གཉིས་ཡོད་ན། a དང་ b བར་གྱི་གྲངས་ཆ་ཆ་མཚུངས་ཕྱིར་སློག་བྱ་དགོས། དཔེར་ན།: >>> generate_integers (((2), (8)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((8), (2)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((10), (14)) (std::vector<long> ((())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]