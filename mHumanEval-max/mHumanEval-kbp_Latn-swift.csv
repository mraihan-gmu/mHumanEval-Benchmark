task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,kbp_Latn,swift,"
Ɛ-ɛjaɖɛ taa lɛ, ɛyaa mba pɛfɛyɩna ɖoŋ.// Ñɔɔzɩ se paa mayaɣ ŋga lɛ, kɛwɛna mayaɣ ŋga kɛwɛna kpata yɔ nɛ pɩɖɛɛ /// >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)
/// false
/// >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)
/// true
func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
","func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
    let sortedNumbers = numbers.sorted()
    for i in 0..<sortedNumbers.count - 1 {
        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"
HumanEval_1,kbp_Latn,swift,"
// Taawɛɛna kɩ-tɛ matʋ natʋyʋ.// Kpaŋnaŋ ndɩ ndɩ wɛna ɖama yɔɔ (paa ŋgʊ kɩ-taa lɛ, patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋɩɣna nɛ patɩŋna.// ɛlɩzɩ mba yɔ, nɛ ɛlɩzɩ-wɛ nɛ ɛlɩzɩ-wɛ nɛ ɛcɛlɩ-wɛ ɛ-tɛ matrix. // Tʋma ana a-taa lɛ, ŋpɩzɩɣ ŋma tɔm nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ nɛ ŋɖʋ-tʋ/// >>> separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"")
/// [""()"", ""(())"", ""(()())""]
func separate_paren_groups(paren_string: String) -> [String] {
","func separate_paren_groups(paren_string: String) -> [String] {
    var results = [String]()
    var currentGroup = """"
    var balance = 0

    for char in paren_string {
        // Ignore spaces
        if char == "" "" {
            continue
        }
        
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }

        currentGroup.append(char)

        if balance == 0 && !currentGroup.isEmpty {
            results.append(currentGroup)
            currentGroup = """"
        }
    }
    
    return results
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(separate_paren_groups(paren_string: ""(()()) ((())) () ((())()())"") == [""(()())"", ""((()))"", ""()"", ""((())()())""])
assert(separate_paren_groups(paren_string: ""() (()) ((())) (((())))"") == [""()"", ""(())"", ""((()))"", ""(((())))""])
assert(separate_paren_groups(paren_string: ""(()(())((())))"") == [""(()(())((())))""])
assert(separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"") == [""()"", ""(())"", ""(()())""])"
HumanEval_2,kbp_Latn,swift,"
// Pɩsɩɣnɩ-ɖʋ nɛ ɖɩna ɛzɩma ɖɩkpaɣ tɔm piye nɖɩ nɛ ɖɩpɩsɩ tɔm piye nɖɩ ɖɩ-taa tɔm piye wɛɛ yɔ. (Paa ɛzɩmtaa lɛ, hɔɔlʋʋ ŋgʋ kɩkazaa yɔ, kɩkɩlɩɣ 1.)Pɩtɛ lɛ, ɖɩnaɣ se ɛyʊ ɛ-ñʊʊ taa wɛtʊ nɛ ɛ-tɛ ɛyʊ yɔɔ wɛtʊ nɛ ɛ-tɛ ɛyʊ yɔɔ wɛtʊ nɛ ɛ-tɛ ɛyʊ yɔɔ wɛtʊ nɛ ɛ-tɛ ɛyʊ yɔɔ wɛtʊ.// Yee paha-ɩ ɛ-tɛ ɛyʊ kʊyʊmʊʊ kɔyɔ, papɩzɩɣ pɛtɛyɩ-ɩ nɛ /// >>> truncate_number(number: 3.5)
/// 0.5
func truncate_number(number: Double) -> Double {
","func truncate_number(number: Double) -> Double {
    return number - Double(Int(number))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(truncate_number(number: 3.5) == 0.5)
assert(truncate_number(number: 1.25) == 0.25)
assert(truncate_number(number: 123.0) == 0.0)"
HumanEval_3,kbp_Latn,swift,"
Pɩtɩkɛ mbʋ yɔ, pɩkaɣ pɩsʋʋ cɛtɩm.Pɩwɛɛ se ŋtɩlɩ se paa ɛzɩmtaa lɛ, liidiye nɖɩ ŋwɛna yɔ, ɖɩtɩtalɩ-ɖɩ.Ŋpɩzɩɣ ŋlɩzɩ liidiye naɖɩyɛ nɛ ŋɖʋ-ɖɩ ña-kɩhɛyʋʋ taa./// >>> below_zero(operations: [1, 2, 3])
/// false
/// >>> below_zero(operations: [1, 2, -4, 5])
/// true
func below_zero(operations: [Int]) -> Bool {
","func below_zero(operations: [Int]) -> Bool {
    var balance = 0
    for operation in operations {
        balance += operation
        if balance < 0 {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_zero(operations: [] as [Int]) == false)
assert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)
assert(below_zero(operations: [1, 2, -4, 5, 6]) == true)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)
assert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"
HumanEval_4,kbp_Latn,swift,"
MAD = average. x - x_mean. // kɩ-tɛ tɔm nɛ kɩ-tɛ cɛcɛsɩ (nɛ ɖɩ-taa lɛ, kɩ-tɛ cɛcɛsɩ): // Mʊntʊsʊʊ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ// kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ// Pɩcɔ nɛ ɖɩtɩlɩ ɛzɩma ɖɩkpaɣ tɔmpiye nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ lɛ, ɖɩnaɣ se ɖɩ-tɛ lɛɣzʋʋ kɩlɩna wɛʊ ɛzɩ pɩpɔzʋʋ yɔ./// >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])
/// 1.0
func mean_absolute_deviation(numbers: [Double]) -> Double {
","func mean_absolute_deviation(numbers: [Double]) -> Double {
    guard !numbers.isEmpty else { return 0.0 }
    
    let mean = numbers.reduce(0.0, +) / Double(numbers.count)
    let absoluteDifferences = numbers.map { abs($0 - mean) }
    let mad = absoluteDifferences.reduce(0.0, +) / Double(absoluteDifferences.count)
    
    return mad
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"
HumanEval_5,kbp_Latn,swift,"
// Ɖɩcɔna kɔyɔ, ɖɩnaɣ se paa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye./// >>> intersperse(numbers: [] as [Int], delimeter: 4)
/// [] as [Int]
/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)
/// [1, 4, 2, 4, 3]
func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
","func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
    guard !numbers.isEmpty else { return [] }
    
    var result: [Int] = []
    
    for number in numbers {
        result.append(number)
        result.append(delimeter)
    }
    
    // Remove the last added delimiter
    result.removeLast()
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])
assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])
assert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
HumanEval_6,kbp_Latn,swift,"
// Ɖɩkpaɣ ɛzɩ (() (()) yɔ, pɩtalɩɣ hɔɔlɩŋ naalɛ nɛ ((())) lɛ, hɔɔlɩŋ naadozo. // Paa samaɣ ŋga lɛ, kalɩzɩ ka-taa tɔm kɩcɛyɩtʋ ndʋ tɩ-taa pamaɣ-tʋ yɔ.// Tʊma ana a-taa lɛ, pɩlɩna tɔmpiye nɖɩ ɖɩ-taa paɖʊ-tʊ nɛ hɔɔlɩŋ ndɩ ndɩ nɛ pɩsa nɛ patɩlɩ-tʊ nɛ pɩtaatasɩ pɩsʋʋ pɩ-taa./// >>> parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"")
/// [2, 3, 1, 3]
func parse_nested_parens(paren_string: String) -> [Int] {
","func parse_nested_parens(paren_string: String) -> [Int] {
    let groups = paren_string.split(separator: "" "")
    var depths: [Int] = []
    
    for group in groups {
        var maxDepth = 0
        var currentDepth = 0
        
        for char in group {
            if char == ""("" {
                currentDepth += 1
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == "")"" {
                currentDepth -= 1
            }
        }
        
        depths.append(maxDepth)
    }
    
    return depths
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"") == [2, 3, 1, 3])
assert(parse_nested_parens(paren_string: ""() (()) ((())) (((())))"") == [1, 2, 3, 4])
assert(parse_nested_parens(paren_string: ""(()(())((())))"") == [4])"
HumanEval_7,kbp_Latn,swift,"
// Wɩlɩɣ se pɩtɛŋna nɛ pɩtɛ lɛ, ŋpɩzɩɣ ŋlɩzɩ tɔm kɩfatʋ natʋyʋ nɛ ŋsɩɩ tɩ-taa./// >>> filter_by_substring(strings: [] as [String], substring: ""a"")
/// [] as [String]
/// >>> filter_by_substring(strings: [""abc"", ""bacd"", ""cde"", ""array""], substring: ""a"")
/// [""abc"", ""bacd"", ""array""]
func filter_by_substring(strings: [String], substring: String) -> [String] {
","func filter_by_substring(strings: [String], substring: String) -> [String] {
    return strings.filter { $0.contains(substring) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_substring(strings: [] as [String], substring: ""john"") == [] as [String])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xx"") == [""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""grunt"", ""trumpet"", ""prune"", ""gruesome""], substring: ""run"") == [""grunt"", ""prune""])"
HumanEval_8,kbp_Latn,swift,"
// Pɩwɛɛ se kɩ-tɛ kɩjɛyʊʊ ɛwɛɛ ɛzɩ 0 nɛ kɩ-tɛ kɩjɛyʊʊ wɛɛ ɛzɩ 1.// Pɩcɔ nɛ ɖɩna ɛyʊ ɛ-tɛ ɛyʊtʊ lɛ, ɖɩpɩsɩɣ ɛyʊ ɛ-tɛ ɛyʊtʊ nɛ ɛ-tɛ ɛyʊtʊ lɛɛtʊ./// >>> sum_product(numbers: [] as [Int])
/// (0, 1)
/// >>> sum_product(numbers: [1, 2, 3, 4])
/// (10, 24)
func sum_product(numbers: [Int]) -> (Int, Int) {
","func sum_product(numbers: [Int]) -> (Int, Int) {
    let sum = numbers.reduce(0, +)
    let product = numbers.reduce(1, *)
    return (sum, product)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_product(numbers: [] as [Int]) == (0, 1))
assert(sum_product(numbers: [1, 1, 1]) == (3, 1))
assert(sum_product(numbers: [100, 0]) == (100, 0))
assert(sum_product(numbers: [3, 5, 7]) == (15, 105))
assert(sum_product(numbers: [10]) == (10, 10))"
HumanEval_9,kbp_Latn,swift,"
Pɩtɛ lɛ, ŋnaɣ se:// Pɩlɩna ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ, ɛyʊ yɔɔ lɛ./// >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])
/// [1, 2, 3, 3, 3, 4, 4]
func rolling_max(numbers: [Int]) -> [Int] {
","func rolling_max(numbers: [Int]) -> [Int] {
    var result = [Int]()
    var currentMax: Int? = nil
    for number in numbers {
        if let max = currentMax {
            currentMax = max > number ? max : number
        } else {
            currentMax = number
        }
        result.append(currentMax!)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rolling_max(numbers: [] as [Int]) == [] as [Int])
assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])
assert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
HumanEval_10,kbp_Latn,swift,"
// - Tɩŋna nɛ ŋtɛzɩna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye palindromik yɔ. // - Ñɩnɩɣ tɔmpiye nɖɩ ɖɩ-tɛ postfix kɩɖaɣlʋʋ nɛ ɖɩ-taa lɛ palindrome. // Pɩtɛ maɣzɩm taa lɛ, tɔmpiye nɖɩ ɖɩ-taa tɔm ɖɩlɩna yɔ ɖɩfɛyɩ kaɖɛ: // Ñɩnɩ palindrome kɩpɩɣlʋʋ ŋgʋ kɩpaɣzɩɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ. /// >>> make_palindrome(string: """")
/// """"
/// >>> make_palindrome(string: ""cat"")
/// ""catac""
/// >>> make_palindrome(string: ""cata"")
/// ""catac""
func make_palindrome(string: String) -> String {
","func make_palindrome(string: String) -> String {
    func isPalindrome(_ s: String) -> Bool {
        return s == String(s.reversed())
    }
    
    if string.isEmpty || isPalindrome(string) {
        return string
    }
    
    for i in stride(from: string.count, through: 0, by: -1) {
        let suffixIndex = string.index(string.startIndex, offsetBy: i)
        let suffix = String(string[suffixIndex..<string.endIndex])
        if isPalindrome(suffix) {
            let prefix = String(string[string.startIndex..<suffixIndex])
            return string + String(prefix.reversed())
        }
    }
    
    return string
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_palindrome(string: """") == """")
assert(make_palindrome(string: ""x"") == ""x"")
assert(make_palindrome(string: ""xyz"") == ""xyzyx"")
assert(make_palindrome(string: ""xyx"") == ""xyx"")
assert(make_palindrome(string: ""jerry"") == ""jerryrrej"")"
HumanEval_11,kbp_Latn,swift,"
// Palakɩ XOR binary tɔm nɛ pɩpɩsɩɣ ɖɔɖɔ pɩ-tɛ pɩlɩʋ ɛzɩ tɔmpiye yɔ. // Pɩtɛ lɛ, a nɛ b wɛna 1 nɛ 0 pɛ-hɛkʊ taa./// >>> string_xor(a: ""010"", b: ""110"")
/// ""100""
func string_xor(a: String, b: String) -> String {
","func string_xor(a: String, b: String) -> String {
    let charactersA = Array(a)
    let charactersB = Array(b)
    var result = """"

    for i in 0..<charactersA.count {
        let bitA = charactersA[i]
        let bitB = charactersB[i]
        
        if bitA != bitB {
            result.append(""1"")
        } else {
            result.append(""0"")
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: ""111000"", b: ""101010"") == ""010010"")
assert(string_xor(a: ""1"", b: ""1"") == ""0"")
assert(string_xor(a: ""0101"", b: ""0000"") == ""0101"")"
HumanEval_12,kbp_Latn,swift,"
Pɩtɛ lɛ, pɩpɩsɩɣ nil yee pɩtɛkɛ mayaɣ nakɛyɛ wɛna yɔ.Ɛ-tɛ tɔmpiye nɖɩ ɖɩ-taa ɛ-tɛ tɔmpiye kɩlɩna yɔ, ɖɩ-tɛ kajalaɣ ñɩnɖɛ./// >>> longest(strings: [] as [String])
/// nil
/// >>> longest(strings: [""a"", ""b"", ""c""])
/// ""a""
/// >>> longest(strings: [""a"", ""bb"", ""ccc""])
/// ""ccc""
func longest(strings: [String]) -> String? {
","func longest(strings: [String]) -> String? {
    guard !strings.isEmpty else { return nil }
    var longestString = strings[0]
    for string in strings {
        if string.count > longestString.count {
            longestString = string
        }
    }
    return longestString
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(longest(strings: [] as [String]) == nil)
assert(longest(strings: [""x"", ""y"", ""z""]) == ""x"")
assert(longest(strings: [""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]) == ""zzzz"")"
HumanEval_13,kbp_Latn,swift,"
// Ɛpɩsɩɣ ɛ-tɛ sɔsɔm taa tɔm nabʊyʊ taa ɛyʊ naalɛ a nɛ b /// >>> greatest_common_divisor(a: 3, b: 5)
/// 1
/// >>> greatest_common_divisor(a: 25, b: 15)
/// 5
func greatest_common_divisor(a: Int, b: Int) -> Int {
","func greatest_common_divisor(a: Int, b: Int) -> Int {
    if b == 0 {
        return a
    } else {
        return greatest_common_divisor(a: b, b: a % b)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(greatest_common_divisor(a: 3, b: 7) == 1)
assert(greatest_common_divisor(a: 10, b: 15) == 5)
assert(greatest_common_divisor(a: 49, b: 14) == 7)
assert(greatest_common_divisor(a: 144, b: 60) == 12)"
HumanEval_14,kbp_Latn,swift,"
// Pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-tɩŋa ɖɩlɩna tɔmpiye nɖɩ ɖɩ-taa tɔmpiye kɩsɛyɛ nɛ ɖɩkɔɔ ɖɩtalɩ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye kɩsɛyɛ wɛɛ yɔ./// >>> all_prefixes(string: ""abc"")
/// [""a"", ""ab"", ""abc""]
func all_prefixes(string: String) -> [String] {
","func all_prefixes(string: String) -> [String] {
    var prefixes: [String] = []
    for i in 1...string.count {
        let prefix = String(string.prefix(i))
        prefixes.append(prefix)
    }
    return prefixes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: """") == [] as [String])
assert(all_prefixes(string: ""asdfgh"") == [""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""])
assert(all_prefixes(string: ""WWW"") == [""W"", ""WW"", ""WWW""])"
HumanEval_15,kbp_Latn,swift,"
// Pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa wɛ nimero waa mba pɛ-tɛ wɛtʊ tɩna yɔ kpaɣ nɛ 0 nɛ pɩkɔɔ pɩtalɩ n. /// >>> string_sequence(n: 0)
/// ""0""
/// >>> string_sequence(n: 5)
/// ""0 1 2 3 4 5""
func string_sequence(n: Int) -> String {
","func string_sequence(n: Int) -> String {
    return (0...n).map { String($0) }.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_sequence(n: 0) == ""0"")
assert(string_sequence(n: 3) == ""0 1 2 3"")
assert(string_sequence(n: 10) == ""0 1 2 3 4 5 6 7 8 9 10"")"
HumanEval_16,kbp_Latn,swift,"
// Ye ŋha-ɖʋ tɔm piye naɖɩyɛ lɛ, ɖɩñɩnɩ nɛ ɖɩna se tɔmpiye nɖɩ ɖɩ-taa matʋ ndɩ ndɩ sakɩyɛ wɛɛ yaa we?/// >>> count_distinct_characters(string: ""xyzXYZ"")
/// 3
/// >>> count_distinct_characters(string: ""Jerry"")
/// 4
func count_distinct_characters(string: String) -> Int {
","func count_distinct_characters(string: String) -> Int {
    let lowercasedString = string.lowercased()
    let distinctCharacters = Set(lowercasedString)
    return distinctCharacters.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_distinct_characters(string: """") == 0)
assert(count_distinct_characters(string: ""abcde"") == 5)
assert(count_distinct_characters(string: ""abcdecadeCADE"") == 5)
assert(count_distinct_characters(string: ""aaaaAAAAaaaa"") == 1)
assert(count_distinct_characters(string: ""Jerry jERRY JeRRRY"") == 5)"
HumanEval_17,kbp_Latn,swift,"
""Nɔɔ kʋɖʋmaɣ"" - Nɔɔ kʋɖʋmaɣ ŋga kɛwɛ hɔɔlɩŋ naanza taa yɔ'O 'kadɩ ' - hɩlaɣ hɔɔlʋʋ, pɩlakɩ hɩlaɣ naalɛ.'O' - hendu tɩŋa, pɩlakɩ tam naanza.Takayaɣ nakɛyɛ yɔɔdɩ tɔm tʋnɛ:Ɛlɛ pɩtɩkɛ kɛdɛzaɣ ñɩŋga.// Ñɔ-tʋmɩyɛ lɛ se ŋñɔɔzɩ tɔmpiye ɖɩnɛ nɛ ŋpɩsɩna nimero waa mba pa-taa paa weyi ɛ-tɛ ɛ-tɛ tɔmpiye nɖɩ ɖɩ-taa yɔ.// Tʊma ana a-taa lɛ, pɩ-tɛ matʊ wɛ ɛzɩ hendu ndʊ tɩ-tɛ matʊ yɔ ASCII taa./// >>> parse_music(music_string: ""o o| .| o| o| .| .| .| .| o o"")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
","func parse_music(music_string: String) -> [Int] {
    let notes = music_string.split(separator: "" "")
    var beats: [Int] = []
    
    for note in notes {
        switch note {
        case ""o"":
            beats.append(4)
        case ""o|"":
            beats.append(2)
        case "".|"":
            beats.append(1)
        default:
            continue
        }
    }
    
    return beats
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: """") == [] as [Int])
assert(parse_music(music_string: ""o o o o"") == [4, 4, 4, 4])
assert(parse_music(music_string: "".| .| .| .|"") == [1, 1, 1, 1])
assert(parse_music(music_string: ""o| o| .| .| o o o o"") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: ""o| .| o| .| o o| o o|"") == [2, 1, 2, 1, 4, 2, 4, 2])"
HumanEval_18,kbp_Latn,swift,"
// Ñɩnɩ tam ɛzɩma pɩpɩzɩɣ nɛ pana hɔɔlɩŋ cikpeŋ weyi ɩ-taa tɔm piye naɖɩyɛ yɔ./// >>> how_many_times(string: """", substring: ""a"")
/// 0
/// >>> how_many_times(string: ""aaa"", substring: ""a"")
/// 3
/// >>> how_many_times(string: ""aaaa"", substring: ""aa"")
/// 3
func how_many_times(string: String, substring: String) -> Int {
","func how_many_times(string: String, substring: String) -> Int {
    guard !substring.isEmpty else { return 0 }
    
    var count = 0
    var startIndex = string.startIndex
    
    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {
        count += 1
        startIndex = string.index(after: range.lowerBound)
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(how_many_times(string: """", substring: ""x"") == 0)
assert(how_many_times(string: ""xyxyxyx"", substring: ""x"") == 4)
assert(how_many_times(string: ""cacacacac"", substring: ""cac"") == 4)
assert(how_many_times(string: ""john doe"", substring: ""john"") == 1)"
HumanEval_19,kbp_Latn,swift,"
// Pɩsɩɣna nɛ ŋlɩzɩ n̄ɩɣʋ ŋgʋ kɩ-taa n̄ɩʋ ŋgʋ kɩ-taa n̄ɩʋ ŋgʋ kɩ-taa n̄ɩʋ ŋgʋ kɩ-taa n̄ɩʋ ŋgʋ kɩ-taa n̄ɩʋ kɩlɩna yɔ.'Ɛzɩma ŋpɩzɩɣ ŋlɩzɩ tɔm pee kɩbana yɔ lɛ: 'Zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.'Pʋwɛ ɛzɩ '0' nɛ '9' pɛ-hɛkʊ taa./// >>> sort_numbers(numbers: ""three one five"")
/// ""one three five""
func sort_numbers(numbers: String) -> String {
","func sort_numbers(numbers: String) -> String {
    // Mapping of word numbers to digits
    let numberWords: [String: Int] = [
        ""zero"": 0,
        ""one"": 1,
        ""two"": 2,
        ""three"": 3,
        ""four"": 4,
        ""five"": 5,
        ""six"": 6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"": 9
    ]

    // Split the input string into words
    let words = numbers.split(separator: "" "")

    // Sort the words based on their corresponding number values
    let sortedWords = words.sorted { 
        numberWords[String($0)]! < numberWords[String($1)]! 
    }

    // Join the sorted words back into a single string
    return sortedWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_numbers(numbers: """") == """")
assert(sort_numbers(numbers: ""three"") == ""three"")
assert(sort_numbers(numbers: ""three five nine"") == ""three five nine"")
assert(sort_numbers(numbers: ""five zero four seven nine eight"") == ""zero four five seven eight nine"")
assert(sort_numbers(numbers: ""six five four three two one zero"") == ""zero one two three four five six"")"
HumanEval_20,kbp_Latn,swift,"
// lɛɛba nɛ ɛpɩsɩnɩ-wɛ pɩ-tɛ (ɛzɩ kɩlɩna pazɩ yɔ, kɩlɩna ɖɔʊ).// Kɩ-taa lɛ, ŋpɩzɩɣ ŋlɩzɩ nɛ ŋha-ɩ naalɛ mba pɔñɔtɩnɩ-ɩ yɔ./// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
func find_closest_elements(numbers: [Double]) -> (Double, Double) {
","func find_closest_elements(numbers: [Double]) -> (Double, Double) {
    // Sort the array to bring closest numbers next to each other
    let sortedNumbers = numbers.sorted()
    
    // Initialize variables to keep track of the smallest difference and the pair
    var minDifference = Double.greatestFiniteMagnitude
    var closestPair: (Double, Double) = (0.0, 0.0)
    
    // Iterate over the sorted numbers to find the smallest difference
    for i in 0..<sortedNumbers.count - 1 {
        let num1 = sortedNumbers[i]
        let num2 = sortedNumbers[i + 1]
        let difference = abs(num1 - num2)
        
        if difference < minDifference {
            minDifference = difference
            closestPair = (num1, num2)
        }
    }
    
    return closestPair
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))
assert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))
assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
HumanEval_21,kbp_Latn,swift,"
// mbʊ pʊyɔɔ yɔ, pʊtʊ weyi ɛkɩlɩ tɔyʊʊ yɔ ɛkaɣ pɩsʋʋ 0 nɛ weyi ɛkɩlɩ tɔyʊʊ yɔ ɛkaɣ pɩsʋʋ 1 // Ye ŋha-ɩ nimero waa (ɛzɩma pɩtalɩɣ naalɛ yɔ), ŋlabɩnɩ tʊmɩyɛ nɛ ŋlɛɣzɩ nimero waa mba yɔ, /// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])
/// [0.0, 0.25, 0.5, 0.75, 1.0]
func rescale_to_unit(numbers: [Double]) -> [Double] {
","func rescale_to_unit(numbers: [Double]) -> [Double] {
    guard numbers.count > 1 else { return numbers }
    
    let minValue = numbers.min()!
    let maxValue = numbers.max()!
    let range = maxValue - minValue
    
    guard range != 0 else {
        return numbers.map { _ in 0.0 }
    }
    
    return numbers.map { ($0 - minValue) / range }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])
assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])
assert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])
assert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])
assert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
HumanEval_22,kbp_Latn,swift,"
// Wɩlɩɣ se ɛyʊ ɛ-tɛ ɛyʊ kɩfalʊ ɛ-tɛ ɛyʊ kɩfalʊ ɛ-tɛ ɛyʊ kɩfalʊ ɛ-tɛ ɛyʊ kɩfalʊ ɛ-tɛ ɛyʊ kɩfalʊ ɛ-tɛ ɛyʊ kɩfalʊ./// >>> filter_integers(values: [""a"", 3.14, 5])
/// [5]
/// >>> filter_integers(values: [1, 2, 3, ""abc"", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])
/// [1, 2, 3]
func filter_integers(values: [AnyHashable]) -> [Int] {
","func filter_integers(values: [AnyHashable]) -> [Int] {
    return values.compactMap { $0 as? Int }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])
assert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, ""adasd""]) == [4, 9])
assert(filter_integers(values: [3, ""c"", 3, 3, ""a"", ""b""]) == [3, 3, 3])"
HumanEval_23,kbp_Latn,swift,"
// Pɩpɩsɩɣna tɔmpiye nɖɩ ɖɩ-kɩɖaʋ yɔ ɖɩ-kɩɖaʋ./// >>> strlen(string: """")
/// 0
/// >>> strlen(string: ""abc"")
/// 3
func strlen(string: String) -> Int {
","func strlen(string: String) -> Int {
    return string.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strlen(string: """") == 0)
assert(strlen(string: ""x"") == 1)
assert(strlen(string: ""asdasnakj"") == 9)"
HumanEval_24,kbp_Latn,swift,"
// Pɩsa nɛ ɖɩtɩlɩ n, ɖɩñɩnɩ n taa sɔsɔ weyi ɛkɩlɩ n yɔ, nɛ ɛtɛzɩ n yɔ./// >>> largest_divisor(n: 15)
/// 5
func largest_divisor(n: Int) -> Int {
","func largest_divisor(n: Int) -> Int {
    for i in stride(from: n / 2, to: 0, by: -1) {
        if n % i == 0 {
            return i
        }
    }
    return 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_divisor(n: 3) == 1)
assert(largest_divisor(n: 7) == 1)
assert(largest_divisor(n: 10) == 5)
assert(largest_divisor(n: 100) == 50)
assert(largest_divisor(n: 49) == 7)"
HumanEval_25,kbp_Latn,swift,"
// Pɩwɛɛ se tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.// Pɩwɛɛ se paa tɔmpiye nɖɩ lɛ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-lɛ.Pɩsɩ nɛ ŋna-ɩ kɩlɛmʋʋ yɔɔ./// >>> factorize(n: 8)
/// [2, 2, 2]
/// >>> factorize(n: 25)
/// [5, 5]
/// >>> factorize(n: 70)
/// [2, 5, 7]
func factorize(n: Int) -> [Int] {
","func factorize(n: Int) -> [Int] {
    guard n > 1 else { return [] }
    var number = n
    var factors: [Int] = []
    var divisor = 2
    
    while number >= divisor {
        while number % divisor == 0 {
            factors.append(divisor)
            number /= divisor
        }
        divisor += 1
    }
    
    return factors
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(factorize(n: 2) == [2])
assert(factorize(n: 4) == [2, 2])
assert(factorize(n: 8) == [2, 2, 2])
assert(factorize(n: 57) == [3, 19])
assert(factorize(n: 3249) == [3, 3, 19, 19])
assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])
assert(factorize(n: 20577) == [3, 19, 19, 19])
assert(factorize(n: 18) == [2, 3, 3])"
HumanEval_26,kbp_Latn,swift,"
// Ñɔɔzɩ wondu nɛ tɩwɛɛ ɛzɩ tɩ-taa yɔ.// Pɩlɩʋ taa lɛ, ɖɩlɩzɩ kɩlɛmɩŋ weyi ɩwɛ tam nabʋlɛ yɔ./// >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])
/// [1, 3, 4]
func remove_duplicates(numbers: [Int]) -> [Int] {
","func remove_duplicates(numbers: [Int]) -> [Int] {
    var elementCount = [Int: Int]()
    for number in numbers {
        elementCount[number, default: 0] += 1
    }
    return numbers.filter { elementCount[$0] == 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])
assert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
HumanEval_27,kbp_Latn,swift,"
// Pɩsa nɛ ŋpɩzɩ ŋla ŋ-takayaɣ taa tɔm lɛ, ŋlɛɣzɩ-kɛ nɛ ŋyele mayaɣ sɔsɔɔ nɛ ŋyele mayaɣ cikpelaɣ. /// >>> flip_case(string: ""Hello"")
/// ""hELLO""
func flip_case(string: String) -> String {
","func flip_case(string: String) -> String {
    return String(string.map { character in
        if character.isLowercase {
            return character.uppercased()
        } else if character.isUppercase {
            return character.lowercased()
        } else {
            return String(character)
        }
    }.joined())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: """") == """")
assert(flip_case(string: ""Hello!"") == ""hELLO!"")
assert(flip_case(string: ""These violent delights have violent ends"") == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")"
HumanEval_28,kbp_Latn,swift,"
// Ɛyʊ ɛ-tɛ tɔm kpɛlɛkʊʊ tʊmɩyɛ taa lɛ, ɛ-tɛ tɔm kpɛlɛkʊʊ tʊmɩyɛ taa lɛ, ɛ-tɛ tɔm kpɛlɛkʊʊ tʊmɩyɛ taa lɛ, ɛ-tɛ tɔm kpɛlɛkʊʊ tʊmɩyɛ taa./// >>> concatenate(strings: [] as [String])
/// """"
/// >>> concatenate(strings: [""a"", ""b"", ""c""])
/// ""abc""
func concatenate(strings: [String]) -> String {
","func concatenate(strings: [String]) -> String {
    return strings.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(concatenate(strings: [] as [String]) == """")
assert(concatenate(strings: [""x"", ""y"", ""z""]) == ""xyz"")
assert(concatenate(strings: [""x"", ""y"", ""z"", ""w"", ""k""]) == ""xyzwk"")"
HumanEval_29,kbp_Latn,swift,"
// Pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna./// >>> filter_by_prefix(strings: [] as [String], prefix: ""a"")
/// [] as [String]
/// >>> filter_by_prefix(strings: [""abc"", ""bcd"", ""cde"", ""array""], prefix: ""a"")
/// [""abc"", ""array""]
func filter_by_prefix(strings: [String], prefix: String) -> [String] {
","func filter_by_prefix(strings: [String], prefix: String) -> [String] {
    return strings.filter { $0.hasPrefix(prefix) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_prefix(strings: [] as [String], prefix: ""john"") == [] as [String])
assert(filter_by_prefix(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], prefix: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])"
HumanEval_30,kbp_Latn,swift,"
// Pɩpɩsɩɣ ɛyʊ hɔɔlɩŋ weyi ɛ-taa ɛ-taa wɛ kɩbam yɔ. /// >>> get_positive(l: [-1, 2, -4, 5, 6])
/// [2, 5, 6]
/// >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// [5, 3, 2, 3, 9, 123, 1]
func get_positive(l: [Int]) -> [Int] {
","func get_positive(l: [Int]) -> [Int] {
    return l.filter { $0 > 0 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])
assert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])
assert(get_positive(l: [-1, -2]) == [] as [Int])
assert(get_positive(l: [] as [Int]) == [] as [Int])"
HumanEval_31,kbp_Latn,swift,"
// Pɩpɩsɩɣ tɔmpiye true yee tɔmpiye nɖɩ ɖɩkɛ kajalaɣ tɔmpiye kɔyɔ, nɛ false yee pɩtɛkɛ mbʋ yɔ. /// >>> is_prime(n: 6)
/// false
/// >>> is_prime(n: 101)
/// true
/// >>> is_prime(n: 11)
/// true
/// >>> is_prime(n: 13441)
/// true
/// >>> is_prime(n: 61)
/// true
/// >>> is_prime(n: 4)
/// false
/// >>> is_prime(n: 1)
/// false
func is_prime(n: Int) -> Bool {
","func is_prime(n: Int) -> Bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    var i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_prime(n: 6) == false)
assert(is_prime(n: 101) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 13441) == true)
assert(is_prime(n: 61) == true)
assert(is_prime(n: 4) == false)
assert(is_prime(n: 1) == false)
assert(is_prime(n: 5) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 17) == true)
assert(is_prime(n: 85) == false)
assert(is_prime(n: 77) == false)
assert(is_prime(n: 255379) == false)"
HumanEval_33,kbp_Latn,swift,"
Lɩmaɣzɩyɛ nɖɩ ɖɩ-yɔɔ lɛ, ɖɩ-taa lɛ, ɛyʊ ɛ-lɩmaɣza wɛna ɛ-tɩ yɔɔ wɛʊ yɔɔ.// l' wɛ ɛzɩ l yɔ, yee ɛ-tɔm taa lɛ, ɛfɛyɩna tam nabudozo, ɛlɛ yee ɛ-tɔm taa lɛ, ɛ-tɔm taa lɛ, ɛ-tɔm taa lɛ, ɛ-tɔm taa lɛ, ɛ-tɔm taa lɛ, ɛ-tɔm wɛ ɖɔɖɔ.// Tʋma ana a-taa lɛ, pakpaɣ matrice l nɛ papɩsɩna matrice l' nɖɩ ɖɩ-taa lɛ, /// >>> sort_third(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])
/// [2, 6, 3, 4, 8, 9, 5]
func sort_third(l: [Int]) -> [Int] {
","func sort_third(l: [Int]) -> [Int] {
    // Collect indices and their values where index is divisible by 3
    var divisibleByThreeValues: [(index: Int, value: Int)] = []
    for (index, value) in l.enumerated() where index % 3 == 0 {
        divisibleByThreeValues.append((index, value))
    }
    
    // Sort the values that were at the indices divisible by 3
    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()
    
    // Create a mutable copy of original array to modify
    var result = l
    
    // Replace the sorted values back into their original indices
    for (i, sortedValue) in sortedValues.enumerated() {
        result[divisibleByThreeValues[i].index] = sortedValue
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])
assert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])
assert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"
HumanEval_34,kbp_Latn,swift,"
// Ɛpɩsɩɣ ɛyʊ yɔɔ tɔm kɩmamatʊ ndʊ tɩ-taa ɛyʊ wɛ ɛ-tɩ yɔɔ yɔ /// >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [0, 2, 3, 5, 9, 123]
func unique(l: [Int]) -> [Int] {
","func unique(l: [Int]) -> [Int] {
    return Array(Set(l)).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"
HumanEval_35,kbp_Latn,swift,"
// Pɩpɩsɩɣ ɛyʊ sɔsɔtʊ ɛ-tɛ ɛyʊtʊ taa. /// >>> max_element(l: [1, 2, 3])
/// 3
/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
func max_element(l: [Int]) -> Int {
","func max_element(l: [Int]) -> Int {
    guard let max = l.max() else {
        fatalError(""Array should not be empty"")
    }
    return max
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_element(l: [1, 2, 3]) == 3)
assert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
HumanEval_36,kbp_Latn,swift,"
// Pɩsɩɣna nɛ ɖɩna tam ɛzɩma 7 lɩzɩɣna hɔɔlɩŋ weyi ɩ-taa lɛ, 11 yaa 13 pɩzɩɣ nɛ pɩtayɩ-ɩ yɔ./// >>> fizz_buzz(n: 50)
/// 0
/// >>> fizz_buzz(n: 78)
/// 2
/// >>> fizz_buzz(n: 79)
/// 3
func fizz_buzz(n: Int) -> Int {
","func fizz_buzz(n: Int) -> Int {
    var count = 0
    for number in 0..<n {
        if number % 11 == 0 || number % 13 == 0 {
            var current = number
            while current > 0 {
                if current % 10 == 7 {
                    count += 1
                }
                current /= 10
            }
        }
    }
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fizz_buzz(n: 50) == 0)
assert(fizz_buzz(n: 78) == 2)
assert(fizz_buzz(n: 79) == 3)
assert(fizz_buzz(n: 100) == 3)
assert(fizz_buzz(n: 200) == 6)
assert(fizz_buzz(n: 4000) == 192)
assert(fizz_buzz(n: 10000) == 639)
assert(fizz_buzz(n: 100000) == 8026)"
HumanEval_37,kbp_Latn,swift,"
// nɛ l-tʊmɩyɛ nɖɩ ɖɩ-tɛ ɛyʊ yɔ, ɛlɛ ɖɩ-tɛ ɛyʊ yɔ.L' wɛ ɖɔɖɔ ɛzɩ l yɔ, yee pɩkɛ kɩkpɛdɩm kɔyɔ, kɩwɛ ɖɔɖɔ ɛzɩ l yɔ, yee pɩkɛ kɩkpɛdɩm kɔyɔ, kɩwɛ ɖɔɖɔ ɛzɩ l yɔ.// Tʋma ana a-taa lɛ, pakpaɣ matrice l nɛ papɩsɩna matrice l' nɖɩ ɖɩ-taa lɛ, /// >>> sort_even(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_even(l: [5, 6, 3, 4])
/// [3, 6, 5, 4]
func sort_even(l: [Int]) -> [Int] {
","func sort_even(l: [Int]) -> [Int] {
    var evenIndicesValues = [Int]()
    
    // Collect values from even indices
    for (index, value) in l.enumerated() {
        if index % 2 == 0 {
            evenIndicesValues.append(value)
        }
    }
    
    // Sort the collected even indices values
    evenIndicesValues.sort()
    
    var result = l
    var evenIndex = 0
    
    // Replace even-indexed elements in result with sorted values
    for i in 0..<result.count {
        if i % 2 == 0 {
            result[i] = evenIndicesValues[evenIndex]
            evenIndex += 1
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])
assert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
HumanEval_39,kbp_Latn,swift,"
// prime_fib pɩlɩzɩɣ n-tɛ n̄ɩnɖɛ nɖɩ ɖɩkɛ Fibonacci n̄ɩnɖɛ nɛ ɖɩkɛ ɖɔɖɔ kajalaɣ n̄ɩnɖɛ yɔ. /// >>> prime_fib(n: 1)
/// 2
/// >>> prime_fib(n: 2)
/// 3
/// >>> prime_fib(n: 3)
/// 5
/// >>> prime_fib(n: 4)
/// 13
/// >>> prime_fib(n: 5)
/// 89
func prime_fib(n: Int) -> Int {
","func isPrime(_ num: Int) -> Bool {
    if num <= 1 { return false }
    if num <= 3 { return true }
    if num % 2 == 0 || num % 3 == 0 { return false }
    var i = 5
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}

func generateFibonacci(n: Int) -> [Int] {
    var fibs = [1, 2]
    var next = fibs[0] + fibs[1]
    while fibs.count < n || !isPrime(next) {
        fibs.append(next)
        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]
    }
    return fibs
}

func prime_fib(n: Int) -> Int {
    var count = 0
    var fibs = generateFibonacci(n: n)
    for fib in fibs {
        if isPrime(fib) {
            count += 1
            if count == n {
                return fib
            }
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_fib(n: 1) == 2)
assert(prime_fib(n: 2) == 3)
assert(prime_fib(n: 3) == 5)
assert(prime_fib(n: 4) == 13)
assert(prime_fib(n: 5) == 89)
assert(prime_fib(n: 6) == 233)
assert(prime_fib(n: 7) == 1597)
assert(prime_fib(n: 8) == 28657)
assert(prime_fib(n: 9) == 514229)
assert(prime_fib(n: 10) == 433494437)"
HumanEval_40,kbp_Latn,swift,"
// nɛ ɛ-tɛ lɛɣzʋʋ wɛ zero, nɛ ɛ-tɛ lɛɣzʋʋ wɛ cɛtɩm. // pɩpɩsɩɣ tɔmpiye true yee tɔmpiye nɖɩ ɖɩ-taa wɛ tɔmpiye ndɩ ndɩ naadozo yɔ nɛ // triple_sum_to_zero kpaɣ ɛyʊ ɛ-tɛ intɛrɩjɛrɩ waa ɛzɩ ɛ-tɛ tɔm yɔ. /// >>> triples_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(l: [1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(l: [1])
/// false
func triples_sum_to_zero(l: [Int]) -> Bool {
","func triples_sum_to_zero(l: [Int]) -> Bool {
    let count = l.count
    if count < 3 {
        return false
    }
    
    let sortedArray = l.sorted()
    
    for i in 0..<count - 2 {
        var left = i + 1
        var right = count - 1
        
        while left < right {
            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]
            if currentSum == 0 {
                return true
            } else if currentSum < 0 {
                left += 1
            } else {
                right -= 1
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)
assert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)
assert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)
assert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)
assert(triples_sum_to_zero(l: [1]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)
assert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"
HumanEval_41,kbp_Latn,swift,"
// Tʋma ana a-taa lɛ, pakpaɣna nɛ palɩzɩna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye. Pa-nʋmɔʋ ɖɔm wɛ ɛzɩ paatɛm talʋʋ ɖama yɔ.Ɛlɛ, lɔɔɖa ana awɛ ɖoŋ nɛ awɛ ɖɔɖɔ ɖoŋ pɩdɩɩfɛyɩ, nɛ pʋyɔɔ lɛ, awɛɛ nɛ awɛɛ nɛ awɛɛ.Alɩwaatʋ ndʋ lɔɔɖɩyɛ nɖɩ ɖɩɖɛɣ nɛ ɖɩlɩɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩkɔŋʋʋ lɔɔɖɩyɛ nɖɩ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ yɔ.Lɔɔɖa tɩŋa wɛna ɖoŋ kʋɖʋmʋʋ nɛ payaɣ-yɛ se lɔɔɖa naalɛ.Lɔɔɖa naalɛ wena awɛ poliŋ yɔ, a-naalɛ a-taa lɛ, lɔɔɖa wena awɛ poliŋ yɔ, a-naalɛ a-taa lɛ, lɔɔɖa wena awɛ poliŋ yɔ, a-naalɛ a-taa lɛ, lɔɔɖa wena awɛ poliŋ yɔ.lɔɔɖa n wɛɛ nɛ pɔɖɔŋ nɛ pɛɖɛɣna n-nɩmɩyɛ nɛ n-nɩmɩyɛ.Maɣzɩ se ŋwɛ habɩyɛ nɖɩ ɖɩtɩŋʋʋ camɩyɛ yɔ ɖɩ-yɔɔ.func car_race_collision(n: Int) -> Int {
","func car_race_collision(n: Int) -> Int {
    return n
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(car_race_collision(n: 2) == 4)
assert(car_race_collision(n: 3) == 9)
assert(car_race_collision(n: 4) == 16)
assert(car_race_collision(n: 8) == 64)
assert(car_race_collision(n: 10) == 100)"
HumanEval_42,kbp_Latn,swift,"
// Pɩpɩsɩɣ matriki nɛ ɛ-ñʊʊ mayaɣ lɛɣza 1. /// >>> incr_list(l: [1, 2, 3])
/// [2, 3, 4]
/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [6, 4, 6, 3, 4, 4, 10, 1, 124]
func incr_list(l: [Int]) -> [Int] {
","func incr_list(l: [Int]) -> [Int] {
    return l.map { $0 + 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(incr_list(l: [] as [Int]) == [] as [Int])
assert(incr_list(l: [3, 2, 1]) == [4, 3, 2])
assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
HumanEval_43,kbp_Latn,swift,"
// nɛ ɛ-tɛ lɛɣzʋʋ wɛ zero, nɛ ɛ-tɛ lɛɣzʋʋ wɛ cɛtɩm. // pɩpɩsɩɣ tɔmpiye true yee ɛyʊ ɛ-tɛ tɔmpiye nɖɩ ɖɩ-taa ɛ-tɛ tɔmpiye naalɛ wɛ ndɩ nɛ ɖama yɔ.// pairs_sum_to_zero kpaɣ ɛyʊ ɛ-tɛ ɛyʊtʊ ndɩ ndɩ ɛzɩ ɛ-tɛ ɛyʊtʊ yɔ. /// >>> pairs_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(l: [1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(l: [1])
/// false
func pairs_sum_to_zero(l: [Int]) -> Bool {
","func pairs_sum_to_zero(l: [Int]) -> Bool {
    var set = Set<Int>()
    for num in l {
        if set.contains(-num) {
            return true
        }
        set.insert(num)
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)
assert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)
assert(pairs_sum_to_zero(l: [1]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"
HumanEval_44,kbp_Latn,swift,"
// kɩlɩna 10 yɔ. // pɩpɩsɩɣ ɛ-tɛ tɔmpiye lɩmaɣzɩyɛ pɩtɛ lɛɣzɩtʋ. // Pɩsɩ takayɩhayʋʋ kɩsɔzɩŋ x ñɩŋgʋ nɛ ŋyele takayɩhayʋʋ kɩsɔzɩŋ. /// >>> change_base(x: 8, base: 3)
/// ""22""
/// >>> change_base(x: 8, base: 2)
/// ""1000""
/// >>> change_base(x: 7, base: 2)
/// ""111""
func change_base(x: Int, base: Int) -> String {
","func change_base(x: Int, base: Int) -> String {
    guard base > 1 && base < 10 else {
        return """"
    }
    
    var number = x
    var result = """"
    
    repeat {
        let remainder = number % base
        result = ""\(remainder)"" + result
        number /= base
    } while number > 0
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(change_base(x: 8, base: 3) == ""22"")
assert(change_base(x: 9, base: 3) == ""100"")
assert(change_base(x: 234, base: 2) == ""11101010"")
assert(change_base(x: 16, base: 2) == ""10000"")
assert(change_base(x: 8, base: 2) == ""1000"")
assert(change_base(x: 7, base: 2) == ""111"")
assert(change_base(x: 2, base: 3) == ""2"")
assert(change_base(x: 3, base: 4) == ""3"")
assert(change_base(x: 4, base: 5) == ""4"")
assert(change_base(x: 5, base: 6) == ""5"")
assert(change_base(x: 6, base: 7) == ""6"")
assert(change_base(x: 7, base: 8) == ""7"")"
HumanEval_45,kbp_Latn,swift,"
// Ɖɩcɔna kɔyɔ, ɛ-hɛkʊ taa ɛ-ɖaɣlakɩŋ nɛ ɛ-tɛ yuŋ pɩlɩna pʊtʊnaa mba ɛyʊ wɛna yɔ pɔ-yɔɔ./// >>> triangle_area(a: 5, h: 3)
/// 7.5
func triangle_area(a: Int, h: Int) -> Double {
","func triangle_area(a: Int, h: Int) -> Double {
    return 0.5 * Double(a) * Double(h)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 5, h: 3) == 7.5)
assert(triangle_area(a: 2, h: 2) == 2.0)
assert(triangle_area(a: 10, h: 8) == 40.0)"
HumanEval_46,kbp_Latn,swift,"
// Mentendi-mɩ se ɩma tʋmɩyɛ naɖɩyɛ nɛ ɖɩpɩzɩ ɖɩkalɩ fib4 hɔɔlɩŋ n̄ɩŋgʋ. Ɩtaalakɩ tʋmɩyɛ nɛ tɔm kɩfatʋ. Fɛyɩtʊ ndʊ tɩ-taa lɛ, pʊtɔbʊʊ se fɩyɩtʊ ndʊ tɩ-taa wɛ pʊtʊnaa mba pɛfɛyɩ yɔ nɛ pɩtasɩna fɩyɩtʊ ndʊ tɩ-taa wɛ pʊtʊnaa mba pɛfɛyɩ yɔ.(Cɔnɩ tayʋʋ 4)(Cɔnɩ tayʋʋ 4)(Cɔnɩ tayʋʋ yɔɔ kɔɔnɔɔ tɔm ñʋʋ.)(Cɔnɩ tayʋʋ yɔɔ kɔɔnɔɔ tɔm ñʋʋ.)Fib4 kɛna Fibbonacci tɛ kʊyʊmʊʊ ŋgʊ kɩ-tɛ kʊyʊmʊʊ tɔm nɛ kɩ-tɛ kʊyʊmʊʊ tɔm./// >>> fib4(n: 5)
/// 4
/// >>> fib4(n: 6)
/// 8
/// >>> fib4(n: 7)
/// 14
func fib4(n: Int) -> Int {
","func fib4(n: Int) -> Int {
    if n == 0 || n == 1 || n == 3 {
        return 0
    } else if n == 2 {
        return 2
    }
    
    var fibs = [0, 0, 2, 0]
    
    for i in 4...n {
        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]
        fibs.append(nextFib)
    }
    
    return fibs[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib4(n: 5) == 4)
assert(fib4(n: 8) == 28)
assert(fib4(n: 10) == 104)
assert(fib4(n: 12) == 386)"
HumanEval_47,kbp_Latn,swift,"
// Pɩpɩsɩɣ hɔɔlɩŋ weyi ɩwɛ matriki l taa yɔ, ɩ-hɛkʊ taa. /// >>> median(l: [3, 1, 2, 4, 5])
/// 3
/// >>> median(l: [-10, 4, 6, 1000, 10, 20])
/// 15.0
func median(l: [Int]) -> Double {
","func median(l: [Int]) -> Double {
    let sorted = l.sorted()
    let count = sorted.count
    if count % 2 == 0 {
        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2.0
    } else {
        return Double(sorted[count / 2])
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(median(l: [3, 1, 2, 4, 5]) == 3)
assert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)
assert(median(l: [5]) == 5)
assert(median(l: [6, 5]) == 5.5)
assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
HumanEval_48,kbp_Latn,swift,"
// Ɛcɔŋna se tɔmpiye nɖɩ ɖɩ-taa pama tɔm yɔ, ɖɩkɛ palindrome yaa we ?/// >>> is_palindrome(text: """")
/// true
/// >>> is_palindrome(text: ""aba"")
/// true
/// >>> is_palindrome(text: ""aaaaa"")
/// true
/// >>> is_palindrome(text: ""zbcd"")
/// false
func is_palindrome(text: String) -> Bool {
","func is_palindrome(text: String) -> Bool {
    return text == String(text.reversed())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: """") == true)
assert(is_palindrome(text: ""aba"") == true)
assert(is_palindrome(text: ""aaaaa"") == true)
assert(is_palindrome(text: ""zbcd"") == false)
assert(is_palindrome(text: ""xywyx"") == true)
assert(is_palindrome(text: ""xywyz"") == false)
assert(is_palindrome(text: ""xywzx"") == false)"
HumanEval_49,kbp_Latn,swift,"
// Pɩpɩsɩɣ 2^n modulo p (ɩtɩlɩɣ nimerikɩwaa). /// >>> modp(n: 3, p: 5)
/// 3
/// >>> modp(n: 1101, p: 101)
/// 2
/// >>> modp(n: 0, p: 101)
/// 1
/// >>> modp(n: 3, p: 11)
/// 8
/// >>> modp(n: 100, p: 101)
/// 1
func modp(n: Int, p: Int) -> Int {
","func modp(n: Int, p: Int) -> Int {
    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(modp(n: 3, p: 5) == 3)
assert(modp(n: 1101, p: 101) == 2)
assert(modp(n: 0, p: 101) == 1)
assert(modp(n: 3, p: 11) == 8)
assert(modp(n: 100, p: 101) == 1)
assert(modp(n: 30, p: 5) == 4)
assert(modp(n: 31, p: 5) == 3)"
HumanEval_51,kbp_Latn,swift,"
// remove_vowels kɛna tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩfɛyɩna tɔmpiye yɔ. /// >>> remove_vowels(text: """")
/// """"
/// >>> remove_vowels(text: ""abcdef"")
/// ""bcdf""
/// >>> remove_vowels(text: ""aaaaa"")
/// """"
/// >>> remove_vowels(text: ""aaBAA"")
/// ""B""
/// >>> remove_vowels(text: ""zbcd"")
/// ""zbcd""
func remove_vowels(text: String) -> String {
","func remove_vowels(text: String) -> String {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    return String(text.filter { !vowels.contains($0) })
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_vowels(text: """") == """")
assert(remove_vowels(text: ""abcdef\nghijklm"") == ""bcdf\nghjklm"")
assert(remove_vowels(text: ""fedcba"") == ""fdcb"")
assert(remove_vowels(text: ""eeeee"") == """")
assert(remove_vowels(text: ""acBAA"") == ""cB"")
assert(remove_vowels(text: ""EcBOO"") == ""cB"")
assert(remove_vowels(text: ""ybcd"") == ""ybcd"")"
HumanEval_52,kbp_Latn,swift,"
// Pɩpɩsɩɣ true yee nimero waa tɩŋa ɩwɛ pʊcɔ t./// >>> below_threshold(l: [1, 2, 4, 10], t: 100)
/// true
/// >>> below_threshold(l: [1, 20, 4, 10], t: 5)
/// false
func below_threshold(l: [Int], t: Int) -> Bool {
","func below_threshold(l: [Int], t: Int) -> Bool {
    for number in l {
        if number >= t {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)
assert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"
HumanEval_53,kbp_Latn,swift,"
// Ɖɩkpɛndɩ hɔɔlɩŋ naalɛ x nɛ y /// >>> add(x: 2, y: 3)
/// 5
/// >>> add(x: 5, y: 7)
/// 12
func add(x: Int, y: Int) -> Int {
","func add(x: Int, y: Int) -> Int {
    return x + y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(x: 0, y: 1) == 1)
assert(add(x: 1, y: 0) == 1)
assert(add(x: 2, y: 3) == 5)
assert(add(x: 5, y: 7) == 12)
assert(add(x: 7, y: 5) == 12)"
HumanEval_54,kbp_Latn,swift,"
// Ñɩnɩ se tɔm pee naalɛ ɩwɛna masɩ kʋɖʋmsɩ yaa we. /// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"")
/// true
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabc"")
/// true
/// >>> same_chars(s0: ""dddddddabc"", s1: ""abcd"")
/// true
/// >>> same_chars(s0: ""eabcd"", s1: ""dddddddabc"")
/// false
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabce"")
/// false
/// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"")
/// false
func same_chars(s0: String, s1: String) -> Bool {
","func same_chars(s0: String, s1: String) -> Bool {
    let set0 = Set(s0)
    let set1 = Set(s1)
    return set0 == set1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"") == true)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabc"") == true)
assert(same_chars(s0: ""dddddddabc"", s1: ""abcd"") == true)
assert(same_chars(s0: ""eabcd"", s1: ""dddddddabc"") == false)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabcf"") == false)
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"") == false)
assert(same_chars(s0: ""aabb"", s1: ""aaccc"") == false)"
HumanEval_55,kbp_Latn,swift,"
// Pɩpɩsɩɣ Fibonacci n-n̄ɩŋgʋ. /// >>> fib(n: 10)
/// 55
/// >>> fib(n: 1)
/// 1
/// >>> fib(n: 8)
/// 21
func fib(n: Int) -> Int {
","func fib(n: Int) -> Int {
    if n <= 0 {
        return 0
    } else if n == 1 {
        return 1
    }
    
    var a = 0
    var b = 1
    for _ in 2...n {
        let temp = a + b
        a = b
        b = temp
    }
    return b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib(n: 10) == 55)
assert(fib(n: 1) == 1)
assert(fib(n: 8) == 21)
assert(fib(n: 11) == 89)
assert(fib(n: 12) == 144)"
HumanEval_56,kbp_Latn,swift,"
// pɩpɩsɩɣ tɔmpiye true yee paa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa lɛ.// pɩtɛ lɛ, ""<"" nɛ "">"" wɛna. /// >>> correct_bracketing(brackets: ""<"")
/// false
/// >>> correct_bracketing(brackets: ""<>"")
/// true
/// >>> correct_bracketing(brackets: ""<<><>>"")
/// true
/// >>> correct_bracketing(brackets: ""><<>"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    
    for bracket in brackets {
        if bracket == ""<"" {
            balance += 1
        } else if bracket == "">"" {
            balance -= 1
            if balance < 0 {
                return false
            }
        }
    }
    
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""<>"") == true)
assert(correct_bracketing(brackets: ""<<><>>"") == true)
assert(correct_bracketing(brackets: ""<><><<><>><>"") == true)
assert(correct_bracketing(brackets: ""<><><<<><><>><>><<><><<>>>"") == true)
assert(correct_bracketing(brackets: ""<<<><>>>>"") == false)
assert(correct_bracketing(brackets: ""><<>"") == false)
assert(correct_bracketing(brackets: ""<"") == false)
assert(correct_bracketing(brackets: ""<<<<"") == false)
assert(correct_bracketing(brackets: "">"") == false)
assert(correct_bracketing(brackets: ""<<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>><<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>>><>"") == false)"
HumanEval_57,kbp_Latn,swift,"
// Return true kɛna se, ɛyʊ wɛtʊ taa lɛ, tɩpaɣlɩɣ yaa tɩpaɣlɩɣ. /// >>> monotonic(l: [1, 2, 4, 20])
/// true
/// >>> monotonic(l: [1, 20, 4, 10])
/// false
/// >>> monotonic(l: [4, 1, 0, -10])
/// true
func monotonic(l: [Int]) -> Bool {
","func monotonic(l: [Int]) -> Bool {
    guard l.count > 1 else {
        return true
    }
    
    var increasing = true
    var decreasing = true
    
    for i in 1..<l.count {
        if l[i] > l[i - 1] {
            decreasing = false
        } else if l[i] < l[i - 1] {
            increasing = false
        }
    }
    
    return increasing || decreasing
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(monotonic(l: [1, 2, 4, 10]) == true)
assert(monotonic(l: [1, 2, 4, 20]) == true)
assert(monotonic(l: [1, 20, 4, 10]) == false)
assert(monotonic(l: [4, 1, 0, -10]) == true)
assert(monotonic(l: [4, 1, 1, 0]) == true)
assert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)
assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)
assert(monotonic(l: [9, 9, 9, 9]) == true)"
HumanEval_58,kbp_Latn,swift,"
// Ɛpɩsɩɣ ɛ-tɛ ɛyʊ kɩfalʊ weyi ɛ-tɛ ɛyʊ kɩfalʊ yɔ ɛ-tɛ ɛyʊ kɩfalʊ./// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])
/// [1, 5, 653]
/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])
/// [2, 3]
func common(l1: [Int], l2: [Int]) -> [Int] {
","func common(l1: [Int], l2: [Int]) -> [Int] {
    let set1 = Set(l1)
    let set2 = Set(l2)
    let commonElements = set1.intersection(set2)
    return Array(commonElements).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])
assert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])
assert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])
assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
HumanEval_59,kbp_Latn,swift,"
// Pɩsɩɣna nɛ ɖɩna se n > 1 tɛ lɛ, pɩtɛkɛ mbʊ payaɣ se prime yɔ./// >>> largest_prime_factor(n: 13195)
/// 29
/// >>> largest_prime_factor(n: 2048)
/// 2
func largest_prime_factor(n: Int) -> Int {
","func largest_prime_factor(n: Int) -> Int {
    var number = n
    var divisor = 2
    
    while number > 1 {
        if number % divisor == 0 {
            number /= divisor
        } else {
            divisor += 1
        }
    }
    
    return divisor
}

// Example usage:
// print(largest_prime_factor(n: 13195)) // Output: 29
// print(largest_prime_factor(n: 2048))  // Output: 2","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_prime_factor(n: 15) == 5)
assert(largest_prime_factor(n: 27) == 3)
assert(largest_prime_factor(n: 63) == 7)
assert(largest_prime_factor(n: 330) == 11)
assert(largest_prime_factor(n: 13195) == 29)"
HumanEval_60,kbp_Latn,swift,"
// sum_to_n kɛna tʋmɩyɛ nɖɩ ɖɩtɔyɩɣ 1 nɛ pɩkɔɔ pɩtalɩ n yɔ. /// >>> sum_to_n(n: 30)
/// 465
/// >>> sum_to_n(n: 100)
/// 5050
/// >>> sum_to_n(n: 5)
/// 15
/// >>> sum_to_n(n: 10)
/// 55
/// >>> sum_to_n(n: 1)
/// 1
func sum_to_n(n: Int) -> Int {
","func sum_to_n(n: Int) -> Int {
    return (n * (n + 1)) / 2
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_to_n(n: 1) == 1)
assert(sum_to_n(n: 6) == 21)
assert(sum_to_n(n: 11) == 66)
assert(sum_to_n(n: 30) == 465)
assert(sum_to_n(n: 100) == 5050)"
HumanEval_61,kbp_Latn,swift,"
// pɩpɩsɩɣ tɔmpiye true yee paa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa lɛ.// pɩlɩʋ taa lɛ, tɔmpiye "" ("") nɛ "" ("") wɛna./// >>> correct_bracketing(brackets: ""("")
/// false
/// >>> correct_bracketing(brackets: ""()"")
/// true
/// >>> correct_bracketing(brackets: ""(()())"")
/// true
/// >>> correct_bracketing(brackets: "")(()"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    for char in brackets {
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""()"") == true)
assert(correct_bracketing(brackets: ""(()())"") == true)
assert(correct_bracketing(brackets: ""()()(()())()"") == true)
assert(correct_bracketing(brackets: ""()()((()()())())(()()(()))"") == true)
assert(correct_bracketing(brackets: ""((()())))"") == false)
assert(correct_bracketing(brackets: "")(()"") == false)
assert(correct_bracketing(brackets: ""("") == false)
assert(correct_bracketing(brackets: ""(((("") == false)
assert(correct_bracketing(brackets: "")"") == false)
assert(correct_bracketing(brackets: ""(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())())(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())()))()"") == false)"
HumanEval_62,kbp_Latn,swift,"
// Pɩpɩsɩ polinomii kʋnɛ kɩ-tɛ derivative nɛ kɩwɛna kɩwɛʋ ɖɔɖɔ. // xs[0] + xs[1] * x + xs[2] * x^2 + .... // xs kɛna polynôme taa tɔmpiye naɖɩyɛ. /// >>> derivative(xs: [3, 1, 2, 4, 5])
/// [1, 4, 12, 20]
/// >>> derivative(xs: [1, 2, 3])
/// [2, 6]
func derivative(xs: [Int]) -> [Int] {
","func derivative(xs: [Int]) -> [Int] {
    guard xs.count > 1 else { return [] }
    var result: [Int] = []
    for i in 1..<xs.count {
        result.append(xs[i] * i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])
assert(derivative(xs: [1, 2, 3]) == [2, 6])
assert(derivative(xs: [3, 2, 1]) == [2, 2])
assert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])
assert(derivative(xs: [1]) == [] as [Int])"
HumanEval_63,kbp_Latn,swift,"
// Mentendi-mɩ se ɩma tʋmɩyɛ naɖɩyɛ nɛ ɖɩpɩzɩ ɖɩkalɩ ɛ-tɛ n-n̄ɩŋgʋ ŋgʋ kɩwɛ nimbrɩ waa ndɩ ndɩ taa yɔ.Fibɔrɩ nɛ fɩrɩdɩnaa mba pɛtɛyɩɣ ɖama yɔFibib (f) = 1(Cɔnɩ tayʋʋ yɔɔ kɔɔnɔɔ tɔm kɩsɔzɩtʋ.)Fibib (f) == 0 FibFib n̄ɩnʋʋ n̄ɩnʋʋ wɛ ɛzɩ Fibbonacci n̄ɩnʋʋ yɔ nɛ pama-kʋ nɛ tɔm pee ana yɔ:/// >>> fibfib(n: 1)
/// 0
/// >>> fibfib(n: 5)
/// 4
/// >>> fibfib(n: 8)
/// 24
func fibfib(n: Int) -> Int {
","func fibfib(n: Int) -> Int {
    if n == 0 || n == 1 {
        return 0
    }
    if n == 2 {
        return 1
    }
    
    var fibfibNums = [0, 0, 1]
    
    for i in 3...n {
        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]
        fibfibNums.append(nextFibFib)
    }
    
    return fibfibNums[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fibfib(n: 2) == 1)
assert(fibfib(n: 1) == 0)
assert(fibfib(n: 5) == 4)
assert(fibfib(n: 8) == 24)
assert(fibfib(n: 10) == 81)
assert(fibfib(n: 12) == 274)
assert(fibfib(n: 14) == 927)"
HumanEval_64,kbp_Latn,swift,"
// Kɩɖaʋ: // nɔɔ ŋga ka-taa tɔm pee lɩnaa yɔ, ɛlɛ, tɔm pee wena awɛ tɔm pee wena a-taa tɔm pee tɛm yɔ, a-taa ɖeke. 'Ɛzɩma pamaɣna 'a' nɛ 'e' nɛ 'i' nɛ 'o' nɛ 'u' yɔ, mbʋ ɖɔɖɔ pamaɣna 'y' nɛ 'a' nɛ 'e' nɛ 'i' nɛ 'o' nɛ 'u' nɛ 'y' nɛ 'a' nɛ 'a' nɛ 'u'.Ɛ-tɛ tɔm piye nɖɩ ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ yɔ, ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ.// Maʋ tʋmɩyɛ nɖɩ payaɣ se vowels_count yɔ ɖɩ-taa tɔmpiye nɖɩ ɖɩwɩlɩɣ se /// >>> vowels_count(s: ""abcde"")
/// 2
/// >>> vowels_count(s: ""ACEDY"")
/// 3
func vowels_count(s: String) -> Int {
","func vowels_count(s: String) -> Int {
    guard !s.isEmpty else { return 0 }
    
    let vowels = Set(""aeiouAEIOU"")
    var count = 0
    let characters = Array(s)
    
    for i in 0..<characters.count {
        let char = characters[i]
        
        if vowels.contains(char) {
            count += 1
        } else if char == ""y"" || char == ""Y"" {
            if i == characters.count - 1 {
                count += 1
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(vowels_count(s: ""abcde"") == 2)
assert(vowels_count(s: ""Alone"") == 3)
assert(vowels_count(s: ""key"") == 2)
assert(vowels_count(s: ""bye"") == 1)
assert(vowels_count(s: ""keY"") == 2)
assert(vowels_count(s: ""bYe"") == 1)
assert(vowels_count(s: ""ACEDY"") == 3)"
HumanEval_65,kbp_Latn,swift,"
// Yee shift > nimero waa kɔyɔ, pɩpɩsɩɣ nimero waa mba pɛlɛɣzɩ-wɛ yɔ. // nɛ pɩpɩsɩɣ pɩ-tɛ lɩmaɣzɩyɛ ɛzɩ tɔmpiye yɔ. // Ñɩɣtʊ taa lɛ, pɛlɛzɩɣ x tam nabʊyʊ taa, pɛlɛzɩɣ-kʊ nɛ kɩ-yɔɔ nɛ kɩ-yɔɔ./// >>> circular_shift(x: 12, shift: 1)
/// ""21""
/// >>> circular_shift(x: 12, shift: 2)
/// ""12""
func circular_shift(x: Int, shift: Int) -> String {
","func circular_shift(x: Int, shift: Int) -> String {
    let digits = Array(String(x))
    let count = digits.count
    
    // If shift is greater than the number of digits, return the digits reversed
    if shift >= count {
        return String(digits.reversed())
    }
    
    // Calculate the actual shift needed by using modulo operation
    let actualShift = shift % count
    
    // Perform the circular shift to the right
    let splitIndex = count - actualShift
    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]
    
    return String(shiftedDigits)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(circular_shift(x: 100, shift: 2) == ""001"")
assert(circular_shift(x: 12, shift: 2) == ""12"")
assert(circular_shift(x: 97, shift: 8) == ""79"")
assert(circular_shift(x: 12, shift: 1) == ""21"")
assert(circular_shift(x: 11, shift: 101) == ""11"")"
HumanEval_66,kbp_Latn,swift,"
// Kɩɖaŋ: ASCII mayaɣ// Ma tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye sɔsɔyɛ wɛna yɔ ɖɩ-tɛ tɔmpiye ɖeke yɔ.Tʋma wena ŋlakɩ yɔ/// >>> digitSum(s: """")
/// 0
/// >>> digitSum(s: ""abAB"")
/// 131
/// >>> digitSum(s: ""abcCd"")
/// 67
/// >>> digitSum(s: ""helloE"")
/// 69
/// >>> digitSum(s: ""woArBld"")
/// 131
/// >>> digitSum(s: ""aAaaaXa"")
/// 153
func digitSum(s: String) -> Int {
","func digitSum(s: String) -> Int {
    var sum = 0
    for character in s {
        if character.isUppercase {
            sum += Int(character.asciiValue ?? 0)
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: """") == 0)
assert(digitSum(s: ""abAB"") == 131)
assert(digitSum(s: ""abcCd"") == 67)
assert(digitSum(s: ""helloE"") == 69)
assert(digitSum(s: ""woArBld"") == 131)
assert(digitSum(s: ""aAaaaXa"") == 153)
assert(digitSum(s: "" How are yOu?"") == 151)
assert(digitSum(s: ""You arE Very Smart"") == 327)"
HumanEval_67,kbp_Latn,swift,"
// nɛ pɩcɔ nɛ pɩtalɩɣ: // ɖaɣ taa lɛ, pɩpɩsɩɣ mango pee wena awɛ ɖaɣ taa yɔ a-tɛ akɔnta. // pomegranates nɛ pommes nɛ nimero entier ŋgʋ kɩwɩlɩɣ pee tɩŋa yɔ Mɛnɔ nɛ e sa kaa wa pee nɔ́ nɛ da ngɛ he nɛ wa ngɛ ɔ?Pɩtɛ lɛ, pɔcɔna nɛ pana se pɩ-taa lɛ, kɩ-taa wɛ pee wena awɛ yɔ.// Tʋma ana a-taa lɛ, pakaɣ-ŋ haʋ tɔmpiye nɖɩ ɖɩwɩlɩɣ pɔpɔtʋ nɛ pombowaa yɔ./// >>> fruit_distribution(s: ""5 apples and 6 oranges"", n: 19)
/// 8
/// >>> fruit_distribution(s: ""0 apples and 1 oranges"", n: 3)
/// 2
/// >>> fruit_distribution(s: ""2 apples and 3 oranges"", n: 100)
/// 95
/// >>> fruit_distribution(s: ""100 apples and 1 oranges"", n: 120)
/// 19
func fruit_distribution(s: String, n: Int) -> Int {
","func fruit_distribution(s: String, n: Int) -> Int {
    let components = s.components(separatedBy: "" "")
    var apples = 0
    var oranges = 0
    
    for (index, component) in components.enumerated() {
        if component == ""apples"" || component == ""apple"" {
            if let number = Int(components[index - 1]) {
                apples = number
            }
        } else if component == ""oranges"" || component == ""orange"" {
            if let number = Int(components[index - 1]) {
                oranges = number
            }
        }
    }
    
    let totalApplesOranges = apples + oranges
    let mangoes = n - totalApplesOranges
    return mangoes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 19) == 8)
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 21) == 10)
assert(fruit_distribution(s: ""0 apples and 1 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""1 apples and 0 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 100) == 95)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 5) == 0)
assert(fruit_distribution(s: ""1 apples and 100 oranges"", n: 120) == 19)"
HumanEval_68,kbp_Latn,swift,"
// Kɩɖaʋ 1: // Yee ɛyʊ ɛfɛyɩna ɛ-tɛ kɩlabʊ yaa ɛ-tɛ kɩlabʊ ŋgʊ kɩ-taa ɛfɛyɩ yɔ, pɩpɩsɩɣ []. Pɩwɛɛ se patasɩ lɩzʋʋ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ, [small_value, its index] taa, // Yee panaa nɩŋgbaŋgʊʊ ndɩ ndɩ nɛ kɩ-wɛtʊ kɩlɩna ñɩɩɩ yɔ, pɩpɩsɩɣ nɩŋgbaŋgʊʊ ŋgʊ kɩ-wɛtʊ kɩlɩna ñɩɩɩ yɔ. // Nɔɔyʊ weyi ɛ-taa ɛ-tɛ ɛyʊ wɛ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ, pɩwɛɛ se pɩkɛ ɛ-tɛ ɛyʊ weyi ɛ-tɛ ɛyʊ wɛʊ yɔ.Ŋŋpɩzɩɣ nɛ ŋlɩzɩ-ɩ nɛ ŋyele-i nɛ ɛkɔɔ.// ""Ɛzɩma pamaɣna tɩʋ nakʋyʋ piliŋa ŋga ka-taa wɛ nimero waa mba pɛfɛyɩ kɩmaŋ yɔ /// >>> pluck(arr: [4, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(arr: [1, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(arr: [] as [Int])
/// [] as [Int]
/// Example 4:
/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])
/// [0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
func pluck(arr: [Int]) -> [Int] {
","func pluck(arr: [Int]) -> [Int] {
    var smallestEvenValue: Int? = nil
    var smallestIndex: Int? = nil

    for (index, value) in arr.enumerated() {
        if value % 2 == 0 {
            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {
                smallestEvenValue = value
                smallestIndex = index
            }
        }
    }

    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {
        return [smallestEvenValue, smallestIndex]
    } else {
        return []
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pluck(arr: [4, 2, 3]) == [2, 1])
assert(pluck(arr: [1, 2, 3]) == [2, 1])
assert(pluck(arr: [] as [Int]) == [] as [Int])
assert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])
assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])
assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])
assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])
assert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
HumanEval_69,kbp_Latn,swift,"
// Kɩɖaŋ: // Yee pɩfɛyɩ kɔyɔ, pɩpɩsɩɣ -1.// Ɛyʊ kʊyʊm kpɛlɛkʊʊ taa lɛ, tam ɛzɩma ɛyʊ wɛʊ yɔ, pɩkɛ ɛ-tɛ kʊyʊm kpɛlɛkʊʊ taa. // ɛtɛyɩɣ, nɛ ɛ-tɛ ɖoŋ wɛna pɩkɩlɩ yaa kɩmaɣna ɛtɛyɩɣ ɛ-tɩ. Pɩtɛ lɛ, ŋnaɣ ɛyʊ weyi ɛ-tɛ ɛyʊ kɩlɩna ɖɔʊ yɔ nɛ ɛ-tɛ ɛyʊ kɩlɩna ɖɔʊ yɔ./// >>> search(lst: [4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(lst: [5, 5, 4, 4, 4])
/// -1
func search(lst: [Int]) -> Int {
","func search(lst: [Int]) -> Int {
    var frequencyMap = [Int: Int]()
    
    // Count frequencies of each number in the list
    for number in lst {
        frequencyMap[number, default: 0] += 1
    }
    
    var result = -1
    
    // Iterate through the frequency map to find the greatest integer that satisfies the condition
    for (number, frequency) in frequencyMap {
        if frequency >= number {
            result = max(result, number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(search(lst: [5, 5, 5, 5, 1]) == 1)
assert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)
assert(search(lst: [3, 3]) == -1)
assert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)
assert(search(lst: [2, 3, 3, 2, 2]) == 2)
assert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)
assert(search(lst: [3, 2, 8, 2]) == 2)
assert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)
assert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)
assert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)
assert(search(lst: [1, 9, 10, 1, 3]) == 1)
assert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)
assert(search(lst: [1]) == 1)
assert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)
assert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)
assert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)
assert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)
assert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)
assert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)
assert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)
assert(search(lst: [10]) == -1)
assert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)
assert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)
assert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)
assert(search(lst: [3, 10, 10, 9, 2]) == -1)"
HumanEval_70,kbp_Latn,swift,"
// Kɩɖaŋ: Pɩtɛ lɛ, ɖɩnaɣ ɛyʊ kɩlɩm, nɛ ɛyʊ kɩlɩm wayɩ lɛ, ɛyʊ kɩlɩm nɛ pɩtasɩna ɛyʊ kɩlɩm wayɩ.// Pɩfɛyɩ ɖeu se ɖɩpaɣzɩ nɛ ɖɩkpaɣ kɩjɛyʊʊ mayaɣ kɔyɔ, // Ɛtɛrɩ waa tɛ matriki, pɩpɩsɩ matriki kɩlɛlʋʋ./// >>> strange_sort_list(lst: [1, 2, 3, 4])
/// [1, 4, 2, 3]
/// >>> strange_sort_list(lst: [5, 5, 5, 5])
/// [5, 5, 5, 5]
/// >>> strange_sort_list(lst: [] as [Int])
/// [] as [Int]
func strange_sort_list(lst: [Int]) -> [Int] {
","func strange_sort_list(lst: [Int]) -> [Int] {
    var sortedList = lst.sorted()
    var result: [Int] = []
    
    while !sortedList.isEmpty {
        if let min = sortedList.first {
            result.append(min)
            sortedList.removeFirst()
        }
        
        if let max = sortedList.last {
            result.append(max)
            sortedList.removeLast()
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])
assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])
assert(strange_sort_list(lst: [] as [Int]) == [] as [Int])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])
assert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])
assert(strange_sort_list(lst: [111111]) == [111111])"
HumanEval_71,kbp_Latn,swift,"
// Kɩɖaʋ: Ɛlɛ, pɩcɛyaa se ɖɩtɩlɩ hɔɔlʋʋ naadozo ñɩŋgʋ.// Hɔɔlɩŋ naadozo wɛna tam nabudozo taa yee ɛ-hɔɔlɩŋ naalɛ ɩ-taa ɛ-tɛ ɖɔʊ ɛkɩlɩ kɔyɔ.// Pɩtɛkɛ mbʋ lɛ, pɩpɩsɩɣ -1 // tɔmɩŋ naadozo taa lɛ, ɖɩkpaɣ tɔmɩŋ naalɛ nɛ ɖɩtazɩ-ɩ nɛ ɖɩna se tɔmɩŋ naadozo taa lɛ, tɔmɩŋ naadozo taa lɛ, ɖɩkpaɣ tɔmɩŋ naalɛ nɛ ɖɩtazɩ-ɩ nɛ ɖɩna se tɔmɩŋ naadozo taa lɛ, tɔmɩŋ naadozo taa lɛ, ɖɩkpaɣ tɔmɩŋ naalɛ.// Yee ɖɩkpaɣ tɔmpiye triangle hɔɔlʋʋ lɛɛkʋ taa hɔɔlɩŋ naadozo yɔ, ɖɩpɩsɩɣ ɛ-tʊmɩyɛ yɔɔ tɔmpiye /// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
","func triangle_area(a: Int, b: Int, c: Int) -> Double {
    // Check if the sides form a valid triangle
    if a + b > c && a + c > b && b + c > a {
        // Calculate the semi-perimeter
        let s = Double(a + b + c) / 2.0
        // Calculate the area using Heron's formula
        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
        // Round to 2 decimal places
        return round(area * 100) / 100
    } else {
        return -1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)"
HumanEval_72,kbp_Latn,swift,"
// Kɩɖaʋ: Pɩkɛ palindromie (palindromie) nɛ ɛ-tɛ wondu kpeekpe kpɛndɩna nɛ tɩtalɩ yaa tɩtalɩ ɛ-kɩjɩkpʋʋ w.// Ma tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm ndʋ tɩkɛ toovenim yɔ, ye tɔm ndʋ tɩ-taa tɔm kɩlɩʋ ɛlɩwa yɔ, nɛ tɔm ndʋ tɩkɛ cɛtɩm yɔ, ye pɩtɛkɛ mbʋ yɔ. /// >>> will_it_fly(q: [1, 2], w: 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(q: [3, 2, 3], w: 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(q: [3, 2, 3], w: 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(q: [3], w: 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q: [Int], w: Int) -> Bool {
","func will_it_fly(q: [Int], w: Int) -> Bool {
    func isPalindromic(_ array: [Int]) -> Bool {
        return array == array.reversed()
    }
    
    let sum = q.reduce(0, +)
    return isPalindromic(q) && sum <= w
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(will_it_fly(q: [3, 2, 3], w: 9) == true)
assert(will_it_fly(q: [1, 2], w: 5) == false)
assert(will_it_fly(q: [3], w: 5) == true)
assert(will_it_fly(q: [3, 2, 3], w: 1) == false)
assert(will_it_fly(q: [1, 2, 3], w: 6) == false)
assert(will_it_fly(q: [5], w: 5) == true)"
HumanEval_73,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: Ŋpɩzɩɣ nɛ ŋlɛɣzɩ hɔɔlʋʋ nakʋyʋ nɛ ŋla lɛɛbʋ.Pɩwɛɛ se pɛlɛɣzɩ-ɩ se pɩsa nɛ ɛ-tɛ matriki wɛɛ camɩyɛ.// Ye ɖɩha-ɩ nimero waa tɩŋa yɔ, ɖɩñɩnɩɣ kɩlɛmɩŋ weyi ɩfɛyɩ yɔ nɛ ɖɩna se /// >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(arr: [1, 2, 3, 2, 1])
/// 0
func smallest_change(arr: [Int]) -> Int {
","func smallest_change(arr: [Int]) -> Int {
    var changes = 0
    let n = arr.count

    for i in 0..<(n / 2) {
        if arr[i] != arr[n - i - 1] {
            changes += 1
        }
    }

    return changes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)
assert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)
assert(smallest_change(arr: [1, 4, 2]) == 1)
assert(smallest_change(arr: [1, 4, 4, 2]) == 1)
assert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)
assert(smallest_change(arr: [3, 1, 1, 3]) == 0)
assert(smallest_change(arr: [1]) == 0)
assert(smallest_change(arr: [0, 1]) == 1)"
HumanEval_74,kbp_Latn,swift,"
// Kɩɖaŋ // yee matriki naalɛ ɩwɛna matriki kɩmaŋ kʋɖʋmʋʋ kɔyɔ, pɩpɩsɩɣ kajalaɣ matriki.// mbʊ pʊyɔɔ yɔ, ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ.Takayaɣ ŋga ka-taa pamaɣna se pɩsa nɛ pamaɣna se tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ./// >>> total_match(lst1: [] as [String], lst2: [] as [String])
/// [] as [String]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""])
/// [""hI"", ""Hi""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""])
/// [""hi"", ""admin""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""])
/// [""hI"", ""hi"", ""hi""]
/// >>> total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""])
/// [""4""]
func total_match(lst1: [String], lst2: [String]) -> [String] {
","func total_match(lst1: [String], lst2: [String]) -> [String] {
    let totalChars1 = lst1.reduce(0) { $0 + $1.count }
    let totalChars2 = lst2.reduce(0) { $0 + $1.count }
    
    if totalChars1 < totalChars2 {
        return lst1
    } else if totalChars2 < totalChars1 {
        return lst2
    } else {
        return lst1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi""]) == [""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""]) == [""hi"", ""admin""])
assert(total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""]) == [""4""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""]) == [""hI"", ""Hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""]) == [""hI"", ""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hii""]) == [""hi"", ""admin""])
assert(total_match(lst1: [] as [String], lst2: [""this""]) == [] as [String])
assert(total_match(lst1: [""this""], lst2: [] as [String]) == [] as [String])"
HumanEval_75,kbp_Latn,swift,"
// Kɩɖaʋ: // Ɖɩtɩlɩɣ se a) wɛna 100 yɔɔ. Pɩtɩkɛ toovenim.// Maɣna tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ, yee tɔmpiye nɖɩ ɖɩkɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye 3 yɔ./// >>> is_multiply_prime(a: 30)
/// true
/// 30 = 2 * 3 * 5
func is_multiply_prime(a: Int) -> Bool {
","func is_multiply_prime(a: Int) -> Bool {
    // Function to check if a number is prime
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Generate all prime numbers less than 100
    var primes = [Int]()
    for i in 2..<100 {
        if isPrime(i) {
            primes.append(i)
        }
    }
    
    // Check combinations of 3 primes
    let primeCount = primes.count
    for i in 0..<primeCount {
        for j in i..<primeCount {
            for k in j..<primeCount {
                if primes[i] * primes[j] * primes[k] == a {
                    return true
                }
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_multiply_prime(a: 5) == false)
assert(is_multiply_prime(a: 30) == true)
assert(is_multiply_prime(a: 8) == true)
assert(is_multiply_prime(a: 10) == false)
assert(is_multiply_prime(a: 125) == true)
assert(is_multiply_prime(a: 105) == true)
assert(is_multiply_prime(a: 126) == false)
assert(is_multiply_prime(a: 729) == false)
assert(is_multiply_prime(a: 891) == false)
assert(is_multiply_prime(a: 1001) == true)"
HumanEval_76,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // x kɛ n tɛ ɖoŋ weyi ɛfɛyɩ yuŋ yɔ, yee n**int=x // n tɛ ɖoŋ nɛ ɛtɛ ɛfɛyɩ ɖeu lɛɛbʋ taa. // Ñɔ-tʋmɩyɛ lɛ se ŋma tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm ndʋ tɩkɛ toovenim yɔ, ye x kɛ tɔmpiye kɛlɛʋ yɔ./// >>> is_simple_power(x: 1, n: 4)
/// true
/// >>> is_simple_power(x: 2, n: 2)
/// true
/// >>> is_simple_power(x: 8, n: 2)
/// true
/// >>> is_simple_power(x: 3, n: 2)
/// false
/// >>> is_simple_power(x: 3, n: 1)
/// false
/// >>> is_simple_power(x: 5, n: 3)
/// false
func is_simple_power(x: Int, n: Int) -> Bool {
","func is_simple_power(x: Int, n: Int) -> Bool {
    if x < 1 || n < 1 {
        return false
    }
    if x == 1 {
        return true // n**0 = 1
    }
    var power = 1
    while power < x {
        power *= n
    }
    return power == x
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_simple_power(x: 16, n: 2) == true)
assert(is_simple_power(x: 143214, n: 16) == false)
assert(is_simple_power(x: 4, n: 2) == true)
assert(is_simple_power(x: 9, n: 3) == true)
assert(is_simple_power(x: 16, n: 4) == true)
assert(is_simple_power(x: 24, n: 2) == false)
assert(is_simple_power(x: 128, n: 4) == false)
assert(is_simple_power(x: 12, n: 6) == false)
assert(is_simple_power(x: 1, n: 1) == true)
assert(is_simple_power(x: 1, n: 12) == true)"
HumanEval_77,kbp_Latn,swift,"
// Kɩɖaŋ: // Tɔzɩ se ŋpɩzɩɣ ŋmaɣzɩ se tɔm ndʋ ŋyɔɔdaa yɔ tɩkɛ toovenim paa ɛzɩmtaa. // yee pɩtɛ intɛrɩger waa nabɛyɛ tɛ kubitu kɔyɔ. Takayaɣ ŋga ka-taa lɛ, pamaɣ size, ɛyʊ ɛ-tɔm wɛ ndɩ nɛ ɛ-tɛ tɔm./// >>> iscube(a: 1)
/// true
/// >>> iscube(a: 2)
/// false
/// >>> iscube(a: -1)
/// true
/// >>> iscube(a: 64)
/// true
/// >>> iscube(a: 0)
/// true
/// >>> iscube(a: 180)
/// false
func iscube(a: Int) -> Bool {
","func iscube(a: Int) -> Bool {
    if a == 0 { return true } // 0 is a cube (0^3)
    let absA = abs(a)
    let cubeRoot = Int(round(pow(Double(absA), 1.0/3.0)))
    return cubeRoot * cubeRoot * cubeRoot == absA
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(iscube(a: 1) == true)
assert(iscube(a: 2) == false)
assert(iscube(a: -1) == true)
assert(iscube(a: 64) == true)
assert(iscube(a: 180) == false)
assert(iscube(a: 1000) == true)
assert(iscube(a: 0) == true)
assert(iscube(a: 1729) == false)"
HumanEval_78,kbp_Latn,swift,"
// Kɩɖaŋ: Nɛ mayaɣ A, B, C, D, E, F kɛna mayaɣ sɔsɔɣa paa ɛzɩmtaa.// Tɔzɩ se: ŋpɩzɩɣ ŋmaɣzɩ se tɔm ndʋ ŋɖʋwa yɔ tɩkɛ toovenim yaa tɩkɛ falaa.B (= decimal 11), D (= decimal 13) Pʋ-tɔbʋʋ se ŋñɩnɩɣ se ŋtɩlɩ hɔɔlɩŋ weyi ɩ-taa ŋpɩzɩɣ ŋtɩŋna yɔ: 2, 3, 5, 7, // Kɩjɩkpɩŋ sɔsɔŋ lɛ 2, 3, 5, 7, 11, 13, 17,... // Hexadecimal waa kɔyɔ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. // kɩlɩna 1 nɛ pɩtɛkɛ natʊyʊ kɩlɩna naalɛ yɔ).// nimbrɩ waa mba pɛkɛ kajalaɣ n̄ɩnzɩ yɔ (n̄ɩnzɩ kajalaɣ n̄ɩnzɩ yaa kajalaɣ n̄ɩnzɩ, pɩkɛ n̄ɩnzɩ nzɩ sɩ-taa lɛ, nimbrɩ waa kɩkpɛdaa yɔ)Ɛkɛ ɛsaadɛzɩimɛɛlɩ mayaɣ ŋga ka-taa ɛsaadɛzɩimɛɛlɩ mayaɣ wɛɛ yɔ.// Paɖʋ-ŋ tʋmɩyɛ se ŋma tʋmɩyɛ nɖɩ ɖɩmʋɣ yɔ /// >>> hex_key(num: ""AB"")
/// 1
/// >>> hex_key(num: ""1077E"")
/// 2
/// >>> hex_key(num: ""ABED1A33"")
/// 4
/// >>> hex_key(num: ""123456789ABCDEF0"")
/// 6
/// >>> hex_key(num: ""2020"")
/// 2
func hex_key(num: String) -> Int {
","func hex_key(num: String) -> Int {
    // Define hexadecimal digits that are prime numbers
    let primeHexDigits: Set<Character> = [""2"", ""3"", ""5"", ""7"", ""B"", ""D""]
    
    // Initialize count
    var primeCount = 0
    
    // Iterate over each character in the string
    for char in num {
        // Check if the character is a prime hexadecimal digit
        if primeHexDigits.contains(char) {
            primeCount += 1
        }
    }
    
    return primeCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: ""AB"") == 1)
assert(hex_key(num: ""1077E"") == 2)
assert(hex_key(num: ""ABED1A33"") == 4)
assert(hex_key(num: ""2020"") == 2)
assert(hex_key(num: ""123456789ABCDEF0"") == 6)
assert(hex_key(num: ""112233445566778899AABBCCDDEEFF00"") == 12)"
HumanEval_79,kbp_Latn,swift,"
// Kɩɖaŋ: // Takayɩhatʋ ndʋ tɩ-taa pɛcɛzɩ-ɩ yɔ, tɩsɩɣnɩ-ɩ nɛ ɛlɩzɩ-tʋ camɩyɛ. // Pɩkaɣ wɛʋ tɔm pee kɩkalasɩ naalɛ 'db' tɔmpiye ɖɩbazɩyɛ nɛ ɖɩ-tɛ wayɩ. Paa mayaɣ ŋga lɛ, ka-taa mayaɣ ŋga lɛ, ka-taa mayaɣ ŋga lɛ ""0"" yaa ""1"".Pɩwɛɛ se kɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa paa mayaɣ ŋga lɛ kɛwɛna binɛɛrɩ mayaɣ yɔ.// Pʊkɔŋna-ŋ nimero waa sakɩyɛ nɛ ña-tʋmɩyɛ lɛ se ŋlɛɣzɩ-ɩ nɛ /// >>> decimal_to_binary(decimal: 15)
/// ""db1111db""
/// >>> decimal_to_binary(decimal: 32)
/// ""db100000db""
func decimal_to_binary(decimal: Int) -> String {
","func decimal_to_binary(decimal: Int) -> String {
    let binaryString = String(decimal, radix: 2)
    return ""db"" + binaryString + ""db""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(decimal_to_binary(decimal: 0) == ""db0db"")
assert(decimal_to_binary(decimal: 32) == ""db100000db"")
assert(decimal_to_binary(decimal: 103) == ""db1100111db"")
assert(decimal_to_binary(decimal: 15) == ""db1111db"")"
HumanEval_80,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Ɛyʋ pɩzɩɣ nɛ ɛlɩzɩ tɔm piye nɖɩ ɖɩ-taa tɔm pee 3 nɛ paa tɔmpiye nɖɩ lɛ ɖɩ-taa lɛ, ɖɩ-taa tɔm pee 3 wɛ ndɩ nɛ ɖama.// Ña-tʋmɩyɛ lɛ se ŋtazɩ se ŋtɩlɩ se tɔmpiye nɖɩ ɖɩ-taa tɔm kɩlɩ ɖɔʋ yaa ɖɩtɩlɩɩ. // Paha-ŋ tɔmpiye s. /// >>> is_happy(s: ""a"")
/// false
/// >>> is_happy(s: ""aa"")
/// false
/// >>> is_happy(s: ""abcd"")
/// true
/// >>> is_happy(s: ""aabb"")
/// false
/// >>> is_happy(s: ""adb"")
/// true
/// >>> is_happy(s: ""xyy"")
/// false
func is_happy(s: String) -> Bool {
","func is_happy(s: String) -> Bool {
    let characters = Array(s)
    if characters.count < 3 {
        return false
    }
    
    for i in 0..<(characters.count - 2) {
        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_happy(s: ""a"") == false)
assert(is_happy(s: ""aa"") == false)
assert(is_happy(s: ""abcd"") == true)
assert(is_happy(s: ""aabb"") == false)
assert(is_happy(s: ""adb"") == true)
assert(is_happy(s: ""xyy"") == false)
assert(is_happy(s: ""iopaxpoi"") == true)
assert(is_happy(s: ""iopaxioi"") == false)"
HumanEval_81,kbp_Latn,swift,"
// Kɩɖaʋ: / 0.0 E // > 0.0 D- // > 0,7 D // > 1.0 D+ // > 1.3 C- // > 1.7 C C+ taa// > 2.3 B- // > 2.7 B // > 3.0 B+ // > 3.3 A- // > 3.7 A // 4.0 A+ Kʋdɔmɩŋ waʋ nʋmɔʋ taa lɛ, pɩpɔzʋʋ se ŋtɩlɩ mbʋ ŋpɩzɩɣ ŋla yɔ.// tʋmɩyɛ nɖɩ ɖɩpɩzɩɣ nɛ ɖɩlɩzɩ tɔm pee ndɩ ndɩ nɛ ɖɩlabɩnɩ tʋmɩyɛ tɔm pee wena awɛ ɛzɩ pɩ-tɛɛ yɔ: Ɛha-ŋ takayɩsɩ ndɩ ndɩ nɛ pɩpɔzʋʋ se ŋma-sɩ.Ɛlɛ, ɛ-tɛ tɔm ndʋ tɩ-taa ɛlabɩnɩ tʋmɩyɛ nɛ ɛmaɣzɩɣ yɔ, tɩtɩtasɩ wɛʋ.Wɩlɩyʋ lakɩ ɛ-maɣmaɣ ɛ-lɩmaɣza nɛ ɛɖʋʋ ɛ-tɩ takayɩsɩ taa.Pɩkɛ kpelaɣ fenaɣ kɛdɛzaɣ kpɩtaʋ taa nɛ wɩlɩyʋ wɛɛ nɛ ɛwɩlɩɣ ɛ-wɩlɩyaa takayɩsɩ./// >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])
/// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
func numerical_letter_grade(grades: [Double]) -> [String] {
","func numerical_letter_grade(grades: [Double]) -> [String] {
    return grades.map { gpa in
        switch gpa {
        case 4.0:
            return ""A+""
        case 3.7...4.0:
            return ""A""
        case 3.3..<3.7:
            return ""A-""
        case 3.0..<3.3:
            return ""B+""
        case 2.7..<3.0:
            return ""B""
        case 2.3..<2.7:
            return ""B-""
        case 2.0..<2.3:
            return ""C+""
        case 1.7..<2.0:
            return ""C""
        case 1.3..<1.7:
            return ""C-""
        case 1.0..<1.3:
            return ""D+""
        case 0.7..<1.0:
            return ""D""
        case 0.0..<0.7:
            return ""D-""
        default:
            return ""E""
        }
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [""A+"", ""B"", ""C-"", ""C"", ""A-""])
assert(numerical_letter_grade(grades: [1.2]) == [""D+""])
assert(numerical_letter_grade(grades: [0.5]) == [""D-""])
assert(numerical_letter_grade(grades: [0.0]) == [""E""])
assert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [""D"", ""D-"", ""C-"", ""B"", ""B+""])
assert(numerical_letter_grade(grades: [0.0, 0.7]) == [""E"", ""D-""])"
HumanEval_82,kbp_Latn,swift,"
// Kɩɖaŋ // pɩlɩɣna ɛyʊ ɛ-tʊmɩyɛ yɔɔ yaa pɩtɛkɛ mbʊ yɔ pɩfɛyɩ ɖeu.// Ma tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ, ye tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ./// >>> prime_length(string: ""Hello"")
/// true
/// >>> prime_length(string: ""abcdcba"")
/// true
/// >>> prime_length(string: ""kittens"")
/// true
/// >>> prime_length(string: ""orange"")
/// false
func prime_length(string: String) -> Bool {
","func prime_length(string: String) -> Bool {
    let length = string.count
    
    guard length > 1 else {
        return false
    }
    
    for i in 2..<length {
        if length % i == 0 {
            return false
        }
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_length(string: ""Hello"") == true)
assert(prime_length(string: ""abcdcba"") == true)
assert(prime_length(string: ""kittens"") == true)
assert(prime_length(string: ""orange"") == false)
assert(prime_length(string: ""wow"") == true)
assert(prime_length(string: ""world"") == true)
assert(prime_length(string: ""MadaM"") == true)
assert(prime_length(string: ""Wow"") == true)
assert(prime_length(string: """") == false)
assert(prime_length(string: ""HI"") == true)
assert(prime_length(string: ""go"") == true)
assert(prime_length(string: ""gogo"") == false)
assert(prime_length(string: ""aaaaaaaaaaaaaaa"") == false)
assert(prime_length(string: ""Madam"") == true)
assert(prime_length(string: ""M"") == false)
assert(prime_length(string: ""0"") == false)"
HumanEval_83,kbp_Latn,swift,"
// kɩtɛŋ wɛtʊ ndʊ tɩpaɣzɩɣ yaa tɩtɛzɩɣ 1 yɔ. // Ye ɖɩhaɣ ɛyʊ kʊyʊm mbʊ yɔ, ɖɩpɩsɩɣ ɛyʊ kʊyʊm mbʊ yɔ ɛ-tɛ kʊyʊm mbʊ yɔ.func starts_one_ends(n: Int) -> Int {
","func starts_one_ends(n: Int) -> Int {
    if n == 1 {
        // For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.
        return 1
    }
    
    // Count of n-digit numbers starting with 1:
    // First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.
    let startWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Count of n-digit numbers ending with 1:
    // Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.
    // So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.
    let endWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Intersection of both sets is the numbers starting and ending with 1
    // which are of the form `1` followed by (n-2) digits and `1`, so:
    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))
    
    return startWithOne + endWithOne - startAndEndWithOne
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(starts_one_ends(n: 1) == 1)
assert(starts_one_ends(n: 2) == 18)
assert(starts_one_ends(n: 3) == 180)
assert(starts_one_ends(n: 4) == 1800)
assert(starts_one_ends(n: 5) == 18000)"
HumanEval_84,kbp_Latn,swift,"
// Kɩɖaʋ kɩdɛɛka // Ye ɖɩhaɣ ɛyʊ kʊyʊm N kɔyɔ, ɖɩpɩsɩɣ ɛ-tɛ kʊyʊm mayaɣ./// >>> solve(N: 1000)
/// ""1""
/// >>> solve(N: 150)
/// ""110""
/// >>> solve(N: 147)
/// ""1100""
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
func solve(N: Int) -> String {
","func solve(N: Int) -> String {
    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)
    return String(sumOfDigits, radix: 2)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(N: 1000) == ""1"")
assert(solve(N: 150) == ""110"")
assert(solve(N: 147) == ""1100"")
assert(solve(N: 333) == ""1001"")
assert(solve(N: 963) == ""10010"")"
HumanEval_85,kbp_Latn,swift,"
// Kɩɖaŋ: // Ɖɩcɔna kɔyɔ, ɛyʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ ɛ-tɛ ɛyʊ kɩlɩna wɛʊ./// >>> add(lst: [4, 2, 6, 7])
/// 2
func add(lst: [Int]) -> Int {
","func add(lst: [Int]) -> Int {
    var sum = 0
    for i in stride(from: 1, to: lst.count, by: 2) {
        if lst[i] % 2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(lst: [4, 88]) == 88)
assert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)
assert(add(lst: [4, 0, 6, 7]) == 0)
assert(add(lst: [4, 4, 6, 8]) == 12)"
HumanEval_86,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Tɔzɩ se: Pɩwɛɛ se ŋɖɔ tɔm pee nɛ hɔɔlɩŋ weyi ɩ-taa tɔm pee wɛɛ yɔ ɩ-yɔɔ.// nɛ ɛ-tɛ lɛɣtʊ ndʊ tɩlɩna ɛ-tɛ lɛɣtʊ ndʊ tɩlɩna ɛ-tɛ lɛɣtʊ yɔ.// paɣzɩna tɔm pee kɩfana wena a-taa lɛ, pamaɣna tɔm pee tɩŋa nɛ Ɛ-tɛ tɔm pee tɩŋa wɛna ɖama taa (ɛzɩ pɩ-tɛ tɔm pee tɩŋa yɔ)Ma tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩ-ɖɩ nɛ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ./// >>> anti_shuffle(s: ""Hi"")
/// ""Hi""
/// >>> anti_shuffle(s: ""hello"")
/// ""ehllo""
/// >>> anti_shuffle(s: ""Hello World!!!"")
/// ""Hello !!!Wdlor""
func anti_shuffle(s: String) -> String {
","func anti_shuffle(s: String) -> String {
    let words = s.components(separatedBy: .whitespaces)
    let orderedWords = words.map { String($0.sorted()) }
    var result = """"
    var wordIndex = 0
    
    for character in s {
        if character.isWhitespace {
            result.append(character)
        } else if wordIndex < orderedWords.count {
            if let currentWord = orderedWords[wordIndex].first {
                result.append(currentWord)
                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)
            }
        }
        
        if let lastCharacter = result.last {
            if lastCharacter.isWhitespace {
                wordIndex += 1
            }
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(anti_shuffle(s: ""Hi"") == ""Hi"")
assert(anti_shuffle(s: ""hello"") == ""ehllo"")
assert(anti_shuffle(s: ""number"") == ""bemnru"")
assert(anti_shuffle(s: ""abcd"") == ""abcd"")
assert(anti_shuffle(s: ""Hello World!!!"") == ""Hello !!!Wdlor"")
assert(anti_shuffle(s: """") == """")
assert(anti_shuffle(s: ""Hi. My name is Mister Robot. How are you?"") == "".Hi My aemn is Meirst .Rboot How aer ?ouy"")"
HumanEval_87,kbp_Latn,swift,"
// Kɩɖaŋ: // Pɩtasɩ lɛ, ŋñɔɔzɩ tɔm hɔɔlɩŋ weyi ɩ-taa ŋwɛɛ yɔ nɛ ŋyele nɛ ɩ-taa tɔm hɔɔlɩŋ weyi ɩ-taa ŋwɛɛ yɔ ɩpaɣlɩ. // Ñɔɔzɩ tɔm ñʋŋ weyi ɩ-taa ŋcaɣ se ŋwolo yɔ, nɛ ŋpaɣzɩnɩ pɩ-taa. // paa pɩyʊ weyi lɛ, ɛkɛna ɛ-tɛ coordonnées (sɩɩtʊ, tilima), pɩpaɣzɩna 0. Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ taa.// Ɖɩcɔna lst nɛ ɛyʊ ɛ-tɛ x lɛ, ɖɩñɩnɩ ɛyʊ ɛ-tɛ x, // paa ñʋŋ weyi lɛ ɩ-taa papɩzɩɣ nɛ pama matʋ ndɩ ndɩ. // kɩwɛ ɛzɩ matrix yɔ, ɛlɛ, pɩtɛkɛ ɛzɩ matrix yɔ, // Paha-ŋ 2 dimension waa, ɛzɩ nʊmɔʊ ŋgʊ kɩwɛna kɩ-taa yɔ, /// >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)
/// [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(lst: [] as [[Int]], x: 1)
/// [] as [(Int, Int)]
/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)
/// [(2, 2)]
func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
","func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
    var coordinates: [(Int, Int)] = []
    
    for (rowIndex, row) in lst.enumerated() {
        for (colIndex, value) in row.enumerated() {
            if value == x {
                coordinates.append((rowIndex, colIndex))
            }
        }
    }
    
    let sortedCoordinates = coordinates.sorted {
        if $0.0 == $1.0 {
            return $0.1 > $1.1
        } else {
            return $0.0 < $1.0
        }
    }
    
    return sortedCoordinates
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])
assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])
assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])
assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
HumanEval_88,kbp_Latn,swift,"
// Kɩɖaŋ: // * taapɩsɩna matʋ ndʋ tɩ-taa pama-tʋ yɔ. // Cɔnɩ: // yaa ɛ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ kajalaɣ tɔmpiye, kɛdɛzaɣ tɔmpiye) kɛ paa. // ŋkaɣ ñɔɔzʋʋ matriki ŋgʋ kɩ-taa paa mayaɣ ŋga lɛ, ka-taa kɔyɔ, ka-taa kɔyɔ, ka-taa kɔyɔ, ka-taa kɔyɔ, ka-taa kɔyɔ.// Ɖɩhaɣ ɛyʊ kʊyʊmʊʊ kʊyʊmʊʊ, pɩpɩsɩɣ ɛyʊ kʊyʊmʊtʊ ɛyʊ kʊyʊmʊtʊ pɩtɛ lɛ, /// >>> sort_array(array: [] as [Int])
/// [] as [Int]
/// >>> sort_array(array: [5])
/// [5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5])
/// [0, 1, 2, 3, 4, 5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])
/// [6, 5, 4, 3, 2, 1, 0]
func sort_array(array: [Int]) -> [Int] {
","func sort_array(array: [Int]) -> [Int] {
    guard let first = array.first, let last = array.last else {
        return array
    }
    let sum = first + last
    if sum % 2 == 0 {
        return array.sorted(by: >) // Descending order
    } else {
        return array.sorted() // Ascending order
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(array: [] as [Int]) == [] as [Int])
assert(sort_array(array: [5]) == [5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])
assert(sort_array(array: [2, 1]) == [1, 2])
assert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])
assert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"
HumanEval_89,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2 nɛ ɖɩkpaɣ 2// Pɩwɛɛ se pɛlɛɣzɩ alɩfʋɛtɩ ŋgʋ nɛ pama-kʋ nɛ pama-kʋ ɖɔɖɔ nɛ pama-kʋ ɖɔɖɔ nɛ pama-kʋ ɖɔɖɔ nɛ pama-kʋ ɖɔɖɔ nɛ pama-kʋ ɖɔɖɔ.// pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ alɩfaabɛɛtɩ wɛʊ yɔ. // Ñɔɔzɩ tʋmɩyɛ naɖɩyɛ nɛ ɖɩ-taa lɛ, ŋpɩzɩɣ ŋlɩzɩ tɔm piye naɖɩyɛ nɛ ŋyaa ɖɩ-taa tɔm piye nɛ /// >>> encrypt(s: ""hi"")
/// ""lm""
/// >>> encrypt(s: ""asdfghjkl"")
/// ""ewhjklnop""
/// >>> encrypt(s: ""gf"")
/// ""kj""
/// >>> encrypt(s: ""et"")
/// ""ix""
func encrypt(s: String) -> String {
","func encrypt(s: String) -> String {
    let alphabet = Array(""abcdefghijklmnopqrstuvwxyz"")
    let shift = 2 * 2 // shift down by two multiplied by two places, i.e., 4
    var result = """"

    for character in s {
        if let index = alphabet.firstIndex(of: character) {
            let newIndex = (index + shift) % alphabet.count
            result.append(alphabet[newIndex])
        } else {
            result.append(character) // append non-alphabetic characters unchanged
        }
    }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: ""hi"") == ""lm"")
assert(encrypt(s: ""asdfghjkl"") == ""ewhjklnop"")
assert(encrypt(s: ""gf"") == ""kj"")
assert(encrypt(s: ""et"") == ""ix"")
assert(encrypt(s: ""faewfawefaewg"") == ""jeiajeaijeiak"")
assert(encrypt(s: ""hellomyfriend"") == ""lippsqcjvmirh"")
assert(encrypt(s: ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"") == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")
assert(encrypt(s: ""a"") == ""e"")"
HumanEval_90,kbp_Latn,swift,"
// Ye pɩfɛyɩ mbʋ yɔ, pɩsɩɣnɩ nil. Takayaɣ ŋga ka-taa lɛ, pamaɣ size, pɩtɛ lɛ, pamaɣ size, pɩtɛ lɛ, pamaɣ size, pɩtɛ lɛ, pamaɣ size, pɩtɛ lɛ, pamaɣ size, pɩtɛ lɛ, pamaɣ size.// Paha-ŋ intɛrɩ waa sakɩyɛ. /// >>> next_smallest(lst: [1, 2, 3, 4, 5])
/// 2
/// >>> next_smallest(lst: [5, 1, 4, 3, 2])
/// 2
/// >>> next_smallest(lst: [] as [Int])
/// nil
/// >>> next_smallest(lst: [1, 1])
/// nil
func next_smallest(lst: [Int]) -> Int? {
","func next_smallest(lst: [Int]) -> Int? {
    if lst.count < 2 {
        return nil
    }
    
    var uniqueSorted = Array(Set(lst)).sorted()
    
    if uniqueSorted.count < 2 {
        return nil
    }
    
    return uniqueSorted[1]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)
assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)
assert(next_smallest(lst: [] as [Int]) == nil)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
HumanEval_91,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Tɔm hɔɔlɩŋ wɛna '.', '?' yaa '!'. Tɔm piye ""m"" ɖɩlɩna tɔm piye ""m"" taa.Payaɣ-ŋ se ""Tʋma"" nɛ ŋkaɣ naʋ se tɔm pee wena ŋkaɣ kalʋʋ yɔ, a-taa naayɛ tɔm loyaɣ taa./// >>> is_bored(S: ""Hello world"")
/// 0
/// >>> is_bored(S: ""The sky is blue. The sun is shining. I love this weather"")
/// 1
func is_bored(S: String) -> Int {
","func is_bored(S: String) -> Int {
    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }
    var boredomCount = 0
    
    for sentence in sentences {
        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)
        if trimmedSentence.hasPrefix(""I"") {
            boredomCount += 1
        }
    }
    
    return boredomCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_bored(S: ""Hello world"") == 0)
assert(is_bored(S: ""Is the sky blue?"") == 0)
assert(is_bored(S: ""I love It !"") == 1)
assert(is_bored(S: ""bIt"") == 0)
assert(is_bored(S: ""I feel good today. I will be productive. will kill It"") == 2)
assert(is_bored(S: ""You and I are going for a walk"") == 0)"
HumanEval_92,kbp_Latn,swift,"
// Kɩɖaŋ // Pɩpɩsɩɣ false paa ɛzɩmtaa. // Pɩpɩsɩɣ tɔmpiye true yee tɔmpiye naɖɩyɛ ɛtalɩ naalɛ lɛɛna yɔ nɛ tɔmpiye nɖɩ ɖɩ-tɩŋa ɖɩkɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.// Ñɔɔzɩ tʋmɩyɛ nɖɩ ɖɩ-taa pamaɣna hɔɔlɩŋ naadozo yɔ. /// >>> any_int(x: 5, y: 2, z: 7)
/// true
/// >>> any_int(x: 3, y: 2, z: 2)
/// false
/// >>> any_int(x: 3, y: -2, z: 1)
/// true
/// >>> any_int(x: 3.6, y: -2.2, z: 2)
/// false
func any_int(x: Double, y: Double, z: Double) -> Bool {
","func any_int(x: Double, y: Double, z: Double) -> Bool {
    guard x == floor(x), y == floor(y), z == floor(z) else {
        return false
    }
    
    let a = Int(x)
    let b = Int(y)
    let c = Int(z)
    
    return a == b + c || b == a + c || c == a + b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(any_int(x: 2, y: 3, z: 1) == true)
assert(any_int(x: 2.5, y: 2, z: 3) == false)
assert(any_int(x: 1.5, y: 5, z: 3.5) == false)
assert(any_int(x: 2, y: 6, z: 2) == false)
assert(any_int(x: 4, y: 2, z: 2) == true)
assert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)
assert(any_int(x: -4, y: 6, z: 2) == true)
assert(any_int(x: 2, y: 1, z: 1) == true)
assert(any_int(x: 3, y: 4, z: 7) == true)
assert(any_int(x: 3.0, y: 4, z: 7) == false)"
HumanEval_93,kbp_Latn,swift,"
// Kɩɖaŋ: // Pɩwɛɛ se pama-kʋ nɛ masɩ yeke. // Wondu ndʋ tɩwɛ kʋnʋŋ taa yɔ, tɩ-taa.// tɔm ndʋ tɩ-taa lɛ, pamaɣ takayaɣ ŋga nɛ ɖɩ-hɩɖɛ nɛ ɖɩɖɛɛna ɖɩ-yɔɔ nɛ ɖɩ-taa lɛ, pamaɣ takayaɣ ŋga nɛ ɖɩ-hɩɖɛ nɛ ɖɩ-hɩɖɛ.Ɛlɛɣzɩna matʋ tɩŋa nɛ ɛtɛzɩna matʋ ndʋ tɩ-taa tɩ-taa ɛyʊ wɛ yɔ.Takayaɣ ŋga ka-taa pama tɔm natʋyʋ nɛ ka-taa lɛ, ŋnaɣ tɔm ndʋ tɩ-taa./// >>> encode(message: ""test"")
/// ""TGST""
/// >>> encode(message: ""This is a message"")
/// ""tHKS KS C MGSSCGG""
func encode(message: String) -> String {
","func encode(message: String) -> String {
    let vowels = ""aeiouAEIOU""
    let vowelReplacement = [
        ""a"": ""c"", ""e"": ""g"", ""i"": ""k"", ""o"": ""q"", ""u"": ""w"",
        ""A"": ""C"", ""E"": ""G"", ""I"": ""K"", ""O"": ""Q"", ""U"": ""W""
    ]
    
    var encodedMessage = """"
    
    for char in message {
        if vowels.contains(char) {
            if let replacement = vowelReplacement[String(char)] {
                encodedMessage.append(replacement)
            }
        } else {
            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())
            encodedMessage.append(swappedCase)
        }
    }
    
    return encodedMessage
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: ""TEST"") == ""tgst"")
assert(encode(message: ""Mudasir"") == ""mWDCSKR"")
assert(encode(message: ""YES"") == ""ygs"")
assert(encode(message: ""This is a message"") == ""tHKS KS C MGSSCGG"")
assert(encode(message: ""I DoNt KnOw WhAt tO WrItE"") == ""k dQnT kNqW wHcT Tq wRkTg"")"
HumanEval_94,kbp_Latn,swift,"
// Kɩɖaŋ: // Pɩwɛɛ se ŋñɩnɩ mayaɣ ŋga kɛwɛna wazaɣ siŋŋ yɔ nɛ ŋyele nɛ ka-taa mayaɣ ŋga kɛwɛna wazaɣ siŋŋ yɔ.// Paha-ŋ intɛrɩ waa sakɩyɛ. /// >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])
/// 7
func skjkasdkd(lst: [Int]) -> Int {
","func skjkasdkd(lst: [Int]) -> Int {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    var largestPrime: Int? = nil
    for number in lst {
        if isPrime(number) {
            if largestPrime == nil || number > largestPrime! {
                largestPrime = number
            }
        }
    }
    
    if let largestPrime = largestPrime {
        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)
    }
    
    return 0 // In case there are no prime numbers
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)
assert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)
assert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)
assert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)
assert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)
assert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)
assert(skjkasdkd(lst: [8191]) == 19)
assert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)
assert(skjkasdkd(lst: [127, 97, 8192]) == 10)"
HumanEval_96,kbp_Latn,swift,"
// kɩɖaʋ: // intɛrɩ waa mba pɛkɛ kajalaɣ mba nɛ pɛfɛyɩ n yɔ. // Palakɩ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ ɛyʊ kʊyʊm nɛ ɖɩpɩsɩɣ kajalaɣ n ñɩŋʊ yɔ./// >>> count_up_to(n: 5)
/// [2, 3]
/// >>> count_up_to(n: 11)
/// [2, 3, 5, 7]
/// >>> count_up_to(n: 0)
/// [] as [Int]
/// >>> count_up_to(n: 20)
/// [2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(n: 1)
/// [] as [Int]
/// >>> count_up_to(n: 18)
/// [2, 3, 5, 7, 11, 13, 17]
func count_up_to(n: Int) -> [Int] {
","func count_up_to(n: Int) -> [Int] {
    guard n > 2 else { return [] }
    
    var primes: [Int] = [2]
    
    for number in 3..<n {
        var isPrime = true
        for prime in primes {
            if prime * prime > number {
                break
            }
            if number % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(number)
        }
    }
    
    return primes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_up_to(n: 5) == [2, 3])
assert(count_up_to(n: 6) == [2, 3, 5])
assert(count_up_to(n: 7) == [2, 3, 5])
assert(count_up_to(n: 10) == [2, 3, 5, 7])
assert(count_up_to(n: 0) == [] as [Int])
assert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])
assert(count_up_to(n: 1) == [] as [Int])
assert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])
assert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
assert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"
HumanEval_97,kbp_Latn,swift,"
// Kɩɖaŋ: // Pɩwɛɛ se ɖɩmaɣzɩ se tɔm ndʋ ɖɩma yɔ, tɩkɛ toovenim paa ɛzɩmtaa. // pɛ-ɛyʋtʋ mayaɣ taa. // Pɩtɛŋna tʊmɩyɛ nɖɩ ɖɩkpaɣ ɛyʊ ɛ-ñʊʊ taa tɔm nabʊlɛ nɛ ɖɩpɩsɩɣ /// >>> multiply(a: 148, b: 412)
/// 16
/// >>> multiply(a: 19, b: 28)
/// 72
/// >>> multiply(a: 2020, b: 1851)
/// 0
/// >>> multiply(a: 14, b: -15)
/// 20
func multiply(a: Int, b: Int) -> Int {
","func multiply(a: Int, b: Int) -> Int {
    let unitDigitA = abs(a % 10)
    let unitDigitB = abs(b % 10)
    return unitDigitA * unitDigitB
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(multiply(a: 148, b: 412) == 16)
assert(multiply(a: 19, b: 28) == 72)
assert(multiply(a: 2020, b: 1851) == 0)
assert(multiply(a: 14, b: -15) == 20)
assert(multiply(a: 76, b: 67) == 42)
assert(multiply(a: 17, b: 27) == 49)
assert(multiply(a: 0, b: 1) == 0)
assert(multiply(a: 0, b: 0) == 0)"
HumanEval_98,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Ye ŋwɛna masɩ nzɩ sɩ-taa pamaɣ-sɩ nɛ tɔm pee sɔsɔna yɔ, kalɩ sɩ-taa tɔm pee wena awɛ ɖɔɖɔ nɛ tɔm pee kɩkpɛdaa yɔ. /// >>> count_upper(s: ""aBCdEf"")
/// 1
/// >>> count_upper(s: ""abcdefg"")
/// 0
/// >>> count_upper(s: ""dBBE"")
/// 0
func count_upper(s: String) -> Int {
","func count_upper(s: String) -> Int {
    let upperVowels = Set<Character>([""A"", ""E"", ""I"", ""O"", ""U""])
    var count = 0

    for (index, char) in s.enumerated() {
        if index % 2 == 0 && upperVowels.contains(char) {
            count += 1
        }
    }

    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_upper(s: ""aBCdEf"") == 1)
assert(count_upper(s: ""abcdefg"") == 0)
assert(count_upper(s: ""dBBE"") == 0)
assert(count_upper(s: ""B"") == 0)
assert(count_upper(s: ""U"") == 1)
assert(count_upper(s: """") == 0)
assert(count_upper(s: ""EEEE"") == 2)"
HumanEval_99,kbp_Latn,swift,"
// Kɩɖaŋ // nɛ ɛ-tɛ intɛrɩjɛrɩ waa naalɛ, ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛYe ɖɩkpaɣ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ se ɖɩkpaɣ nɛ ɖɩmaɣzɩ// Ñɔɔzɩ tʋmɩyɛ nɖɩ ɖɩ-taa pamaɣ mayaɣ nakɛyɛ nɛ ɖɩ-taa lɛ, ŋnaɣ mayaɣ ŋga kɛwɛ ndɩ nɛ mayaɣ ŋga yɔ./// >>> closest_integer(value: ""10"")
/// 10
/// >>> closest_integer(value: ""15.3"")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value: String) -> Int {
","func closest_integer(value: String) -> Int {
    if let number = Double(value) {
        return Int(number.rounded(.awayFromZero))
    }
    return 0 // or handle error as needed
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: ""10"") == 10)
assert(closest_integer(value: ""14.5"") == 15)
assert(closest_integer(value: ""-15.5"") == -16)
assert(closest_integer(value: ""15.3"") == 15)
assert(closest_integer(value: ""0"") == 0)"
HumanEval_100,kbp_Latn,swift,"
// Kɩɖaŋ: // i kɛna pɩyɛ ndɩ ɖɩ-tɛ wɛtʊ (i+1). // Pɩpɩsɩɣ ɛ-tɛ pɩyɛ ndɩ ɖɩ-tɛtʊ taa, ɖenɖe ɛyʊ wɛtʊ // - ɛ-tɛ nabʊyʊ taa lɛ, yee n ɛ-tɛ nabʊyʊ kɔyɔ. - ye n kɛ ɛyʊ ɛyʊ yɔ, pʊtɔbʊʊ se ɛyʊ ɛ-tɛ ɛyʊ.// Pʊtʊnaa mba pɛwɛ pʊtʊnaa mba pa-wayɩ yɔ pa-taa yɔ: // Kajalaɣ n̄ɩɣyʋʋ taa lɛ, n̄ɩɣlɩm n̄ɩmbʋ wɛna. // Ye ŋha-ɖʋ ɛyʊ kʊyʊmʊʊ n kɔyɔ, pɩwɛɛ se ŋñɔɔzɩ ɛ-tɛ pɩyɛ ndɩ ndɩ./// >>> make_a_pile(n: 3)
/// [3, 5, 7]
func make_a_pile(n: Int) -> [Int] {
","func make_a_pile(n: Int) -> [Int] {
    var pile = [Int]()
    var currentLevelStones = n
    
    for _ in 0..<n {
        pile.append(currentLevelStones)
        if n % 2 == 0 {
            currentLevelStones += 2
        } else {
            currentLevelStones += 2
        }
    }
    
    return pile
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_a_pile(n: 3) == [3, 5, 7])
assert(make_a_pile(n: 4) == [4, 6, 8, 10])
assert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])
assert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])
assert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"
HumanEval_101,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // nɛ ɛtayɩ tɔm pee nɛ ɛpɩsɩnɩ tɔm pee ndɩ ndɩ. Ŋkaɣ naʋ tɔm pee wena awɛ tayʋʋ nɛ hɩlaɣ yaa tɩyɛ yɔ./// >>> words_string(s: ""Hi, my name is John"")
/// [""Hi"", ""my"", ""name"", ""is"", ""John""]
/// >>> words_string(s: ""One, two, three, four, five, six"")
/// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
func words_string(s: String) -> [String] {
","func words_string(s: String) -> [String] {
    let separators = CharacterSet(charactersIn: "", "")
    return s.components(separatedBy: separators).filter { !$0.isEmpty }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_string(s: ""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""])
assert(words_string(s: ""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: ""Hi, my name"") == [""Hi"", ""my"", ""name""])
assert(words_string(s: ""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: """") == [] as [String])
assert(words_string(s: ""ahmed     , gamal"") == [""ahmed"", ""gamal""])"
HumanEval_102,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // ye pɩfɛyɩ kɔyɔ, pɩpɔzʋʋ se ɖɩpɩsɩɣ -1.// kɩlɩna wɛʊ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ// Tʋma ana a-taa lɛ, pakpaɣ ɛyʊ ɛ-ñʊʊ mayaɣ x nɛ y nɛ papɩsɩna-ɩ ɛ-ñʊʊ mayaɣ /// >>> choose_num(x: 12, y: 15)
/// 14
/// >>> choose_num(x: 13, y: 12)
/// -1
func choose_num(x: Int, y: Int) -> Int {
","func choose_num(x: Int, y: Int) -> Int {
    // Determine the starting and ending range values
    let start = min(x, y)
    let end = max(x, y)
    
    // Iterate from the end of the range to the start
    for num in (start...end).reversed() {
        // Check if the current number is even
        if num % 2 == 0 {
            return num
        }
    }
    
    // Return -1 if no even number is found
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(choose_num(x: 12, y: 15) == 14)
assert(choose_num(x: 13, y: 12) == -1)
assert(choose_num(x: 33, y: 12354) == 12354)
assert(choose_num(x: 5234, y: 5233) == -1)
assert(choose_num(x: 6, y: 29) == 28)
assert(choose_num(x: 27, y: 10) == -1)
assert(choose_num(x: 7, y: 7) == -1)
assert(choose_num(x: 546, y: 546) == 546)"
HumanEval_103,kbp_Latn,swift,"
extension Int: Error {}
        
// Kɩɖaʋ: Yee n ɛkɩlɩ m yɔ, pɩsɩna -1.// Ñɔɔzɩ tɔm ndʋ tɩ-yɔɔ tɔm nɛ ŋla nɛ tɩtalɩ ɛ-cɔlɔ kpam nɛ ŋlɛɣzɩ-tʋ nɛ tɩpɩsɩ binɛɛrɩ tɔm. // kɩ-tɛ hɔɔlɩŋ weyi ɛ-taa n nɛ m pɛtɛyɩ ɖama yɔ (n nɛ m pɛtɛyɩ ɖama).// Pʊtɔbʊʊ se paha-ŋ nimero waa naalɛ n nɛ m, nɛ ña-tʋmɩyɛ lɛ se ŋmaɣzɩ nɛ ŋtɩlɩ /// >>> rounded_avg(n: 1, m: 5)
/// .success(""0b11"")
/// >>> rounded_avg(n: 7, m: 5)
/// .failure(-1)
/// >>> rounded_avg(n: 10, m: 20)
/// .success(""0b1111"")
/// >>> rounded_avg(n: 20, m: 33)
/// .success(""0b11010"")
func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
","func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
    if n > m {
        return .failure(-1)
    }
    
    let count = m - n + 1
    let sum = (n + m) * count / 2
    let average = Double(sum) / Double(count)
    let roundedAverage = Int(average.rounded())
    let binaryString = String(roundedAverage, radix: 2)
    
    return .success(""0b"" + binaryString)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rounded_avg(n: 1, m: 5) == .success(""0b11""))
assert(rounded_avg(n: 7, m: 13) == .success(""0b1010""))
assert(rounded_avg(n: 964, m: 977) == .success(""0b1111001010""))
assert(rounded_avg(n: 996, m: 997) == .success(""0b1111100100""))
assert(rounded_avg(n: 560, m: 851) == .success(""0b1011000010""))
assert(rounded_avg(n: 185, m: 546) == .success(""0b101101110""))
assert(rounded_avg(n: 362, m: 496) == .success(""0b110101101""))
assert(rounded_avg(n: 350, m: 902) == .success(""0b1001110010""))
assert(rounded_avg(n: 197, m: 233) == .success(""0b11010111""))
assert(rounded_avg(n: 7, m: 5) == .failure(-1))
assert(rounded_avg(n: 5, m: 1) == .failure(-1))
assert(rounded_avg(n: 5, m: 5) == .success(""0b101""))"
HumanEval_104,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Tɔzɩ se: Pɩwɛɛ se patɩlɩ ɛzɩma patɩŋna nɛ pɔñɔɔzɩ matʋ ndʋ tɩ-yɔɔ yɔ.// kɩ-taa lɛ, ɛyʊ ɛfɛyɩna ɛ-tɛ ɛyʊ mayaɣ nakɛyɛ. // Ye ɖɩhaɣ ɛyʊ kʊyʊmʊʊ kʊyʊmʊʊ x, ɖɩpɩsɩɣ ɛyʊ kʊyʊmʊʊ kʊyʊmʊʊ /// >>> unique_digits(x: [15, 33, 1422, 1])
/// [1, 15, 33]
/// >>> unique_digits(x: [152, 323, 1422, 10])
/// [] as [Int]
func unique_digits(x: [Int]) -> [Int] {
","func unique_digits(x: [Int]) -> [Int] {
    return x.filter { number in
        var hasEvenDigit = false
        var num = number
        while num > 0 {
            if (num % 10) % 2 == 0 {
                hasEvenDigit = true
                break
            }
            num /= 10
        }
        return !hasEvenDigit
    }.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])
assert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])
assert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])
assert(unique_digits(x: [135, 103, 31]) == [31, 135])"
HumanEval_105,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: (Cɔnɩ aɖakaɣ ""Ɛyʋ kʋɖʋm"", ""Ɛyaa naalɛ"", ""Ɛyaa naadozo"", ""Ɛyaa naanza"", ""Ɛyaa kagbanzɩ"", ""Ɛyaa loɖo"", ""Ɛyaa lʋbɛ"", ""Ɛyaa lutozo"", ""Ɛyaa nakʋ"")// nɛ ɖɩlɛɣzɩna paa mayaɣ ŋga nɛ ka-hɩɖɛ kpaɣ // Ye ŋha-ɖʋ tam nabʊyʊ yɔ, kpaɣ 1 nɛ 9 pɛ-hɛkʊ taa nɛ ŋñɔɔzɩ-wɛ./// >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])
/// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
/// If the array is empty, return an empty array:
/// >>> by_length(arr: [] as [Int])
/// [] as [String]
/// If the array has any strange number ignore it:
/// >>> by_length(arr: [1, -1, 55])
/// [""One""]
func by_length(arr: [Int]) -> [String] {
","func by_length(arr: [Int]) -> [String] {
    let numberNames: [Int: String] = [
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine""
    ]
    
    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }
                                           .sorted(by: >)
    
    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? """" }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""])
assert(by_length(arr: [] as [Int]) == [] as [String])
assert(by_length(arr: [1, -1, 55]) == [""One""])
assert(by_length(arr: [1, -1, 3, 2]) == [""Three"", ""Two"", ""One""])
assert(by_length(arr: [9, 4, 8]) == [""Nine"", ""Eight"", ""Four""])"
HumanEval_106,kbp_Latn,swift,"
// Kɩɖaʋ: // i tɛ tɔmpiye nɖɩ ɖɩkɛ 1 nɛ i pɛ-tɛ tɔmpiye ndɩ ndɩ (1 * 2 * ... * i) yɔ. // Mɛnpaɣzɩɣ kpaɣʋ 1. // yaa lɛɛna taa lɛ, pɩlɩɣ 1 nɛ piwolo i pɛ-hɛkʊ taa. Ɛtɛzɩɣ lɩzʋʋ size ɛ-tɛ n wɛ ɛzɩ ɛ-tɛ i wɛ ɛzɩ ɛ-tɛ i yɔ.// Ɖɩkpaɣ fɩkɩnatɛɛrɩ fɩkɩnatɛɛrɩ n ɛzɩ pɩyʊ yɔ, /// >>> f(n: 5)
/// [1, 2, 6, 24, 15]
func f(n: Int) -> [Int] {
","func f(n: Int) -> [Int] {
    func factorial(_ x: Int) -> Int {
        guard x > 1 else { return 1 }
        return (1...x).reduce(1, *)
    }
    
    func sumTo(_ x: Int) -> Int {
        return (1...x).reduce(0, +)
    }
    
    var result = [Int]()
    for i in 1...n {
        if i % 2 == 0 {
            result.append(factorial(i))
        } else {
            result.append(sumTo(i))
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(f(n: 5) == [1, 2, 6, 24, 15])
assert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])
assert(f(n: 1) == [1])
assert(f(n: 3) == [1, 2, 6])"
HumanEval_107,kbp_Latn,swift,"
// Kɩɖaʋ 1: // palindromes intègres qui se trouvent dans la gamme ((1, n), inclusive. // Yee paha-ɖʋ ɛyʊ kʊyʊmʊʊ n kɔyɔ, ɖɩpɩsɩɣ ɛyʊ kʊyʊmʊ ŋgʊ kɩwɛna ɛyʊ kʊyʊm nɛ ɛyʊ kʊyʊm yɔ./// >>> even_odd_palindrome(n: 3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(n: 12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n: Int) -> (Int, Int) {
","func even_odd_palindrome(n: Int) -> (Int, Int) {
    func isPalindrome(_ num: Int) -> Bool {
        let str = String(num)
        return str == String(str.reversed())
    }
    
    var evenCount = 0
    var oddCount = 0
    
    for i in 1...n {
        if isPalindrome(i) {
            if i % 2 == 0 {
                evenCount += 1
            } else {
                oddCount += 1
            }
        }
    }
    
    return (evenCount, oddCount)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_palindrome(n: 123) == (8, 13))
assert(even_odd_palindrome(n: 12) == (4, 6))
assert(even_odd_palindrome(n: 3) == (1, 2))
assert(even_odd_palindrome(n: 63) == (6, 8))
assert(even_odd_palindrome(n: 25) == (5, 6))
assert(even_odd_palindrome(n: 19) == (4, 6))
assert(even_odd_palindrome(n: 9) == (4, 5))
assert(even_odd_palindrome(n: 1) == (0, 1))"
HumanEval_108,kbp_Latn,swift,"
Ɖɩkpaɣ ɛzɩ 123 wɛna nimasɩ -1, 2 nɛ 3.// Yee nimero nakʋyʋ ɛwɛ kɩjɛyʊʊ kɔyɔ, ɛ-tɛ kajalaɣ nimero kɩjɛyʊʊ kɔyɔ: // kɩ-tɛ ɛyʊ kʊyʊmʊʊ ŋgʊ kɩ-tɛ kʊyʊmʊʊ kɩlɩna 0 yɔ. // Ma tʋmɩyɛ nɖɩ payaɣ se count_nums yɔ nɛ ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa pamaɣ hɔɔlɩŋ ɛnɩ yɔ nɛ ɖɩpɩsɩɣ /// >>> count_nums(arr: [] as [Int])
/// 0
/// >>> count_nums(arr: [-1, 11, -11])
/// 1
/// >>> count_nums(arr: [1, 1, 2])
/// 3
func count_nums(arr: [Int]) -> Int {
","func count_nums(arr: [Int]) -> Int {
    return arr.filter { number in
        var n = number
        var sumOfDigits = 0

        while n != 0 {
            sumOfDigits += n % 10
            n /= 10
        }

        return sumOfDigits > 0
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_nums(arr: [] as [Int]) == 0)
assert(count_nums(arr: [-1, -2, 0]) == 0)
assert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)
assert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)
assert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)
assert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)
assert(count_nums(arr: [0, 1]) == 1)
assert(count_nums(arr: [1]) == 1)"
HumanEval_109,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Tɔzɩ se: pɩhaɣ waɖɛ se matriki ŋgʋ kɩ-taa tɔm kɩlɩ cɛyʋʋ yɔ, kɩwɛna tɔm kɩlɩʋ.// Yee matʊ ndʊ ɖɩha-ɩ yɔ tɩfɛyɩ kɔyɔ, pɩpɩsɩɣ true. // nɛ pɩtɛ lɛ, pɩpɩsɩɣ true else pɩpɩsɩɣ false. // Yee pɩsaŋ se ɖɩpɩzɩ ɖɩlɩzɩ ñɩɣlɩm pɩyʊ weyi ɛ-taa wɛ ñɩɣlɩm yɔ nɛ ɖɩlabɩnɩ tʋmɩyɛ tɔm ndʊ tɩwɛ pɩ-tɛɛ yɔ // kɩ-tɛ kajalaɣ lone, pʊ-tɔbʊʊ se 0 ñɩnɖɛ. Pɩtɛ lɛ, ɖɩkpaɣ kɩ-tɛ kɩlɛmʋʋ nɛ ɖɩlɛɣzɩ-kʋ nɛ ɖɩɖʋna kɩ-tɛ kɩlɛmʋʋ hɔɔlʋʋ ŋgʋ kɩ-taa.// N̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ ɖʋʋ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ yɔɔ n̄ɩɣyʋʋ kʋyʋmʋʋ.Ŋpɩzɩɣ ŋla tʋmɩyɛ nɖɩ tam sakɩyɛ.// tʊma wena palakɩ tʊma sɔsɔna ana a-yɔɔ yɔ: Pɩpɩzɩɣ nɛ pɩla se patɩlɩ matriki nɛ pɩtaakɩlɩ ɖɔʋ nɛ pɩtɛ lɛ, pala tʋmɩyɛ nɖɩ.Ŋpɩzɩɣ nɛ ŋlɩzɩ mbʋ ŋsɔɔlaa yɔ nɛ ŋlabɩnɩ tʋmɩyɛ.Ɖɩwɛna 'arr' matʊ N intɛrɩjɛrɩ waa arr[1], arr[2], ..., arr[N]./// >>> move_one_ball(arr: [3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given array.
/// >>> move_one_ball(arr: [3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// array by performing any number of right shift operations.
func move_one_ball(arr: [Int]) -> Bool {
","func move_one_ball(arr: [Int]) -> Bool {
    guard !arr.isEmpty else { return true }
    
    let n = arr.count
    var breakPointCount = 0
    
    // Find the number of break points where the array is decreasing
    for i in 0..<n {
        if arr[i] > arr[(i + 1) % n] {
            breakPointCount += 1
        }
    }
    
    // If there's at most one break point, the array can be right shifted
    return breakPointCount <= 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)
assert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)
assert(move_one_ball(arr: [4, 3, 1, 2]) == false)
assert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)
assert(move_one_ball(arr: [] as [Int]) == true)"
HumanEval_110,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Pɩtɛkɛ mbʋ lɛ, pɩpɩsɩɣ ""Aayɩ"".// nɛ lst1 tɛ lɛɛtʊ kpeekpe taa lɛ, pɩpɩsɩɣ ""ƐƐƐƐ"".// Yee pɩpɩzɩɣ se pɛlɛɣzɩ wondu lst1 nɛ lst2 pɛ-hɛkʋ taa nɛ pɩla se // Paɖɩzɩɣ hɔɔlɩŋ weyi ɛ-taa papɩzɩɣ nɛ pɛlɛɣzɩ lst1 nɛ lst2 yɔ.// nɛ pɩpɩsɩ lst1 kɛ matrice nɛ ɛ-taa wɛ mbʊ yɔ.Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ// Tɔmpiye ɖɩnɛ ɖɩ-taa, ŋkaɣ labʊ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ nabʊlɛ taa yɔ, /// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])
/// ""YES""
/// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])
/// ""NO""
/// It is assumed that the input arrays will be non-empty.
func exchange(lst1: [Int], lst2: [Int]) -> String {
","func exchange(lst1: [Int], lst2: [Int]) -> String {
    var hasOddInLst1 = false
    var hasEvenInLst2 = false
    
    for num in lst1 {
        if num % 2 != 0 {
            hasOddInLst1 = true
            break
        }
    }
    
    for num in lst2 {
        if num % 2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasOddInLst1 {
        return ""YES""
    }
    
    if hasEvenInLst2 {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == ""YES"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == ""NO"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == ""NO"")
assert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == ""NO"")
assert(exchange(lst1: [100, 200], lst2: [200, 200]) == ""YES"")"
HumanEval_111,kbp_Latn,swift,"
// Kɩɖaʋ: // Ye tɔm pee naayɛ ɛñɔɔzʋʋna ɖama yɔ, pɩpɔzʋʋ se ɖɩpɩsɩna-yɛ tɩŋa. Takayɩhatʋ ndʋ tɩtamsɩna \\ Takayɩhatʋ ndʋ tɩ-yɔɔ papɩzɩɣ patɩŋna nɛ patɩlɩ yɔ \\ yɔ// Ye ŋha-ɩ tɔmpiye nɖɩ ɖɩwɩlɩɣ mayaɣ cikpelaɣ ŋga kɛwɛna mayaɣ cikpelaɣ yɔ, pɩsɩna nɛ ŋlɩzɩ tɔm kpou nakʋyʋ./// >>> histogram(test: ""a b c"")
/// [""a"" : 1, ""b"" : 1, ""c"" : 1]
/// >>> histogram(test: ""a b b a"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""a b c a b"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""b b b b a"")
/// [""b"" : 4]
/// >>> histogram(test: """")
/// [:] as [String : Int]
func histogram(test: String) -> [String : Int] {
","func histogram(test: String) -> [String : Int] {
    var letterCount: [String: Int] = [:]

    // Split the string into an array of letters
    let letters = test.split(separator: "" "").map { String($0) }

    // Count occurrences of each letter
    for letter in letters {
        letterCount[letter, default: 0] += 1
    }

    // Determine the maximum number of occurrences
    guard let maxCount = letterCount.values.max() else {
        return [:] as [String : Int]
    }

    // Filter the letterCount dictionary to only include letters with the max count
    let result = letterCount.filter { $0.value == maxCount }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(histogram(test: ""a b b a"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c a b"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c d g"") == [""a"" : 1, ""b"" : 1, ""c"" : 1, ""d"" : 1, ""g"" : 1])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: ""b b b b a"") == [""b"" : 4])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: """") == [:] as [String : Int])
assert(histogram(test: ""a"") == [""a"" : 1])"
HumanEval_112,kbp_Latn,swift,"
// Kɩɖaʋ kɩdɛɛka // Pɩwɛɛ se ŋpɩsɩɣ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ pɩ-tɛ.// Ɛyʋ pɩzɩɣ nɛ ɛyɔɔdɩ se ɛ-tɔm kɛ palindrome ye ɛ-tɔm ɛ-tɔm kɛ mbʋ ɖɔɖɔ.// nɛ pʋwayɩ lɛ, ŋtazɩ nɛ ŋna se pɩlɩʋ ŋgʋ kɩ-taa ŋlɩɣ yɔ, kɩkɛ palindrome yaa we. // Ɖɩha-ɖʋ tɔmpiye naalɛ s nɛ c, pɩwɛɛ se ɖɩlɩzɩ tɔmpiye nɖɩ ɖɩ-tɩŋa s taa yɔ ɖɩ-taa nɛ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa c taa yɔ.Tʋma wena ŋlakɩ yɔ/// >>> reverse_delete(s: ""abcde"", c: ""ae"")
/// (""bcd"", false)
/// >>> reverse_delete(s: ""abcdef"", c: ""b"")
/// (""acdef"", false)
/// >>> reverse_delete(s: ""abcdedcba"", c: ""ab"")
/// (""cdedc"", true)
func reverse_delete(s: String, c: String) -> (String, Bool) {
","func reverse_delete(s: String, c: String) -> (String, Bool) {
    // Remove characters from s that are in c
    let filteredString = s.filter { !c.contains($0) }
    
    // Check if the resulting string is a palindrome
    let isPalindrome = filteredString == String(filteredString.reversed())
    
    // Return the resulting string and the palindrome check result
    return (filteredString, isPalindrome)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(reverse_delete(s: ""abcde"", c: ""ae"") == (""bcd"", false))
assert(reverse_delete(s: ""abcdef"", c: ""b"") == (""acdef"", false))
assert(reverse_delete(s: ""abcdedcba"", c: ""ab"") == (""cdedc"", true))
assert(reverse_delete(s: ""dwik"", c: ""w"") == (""dik"", false))
assert(reverse_delete(s: ""a"", c: ""a"") == ("""", true))
assert(reverse_delete(s: ""abcdedcba"", c: """") == (""abcdedcba"", true))
assert(reverse_delete(s: ""abcdedcba"", c: ""v"") == (""abcdedcba"", true))
assert(reverse_delete(s: ""vabba"", c: ""v"") == (""abba"", true))
assert(reverse_delete(s: ""mamma"", c: ""mia"") == ("""", true))"
HumanEval_113,kbp_Latn,swift,"
// nɛ ɛyʊ ɛ-ñʊʊ taa lɛ, ɛ-tɛ ɛyʊ ɛ-ñʊʊ taa lɛ, ɛ-tɛ ɛyʊ ɛ-ñʊʊ taa lɛ. // tɔmpiye i. "" ɖenɖe lɛ, pɩwɛɛ se pɛlɛɣzɩ i waa tɩŋa nɛ mayaɣ // Pɩwɛɛ se tɔmpiye i nɖɩ ɖɩlɩna tɔmpiye nɖɩ ɖɩ-taa yɔ, ɖɩkɛ tɔmpiye ndɩ ɖɩ-tɛ tɔmpiye.// Ye ŋwɛna matrice taa tɔmɩŋ, paa matrice nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmɩŋ kɛ nimero waa yeke, pɩsɩna matrice. /// >>> odd_count(lst: [""1234567""])
/// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
/// >>> odd_count(lst: [""3"", ""11111111""])
/// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
func odd_count(lst: [String]) -> [String] {
","func odd_count(lst: [String]) -> [String] {
    return lst.map { str in
        let oddCount = str.filter { ""13579"".contains($0) }.count
        return ""the number of odd elements \(oddCount)n the str\(oddCount)ng \(oddCount) of the \(oddCount)nput.""
    }
}

// Example Usage
print(odd_count(lst: [""1234567""]))
print(odd_count(lst: [""3"", ""11111111""]))","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(odd_count(lst: [""1234567""]) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""])
assert(odd_count(lst: [""3"", ""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""])
assert(odd_count(lst: [""271"", ""137"", ""314""]) == [""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""])"
HumanEval_114,kbp_Latn,swift,"
// Kɩɖaʋ kɩdɛɛka Kʋñɔŋ ŋgʋ kɩ-taa ŋwɛɛ yɔ// Ye ŋha-ɩ intɛrɩjɛrɩ waa nɩŋgbaŋgʊʊ kɔyɔ, ŋñɩnɩɣ pʊtʊ weyi ɛfɛyɩ kɩ-taa yɔ ɛ-tɛ pʊtʊnaa cikpema yɔ /// >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(nums: [-1, -2, -3])
/// -6
func minSubArraySum(nums: [Int]) -> Int {
","func minSubArraySum(nums: [Int]) -> Int {
    guard !nums.isEmpty else { return 0 }
    
    var currentMin = nums[0]
    var overallMin = nums[0]
    
    for i in 1..<nums.count {
        currentMin = min(nums[i], currentMin + nums[i])
        overallMin = min(overallMin, currentMin)
    }
    
    return overallMin
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)
assert(minSubArraySum(nums: [-1, -2, -3]) == -6)
assert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)
assert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)
assert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)
assert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)
assert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)
assert(minSubArraySum(nums: [-10]) == -10)
assert(minSubArraySum(nums: [7]) == 7)
assert(minSubArraySum(nums: [1, -1]) == -1)"
HumanEval_115,kbp_Latn,swift,"
// Kɩɖaʋ 1: // Wɩlɩ tam ɛzɩma pɩwɛɛ se ŋhɛzɩ n̄ɩɣtʋ ndʋ yɔ. 'Ɩkaɣ tɩŋnʋʋ pɔŋ yɔɔ nɛ ɩhɛzɩ pɔŋ taa.'Nɛ pɔpɔŋ tɩŋa taa wɛ kɩmaŋ.Paa lɔkɔ ŋgʋ lɛ, kɩwɛna pɔʋ ŋgʋ kɩ-taa papɩzɩɣ nɛ palɩzɩ lɩm yɔ.Nɛ paa 1 weyi lɛ, ɛ-taa kɛ lɩm yeke.Paa n̄ɩnʋʋ ŋgʋ lɛ, kɩwɛna n̄ɩɣyʋʋ kʋyʋmʋʋ./// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)
/// 6
/// Example 2:
/// >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)
/// 5
/// Example 3:
/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
func max_fill(grid: [[Int]], capacity: Int) -> Int {
","func max_fill(grid: [[Int]], capacity: Int) -> Int {
    var totalWater = 0
    for row in grid {
        for unit in row {
            if unit == 1 {
                totalWater += 1
            }
        }
    }
    return (totalWater + capacity - 1) / capacity
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)
assert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)
assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
HumanEval_116,kbp_Latn,swift,"
Pɩwɛɛ se pala-ɖɩ nɛ ɖɩwɛɛ ɛzɩ ɖɩnaɣ yɔ:// Ye ɛ-ñʋŋ taa ɛɖanɛ yɔ, ɛ-ñʋŋ taa lɛ, ɛ-ñʋŋ taa lɛ, ɛ-ñʋŋ taa lɛ, ɛ-ñʋŋ taa lɛ.// ɛyʊ ɛ-ñʊʊ taa ɛyʊ hʊtʊ taa ɛyʊ ɛ-ñʊʊ taa ɛyʊ ɛ-ñʊʊ taa ɛyʊ ɛ-ñʊʊ taa ɛyʊ ɛ-ñʊʊ taa ɛyʊ ɛ-ñʊʊ taa.// Kata kʋnɛ kɩ-taa, pɩwɛɛ se ŋñɔɔzɩ nimero waa mba pɛtɛkɛ kɩmaŋ yɔ, nɛ ŋmaɣzɩna /// >>> sort_array(arr: [1, 5, 2, 3, 4])
/// [1, 2, 3, 4, 5]
/// >>> sort_array(arr: [-2, -3, -4, -5, -6])
/// [-6, -5, -4, -3, -2]
/// >>> sort_array(arr: [1, 0, 2, 3, 4])
/// [0, 1, 2, 3, 4]
func sort_array(arr: [Int]) -> [Int] {
","func sort_array(arr: [Int]) -> [Int] {
    return arr.sorted {
        let onesCount1 = $0.nonNegativeOnesCount()
        let onesCount2 = $1.nonNegativeOnesCount()
        return (onesCount1, $0) < (onesCount2, $1)
    }
}

extension Int {
    func nonNegativeOnesCount() -> Int {
        return self < 0 ? 0 : self.nonBitCount()
    }
    
    private func nonBitCount() -> Int {
        var count = 0
        var num = self
        while num > 0 {
            count += num & 1
            num >>= 1
        }
        return count
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])
assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])
assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])
assert(sort_array(arr: [] as [Int]) == [] as [Int])
assert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])
assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
HumanEval_117,kbp_Latn,swift,"
// Kɩɖaŋ: // Tɔzɩ se ŋpɩzɩɣ ŋmaɣzɩ se tɔm ndʋ ŋma yɔ tɩ-taa lɛ, masɩ nɛ hɔɔlɩŋ yeke wɛna. // Yee ɛ-tɛ matʋ s fɛyɩ kɔyɔ, pʋbʋ lɛ, tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ matʋ kɩfalʊʊ. // n tɔmpiye, nɛ pɩsa nɛ tɔm pee ana awɛɛ tɔmpiye s taa. // tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee kpeekpe kpou taa nɛ pɩ-taa wɛ tɔm pee // Ye ŋha-ɖʋ tɔmpiye s nɛ natʊyʊ n kɔyɔ, paɖʊ-ŋ tʋmɩyɛ se ŋlabɩnɩ tʋmɩyɛ /// >>> select_words(s: ""Mary had a little lamb"", n: 4)
/// [""little""]
/// >>> select_words(s: ""Mary had a little lamb"", n: 3)
/// [""Mary"", ""lamb""]
/// >>> select_words(s: ""simple white space"", n: 2)
/// [] as [String]
/// >>> select_words(s: ""Hello world"", n: 4)
/// [""world""]
/// >>> select_words(s: ""Uncle sam"", n: 3)
/// [""Uncle""]
func select_words(s: String, n: Int) -> [String] {
","func select_words(s: String, n: Int) -> [String] {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    let words = s.split(separator: "" "")
    var result: [String] = []
    
    for word in words {
        let consonantCount = word.filter { !vowels.contains($0) }.count
        if consonantCount == n {
            result.append(String(word))
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(select_words(s: ""Mary had a little lamb"", n: 4) == [""little""])
assert(select_words(s: ""Mary had a little lamb"", n: 3) == [""Mary"", ""lamb""])
assert(select_words(s: ""simple white space"", n: 2) == [] as [String])
assert(select_words(s: ""Hello world"", n: 4) == [""world""])
assert(select_words(s: ""Uncle sam"", n: 3) == [""Uncle""])
assert(select_words(s: """", n: 4) == [] as [String])
assert(select_words(s: ""a b c d e f"", n: 1) == [""b"", ""c"", ""d"", ""f""])"
HumanEval_118,kbp_Latn,swift,"
// Kɩɖaʋ: Ŋpɩzɩɣ ŋmaɣzɩ se tɔmpiye nɖɩ ɖɩ-taa ŋnaɣ-ɩ yɔ, ɖɩ-taa wɛ aŋglɛɛ kʋnʋŋ taa masɩ ɖeke.// nɛ ɛñɩnɩ ɛ-tɛ matʋ ndʋ tɩ-taa pama tɔm pee ana yɔ. // Tɔmpiye nɖɩ ɖɩ-paɣzʋʋ nɛ ɖɩ-tɛŋ paatasɩɣ-ɖɩ kalʋʋ. Ye ŋtɩpɩzɩ yɔ, pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa tɔm fɛyɩ yɔ.// tɔmpiye nɖɩ ɖɩlɩna tɔmpiye nɖɩ ɖɩ-nɩwaŋ yɔɔ yɔ ɖɩ-taa tɔm naalɛ (ɖɩ-tɛ tɔmpiye ɖɩlɩna tɔmpiye sɔsɔyɛ yɔɔ).Ŋŋkalɩɣ tɔm piye naɖɩyɛ lɛ, ŋñɩnɩɣ nɛ ŋnaɣ mayaɣ ŋga kɛwɛna nɔɔ kʋɖʋmaɣ nɛ tɔm piye nɖɩ ɖɩ-taa ŋmaɣ yɔ./// >>> get_closest_vowel(word: ""yogurt"")
/// ""u""
/// >>> get_closest_vowel(word: ""FULL"")
/// ""U""
/// >>> get_closest_vowel(word: ""quick"")
/// """"
/// >>> get_closest_vowel(word: ""ab"")
/// """"
func get_closest_vowel(word: String) -> String {
","func get_closest_vowel(word: String) -> String {
    let vowels = Set(""aeiouAEIOU"")
    var foundVowel: Character? = nil
    
    for i in stride(from: word.count - 2, through: 1, by: -1) {
        let currentIndex = word.index(word.startIndex, offsetBy: i)
        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)
        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)
        
        if vowels.contains(word[currentIndex]) && 
            !vowels.contains(word[previousIndex]) && 
            !vowels.contains(word[nextIndex]) {
            foundVowel = word[currentIndex]
            break
        }
    }
    
    return foundVowel != nil ? String(foundVowel!) : """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: ""yogurt"") == ""u"")
assert(get_closest_vowel(word: ""full"") == ""u"")
assert(get_closest_vowel(word: ""easy"") == """")
assert(get_closest_vowel(word: ""eAsy"") == """")
assert(get_closest_vowel(word: ""ali"") == """")
assert(get_closest_vowel(word: ""bad"") == ""a"")
assert(get_closest_vowel(word: ""most"") == ""o"")
assert(get_closest_vowel(word: ""ab"") == """")
assert(get_closest_vowel(word: ""ba"") == """")
assert(get_closest_vowel(word: ""quick"") == """")
assert(get_closest_vowel(word: ""anime"") == ""i"")
assert(get_closest_vowel(word: ""Asia"") == """")
assert(get_closest_vowel(word: ""Above"") == ""o"")"
HumanEval_119,kbp_Latn,swift,"
// Kɩɖaŋ: // Ye pɩsaŋ se ɛyʋ ɛlɩzɩ tɔmpiye kɩbanɖɛ yɔ, ɛpɩsɩnɩ tɔmpiye ""ɛɛɛ"" nɛ ye pɩsaŋ se ɛyʋ ɛpɩsɩnɩ tɔmpiye ""ɛɛɛ"" yɔ, ɛpɩsɩnɩ tɔmpiye ""ɛɛɛ"".// '()) ' pɩtɩkɛ mbʋ. Ɖɩkpaɣ ɛzɩ: tɔmpiye '(())))' wɛ ɖeu, ɛlɛ tɔmpiye // Paɣtʊ ndʊ tɩ-taa lɛ, yee pɩ-taa ɛyʊ ɛ-tɔm ɛlaba camɩyɛ kɔyɔ, pɩ-tɛ ɛ-tɔm wɛ ɖeu.// pɩlɩʋ ŋgʋ kɩ-taa tɔm pee kɩbana naayɛ wɛɛ yɔ.// Ña-tʋmɩyɛ lɛ se ŋtazɩ nɛ ŋna se pɩpɩzɩɣ nɛ pɩsa nɛ ŋkpɛndɩ tɔmpiye naalɛ nɛ ŋɖʋ-ɖɩ nɛ ɖɩwɛɛna ɖama taa.// kɩ-taa lɛ, ŋpɩzɩɣ ŋtɩŋnɩ "" (_) "" yaa "" (_) "" yɔɔ nɛ ŋñɔtʋʋnɩ-ɩ.// Paha-ŋ matʋ naalɛ, matʋ naalɛ wɛna kɩ-tɩ yɔɔ./// >>> match_parens(lst: [""()("", "")""])
/// ""Yes""
/// >>> match_parens(lst: ["")"", "")""])
/// ""No""
func match_parens(lst: [String]) -> String {
","func match_parens(lst: [String]) -> String {
    let combined1 = lst[0] + lst[1]
    let combined2 = lst[1] + lst[0]
    
    func isBalanced(_ s: String) -> Bool {
        var balance = 0
        for char in s {
            if char == ""("" {
                balance += 1
            } else if char == "")"" {
                balance -= 1
            }
            if balance < 0 {
                return false
            }
        }
        return balance == 0
    }
    
    if isBalanced(combined1) || isBalanced(combined2) {
        return ""Yes""
    } else {
        return ""No""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(match_parens(lst: [""()("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", "")""]) == ""No"")
assert(match_parens(lst: [""(()(())"", ""())())""]) == ""No"")
assert(match_parens(lst: ["")())"", ""(()()(""]) == ""Yes"")
assert(match_parens(lst: [""(())))"", ""(()())((""]) == ""Yes"")
assert(match_parens(lst: [""()"", ""())""]) == ""No"")
assert(match_parens(lst: [""(()("", ""()))()""]) == ""Yes"")
assert(match_parens(lst: [""(((("", ""((())""]) == ""No"")
assert(match_parens(lst: ["")(()"", ""(()(""]) == ""No"")
assert(match_parens(lst: ["")("", "")(""]) == ""No"")
assert(match_parens(lst: [""("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", ""(""]) == ""Yes"")"
HumanEval_120,kbp_Latn,swift,"
// Kɩɖaʋ 1: // nɛ k-kpɩzʊʊ nɛ k-kpɩzʊʊ taa lɛ, k-kpɩzʊʊ taa lɛ, k-kpɩzʊʊ taa lɛ. // Ɖɩhaɣ ɛyʊ ɛ-tɛ intɛrɩ waa nɛ kɩlʊʊ kʊyʊmʊʊ, pɩpɩsɩɣ ɛyʊ ɛ-tɛ intɛrɩ waa mba pa-taa paa weyi ɛ-tɛ ɛ-tɛ intɛrɩ kʊyʊmʊʊ yɔ./// >>> maximum(arr: [-3, -4, 5], k: 3)
/// [-4, -3, 5]
/// Example 2:
/// >>> maximum(arr: [4, -4, 4], k: 2)
/// [4, 4]
/// Example 3:
/// >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)
/// [2]
/// Note:
/// 1. The length of the array will be in the range of [1, 1000].
/// 2. The elements in the array will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
func maximum(arr: [Int], k: Int) -> [Int] {
","func maximum(arr: [Int], k: Int) -> [Int] {
    guard k > 0 else { return [] }
    let sortedArr = arr.sorted(by: >)
    let maxElements = Array(sortedArr.prefix(k))
    return maxElements.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])
assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])
assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])
assert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])
assert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])
assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])
assert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])
assert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])
assert(maximum(arr: [4, -4], k: 2) == [-4, 4])
assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])
assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
HumanEval_121,kbp_Latn,swift,"
// Kɩɖaŋ // Ye ɖɩhaɣ intɛrɩjɛrɩ waa mba pɛfɛyɩ kɩ-tɩ yɔɔ yɔ, ɖɩpɩsɩɣ paɣtʊ ndʊ tɩ-tɩŋa tɩ-tɛ paɣtʊ ndʊ tɩ-taa paa weyi ɛwɛna ɛ-tɩ yɔɔ yɔ./// >>> solution(lst: [5, 8, 7, 1])
/// 12
/// >>> solution(lst: [3, 3, 3, 3, 3])
/// 9
/// >>> solution(lst: [30, 13, 24, 321])
/// 0
func solution(lst: [Int]) -> Int {
","func solution(lst: [Int]) -> Int {
    var sum = 0
    for (index, value) in lst.enumerated() {
        if index % 2 == 0 && value % 2 != 0 {
            sum += value
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solution(lst: [5, 8, 7, 1]) == 12)
assert(solution(lst: [3, 3, 3, 3, 3]) == 9)
assert(solution(lst: [30, 13, 24, 321]) == 0)
assert(solution(lst: [5, 9]) == 5)
assert(solution(lst: [2, 4, 8]) == 0)
assert(solution(lst: [30, 13, 23, 32]) == 23)
assert(solution(lst: [3, 13, 2, 9]) == 3)"
HumanEval_122,kbp_Latn,swift,"
// Kɩɖaʋ: // kɩ-tɛ kɩkpɛdʊʊ ŋgʊ kɩ-taa lɛ, kʊɖʊmɩŋ naalɛ ŋgʊ kɩlɩna kajalaɣ k kʊɖʊmɩŋ taa.// Ye ɖɩhaɣ ɛyʊ ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ, ɛ-tɛ intɛrɩjɛrɩ waa taa lɛ./// >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
func add_elements(arr: [Int], k: Int) -> Int {
","func add_elements(arr: [Int], k: Int) -> Int {
    var sum = 0
    for i in 0..<k {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)
assert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)
assert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)
assert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)
assert(add_elements(arr: [1], k: 1) == 1)"
HumanEval_123,kbp_Latn,swift,"
// get_odd_collatz(5) pɩsɩna [1, 5] # Kollatz tɛtʊ taa lɛ 5 kɛ [5, 16, 8, 4, 2, 1], mbʊ pʊyɔɔ yɔ, ɛyʊ ɛ-ñʊʊ mayaɣ kɔyɔ 1 nɛ 5. // Kɩɖaʋ nakʋyʋ yɔ: 2. Ɛpɩsɩnɩ ɛ-tɛ matriki nɛ ɛ-tɛ matriki wɛɛ nɛ pɩpaɣlɩɣ.// 1. Collatz(1) kɛna [1]. // Cɔnɩ: // tɔmpiye nɛ pɩtasɩ 1. Tɔmpiye nɖɩ ɖɩ-taa lɛ, paa n ɛ-tɛ wazaɣ ŋga yɔ, tɔmpiye nɖɩ ɖɩ-tɛ wɛtʊ kaɣ talʋʋ 1.Ye tɔmpiye nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ ɖɩkɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ, tɔmpiye nɖɩ ɖɩ-wayɩ yɔ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ ɖɩ-tɛ tɔmpiye yɔ, ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ ɖɩ-tɛ tɔmpiye yɔ.// tɔmpiye kɩbɩnɖɛ kɔyɔ: yee tɔmpiye kɩbɩnɖɛ nɖɩ ɖɩkɛ ɛyʊ yɔ, tɔmpiye kɩɖɛɖɛɖɛ ɖɩkɛ hɔɔlʋʋ // ɛzɩ mbʊ yɔ: paɣzɩna ɛyʊ ɛ-tɛ ɛyʊ kʊyʊm n.// Collatz tɛ maɣzɩm kɛ maɣzɩm pɩlɩna matʋ taa nɛ pɩcɔna tɔmpiye nɖɩ ɖɩ-taa pama-ɖɩ yɔ.// Ye ɖɩhaɣ ɛyʊ kʊyʊm mbʊ yɔ, pɩpɩsɩɣ ɛyʊ weyi ɛ-tɛ ɛyʊ kʊyʊm mbʊ yɔ nɛ ɛ-tɛ ɛyʊ kʊyʊm mbʊ yɔ./// >>> get_odd_collatz(n: 5)
/// [1, 5]
func get_odd_collatz(n: Int) -> [Int] {
","func get_odd_collatz(n: Int) -> [Int] {
    var collatzSequence: [Int] = []
    var number = n

    while number != 1 {
        if number % 2 != 0 {
            collatzSequence.append(number)
        }
        if number % 2 == 0 {
            number /= 2
        } else {
            number = 3 * number + 1
        }
    }

    collatzSequence.append(1) // append 1 as the sequence ends at 1

    let sortedOdds = collatzSequence.sorted()
    
    return sortedOdds
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])
assert(get_odd_collatz(n: 5) == [1, 5])
assert(get_odd_collatz(n: 12) == [1, 3, 5])
assert(get_odd_collatz(n: 1) == [1])"
HumanEval_124,kbp_Latn,swift,"
Pɩwɛɛ se pama kɩyakʋ ŋgʋ nɛ kɩwɛɛ ɛzɩ: f-y-y-y-y-y yɔ.Pɩfɛyɩ se fenasɩ nzɩ sɩwɛɛ nɛ sɩkɩlɩ fenasɩ 12 yaa sɩtɩtalɩ fenasɩ 1 yɔ.Pɩtasɩ lɛ, kɩyakɩŋ weyi ɩwɛ fenaɣ 1, 3, 5, 7, 8, 10, 12 taa yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 30 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 29 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 1 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 29 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 29 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 29 yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ 1 yɔ.Pɩtɛ alɩwaatʊ ndʊ tɩ-taa lɛ, pɩfɛyɩ se pɛtɛzɩ-tʊ.// Kɩyakʋ ŋgʋ kɩkɛ kɩmʋnaʋ ye paɣtʋ ndʋ tɩkɔŋ yɔ tɩ-tɩŋa tɩ-taa natʋyʋ ɩwɛɛ yɔ: // pɩpɩsɩɣ true yee kɩyakʋ ɛ-taa ɛwɛ camɩyɛ kɔyɔ false. // Pɩwɛɛ se ŋma tʋmɩyɛ nɖɩ ɖɩñɔɔzʋʋ kɩyakʋ nakʋyʋ yɔ nɛ /// >>> valid_date(date: ""03-11-2000"")
/// true
/// >>> valid_date(date: ""15-01-2012"")
/// false
/// >>> valid_date(date: ""04-0-2040"")
/// false
/// >>> valid_date(date: ""06-04-2020"")
/// true
/// >>> valid_date(date: ""06/04/2020"")
/// false
func valid_date(date: String) -> Bool {
","func valid_date(date: String) -> Bool {
    // Check if the date is empty
    if date.isEmpty {
        return false
    }
    
    // Split the date into components using the ""-"" delimiter
    let components = date.split(separator: ""-"")
    
    // Ensure the date has exactly three components
    if components.count != 3 {
        return false
    }
    
    // Ensure the date components are integers
    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {
        return false
    }
    
    // Check if the month is within the valid range
    if month < 1 || month > 12 {
        return false
    }
    
    // Define the number of days in each month
    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    // Check the day range for each month
    if day < 1 || day > daysInMonth[month] {
        return false
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(valid_date(date: ""03-11-2000"") == true)
assert(valid_date(date: ""15-01-2012"") == false)
assert(valid_date(date: ""04-0-2040"") == false)
assert(valid_date(date: ""06-04-2020"") == true)
assert(valid_date(date: ""01-01-2007"") == true)
assert(valid_date(date: ""03-32-2011"") == false)
assert(valid_date(date: """") == false)
assert(valid_date(date: ""04-31-3000"") == false)
assert(valid_date(date: ""06-06-2005"") == true)
assert(valid_date(date: ""21-31-2000"") == false)
assert(valid_date(date: ""04-12-2003"") == true)
assert(valid_date(date: ""04122003"") == false)
assert(valid_date(date: ""20030412"") == false)
assert(valid_date(date: ""2003-04"") == false)
assert(valid_date(date: ""2003-04-12"") == false)
assert(valid_date(date: ""04-2003"") == false)"
HumanEval_125,kbp_Latn,swift,"
extension Int: Error {}
        
// Kɩɖaŋ // alphabet, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 Pɩwɛɛ se pɛtɛyɩ-ɩ nɛ ',' ye pɩfɛyɩna yɔ, pɩwɛɛ se ŋyele nɛ pamaɣna takayɩsɩ cikpesi nzɩ sɩwɛ tɔm hʋʋ hɔɔlʋʋ taa yɔ.// Ye ŋwɛna tɔm pee sakɩyɛ yɔ, pɩhaɣ-ŋ tɔm pee sakɩyɛ nɛ ŋtayɩ-yɛ nɛ ŋyele pɩ-taa ɖenɖe pɩfɛyɩ yɔ./// >>> split_words(txt: ""Hello world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""Hello,world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""abcdef"")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
","func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains("" "") {
        let words = txt.split(separator: "" "").map { String($0) }
        return .success(words)
    } else if txt.contains("","") {
        let words = txt.split(separator: "","").map { String($0) }
        return .success(words)
    } else {
        let oddOrderedLowerCaseLetters = txt.filter { char in
            if let asciiValue = char.asciiValue {
                let order = asciiValue - Character(""a"").asciiValue!
                return order % 2 == 1
            }
            return false
        }
        return .failure(oddOrderedLowerCaseLetters.count)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: ""Hello world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello,world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello world,!"") == .success([""Hello"", ""world,!""]))
assert(split_words(txt: ""Hello,Hello,world !"") == .success([""Hello,Hello,world"", ""!""]))
assert(split_words(txt: ""abcdef"") == .failure(3))
assert(split_words(txt: ""aaabb"") == .failure(2))
assert(split_words(txt: ""aaaBb"") == .failure(1))
assert(split_words(txt: """") == .failure(0))"
HumanEval_126,kbp_Latn,swift,"
// Kɩɖaŋ Ɛ-tɛ lɛɣtʋ ñɩnʋʋ tʋmɩyɛ nɖɩ payaɣ se ""numéro"", ɖɩpɩsɩɣ false.Yee ɛyʊ ɛ-tɛ ɛyʊ kɩfalʊ ɛwɛna ɛ-tɛ ɛyʊ kɩfalʊ kɔyɔ, ɛ-tɛ ɛyʊ kɩfalʊ ɛ-tɛ ɛyʊ kɩfalʊ.// Ye ŋha-ɩ nimero waa sakɩyɛ yɔ, ɛpɩsʋʋna paa pa-taa ɛfɛyɩ yaa pa-taa fɛyɩ yɔ./// >>> is_sorted(lst: [5])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])
/// false
func is_sorted(lst: [Int]) -> Bool {
","func is_sorted(lst: [Int]) -> Bool {
    guard !lst.isEmpty else { return true }

    var previous = lst[0]
    var duplicates = 0

    for i in 1..<lst.count {
        if lst[i] < previous {
            return false
        } else if lst[i] == previous {
            duplicates += 1
            if duplicates > 1 {
                return false
            }
        } else {
            duplicates = 0
        }
        previous = lst[i]
    }

    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_sorted(lst: [5]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)
assert(is_sorted(lst: [] as [Int]) == true)
assert(is_sorted(lst: [1]) == true)
assert(is_sorted(lst: [3, 2, 1]) == false)
assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)
assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
HumanEval_127,kbp_Latn,swift,"
// [Input/output] samples: // Ye hɔɔlɩŋ naalɛ ɩtɩkpɛndɩ yɔ, pɩsɩna ""Aayɩ"".// Pɩtɛkɛ mbʋ yɔ, pɩpɩsɩɣ ""Aayɩ"".// Yee tɔm hɛkʋ taa tɔm kɛ kajalaɣ tɔm kɔyɔ, ŋpɩsɩɣ ""ƐƐƐƐ"", // nɛ ɛ-ɖaɣlɩkɩŋ lɛ 1, nɛ pɩtɛkɛ kajalaɣ n̄ɩnʋʋ. // Kɩɖaʋ, hɔɔlɩŋ weyi ɩ-taa (1, 3), (2, 4) nɛ (2, 3) pɛtɛyɩ ɖama yɔ.// hɛkʋ taa hɛkʋ taa lɛ, pɩkɛ kajalaɣ n̄ɩnʋʋ. // Ña-tʋmɩyɛ lɛ se ŋtɩlɩ se ɛzɩmtaa pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna nɛ pɩtɛŋna// Paa hɔɔlʊʊ ŋgʊ lɛ, pamaɣzɩɣ se kɩ-paɣzɩyɛ wɛna pʊcɔ yaa kɩ-tɛ tɛm. // pɩ-taa lɛ, ɖɩnaɣ paɣzʋʋ nɛ ɖɩtɛ. // Pɩtɛ alɩwaatʊ ndʊ tɩ-taa lɛ, alɩwaatʊ ndʊ tɩ-taa (paɣzɩ, tɩtɛ)Ɖɩkpaɣ ɛzɩ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ.// Paha-ŋ alɩwaatʋ naalɛ, /// >>> intersection(interval1: (1, 2), interval2: (2, 3))
/// ""NO""
/// >>> intersection(interval1: (-1, 1), interval2: (0, 4))
/// ""NO""
/// >>> intersection(interval1: (-3, -1), interval2: (-5, 5))
/// ""YES""
func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
","func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
    // Helper function to determine if a number is prime
    func isPrime(_ num: Int) -> Bool {
        if num <= 1 {
            return false
        }
        if num <= 3 {
            return true
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false
        }
        var i = 5
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Find the start and end of the intersection
    let intersectStart = max(interval1.0, interval2.0)
    let intersectEnd = min(interval1.1, interval2.1)
    
    // Calculate the length of the intersection
    let intersectionLength = intersectEnd - intersectStart

    // Check if intersection length is positive and prime
    if intersectionLength > 0 && isPrime(intersectionLength) {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersection(interval1: (1, 2), interval2: (2, 3)) == ""NO"")
assert(intersection(interval1: (-1, 1), interval2: (0, 4)) == ""NO"")
assert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == ""YES"")
assert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == ""YES"")
assert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (3, 5)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (1, 2)) == ""NO"")
assert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == ""NO"")"
HumanEval_128,kbp_Latn,swift,"
// Kɩɖaʋ: // Tɔzɩ: pɩpɩsɩɣ nil nɛ pɩfɛyɩna tɔm. // paa mayaɣ ŋga lɛ, ka-taa lɛ, 1, -1 yaa 0 wɛna.// kɩkpɛndaɣ ŋga kɛwɛna hɔɔlɩŋ ndɩ ndɩ taa yɔ nɛ hɔɔlɩŋ weyi ɛ-taa pamaɣna hɔɔlɩŋ ndɩ ndɩ yɔ.// Paha-ŋ intɛrɩ waa sakɩyɛ nɛ pɩwɛɛ se ŋpɩsɩ /// >>> prod_signs(arr: [1, 2, 2, -4])
/// 9
/// >>> prod_signs(arr: [0, 1])
/// 0
/// >>> prod_signs(arr: [] as [Int])
/// nil
func prod_signs(arr: [Int]) -> Int? {
","func prod_signs(arr: [Int]) -> Int? {
    // Return nil for empty array
    if arr.isEmpty {
        return nil
    }

    // Calculate the sum of magnitudes
    let sumOfMagnitudes = arr.reduce(0) { sum, num in
        return sum + abs(num)
    }

    // Calculate the product of all signs
    let productOfSigns = arr.reduce(1) { product, num in
        if num > 0 {
            return product * 1
        } else if num < 0 {
            return product * -1
        } else {
            return 0
        }
    }

    // Return the result of sum of magnitudes multiplied by product of signs
    return sumOfMagnitudes * productOfSigns
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prod_signs(arr: [1, 2, 2, -4]) == -9)
assert(prod_signs(arr: [0, 1]) == 0)
assert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)
assert(prod_signs(arr: [] as [Int]) == nil)
assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)
assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)
assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)
assert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
HumanEval_129,kbp_Latn,swift,"
// Kɩɖaŋ: // Pɩpɩsɩɣ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-lɛ.// Pɩkɛna ɖɔnɛ se tɔm cosuu wɛ ndɩ ndɩ. // Lɩmaɣzɩyɛ A[j] = Lɩmaɣzɩyɛ B[j]. // nɛ pɩsa nɛ lst_A[i] < lst_B[i] nɛ j (1 <= j < i) kɔyɔ ɖɩwɛnɩ // nɛ pɩtasɩnɩ lst_B, pʋ-tɔbʋʋ se, ɛyʊ ɛ-tɛ ɛyʊ kɩfalʊ kɔyɔ i (1 <= i <= k) (Yele ɖɩya-wɛ se lst_A nɛ lst_B), lst_A wɛna tɔm pee kɩtatasɩ sakɩyɛ.// pɩtɛ lɛ, ɖɩkpaɣ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-lɛ// Nʋmɔʋ A (kʋ-ɖaɣlɩkɩŋ k) wɛ cikpeluu nɛ Nʋmɔʋ B (kʋ-ɖaɣlɩkɩŋ k) ye:ŊYEKƐƐƐ se ŋtaatasɩ naʋ nɔɔyʋ.(Cɔnɩ aɖakaɣ ŋga kɛwɛ takayaɣ kanɛ ka-taa yɔ.)// Ɖɩcɔna kɔyɔ, ɖɩnaɣ se nʋmɔʋ ŋgʋ kɩ-ɖaɣlɩkɩŋ talɩ k yɔ, kɩ-taa lɛ, ɖɩnaɣ se ɖɩɖɔmna k pilinzi ɖeyi ɖeyi (ɛtɛkɛ // Ɛyʋ ɛ-hɔɔlʋʋ taa. Pʋ-tɔbʋʋ se ŋpɩzɩɣ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛna yɔ nɛ ŋtazɩ kɩ-taa.Ŋpɩzɩɣ ŋlɩzɩ-ɩ paa lone nɖɩ ɖɩ-taa nɛ ŋwolo lone nɖɩ ɖɩ-taa ŋsɔɔlaa yɔ.Ŋpɩzɩɣ ŋpaɣzɩna nɛ ŋñɩnɩ n̄ɩɣyʋʋ cikpeluu ŋgʋ kɩ-ɖaɣlɩkɩŋ talɩɣ k yɔ.// inclusive lɩzɩɣna tam kʋɖʋmʋʋ kɛ grille waa taa. Paa nimero waa tɩŋa payɩ weyi ɩwɛ [1, N * N] yɔ, ɛ-taa wɛ ñɩm.// Ye ɖɩkpaɣ ɛyʊ ɛ-tɛ ɛ-tɛ ñʊʊ mayaɣ kɔyɔ, ɛ-tɛ ñʊʊ mayaɣ kɔyɔ N nɛ ɛ-tɛ ñʊʊ mayaɣ kɔyɔ N (N >= 2) nɛ ɛ-tɛ ñʊʊ mayaɣ kɔyɔ k, /// >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)
/// [1, 2, 1]
/// >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)
/// [1]
func minPath(grid: [[Int]], k: Int) -> [Int] {
","func minPath(grid: [[Int]], k: Int) -> [Int] {
    let n = grid.count
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    struct Path: Comparable {
        let cells: [Int]
        
        static func < (lhs: Path, rhs: Path) -> Bool {
            return lhs.cells.lexicographicallyPrecedes(rhs.cells)
        }
    }
    
    var minPath: Path? = nil
    
    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {
        var currentPath = currentPath
        currentPath.append(grid[x][y])
        
        if currentPath.count == k {
            let newPath = Path(cells: currentPath)
            if minPath == nil || newPath < minPath! {
                minPath = newPath
            }
            return
        }
        
        for direction in directions {
            let newX = x + direction.0
            let newY = y + direction.1
            if newX >= 0 && newX < n && newY >= 0 && newY < n {
                dfs(x: newX, y: newY, k: k, currentPath: currentPath)
            }
        }
    }
    
    for i in 0..<n {
        for j in 0..<n {
            dfs(x: i, y: j, k: k, currentPath: [])
        }
    }
    
    return minPath!.cells
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])
assert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])
assert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])
assert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])
assert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])
assert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])
assert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])
assert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])
assert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])
assert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])
assert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"
HumanEval_130,kbp_Latn,swift,"
// Kɩɖaŋ: // kajalaɣ n + 1 nɩŋgbanzɩ Tribonacci tʊma taa. // Paha-ŋ nimero entier n weyi ɛfɛyɩ kɩgalʊʊ yɔ, pɩwɛɛ se ŋpɩsɩ ɛ-tɛ matrice nɛ 2+3+3=8 (Tɩnaɣ ɖɔɖɔ pɩ-tɛ tɔm kɩsɔzɩtʋ taa.)Tɔɔnaɣ ŋga ka-taa lɛ,Tʋma wena ŋlakɩ yɔ a-taa lɛ, ŋpɩzɩɣ nɛ ŋmaɣzɩnɩ mbʋ ŋlaba yɔ.// Kɩɖaʋ nakʋyʋ yɔ: // tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ye n ɛfɛyɩ yɔ. // tri (n) = 1 + n / 2, ye n ɛkpɛndɩ kɔyɔ. Tɔɔnaɣ ŋga ka-taa lɛ,// Tribonacci tɔmpiye lɩna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye: Ɛlɛ, ɛyaa ɩɩsɩŋ Tribonacci tɔm piye nɖɩ.Paa anɩ ɛsɩm Fibonacci tɛ n̄ɩɣlɩm n̄ɩɣlɩm, pama-kʋ nɛ pɩtalɩ pɩnaɣ 1900 taa./// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
","func tri(n: Int) -> [Int] {
    guard n >= 0 else { return [] }
    if n == 0 { return [1] }
    if n == 1 { return [1, 3] }
    if n == 2 { return [1, 3, 2] }
    
    var sequence = [1, 3, 2]
    
    for i in 3...n {
        if i % 2 == 0 {
            sequence.append(1 + i / 2)
        } else {
            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]
            sequence.append(nextVal)
        }
    }
    
    return sequence
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])"
HumanEval_131,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // Ye nimasɩ tɩŋa ɩkɛ kɩkpɛndɩnaa yɔ, pɩpɩsɩɣ 0.// Ye ɖɩhaɣ ɛyʊ kʊyʊmʊʊ kʊyʊmʊʊ n, ɖɩpɩsɩɣ ɛyʊ kʊyʊmʊʊ kʊyʊmʊʊ tɔmpiye. /// >>> digits(n: 1)
/// 1
/// >>> digits(n: 4)
/// 0
/// >>> digits(n: 235)
/// 15
func digits(n: Int) -> Int {
","func digits(n: Int) -> Int {
    var num = n
    var product = 1
    var hasOdd = false
    
    while num > 0 {
        let digit = num % 10
        if digit % 2 != 0 {
            hasOdd = true
            product *= digit
        }
        num /= 10
    }
    
    return hasOdd ? product : 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digits(n: 5) == 5)
assert(digits(n: 54) == 5)
assert(digits(n: 120) == 1)
assert(digits(n: 5014) == 5)
assert(digits(n: 98765) == 315)
assert(digits(n: 5576543) == 2625)
assert(digits(n: 2468) == 0)"
HumanEval_132,kbp_Latn,swift,"
// ɖenɖe pɩtatɩɩfɛyɩ yɔ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ, pɩ-taa lɛ.// Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye true yee nɛ yee pɛtɛyɩ-ɖɩ nɛ tɔmpiye kʊɖʊmɖɩyɛ yɔ.// Ñɔɔzɩ tʋmɩyɛ naɖɩyɛ nɛ ɖɩ-taa lɛ, ŋpɩzɩɣ ŋma tɔm piye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ ɖɩ-taa lɛ, ŋtazɩ tɔm piye nɖɩ ɖɩ-taa lɛ, ŋtazɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ŋtazɩ tɔmpiye nɖɩ ɖɩ-taa lɛ./// >>> is_nested(string: ""[[]]"")
/// true
/// >>> is_nested(string: ""[]]]]]]][[[[[]"")
/// false
/// >>> is_nested(string: ""[][]"")
/// false
/// >>> is_nested(string: ""[]"")
/// false
/// >>> is_nested(string: ""[[][]]"")
/// true
/// >>> is_nested(string: ""[[]][["")
/// true
func is_nested(string: String) -> Bool {
","func is_nested(string: String) -> Bool {
    var stack: [Character] = []
    var nested = false

    for bracket in string {
        if bracket == ""["" {
            stack.append(bracket)
        } else if bracket == ""]"" {
            if let last = stack.last, last == ""["" {
                stack.removeLast()
                if !stack.isEmpty {
                    nested = true
                }
            } else {
                return false
            }
        }
    }
    return nested
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_nested(string: ""[[]]"") == true)
assert(is_nested(string: ""[]]]]]]][[[[[]"") == false)
assert(is_nested(string: ""[][]"") == false)
assert(is_nested(string: ""[]"") == false)
assert(is_nested(string: ""[[[[]]]]"") == true)
assert(is_nested(string: ""[]]]]]]]]]]"") == false)
assert(is_nested(string: ""[][][[]]"") == true)
assert(is_nested(string: ""[[]"") == false)
assert(is_nested(string: ""[]]"") == false)
assert(is_nested(string: ""[[]][["") == true)
assert(is_nested(string: ""[[][]]"") == true)
assert(is_nested(string: """") == false)
assert(is_nested(string: ""[[[[[[[["") == false)
assert(is_nested(string: ""]]]]]]]]"") == false)"
HumanEval_133,kbp_Latn,swift,"
// Kɩɖaŋ: // paa wonuu ŋgʊ lɛ kɩ-tɛ pɩlɩʊ taa nɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-nɔɔ.// Pɩwɛɛ se ŋyele nɛ tɔmpiye nɖɩ ɖɩ-taa pamaɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ, ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ.// Paha-ŋ nimbrɩwaa sakɩyɛ. /// >>> sum_squares(lst: [1.0, 2.0, 3.0])
/// 14
/// >>> sum_squares(lst: [1.0, 4.0, 9.0])
/// 98
/// >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> sum_squares(lst: [1.4, 4.2, 0.0])
/// 29
/// >>> sum_squares(lst: [-2.4, 1.0, 1.0])
/// 6
func sum_squares(lst: [Double]) -> Int {
","func sum_squares(lst: [Double]) -> Int {
    return lst.map { ceil($0) } // Round each element to the upper int (Ceiling)
              .map { Int($0 * $0) } // Square each element
              .reduce(0, +) // Sum all squared elements
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)
assert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)
assert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)
assert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)
assert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)
assert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)
assert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)
assert(sum_squares(lst: [0.0]) == 0)
assert(sum_squares(lst: [-1.0]) == 1)
assert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"
HumanEval_134,kbp_Latn,swift,"
// Kɩɖaŋ: // Cɔnɩ nɛ ŋna: tɔm piye ""word"" kɛna matʋ ndɩ ndɩ ndɩ ndɩ nɛ tɩ-taa lɛ, ɖɩkpaɣ lone nɛ ɖɩtayɩ ɖama.Tɔm piye naɖɩyɛ hɔɔlʋʋ nakʋyʋ, nɛ ye pɩtaakɛ mbʋ yɔ, pɩkɛ cɛtɩm tɔm.// tɔmpiye naɖɩyɛ taa lɛ, ɖɩkɛ alɩfaabɛɛtɩ tɔmpiye nɛ ɖɩtɛkɛ // Ñɔɔzɩ tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ true yee kɛdɛzaɣ mayaɣ kɔyɔ /// >>> check_if_last_char_is_a_letter(txt: ""apple pie"")
/// false
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e"")
/// true
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e "")
/// false
/// >>> check_if_last_char_is_a_letter(txt: """")
/// false
func check_if_last_char_is_a_letter(txt: String) -> Bool {
","func check_if_last_char_is_a_letter(txt: String) -> Bool {
    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {
        return false
    }
    
    if lastChar.isLetter {
        let words = txt.split(separator: "" "")
        if let lastWord = words.last {
            return lastWord.count == 1
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(check_if_last_char_is_a_letter(txt: ""apple"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e"") == true)
assert(check_if_last_char_is_a_letter(txt: ""eeeee"") == false)
assert(check_if_last_char_is_a_letter(txt: ""A"") == true)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie "") == false)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie 1"") == false)
assert(check_if_last_char_is_a_letter(txt: """") == false)
assert(check_if_last_char_is_a_letter(txt: ""eeeee e "") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pie"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e "") == false)"
HumanEval_135,kbp_Latn,swift,"
// Kɩɖaŋ: // kɩ-tɛ kɩlɩm ndɩ ndɩ. // yee pɩfɛyɩ kɔyɔ, pɩpɩsɩɣ -1.Pɩfɛyɩ se kɩkɩlɩ yaa kɩtalɩ kɩ-tɛ kɩlɛlʋʋ.// Lɩzɩ tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ ɛyʊ sɔsɔtʊ yɔ, ɖɩ-tɛ kɩlɩm yɔ, nɖɩ ɖɩ-tɛ kɩlɩm yɔ./// >>> can_arrange(arr: [1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(arr: [1, 2, 3])
/// -1
func can_arrange(arr: [Int]) -> Int {
","func can_arrange(arr: [Int]) -> Int {
    for i in (1..<arr.count).reversed() {
        if arr[i] < arr[i - 1] {
            return i
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)
assert(can_arrange(arr: [1, 2, 4, 5]) == -1)
assert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)
assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)
assert(can_arrange(arr: [] as [Int]) == -1)"
HumanEval_136,kbp_Latn,swift,"
// Kɩɖaŋ: // Yee ɛyʊ ɛfɛyɩna ɛyʊ kʊyʊm yaa ɛyʊ kɩlɛyʊ kɔyɔ, ɛ-tɛ kʊyʊm yaa ɛ-tɛ kʊyʊm.// nɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ ɛtɛ'b' kɛna ñɩɩɩ ñɩŋgʋ nɛ 'b' kɛna ñɩɩɩ ñɩŋgʋ.// Ñɔɔzɩ tʋmɩyɛ naɖɩyɛ nɛ ɖɩpɩsɩɣ tɔmpiye (a, b), ɖenɖe 'a' kɛna /// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])
/// (nil, 1)
/// >>> largest_smallest_integers(lst: [] as [Int])
/// (nil, nil)
/// >>> largest_smallest_integers(lst: [0])
/// (nil, nil)
func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
","func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
    var largestNegative: Int? = nil
    var smallestPositive: Int? = nil

    for number in lst {
        if number < 0 {
            if largestNegative == nil || number > largestNegative! {
                largestNegative = number
            }
        } else if number > 0 {
            if smallestPositive == nil || number < smallestPositive! {
                smallestPositive = number
            }
        }
    }

    return (largestNegative, smallestPositive)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))
assert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))
assert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))
assert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))
assert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))
assert(largest_smallest_integers(lst: [0]) == (nil, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"
HumanEval_137,kbp_Latn,swift,"
enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
// Tɔzɩ se: yee pamaɣna ɛyʊ ɛ-tɛ ɛyʊ yɔɔ ɛzɩ ɛyʊ yɔɔ tɔm yɔ, pɩpɩzɩɣ pɩkɛ . yaa , // Ye kɩ-kɩwɛʋ kɩmaŋ kɔyɔ, pɩsɩɣnɩ-ɩ nɛ ɛlɩzɩ nil. // kɩlɩɣna lɛlʊ nɛ kɩpɩsɩɣ lɛlʊ sɔsɔʊ ɛ-tɛ lɛlʊ kɩlɛzɩtʊ taa. // Ñɔɔzɩ tʋmɩyɛ nɖɩ ɖɩmʋɣ intɛrɩjɛrɩwaa, float waa yaa strings waa mba pasɩŋnɩ /// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue(""2,3""))
/// .stringValue(""2,3"")
/// >>> compare_one(a: .stringValue(""5,1""), b: .stringValue(""6""))
/// .stringValue(""6"")
/// >>> compare_one(a: .stringValue(""1""), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
","func compare_one(a: Value, b: Value) -> Value? {
    func convertToDouble(value: Value) -> Double? {
        switch value {
        case .intValue(let int):
            return Double(int)
        case .doubleValue(let double):
            return double
        case .stringValue(let string):
            let formatter = NumberFormatter()
            formatter.locale = Locale(identifier: ""en_US_POSIX"")
            if string.contains("","") {
                formatter.decimalSeparator = "",""
            } else {
                formatter.decimalSeparator = "".""
            }
            return formatter.number(from: string)?.doubleValue
        }
    }
    
    let aDouble = convertToDouble(value: a)
    let bDouble = convertToDouble(value: b)
    
    if let aDouble = aDouble, let bDouble = bDouble {
        if aDouble > bDouble {
            return a
        } else if bDouble > aDouble {
            return b
        }
    }
    
    return nil
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue(""2,3"")) == .stringValue(""2,3""))
assert(compare_one(a: .stringValue(""5,1""), b: .stringValue(""6"")) == .stringValue(""6""))
assert(compare_one(a: .stringValue(""1""), b: .stringValue(""2"")) == .stringValue(""2""))
assert(compare_one(a: .stringValue(""1""), b: .intValue(1)) == nil)"
HumanEval_138,kbp_Latn,swift,"
// Kɩɖaʋ kɩdɛɛka // Ɖɩcɔna nɛ ɖɩna se paa mayaɣ ŋga lɛ, papɩzɩɣ pama-kɛ nɛ tɔmpiye 4 nɛ pama-kɛ ɖɔɖɔ nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 4 nɛ tɔmpiye 6 nɛ tɔmpiye 6 nɛ tɔmpiye 6 nɛ tɔmpiye 7 nɛ tɔmpiye 7 nɛ tɔmpiye 8 nɛ tɔmpiye 8 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9 nɛ tɔmpiye 9/// >>> is_equal_to_sum_even(n: 4)
/// false
/// >>> is_equal_to_sum_even(n: 6)
/// false
/// >>> is_equal_to_sum_even(n: 8)
/// true
func is_equal_to_sum_even(n: Int) -> Bool {
","func is_equal_to_sum_even(n: Int) -> Bool {
    if n <= 8 {
        return false
    }
    return n % 2 == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_equal_to_sum_even(n: 4) == false)
assert(is_equal_to_sum_even(n: 6) == false)
assert(is_equal_to_sum_even(n: 8) == true)
assert(is_equal_to_sum_even(n: 10) == true)
assert(is_equal_to_sum_even(n: 11) == false)
assert(is_equal_to_sum_even(n: 12) == true)
assert(is_equal_to_sum_even(n: 13) == false)
assert(is_equal_to_sum_even(n: 16) == true)"
HumanEval_139,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // ɖenɖe n > 0 yɔ (n-1)! * (n-2)! * ... * 1! // Payaɣ Brésil tɛtʊ taa tɔmpiye se: /// >>> special_factorial(n: 4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
func special_factorial(n: Int) -> Int {
","func factorial(_ n: Int) -> Int {
    return n <= 1 ? 1 : n * factorial(n - 1)
}

func special_factorial(n: Int) -> Int {
    var result = 1
    for i in 1...n {
        result *= factorial(i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(special_factorial(n: 4) == 288)
assert(special_factorial(n: 5) == 34560)
assert(special_factorial(n: 7) == 125411328000)
assert(special_factorial(n: 1) == 1)"
HumanEval_140,kbp_Latn,swift,"
// nɛ pʋwayɩ lɛ, ɖɩlɛɣzɩ lone ndɩ ɖɩ-taa tɔm nɛ - // nɛ yee pɩcɛzɩ nabʊlɛ mbʊ yɔ, // Ye ŋwɛna tɔm piye naɖɩyɛ yɔ, kpaɣ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ nɛ ŋlɛɣzɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ nɛ ŋlɛɣzɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ./// >>> fix_spaces(text: "" Example"")
/// ""Example""
/// >>> fix_spaces(text: "" Example 1"")
/// ""Example_1""
/// >>> fix_spaces(text: "" Example 2"")
/// ""_Example_2""
/// >>> fix_spaces(text: "" Example 3"")
/// ""_Example-3""
func fix_spaces(text: String) -> String {
","func fix_spaces(text: String) -> String {
    var result = """"
    var spaceCount = 0
    
    for character in text {
        if character == "" "" {
            spaceCount += 1
        } else {
            if spaceCount == 1 {
                result.append(""_"")
            } else if spaceCount > 1 {
                result.append(""-"")
            }
            result.append(character)
            spaceCount = 0
        }
    }
    
    if spaceCount == 1 {
        result.append(""_"")
    } else if spaceCount > 1 {
        result.append(""-"")
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: ""Example"") == ""Example"")
assert(fix_spaces(text: ""Mudasir Hanif "") == ""Mudasir_Hanif_"")
assert(fix_spaces(text: ""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"")
assert(fix_spaces(text: ""Exa   mple"") == ""Exa-mple"")
assert(fix_spaces(text: ""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"")"
HumanEval_141,kbp_Latn,swift,"
// Kɩɖaŋ: // - Kajalaɣ ñɩŋgʋ lɛ: ['txt', 'exe', 'dll']// latɛŋ masɩ taa lɛ, payaɣ se 'a'-'z' nɛ 'A'-'Z'.// - Kajalaɣ ñɩŋgʋ taa lɛ, pɩfɛyɩ se ŋyele nɛ tɔm pee wena awɛ tɩ-taa yɔ, awɛɛ falaa, nɛ pɩpɔzʋʋ se ŋpaɣzɩnɩ mayaɣ ŋga ka-taa // - Takayaɣ ŋga ka-hɩɖɛ wɛna ñɩɩyʊʊ nakʊyʊ '.' // - Takayaɣ mayaɣ taa mayaɣ kɔyɔ, pɩfɛyɩ se kɛwɛɛna nimasɩ naadozo yɔɔ ('0' - '9'). // nɛ ŋkatɩ: // Pɩkɛna takayaɣ nakɛyɛ hɩɖɛ se ɖɩkɛ toovenim ye ɖɩlakɩ nɛ ɖɩɖɔ tɔm ndʋ tɩkɔŋ yɔ tɩ-yɔɔ yɔ.// Yee tɔmpiye nɖɩ ɖɩ-hɩɖɛ ɛwɛ camɩyɛ yɔ, ɖɩpɩsɩɣ ""ɛɛɛ"" nɛ yee ɖɩfɛyɩ camɩyɛ yɔ, ɖɩpɩsɩɣ ""ɛɛɛ"".// Ñɔɔzɩ tʋmɩyɛ naɖɩyɛ nɛ ɖɩkpaɣ tɔmpiye nɖɩ ɖɩwɩlɩɣ takayaɣ nakɛyɛ hɩɖɛ yɔ nɛ ɖɩpɩsɩ /// >>> file_name_check(file_name: ""example.txt"")
/// ""Yes""
/// >>> file_name_check(file_name: ""1example.dll"")
/// ""No""
func file_name_check(file_name: String) -> String {
","func file_name_check(file_name: String) -> String {
    // Split by the dot.
    let components = file_name.split(separator: ""."", omittingEmptySubsequences: false)
    
    // Check if there's exactly one dot.
    guard components.count == 2 else {
        return ""No""
    }
    
    // Extract the prefix and suffix.
    let prefix = String(components[0])
    let suffix = String(components[1])
    
    // Check if the prefix is non-empty and starts with a letter.
    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {
        return ""No""
    }
    
    // Check if the suffix is one of the allowed types.
    let validSuffixes = [""txt"", ""exe"", ""dll""]
    guard validSuffixes.contains(suffix) else {
        return ""No""
    }
    
    // Count digits in the file name.
    let digitCount = file_name.filter { $0.isNumber }.count
    
    // Ensure that there are not more than 3 digits.
    guard digitCount <= 3 else {
        return ""No""
    }
    
    // If all checks pass, it's a valid file name.
    return ""Yes""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(file_name_check(file_name: ""example.txt"") == ""Yes"")
assert(file_name_check(file_name: ""1example.dll"") == ""No"")
assert(file_name_check(file_name: ""s1sdf3.asd"") == ""No"")
assert(file_name_check(file_name: ""K.dll"") == ""Yes"")
assert(file_name_check(file_name: ""MY16FILE3.exe"") == ""Yes"")
assert(file_name_check(file_name: ""His12FILE94.exe"") == ""No"")
assert(file_name_check(file_name: ""_Y.txt"") == ""No"")
assert(file_name_check(file_name: ""?aREYA.exe"") == ""No"")
assert(file_name_check(file_name: ""/this_is_valid.dll"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.wow"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.txt"") == ""Yes"")
assert(file_name_check(file_name: ""this_is_valid.txtexe"") == ""No"")
assert(file_name_check(file_name: ""#this2_i4s_5valid.ten"") == ""No"")
assert(file_name_check(file_name: ""@this1_is6_valid.exe"") == ""No"")
assert(file_name_check(file_name: ""this_is_12valid.6exe4.txt"") == ""No"")
assert(file_name_check(file_name: ""all.exe.txt"") == ""No"")
assert(file_name_check(file_name: ""I563_No.exe"") == ""Yes"")
assert(file_name_check(file_name: ""Is3youfault.txt"") == ""Yes"")
assert(file_name_check(file_name: ""no_one#knows.dll"") == ""Yes"")
assert(file_name_check(file_name: ""1I563_Yes3.exe"") == ""No"")
assert(file_name_check(file_name: ""I563_Yes3.txtt"") == ""No"")
assert(file_name_check(file_name: ""final..txt"") == ""No"")
assert(file_name_check(file_name: ""final132"") == ""No"")
assert(file_name_check(file_name: ""_f4indsartal132."") == ""No"")
assert(file_name_check(file_name: "".txt"") == ""No"")
assert(file_name_check(file_name: ""s."") == ""No"")"
HumanEval_143,kbp_Latn,swift,"
// Kɩɖaʋ 1: // tɔm pee wena awɛ tɔmpiye kɩfaɖɛ taa yɔ, pɩwɛɛ se awɛ ɛzɩ kajalaɣ ñɩnɖɛ yɔ. // nɛ ɛ-kɩɖaʊ kɛ ɛ-tɛ kajalaɣ tɔm, // nɛ pɩpɔzʋʋ se ŋyele nɛ tɔm pee wena awɛ kajalaɣ tɔm piye taa yɔ, // tɔm loyaɣ taa tɔm pee naayɛ wɛna nɛ pɩ-taa lɛ, ŋsɩɣna mayaɣ nakɛyɛ nɛ ŋtayɩ-yɛ.// Paha-ŋ tɔm pee wena awɛ ɛzɩ tɔm loyaɣ yɔ, /// >>> words_in_sentence(sentence: ""This is a test"")
/// ""is""
/// Example 2:
/// >>> words_in_sentence(sentence: ""lets go for swimming"")
/// ""go for""
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
func words_in_sentence(sentence: String) -> String {
","func words_in_sentence(sentence: String) -> String {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    let words = sentence.split(separator: "" "")
    let primeLengthWords = words.filter { isPrime($0.count) }
    return primeLengthWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_in_sentence(sentence: ""This is a test"") == ""is"")
assert(words_in_sentence(sentence: ""lets go for swimming"") == ""go for"")
assert(words_in_sentence(sentence: ""there is no place available here"") == ""there is no place"")
assert(words_in_sentence(sentence: ""Hi I am Hussein"") == ""Hi am Hussein"")
assert(words_in_sentence(sentence: ""go for it"") == ""go for it"")
assert(words_in_sentence(sentence: ""here"") == """")
assert(words_in_sentence(sentence: ""here is"") == ""is"")"
HumanEval_144,kbp_Latn,swift,"
Ŋpɩzɩɣ ŋmaɣzɩ se x nɛ n kɛ hɔɔlɩŋ weyi ɩfɛyɩnɩ nimero yɔ.// <numerator>/<denominator> ɖenɖe numérateur nɛ dénominateur pa-naalɛ pɛkɛ nimero waa tɩŋa nɛ pɛwɛ ɖeu yɔ. Pɩtasɩna se x nɛ n, pɛtɛyɩɣ ɖama nɛ pamaɣna hɔɔlɩŋ cikpeŋ nɛ pamaɣna-wɛ nɛ hɔɔlɩŋ cikpeŋ ɛnɩ yɔ:// x * n. Ɖɩkpaɣ kɔyɔ, tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye true yee x * n ɛ-tɛ tɔmpiye kɔyɔ, pɩkɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye false yɔ.// Ñɔ-tʋmɩyɛ lɛ se ŋlabɩnɩ tʋmɩyɛ tʋmɩyɛ nɖɩ ɖɩkaɣ kɛlɛʋ tɔm piye nɖɩ yɔ./// >>> simplify(x: ""1/5"", n: ""5/1"")
/// true
/// >>> simplify(x: ""1/6"", n: ""2/1"")
/// false
/// >>> simplify(x: ""7/10"", n: ""10/2"")
/// false
func simplify(x: String, n: String) -> Bool {
","func simplify(x: String, n: String) -> Bool {
    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {
        let parts = fraction.split(separator: ""/"").map { Int($0)! }
        return (numerator: parts[0], denominator: parts[1])
    }
    
    let (xNumerator, xDenominator) = parseFraction(fraction: x)
    let (nNumerator, nDenominator) = parseFraction(fraction: n)
    
    // Multiply the two fractions: (xNumerator * nNumerator) / (xDenominator * nDenominator)
    let resultNumerator = xNumerator * nNumerator
    let resultDenominator = xDenominator * nDenominator
    
    // Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator
    return resultNumerator % resultDenominator == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/6"", n: ""2/1"") == false)
assert(simplify(x: ""5/1"", n: ""3/1"") == true)
assert(simplify(x: ""7/10"", n: ""10/2"") == false)
assert(simplify(x: ""2/10"", n: ""50/10"") == true)
assert(simplify(x: ""7/2"", n: ""4/2"") == true)
assert(simplify(x: ""11/6"", n: ""6/1"") == true)
assert(simplify(x: ""2/3"", n: ""5/2"") == false)
assert(simplify(x: ""5/2"", n: ""3/5"") == false)
assert(simplify(x: ""2/4"", n: ""8/4"") == true)
assert(simplify(x: ""2/4"", n: ""4/2"") == true)
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/5"", n: ""1/5"") == false)"
HumanEval_145,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ// Tɔzɩ se: yee wondu ndɩ ndɩ wɛna ɖama yɔɔ lɛ, tɩ-taa mayaɣ kɔyɔ: // nɛ pɔcɔna nɛ pana se pɛtɛzɩ-wɛ pɩdɩɩfɛyɩ yaa pɛtɛzɩ-wɛ pɩdɩɩfɛyɩ. // Ma tʋmɩyɛ nɖɩ ɖɩñɔɔzʋʋ ɛyʊ ɛ-tɛ ɛyʊ yɔɔ yɔ./// >>> order_by_points(nums: [1, 11, -1, -11, -12])
/// [-1, -11, 1, -12, 11]
/// >>> order_by_points(nums: [] as [Int])
/// [] as [Int]
func order_by_points(nums: [Int]) -> [Int] {
","func order_by_points(nums: [Int]) -> [Int] {
    return nums.enumerated().sorted {
        let sum1 = digitSum($0.element)
        let sum2 = digitSum($1.element)
        if sum1 == sum2 {
            return $0.offset < $1.offset
        } else {
            return sum1 < sum2
        }
    }.map { $0.element }
}

func digitSum(_ number: Int) -> Int {
    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])
assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])
assert(order_by_points(nums: [] as [Int]) == [] as [Int])
assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])
assert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])
assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
HumanEval_146,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: // kajalaɣ nɛ kɛdɛzaɣ nimero waa mba pɛfɛyɩ kɩmaŋ yɔ (1, 3, 5, 7, 9). // kɩ-tɛ wondu ndɩ ndɩ ndʊ tɩkɩlɩ 10 yɔ nɛ tɩ-naalɛ Takayaɣ ŋga ka-taa pamaɣ size, ɛyʊ ɛ-tʊmɩyɛ lɛ se ɛlɩzɩ ɛ-tɛ tɔm nɛ ɛlɩzɩ-tʊ nɛ ɛ-tɛ tɔm./// >>> specialFilter(nums: [15, -73, 14, -15])
/// 1
/// >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])
/// 2
func specialFilter(nums: [Int]) -> Int {
","func specialFilter(nums: [Int]) -> Int {
    return nums.filter { num in
        let absNum = abs(num)
        
        guard absNum > 10 else {
            return false
        }
        
        let firstDigit = String(String(absNum).first!)
        let lastDigit = String(absNum % 10)
        
        let oddDigits: Set = [""1"", ""3"", ""5"", ""7"", ""9""]
        
        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(specialFilter(nums: [5, -2, 1, -5]) == 0)
assert(specialFilter(nums: [15, -73, 14, -15]) == 1)
assert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)
assert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)
assert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)
assert(specialFilter(nums: [1]) == 0)
assert(specialFilter(nums: [] as [Int]) == 0)"
HumanEval_147,kbp_Latn,swift,"
// Kɩɖaʋ: // nɛ a[i] + a[j] + a[k] kɛ 3 tam nabʊyʊ. // Pɩpɩsɩɣ tam nabudozo (a[i], a[j], a[k]) a ɖenɖe i < j < k, // Paa i weyi lɛ, ɛ-ñɩm kɔyɔ: a[i] = i * i - i + 1. // Pʊtɔbʊʊ se ŋwɛna ɛyʊ kʊyʊmʊm n. Pɩwɛɛ se ŋñɔɔzɩ ɛyʊ kʊyʊmʊm a weyi ɛ-ɖaɣlɩkɩŋ talɩɣ n yɔ. /// >>> get_max_triples(n: 5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
func get_max_triples(n: Int) -> Int {
","func get_max_triples(n: Int) -> Int {
    // Create the array a based on the problem description
    var a = [Int](repeating: 0, count: n)
    for i in 1...n {
        a[i - 1] = i * i - i + 1
    }
    
    var count = 0
    // Check for all possible triples
    for i in 0..<n {
        for j in (i + 1)..<n {
            for k in (j + 1)..<n {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count += 1
                }
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_max_triples(n: 5) == 1)
assert(get_max_triples(n: 6) == 4)
assert(get_max_triples(n: 10) == 36)
assert(get_max_triples(n: 100) == 53361)"
HumanEval_149,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm pee tɩŋa wɛna kɩmaŋ kʋɖʋmɩŋ.// Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩna tɔmpiye ndɩ ndɩ nɛ ɖɩ-tɛ paɣtʊ. // Ye tɔm pee naalɛ ɩwɛna kɩmaŋ kʋɖʋmʋʋ yɔ, paɖʋʋ-yɛ alphabetiki taa. Pɩwɛɛ se ɛpɩsɩnɩ ɛ-tɛ matriki ŋgʊ kɩ-tɛ paɣtʊ yɔɔ.// Pɩwɛɛ se tɔm pee wena awɛ yɔ, a-ɖaɣlɩkɩŋ ɩkpa ɖoŋ nɛ pɩsa nɛ ɩpɩzɩ ɩyɔɔdɩ tɔm pee wena awɛ yɔ.Pɩpɩzɩɣ nɛ pɩla se kɩ-taa tɔm kɩlɛlʋʋ wɛɛ.// Ñɩɣtʊ kɛna tam tam tɔmpiye nɛ pɩtɛkɛ tam tam tɔmpiye naɖɩyɛ.Ɛtɛyɩɣ ɛ-tɛ matriki nɛ ɛ-tɛ matriki kɩlɛlʋʋ nɛ ɛ-tɛ matriki kɩlɛlʋʋ.// ɛñɩɣ tɔmpiye nɖɩ ɖɩ-tɛ matʊ fɛyɩ kɩmaŋ yɔ, Takayaɣ ŋga ka-taa pamaɣ size, pɩ-tɛ lɛɣtʋ kɩfatʋ natʋyʋ wɛna./// >>> sorted_list_sum(lst: [""aa"", ""a"", ""aaa""])
/// [""aa""]
/// >>> sorted_list_sum(lst: [""ab"", ""a"", ""aaa"", ""cd""])
/// [""ab"", ""cd""]
func sorted_list_sum(lst: [String]) -> [String] {
","func sorted_list_sum(lst: [String]) -> [String] {
    return lst.filter { $0.count % 2 == 0 }
              .sorted { 
                  if $0.count == $1.count {
                      return $0 < $1
                  }
                  return $0.count < $1.count
              }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sorted_list_sum(lst: [""aa"", ""a"", ""aaa""]) == [""aa""])
assert(sorted_list_sum(lst: [""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""])
assert(sorted_list_sum(lst: [""d"", ""b"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""])
assert(sorted_list_sum(lst: [""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""])
assert(sorted_list_sum(lst: [""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""aaaa"", ""bbbb"", ""dd"", ""cc""]) == [""cc"", ""dd"", ""aaaa"", ""bbbb""])"
HumanEval_150,kbp_Latn,swift,"
// Kɩɖaŋ: // kɩkɛ kajalaɣ n̄ɩnʋʋ nɛ pɩpɔzaa se pɩpɩsɩ y kɩ-kɩjɩkpʋʋ.Pɩtɛ kɩlɛmʋʋ kʋnɛ, kɩ-taa lɛ, ɖɩnaɣ se, yee n ɛtɛzɩɣ pɩsʋʋ x kɔyɔ, pʋpɔzʋʋ se ɖɩpɩsɩ ɛ-ñɩm./// >>> x_or_y(n: 7, x: 34, y: 12)
/// 34
/// >>> x_or_y(n: 15, x: 8, y: 5)
/// 5
func x_or_y(n: Int, x: Int, y: Int) -> Int {
","func x_or_y(n: Int, x: Int, y: Int) -> Int {
    func isPrime(_ number: Int) -> Bool {
        if number <= 1 { return false }
        if number <= 3 { return true }
        if number % 2 == 0 || number % 3 == 0 { return false }
        
        var i = 5
        while i * i <= number {
            if number % i == 0 || number % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    return isPrime(n) ? x : y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(x_or_y(n: 7, x: 34, y: 12) == 34)
assert(x_or_y(n: 15, x: 8, y: 5) == 5)
assert(x_or_y(n: 3, x: 33, y: 5212) == 33)
assert(x_or_y(n: 1259, x: 3, y: 52) == 3)
assert(x_or_y(n: 7919, x: -1, y: 12) == -1)
assert(x_or_y(n: 3609, x: 1245, y: 583) == 583)
assert(x_or_y(n: 91, x: 56, y: 129) == 129)
assert(x_or_y(n: 6, x: 34, y: 1234) == 1234)
assert(x_or_y(n: 1, x: 2, y: 0) == 0)
assert(x_or_y(n: 2, x: 2, y: 0) == 2)"
HumanEval_151,kbp_Latn,swift,"
Wɩlɩɣ se ŋpɩzɩɣ nɛ ŋlɩzɩ tɔm pee wena awɛ ndɩ yɔ, nɛ ŋyele nɛ ŋtazɩ tɔm pee wena awɛ ndɩ yɔ, a-taa.// Ye ŋha-ɖʋ nimbrɩ waa sakɩyɛ yɔ, pɩsɩna nɛ ɖɩna nimbrɩ waa mba pa-naalɛ pa-kɩɖaʋ taa lɛ, pa-tɩŋa pa-taa lɛ, nimbrɩ waa mba pa-naalɛ pa-taa lɛ, pa-taa lɛ, pa-taa lɛ, we?/// >>> double_the_difference(lst: [1, 3, 2, 0])
/// 10
/// >>> double_the_difference(lst: [-1, -2, 0])
/// 0
/// >>> double_the_difference(lst: [9, -2])
/// 81
/// >>> double_the_difference(lst: [0])
/// 0
/// If the input array is empty, return 0.
func double_the_difference(lst: [Double]) -> Int {
","func double_the_difference(lst: [Double]) -> Int {
    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }
              .map { Int($0) * Int($0) }
              .reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(double_the_difference(lst: [] as [Double]) == 0)
assert(double_the_difference(lst: [5.0, 4.0]) == 25)
assert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)
assert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)
assert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)
assert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)
assert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"
HumanEval_152,kbp_Latn,swift,"
// kɩɖaʋ: // kɩ-tɛ wazaɣ kɔyɔ 0, nɛ yee pɩtɛkɛ mbʋ yɔ, kɩ-tɛ wazaɣ kɔyɔ, kɩ-tɛ ndɩ kpem ŋga kɛwɛna tɔmpiye nɖɩ ɖɩ-taa nɛ tɔmpiye nɖɩ ɖɩ-taa.// Ɛpɩsɩɣ ɛ-tɛ matriki kɩɖaɣlʋʋ ŋgʋ kɩwɩlɩɣ ɛzɩma ɛ-tɛ matriki kɩɖaɣlʋʋ kɩlɩna yɔ.// Paha-ŋ takayɩsɩ naalɛ nɛ ŋmaɣzɩna-sɩ nɛ sɩwɛɛ kɩmaŋ, paa sɩ-taa lɛ, sɩ-taa nakɛyɛ wɩlɩɣ se sɩ-tɔm kɛ toovenim. // Ña-tʋmɩyɛ lɛ se ŋtɩlɩ se ɛyʋ nɔɔyʋ maɣzaɣ se tɔm ndʋ tɩlɩnɩ tɔm ndɩ ndɩ taa yɔ, tɩkɛ toovenim yaa we. Pɩcɛyaa se ɖɩmaɣzɩ nɛ ɖɩna.Pɩkɛna mbʋ ɛyʋ maɣzɩɣ nɛ ɛ-lɩmaɣza wɛna alɩwaatʋ ndʋ tɩ-taa yɔ.Pɩtɩla ɖɩtɔzʋʋ alɩwaatʋ ndʋ ɖɩnaɣ se ɖɩtɛm ɖa-taa se ɖɩkaɣ pɩsʋʋ ɛyaa kɩbama yɔ./// >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])
/// [0, 0, 0, 0, 3, 3]
/// >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])
/// [4, 4, 1, 0, 0, 6]
func compare(game: [Int], guess: [Int]) -> [Int] {
","func compare(game: [Int], guess: [Int]) -> [Int] {
    var result: [Int] = []
    
    for i in 0..<game.count {
        let difference = abs(game[i] - guess[i])
        result.append(difference)
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])
assert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])
assert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])
assert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"
HumanEval_153,kbp_Latn,swift,"
// Kɩɖaʋ: (Ɛ-tɛ ɖoŋ wɛ -1).// pɩpɩsɩɣ 'Slices.SErviNGSliCes' mbʋ pʋyɔɔ yɔ 'SErviNGSliCes' kɛna kɩwalʋʋ ŋgʋ kɩkɩlɩ ɖoŋ yɔ // tɔmpiye: ['SErviNGSliCes', 'Cheese', 'StuFfed'] pʋbʋ lɛ, pɩwɛɛ se ŋlabɩnɩ-ɖɩ tʋmɩyɛ // Ɖɩkpaɣ ɛzɩ, ye paha-ɖʋ ""Slices"" ɛzɩ class nɛ array yɔ yɔ, // ɛlɩzɩɣ weyi ɛ-tɔm kɩlɩ cɛyʋʋ yɔ. Yee pɩtɛŋna nɛ pɩtalɩ naalɛ yaa sakɩyɛ nɛ pɩtalɩ ɖoŋ kʋɖʋmʋʋ kɔyɔ, pɩwɛɛ se ŋñɔɔzɩ-yɛ nɛ pɩsa nɛ pɩsa nɛ pɩsaŋ.// format: ClassName.StrongestExtensionName. // Pɩwɛɛ se ŋñɩnɩ kɩwalʊʊ ŋgʊ kɩkɩlɩ ɖoŋ yɔ nɛ ŋpɩsɩ ɛ-tɛ tɔmpiye naɖɩyɛ.// pɩlɩna ɛ-hɩɖɛ kɩsɛyɛ yɔɔ lɛ, ɖoŋ weyi ɛ-taa wɛ ɛ-tɩ yɔ, ɛ-tɛ kpɩnɛ nɖɩ payaɣ se CAP nɛ SM yɔ.// tɔmpiye nɖɩ ɖɩ-hɩɖɛ taa, nɛ ɖɩ-taa lɛ, SM kɛ tɔmpiye cikpeɖe // tɔmpiye ɖoŋ ñɩnɖɛ yɔ: CAP kɛna mayaɣ sɔsɔɣa ŋga ka-taa pama tɔmpiye nɖɩ yɔ.Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.// Pʊkɔŋna-ŋ haʊ takayaɣ ŋga payaɣ se class yɔ (kɛkɛkɛkɛ) nɛ pɩtasɩna-ŋ ɖɔɖɔ takayasɩ kɩkalasɩ./// >>> Strongest_Extension(class_name: ""my_class"", extensions: [""AA"", ""Be"", ""CC""])
/// ""my_class.AA""
func Strongest_Extension(class_name: String, extensions: [String]) -> String {
","func Strongest_Extension(class_name: String, extensions: [String]) -> String {
    var strongestExtension: String? = nil
    var maxStrength = Int.min
    
    for ext in extensions {
        let cap = ext.filter { $0.isUppercase }.count
        let sm = ext.filter { $0.isLowercase }.count
        let strength = cap - sm
        
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = ext
        }
    }
    
    if let strongestExt = strongestExtension {
        return ""\(class_name).\(strongestExt)""
    }
    
    return class_name
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(Strongest_Extension(class_name: ""Watashi"", extensions: [""tEN"", ""niNE"", ""eIGHt8OKe""]) == ""Watashi.eIGHt8OKe"")
assert(Strongest_Extension(class_name: ""Boku123"", extensions: [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]) == ""Boku123.YEs.WeCaNe"")
assert(Strongest_Extension(class_name: ""__YESIMHERE"", extensions: [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]) == ""__YESIMHERE.NuLl__"")
assert(Strongest_Extension(class_name: ""K"", extensions: [""Ta"", ""TAR"", ""t234An"", ""cosSo""]) == ""K.TAR"")
assert(Strongest_Extension(class_name: ""__HAHA"", extensions: [""Tab"", ""123"", ""781345"", ""-_-""]) == ""__HAHA.123"")
assert(Strongest_Extension(class_name: ""YameRore"", extensions: [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]) == ""YameRore.okIWILL123"")
assert(Strongest_Extension(class_name: ""finNNalLLly"", extensions: [""Die"", ""NowW"", ""Wow"", ""WoW""]) == ""finNNalLLly.WoW"")
assert(Strongest_Extension(class_name: ""_"", extensions: [""Bb"", ""91245""]) == ""_.Bb"")
assert(Strongest_Extension(class_name: ""Sp"", extensions: [""671235"", ""Bb""]) == ""Sp.671235"")"
HumanEval_154,kbp_Latn,swift,"
Pɩwɛɛ se ɖɩpɩsɩ tɔm piye true yee tɔmpiye naalɛ ñɩnɖɛ yaa ɖɩ-tɛ lɛɣzʋʋ nakʋyʋ kɛ tɔmpiye kajalaɣ ñɩnɖɛ taa yɔ./// >>> cycpattern_check(a: ""abcd"", b: ""abd"")
/// false
/// >>> cycpattern_check(a: ""hello"", b: ""ell"")
/// true
/// >>> cycpattern_check(a: ""whassup"", b: ""psus"")
/// false
/// >>> cycpattern_check(a: ""abab"", b: ""baa"")
/// true
/// >>> cycpattern_check(a: ""efef"", b: ""eeff"")
/// false
/// >>> cycpattern_check(a: ""himenss"", b: ""simen"")
/// true
func cycpattern_check(a: String, b: String) -> Bool {
","func cycpattern_check(a: String, b: String) -> Bool {
    guard !b.isEmpty else { return true }
    let bCombined = b + b
    for i in 0..<b.count {
        let rotation = String(bCombined.dropFirst(i).prefix(b.count))
        if a.contains(rotation) {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(cycpattern_check(a: ""xyzw"", b: ""xyw"") == false)
assert(cycpattern_check(a: ""yello"", b: ""ell"") == true)
assert(cycpattern_check(a: ""whattup"", b: ""ptut"") == false)
assert(cycpattern_check(a: ""efef"", b: ""fee"") == true)
assert(cycpattern_check(a: ""abab"", b: ""aabb"") == false)
assert(cycpattern_check(a: ""winemtt"", b: ""tinem"") == true)"
HumanEval_155,kbp_Latn,swift,"
// Kɩɖaʋ: // Ye ɖɩha-ɩ nimero waa tɩŋa yɔ, pɩpɩsɩɣ nimero waa mba pɛtɛyɩɣ yɔ nɛ nimero waa mba pɛtɛyɩɣ yɔ./// >>> even_odd_count(num: -12)
/// (1, 1)
/// >>> even_odd_count(num: 123)
/// (1, 2)
func even_odd_count(num: Int) -> (Int, Int) {
","func even_odd_count(num: Int) -> (Int, Int) {
    var countEvens = 0
    var countOdds = 0
    var number = abs(num) // Handle negative numbers by taking absolute value

    while number > 0 {
        let digit = number % 10
        if digit % 2 == 0 {
            countEvens += 1
        } else {
            countOdds += 1
        }
        number /= 10
    }
    return (countEvens, countOdds)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_count(num: 7) == (0, 1))
assert(even_odd_count(num: -78) == (1, 1))
assert(even_odd_count(num: 3452) == (2, 2))
assert(even_odd_count(num: 346211) == (3, 3))
assert(even_odd_count(num: -345821) == (3, 3))
assert(even_odd_count(num: -2) == (1, 0))
assert(even_odd_count(num: -45347) == (2, 3))
assert(even_odd_count(num: 0) == (1, 0))"
HumanEval_156,kbp_Latn,swift,"
// Kɩɖaŋ: // Paɣtʊ ndʊ tɩtɔŋ se: 1 <= num <= 1000 Nɛ ŋyele nɛ pama-kʋ nɛ mayaɣ cikpelaɣ.// Ye paha-ɖʋ kɩmaŋ mayaɣ kɔyɔ, ɖɩkpaɣ kɩmaŋ mayaɣ ŋga nɛ ɖɩkpaɣ Roma n̄ɩnzɩ taa ɛzɩ n̄ɩɣyʋʋ yɔ, /// >>> int_to_mini_roman(number: 19)
/// ""xix""
/// >>> int_to_mini_roman(number: 152)
/// ""clii""
/// >>> int_to_mini_roman(number: 426)
/// ""cdxxvi""
func int_to_mini_roman(number: Int) -> String {
","func int_to_mini_roman(number: Int) -> String {
    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    let numerals = [""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""]
    
    var num = number
    var result = """"
    
    for (index, value) in values.enumerated() {
        while num >= value {
            result += numerals[index]
            num -= value
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(int_to_mini_roman(number: 19) == ""xix"")
assert(int_to_mini_roman(number: 152) == ""clii"")
assert(int_to_mini_roman(number: 251) == ""ccli"")
assert(int_to_mini_roman(number: 426) == ""cdxxvi"")
assert(int_to_mini_roman(number: 500) == ""d"")
assert(int_to_mini_roman(number: 1) == ""i"")
assert(int_to_mini_roman(number: 4) == ""iv"")
assert(int_to_mini_roman(number: 43) == ""xliii"")
assert(int_to_mini_roman(number: 90) == ""xc"")
assert(int_to_mini_roman(number: 94) == ""xciv"")
assert(int_to_mini_roman(number: 532) == ""dxxxii"")
assert(int_to_mini_roman(number: 900) == ""cm"")
assert(int_to_mini_roman(number: 994) == ""cmxciv"")
assert(int_to_mini_roman(number: 1000) == ""m"")"
HumanEval_157,kbp_Latn,swift,"
// Kɩɖaʋ: // 90 degree. Hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ.// hɔɔlɩŋ ɛnɩ ɩwɛ ɛzɩ tɔm hɔɔlɩŋ naadozo yɔ, ye pɩtɛkɛ mbʋ yɔ, pɩkɛ cɛtɩm tɔm. Pɩpɩsɩɣ tɔmpiye true yee tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-ɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-ɖɩ ɖɩ-yɔɔ tɔmpiye nɖɩ ɖɩ-ɖɩ ɖɩ-ɖɩ yɔ/// >>> right_angle_triangle(a: 3, b: 4, c: 5)
/// true
/// >>> right_angle_triangle(a: 1, b: 2, c: 3)
/// false
func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
","func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
    let sides = [a, b, c].sorted()
    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(right_angle_triangle(a: 3, b: 4, c: 5) == true)
assert(right_angle_triangle(a: 1, b: 2, c: 3) == false)
assert(right_angle_triangle(a: 10, b: 6, c: 8) == true)
assert(right_angle_triangle(a: 2, b: 2, c: 2) == false)
assert(right_angle_triangle(a: 7, b: 24, c: 25) == true)
assert(right_angle_triangle(a: 10, b: 5, c: 7) == false)
assert(right_angle_triangle(a: 5, b: 12, c: 13) == true)
assert(right_angle_triangle(a: 15, b: 8, c: 17) == true)
assert(right_angle_triangle(a: 48, b: 55, c: 73) == true)
assert(right_angle_triangle(a: 1, b: 1, c: 1) == false)
assert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"
HumanEval_158,kbp_Latn,swift,"
// tɔm pee, pɩpɩsɩɣ tɔm pee wena awɛ kajalaɣ lone taa tɔm kpou taa yɔ. Yee ɛyʊ ɛ-tɛ tɔmpiye ɛfɛyɩ ndɩ nɛ lɛɛɖɛ yɔ, ɛpɩzɩɣ nɛ ɛlɩzɩ ɛ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.Ɛ-tɛ tɔm pee wɛ ndɩ ndɩ. Ɛ-tɛ tɔm pee kɩlɩna ɖɔʊ.Maɣzɩ nɛ ŋna ɛzɩma ŋpɩzɩɣ nɛ ŋlabɩnɩ tʋmɩyɛ tɔm pee wena awɛ ɛzɩ masɩ yɔ./// >>> find_max(words: [""name"", ""of"", ""string""])
/// ""string""
/// >>> find_max(words: [""name"", ""enam"", ""game""])
/// ""enam""
/// >>> find_max(words: [""aaaaaaa"", ""bb"", ""cc""])
/// ""aaaaaaa""
func find_max(words: [String]) -> String {
","func find_max(words: [String]) -> String {
    func uniqueCharacterCount(in word: String) -> Int {
        return Set(word).count
    }
    
    return words.max { a, b in
        let uniqueCountA = uniqueCharacterCount(in: a)
        let uniqueCountB = uniqueCharacterCount(in: b)
        
        if uniqueCountA == uniqueCountB {
            return a > b
        }
        
        return uniqueCountA < uniqueCountB
    } ?? """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_max(words: [""name"", ""of"", ""string""]) == ""string"")
assert(find_max(words: [""name"", ""enam"", ""game""]) == ""enam"")
assert(find_max(words: [""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa"")
assert(find_max(words: [""abc"", ""cba""]) == ""abc"")
assert(find_max(words: [""play"", ""this"", ""game"", ""of"", ""footbott""]) == ""footbott"")
assert(find_max(words: [""we"", ""are"", ""gonna"", ""rock""]) == ""gonna"")
assert(find_max(words: [""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation"")
assert(find_max(words: [""this"", ""is"", ""a"", ""prrk""]) == ""this"")
assert(find_max(words: [""b""]) == ""b"")
assert(find_max(words: [""play"", ""play"", ""play""]) == ""play"")"
HumanEval_159,kbp_Latn,swift,"
// Kɩɖaʋ: Ye ŋfɛyɩnɩ tɔɔnaɣ yɔ, ŋkaɣ tɔɔʋ-kɛ nɛ ŋtɛ ña-calɩm.(Cɔnɩ aɖakaɣ ŋga ka-taa pama tɔm ñʋʋ ŋgʋ yɔ.)// pɩwɛɛ se ŋpɩsɩ [ tɔɔnasɩ nzɩ ŋtɔɔ yɔ sɩ-kpɩtɩŋ tɩŋa taa, Ɛlɛ lɛɛlɛɛyɔ lɛ, pɩwɛɛ se ŋtɔɔ karɩbɔɔnɩ nɛ pɩsa nɛ ŋtɛzɩ tɔɔnaɣ tɔɔʋ.Ŋkɛ kpɩnɛ nɖɩ ɖɩwɛnɩ ñɔɔsɩ yɔ, nɛ ŋtɛm tɔɔʋ kaarooti sakɩyɛ./// >>> eat(number: 5, need: 6, remaining: 10)
/// [11, 4]
/// >>> eat(number: 4, need: 8, remaining: 9)
/// [12, 1]
/// >>> eat(number: 1, need: 10, remaining: 10)
/// [11, 0]
/// >>> eat(number: 2, need: 11, remaining: 5)
/// [7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
func eat(number: Int, need: Int, remaining: Int) -> [Int] {
","func eat(number: Int, need: Int, remaining: Int) -> [Int] {
    let totalNeeded = number + need
    let totalEaten = min(totalNeeded, number + remaining)
    let carrotsLeft = max(0, remaining - (totalEaten - number))
    return [totalEaten, carrotsLeft]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])
assert(eat(number: 4, need: 8, remaining: 9) == [12, 1])
assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])
assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])
assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])
assert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
HumanEval_160,kbp_Latn,swift,"
// Ñɩɣtʊ tʊmɩyɛ laɖʊ wɛna tʊmɩyɛ laɖʊ kʋɖʋm, nɛ tʊmɩyɛ laɖʊ wɛna tʊmɩyɛ laɖʊ naalɛ. // Opérand kɛna nimero waa kɩmaŋ weyi ɩfɛyɩ kɩmaŋ yɔ. // Ñɩɣtʊ ndʊ tɩ-taa lɛ, ɛyʊ weyi ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ wɛʊ yɔ.// Cɔnɩ: // => pɩlɩʋ = 9 // pɩlɩʋ = 2 + 3 * 4 - 5 // matrix = [2, 3, 4, 5] '*' '-'] // Kɩɖaʋ: // Kpɛlɩ kpɛlɛkʋʋ (**) // Kpaŋnaŋ tɛ ɖama hɛkʋ taa tayʋʋ ( // ) // Kɩwalʋʋ (*) // Kɩ-tɛ tɔm ( - ) // Kɩkpɛndɩ (+) // Algebra taa tʋma kɩbana: // nɛ ɖɩpɩsɩɣ ɛ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ akɔnta. // nabʊlɛ taa lɛ, ɛyʊ ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛ-tɛ ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ kɩlɩna ɛyʊ.Ɖɩkpaɣ ɛzɩ, ɛyʊ weyi ɛ-tɛ ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ.func do_algebra(operator: [String], operand: [Int]) -> Int {
","func do_algebra(operator: [String], operand: [Int]) -> Int {
    var result = operand[0]
    let precedence: [String: Int] = [""+"": 1, ""-"": 1, ""*"": 2, ""//"": 2, ""**"": 3]
    
    var opStack: [String] = []
    var numStack: [Int] = [result]
    
    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {
        switch op {
        case ""+"":
            return a + b
        case ""-"":
            return a - b
        case ""*"":
            return a * b
        case ""//"":
            return a / b
        case ""**"":
            return Int(pow(Double(a), Double(b)))
        default:
            fatalError(""Unsupported operator: \(op)"")
        }
    }
    
    for i in 0..<operator.count {
        let currentOp = `operator`[i]
        let currentNum = operand[i + 1]
        
        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {
            opStack.removeLast()
            let b = numStack.removeLast()
            let a = numStack.removeLast()
            numStack.append(applyOperator(lastOp, b, a))
        }
        
        opStack.append(currentOp)
        numStack.append(currentNum)
    }
    
    while let lastOp = opStack.popLast() {
        let b = numStack.removeLast()
        let a = numStack.removeLast()
        numStack.append(applyOperator(lastOp, b, a))
    }
    
    return numStack.first!
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(do_algebra(operator: [""**"", ""*"", ""+""], operand: [2, 3, 4, 5]) == 37)
assert(do_algebra(operator: [""+"", ""*"", ""-""], operand: [2, 3, 4, 5]) == 9)
assert(do_algebra(operator: [""//"", ""*""], operand: [7, 3, 4]) == 8)"
HumanEval_161,kbp_Latn,swift,"
// Kɩɖaŋ // Pɩwɛɛ se tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee wena pɩlɩna a-yɔɔ yɔ. // Ye tɔmpiye nɖɩ ɖɩfɛyɩna masɩ kɔyɔ, pɛlɛɣzɩ tɔmpiye nɖɩ. Ye pɩtɛkɛ mbʋ yɔ, yele nɛ pɩla mbʋ.// yee s[i] kɛna mayaɣ kɔyɔ, pɛlɛɣzɩ-kɛ nɛ pɩɖɛɛna hɔɔlɩŋ weyi ɩ-taa pama-kɛ yɔ, yaa pɩɖɛɛna hɔɔlɩŋ weyi ɩ-taa pama-kɛ yɔ, // Paha-ŋ tɔmpiye s. /// >>> solve(s: ""1234"")
/// ""4321""
/// >>> solve(s: ""ab"")
/// ""AB""
/// >>> solve(s: ""#a@C"")
/// ""#A@c""
func solve(s: String) -> String {
","func solve(s: String) -> String {
    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {
        return String(s.reversed())
    }
    
    var result = """"
    for char in s {
        if char.isLetter {
            if char.isLowercase {
                result.append(char.uppercased())
            } else {
                result.append(char.lowercased())
            }
        } else {
            result.append(char)
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: ""AsDf"") == ""aSdF"")
assert(solve(s: ""1234"") == ""4321"")
assert(solve(s: ""ab"") == ""AB"")
assert(solve(s: ""#a@C"") == ""#A@c"")
assert(solve(s: ""#AsdfW^45"") == ""#aSDFw^45"")
assert(solve(s: ""#6@2"") == ""2@6#"")
assert(solve(s: ""#$a^D"") == ""#$A^d"")
assert(solve(s: ""#ccc"") == ""#CCC"")"
HumanEval_162,kbp_Latn,swift,"
// Yee 'text' ɛkɛ matʋ kɩtatasɩ yɔ, pɩpɩsɩɣ nil. // Ye ŋha-ɩ tɔmpiye 'text', pɩsɩna-ɩ nɛ ɛ-tɛ tɔmpiye md5 hash. /// >>> string_to_md5(text: ""Hello world"")
/// ""3e25960a79dbc69b674cd4ec67a72c62""
func string_to_md5(text: String) -> String? {
","import Foundation
import CommonCrypto

func string_to_md5(text: String) -> String? {
    guard !text.isEmpty else { return nil }
    
    let length = Int(CC_MD5_DIGEST_LENGTH)
    let messageData = text.data(using: .utf8)!
    var digestData = Data(count: length)
    
    _ = digestData.withUnsafeMutableBytes { digestBytes in
        messageData.withUnsafeBytes { messageBytes in
            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)
        }
    }
    
    return digestData.map { String(format: ""%02hhx"", $0) }.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_to_md5(text: ""Hello world"") == ""3e25960a79dbc69b674cd4ec67a72c62"")
assert(string_to_md5(text: """") == nil)
assert(string_to_md5(text: ""A B C"") == ""0ef78513b0cb8cef12743f5aeb35f888"")
assert(string_to_md5(text: ""password"") == ""5f4dcc3b5aa765d61d8327deb882cf99"")"
HumanEval_163,kbp_Latn,swift,"
// Kɩɖaʋ nakʋyʋ yɔ: Nɛ b, pɩlɩɣna ɛzɩma pɩpaɣlɩɣ yɔ.// Ye ŋha-ɖʋ ɛtɛrɩyɔm waa naalɛ a nɛ b, ɖitiyiɣ a nɛ b pɛ-hɛkʋ taa ɛtɛrɩyɔm waa mba pa-taa lɛ, pa-taa lɛ, a nɛ b pɛ-hɛkʋ taa ɛtɛrɩyɔm waa./// >>> generate_integers(a: 2, b: 8)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 8, b: 2)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 10, b: 14)
/// [] as [Int]
func generate_integers(a: Int, b: Int) -> [Int] {
","func generate_integers(a: Int, b: Int) -> [Int] {
    let lower = min(a, b)
    let upper = max(a, b)
    var result = [Int]()
    
    for number in lower...upper {
        if number % 2 == 0 {
            result.append(number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])
assert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 17, b: 89) == [] as [Int])"
