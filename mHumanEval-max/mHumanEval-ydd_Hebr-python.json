[
    {
        "task_id": "HumanEval/0",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"טשעק אויב אין געגעבן רשימה פון נומערן, זענען קיין צוויי נומערן נעענטער צו יעדער אנדערע ווי געגעבן טהרעשאָלד. בייַשפּיל: >>> האט_קליוז_עלעמענטן (([1.0, 2.0, 3.0], 0.5) פאַלש >>> האט_קליוז_עלעמענטן (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) אמת \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"יפּוט צו דעם פונקציע איז אַ שטריקל קאַנטיינד קייפל גרופּעס פון נעסטעד פּאַראַנטהעזעס. דיין ציל איז צו צעשיידט די גרופּע אין באַזונדער סטרינגס און צוריקקומען די רשימה פון יענע. באַזונדער גרופּעס זענען באַלאַנסט (יעדע עפענען בראַקעס איז ריכטיק פארמאכט) און ניט נעסטעד ין יעדער אנדערע איגנאָרירן קיין ספּייסאַז אין די ינפּוט שטריקל. בייַשפּיל: >>> separate_paren_groups'(( ) (() (( ) ) ) ) '['() ', '(()) ', '((()) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"געגעבן אַ positive פלאָוטינג פונט נומער, עס קענען זיין דיקאַמפּאָוזד אין און ינטאַדזשער טייל (גרעסטער ינטאַדזשער קלענערער ווי געגעבן נומער) און דעצימאַלס (לעפט איבער טייל שטענדיק קלענערער ווי 1). צוריקקומען די דעצימאַל טייל פון די נומער. בייַשפּיל: >>> טרונקאַייט_נומער ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"איר זענט געגעבן אַ רשימה פון אַוועקלייגן און ווידדראָאַל אַפּעריישאַנז אויף אַ באַנק חשבון אַז הייבט מיט נול וואָג. דיין אַרבעט איז צו דעטעקט אויב אין קיין פונט די וואָג פון חשבון פאלס אונטער נול, און אין אַז פונט פונקציע זאָל צוריקקומען אמת. אַנדערש עס זאָל צוריקקומען פאַלש. בייַשפּיל: >>> אונטער_נול (([1, 2, 3]) פאַלש >>> אונטער_נול (([1, 2, -4, 5]) אמת \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"פֿאַר אַ געגעבן רשימה פון ינפּוט נומערן, רעכענען מיטל אַבסאָלוט דעוויאַישאַן אַרום די מיטל פון דעם דאַטאַסעט. מיטל אַבסאָלוט דעוויאַישאַן איז די דורכשניטלעך אַבסאָלוט חילוק צווישן יעדער עלעמענט און אַ צענטערפּונקט (מאָס אין דעם פאַל): MAD = דורכשניטלעך. x - x_מעאַן. בייַשפּיל: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"אַרייַנלייגן אַ נומער 'דילימעטער' צווישן יעדער צוויי קאָנסעקוטיווע עלעמענטן פון ינפּוט רשימה `numbers' >>> ינטערספּערסע([], 4) [] >>> ינטערספּערסע([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"אין דעם פונקציע איז א סטרינג וואס רעפרעזענטירט מערערע גרופעס פאר נעסטעד קארענטעז אפגעשיידט דורך ספעיסעס. פאר יעדע פון די גרופעס, לייגט ארויס די טיפעסטע לעוועל פון נעסטעד קארענטעז. למשל (() (()) האט מאקסימום צוויי לעוועלס פון נעסטעד, בשעת ((())) האט דריי. >>> parse_nested_parens (('((()) ((())) () (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"פילטער אַ ינפּוט רשימה פון סטרינגס בלויז פֿאַר די וואָס אַנטהאַלטן געגעבן סאַבסטררינג >>> filter_by_substring([], 'אַ') [] >>> filter_by_substring(['אַבק', 'באַקד', 'קדע', 'אַררייַ'], 'אַ') ['אַבק', 'באַקד', 'אַררייַ'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"פֿאַר אַ געגעבן רשימה פון ינטיידזשערז, צוריקקומען אַ טופּל קאַנסיסטינג פון אַ סומע און אַ פּראָדוקט פון אַלע די ינטיידזשערז אין אַ רשימה. ליידיק סומע זאָל זיין גלייַך צו 0 און ליידיק פּראָדוקט זאָל זיין גלייַך צו 1. >>> סומע_פּראָדוקט (([]) (0, 1) >>> סומע_פּראָדוקט (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"פֿון אַ געגעבן רשימה פון ינטיידזשערז, דזשענערייט אַ רשימה פון ראָולינג מאַקסימום עלעמענט געפֿונען ביז געגעבן מאָמענט אין די סיקוואַנס. >>> ראָולינג_מאַקס (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"געפינען די שאָרטיסט פּאַלינדראָם וואָס הייבט מיט אַ סאַפּלייד שטריקל. אַלגערידאַם געדאַנק איז פּשוט: - געפינען די לאָנגעסט פּאָסטפיקס פון סאַפּלייד שטריקל וואָס איז אַ פּאַלינדראָם. - צוטשעפּען צו די סוף פון די שטריקל פאַרקערט פון אַ שטריקל פּרעפיקס וואָס קומט איידער די פּאַלינדראָמיק סאַפיקס. >>> מאַכן_פּאַלינדראָם ((('') ' ' >>> מאַכן_פּאַלינדראָם ((('קאַטאַק') 'קאַטאַק' >>> מאַכן_פּאַלינדראָם ((('קאַטאַק') 'קאַטאַק' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"פּרובירן אויב געגעבן שטריקל איז אַ פּאַלינדראָם \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"אַרייַנפיר זענען צוויי סטרינגס אַ און ב קאַנסיסטינג בלויז פון 1 ס און 0 ס. דורכפירן ביינערי קסאָר אויף די ינפּוץ און צוריקקומען רעזולטאַט אויך ווי אַ שטריקל. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"אויס פון ליסטע פון סטרינגס, צוריקקומען די לענגסטע. צוריקקומען די ערשטע אין פאל פון מערערע סטרינגס פון די זעלבע לענג. צוריקקומען קיין אויב די ינפּוט ליסטע איז ליידיק. >>> לענגסטע([]) >>> לענגסטע(['א', 'ב', 'ג']) 'א' >>> לענגסטע(['א', 'ב', 'קק']) 'קק' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"צוריקקומען אַ גרעסטע פּראָסט דיוויזאָר פון צוויי ינטעדזשערז אַ און ב >>> גרעסטע_פֿאַרשפּרייט_דיוויזאָר ((3, 5) 1 >>> גרעסטע_פֿאַרשפּרייט_דיוויזאָר ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"צוריקקומען רשימה פון אַלע פּרעפיקסעס פון שאָרטיסט צו לאָנגעסט פון די ינפּוט שטריקל >>> all_prefixes('abc') ['אַ', 'אַב', 'אַבק'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"צוריקקומען אַ שטריקל וואָס כּולל ספּייס-דילימעד נומערן סטאַרטינג פון 0 אַרויף צו n ינקלוסיוו. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"געגעבן אַ שטריקל, געפינען אויס ווי פילע באַזונדער אותיות (אָפֿרויס פון פאַל) טוט עס באשטייט פון >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('גערי') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"ינטאַפּ צו דעם פונקציע איז אַ שטריקל רעפּריזענטינג מוזיקאַליש הערות אין אַ ספּעציעל אַסקי פֿאָרמאַט. דיין אַרבעט איז צו פּאַרס שטריקל רשימה פון ינטעגרעס קאָראַספּאַנדינג צו פילע ביץ טוט. דאָ איז אַ לעגענדע: 'אָ' טאָן, לעצט ביץ 'אָ' - ראָש - האַלב טאָן, לעצט צוויי ביץ 'א' - קוואַטער טאָן, לעצט איין באַט >>> פּאַרסע_מוזיק. 'אָ' אָ .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"געפינען ווי פילע מאל אַ געגעבן סאַבסטראַנג קענען זיין געפֿונען אין דער אָריגינעל שטריקל. ציילן אָוווערלאַפּינג פאלן. >>> ווי_פיל_צייטן('', 'אַ') 0 >>> ווי_פיל_צייטן('אַאַ', 'אַ') 3 >>> ווי_פיל_צייטן('אַאַ', 'אַאַ') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"אַרייַנפיר איז אַ פּלאַץ-דילימאַטעד שטריקל פון נומעראַלס פון 'נול' צו 'ניין'. גילטיק ברירות זענען 'נול', 'איין', 'צוויי', 'דרייַ', 'פיר', 'פופֿץ', 'זעקס', 'זיבן', 'אכט' און 'ניין'. צוריקקומען די שטריקל מיט נומערן סאָרטיד פון קלענסטער צו גרעסטער >>> sort_numbers (('דרייַ איין פינף') 'איין דריי פינף' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"פֿון אַ צוגעשטעלטע רשימה פון נומערן (פון לענג בייַ מינדסטער צוויי) אויסקלייַבן און צוריקקומען צוויי וואָס זענען די קלאָוסאַסט צו יעדער אנדערע און צוריקקומען זיי אין סדר (מינער נומער, גרעסערע נומער). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"געגעבן ליסטע פון נומערן (פון כאטש צוויי עלעמענטן), לייג אן א לינעארע טראנספארמאציע צו יענע ליסטע, אזוי אז די קלענסטע נומער וועט ווערן 0 און די גרעסטע וועט ווערן 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"פילטער געגעבן ליסטע פון קיין פּיטהאָן וואַלועס בלויז פֿאַר ינטעדזשערז >>> filter_integers(['אַ', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'אַבק', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"צוריקקומען לענג פון געגעבן שטריקל >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"פֿאַר אַ געגעבן נומער n, געפֿינען די גרעסטע נומער וואָס דיווידז n יוואַנלי, קלענערער ווי n >>> גרעסטע_דיוויזאָר ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"צוריקקומען רשימה פון פריים פאַקטאָריסעס פון געגעבן ינטייגער אין סדר פון קלענסטער צו גרעסטער. יעדער פון די פאַקטאָרס זאָל זיין ליסטעד נומער פון מאל קאָראַספּאַנדינג צו ווי פילע מאל עס ערשיינט אין פאַקטאָריזאַטיאָן. ינפּוט נומער זאָל זיין גלייַך צו די פּראָדוקט פון אַלע פאַקטאָרס >>> פאַקטאָריזע ((8) [2, 2, 2] >>> פאַקטאָריזע ((25) [5, 5] >>> פאַקטאָריזע ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"פון א ליסטע פון אינטעדזשערס, נעמט אוועק אלע עלעמענטן וואס קומען פאר מער ווי איינמאל. האלט סדר פון עלעמענטן לינקס די זעלבע ווי אין די אינפּוט. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"פֿאַר אַ געגעבן שטריקל, פליפּ קליינע אותיות צו הויך און הויך צו קליינע אותיות. >>> flip_case ((('העלא') 'העלא' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"קאָנקאַטענאַטע רשימה פון סטרינגס אין אַ איין סטרינג >>> קאָנקאַטענאַטע (([]) '' >>> קאָנקאַטענאַטע ((['אַ', 'ב', 'ג']) 'אַבק' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"פילטערן אַן ינפּוט רשימה פון סטרינגס בלויז פֿאַר די וואָס אָנהייבן מיט אַ געגעבן פּרעפיקס. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"צוריקקומען בלויז positive נומערן אין דער רשימה. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"צוריקקומען אמת אויב אַ געגעבן נומער איז פּריים, און פאַלש אַנדערש. >>> איז_פּרימע (א) (6) פאַלש >>> איז_פּרימע (א) 101) אמת >>> איז_פּרימע (א) 11 אמת >>> איז_פּרימע (א) 13441) אמת >>> איז_פּרימע (א) 61 אמת >>> איז_פּרימע (א) 4) פאַלש >>> איז_פּרימע (א) פאַלש \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs זענען קאָעפיסיענטן פון אַ פּאַלינאָמיאַל. find_zero געפינען x אַזאַ אַז poly(x) = 0. find_zero ריטורנס בלויז בלויז נול פונט, אַפֿילו אויב עס זענען פילע. דערצו, find_zero נאָר נעמט רשימה xs מיט אַ פּאַר נומער פון קאָעפיסיענטן און גרעסטע ניט-נול קאָעפיסיענט ווי עס געראַנטיז אַ לייזונג. >>> קייַלעכיק ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> קייַלעכיק ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"עוואַלואַטעס פּאַלינאָמיאַל מיט קאָעפיסיענטן xs אין פונט x. צוריקקומען xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"די פונקציע נעמט אַ רשימה ל' און גיט צוריק אַ רשימה ל' אַזאַ אַז ל' איז יידעניקאַל צו ל אין די ינדעסיז וואָס זענען נישט דיוויידזשאַבאַל דורך דרייַ, בשעת זייַן וואַלועס אין די ינדעסיז וואָס זענען דיוויידזשאַבאַל דורך דרייַ זענען גלייַך צו די וואַלועס פון די קאָראַספּאַנדינג ינדעסיז פון ל, אָבער סאָרטעד. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"צוריקקומען סאָרטעד יינציק עלעמענטן אין אַ רשימה >>> יינציק (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"צוריקקומען מאַקסימום עלעמענט אין דער רשימה. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"צוריקקומען די נומער פון מאל די ציפער 7 ערשיינט אין ינטיידזשערז ווייניקער ווי n וואָס זענען דיוויידזשאַבאַל דורך 11 אָדער 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"די פונקציע נעמט א ליסטע l און גיט צוריק א ליסטע l' אז l' איז אידענטישע צו l אין די אומגעלייגטע אינדעסיעס, בשעת די ווערטען ביי די פּערדיגע אינדעסיעס זענען גלייך צו די ווערטען פון די פּערדיגע אינדעסיעס פון l, אבער סארטירט. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"נעמט ווי ינפּוט שטריקל ענקאָדעד מיט ענקאָדע_סיקלאַק פונקציע. ריטורנס דיקאָדעד שטריקל. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"קערט ענקאָדעד שטריקל דורך סייקלינג גרופּעס פון דרייַ אותיות. \"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib גיט צוריק די n-טע נומער וואס איז א פיבאנאצקי נומער און עס איז אויך א פריים. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero נעמט אַ רשימה פון ינטיידזשערז ווי אַן אַרייַנפיר. עס קערט אמת אויב עס זענען דריי באַזונדער עלעמענטן אין דער רשימה אַז סומע צו נול, און פאַלש אַנדערש. >>> triples_sum_to_zero([1, 3, 5, 0]) פאַלש >>> triples_sum_to_zero[(1, 3, -2, 1]) אמת >>> triples_sum_to_zero([1, 2, 3, 7]) פאַלש >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) אמת >>> triples_sum_to_zero[1]) פאַלש \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"פֿאַרשטייט זיך אַ וועג וואָס איז אַ פּערפעקטלי גלייַך ינפיניטלי לאַנג שורה. n קאַרס זענען דרייווינג לינקס צו רעכט; סיימאַלטייניאַסלי, אַ אַנדערש שטעלן פון n קאַרס זענען דרייווינג רעכט צו לינקס. די צוויי שטעלט פון קאַרס אָנהייבן אויס זייַענדיק זייער ווייַט פון יעדער אנדערע. אַלע קאַרס מאַך אין דער זעלביקער גיכקייַט. צוויי קאַרס זענען געזאָגט צו קאַליידז ווען אַ מאַשין וואָס איז מאָווינג לינקס צו רעכט כאַץ אַ מאַשין וואָס איז מאָווינג רעכט צו לינקס. אָבער, די קאַרס זענען ינפיניטלי סטראָובאַל און שטאַרק; ווי אַ רעזולטאַט, זיי פאָרזעצן צו מאַך אין זייער טראַקטאָריע ווי אויב זיי האבן נישט קאַליידז. דעם פונקציע אויסגעט די נומער פון אַזאַ קאַלאַזיאַנז. \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"צוריקקומען רשימה מיט עלעמענטן ינקרימענטיד דורך 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero נעמט אַ רשימה פון ינטיידזשערז ווי אַ ינפּוט. עס קערט אמת אויב עס זענען צוויי באַזונדער עלעמענטן אין דער רשימה אַז סומע צו נול, און פאַלש אַנדערש. >>> pairs_sum_to_zero([1, 3, 5, 0]) פאַלש >>> pairs_sum_to_zero[(1, 3, -2, 1]) פאַלש >>> pairs_sum_to_zero([1, 2, 3, 7]) פאַלש >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) אמת >>> pairs_sum_to_zero[1]) פאַלש \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"טוישן נומעריש באַזע פון ינפּוט נומער קס צו באַזע. צוריקקומען שטריקל רעפּראַזענץ נאָך די קאַנווערזשאַן. באַזע נומערן זענען ווייניקער ווי 10. >>> טוישן_באַזע(8, 3) '22' >>> טוישן_באַזע(8, 2) '1000' >>> טוישן_באַזע(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"געגעבן לענג פון אַ זייַט און הויך צוריקקומען געגנט פֿאַר אַ דרייַעק. >>> דרייַעק_אַריאַ\"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"די פיב 4 נומערן סיקוואַנס איז אַ סיקוואַנס ענלעך צו די פיבאָנאַצקי סיקוואַנס וואָס איז דיפיינד ווי גייט: פיב 4 ((0) -> 0 פיב 4 ((1) -> 0 פיב 4 ((2) -> 2 פיב 4 ((3) -> 0 פיב 4 ((n) -> פיב 4 ((n-1) + פיב 4 ((n-2) + פיב 4 ((n-3) + פיב 4 ((n-4). ביטע שרייַבן אַ פונקציע צו יפישאַנטלי רעכענען די n-טע עלעמענט פון די פיב 4 נומערן סיקוואַנס. טאָן ניט נוצן רעקורסיאָן. >>> פיב 4 ((5) 4 >>> פיב 4 ((6) >>> 8 פיב 4 ((7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"צוריקקומען מעדיאַן פון עלעמענטן אין דער רשימה ל. >>> מעדיאַן (([3, 1, 2, 4, 5]) 3 >>> מעדיאַן (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"טשעקס אויב געגעבן שטריקל איז אַ פּאַלינדראָם >>> איז_פּאַלינדראָם (('') אמת >>> איז_פּאַלינדראָם (('aba') אמת >>> איז_פּאַלינדראָם (('aaaaa') אמת >>> איז_פּאַלינדראָם (('zbcd') פאַלש \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"צוריקקומען 2^n מאָדולאָ פּ (זאָל זיין אַווער פון נומעריקס). >>> מאָדולאָ פּ (א) 3, 5) 3 >>> מאָדולאָ פּ (א) 1, 101) 2 >>> מאָדולאָ פּ (א), 0, 101) 1 >>> מאָדולאָ פּ (א), 3, 11) 8 >>> מאָדולאָ פּ (א) 1, 100 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"נעמט ווי ינפּוט שטריקל ענקאָדעד מיט ענקאָדע_שיפט פונקציע. ריטורנס דיקאָדעד שטריקל. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"קערט ענקאָדעד שטריקל דורך יבעררוק יעדער כאַראַקטער דורך 5 אין די אַלפאַבע. \"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels איז א פונקציע וואס נעמט סטרינג און ריטורנז סטרינג אן וואקאלן. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"צוריקקומען אמת אויב אַלע נומערן אין דער רשימה ל זענען אונטער טהרעשאָלד ט. >>> below_threshold([1, 2, 4, 10], 100) אמת >>> below_threshold([1, 20, 4, 10], 5) פאַלש \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"לייג צו צוויי נומערן x און y >>> לייג צו ((2, 3) 5 >>> לייג צו ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"קאָנטראָלירן אויב צוויי ווערטער האָבן די זעלבע אותיות. >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') אמת >>> same_chars('abcd', 'dddddddabc') אמת >>> same_chars('dddddddabc', 'abcd') אמת >>> same_chars('eabcd', 'dddddddddabc') פאַלש >>> same_chars('abcd', 'dddddddabddce') פאַלש >>> same_chars'(abcdzzzz', 'dddzzzzzzzddabc') פאַלש \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"צוריקקומען n-טה פיבאָנאַצקי נומער. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets איז א סטרינג פון \"<\" און \">\". return True אויב יעדער עפן בראַקעט האט אַ קאָראַספּאַנדינג קלאָוזינג בראַקעט. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") True >>> correct_bracketing(\"<><>>\") True >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"צוריקקומען אמת איז רשימה עלעמענטן זענען מאָנאָטאָניקלי ינקריסינג אָדער דיקריסינג. >>> מאָנאָטאָניק (([1, 2, 4, 20]) אמת >>> מאָנאָטאָניק (([1, 20, 4, 10]) פאַלש >>> מאָנאָטאָניק (([4, 1, 0, -10]) אמת \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"צוריקקומען סאָרטעד יינציק פּראָסט עלעמענטן פֿאַר צוויי רשימות. >>> פּראָסט (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> פּראָסט (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"צוריקקומען די גרעסטע פריים פאַקטאָר פון n. נעמט n > 1 און איז נישט אַ פריים. >>> גרעסטע_פריים_פאַקטאָר ((13195) 29 >>> גרעסטע_פריים_פאַקטאָר ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n איז א פונקציע וואס סומז נומערן פון 1 ביז n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets איז א סטרינג פון \"(\" און \")\". צוריקקומען אמת אויב יעדער עפן בראַקעט האט אַ קאָראַספּאַנדינג קלאָוזינג בראַקעט. >>> correct_bracketing(\"(\") פאַלש >>> correct_bracketing(\"() אמת >>> correct_bracketing(\"(()) אמת >>> correct_bracketing(\")\"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs רעפּריזענץ קאָעפֿיציענטן פון אַ פּאַלינאָמיאַל. xs[0] + xs[1] * x + xs[2] * x^2 + .... צוריקקומען דעריוואַטיוו פון דעם פּאַלינאָמיאַל אין דער זעלביקער פאָרעם. >>> דעריוואַטיוו (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> דעריוואַטיוו [(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"די פיבפיב נומערן סיקוואַנס איז אַ סיקוואַנס ענלעך צו די פיבבאָנאַצקי סיקוואַנס וואָס איז דיפיינד ווי גייט: פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן)) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן) == 0 פיבפיב (באַהעפטן)) == 1 פיבפיב (באַהעפטן)) == 1 פיבפיבפיב (באַהעפטן)) + פיבפיבפיב (נ) + פיבאַהעפטן)) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"שרײַבן אַ פֿונקציע וואָקאַל_קאַונט וואָס נעמט אַ שטריקל וואָס רעפּריזענץ אַ וואָרט ווי ינפּוט און צוריקגעגעבן די נומער פון וואָקאַלס אין דעם שטריקל. וואָקאַלס אין דעם פאַל זענען 'אַ', 'ע', 'י', 'אָ', 'ו'. דאָ, 'י' איז אויך אַ וואָקאַל, אָבער בלויז ווען עס איז אין די סוף פון די געגעבן וואָרט. בייַשפּיל: >>> וואָקאַלס_קאַונט (א) \"אַבקדע\") 2 >>> וואָקאַלס_קאַונט (א) \"אַסידי\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"לייג צו מער טעסט קאַסעס. \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"קרייַז פאַרוועגן די דידזשיץ פון די ינטייגער קס, פאַרוועגן די דידזשיץ רעכט דורך פאַרוועגן און צוריקקומען די רעזולטאַט ווי אַ שטריקל. אויב פאַרוועגן > נומער פון דידזשיץ, צוריקקומען דידזשיץ ריווערסט. >>> קרייַז_שיפט 12 1) \"21\" >>> קרייַז_שיפט 12 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"אַרבעט שרייַבן אַ פונקציע וואָס נעמט אַ שטריקל ווי ינפּוט און קערט די סומע פון די אויבערשטער אותיות בלויז 'אַסקי קאָודז. ביישפילן: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"אין דעם אַרבעט, איר וועט זיין געגעבן אַ שטריקל אַז רעפּראַזענץ אַ נומער פון apples און apples אַז זענען פונאנדערגעטיילט אין אַ קאָרב פון פרוכט דעם קאָרב כּולל apples, apples, און מאַנגאָ פירות. געגעבן די שטריקל אַז רעפּראַזענץ די גאַנץ נומער פון די apples און apples און אַ ינטייגער אַז רעפּראַזענץ די גאַנץ נומער פון די פירות אין די קאָרב צוריקקומען די נומער פון די מאַנגאָ פירות אין די קאָרב. פֿאַר יקסאַמבאַל: fruit_distribution\"5(apples און 6 apples\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 apples און 1 apples\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 apples און 3 apples\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 apples און 120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"געגעבען א עריי וואס רעפרעזענטירט א צווייג פון א בוים וואס האט נישט-נעגאטיווע אינטעדזשער נאדס איז דיין אויפגאבע צו צונעמען איינע פון די נאדס און צוריקקומען עס. די צונעמען נאד זאל זיין די נאד מיט די קלענסטע אפילו ווערט. אויב מען געפינט מערערע נאדס מיט די זעלבע קלענסטע אפילו ווערט, צוריקקומען די נאד וואס האט קלענסטע אינדעקס. די צונעמען נאד זאל צוריקקומען אין א ליסטע, [smalest_value, זיין אינדעקס], אויב עס זענען נישט קיין אפילו ווערט אדער די געגעבן עריי איז ליידיג, צוריקקומען []. ביישפיל 1: אריינפיר: [4,2,3] אויספיר: [2, 1] דערקלערונג: 2 האט די קלענסטע אפילו ווערט, און 2 האט די קלענסטע אינדעקס. ביישפיל 2: אריינפיר: [1,2,3] אויספיר: [2, 1] דערקלערונג: 2 האט די קלענסטע אפילו ווערט, און 2 האט די קלענסטע אפילו אינדעקס. ביישפיל 3: אריינפיר: [1,2,3] [4,5, [4,5] [5,] [5, [0, 3, 4] [0, 2] אויספיר: 1 אויספיר: 0, [0,] דער קלענסטע נאד: 1 האט די קלענסטע נאד, אבער די קלענסטע אינדע איז ניד, וואס איז צוויי ניר, דערקלער ווערט איז ניר, [0==0], אזוי מיר וועלן אויסקלערן די ערשטע נאד, די קלענסטע נאד איז די קלענסטע נאד, אבער די לענג איז <==1\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''מען גיט א ליסטע פון פאזיטיווע אינטעדזשערס. צוריקקומען די גרעסטע אינטעדזשער וואס איז גרעסער ווי נול, און האט א פראקסיע גרעסער ווי אדער גלייך צו די ווערט פון די אינטעדזשער אליין. די פראקסיע פון א אינטעדזשער איז די צאל מאל וואס עס קומט ארויף אין די ליסטע. אויב עס איז נישט דא אזא ווערט, צוריקקומען -1.'''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''געגעבענע ליסטע פון אינטעדזשערס, צוריקקומען ליסטע אין אומזיסטע סדר. אומזיסטע סארטינג, איז ווען איר הייבט מיט די מינימום ווערט, דערנאך מאַקסימום פון די רעשט אינטעדזשערס, דערנאך מינימום און אַזוי ווייטער. ביישפילן: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''געגעבען די לענג פון די דריי זייטן פון א דרייקעלע. צוריקקומען די שטח פון די דרייקעלע ארומגענומען צו 2 דעצימאל פוינטס אויב די דריי זייטן פארמאגן א גילטיגע דרייקעלע. אנדערש צוריקקומען -1 דריי זייטן מאכן א גילטיגע דרייקעלע ווען די סומע פון סיי וועלכע צוויי זייטן איז גרעסער ווי די דריטע זייט. ביישפיל: דרייקעלע_א שטח (א שטח) 3, 4, 5) == 6.00 דרייקעלע_א שטח (א שטח) 1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''שרײַבן אַ פונקציע וואָס גיט צוריק True אויב דער אָבדזשעקט q וועט פליען, און False אַנדערש. דער אָבדזשעקט q וועט פליען אויב עס איז באַלאַנסט (עס איז אַ פּאַלינדראָמיק רשימה) און די סומע פון זייַן עלעמענטן איז ווייניקער ווי אָדער גלייַך די מאַקסימום מעגלעך וואָג w. בייַשפּיל: will_it_fly([1, 2], 5) â -> False # 1+2 איז ווייניקער ווי די מאַקסימום מעגלעך וואָג, אָבער עס איז אַנבאַלאַנסט. will_it_fly([3, 2, 3], 1) â -> False # עס איז באַלאַנסט, אָבער 3+2+3 איז מער ווי די מאַקסימום מעגלעך וואָג. will_it_fly[3, 2, 3], 9) â -> True # 3+23 איז ווייניקער ווי די מאַקסימום מעגלעך וואָג, און עס איז באַלאַנסט. will_it_fly([3], â 5) -> True # 3 איז ווייניקער ווי די מאַקסימום מעגלעך וואָג, און עס איז באַלאַנסט. '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"א פאלינדראמישע עריי איז אן עריי וואס ווערט געליינט די זעלבע צוריק און פאראויס. אין איין טויש, קען מען טוישן איין עלעמענט צו סיי וועלכע אנדערע עלעמענט. למשל: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''שרײַבן אַ פֿונקציע וואָס נעמט צוויי ליסטעס פון סטרינגס און ריטורנס די ליסט וואָס האט גאַנץ נומער פון טשאַרס אין די אַלע סטרינגס פון די ליסט ווייניקער ווי די אנדערע ליסט. אויב די צוויי ליסטעס האָבן די זעלבע נומער פון טשאַרס, צוריקקומען די ערשטער ליסט. ביישפילן total_match([], []) â -> [] total_match['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match['4', ['1', '2', '3', '4', '5', ['4]) -> ['4'] ]]'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"שרײַבן אַ פֿונקציע וואָס גיט צוריק אמת אויב די געגעבן נומער איז די מאַלטאַפּליקאַציע פון 3 פּרימע נומערן און פאַלש אַנדערש. וויסנדיק אַז (אַ) איז ווייניקער ווי 100.\"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"דיין אַרבעט איז צו שרייַבן אַ פונקציע וואָס ריטורנס אמת אויב אַ נומער קס איז אַ פּשוט מאַכט פון נ און פאַלש אין אנדערע קאַסעס. קס איז אַ פּשוט מאַכט פון נ אויב נ ** ינט = קס למשל: is_simple_power(1, 4) => אמת איז_simple_power(2, 2) => אמת איז_simple_power(8, 2) => אמת איז_simple_power(3, 2) => פאַלש איז_simple_power_(3, 1) פאַלש => איז_simple_power_(5, 3) => פאַלש \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''שרײַבן אַ פֿונקציע וואָס נעמט אַ גאַנץ נומער און גיט צוריק True אויב דאָס איז אַ קוב פון עטלעכע גאַנץ נומער. באַמערקונג: איר קענט יבערנעמען אַז די אַרייַנפיר איז שטענדיק גילטיק. ביישפילן: iscube(1) ==> True iscube(2) ==> False iscube(-1) ==> True iscube(64) ==> True iscube(0) ==> True iscube(180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"איר זענט געווען געבעטן צו שרייבן א פונקציע וואס באקומט א העקסאדעצימאל נומער אלס א סטרינג און ציילט די צאל פון העקסאדעצימאל ציפערן וואס זענען פריים (פריים נומער, אדער א פריים, איז א נאטירליכע נומער גרעסער ווי 1 וואס איז נישט א פראדוקט פון צוויי קלענערע נאטירליכע נומערן). העקסאדעצימאל ציפערן זענען 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. פריים נומערן זענען 2, 3, 5, 7, 11, 13, 17,... אזוי איר האָבן צו באַשליסן א נומער פון די פאלגענדע ציפערן: 2, 3, 5, 7, B (= דעצימאל 11), D (= דעצימאל 13). הערה: איר קענט אננעמען אז די אינטאוט איז שטענדיק ריכטיג אדער ליידיק, און סימבאלן A,B,C,D,E,F זענען שטענדיק גרויסע קארטערס. ביישפילן: פאר num \"AB\" דארף די אינטאוט זיין num = 1. פאר \"1077E\" דארף די אינטאוט זיין 2. פאר num \"AB\" דארף זיין num = 1.331EDA\" דארף די אינטאוט זיין num = 4.123ABC = 6.06745DEF \"2020\" דארף זיין 2.0\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"די פונקציע זאָל צוריקקומען אַ שטריקל, מיט יעדער כאַראַקטער רעפּריזענטינג אַ ביינערי נומער. יעדער כאַראַקטער אין די שטריקל וועט זיין '0' אָדער '1'. עס וועט זיין אַן עקסטרע פּאָר פון אותיות 'db' אין די אָנהייב און אין די סוף פון די שטריקל. די עקסטרע אותיות זענען דאָרט צו העלפן מיט די פֿאָרמאַט. ביישפילן: דעצימאַל_צו_ביינערי\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"איר זענט געגעבן אַ שטריקל s. דיין אַרבעט איז צו קאָנטראָלירן אויב די שטריקל איז צופרידן אָדער נישט. א שטריקל איז צופרידן אויב זייַן לענג איז בייַ מינדסטער 3 און יעדער 3 קאָנסעקוטיווע אותיות זענען באַזונדער פֿאַר בייַשפּיל: איז_האַפּי (a) => פאַלש איז_האַפּי (aa) => פאַלש איז_האַפּי (abcd) => אמת איז_האַפּי (aabb) => פאַלש איז_האַפּי (adb) => אמת איז_האַפּי (xyy) => פאַלש \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"עס איז די לעצטע וואָך פון די סעמיסטער און די לערער האט צו געבן די גראַדעס צו סטודענטן. די לערער האט געמאכט איר אייגן אַלגערידאַם פֿאַר גריידינג. דער בלויז פּראָבלעם איז, זי האט פאַרפאַלן די קאָד זי געניצט פֿאַר גריידינג. זי האט געגעבן איר אַ רשימה פון גפּאַ פֿאַר עטלעכע סטודענטן און איר האָבן צו שרייַבן אַ פונקציע וואָס קענען אַרויסגעבן אַ רשימה פון בריוו גראַדעס ניצן די פאלגענדע טיש: גפּאַ.\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"שרײַבן אַ פֿונקציע וואָס נעמט אַ שטריקל און גיט צוריק אמת אויב די שטריקל לענג איז אַ פּריים נומער אָדער פאַלש אַנדערש ביישפילן פּריים_לענגטה (העלאָ) == אמת פּריים_לענגטה (אַבקדקבאַ) == אמת פּריים_לענגטה (קאַטטענס) == אמת פּריים_לענגטה (אָרינגה) == פאַלש \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"געגעבן אַ positive integer n, צוריקקומען די ציילן פון די נומערן פון n-ציפער positive integers אַז אָנהייבן אָדער סוף מיט 1. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"געגעבן אַ positive integer N, צוריקקומען די גאַנץ סומע פון זייַן דידזשיץ אין ביינערי. בייַשפּיל פֿאַר N = 1000, די סומע פון דידזשיץ וועט זיין 1 די רעזולטאַט זאָל זיין \"1\". פֿאַר N = 150, די סומע פון דידזשיץ וועט זיין 6 די רעזולטאַט זאָל זיין \"110\". פֿאַר N = 147, די סומע פון דידזשיץ וועט זיין 12 די רעזולטאַט זאָל זיין \"1100\". וועריאַבאַלז: @N integer Constraints: 0 â‰¤ N â‰¤ 10000. רעזולטאַט: אַ שטריקל פון ביינערי נומער \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"געגעבן אַ ניט-רוקן רשימה פון ינטיידזשערז, לייגן די פּאַרע עלעמענטן וואָס זענען אין מאָדנע ינדאַקסעס.\"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"שרײַבן אַ פֿונקציע וואָס נעמט אַ שטריקל און גיט צוריק אַ אָרדערד ווערסיע פון אים. אָרדערד ווערסיע פון שטריקל, איז אַ שטריקל וווּ אַלע ווערטער (ספּאַרעסט דורך פּלאַץ) זענען ריפּלייסט דורך אַ נייַ וואָרט וווּ אַלע די אותיות זענען עריינדזשד אין אַסינדענדינג סדר באזירט אויף אַסקי ווערט. באַמערקונג: איר זאָל האַלטן די סדר פון ווערטער און ליידיק ספּייסאַז אין די זאַץ. למשל: anti_shuffle ((('Hi') גיט צוריק 'Hi' anti_shuffle ((('hello') גיט צוריק 'ehllo' anti_shuffle (('Hello World!!!') גיט צוריק 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"איר זענט געגעבן אַ 2 דימענשאַנאַל דאַטן, ווי אַ נעסטעד רשימות, וואָס איז ענלעך צו מאַטריץ, אָבער, ניט ענלעך מאַטריץ, יעדער רודערן קען אַנטהאַלטן אַ אַנדערש נומער פון זייַלען. געגעבן לסט, און ינטייגער קס, געפֿינען ינטיידזשערז קס אין די רשימה, און צוריקקומען רשימה פון טופּלעס, [(קסנומקס, י 1), (קסנומקס, י 2) ...] אַזאַ אַז יעדער טופּלע איז אַ קאָואָרדאַנאַט - (רודערן, זייַלען), סטאַרטינג מיט 0. סאָרט קאָואָרדאַנאַץ ערשט דורך ראָוז אין אַסידענסינג סדר. אויך, סאָרט קאָואָרדאַנאַץ פון די רודערן דורך זייַלען אין דעסקרינדינג סדר. ביישפילן: געט_ראָו [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0, 0, 0, 0, 1, 4], 0 (2, 5), (2, 0, 0] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"געגעבן אַ מענגע פון ניט-נעגאַטיוו ינטיידזשערז, צוריקקומען אַ קאָפּיע פון די געגעבן מענגע נאָך סאָרטינג, איר וועט סאָרט די געגעבן מענגע אין אַסיענדינג סדר אויב די סומע (פירסט אינדעקס ווערט, לעצט אינדעקס ווערט) איז פּאַרע, אָדער סאָרט עס אין דעסקענדינג סדר אויב די סומע (פירסט אינדעקס ווערט, לעצט אינדעקס ווערט) איז פּאַרע. באַמערקונג: * טאָן ניט טוישן די געגעבן מענגע. ביישפילן: * סאָרט_אַררייַ [(]) => [] * סאָרט_אַררייַ []] => [5] * סאָרט_אַררייַ [2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * סאָרט_אַררייַ [2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"שאַפֿן אַ פונקציע ענקריפּט וואָס נעמט אַ שטריקל ווי אַן אַרגומענט און צוריקקומען אַ שטריקל ענקריפּטעד מיט די אַלפאַבע איז ראָוטייטיד. די אַלפאַבע זאָל זיין ראָוטייטיד אין אַזאַ אַ שטייגער אַז די אותיות יבעררוקן אַראָפּ דורך צוויי כאַפּן צו צוויי ערטער. פֿאַר בייַשפּיל: ענקריפּט (('היי') קערט 'לם' ענקריפּט (('אַסדףגגגדזשקל') קערט 'עווהקלינאָפּ' ענקריפּט (('גף') קערט 'קדזש' ענקריפּט (('עט') קערט 'יקס' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"מען גיט א ליסטע פון אינטעדזשערס. שרייב א פונקציע next_smallest() וואס גיט צוריק די 2טע קלענסטע עלעמענט פון די ליסטע. גיט צוריק ניין אויב עס איז נישט דא אזא עלעמענט. next_smallest([1, 2, 3, 4, 5]) == 2 next_smallest([5, 1, 4, 3, 2]) == 2 next_smallest([]) == קיין next_smallest([1, 1]) == קיין \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"איר וועט באַקומען אַ שטריקל פון ווערטער, און דיין אַרבעט איז צו ציילן די נומער פון באָרדאַמז. אַ באָרדאַם איז אַ זאַץ וואָס הייבט מיט די וואָרט \"איך\". זאַץ זענען דילימאַטעד דורך '.', '?' אָדער '!'. למשל: >>> איז_באָרדדד ((\"העלאָ וועלט\") 0 >>> איז_באָרדד ((\"די הימל איז בלוי. די זון איז שיינינג. איך ליבע דעם וועטער\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''שאַפֿן אַ פונקציע וואָס נעמט 3 נומערן. ריטורנס אמת אויב איינער פון די נומערן איז גלייַך צו די סומע פון די אנדערע צוויי, און אַלע נומערן זענען ינטיידזשערז. ריטורנס פאַלש אין קיין אנדערע קאַסעס. ביישפילן any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) â -> True any_int{3.6, -2.2, 2) â -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"שרײַבן אַ פֿונקציע וואָס נעמט אַ אָנזאָג, און קאָדירט אויף אַזאַ א וועג אַז עס סוואַפּס פאַל פון אַלע אותיות, ריפּלייסיז אַלע וואָקאַלז אין דעם אָנזאָג מיט די בריוו וואָס איז 2 ערטער פאָרויס פון דעם וואָקאַל אין די ענגליש אַלפאַבע. נעמט בלויז אותיות. ביישפילן: >>> קאָדירן ((('טעסט') 'TGST' >>> קאָדירן ((('דאס איז אַ אָנזאָג') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"איר זענט געגעבן אַ רשימה פון ינטיידזשערז. איר דאַרפֿן צו געפֿינען די גרעסטע פּרים ווערט און צוריקקומען די סכום פון זייַן דידזשיץ. ביישפילן: פֿאַר lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] די רעזולטאַט זאָל זיין 10 פֿאַר lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] די רעזולטאַט זאָל זיין 25 פֿאַר lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] די רעזולטאַט זאָל זיין 13 פֿאַר lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] די רעזולטאַט זאָל זיין 11 פֿאַר lst = [0,81,12,3,21,1] די רעזולטאַט זאָל זיין 3 פֿאַר lst = [0,8,1,2,1,7] די רעזולטאַט זאָל זיין 7\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"געגעבן אַ ווערטערבוך, צוריקקומען אמת אויב אַלע שליסלען זענען סטרינגס אין קלענערער פאַל אָדער אַלע שליסלען זענען סטרינגס אין אויבערשטער פאַל, אַנדערש צוריקקומען פאַלש. די פונקציע זאָל צוריקקומען פאַלש איז די געגעבן ווערטערבוך איז ליידיק. ביישפילן: טשעק_דיקט_קאַסע (((\"אַ\":\" עפּל\", \"ב\":\" באַנאַנאַ\"}) זאָל צוריקקומען אמת. טשעק_דיקט_קאַס (((\"אַ\":\" עפּל\", \"אַ\":\" באַנאַנאַ\", \"ב\":\" באַנאַנאַ\"}) זאָל צוריקקומען פאַלש. טשעק_דיקט_קאַס {\"אַ\":\" עפּל\", 8:\" באַנאַנאַ\", \"אַ\":\" עפּל\"}) זאָל צוריקקומען פאַלש. טשעק_דיקט_קאַס {\"נעם\":\" יוחנן\", \"אַלט\":\" 36\", \"שטאָט\":\" האָוסטאָן\"}) פאַלש זאָל צוריקקומען טשעק_דיקט_קאַס {\"NC\":\" STATE\", \"Z\":\" 45123 \"IP\" }) זאָל צוריקקומען אמת.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"ימפּלאַמענט אַ פונקציע וואָס נעמט אַ ניט-נעגאַטיוו ינטייגער און ריטורנס אַ מענגע פון די ערשטער n ינטיידזשערז וואָס זענען פּראַמ נומערן און ווייניקער ווי n. פֿאַר בייַשפּיל: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"פאַרענדיקן די פונקציע וואָס נעמט צוויי ינטיידזשערז און ריטורנס די פּראָדוקט פון זייער וניט דידזשיץ. יבערנעמען די ינפּוט איז שטענדיק גילטיק. ביישפילן: פאַרגרעסערן 148, 412) זאָל צוריקקומען 16. פאַרגרעסערן 19 28 זאָל צוריקקומען 72. פאַרגרעסערן 2020 1851 זאָל צוריקקומען 0. פאַרגרעסערן 14 15 זאָל צוריקקומען 20. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"געגעבן אַ שטריקל s, ציילן די נומער פון הויך-קאַסער וואָקאַלס אין פּאַרע אינדעקסן. למשל: count_upper (('aBCdEf') ריטורנס 1 count_upper (('abcdefg') ריטורנס 0 count_upper (('dBBE') ריטורנס 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''שאַפֿן אַ פונקציע וואָס נעמט אַ ווערט (שטרינג) וואָס רעפּריזענץ אַ נומער און צוריקקומען די קלאָוסאַסט ינטיידזשער צו אים. אויב די נומער איז עקווידיסטאַנט פון צוויי ינטיידזשערז, ראָונד עס אַוועק פון נול. ביישפילן >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 באַמערקונג: ראָונדינג אַוועק פון נול מיטל אַז אויב די געגעבן נומער איז עקווידיסטאַנט פון צוויי ינטיידזשערז, די איינער איר זאָל צוריקקומען איז די וואָס איז די ווייַטאַסט פון נול. פֿאַר בייַשפּיל closest_integer \" ((14.5\") זאָל צוריקקומען 15 און closest_integer \" ((-14.5\") זאָל צוריקקומען -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"געגעבן אַ positive integer n, איר האָבן צו מאַכן אַ הויפן פון n לעוועלס פון שטיינער. דער ערשטער מדרגה האט n שטיינער. די נומער פון שטיינער אין דער ווייַטער מדרגה איז: - דער ווייַטער מאָדנע נומער אויב n איז מאָדנע. - דער ווייַטער פּאַרע נומער אויב n איז פּאַרע. צוריקקומען די נומער פון שטיינער אין יעדער מדרגה אין אַ רשימה, ווו עלעמענט אין אינדעקס איך רעפּראַזענץ די נומער פון שטיינער אין די מדרגה (i + 1). ביישפילן: >>> make_a_pile(3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"איר וועט באַקומען אַ שטריקל פון ווערטער אפגעשיידט דורך קאָמאַס אָדער ספּייסיז. דיין אַרבעט איז צו צעטיילט די שטריקל אין ווערטער און צוריקקומען אַ מענגע פון די ווערטער. למשל: words_string ((\"היי, מיין נאָמען איז יוחנן\") == [\"היי\", \"מיין\", \"נאָמען\", \"איז\", \"יוחנן\"] words_string ((\"איין, צוויי, דריי, פיר, פינף, זעקס\") == [\"איין\", \"צוויי\", \"דרייַ\", \"פיר\", \"פופֿן\", \"זעקס\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"די פונקציע נעמט צוויי פאזיטיווע נומערן x און y און ריטורנז די גרעסטע פּערע אינטעדזשער נומער וואס איז אין די קייט [x, y] אינקלוסיוו. אויב עס איז נישט דא אזא נומער, דעמאלטס דארף די פונקציע צוריקקומען -1. למשל: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"איר זענט געגעבן צוויי positive ינטאַדזשערז n און m, און דיין אַרבעט איז צו רעכענען די דורכשניטלעך פון די ינטאַדזשערז פון n דורך m (אַרייַנגערעכנט n און m). ראָונד די ענטפער צו די ניראַסט ינטאַדזשער און קאָנווערט אַז צו ביינערי. אויב n איז גרעסער ווי m, צוריקקומען -1. בייַשפּיל: ראָונדאַד_אַווג (א) 1, 5) => \"0ב11\" ראָונדאַד_אַווג (א) 7, 5) => -1 ראָונדאַד_אַווג (א) 10, 20) => \"0ב11\" ראָונדאַד_אַווג (א) 20, 33) => \"0ב11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"געגעבן אַ רשימה פון positive integers x. צוריקקומען אַ סאָרטיד רשימה פון אַלע עלעמענטן וואָס האט ניט קיין פּאַרע ציפער. באַמערקונג: צוריקגעקומען רשימה זאָל זיין סאָרטיד אין ינקריסינג סדר. למשל: >>> יינציק_דידזשיץ (([15, 33, 1422, 1]) [1, 15, 33] >>> יינציק_דידזשיץ (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"אראפגעלייגט א אראפשטעל פון אינטעדזשערס, סארט די אינטעדזשערס וואס זענען צווישן 1 און 9 אריינגערעכנט, פארקערט דעם רעזולטאטארן אראפשטעל, און דערנאך פארבייטשטעלט יעדע ציפער מיט איר קארעספאנדענעם נאמען פון \"איין\", \"צוויי\", \"דריי\", \"פיר\", \"פופיר\", \"שש\", \"זיבן\", \"אכט\", \"ניין\". למשל: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> סארט arr -> [1, 1, 2, 3, 4, 5, 8] -> ריווערס arr -> [8, 5, 4, 3, 2, 1, 1] צוריקקומען [\"אכט\", \"פיר\", \"דריי\", \"צוויי\", \"צוויי\", \"צוויי\", \"איין\", \"איין\"] אויב די אראפ איז ליידיג, צוריקקומען אן אראפשטעל: arr = [] צוריקקומען [] אויב די אראפשטעל האט סיי וועלכע מאדנע נאמען איגנארירן עס: arr = [1, -1 , 55] -> arr -> [1, 55] -> reverse arr -> [55, return = 1] - [איין' ].\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"ימפּלאַמענט די פונקציע f וואָס נעמט n ווי אַ פּאַראַמעטער, און ריטורנס אַ רשימה פון גרייס n, אַזאַ אַז די ווערט פון די עלעמענט אין אינדעקס איך איז די פאַקטאָריאַל פון איך אויב איך איז פּער אָדער די סומע פון נומערן פון 1 צו איך אַנדערש. איך סטאַרץ פון 1. די פאַקטאָריאַל פון איך איז די מאַלטאַפּליקיישאַן פון די נומערן פון 1 צו איך (1 * 2 * ... * איך). בייַשפּיל: f(5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"געגעבן אַ positive גאַנץ נומער n, צוריקקומען אַ טופּל אַז האט די נומער פון פּאַר און מאָדנע גאַנץ פּאַלינדראָמס אַז פאַלן ין די קייט ((1, n), ינקלוסיוו. בייַשפּיל1: ינפּוט: 3 רעזולטאַט: (1, 2) דערקלערונג: גאַנץ פּאַלינדראָם זענען 1, 2, 3. איינער פון זיי איז פּאַר, און צוויי פון זיי זענען מאָדנע. בייַשפּיל2: ינפּוט: 12 רעזולטאַט: (4, 6) דערקלערונג: גאַנץ פּאַלינדראָם זענען 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. פיר פון זיי זענען פּאַר, און 6 פון זיי זענען מאָדנע. באַמערקונג: 1. 1 <= n <= 10 ^ 3 2. טופּל האט צוריקגעקומען די נומער פון פּאַר און מאָדנע גאַנץ פּאַלינדראָמס ריספּעקטיוולי. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"שרײַבן אַ פֿונקציע count_nums וואָס נעמט אַ מענגע פון אינטעדזשערס און גיט צוריק די נומער פון עלעמענטן וואָס האט אַ סכום פון דידזשיץ > 0. אויב אַ נומער איז נעגאַטיוו, דעמאָלט זייַן ערשטער געחתמעט ציפער וועט זיין נעגאַטיוו: למשל -123 האט געחתמעט דידזשיץ -1, 2, און 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"מיר האָבן אַ 'אַרר' פון N אינטעדזשערז אַרר[1], אַרר[2], ..., אַרר[N]. די נומערן אין דער מענגע וועט זיין ראַנדאַמלי אָרדערד. דיין אַרבעט איז צו באַשליסן אויב עס איז מעגלעך צו באַקומען אַ מענגע סאָרטעד אין ניט-דעקריסינג סדר דורך דורכפירן די פאלגענדע אָפּעראַציע אויף די געגעבן מענגע: איר זענט ערלויבט צו דורכפירן רעכט שיף אָפּעראַציע קיין נומער פון מאל. איין רעכט שיף אָפּעראַציע מיטל סשיפטינג אַלע עלעמענטן פון די מענגע דורך איין שטעלע אין די רעכט ריכטונג. די לעצטע עלעמענט פון די מענגע וועט זיין אריבערגעפארן צו די אָנהייב שטעלע אין די מענגע ד\"ה 0th אינדעקס. אויב עס איז מעגלעך צו באַקומען די סאָרטעד מענגע דורך דורכפירן די אויבן אָפּעראַציע דעמאָלט צוריקקומען אמת אַנדערש צוריקקומען פאַלש. אויב די געגעבן מענגע איז ליידיק דעמאָלט צוריקקומען אמת. באַמערקונג: די געגעבן רשימה איז געראַנטיד צו האָבן יינציקלעדיק עלעמענטן. פֿאַר בייַשפּאָד: מאַך_אנע_און_און_און[3, 4, 5, 2] דערקלערונג: אמת דערקלערונג: דורך פּערפערן 2 רעכט אָפּעריישאַנז, ניט-דעקריסינג אָרענגינג אָרענגעס קענען זיין אַריסיסט פֿאַר די מענגע פֿאַר די מענגע מענגע.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"אין דעם פּראָבלעם, איר וועט ימפּלאַמענט אַ פונקציע וואָס נעמט צוויי רשימות פון נומערן, און דיטערמענץ צי עס איז מעגלעך צו דורכפירן אַ וועקסל פון עלעמענטן צווישן זיי צו מאַכן lst1 אַ רשימה פון בלויז פּאַר נומערן. עס איז קיין שיעור אויף די נומער פון וועקסל עלעמענטן צווישן lst1 און lst2. אויב עס איז מעגלעך צו וועקסל עלעמענטן צווישן די lst1 און lst2 צו מאַכן אַלע די עלעמענטן פון lst1 צו זיין פּאַר, צוריקקומען \"יאָ\". אַנדערש, צוריקקומען \"ניין\". למשל: וועקסל [(1, 2, 3, 4], [1, 2, 3, 4]) => \"יאָ\" וועקסל [(1, 2, 3, 4], [1, 5, 3, 4]) => \"ניין\" עס איז אנגענומען אַז די ינפּוץ רשימות וועט זיין ניט-טייַער. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"געגעבען א סטרינג וואס רעפרעזענטירט א ספעיס אפגעשיידט קליינע אותיות, צוריקקומען א ווערטערבוך פון דעם אות מיט די מערסטע איבערחזרונגען און מיט די קארעספאנדענטע ציילונג. אויב עטליכע אותיות האבן די זעלבע ערשיינונג, צוריקקומען זיי אלע. ביישפיל: היסטאגרעם\"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"אַרבעט מיר זענען געגעבן צוויי סטרינגס s און c, איר האָבן צו ויסמעקן אַלע די אותיות אין s וואָס זענען גלייַך צו קיין כאַראַקטער אין c דעמאָלט קאָנטראָלירן אויב די רעזולטאַט שטריקל איז פּאַלינדראָם. א שטריקל איז גערופן פּאַלינדראָם אויב עס לייענט די זעלבע צוריק ווי פאָרויס. איר זאָל צוריקקומען אַ טופּל וואָס כּולל די רעזולטאַט שטריקל און אמת / פאַלש פֿאַר די קאָנטראָלירן. בייַשפּיל פֿאַר s = \"אַבקדע\", c = \"אַע\", די רעזולטאַט זאָל זיין ('בקד', פאַלש) פֿאַר s = \"אַבקדעף\", c = \"ב\" די רעזולטאַט זאָל זיין ('אַקדעף', פאַלש) פֿאַר s = \"אַבקדעדעד\", c = \"אַבקדעף\", די רעזולטאַט זאָל זיין ('אַקדעד', אמת) \"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"געגעבן אַ רשימה פון סטרינגס, ווו יעדער שטריקל באשטייט פון בלויז דידזשיץ, צוריקקומען אַ רשימה. יעדער עלעמענט י פון די רעזולטאַט זאָל זיין \"די נומער פון מאָדנע עלעמענטן אין די שטריקל י פון די ינפּוט. \" ווו אַלע די י זאָל זיין ריפּלייסט דורך די נומער פון מאָדנע דידזשיץ אין די י'ט שטריקל פון די ינפּוט. >>> מאָדנע_קאָונט ['1234567']) [\"די נומער פון מאָדנע עלעמענטן 4n די סטר 4נג פון די 4nput.\"] >>> מאָדנע_קאָונט ['3',\"111111\"]) [\"די נומער פון מאָדנע עלעמענטן 1n די סטר 1נג פון די 1nput. \", \"די נומער פון מאָדנע עלעמענטן 8n די סטר 8נג פון די 8nput. \"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"געגעבן אַ מענגע פון ינטיידזשערז נאַמז, געפינען די מינימום סומע פון קיין ניט-טאָף סאַב-מענגע פון נאַמז. בייַשפּיל minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"איר זענט געגעבן אַ רעקטאַנגגיאַלער גריד פון וועלז. יעדער רודערן רעפּראַזענץ אַ איין געזונט, און יעדער 1 אין אַ רודערן רעפּראַזענץ אַ איין אַפּאַראַט פון וואַסער. יעדער געזונט האט אַ קאָראַספּאַנדינג בעקן וואָס קענען ווערן געניצט צו עקסטראַקט וואַסער פון עס, און אַלע בעקץ האָבן די זעלבע קאַפּאַציטעט. דיין אַרבעט איז צו נוצן די בעקץ צו ליידיק די וועלז. רעזולטאַט די נומער פון מאל איר דאַרפֿן צו נידעריקער די בעקץ. בייַשפּיל 1: ינפּוט: גריד: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 רעזולטאַט: 6 בייַשפּיל: ינפּוט: גריד: [[0,0,1,1], [0,0,0,0], [1,1], [0,1,1]] bucket_capacity: 2 רעזולטאַט: 5 בייַשפּיל: ינפּוט: [[0,0,0], [0,0]] bucket_capacity: 5 געזונט: 0 * קנאַפּ: 1 * * * * * 1 * * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * * 2 * * * * * * * * * * * 2 * * 2 * * * 2 * * * * 2 * * * * * * * * 2 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"אין דעם קאַטאַ, איר האָבן צו סאָרט אַ מענגע פון ניט-נעגאַטיוו ינטיידזשערז לויט צו נומער פון אָנעס אין זייער ביינערי רעפּראַזענץ אין אַסינדענט סדר. פֿאַר ענלעך נומער פון אָנעס, סאָרט באזירט אויף דעצימאַל ווערט. עס מוזן זיין ימפּלאַמענאַד ווי דעם: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"געגעבן אַ שטריקל s און אַ נאַטירלעך נומער n, איר האָבן שוין טאַסקט צו ימפּלאַמענט אַ פונקציע אַז ריטורנס אַ רשימה פון אַלע ווערטער פון שטריקל s אַז אַנטהאַלטן פּונקט n קאָנסאָנאַנץ, אין סדר די ווערטער דערשייַנען אין די שטריקל s. אויב די שטריקל s איז ליידיק דעמאָלט די פונקציע זאָל צוריקקומען אַ ליידיק רשימה. באַמערקונג: איר זאל יבערנעמען די ינפּוט שטריקל כּולל בלויז אותיות און ספּייסיז. ביישפילן: select_words \"מערי האט אַ ביסל לאם\", 4) ==> [\"little\"] select_words \"מערי האט אַ ביסל לאם\", 3) ==> [\"מערי\", \"לאַם\"] select_words \"פשוט ווייַס פּלאַץ\", 2) ==> [] select_words \"העלא וועלט\", 4) ==> [\"וועלט\"] select_words \"אָנקל סאַם\", 3) ==> [\"אָנקל\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"איר זענט געגעבן אַ וואָרט. דיין אַרבעט איז צו געפֿינען די קלאָוסאַסט וואָקאַל אַז שטייט צווישן צוויי קאָנסאָנאַנץ פון די רעכט זייַט פון דעם וואָרט (קאַס סענסיטיוו). וואָקאַלז אין די אָנהייב און ענדיקן טוט נישט ציילן. צוריקקומען ליידיק שטריקל אויב איר האָט נישט געפונען קיין וואָקאַל באגעגנט די אויבן צושטאַנד. איר קען יבערנעמען אַז די געגעבן שטריקל כּולל ענגליש בריוו בלויז. בייַשפּיל: get_closest_vowel (((\"יאָגורט\") ==> \"ו\" get_closest_vowel (((\"F\") ==> \"ו\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''איר זענט געגעבן אַ רשימה פון צוויי סטרינגס, ביידע סטרינגס באשטייט פון עפענען פּאַראַנטעזעס '(' אָדער נאָענט פּאַראַנטעזעס ') '. דיין אַרבעט איז צו קאָנטראָלירן אויב עס איז מעגלעך צו קאַנאַקאַטיין די צוויי סטרינגס אין עטלעכע סדר, אַז די ריזאַלטינג שטריקל וועט זיין גוט. א שטריקל S איז געהאלטן צו זיין גוט אויב און בלויז אויב אַלע פּאַראַנטעזעס אין S זענען באַלאַנסט. פֿאַר בייַשפּיל: די שטריקל '((()) ' איז גוט, בשעת די שטריקל '())' איז נישט. צוריקקומען 'יא' אויב עס איז אַ וועג צו מאַכן אַ גוט שטריקל, און צוריקקומען 'ניין' אַנדערש. ביישפילן: match_parens [('() ', ') ']) == 'יא' match_parens [('(']) == 'ניין' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"געגעבן אַ מענגע פון ינטיידזשערז און אַ positive ינטיידזשער ק, צוריקקומען אַ סאָרטעד רשימה פון לענג ק מיט די מאַקסימום ק נומערן אין אַרר. בייַשפּיל1: אַרייַנפיר: אַרר = [-3, -4, 5], ק = 3 רעזולטאַט: [-4, -3, 5] בייַשפּיל2: אַרייַנפיר: אַרר = [4, -4, 4], ק = 2 רעזולטאַט: [4, 4] בייַשפּיל3: אַרר = [-3, 2, 1, 2, -1, -2, 1], ק = 1 רעזולטאַט: [2] באַמערקונג: 1. די לענג פון די מענגע וועט זיין אין די קייט פון [1, 1000]. 2. די עלעמענטן אין די מענגע וועט זיין אין די קייט פון [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"געגעבן אַ ניט-רוקן רשימה פון ינטיידזשערז, צוריקקומען די סומע פון אַלע פון די מאָדנע עלעמענטן וואָס זענען אין אַפֿילו שטעלעס. ביישפילן לייזונג (([5, 8, 7, 1]) ==> 12 לייזונג (([3, 3, 3, 3, 3]) ==> 9 לייזונג (([30, 13, 24, 321]) ==>0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"געגעבן אַ ניט-לאָך מענגע פון ינטיידזשערז אַרר און אַ ינטיידזשער ק, צוריקקומען די סומע פון די עלעמענטן מיט בייַ רובֿ צוויי דידזשיץ פון די ערשטער ק עלעמענטן פון אַרר. בייַשפּיל: אַרט = [111,21,3,4000,5,6,7,8,9], ק = 4 רעזולטאַט: 24 # סומע פון 21 + 3 קאַנסטריינץ: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"א פאזיטיווע אינטעגער n, צוריקקומען א סארטירטע ליסטע וואס האט די אומגעלייגטע נומערן אין קאלאץ סיקווענץ. די קאלאץ קאנעקשאן איז א קאנעקשאן אין מאטעמאטיק וואס באדארפט א סיקווענץ וואס איז דעפינירט ווי פאלגענד: אנהייבן מיט סיי וועלכע פאזיטיווע אינטעגער n. דערנאך ווערט יעדער טערם באקומען פון די פריערדיגע טערם ווי פאלגענד: אויב די פריערדיגע טערם איז זויער, איז די קומענדיגע טערם א האלב פון די פריערדיגע טערם. אויב די פריערדיגע טערם איז אומגעלייגט, איז די קומענדיגע טערם 3 מאל די פריערדיגע טערם פלוס 1. די קאנעקשאן איז אז נישט קיין חילוק וועלכע ווערט פון n, וועט די סיקווענץ אלעמאל אנקומען צו 1. נאטיץ: 1. קאלאץ(1) איז [1]. 2. צוריקגעקומען ליסטע סארטירט אין א פארגרייכענדע סדר. למשל: get_odd_collatz(5) צוריקקומען [1, 5] # די קאלאץ סיקווענץ פאר 5 איז [5, 8, 16, 4, 2, 1, 4, 2, 1], אזוי די אומגעלייטיקע נומערן זענען נאר 1, און 5. \"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"איר האָבן צו שרייַבן אַ פונקציע וואָס וואַלאַדייץ אַ געגעבן דאַטע שטריקל און ריטורנס אמת אויב די דאַטע איז גילטיק אַנדערש פאַלש. די דאַטע איז גילטיק אויב אַלע פון די פאלגענדע כּללים זענען צופֿרידן: 1. די דאַטע שטריקל איז נישט ליידיק. 2. די נומער פון טעג איז ניט ווייניקער ווי 1 אָדער העכער ווי 31 טעג פֿאַר חדשים 1,3,5,7,8,10,12. און די נומער פון טעג איז ניט ווייניקער ווי 1 אָדער העכער ווי 30 טעג פֿאַר חדשים 4,6,9,11. און, די נומער פון טעג איז ניט ווייניקער ווי 1 אָדער העכער ווי 29 פֿאַר די חודש 2. 3. די חדשים זאָל ניט זיין ווייניקער ווי 1 אָדער העכער ווי 12. 4. די דאַטע זאָל זיין אין די פֿאָרמאַט: mm-dd-yyyy פֿאַר בייַשפּיל: גילטיק_דאַטע (('03-11-2000') => אמת_דאַטע (('15-01-2012') => פאַלש גילטיק_דאַטע (('04-040') => פאַלש_דאַטע (('06-04-2020') => אמת_דאַטע (('06/04/2020')\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''געגעבן אַ שטריקל פון ווערטער, צוריקקומען אַ רשימה פון ווערטער שפּאַלטן אויף ווייץפּאַסעס, אויב קיין ווייץפּאַסעס עקסיסטירט אין דעם טעקסט איר זאָל שפּאַלטן אויף קאָמאַס ',' אויב קיין קאָמאַס עקסיסטירט איר זאָל צוריקקומען די נומער פון קלענערער אותיות מיט מאָדנע סדר אין די אַלפאַבע, אָרדערס 'א') = 0, אָרדערס' ב') = 1, ... אָרדערס 'ז') = 25 ביישפילן שפּאַלטן_ווערדס ((\"העלאָ וועלט!\") â -> [\"העלאָ\", \"וועלט!\"] שפּאַלטן_ווערדס ((\"העלאָ, וועלט!\") â -> [\"העלאָ\", \"וועלט!\" שפּאַלטן_ווערדס))'''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''געגעבען א ליסטע פון נומערן, צוריקקומען צי זיי זענען סארטירט אין א פארגרעסערונג. אויב ליסטע האט מער ווי 1 דאפליקאט פון די זעלבע נומער, צוריקקומען פאלש. נעמט אן קיין נעגאטיווע נומערן און בלויז אינטעדזשערס. ביישפילן is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"די אינטערוועלס זענען פארמאכט, וואס מיינט אז די אינטערוועל (באפאנג, סוף) איז ביידע אנהייב און סוף. פאר יעדע אינטערוועל איז אנגענומען אז די אנהייב איז ווייניגער אדער גלייך צו די ענדע. דיין אויפגאבע איז צו באשטימען אויב די לענג פון די אינטערוועלס איז א פריים נומער. למשל די אינטערוועלס (1, 3), (2, 4) איז (2, 3) וואס די לענג איז 1, וואס איז נישט א פריים נומער. אויב די לענג פון די אינטערוועל איז א פריים נומער, גיב צוריק \"יא\", אנדערש גיב צוריק \"ניין\". אויב די צוויי אינטערוועלס זענען נישט אינטערוועל, גיב צוריק \"ניין\". [input/output] סעמפלס: אינטערוועל (אנהייב, סוף) = (1, 2).\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"איר זענט געגעבן אַ קייט פון ינטיידזשערז און איר דאַרפֿן צו צוריקקומען סכום פון מאַגנאַטודז פון ינטיידזשערז מאַלטאַפּיאַלייטיד דורך פּראָדוקט פון אַלע וואונדער פון יעדער נומער אין די קייט, רעפּריזענטיד דורך 1, -1 אָדער 0. באַמערקונג: צוריקקומען קיין איינער פֿאַר ליידיק קייט. בייַשפּיל: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == קיין איינער\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"א גריד מיט N ראָוז און N קאָלאָמנס (N >= 2) און אַ positive integer k, יעדער צעל פון די גריד כּולל אַ ווערט. יעדער integer אין די קייט [1, N * N] ינקלוסיוו דערשייַנען פּונקט אַמאָל אויף די סעלז פון די גריד. איר האָבן צו געפֿינען די מינימום דרך פון לענג k אין די גריד. איר קענען אָנהייבן פון קיין צעל, און אין יעדער שריט איר קענען מאַך צו קיין פון די שכייניש סעלז, אין אנדערע ווערטער, איר קענען גיין צו סעלז וואָס טיילן אַ ברעג מיט איר קראַנט צעל. ביטע טאָן אַז אַ דרך פון לענג k מיטל באזוכן פּונקט k סעלז (ניט דאַווקע באַזונדער). איר קענען ניט גיין אויס פון די גריד. אַ דרך א (פון לענג ק) איז באטראכט ווייניקער ווי אַ דרך ב (פון לענג ק) אויב נאָך מאכן די אָרדערד ליסטעס פון די וואַלועס אויף די סעלז אַז A און ב גיין דורך (לאמיר רופן זיי ל_סט און ל_סט ב), ל_סט ב איז לעקסיקאַלי ווייניקער ווי ל_סט ב, אין אנדערע ווערטער, אַ גאַנץ וועג פון לענג k אין די גריד. איר קענען אָנהייבן פון קיין צעל, און אין יעדער שריט איר קענען גיין צו קיין שכיידיק צו קיין שכיידיק צו קיין שכיידיק צו קיין טעלז, אין יעדער צעלז פון די ריס, איר קענען גיין צו קיין טויק, אין קיין וועג פון לענג פון לענג k = k, אין קיין אנדערע ווערטער, אין קיין ין, אין אַ ריס, אין אַ ריס, אין אַ ריס, אין אַ ריס, אין אַ ריס, אין אַ ריס, אין אַ ריס, אין אַ ריס, אין די ריס, אין די ריס, אין די ריס, איז ין, אין די ריס, אין די ריס, אין די ריס, אין די ריס, אין די ריס, אין די ריס, אין די ריס, אין די ריס, אין די ריס, אין די איז י = [j, י = 1 [j, י = 1], איז י = 1 [4, י = 1 [j = 1] י =\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"יעדער ווייסט פיבאָנאַצקי סיקוואַנס, עס איז שטארק געלערנט דורך מאַטעמאַטיקער אין די לעצטע פּאָר סענטשעריז. אָבער, וואָס מענטשן טאָן ניט וויסן איז טריבאָנאַצקי סיקוואַנס. טריבאָנאַצקי סיקוואַנס איז דיפיינד דורך די ריקעראַנס: tri(1) = 3 tri(n) = 1 + n / 2, אויב n איז פּער. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), אויב n איז מאָדנע. למשל: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 איר זענט געגעבן אַ ניט-נעגאַטיוו ינטייער נומער n, איר האָבן צו צוריקקומען אַ רשימה פון די ערשטער n + 1 נומערן פון די טריבאָנאַצקי סיקוואַנס. ביישפילן: tri(3) = [1, 3, 2, 8] \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"געגעבן אַ positive integer n, צוריקקומען די פּראָדוקט פון די פּאַר דידזשיץ. צוריקקומען 0 אויב אַלע דידזשיץ זענען פּער. למשל: דידזשיץ ((1) == 1 דידזשיץ ((4) == 0 דידזשיץ ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''שאַפֿן אַ פונקציע וואָס נעמט אַ שטריקל ווי ינפּוט וואָס כּולל בלויז קוואַדראַט בראַקאַץ. די פונקציע זאָל צוריקקומען אמת אויב און בלויז אויב עס איז אַ גילטיק סאַבסעקווענסע פון בראַקאַץ ווו בייַ מינדסטער איין בראַקאַץ אין די סאַבסעקווענסע איז נעסטעד. איז_נעסטעד '[[]]') â -> אמת איז_נעסטעד '[[]]]]]]]]]]]]]][[[[[[]]]]') â -> פאַלש איז_נעסטעד '[]]]]') â -> פאַלש איז_נעסטעד '[]') â -> פאַלש איז_נעסטעד '[[]]') â -> אמת איז_נעסטעד '[[]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"איר זענט געגעבן אַ רשימה פון נומערן. איר דאַרפֿן צו צוריקקומען די סומע פון סקוואַדראַט נומערן אין די געגעבן רשימה, קייַלעכיק יעדער עלעמענט אין די רשימה צו די אויבערשטער ינט (קסנומקס) ערשטער. ביישפילן: פֿאַר יסט = [1,2,3] די רעזולטאַט זאָל זיין 14 פֿאַר יסט = [1,4,9] די רעזולטאַט זאָל זיין 98 פֿאַר יסט = [1,3,5,7] די רעזולטאַט זאָל זיין 84 פֿאַר יסט = [1.4,4.2,0] די רעזולטאַט זאָל זיין 29 פֿאַר יסט = [-2.4,1,1] די רעזולטאַט זאָל זיין 6 \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''שאַפֿן אַ פונקציע וואָס ריטורנס אמת אויב די לעצטע כאַראַקטער פון אַ געגעבן שטריקל איז אַן אַלפאַבעטיקאַל כאַראַקטער און איז נישט אַ טייל פון אַ וואָרט, און פאַלש אַנדערש. באַמערקונג: \"וואָרט\" איז אַ גרופּע פון אותיות אפגעשיידט דורך פּלאַץ. ביישפילן: טשעק_יף_לאַסט_טשאַרי_איז_אַ_ליטער\"א\"עפּל פּי\") â -> פאַלש טשעק_יף_לאַסט_טשאַרי_איז_אַ_ליטער\"א\"עפּל פּי\") â -> אמת טשעק_יף_לאַסט_טשאַרי_איז_אַ_ליטער\"א\"עפּל פּי \") â -> פאַלש טשעק_יף_לאַסט_טשאַרי_איז_אַ_ליטער\"א\"עפּל פּי\") â -> פאַלש '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"שאַפֿן אַ פונקציע וואָס ריטורנס די גרעסטע אינדעקס פון אַן עלעמענט וואָס איז נישט גרעסער ווי אָדער גלייַך צו די עלעמענט גלייך פריערדיק עס. אויב קיין אַזאַ עלעמענט עקסיסטירט דעמאָלט צוריקקומען -1. די געגעבן מענגע וועט נישט אַנטהאַלטן דופּליקאַט וואַלועס. ביישפילן: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''שאַפֿן אַ פונקציע וואָס קערט אַ טופּל (אַ, ב), ווו 'אַ' איז די גרעסטע פון נעגאַטיוו ינטיידזשערז, און 'ב' איז די קלענסטער פון positive ינטיידזשערז אין אַ רשימה. אויב עס איז קיין נעגאַטיוו אָדער positive ינטיידזשערז, צוריקקומען זיי ווי ניין. ביישפילן: גרעסטע_קלענסטע_ינטיידזשערז[2, 4, 1, 3, 5, 7]) == (ניין, 1) גרעסטע_קלענסטע_ינטיידזשערז[[]] == (ניין, ניין) גרעסטע_קלענסטע_ינטיידזשערז[[0]] == (ניין, ניין) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"שאַפֿן אַ פונקציע וואָס נעמט ינטיידזשערז, פלאָאַטס, אָדער סטרינגס רעפּריזענטינג רעאַל נומערן, און ריטורנס די גרעסערע בייַטעוודיק אין זייַן געגעבן בייַטעוודיק טיפּ. צוריקקומען ניין אויב די וואַלועס זענען גלייַך. באַמערקונג: אויב אַ פאַקטיש נומער איז רעפּריזענטיד ווי אַ שטריקל, די פלאָוטינג פונט קען זיין . אָדער , compare_one(1, 2.5) â -> 2.5 compare_one(1, \"2,3\") â -> \"2,3\" compare_one(\"5,1\", \"6\") â -> \"6\" compare_one(\"1\", 1) â -> ניין \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"אָפּשאַצן צי די געגעבן נומער n קענען זיין געשריבן ווי די סומע פון פּונקט 4 positive פּער נומערן בייַשפּיל is_equal_to_sum_even ((4) == פאַלש is_equal_to_sum_even ((6) == פאַלש is_equal_to_sum_even ((8) == אמת \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"דער בראַזיליאנער פאקטאריאל ווערט דעפינירט ווי: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! וואו n > 0 למשל: >>> special_factorial(4) 288 די פונקציע וועט באקומען א אינטעדזשער אלס אינפּוט און זאל צוריקקומען די ספעציעלע פאקטאריאל פון דעם אינטעדזשער. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_דוגמא-3ל טעקסט, פאַרבייַטן אַלע ספּייסאַז אין עס מיט אַנדערסקאָרז, און אויב אַ שטריקל האט מער ווי 2 קאָנסעקוטיווע ספּייסאַז, דעמאָלט פאַרבייַטן אַלע קאָנסעקוטיווע ספּייסאַז מיט - fix_spaces(\"בייַשפּיל\") == \"בייַשפּיל\" fix_spaces(\"בייַשפּיל1\") == \"בייַשפּיל_1\" fix_spaces(\"בייַשפּיל2\") == \"_בייַשפּיל_2\" fix_spaces\" (בייַשפּיל 3\") == \"_בייַשפּיל-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"שאַפֿן אַ פונקציע וואָס נעמט אַ שטריקל וואָס רעפּריזענץ אַ טעקע ס נאָמען, און ריטורנס 'יא' אויב די טעקע ס נאָמען איז גילטיק, און ריטורנס 'ניין' אַנדערש. אַ טעקע ס נאָמען איז געהאלטן צו זיין גילטיק אויב און בלויז אויב אַלע די פאלגענדע באדינגונגען זענען באגעגנט: - עס זאָל ניט זיין מער ווי דרייַ דידזשיץ ('0'-'9') אין די טעקע ס נאָמען. - די טעקע ס נאָמען כּולל פּונקט איין פּונקט '.' - די סאַבסטראַנג איידער די פּונקט זאָל נישט זיין ליידיק, און עס הייבט מיט אַ בריוו פון די לאַטייַן אַלפאַעט ('אַ'-'ז' און 'אַ'-ז'). - די סאַבסטראַנג נאָך די פּונקט זאָל זיין איינער פון די פאלגענדע: ['טקסט', 'עקסע', 'ד'] ביישפילן: file_name_check\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"ד\"\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" די פונקציע וועט נעמען א ליסטע פון אינטעדזשערס. פאר אלע אריינגערעכנטע אין די ליסטע, די פונקציע וועט קוואדראטירן די אינטעדזשער אריינגערעכנט אויב איר אינדעקס איז א מאלפעיק פון 3 און וועט קובירן די אינטעדזשער אריינגערעכנט אויב איר אינדעקס איז א מאלפעיק פון 4 און נישט א מאלפעיק פון 3. די פונקציע וועט נישט טוישן די אריינגערעכנטע אין די ליסטע וואס זייער אינדעקסן זענען נישט א מאלפעיק פון 3 אדער 4. די פונקציע וועט דאן צוריקקומען די סומע פון אלע אריינגערעכנטע. ביישפילן: פאר lst = [1,2,3] די אויסגאוט זאל זיין 6 פאר lst = [] די אויסגאוט זאל זיין 0 פאר lst = [-1,-5,2,-1,-5] די אויסגאוט זאל זיין -126 \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"מען גיט א סטרינג וואס רעפרעזענטירט א זאץ, דער זאץ פארמאגט עטליכע ווערטער אפגעשיידט דורך א ספעיס, און מען דארף צוריקקומען א סטרינג וואס פארמאגט די ווערטער פון דער ארגינעלער זאץ, וואס זייער לענג זענען פריים נומערן, די סדר פון די ווערטער אין דער נייער סטרינג דארף זיין די זעלבע ווי דער ארגינעלער. ביישפיל1: איינפיר: זאץ = \"דאס איז א טעסט\" אויספיר: \"איז\" ביישפיל2: איינפיר: זאץ = \"לאזט גיין פאר שווימען\" אויספיר: \"גיין פאר\" באגרעניצונגען: * 1 <= len(סענטענס) <= 100 * זאץ פארמאגט בלויז אותיות \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"דיין אַרבעט איז צו ימפּלאַמענטירן אַ פונקציע וואָס וועט פאַרפּשוטן די אויסדרוק x * n. די פונקציע ריטורנס אמת אויב x * n יוואַליוייץ צו אַ גאַנץ נומער און פאַלש אַנדערש. ביידע קסנומקס און n, זענען שטריקל רעפּראַזענץ פון אַ בראָך, און האָבן די פאלגענדע פֿאָרמאַט, <נאַמעראַטאָר> / <דענאָמינאַטאָר> ווו ביידע נומעמאַטאָר און נומעמאַטאָר זענען positive גאַנץ נומערן. איר קענען יבערנעמען אַז קסנומקס, און n זענען גילטיק בראָכן, און טאָן ניט האָבן נול ווי נומעמאַטאָר. פאַרפּשוטן \" 1 / 5\", \"5 / 1\") = אמת פאַרפּשוטן \" 1/ 6\", \"2 / 1\") = פאַלש פאַרפּשוטן \" 7 / 10 \", \"10 / 2\") = פאַלש \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"שרײַבן אַ פֿונקציע וואָס סאָרטירט די געגעבןע ליסטע פון אינטעדזשערס אין אַסינדענט סדר לויט די סאַמע פון זייערע ציפֿערן. באַמערקונג: אויב עס זענען עטלעכע זאכן מיט ענלעכע סאַמע פון זייערע ציפֿערן, סדר זיי באזירט אויף זייער אינדעקס אין דער אָריגינעלער ליסטע. למשל: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"שרײַבן אַ פֿונקציע וואָס נעמט אַ מענגע פון נומערן ווי אַרייַנפיר און צוריקגעגעבן די נומער פון עלעמענטן אין דער מענגע וואָס זענען גרעסער ווי 10 און ביידע ערשטער און לעצטע דידזשיץ פון אַ נומער זענען פּאַרד (1, 3, 5, 7, 9). למשל: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"איר זענט געגעבן אַ positive integer n. איר האָבן צו שאַפֿן אַ integer אַרייַנשייד אַ פון לענג n. פֿאַר יעדער i (1 ‰¤ i ‰¤ n), די ווערט פון a[i] = i * i - i + 1. צוריקקומען די נומער פון טריפּאַלז (a[i], a[j], a[k]) פון אַ ווו i < j < k, און a[i] + a[j] + a[k] איז אַ קייפל פון 3. בייַשפּיל: ינפּוט: n = 5 רעזולטאַט: 1 דערקלערונג: אַ = [1, 3, 7, 13, 21] די בלויז גילטיק טריפּאַל איז (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''אין אונדזער זון סיסטעם זענען אַכט פּלאַנאַץ: די נאָענטסטע צו די זון איז מערקיורי, די ווייַטער איינער איז ווענוס, דעמאָלט ערד, מאַרס, דזשיפּיטער, סאַטורן, אוראַנוס, נאַפּטונוס. שרייַבן אַ פונקציע וואָס נעמט צוויי פּלאַנעט נעמען ווי סטרינגס פּלאַנעט1 און פּלאַנעט2. די פונקציע זאָל צוריקקומען אַ טופּל וואָס כּולל אַלע פּלאַנאַץ וועמענס אָרביטעס זענען ליגן צווישן די אָרביט פון פּלאַנעט1 און די אָרביט פון פּלאַנעט2, סאָרטעד דורך די פּראַקסיסיטי צו די זון. די פונקציע זאָל צוריקקומען אַ ליידיק טופּל אויב פּלאַנעט1 אָדער פּלאַנעט2 זענען נישט ריכטיק פּלאַנעט נעמען. ביישפּילן bf \" י י \" יופּיטער \", \" נאַפּטונע \") ==> (\" סאַטורן \", \" יוראַנוס \") bf \" י \" י \" , \" ערד \", \" מאַרס \", \" דזשיפּיטער \", \" סנ \") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"שרײַב אַ פֿונקציע וואָס נעמט אַ רשימה פון סטרינגס ווי אַ פּאַראַמעטער, דיליץ די סטרינגס וואָס האָבן פּאַרד לענג פון עס, און ריטורנס די ריזאַלטיד רשימה מיט אַ סאָרטעד סדר, די רשימה איז שטענדיק אַ רשימה פון סטרינגס און קיינמאָל אַ מענגע פון נומערן, און עס קען אַנטהאַלטן דופּליקאַץ. די סדר פון די רשימה זאָל זיין אַסכענדינג דורך לענג פון יעדער וואָרט, און איר זאָל צוריקקומען די רשימה סאָרטעד דורך דעם הערשן. אויב צוויי ווערטער האָבן די זעלבע לענג, סאָרט די רשימה אַלפאַבעטיש. די פונקציע זאָל צוריקקומען אַ רשימה פון סטרינגס אין סאָרטעד סדר. איר קען יבערנעמען אַז אַלע ווערטער וועט האָבן די זעלבע לענג. למשל: אַסערט רשימה_סאָרט[\"aa\", \"אַ\", \"aaa\"]) => אַסערט רשימה_סאָרט[\"ab\", \"אַ\", \"aaa\", \"cd\" => \"cd ])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"א פּשוטע פּראָגראַם וואָס זאָל צוריקקומען די ווערט פון x אויב n איז אַ פּריים נומער און זאָל צוריקקומען די ווערט פון y אַנדערש. ביישפילן: פֿאַר x_or_y(7, 34, 12) == 34 פֿאַר x_or_y(15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''געגעבן אַ רשימה פון נומערן, צוריקקומען די סומע פון סקוואַדראַץ פון די נומערן אין דער רשימה וואָס זענען פּאַרד. איגנאָרירן נומערן וואָס זענען נעגאַטיוו אָדער ניט ינטיידזשערז. טאָפּל_די_שיידן (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 טאָפּל_די_שיידן (([-1, -2, 0]) == 0 טאָפּל_די_שיידן (([9, -2]) == 81 טאָפּל_די_שיידן (([0]) == 0 אויב די ינפּוט רשימה איז ליידיק, צוריקקומען 0. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"איך מיין אז מיר אלע געדענקען דעם געפיל ווען מען ווייסט צום סוף די רעזולטאט פון א לאנג ערווארטעטע געשעעניש. די געפילן און געדאנקען וואס מען האט אין יענע מינוט זענען זיכער ווערט צו באמערקן און פארגלייכן. דיין אויפגאבע איז צו באשטימען אויב א מענטש האט ריכטיג געכאפט די רעזולטאטן פון א צאל פון שידוכים. מען גיט דיר צוויי ערייען פון סקארס און געסעס פון גלייכע לענג, וואו יעדער אינדעקס ווייזט א שידוך. צוריקקומען אן עריי פון די זעלבע לענג וואס צייגט ווי ווייט אוועק יעדער געסעס איז געווען. אויב זיי האבן ריכטיג געכאפט, איז די ווערט 0, און אויב נישט, איז די ווערט די אבסורוטע חילוק צווישן די געסעס און די סקאר. למשל:[[1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare[[0,5,0,4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"איר וועט באַקומען די נאָמען פון אַ קלאַס (אַ שטריקל) און אַ רשימה פון עקסטענשאַנז. די עקסטענשאַנז זענען צו זיין געניצט צו לאָדן נאָך קלאסן צו די קלאַס. די שטאַרקייַט פון די עקסטענשאַנז איז ווי גייט: זאל קאַפּ זייַן די נומער פון די הויפּטקאַסער אותיות אין די עקסטענשאַנז נאָמען, און זאל סם זייַן די נומער פון קליינע אותיות אין די עקסטענשאַנז נאָמען, די שטאַרקייַט איז געגעבן דורך די בראָך קאַפּ - סם. איר זאָל געפֿינען די שטאַרקאַסט עקסטענשאַנז און צוריקקומען אַ שטריקל אין דעם פֿאָרמאַט: ClassName.StrongestExtensionName. אויב עס זענען צוויי אָדער מער עקסטענשאַנז מיט די זעלבע שטאַרקייַט, איר זאָל קלייַבן די איינער וואָס קומט ערשטער אין די רשימה. למשל, אויב איר זענען געגעבן \"סלייסיז\" ווי די קלאַס און אַ רשימה פון די עקסטענשאַנז: ['SEviRNGSliCes', 'Cheese', 'StuF'] דעמאָלט איר זאָל צוריקקומען 'SLICENS.SEviRNGSliCes' זינט 'SEviRNGCes' איז די שטאַרקאַסט בריוואַטער פון די עקסטענשאַנז, די שטאַרקייַט איז געגעבן דורך די בראָקייַט פון די פראַקס CAP - SM. איר זאָל געפֿינען די סטריקט די סטריקט די סטריקט די סטריקט פון די סטריקט פון די סטריקס און צוריקקומען אַ סטריקט די סטריקט פון די סטריקט פון די סטריקט אין די סטריקט פון די סטריקט פון די סטריקט.\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"איר זענט געגעבן 2 ווערטער. איר דאַרפֿן צו צוריקקומען אמת אויב די רגע וואָרט אָדער קיין פון זייַן ראָוטיישאַנז איז אַ סאַבסטראַנג אין דער ערשטער וואָרט cycpattern_check(\"abcd\",\"abd\") => פאַלש cycpattern_check(\"העלאָ\",\"על\") => אמת cycpattern_check(\"וואַסאַפּ\",\"פּסוס\") => פאַלש cycpattern_check\"abab\",\"baa\") => אמת cycpattern_check(\"עפע\",\"עעף\") => פאַלש cycpattern_check\"(שימענס\",\"סימענ\") => אמת \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"געגעבן אַ גאַנץ נומער. צוריקקומען אַ טופּל אַז האט די נומער פון פּאַרע און פּאַרע דידזשיץ ריספּעקטיוולי. בייַשפּיל: אפילו_אָד_קאָונט ((-12) ==> (1, 1) אפילו_אָד_קאָונט ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"געגעבן אַ positive גאַנץ נומער, באַקומען זייַן רוימישע נומעראַל עקוויוואַלענט ווי אַ שטריקל, און צוריקקומען עס אין קלענערער.\"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''געגעבן די לענג פון די דריי זייטן פון א דרייקעלע. צוריקקומען אמת אויב די דריי זייטן פארמאגן א ריכט-ענגל דרייקעלע, פאַלש אַנדערש. א ריכט-ענגל דרייקעלע איז א דרייקעלע אין וועלכע איין ווינקל איז ריכט ווינקל אָדער 90 גראַד. ביישפּיל: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"שרײַב אַ פֿונקציע וואָס נעמט אַ רשימה פון שטריכן. די רשימה כּולל פאַרשידענע ווערטער. צוריקקומען דעם וואָרט מיט מאַקסימום נומער פון יינציק אותיות. אויב קייפל שטריכן האָבן מאַקסימום נומער פון יינציק אותיות, צוריקקומען די וואָס קומט ערשטער אין לעקסיקאָגראַפיקאַל סדר. find_max (([\"נעם\", \"פון\", \"שטריך\"]) == \"שטריך\" find_max (([\"נעם\", \"ענעם\", \"שפּיל\"]) == \"ענעם\" find_max (([\"איייייייייייי\", \"בב\" , \"ק\"]) == \"\" ייאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַאַ\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"איר זענט אַ הונגעריק ראַבאַט, און איר האָבן שוין געגעסן אַ זיכער נומער פון קעראַץ, אָבער איצט איר דאַרפֿן צו עסן מער קעראַץ צו פאַרענדיקן די טאָג ס מילז. איר זאָל צוריקקומען אַ מענגע פון [ גאַנץ נומער פון געגעסן קעראַץ נאָך דיין מילז, די נומער פון קעראַץ לינקס נאָך דיין מילז ] אויב עס זענען נישט גענוג רוען קעראַץ, איר וועט עסן אַלע רוען קעראַץ, אָבער וועט נאָך זיין הונגעריק. בייַשפּיל: * עסן ((5, 6, 10) -> [11, 4] * עסן ((4, 8, 9) -> [12, 1] * עסן ((1, 10, 10) -> [11, 0] * עסן ((2, 11, 5) -> [7, 0] וועריאַבאַלז: @ נומער: ינטעגער די נומער פון קעראַץ אַז איר האָבן געגעסן. @ נויט: ינטעגער די נומער פון קעראַץ אַז איר דאַרפֿן צו עסן. @ רעשט: ינטעגער די נומער פון רוען קעראַץ אַז איר דאַרפֿן צו עסן. @ רעשט: ינטעגער די נומער פון רוען קעראַץ אין לאַג: * קנע = 0 = <= <= 1000 * <= 0 = <= 1000 *\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"די ערשטע ליסטע האט יסודותדיקע אלגעברע אפעראציעס, און די צווייטע ליסטע איז א ליסטע פון אינטעדזשערס. ניצט די צוויי געגעבן ליסטע צו בויען די אלגעברע אויסדרוק און צוריקקומען די אפוואל פון דעם אויסדרוק. די יסודותדיקע אלגעברע אפעראציעס: צולייגן (+) אראפנעמען (-)) מאלטיפייען (*) פלאר דיוויזשן (//) עקספאנענטאציע (**) ביישפיל: אפעראטאר['+', '*', '-'] עריי = [2, 3, 4, 5] רעזולטאט = 2 + 3 * 4 - 5 => רעזולטאט = 9 נאט: די לענג פון ליסטע פון אפעראטאר איז גלייך צו די לענג פון די אפעראנט ליסטע מינוס איינס. אפעראנט איז א ליסטע פון נישט-נעגאַטיווע אינטעדזשערס. אפעראטאר האט כאטשיג איין אפעראטאר ליסטע, און אפעראנט ליסטע האט כאטשיג צוויי אפעראנטן. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"אויב s[i] איז א אות, זאל מען צוריקדרייען די קאסע פון נידעריקער צו אויבערשטער אדער פארקערט, און אויב נישט זאל מען עס לאזן ווי עס איז. אויב די שטריקל אנטהאלט נישט קיין אותיות, זאל מען צוריקדרייען די שטריקל. די פונקציע זאל צוריקקומען די ריזאלטעד שטריקל. א משל סאלווען (((\"1234\") = \"4321\" סאלווען (((\"ab\") = \"AB\" סאלווען (((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"געגעבן אַ שטריקל 'טעקסט', צוריקקומען זייַן md5 האַש עקוויוואַלענט שטריקל. אויב 'טעקסט' איז אַ ליידיק שטריקל, צוריקקומען קיין. >>> string_to_md5('העלא וועלט') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "ydd_Hebr",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"געגעבן צוויי positive ינטאַדזשערז אַ און ב, צוריקקומען די אַפֿילו די דידזשיץ צווישן אַ און ב, אין אַסיענדינג סדר. פֿאַר בייַשפּיל: generate_integers(2, 8) => [2, 4, 6, 8] generate_integers(8, 2) => [2, 4, 6, 8] generate_integers(10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]