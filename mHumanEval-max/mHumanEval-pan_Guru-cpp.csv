task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਦਿੱਤੇ ਗਏ ਨੰਬਰਾਂ ਦੇ ਵੈਕਟਰ ਵਿੱਚ, ਕੋਈ ਦੋ ਨੰਬਰ ਦਿੱਤੇ ਗਏ ਥ੍ਰੈਸ਼ਹੋਲਡ ਤੋਂ ਇਕ ਦੂਜੇ ਦੇ ਨੇੜੇ ਹਨ. >>> has_close_elements{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}}{}{}{}{}}{}{}}{}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}}{}}{}}}{}}{}}}{}}{}}{}}{}}{}}}{}}}{}}{}}}{}}}{}}}}{}}}}}{}}{}}}}{}}}{}}}}{}}}}}{}}}}{}}}}{}}}{}}}}}}}{}}}}{}}}}}{}}}}}}}{}}}}}{}}}}}}}}}}{}}}{}}}}}}}{}}}}}}{}}}}{}}}}}}}{}}}}}}{}}}}{}}}}}}}{}}}{}}}}}}}}}}}{}}{}}}}}}}}}{}}}}}{}}}}}}
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਸ ਫੰਕਸ਼ਨ ਲਈ ਇੰਪੁੱਟ ਇੱਕ ਸਤਰ ਹੈ ਜਿਸ ਵਿੱਚ ਨੇਸਟਡ ਬਰੈਂਚਜ਼ ਦੇ ਕਈ ਸਮੂਹ ਹਨ. ਤੁਹਾਡਾ ਟੀਚਾ ਉਹਨਾਂ ਸਮੂਹ ਨੂੰ ਵੱਖਰੇ ਸਤਰਾਂ ਵਿੱਚ ਵੱਖ ਕਰਨਾ ਹੈ ਅਤੇ ਉਹਨਾਂ ਦੇ ਵੈਕਟਰ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਹੈ. ਵੱਖਰੇ ਸਮੂਹ ਸੰਤੁਲਿਤ ਹਨ (ਹਰੇਕ ਖੁੱਲ੍ਹੇ ਬਰੈਕਟ ਨੂੰ ਸਹੀ ਤਰ੍ਹਾਂ ਬੰਦ ਕੀਤਾ ਜਾਂਦਾ ਹੈ) ਅਤੇ ਇਕ ਦੂਜੇ ਦੇ ਅੰਦਰ ਨਹੀਂ ਰੱਖਿਆ ਜਾਂਦਾ ਇੰਪੁੱਟ ਸਤਰ ਵਿੱਚ ਕਿਸੇ ਵੀ ਸਪੇਸ ਨੂੰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ. >>> separate_paren_groups(""( ) (() (( ) ))))) (std::vector<std::string>({(std::string) "")"", ((((())"", (std::string) ""((())))))
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਨੰਬਰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਨੂੰ ਪੂਰਨ ਅੰਕ ਦੇ ਹਿੱਸੇ (ਦਿੱਤੇ ਗਏ ਨੰਬਰ ਤੋਂ ਛੋਟਾ ਵੱਡਾ ਪੂਰਨ ਅੰਕ) ਅਤੇ ਦਸ਼ਮਲਵ (ਖਾਲੀ ਹਿੱਸਾ ਹਮੇਸ਼ਾ 1 ਤੋਂ ਛੋਟਾ ਹੁੰਦਾ ਹੈ) ਵਿੱਚ ਵੰਡਿਆ ਜਾ ਸਕਦਾ ਹੈ. ਨੰਬਰ ਦੇ ਦਸ਼ਮਲਵ ਹਿੱਸੇ ਨੂੰ ਵਾਪਸ ਕਰੋ. >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਬੈਂਕ ਖਾਤੇ ਤੇ ਜਮ੍ਹਾਂ ਅਤੇ ਕਢਵਾਉਣ ਦੀਆਂ ਕਾਰਵਾਈਆਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ ਜੋ ਜ਼ੀਰੋ ਸੰਤੁਲਨ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਪਤਾ ਲਗਾਉਣਾ ਹੈ ਕਿ ਕਿਸੇ ਵੀ ਸਮੇਂ ਖਾਤੇ ਦਾ ਸੰਤੁਲਨ ਜ਼ੀਰੋ ਤੋਂ ਹੇਠਾਂ ਆ ਜਾਂਦਾ ਹੈ, ਅਤੇ ਉਸ ਸਮੇਂ ਫੰਕਸ਼ਨ ਨੂੰ ਸਹੀ ਵਾਪਸ ਆਉਣਾ ਚਾਹੀਦਾ ਹੈ. ਨਹੀਂ ਤਾਂ ਇਹ ਗਲਤ ਵਾਪਸ ਆਉਣਾ ਚਾਹੀਦਾ ਹੈ. >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਨਪੁਟ ਨੰਬਰਾਂ ਦੇ ਦਿੱਤੇ ਵੈਕਟਰ ਲਈ, ਇਸ ਡੇਟਾ ਸੈੱਟ ਦੇ ਮੱਧ ਦੇ ਆਲੇ ਦੁਆਲੇ ਮੱਧਮ ਅਸਲੀ ਭਟਕਣ ਦੀ ਗਣਨਾ ਕਰੋ. ਮੱਧਮ ਅਸਲੀ ਭਟਕਣ ਹਰ ਤੱਤ ਅਤੇ ਇੱਕ ਕੇਂਦਰ ਬਿੰਦੂ (ਇਸ ਕੇਸ ਵਿੱਚ ਮੱਧਮ) ਦੇ ਵਿਚਕਾਰ ਔਸਤ ਅਸਲੀ ਅੰਤਰ ਹੈਃ MAD = ਔਸਤ ∙ x - x_mean ∙ >>> mean_absolute_deviation (((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਨਪੁਟ ਵੈਕਟਰ ਦੇ ਹਰ ਦੋ ਲਗਾਤਾਰ ਤੱਤਾਂ ਦੇ ਵਿਚਕਾਰ ਇੱਕ ਨੰਬਰ 'ਡਿਲਿਮੀਟਰ' ਪਾਓ `numbers' >>> intersperse((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1, (long) 2, (long) 3}), (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਸ ਫੰਕਸ਼ਨ ਲਈ ਇਨਪੁਟ ਇੱਕ ਸਤਰ ਹੈ ਜੋ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਬਰੇਂਟੇਜ਼ ਲਈ ਮਲਟੀਪਲ ਗਰੁੱਪਾਂ ਦੀ ਨੁਮਾਇੰਦਗੀ ਕਰਦੀ ਹੈ। ਹਰੇਕ ਸਮੂਹ ਲਈ, ਬਰੇਂਟੇਜ਼ ਦੇ ਸਭ ਤੋਂ ਡੂੰਘੇ ਪੱਧਰ ਦੇ ਆਉਟਪੁੱਟ ਨੂੰ ਆਉਟਪੁੱਟ ਕਰੋ. ਉਦਾਹਰਣ ਵਜੋਂ (())) ਦੇ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਪੱਧਰ ਹਨ ਜਦੋਂ ਕਿ ((())) ਦੇ ਤਿੰਨ ਹਨ. >>> ਪਾਰਸ_ਨੈਸਟਡ_ਪਾਰਨਸ (((""(()) ((())) () ((()))))))) (std:: vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਤਰਾਂ ਦੇ ਇਨਪੁਟ ਵੈਕਟਰ ਨੂੰ ਸਿਰਫ ਉਹਨਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ ਜਿਨ੍ਹਾਂ ਵਿੱਚ ਦਿੱਤੀ ਗਈ ਸਬਸਟ੍ਰਿੰਗ >>> filter_by_substring((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_substring(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""})), (""a"") (std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਲਈ, ਇੱਕ ਜੋੜ ਅਤੇ ਇੱਕ ਵੈਕਟਰ ਵਿੱਚ ਸਾਰੇ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਉਤਪਾਦ ਤੋਂ ਬਣਿਆ ਇੱਕ ਟੁਪਲ ਵਾਪਸ ਕਰੋ. ਖਾਲੀ ਜੋੜ 0 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਅਤੇ ਖਾਲੀ ਉਤਪਾਦ 1 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ. >>> sum_product((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਤੋਂ, ਕ੍ਰਮ ਵਿੱਚ ਦਿੱਤੇ ਗਏ ਪਲ ਤੱਕ ਪਾਇਆ ਗਿਆ ਰੋਲਿੰਗ ਅਧਿਕਤਮ ਤੱਤ ਦਾ ਇੱਕ ਵੈਕਟਰ ਤਿਆਰ ਕਰੋ. >>> ਰੋਲਿੰਗ_ਮੈਕਸ (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ)) (ਮੈਕਸ)) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ)) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ)) (ਮੈਕਸ)) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ) (ਮੈਕਸ))))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਭ ਤੋਂ ਛੋਟਾ ਪਾਲੀਂਡਰੋਮ ਲੱਭੋ ਜੋ ਸਪਲਾਈ ਕੀਤੀ ਸਤਰ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ. ਐਲਗੋਰਿਦਮ ਵਿਚਾਰ ਸਧਾਰਨ ਹੈਃ - ਸਪਲਾਈ ਕੀਤੀ ਸਤਰ ਦਾ ਸਭ ਤੋਂ ਲੰਬਾ ਪੋਸਟਫਿਕਸ ਲੱਭੋ ਜੋ ਇਕ ਪਾਲੀਂਡਰੋਮ ਹੈ. - ਸਤਰ ਦੇ ਅੰਤ ਵਿਚ ਇਕ ਸਤਰ ਪ੍ਰੀਫਿਕਸ ਦੇ ਉਲਟ ਜੋੜੋ ਜੋ ਪਾਲੀਂਡਰੋਮਿਕ ਪਿਛੇਤਰ ਤੋਂ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ. >>> make_palindrome ((("""")) ("""") >>> make_palindrome (((""cat"")) (""catac"") >>> make_palindrome (((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੰਪੁੱਟ ਦੋ ਸਤਰਾਂ ਹਨ a ਅਤੇ b ਸਿਰਫ 1 ਅਤੇ 0 ਤੋਂ ਬਣੀਆਂ ਹਨ. ਇਹਨਾਂ ਇੰਪੁੱਟਾਂ ਤੇ ਬਾਈਨਰੀ XOR ਕਰੋ ਅਤੇ ਨਤੀਜਾ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵੀ ਵਾਪਸ ਕਰੋ. >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਤਰਾਂ ਦੇ ਵੈਕਟਰ ਤੋਂ ਬਾਹਰ, ਸਭ ਤੋਂ ਲੰਬਾ ਵਾਪਸ ਕਰੋ. ਉਸੇ ਲੰਬਾਈ ਦੇ ਕਈ ਸਤਰਾਂ ਦੇ ਮਾਮਲੇ ਵਿੱਚ ਪਹਿਲਾ ਵਾਪਸ ਕਰੋ. ਇਨਪੁਟ ਵੈਕਟਰ ਖਾਲੀ ਹੋਣ ਦੀ ਸਥਿਤੀ ਵਿੱਚ ਕੋਈ ਨਹੀਂ ਵਾਪਿਸ ਕਰੋ. >>> longest((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest(((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਦੋ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦੇ ਸਭ ਤੋਂ ਵੱਡੇ ਸਾਂਝੇ ਵਿਭਾਜਕ ਨੂੰ ਵਾਪਸ ਕਰੋ >>> ਸਭ ਤੋਂ ਵੱਡਾ_ਆਮ_ਭਾਜਕ (((3), (5)) (1) >>> ਸਭ ਤੋਂ ਵੱਡਾ_ਆਮ_ਭਾਜਕ (((25), (15)) (5)
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੰਪੁੱਟ ਸਤਰ ਦੇ ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਲੰਬੇ ਤੱਕ ਸਾਰੇ ਪ੍ਰੀਫਿਕਸਸ ਦਾ ਵਾਪਸੀ ਵੈਕਟਰ >>> all_prefixes (((""abc"")) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ 0 ਤੋਂ ਲੈ ਕੇ n ਤੱਕ ਦੇ ਸਪੇਸ-ਸੀਮਿਤ ਨੰਬਰ ਸ਼ਾਮਲ ਹਨ. >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਪਤਾ ਕਰੋ ਕਿ ਕਿੰਨੇ ਵੱਖਰੇ ਅੱਖਰ (ਕੋਈ ਵੀ ਕੇਸ ਹੋਵੇ) ਇਸ ਵਿੱਚ >>> count_distinct_characters (((""xyzXYZ"")) (3) >>> count_distinct_characters (((""ਜੈਰੀ"")) (4) ਹਨ
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਸ ਫੰਕਸ਼ਨ ਲਈ ਇੰਪੁੱਟ ਇੱਕ ASCII ਫਾਰਮੈਟ ਵਿੱਚ ਸੰਗੀਤ ਨੋਟਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਸਤਰ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਹੈ ਕਿ ਕਿੰਨੇ ਬੀਟ ਨਾਲ ਸੰਬੰਧਿਤ ਪੂਰਨ ਅੰਕ ਦੇ ਸਤਰ ਵੈਕਟਰ ਨੂੰ ਪਾਰਸ ਕਰਨਾ ਹੈ. ਇੱਥੇ ਇੱਕ ਦਲੀਲ ਹੈਃ 'o' ਨੋਟ, ਪਿਛਲੇ ਚਾਰ ਬੀਟ 'o, 'ਤੇ - ਅੱਧਾ ਨੋਟ, ਪਿਛਲੇ ਦੋ ਬੀਟ' ਤੇ - quater ਨੋਟ, ਪਿਛਲੇ ਇੱਕ ਬੀਟ >>> parse_music. ((""o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪਤਾ ਕਰੋ ਕਿ ਅਸਲ ਸਤਰ ਵਿੱਚ ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਬਸਟ੍ਰਿੰਗ ਕਿੰਨੀ ਵਾਰ ਮਿਲ ਸਕਦੀ ਹੈ। ਓਵਰਲੈਪਿੰਗ ਕੇਸਾਂ ਦੀ ਗਿਣਤੀ ਕਰੋ। >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"")) (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੰਪੁੱਟ 'ਜ਼ੀਰੋ' ਤੋਂ 'ਨੌ' ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦੀ ਇੱਕ ਸਪੇਸ-ਸੀਮਿਤ ਸਤਰ ਹੈ। ਵੈਧ ਚੋਣਾਂ ਹਨ 'ਜ਼ੀਰੋ', 'ਇੱਕ', 'ਦੋ', 'ਤਿੰਨ', 'ਚਾਰ', 'ਪੰਜ', 'ਛੇ', 'ਸੱਤ', 'ਅੱਠ' ਅਤੇ 'ਨੌ'। ਸਤਰ ਨੂੰ ਛੋਟੇ ਤੋਂ ਵੱਡੇ ਤੱਕ ਕ੍ਰਮਬੱਧ ਨੰਬਰਾਂ ਨਾਲ ਵਾਪਸ ਕਰੋ >>> sort_numbers((""three one five"")) (""one three five"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਨੰਬਰਾਂ ਦੇ ਸਪਲਾਈ ਕੀਤੇ ਵੈਕਟਰ (ਘੱਟੋ ਘੱਟ ਦੋ ਦੀ ਲੰਬਾਈ) ਤੋਂ ਦੋ ਦੀ ਚੋਣ ਕਰੋ ਅਤੇ ਵਾਪਸ ਕਰੋ ਜੋ ਇਕ ਦੂਜੇ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ ਹਨ ਅਤੇ ਉਹਨਾਂ ਨੂੰ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰੋ (ਛੋਟੀ ਗਿਣਤੀ, ਵੱਡੀ ਗਿਣਤੀ). >>> find_closest_elements (((std:: vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.2f}))) (std::make_tuple (((2.0f, 2.2f)) >>> find_closest_elements (((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f)) (std::vector<float>, (float) 2.0f))
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਨੰਬਰਾਂ ਦੇ ਦਿੱਤੇ ਵੈਕਟਰ (ਘੱਟੋ ਘੱਟ ਦੋ ਤੱਤਾਂ ਦੇ), ਉਸ ਵੈਕਟਰ ਨੂੰ ਇੱਕ ਲੀਨੀਅਰ ਟ੍ਰਾਂਸਫਾਰਮ ਲਾਗੂ ਕਰੋ, ਤਾਂ ਜੋ ਸਭ ਤੋਂ ਛੋਟੀ ਸੰਖਿਆ 0 ਬਣ ਜਾਵੇ ਅਤੇ ਸਭ ਤੋਂ ਵੱਡੀ 1 ਬਣ ਜਾਵੇ >>> rescale_to_unit (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f}))) (std::vector<float>({(float) 0.0f, (float) 0.25f, (float) 0.5f, (float) 0.75f, (float) 1.0f}))
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਫਿਲਟਰ ਕਿਸੇ ਵੀ cppthon ਮੁੱਲਾਂ ਦੇ ਦਿੱਤੇ ਵੈਕਟਰ ਨੂੰ ਸਿਰਫ ਪੂਰਨ ਅੰਕ ਲਈ >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਦਿੱਤੀ ਗਈ ਸਤਰ ਦੀ ਲੰਬਾਈ ਨੂੰ ਵਾਪਸ ਕਰੋ >>> string_length(("""")) (0) >>> string_length((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਦਿੱਤੇ ਗਏ ਨੰਬਰ n ਲਈ, ਸਭ ਤੋਂ ਵੱਡੀ ਸੰਖਿਆ ਲੱਭੋ ਜੋ n ਨੂੰ ਬਰਾਬਰ ਵੰਡਦੀ ਹੈ, n >>> ਸਭ ਤੋਂ ਵੱਡਾ_ਡਿਵਾਈਜ਼ਰ ਤੋਂ ਛੋਟਾ ਹੈ (((15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਭ ਤੋਂ ਛੋਟੀ ਤੋਂ ਵੱਡੀ ਕ੍ਰਮ ਵਿੱਚ ਦਿੱਤੇ ਗਏ ਪੂਰਨ ਅੰਕ ਦੇ ਪ੍ਰਾਇਮ ਫੈਕਟਰਾਂ ਦਾ ਵਾਪਸੀ ਵੈਕਟਰ. ਹਰੇਕ ਫੈਕਟਰ ਨੂੰ ਕਈ ਵਾਰ ਫੈਕਟਰਿੰਗ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਕਿ ਫੈਕਟਰਾਈਜ਼ੇਸ਼ਨ ਵਿੱਚ ਕਿੰਨੀ ਵਾਰ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ. ਇਨਪੁਟ ਨੰਬਰ ਸਾਰੇ ਫੈਕਟਰਾਂ ਦੇ ਉਤਪਾਦ ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ >>> ਫੈਕਟਰਰਾਈਜ਼ ਕਰੋ (((8)) (std:: vector<long>({(long) 2, (long) 2, (long) 2})) >>> ਫੈਕਟਰਰਾਈਜ਼ ਕਰੋ (((25)) (std:: vector<long>({(long) 5, (long) 5})) >>> ਫੈਕਟਰਰਾਈਜ਼ ਕਰੋ (((((70)) (std:: vector<long>({(long) 2, (long) 5, (long) 7}))
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਵੈਕਟਰ ਤੋਂ, ਸਾਰੇ ਤੱਤ ਹਟਾਓ ਜੋ ਇਕ ਤੋਂ ਵੱਧ ਵਾਰ ਵਾਪਰਦੇ ਹਨ. ਤੱਤਾਂ ਦਾ ਕ੍ਰਮ ਇੰਪੁੱਟ ਦੇ ਸਮਾਨ ਛੱਡੋ. >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਤਰ ਲਈ, ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਅਤੇ ਵੱਡੇ ਅੱਖਰਾਂ ਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਬਦਲ ਦਿਓ. >>> flip_case (((""Hello"")) (""HELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਤਰਾਂ ਦੇ ਵੈਕਟਰ ਨੂੰ ਇੱਕ ਸਤਰ ਵਿੱਚ ਜੋੜੋ >>> concatenate((std::vector<std::string>())) ("""") >>> concatenate((std::vector<std::string>({(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਤਰਾਂ ਦੇ ਇਨਪੁਟ ਵੈਕਟਰ ਨੂੰ ਸਿਰਫ ਉਹਨਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ ਜੋ ਇੱਕ ਦਿੱਤੇ ਗਏ ਪ੍ਰੀਫਿਕਸ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੇ ਹਨ. >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਿਰਫ ਸਕਾਰਾਤਮਕ ਨੰਬਰਾਂ ਨੂੰ ਵੈਕਟਰ ਵਿੱਚ ਵਾਪਸ ਕਰੋ. >>> get_positive((std::vector<long>({long)-1, (long) 2, (long)-4, (long) 4, (long) 5, (long) 6}))) (std::vector<long>({long) 2, (long) 5, (long) 6})) >>> get_positive((std::vector<long>({(long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 3, (long) 9, (long) 123, (long) 1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਜੇਕਰ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ ਪ੍ਰਾਇਮ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਿਸ ਕਰੋ, ਅਤੇ ਹੋਰ ਗਲਤ. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1)) (false)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਵੈਕਟਰ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਵੈਕਟਰ l' ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿਵੇਂ ਕਿ l' ਇੰਡੈਕਸ ਵਿੱਚ l ਦੇ ਸਮਾਨ ਹੈ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਿਆ ਨਹੀਂ ਜਾ ਸਕਦਾ, ਜਦੋਂ ਕਿ ਇੰਡੈਕਸ ਵਿੱਚ ਇਸਦੇ ਮੁੱਲ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਿਆ ਜਾ ਸਕਦਾ ਹੈ, ਉਹ l ਦੇ ਅਨੁਸਾਰੀ ਇੰਡੈਕਸ ਦੇ ਮੁੱਲ ਦੇ ਬਰਾਬਰ ਹਨ, ਪਰ ਕ੍ਰਮਬੱਧ ਹਨ. >>> sort_third((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long>{(long) 2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5})
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਵੈਕਟਰ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਵਿਲੱਖਣ ਤੱਤ ਵਾਪਸ ਕਰੋ >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਵੈਕਟਰ ਵਿੱਚ ਅਧਿਕਤਮ ਤੱਤ ਵਾਪਸ ਕਰੋ. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਅੰਕ 7 ਦੀ ਗਿਣਤੀ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ 11 ਜਾਂ 13 ਨਾਲ ਵੰਡਣ ਵਾਲੇ n ਤੋਂ ਘੱਟ ਪੂਰਨ ਅੰਕ ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਵੈਕਟਰ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਵੈਕਟਰ l' ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿਵੇਂ ਕਿ l' ਅਨਿਯਮਿਤ ਸੂਚਕਾਂਕ ਵਿੱਚ l ਦੇ ਸਮਾਨ ਹੈ, ਜਦੋਂ ਕਿ ਇਸ ਦੇ ਮੁੱਲ ਵੀ ਇੰਡੈਕਸ ਤੇ l ਦੇ ਵੀ ਇੰਡੈਕਸ ਦੇ ਮੁੱਲ ਦੇ ਬਰਾਬਰ ਹੁੰਦੇ ਹਨ, ਪਰ ਕ੍ਰਮਬੱਧ ਹੁੰਦੇ ਹਨ. >>> sort_even: vector<long>{(long) 1, (long) 2, (long) 3}))) (std: vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even: vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std: vector<(long>{(long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib n-th ਨੰਬਰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਕਿ ਇੱਕ ਫਿਬੋਨੈਚੀ ਨੰਬਰ ਹੈ ਅਤੇ ਇਹ ਵੀ ਪ੍ਰਾਇਮਰੀ ਹੈ. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib(3)) (5) >>> prime_fib((4)) (13) >>> prime_fib(5)) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// triples_sum_to_zero ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਲੈਂਦਾ ਹੈ. ਇਹ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇ ਵੈਕਟਰ ਵਿੱਚ ਤਿੰਨ ਵੱਖਰੇ ਤੱਤ ਹਨ ਜੋ ਜ਼ੀਰੋ ਨੂੰ ਜੋੜਦੇ ਹਨ, ਅਤੇ ਹੋਰ ਗਲਤ ਹਨ. >>> triples_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triples_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long)-2, (long) 1} >>> (true) triples_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) >>> triples_to_zero_((std::vector<long> (long) 2, (long) 4, (long) 5, (long) 3, (long) 9, (long) 7))) (true) triples_sum_to_zero))) (long) >>> triples_false (long) >>>
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸੜਕ ਦੀ ਕਲਪਨਾ ਕਰੋ ਜੋ ਇੱਕ ਅਨੰਤ ਲੰਬੀ ਲਾਈਨ ਹੈ. n ਕਾਰਾਂ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀਆਂ ਹਨ; ਇੱਕੋ ਸਮੇਂ, n ਕਾਰਾਂ ਦਾ ਇੱਕ ਵੱਖਰਾ ਸਮੂਹ ਸੱਜੇ ਤੋਂ ਖੱਬੇ ਵੱਲ ਜਾ ਰਿਹਾ ਹੈ. ਕਾਰਾਂ ਦੇ ਦੋ ਸੈੱਟ ਇੱਕ ਦੂਜੇ ਤੋਂ ਬਹੁਤ ਦੂਰ ਹੋਣ ਤੋਂ ਸ਼ੁਰੂ ਹੁੰਦੇ ਹਨ. ਸਾਰੀਆਂ ਕਾਰਾਂ ਇੱਕੋ ਗਤੀ ਤੇ ਚਲਦੀਆਂ ਹਨ. ਦੋ ਕਾਰਾਂ ਨੂੰ ਟਕਰਾਉਣ ਲਈ ਕਿਹਾ ਜਾਂਦਾ ਹੈ ਜਦੋਂ ਇੱਕ ਕਾਰ ਜੋ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ ਇੱਕ ਕਾਰ ਨੂੰ ਟਕਰਾਉਂਦੀ ਹੈ ਜੋ ਸੱਜੇ ਤੋਂ ਖੱਬੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ. ਹਾਲਾਂਕਿ, ਕਾਰਾਂ ਬੇਅੰਤ ਮਜ਼ਬੂਤ ਅਤੇ ਮਜ਼ਬੂਤ ਹਨ; ਨਤੀਜੇ ਵਜੋਂ, ਉਹ ਆਪਣੇ ਰਸਤੇ ਵਿੱਚ ਚਲਦੇ ਰਹਿੰਦੇ ਹਨ ਜਿਵੇਂ ਕਿ ਉਹ ਟਕਰਾ ਨਹੀਂ ਰਹੇ ਸਨ. ਇਹ ਫੰਕਸ਼ਨ ਅਜਿਹੇ ਟੱਕਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਆਉਟਪੁੱਟ ਕਰਦਾ ਹੈ.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// 1. ਨਾਲ ਵਧੇ ਹੋਏ ਤੱਤਾਂ ਦੇ ਨਾਲ ਵਾਪਸੀ ਵੈਕਟਰ >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// pairs_sum_to_zero ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਲੈਂਦਾ ਹੈ. ਇਹ ਸੱਚ ਹੈ ਜੇ ਵੈਕਟਰ ਵਿੱਚ ਦੋ ਵੱਖਰੇ ਤੱਤ ਹਨ ਜੋ ਜ਼ੀਰੋ ਨੂੰ ਜੋੜਦੇ ਹਨ, ਅਤੇ ਹੋਰ ਗਲਤ ਹਨ. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{(long>{long>{long>{long>{long>{long>{long>} (long>long)) (long>long)) (long>long)) >>> (long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਨਪੁਟ ਨੰਬਰ x ਦਾ ਅੰਕੀ ਅਧਾਰ ਅਧਾਰ ਵਿੱਚ ਬਦਲੋ. ਪਰਿਵਰਤਨ ਤੋਂ ਬਾਅਦ ਸਤਰ ਪ੍ਰਤੀਨਿਧਤਾ ਵਾਪਸ ਕਰੋ. ਅਧਾਰ ਨੰਬਰ 10 ਤੋਂ ਘੱਟ ਹਨ. >>> change_base((8), (3)) (""22"") >>> change_base(8), (2)) (""1000"") >>> change_base(7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਤਿਕੋਣ ਲਈ ਇੱਕ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਅਤੇ ਉੱਚ ਵਾਪਸੀ ਖੇਤਰ ਦਿੱਤਾ ਗਿਆ ਹੈ. >>> triangle_area((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Fib4 ਨੰਬਰ ਸੀਕਵੈਂਸ ਫਿਬੋਨੈਕਸੀ ਸੀਕਵੈਂਸ ਵਰਗੀ ਇਕ ਸੀਕਵੈਂਸ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤੀ ਗਈ ਹੈਃ fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ਕਿਰਪਾ ਕਰਕੇ fib4 ਨੰਬਰ ਸੀਕਵੈਂਸ ਦੇ n-th ਐਲੀਮੈਂਟ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰਨ ਲਈ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ. ਰੀਕ੍ਰਿਸ਼ਨ ਦੀ ਵਰਤੋਂ ਨਾ ਕਰੋ. >>> fib4((5)) (4) >>> fib4((6)) (8) >>> fib4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਵੈਕਟਰ l ਵਿੱਚ ਤੱਤਾਂ ਦਾ ਵਾਪਸੀ ਦਾ ਮੱਧਮ. >>> median((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (float(3) >>> median((std::vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਜਾਂਚ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸਤਰ ਇੱਕ ਪੈਲਿੰਡਰੋਮ ਹੈ >>> is_palindrome ((("""")) (true) >>> is_palindrome (((""aba"")) (true) >>> is_palindrome (((""aaaaa"")) (true) >>> is_palindrome (((""zbcd"")) (false)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// 2 ^ n ਮਾਡੂਲੋ ਪੀ (ਅੰਕਾਂ ਤੋਂ ਜਾਣੂ ਹੋਣਾ) ਵਾਪਿਸ ਕਰੋ. >>> ਮਾਡੂਲੋ ((((3), (5)) (3) >>> ਮਾਡੂਲੋ (((1101), (101)) (2) >>> ਮਾਡੂਲੋ (((0), (101)) (1) >>> ਮਾਡੂਲੋ (((3), (11)) (8) >>> ਮਾਡੂਲੋ (((100), (101)) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਤਰ ਨੂੰ ਬਿਨਾਂ ਵੋਕਲ ਦੇ ਵਾਪਸ ਕਰਦਾ ਹੈ. >>> remove_vowels("""")) ("""") >>> remove_vowels(""abcdef"")) (""bcdf"") >>> remove_vowels(""aaaaa"")) ("""") >>> remove_vowels(""aaBAA"")) (""B"") >>> remove_vowels(""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਵਾਪਸ ਸੱਚ ਹੈ, ਜੇ ਵੈਕਟਰ l ਵਿਚ ਸਾਰੇ ਨੰਬਰ ਥ੍ਰੈਸ਼ੋਲਡ ਤੋਂ ਹੇਠਾਂ ਹਨ. >>> below_threshold(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਦੋ ਨੰਬਰ x ਅਤੇ y ਜੋੜੋ >>> ਜੋੜੋ ((((2), (3)) (5) >>> ਜੋੜੋ (((5), (7)) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਚੈੱਕ ਕਰੋ ਕਿ ਕੀ ਦੋ ਸ਼ਬਦਾਂ ਦੇ ਅੱਖਰ ਇੱਕੋ ਜਿਹੇ ਹਨ. >>> same_chars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) (true) >>> same_chars((""abcd""), (""dddddddabc"")) (true) >>> same_chars(""dddddddabc""), (""abcd"") (true) >>> same_chars(""eabcd""), (""dddddddabc"")) (false) >>> same_chars >>>""((abcd""), (""dddddddddabc"") (false) (false) >>> same_chars(""eabcd""), (""ddddzzzzzdzzdddabc"") (false)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// n-th ਫਿਬੋਨੈਕਸੀ ਨੰਬਰ ਵਾਪਸ ਕਰੋ. >>> fib(((10)) (55) >>> fib(((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets ""<"" ਅਤੇ "">"" ਦੀ ਇੱਕ ਸਤਰ ਹੈ. ਜੇਕਰ ਹਰੇਕ ਖੁੱਲਣ ਵਾਲੀ ਬਰੈਕਟ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬੰਦ ਕਰਨ ਵਾਲੀ ਬਰੈਕਟ ਹੁੰਦੀ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing(""<><>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਵਾਪਸੀ ਸਹੀ ਹੈ ਕਿ ਵੈਕਟਰ ਤੱਤ ਇਕਸਾਰਤਾ ਨਾਲ ਵੱਧ ਰਹੇ ਹਨ ਜਾਂ ਘਟ ਰਹੇ ਹਨ. >>> ਇਕਸਾਰਤਾ ਨਾਲ ((((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (ਸੱਚਾ) >>> ਇਕਸਾਰਤਾ ਨਾਲ (((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (ਗਲਤ) >>> ਇਕਸਾਰਤਾ ਨਾਲ ((((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (ਸੱਚਾ)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਦੋ ਵੈਕਟਰਾਂ ਲਈ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਅਨੌਖੇ ਆਮ ਤੱਤ ਵਾਪਸ ਕਰੋ. >>> ਆਮ((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> ਆਮ(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long>{long} 2, (long))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// n ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਇਮ ਫੈਕਟਰ ਵਾਪਸ ਕਰੋ. ਮੰਨ ਲਓ ਕਿ n > 1 ਹੈ ਅਤੇ ਪ੍ਰਾਇਮ ਨਹੀਂ ਹੈ. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ 1 ਤੋਂ n ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ ਕਰਦਾ ਹੈ। >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1)) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets ""("" ਅਤੇ """") ਦੀ ਇੱਕ ਸਤਰ ਹੈ. ਜੇਕਰ ਹਰੇਕ ਖੁੱਲਣ ਵਾਲੀ ਬਰੈਕਟ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬੰਦ ਕਰਨ ਵਾਲੀ ਬਰੈਕਟ ਹੁੰਦੀ ਹੈ ਤਾਂ ਇਹ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ. >>> correct_bracketing((""("")) (false) >>> correct_bracketing(""() "")) (true) >>> correct_bracketing(""(()))))) (true) >>> correct_bracketing(("") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs ਇੱਕ ਬਹੁਪੱਖੀ ਦੇ ਗੁਣਾਂਕ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ. xs[0] + xs[1] * x + xs[2] * x^2 + .... ਇਸ ਬਹੁਪੱਖੀ ਦਾ ਉਸੇ ਰੂਪ ਵਿੱਚ ਡੈਰੀਵੇਟਿਵ ਵਾਪਸ ਕਰੋ. >>> ਡੈਰੀਵੇਟਿਵ (((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> ਡੈਰੀਵੇਟਿਵ (((std::vector<long>({(long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਫਿਬਫਿਬ ਨੰਬਰ ਸੀਕਵੈਂਸ ਫਿਬਬੋਨੈਕਸੀ ਸੀਕਵੈਂਸ ਵਰਗੀ ਇਕ ਲੜੀ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤੀ ਗਈ ਹੈਃ ਫਿਬਫਿਬ ((0) == 0 ਫਿਬਫਿਬ ((1) == 0 ਫਿਬਫਿਬ ((2) == 1 ਫਿਬਫਿਬ ((n) == ਫਿਬਫਿਬ ((n-1) + ਫਿਬਫਿਬ ((n-2) + ਫਿਬਫਿਬ ((n-3). ਫਿਬਫਿਬ ਨੰਬਰ ਸੀਕਵੈਂਸ ਦੇ n-th ਐਲੀਮੈਂਟ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰਨ ਲਈ ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ. >>> ਫਿਬਫਿਬ (((1)) (0) >>> ਫਿਬਫਿਬ (((5)) (4) >>> ਫਿਬਫਿਬ ((8)) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਵੋਕਲਸ_ਕਾਉਂਟ ਲਿਖੋ ਜੋ ਇੱਕ ਸ਼ਬਦ ਨੂੰ ਪ੍ਰਤੀਨਿਧਤਾ ਕਰਨ ਵਾਲੀ ਸਤਰ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਤਰ ਵਿੱਚ ਵੋਕਲਸ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਦਾ ਹੈ। ਇਸ ਕੇਸ ਵਿੱਚ ਵੋਕਲਸ 'ਏ', 'ਈ', 'ਆਈ', 'ਓ', 'ਯੂ' ਹਨ। ਇੱਥੇ, 'ਵਾਈ' ਵੀ ਇੱਕ ਵੋਕਲ ਹੈ, ਪਰ ਸਿਰਫ ਜਦੋਂ ਇਹ ਦਿੱਤੇ ਗਏ ਸ਼ਬਦ ਦੇ ਅੰਤ ਵਿੱਚ ਹੁੰਦਾ ਹੈ। ਉਦਾਹਰਨਃ >>> ਵੋਕਲਸ_ਕਾਉਂਟ (ਆਬ੍ਕਡ) (2) >>> ਵੋਕਲਸ_ਕਾਉਂਟ (ਅਕੈਡ) (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਰਕੂਲਰ ਪੂਰਨ ਅੰਕ x ਦੇ ਅੰਕ ਨੂੰ ਹਿਲਾਓ, ਹਿਲਾ ਕੇ ਅੰਕ ਨੂੰ ਸੱਜੇ ਪਾਸੇ ਹਿਲਾਓ ਅਤੇ ਨਤੀਜਾ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ. ਜੇ ਸ਼ਿਫਟ > ਅੰਕ ਦੀ ਗਿਣਤੀ, ਅੰਕ ਨੂੰ ਉਲਟਾਓ. >>> circular_shift (((12), (1)) (""21"") >>> circular_shift (((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਟਾਸਕ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਿਰਫ ਉਪਰਲੇ ਅੱਖਰਾਂ ਦੇ ਜੋੜ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਉਦਾਹਰਣਃ >>> digitSum ((("""")) (0) >>> digitSum (((""abAB"")) (131) >>> digitSum (((""abcCd"")) (67) >>> digitSum (((""helloE"")) (69) >>> digitSum (((""woArBld"")) (131) >>> digitSum (((""aAXaaaa"")) (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਸ ਕੰਮ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ ਜੋ ਇੱਕ ਫਲਾਂ ਦੀ ਟੋਕਰੀ ਵਿੱਚ ਵੰਡੀਆਂ ਗਈਆਂ ਸੇਬਾਂ ਅਤੇ ਸੰਤਰੇ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ ਇਸ ਟੋਕਰੀ ਵਿੱਚ ਸੇਬ, ਸੰਤਰੇ ਅਤੇ ਅੰਬ ਦੇ ਫਲ ਹੁੰਦੇ ਹਨ. ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਸੰਤਰੇ ਅਤੇ ਸੇਬਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ ਅਤੇ ਇੱਕ ਪੂਰਨ ਅੰਕ ਜੋ ਟੋਕਰੀ ਵਿੱਚ ਫਲਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ ਟੋਕਰੀ ਵਿੱਚ ਅੰਬ ਦੇ ਫਲ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣ ਲਈਃ >>> fruit_distribution (((("" 5 ਸੇਬ ਅਤੇ 6 ਸੰਤਰੇ""), (19)) (8) >>> fruit_distribution ((((""0 ਸੇਬ ਅਤੇ 1 ਸੰਤਰੇ""), (3)) (2) >>> fruit_distribution ((((""2 ਸੇਬ ਅਤੇ 3 ਸੰਤਰੇ""), (100)) (95) >>> fruit_distribution (((""100 ਸੇਬ ਅਤੇ 1 ਸੰਤਰੇ""), (120)) (19)
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਇੱਕ ਰੁੱਖ ਦੀ ਇੱਕ ਸ਼ਾਖਾ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨੋਡ ਹਨ ਤੁਹਾਡਾ ਕੰਮ ਨੋਡਾਂ ਵਿੱਚੋਂ ਇੱਕ ਨੂੰ ਚੁੱਕਣਾ ਅਤੇ ਵਾਪਸ ਕਰਨਾ ਹੈ। ਚੁੱਕਿਆ ਨੋਡ ਸਭ ਤੋਂ ਛੋਟਾ ਬਰਾਬਰ ਮੁੱਲ ਵਾਲਾ ਨੋਡ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ. ਜੇ ਇੱਕੋ ਜਿਹੇ ਸਭ ਤੋਂ ਛੋਟੇ ਬਰਾਬਰ ਮੁੱਲ ਵਾਲੇ ਕਈ ਨੋਡ ਮਿਲਦੇ ਹਨ ਤਾਂ ਨੋਡ ਨੂੰ ਸਭ ਤੋਂ ਛੋਟਾ ਸੂਚਕ ਵਾਪਸ ਕਰੋ. ਚੁੱਕਿਆ ਨੋਡ ਨੂੰ ਇੱਕ ਵੈਕਟਰ ਵਿੱਚ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ, [smallest_value, ਇਸਦੀ ਸੂਚਕ ], ਜੇ ਕੋਈ ਵੀ ਮੁੱਲ ਨਹੀਂ ਹਨ ਜਾਂ ਦਿੱਤਾ ਗਿਆ ਵੈਕਟਰ ਖਾਲੀ ਹੈ, ਵਾਪਸ ਕਰੋ []. ਉਦਾਹਰਨ 1: >>> pluck((stdvector<<(long>{(long) 4, (long) 2, (long) 3}))) (stdvector:::::::::::::::: long long) 2 (long) 0 (long) 0 (long) 1 (long) 2 (long)) (long) 1 (long) 2 (long)) (long)) (long) (long) (long)) (long) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ ਵਾਪਸ ਕਰੋ ਜੋ ਜ਼ੀਰੋ ਤੋਂ ਵੱਡਾ ਹੈ, ਅਤੇ ਪੂਰਨ ਅੰਕ ਦੇ ਮੁੱਲ ਦੇ ਬਰਾਬਰ ਜਾਂ ਇਸ ਤੋਂ ਵੱਧ ਬਾਰੰਬਾਰਤਾ ਹੈ. ਇੱਕ ਪੂਰਨ ਅੰਕ ਦੀ ਬਾਰੰਬਾਰਤਾ ਉਹ ਵਾਰ ਹੈ ਜਦੋਂ ਇਹ ਵੈਕਟਰ ਵਿੱਚ ਦਿਖਾਈ ਦਿੰਦੀ ਹੈ. ਜੇ ਅਜਿਹਾ ਕੋਈ ਮੁੱਲ ਮੌਜੂਦ ਨਹੀਂ ਹੈ, ਤਾਂ ਵਾਪਸ ਕਰੋ -1. ਉਦਾਹਰਣਃ >>> ਖੋਜ: ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ ਲੌਂਗਃ
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ, ਅਜੀਬ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸੀ ਵੈਕਟਰ. ਅਜੀਬ ਲੜੀਬੱਧਤਾ, ਜਦੋਂ ਤੁਸੀਂ ਘੱਟੋ ਘੱਟ ਮੁੱਲ ਨਾਲ ਸ਼ੁਰੂ ਕਰਦੇ ਹੋ, ਫਿਰ ਬਾਕੀ ਪੂਰਨ ਅੰਕ ਦਾ ਵੱਧ ਤੋਂ ਵੱਧ, ਫਿਰ ਘੱਟੋ ਘੱਟ ਅਤੇ ਇਸ ਤਰ੍ਹਾਂ ਜਾਰੀ ਰੱਖੋ. ਉਦਾਹਰਣਃ >>> strange_sort_list{long}1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸਿਆਂ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ. ਤਿਕੋਣ ਦੇ ਖੇਤਰ ਨੂੰ 2 ਦਸ਼ਮਲਵ ਬਿੰਦੂਆਂ ਤੱਕ ਗੋਲ ਕਰੋ ਜੇ ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਜਾਇਜ਼ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ. ਨਹੀਂ ਤਾਂ -1 ਵਾਪਸ ਕਰੋ ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਜਾਇਜ਼ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ ਜਦੋਂ ਕਿਸੇ ਵੀ ਦੋ ਪਾਸਿਆਂ ਦਾ ਜੋੜ ਤੀਜੀ ਪਾਸਿਆਂ ਤੋਂ ਵੱਡਾ ਹੁੰਦਾ ਹੈ. ਉਦਾਹਰਣਃ >>> ਤਿਕੋਣ_ ਖੇਤਰ ((3), (4), (5)) (6.0f) >>> ਤਿਕੋਣ_ ਖੇਤਰ ((1), (2), (10)) (ਫਲੋਟ -1))
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇ ਵਸਤੂ q ਉਡਦੀ ਹੈ, ਅਤੇ ਗਲਤ ਹੈ. ਵਸਤੂ q ਉਡਦੀ ਹੈ ਜੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ (ਇਹ ਇੱਕ ਪੈਲਿੰਡਰੋਮਿਕ ਵੈਕਟਰ ਹੈ) ਅਤੇ ਇਸਦੇ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ. ਉਦਾਹਰਣਃ >>> will_it_fly((std::vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2 ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਪਰ ਇਹ ਅਸੰਤੁਲਿਤ ਹੈ. >>> will_it_fly((std::vector<long>({long) 3, (long) 2, (long) 3})), (1)) (false) # ਇਹ ਸੰਤੁਲਿਤ ਹੈ, ਪਰ 3+2+3 ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਹੈ. >>> will_it_(fly::std::vector<long>{(long>{long}3, (long) 2, (long) 3}), (9) (true) # 3+2 ਹੈ, ਅਤੇ ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਘੱਟ ਹੈ, ਪਰ ਇਹ ਸੰਤੁਲਿਤ ਹੈ. ਅਤੇ (5) (long) (true) # 3+3 ਹੈ, ਪਰ ਇਹ ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਹੈ.
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਉਹਨਾਂ ਤੱਤਾਂ ਦੀ ਘੱਟੋ ਘੱਟ ਗਿਣਤੀ ਲੱਭੋ ਜਿਨ੍ਹਾਂ ਨੂੰ ਵੈਕਟਰ ਨੂੰ ਪਾਲੀਂਡਰੋਮਿਕ ਬਣਾਉਣ ਲਈ ਬਦਲਣ ਦੀ ਜ਼ਰੂਰਤ ਹੈ. ਇੱਕ ਪਾਲੀਂਡਰੋਮਿਕ ਵੈਕਟਰ ਇੱਕ ਵੈਕਟਰ ਹੈ ਜੋ ਪਿੱਛੇ ਅਤੇ ਅੱਗੇ ਇੱਕੋ ਜਿਹਾ ਪੜ੍ਹਿਆ ਜਾਂਦਾ ਹੈ. ਇੱਕ ਤਬਦੀਲੀ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਤੱਤ ਨੂੰ ਕਿਸੇ ਵੀ ਹੋਰ ਤੱਤ ਵਿੱਚ ਬਦਲ ਸਕਦੇ ਹੋ. ਉਦਾਹਰਣ ਲਈਃ >>> smallest_change(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 2} (1) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 1, (long) (0))))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੇ ਦੋ ਵੈਕਟਰਾਂ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ ਅਤੇ ਉਹ ਵੈਕਟਰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਵੈਕਟਰ ਦੀਆਂ ਸਾਰੀਆਂ ਸਤਰਾਂ ਵਿੱਚ ਕੁੱਲ ਅੰਕ ਦੀ ਗਿਣਤੀ ਦੂਜੇ ਵੈਕਟਰ ਤੋਂ ਘੱਟ ਹੈ. ਜੇ ਦੋ ਵੈਕਟਰਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੇ ਅੰਕ ਹਨ, ਤਾਂ ਪਹਿਲੇ ਵੈਕਟਰ ਨੂੰ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣ >>> total_match (), (std::vector (), (std::string) (), (std::vector (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) ()) (, (std:string) ()) (, (std:string) ()) (std:string) (d:string) (string) (string) (string) (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string) (string (string) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str)
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ 3 ਪ੍ਰਾਇਮ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ. ਇਹ ਜਾਣਦਿਆਂ ਕਿ (ਏ) 100 ਤੋਂ ਘੱਟ ਹੈ. ਉਦਾਹਰਨਃ >>> is_multiply_prime((30)) (ਸੱਚਾ) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇ ਇੱਕ ਨੰਬਰ x n ਦੀ ਇੱਕ ਸਧਾਰਨ ਸ਼ਕਤੀ ਹੈ ਅਤੇ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਗਲਤ ਹੈ. x n ਦੀ ਇੱਕ ਸਧਾਰਨ ਸ਼ਕਤੀ ਹੈ ਜੇ n**int=x ਉਦਾਹਰਣ ਲਈਃ >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਪੂਰਨ ਅੰਕ a ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਹੀ ਵਾਪਿਸ ਕਰਦਾ ਹੈ ਜੇ ਇਹ ਇੰਗੇਜਰ ਕਿਸੇ ਪੂਰਨ ਅੰਕ ਦਾ ਘਣ ਹੈ। ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇੰਪੁੱਟ ਹਮੇਸ਼ਾਂ ਯੋਗ ਹੁੰਦਾ ਹੈ। ਉਦਾਹਰਣਃ >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180)) (false)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣ ਦਾ ਕੰਮ ਦਿੱਤਾ ਗਿਆ ਹੈ ਜੋ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਹੈਕਸਾਡੇਸਿਮਲ ਨੰਬਰ ਪ੍ਰਾਪਤ ਕਰਦਾ ਹੈ ਅਤੇ ਹੈਕਸਾਡੇਸਿਮਲ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਗਿਣਦਾ ਹੈ ਜੋ ਪ੍ਰਾਇਮ ਹਨ (ਪ੍ਰਾਇਮ ਨੰਬਰ, ਜਾਂ ਪ੍ਰਾਇਮ, 1 ਤੋਂ ਵੱਡਾ ਇੱਕ ਕੁਦਰਤੀ ਨੰਬਰ ਹੈ ਜੋ ਦੋ ਛੋਟੇ ਕੁਦਰਤੀ ਸੰਖਿਆਵਾਂ ਦਾ ਉਤਪਾਦ ਨਹੀਂ ਹੈ) ਹੈਕਸਾਡੇਸਿਮਲ ਅੰਕ ਹਨ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ਪ੍ਰਾਇਮ ਨੰਬਰ ਹਨ 2, 3, 5, 7, 11, 13, 17,... ਇਸ ਲਈ ਤੁਹਾਨੂੰ ਹੇਠ ਲਿਖੇ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਨਿਰਧਾਰਤ ਕਰਨੀ ਪਵੇਗੀਃ 2, 3, 5, 7, B (=ਦਿਸ਼ਮਲ 11), D (=ਦਿਸ਼ਮਲ 13) ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇੰਪੁੱਟ ਹਮੇਸ਼ਾਂ ਸਹੀ ਜਾਂ ਖਾਲੀ ਹੈ, ਅਤੇ ਪ੍ਰਤੀਕ A,B,C,D,E,F ਹਮੇਸ਼ਾਂ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਹੁੰਦੇ ਹਨ। ਉਦਾਹਰਣਃ >>> hex_((AB""key"") (1) >>> hex_((((10""E77"") (2) >>> hex_(AB""key"") >>>ABC1"") (4) >>>x_(33"") >>> hex_(DBC1"") >>> hex_12345"" ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਦਸ਼ਮਲਵ ਰੂਪ ਵਿੱਚ ਇੱਕ ਨੰਬਰ ਦਿੱਤਾ ਜਾਵੇਗਾ ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਨੂੰ ਬਾਈਨਰੀ ਫਾਰਮੈਟ ਵਿੱਚ ਬਦਲਣਾ ਹੈ. ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ, ਜਿਸ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ ਇੱਕ ਬਾਈਨਰੀ ਨੰਬਰ ਦਰਸਾਉਂਦਾ ਹੈ. ਸਤਰ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ '0' ਜਾਂ '1' ਹੋਵੇਗਾ. ਸਤਰ ਦੇ ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ ਇੱਕ ਵਾਧੂ ਜੋੜਾ ਅੱਖਰ 'db' ਹੋਣਗੇ. ਵਾਧੂ ਅੱਖਰ ਫਾਰਮੈਟ ਵਿੱਚ ਮਦਦ ਕਰਨ ਲਈ ਹਨ. ਉਦਾਹਰਣਃ >>> decimal_to_binary (((15)) (""db1111db"") >>> decimal_to_binary (((32)) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚ ਕਰਨਾ ਹੈ ਕਿ ਸਤਰ ਹੈਕ ਹੈ ਜਾਂ ਨਹੀਂ. ਇੱਕ ਸਤਰ ਹੈਕ ਹੈ ਜੇ ਇਸ ਦੀ ਲੰਬਾਈ ਘੱਟੋ ਘੱਟ 3 ਹੈ ਅਤੇ ਹਰ 3 ਲਗਾਤਾਰ ਅੱਖਰ ਵੱਖਰੇ ਹਨ ਉਦਾਹਰਣ ਲਈਃ >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਏ"")) (ਝੂਠ) >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਏ"")) (ਝੂਠ) >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਏਬੀਸੀਡੀ"")) (ਸੱਚ) >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਏਬੀ"")) (ਝੂਠ) >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਏਬੀਬੀ"")) (ਸੱਚ) >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਏਬੀ"")) (ਸੱਚ) >>> ਹੈ_ਹੈਪੀ ਹੈ_(""ਐਕਸ"") (ਝੂਠ)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਹ ਸੈਮੇਸਟਰ ਦਾ ਆਖਰੀ ਹਫ਼ਤਾ ਹੈ ਅਤੇ ਅਧਿਆਪਕ ਨੂੰ ਵਿਦਿਆਰਥੀਆਂ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣਾ ਹੈ. ਅਧਿਆਪਕ ਗਰੇਡਿੰਗ ਲਈ ਆਪਣਾ ਅਲਗੋਰਿਦਮ ਬਣਾ ਰਹੀ ਹੈ. ਸਿਰਫ ਸਮੱਸਿਆ ਇਹ ਹੈ ਕਿ ਉਸਨੇ ਗਰੇਡਿੰਗ ਲਈ ਵਰਤਿਆ ਕੋਡ ਗੁਆ ਦਿੱਤਾ ਹੈ. ਉਸਨੇ ਤੁਹਾਨੂੰ ਕੁਝ ਵਿਦਿਆਰਥੀਆਂ ਲਈ ਜੀਪੀਏ ਦਾ ਵੈਕਟਰ ਦਿੱਤਾ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਹੇਠ ਦਿੱਤੀ ਸਾਰਣੀ ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਪੱਤਰ ਗ੍ਰੇਡਾਂ ਦਾ ਵੈਕਟਰ ਆਉਟਪੁੱਟ ਦੇ ਸਕਦਾ ਹੈਃ ਜੀਪੀਏ. ਪੱਤਰ ਗ੍ਰੇਡ 4.0 ਏ + > 3.7 ਏ > 3.3 ਏ- > 3.0 ਬੀ + > 2.7 ਬੀ > 2.3 ਬੀ- > 2.0 ਸੀ + > 1.7 ਸੀ > 1.3 ਸੀ- > 1.0 ਡੀ + > 0.7 ਡੀ > 0.0 ਡੀ- 0.0 ਈ ਉਦਾਹਰਣਃ >>>_ ਗ੍ਰੇਡ ਸਮੀਕਰਨ: (((std:: vector<float>{(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f)) ()) (std:: vector<std:: std::string::std::string::std::string::std::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸੱਚੀ ਵਾਪਿਸ ਕਰਦਾ ਹੈ ਜੇ ਸਤਰ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ ਜਾਂ ਗਲਤ ਹੈ ਹੋਰ ਉਦਾਹਰਣ >>> prime_length((""Hello"")) (true) >>> prime_length((""abcdcba"")) (true) >>> prime_length((""kittens"")) (true) >>> prime_length((""orange"")) (false)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, n-ਅੰਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਗਿਣਤੀ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ 1 ਨਾਲ ਸ਼ੁਰੂ ਜਾਂ ਖ਼ਤਮ ਹੁੰਦਾ ਹੈ।
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ N ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਅੰਕਾਂ ਦਾ ਕੁੱਲ ਜੋੜ ਬਾਈਨਰੀ ਵਿੱਚ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਨ >>> solve((1000)) (""1"") >>> solve((150)) (""110"") >>> solve((147)) (""1100"") ਵੇਰੀਏਬਲਃ @N ਪੂਰਨ ਅੰਕ ਕੰਟਰੈਕਟਸਃ 0 ≤ N ≤ 10000. ਆਉਟਪੁੱਟਃ ਬਾਈਨਰੀ ਨੰਬਰ ਦੀ ਇੱਕ ਸਤਰ
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ lst. ਜੋੜੇ ਤੱਤ ਜੋੜੋ ਜੋ ਅਜੀਬ ਸੂਚਕਾਂਕ ਤੇ ਹਨ. ਉਦਾਹਰਣਃ >>> add((std:: vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਇਸਦਾ ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੰਸਕਰਣ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਸਤਰ ਦਾ ਕ੍ਰਮਬੱਧ ਸੰਸਕਰਣ, ਇੱਕ ਸਤਰ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਸ਼ਬਦ (ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ) ਨੂੰ ਇੱਕ ਨਵੇਂ ਸ਼ਬਦ ਦੁਆਰਾ ਬਦਲਿਆ ਜਾਂਦਾ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਅੱਖਰ ASCII ਮੁੱਲ ਦੇ ਅਧਾਰ ਤੇ ਵੱਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਵਿਵਸਥਿਤ ਹੁੰਦੇ ਹਨ. ਨੋਟਃ ਤੁਹਾਨੂੰ ਵਾਕ ਵਿੱਚ ਸ਼ਬਦਾਂ ਅਤੇ ਖਾਲੀ ਥਾਂਵਾਂ ਦਾ ਕ੍ਰਮ ਰੱਖਣਾ ਚਾਹੀਦਾ ਹੈ. ਉਦਾਹਰਣ ਲਈਃ >>> anti_shuffle (((""Hi"")) (""Hi"") >>> anti_shuffle (((""ਹੈਲੋ"")) (""ehllo"") >>> anti_shuffle (((""ਹੈਲੋ ਵਰਲਡ! !"") (""ਹੈਲੋ !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ 2 ਅਯਾਮੀ ਡੇਟਾ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਜਿਵੇਂ ਕਿ ਇੱਕ ਨੇਸਟਡ ਵੈਕਟਰ, ਜੋ ਕਿ ਮੈਟ੍ਰਿਕਸ ਦੇ ਸਮਾਨ ਹੈ, ਹਾਲਾਂਕਿ, ਮੈਟ੍ਰਿਕਸ ਦੇ ਉਲਟ, ਹਰੇਕ ਕਤਾਰ ਵਿੱਚ ਵੱਖ ਵੱਖ ਸੰਖਿਆ ਦੇ ਕਾਲਮ ਹੋ ਸਕਦੇ ਹਨ. lst, ਅਤੇ ਪੂਰਨ ਅੰਕ x ਦਿੱਤੇ ਗਏ ਹਨ, ਵੈਕਟਰ ਵਿੱਚ ਪੂਰਨ ਅੰਕ x ਲੱਭੋ, ਅਤੇ ਟੁਪਲਜ਼ ਦਾ ਵਾਪਸੀ ਵੈਕਟਰ, [(x1, y1), (x2, y2) ...] ਜਿਵੇਂ ਕਿ ਹਰੇਕ ਟੁਪਲ ਇੱਕ ਕੋਆਰਡੀਨੇਟ ਹੈ - (row, columns), 0 ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ. ਸ਼ੁਰੂ ਵਿੱਚ ਕਤਾਰਾਂ ਦੁਆਰਾ ਕਤਾਰਾਂ ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ ਕਰੋ. ਨਾਲ ਹੀ, ਕਤਾਰ ਦੇ ਕੋਆਰਡੀਨੇਟ ਨੂੰ ਹੇਠਾਂ ਵੱਲ ਕ੍ਰਮਬੱਧ ਕਰੋ. ਉਦਾਹਰਣਃ >>> get_row(std::vector<std::vector<<long>, (long) {long} (long) {long} (long) {long}, (long) {long} (long) {long}, (long) {long} (long) {long}, (long) {long}, (long) {long}, (long) {long}, (long) {long}, (long) {long}, (long) {long}, (long) {long}, (long) {long}, (long) {long}, {long} (long) {long}, {long}, {long} (long}, {long}, {long}long (long}, {long}long {long}, {long}long {long}long {long}, {long}long {long}long {long}long {long}, {long {long}long {long}long {long}long {long}long {long}long {long}long {long {long}long {long}long {long}long {long}long {long}long {long}long {long {long}long {long}long {long}long {long}long {long}long {long {long}long {long}long {long {long}long {long}long {long}long {long {long}long}long {long {long}long {long}long {long {long}long {long}long {long}long {long {long}long {long}long {long}
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਕ੍ਰਮਬੱਧ ਕਰਨ ਤੋਂ ਬਾਅਦ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਦਾ ਇੱਕ ਕੋਕਪ ਵਾਪਸ ਕਰੋ, ਤੁਸੀਂ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਨੂੰ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋਗੇ ਜੇ ਜੋੜ ((ਪਹਿਲਾ ਇੰਡੈਕਸ ਮੁੱਲ, ਆਖਰੀ ਇੰਡੈਕਸ ਮੁੱਲ) ਅਜੀਬ ਹੈ, ਜਾਂ ਜੇ ਜੋੜ ((ਪਹਿਲਾ ਇੰਡੈਕਸ ਮੁੱਲ, ਆਖਰੀ ਇੰਡੈਕਸ ਮੁੱਲ) ਜੋੜਾ ਹੈ ਤਾਂ ਇਸਨੂੰ ਹੇਠਾਂ ਆਉਂਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ. ਨੋਟਃ * ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਨੂੰ ਨਾ ਬਦਲੋ. ਉਦਾਹਰਣਃ >>> sort_array ((std::vector<long>())) (std::vector<long>) >>> sort_array ((std::vector<long>) >>> (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਐਨਕ੍ਰਿਪਟ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇੱਕ ਆਰਗੂਮੈਂਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਸਤਰ ਨੂੰ ਏਨਕ੍ਰਿਪਟ ਕੀਤਾ ਗਿਆ ਹੈ ਜਿਸ ਨਾਲ ਐਲਫਾਬੇਟ ਘੁੰਮਿਆ ਜਾ ਰਿਹਾ ਹੈ. ਐਲਫਾਬੇਟ ਨੂੰ ਇਸ ਤਰੀਕੇ ਨਾਲ ਘੁੰਮਾਇਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਕਿ ਅੱਖਰ ਦੋ ਵਾਰ ਦੋ ਸਥਾਨਾਂ ਤੇ ਹੇਠਾਂ ਆਉਂਦੇ ਹਨ. ਉਦਾਹਰਣ ਲਈਃ >>> ਐਨਕ੍ਰਿਪਟ (((""hi"")) (""lm"") >>> ਐਨਕ੍ਰਿਪਟ (((""asdfghjkl"")) (""ewhjklnop"") >>> ਐਨਕ੍ਰਿਪਟ (((""gf"")) (""kj"") >>> ਐਨਕ੍ਰਿਪਟ (((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਇੱਕ ਫੰਕਸ਼ਨ next_smallest ਲਿਖੋ ਜੋ ਵੈਕਟਰ ਦੇ ਦੂਜੇ ਸਭ ਤੋਂ ਛੋਟੇ ਤੱਤ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਜੇ ਅਜਿਹਾ ਕੋਈ ਤੱਤ ਨਹੀਂ ਹੈ ਤਾਂ ਕੋਈ ਵੀ ਵਾਪਸ ਨਾ ਕਰੋ. >>> next_smallest: vector<long>{long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest: vector<long>{(long) 5, (long) 1, (long) 4, (long) 3, (long) 2} >>> 2 next_smallest: vector<long>{(long)) std::nullopt >>> next_smallest: vector<long>{(long) 1, (long) 1))) std::nullopt
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਬੋਰਡਮ ਦੀ ਗਿਣਤੀ ਕਰਨਾ ਹੈ. ਇੱਕ ਬੋਰਡਮ ਇੱਕ ਵਾਕ ਹੈ ਜੋ ""I"" ਸ਼ਬਦ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ। ਵਾਕਾਂ ਨੂੰ '.', '?' ਜਾਂ '! ' ਨਾਲ ਸੀਮਿਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ। ਉਦਾਹਰਣ ਲਈਃ >>> is_bored((""ਹੈਲੋ ਵਰਲਡ"")) (0) >>> is_bored((""ਅਕਾਸ਼ ਨੀਲਾ ਹੈ. ਸੂਰਜ ਚਮਕ ਰਿਹਾ ਹੈ. ਮੈਨੂੰ ਇਹ ਮੌਸਮ ਪਸੰਦ ਹੈ"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ 3 ਨੰਬਰ ਲੈਂਦਾ ਹੈ. ਇਹ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦਾ ਹੈ ਜੇ ਇੱਕ ਨੰਬਰ ਦੂਜੀਆਂ ਦੋ ਦੇ ਜੋੜ ਦੇ ਬਰਾਬਰ ਹੁੰਦਾ ਹੈ, ਅਤੇ ਸਾਰੇ ਨੰਬਰ ਪੂਰਨ ਅੰਕ ਹੁੰਦੇ ਹਨ. ਇਹ ਕਿਸੇ ਵੀ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਗਲਤ ਵਾਪਿਸ ਆਉਂਦਾ ਹੈ. ਉਦਾਹਰਣ >>> any_int (float) (float) (float) (float) (float) (float) (float) (float) (float) (float)) (ਸੱਚਾ) >>> any_int (float) (float) (float) (float) (float) (float)) (ਸੱਚਾ) >>> any_int (float) (float) (float)) (ਸੱਚਾ) >>> any_int (float) (float) (float) (float) (float) (float) (float)) (ਸੱਚਾ) >>> any_int (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float (float) (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (flo) (flo) (flo) (float (flo) (flo) (flo) (float (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸੰਦੇਸ਼ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਇਸ ਤਰ੍ਹਾਂ ਇੰਕੋਡ ਕਰਦਾ ਹੈ ਕਿ ਇਹ ਸਾਰੇ ਅੱਖਰਾਂ ਦੇ ਕੇਸ ਨੂੰ ਬਦਲਦਾ ਹੈ, ਸੰਦੇਸ਼ ਵਿੱਚ ਸਾਰੇ ਵੋਕਲ ਨੂੰ ਉਸ ਅੱਖਰ ਨਾਲ ਬਦਲਦਾ ਹੈ ਜੋ ਅੰਗਰੇਜ਼ੀ ਵਰਣਮਾਲਾ ਵਿੱਚ ਉਸ ਵੋਕਲ ਤੋਂ 2 ਸਥਾਨਾਂ ਤੋਂ ਅੱਗੇ ਦਿਖਾਈ ਦਿੰਦਾ ਹੈ. ਸਿਰਫ ਅੱਖਰਾਂ ਨੂੰ ਮੰਨੋ. ਉਦਾਹਰਣਃ >>> ਇੰਕੋਡ ਕਰੋ (((""ਟੈਸਟ"")) (""ਟੀਜੀਐਸਟੀ"") >>> ਇੰਕੋਡ ਕਰੋ (((""ਇਹ ਇੱਕ ਸੰਦੇਸ਼ ਹੈ"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਇਮਰੀ ਮੁੱਲ ਲੱਭਣ ਅਤੇ ਇਸਦੇ ਅੰਕ ਦੇ ਜੋੜ ਨੂੰ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ. ਉਦਾਹਰਣਃ >>> skjkasdkd((std::vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 5, (long) 7, (long) 4, (long) 5, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਨਕਸ਼ਾ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਜੇ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਤਰਾਂ ਹਨ ਜਾਂ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਤਰਾਂ ਹਨ, ਤਾਂ ਸਹੀ ਵਾਪਿਸ ਪਰਤੋ, ਨਹੀਂ ਤਾਂ ਗਲਤ ਵਾਪਿਸ ਪਰਤੋ. ਫੰਕਸ਼ਨ ਨੂੰ ਗਲਤ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਕਿ ਦਿੱਤਾ ਗਿਆ ਨਕਸ਼ਾ ਖਾਲੀ ਹੈ. ਉਦਾਹਰਣਃ >>> ਚੈੱਕ_ਡਿਕਟ_ਕੇਸ, {{((std::map<std::string, std::string>, {{""a"", ""apple""}, {""b"", ""banana""}}))) (ਸੱਚਾ) >>> ਚੈੱਕ_ਡਿਕਟ_ਕੇਸ, {{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋ ਜੋ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਪਹਿਲੇ n ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੁੰਦੇ ਹਨ ਅਤੇ n ਤੋਂ ਘੱਟ ਹੁੰਦੇ ਹਨ. ਉਦਾਹਰਣ ਲਈਃ >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long> >>> count_up_to_8) (std:vector<long>{(long) 3, (long) 11, (long) 3, (long) 5, (long)) (std:vector<long> (long)) (long) 1, (long)) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਫੰਕਸ਼ਨ ਨੂੰ ਪੂਰਾ ਕਰੋ ਜੋ ਦੋ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਉਹਨਾਂ ਦੇ ਯੂਨਿਟ ਅੰਕ ਦੇ ਉਤਪਾਦ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਮੰਨ ਲਓ ਕਿ ਇੰਪੁੱਟ ਹਮੇਸ਼ਾਂ ਯੋਗ ਹੁੰਦਾ ਹੈ. ਉਦਾਹਰਣਃ >>> ਗੁਣਾ (((148), (412)) (16) >>> ਗੁਣਾ (((19), (28)) (72) >>> ਗੁਣਾ (((2020), (1851)) (0) >>> ਗੁਣਾ (((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ, ਜੋ ਕਿ ਸੰਕੇਤ ਵਿੱਚ ਵੱਡੇ ਅੱਖਰਾਂ ਦੇ ਵੋਕਲ ਦੀ ਗਿਣਤੀ ਗਿਣੋ. ਉਦਾਹਰਨ ਲਈਃ >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਨੰਬਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ ਅਤੇ ਇਸ ਦੇ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਜੇ ਨੰਬਰ ਦੋ ਪੂਰਨ ਅੰਕ ਤੋਂ ਬਰਾਬਰ ਹੈ, ਤਾਂ ਇਸ ਨੂੰ ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਕਰ ਦਿਓ. ਉਦਾਹਰਣ >>> closest_integer (((""10"")) (10) >>> closest_integer (((""15.3"")) ਨੋਟ (15): ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਕਰਨ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਜੇ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ ਦੋ ਪੂਰਨ ਅੰਕ ਤੋਂ ਬਰਾਬਰ ਹੈ, ਤਾਂ ਤੁਹਾਨੂੰ ਉਹ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਜ਼ੀਰੋ ਤੋਂ ਸਭ ਤੋਂ ਦੂਰ ਹੈ. ਉਦਾਹਰਣ ਲਈ closest_integer (((""14.5"") ਨੂੰ 15 ਅਤੇ closest_integer ((-14.5"") ਨੂੰ -15. ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਪੱਥਰਾਂ ਦੇ n ਪੱਧਰਾਂ ਦਾ ਇੱਕ ਢੇਰ ਬਣਾਉਣਾ ਹੈ. ਪਹਿਲੇ ਪੱਧਰ ਵਿੱਚ n ਪੱਥਰ ਹਨ. ਅਗਲੇ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਹੈਃ - ਅਗਲਾ ਅਜੀਬ ਨੰਬਰ ਜੇ n ਅਜੀਬ ਹੈ. - ਅਗਲਾ ਜੋੜ ਨੰਬਰ ਜੇ n ਜਮ੍ਹਾ ਹੈ. ਇੱਕ ਵੈਕਟਰ ਵਿੱਚ ਹਰੇਕ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ, ਜਿੱਥੇ ਸੂਚਕਾਂਕ i ਤੇ ਤੱਤ (i + 1) ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ. ਉਦਾਹਰਣਃ >>> make_a_pile(3)) (std::vector<long>{long) 3, (long) 5, (long) 7}))
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਕਾਮੇ ਜਾਂ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ. ਤੁਹਾਡਾ ਕੰਮ ਸਤਰ ਨੂੰ ਸ਼ਬਦਾਂ ਵਿੱਚ ਵੰਡਣਾ ਅਤੇ ਸ਼ਬਦਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਨਾ ਹੈ. ਉਦਾਹਰਣ ਲਈਃ >>> words_string (((""Hi, my name is John"")) (std::vector<std::string>({(std::string) ""Hi"", (std::string) ""my"", (std::string) ""name"", (std::string) ""is"", (std::string) ""John""}) >>> words_string (((""One, two, three, four, five, six"")) (std::vector<std::string>{(stdstring) ""One"", (std::string) ""two"", (std::string) ""three"", (std::string) ""four"", (std::string) ""five"", (std::string) ""six""})
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਹ ਫੰਕਸ਼ਨ ਦੋ ਸਕਾਰਾਤਮਕ ਨੰਬਰ x ਅਤੇ y ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਭ ਤੋਂ ਵੱਡਾ ਜੋੜ ਪੂਰਨ ਅੰਕ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ [x, y] ਦੀ ਰੇਂਜ ਵਿੱਚ ਹੈ। ਜੇ ਅਜਿਹੀ ਕੋਈ ਗਿਣਤੀ ਨਹੀਂ ਹੈ, ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ -1 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਉਦਾਹਰਣ ਲਈਃ >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ਤੁਹਾਨੂੰ ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਅਤੇ m ਦਿੱਤੇ ਗਏ ਹਨ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ n ਤੋਂ m ਤੱਕ ਪੂਰਨ ਅੰਕ ਦੀ ਔਸਤ ਗਣਨਾ ਕਰਨਾ ਹੈ (n ਅਤੇ m ਸਮੇਤ) । ਜਵਾਬ ਨੂੰ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਤੱਕ ਗੋਲ ਕਰੋ ਅਤੇ ਇਸਨੂੰ ਬਾਈਨਰੀ ਵਿੱਚ ਤਬਦੀਲ ਕਰੋ। ਜੇ n m ਤੋਂ ਵੱਡਾ ਹੈ, ਤਾਂ ਵਾਪਸ ਕਰੋ -1. ਉਦਾਹਰਨਃ >>> ਗੋਲ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵਗ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆਵ_ਆ
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ x ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਸਾਰੇ ਤੱਤਾਂ ਦਾ ਇੱਕ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕੋਈ ਵੀ ਅੰਕ ਨਹੀਂ ਹੈ. ਨੋਟਃ ਵਾਪਸ ਕੀਤੇ ਵੈਕਟਰ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ. ਉਦਾਹਰਣ ਲਈਃ >>> unique_digits(std::vector<long>({(long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਪੂਰਨ ਅੰਕ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰੋ ਜੋ 1 ਅਤੇ 9 ਦੇ ਵਿਚਕਾਰ ਹਨ, ਨਤੀਜੇ ਵਜੋਂ ਵੈਕਟਰ ਨੂੰ ਉਲਟਾਓ, ਅਤੇ ਫਿਰ ਹਰੇਕ ਅੰਕ ਨੂੰ ਇਸਦੇ ਅਨੁਸਾਰੀ ਨਾਮ ਨਾਲ ""ਇੱਕ"", ""ਦੋ"", ""ਤਿੰਨ"", ""ਚਾਰ"", ""ਪੰਜ"", ""ਛੇ"", ""ਸੱਤ"", ""ਅੱਠ"", ""ਨੌ"" ਤੋਂ ਬਦਲੋ. ਉਦਾਹਰਣ ਲਈਃ >>> by_length(std::vector<long>{(long) 2, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3}))) (std::vector<std::string>{(std::string) ""Eight"", (std::string) ""Five"", (std::string) ""Four"", (std::string) ""Three"", (std::string) ""Two"", (std::string) ""Two"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"" ਨਾਲ ਬਦਲੋ. ਉਦਾਹਰਣ ਲਈਃ >>> by_length_length:{string}, (std:{(long}, (std:{(std::string}, (std::string}, (long:{(std::string}, (long:}, (long: (((std:},}) (long: (((th: (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਫੰਕਸ਼ਨ f ਨੂੰ ਲਾਗੂ ਕਰੋ ਜੋ n ਨੂੰ ਇੱਕ ਪੈਰਾਮੀਟਰ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ, ਅਤੇ n ਆਕਾਰ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿਵੇਂ ਕਿ ਇੰਡੈਕਸ i ਤੇ ਤੱਤ ਦਾ ਮੁੱਲ i ਦਾ ਫੈਕਟਰਿਅਲ ਹੁੰਦਾ ਹੈ ਜੇ i ਜਮ੍ਹਾ ਹੈ ਜਾਂ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ ਨਹੀਂ ਹੁੰਦਾ. i 1 ਤੋਂ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ. i ਦਾ ਫੈਕਟਰਿਅਲ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ (1 * 2 * . . . * i. ਉਦਾਹਰਣਃ >>> f (((5)) (std:: vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਟੂਪਲ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਜੋੜ ਅਤੇ ਅਜੀਬ ਪੂਰਨ ਅੰਕ ਦੇ ਪਾਲੀਂਡਰੋਮ ਦੀ ਗਿਣਤੀ ਹੈ ਜੋ ਰੇਂਜ ਦੇ ਅੰਦਰ ਆਉਂਦੀ ਹੈ. ਉਦਾਹਰਨ 1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) ਵਿਆਖਿਆਃ ਪੂਰਨ ਅੰਕ ਪਾਲੀਂਡਰੋਮ 1, 2, 3 ਹਨ, ਉਨ੍ਹਾਂ ਵਿੱਚੋਂ ਇੱਕ ਜੋੜਾ ਹੈ, ਅਤੇ ਉਨ੍ਹਾਂ ਵਿੱਚੋਂ ਦੋ ਅਜੀਬ ਹਨ. ਉਦਾਹਰਨ 2: >>> even_odd_palindrome (((12)) (std::make_tuple ((4, 6)) ਵਿਆਖਿਆਃ ਪੂਰਨ ਅੰਕ ਪਾਲੀਂਡਰੋਮ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11 ਹਨ, ਉਨ੍ਹਾਂ ਵਿੱਚੋਂ ਚਾਰ ਜਣੇ ਹਨ, ਅਤੇ ਉਨ੍ਹਾਂ ਵਿੱਚੋਂ 6 ਅਜੀਬ ਹਨ. ਨੋਟਃ 1. < 1 = n = 10 ^ 3 2. ਵਾਪਸ ਕੀਤੇ ਟੂਪਲ ਵਿੱਚ ਕ੍ਰਮਵਾਰ ਜੋੜ ਅਤੇ ਅਜੀਬ ਪੂਰਨ ਅੰਕ ਪਾਲੀਂਡਰੋਮ ਦੀ ਗਿਣਤੀ ਹੈ.
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ count_nums ਲਿਖੋ ਜੋ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਤੱਤਾਂ ਦੀ ਸੰਖਿਆ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਅੰਕ ਦਾ ਜੋੜ ਹੈ > 0. ਜੇ ਕੋਈ ਨੰਬਰ ਨਕਾਰਾਤਮਕ ਹੈ, ਤਾਂ ਇਸਦਾ ਪਹਿਲਾ ਦਸਤਖਤ ਕੀਤਾ ਅੰਕ ਨਕਾਰਾਤਮਕ ਹੋਵੇਗਾਃ ਉਦਾਹਰਣ ਵਜੋਂ -123 ਦੇ ਦਸਤਖਤ ਕੀਤੇ ਅੰਕ ਹਨ -1, 2, ਅਤੇ 3. >>> count_nums{((std::vector<long>())) (0) >>> count_nums{(std::vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums::std::vector<long>{(long) 1, (long) 1, (long) 2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਾਡੇ ਕੋਲ N ਪੂਰਨ ਅੰਕ arr[1], arr[2], ..., arr[N] ਦਾ ਇੱਕ ਵੈਕਟਰ 'arr' ਹੈ। ਵੈਕਟਰ ਵਿੱਚ ਨੰਬਰ ਬੇਤਰਤੀਬੇ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਜਾਣਗੇ। ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਤੇ ਹੇਠ ਲਿਖੀ ਕਾਰਵਾਈ ਕਰਕੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਗੈਰ-ਘਟਾਉਣ ਵਾਲੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰਨਾ ਸੰਭਵ ਹੈ: ਤੁਹਾਨੂੰ ਕਿਸੇ ਵੀ ਸਮੇਂ ਸੱਜੇ ਪਾਸੇ ਜਾਣ ਦੀ ਕਾਰਵਾਈ ਕਰਨ ਦੀ ਆਗਿਆ ਹੈ। ਇੱਕ ਸੱਜੇ ਪਾਸੇ ਜਾਣ ਦੀ ਕਾਰਵਾਈ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਵੈਕਟਰ ਦੇ ਸਾਰੇ ਤੱਤਾਂ ਨੂੰ ਸਹੀ ਦਿਸ਼ਾ ਵਿੱਚ ਇੱਕ ਸਥਿਤੀ ਦੁਆਰਾ ਬਦਲਣਾ। ਵੈਕਟਰ ਦਾ ਆਖਰੀ ਤੱਤ ਵੈਕਟਰ ਵਿੱਚ ਸ਼ੁਰੂਆਤੀ ਸਥਿਤੀ ਵਿੱਚ ਚਲੇ ਜਾਵੇਗਾ ਭਾਵ 0 ਵੀਂ ਇੰਡੈਕਸ. ਜੇ ਉਪਰੋਕਤ ਕਾਰਵਾਈ ਕਰਕੇ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰ ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਹੈ ਤਾਂ ਵਾਪਸੀ ਸੱਚੀ ਵਾਪਸੀ ਗਲਤ ਹੈ. ਜੇ ਦਿੱਤਾ ਗਿਆ ਵੈਕਟਰ ਖਾਲੀ ਹੈ ਤਾਂ ਵਾਪਸੀ ਸੱਚੀ ਵਾਪਸੀ. ਨੋਟਃ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਨੂੰ ਵਿਲੱਖਣਸ਼ੀਲ ਤੱਤ ਪ੍ਰਾਪਤ ਕਰਨ ਦੀ ਗਰੰਟੀ ਹੈ। ਉਦਾਹਰਣ ਲਈਃ >>> move_one_ball_{(st_vector}<<{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਸ ਸਮੱਸਿਆ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋਗੇ ਜੋ ਦੋ ਵੈਕਟਰਾਂ ਦੀ ਗਿਣਤੀ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਇਹ ਨਿਰਧਾਰਤ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਉਹਨਾਂ ਦੇ ਵਿਚਕਾਰ ਤੱਤਾਂ ਦਾ ਆਦਾਨ-ਪ੍ਰਦਾਨ ਕਰਨਾ ਸੰਭਵ ਹੈ ਤਾਂ ਜੋ lst1 ਨੂੰ ਸਿਰਫ ਜੋੜਿਆਂ ਦੀ ਗਿਣਤੀ ਦਾ ਵੈਕਟਰ ਬਣਾਇਆ ਜਾ ਸਕੇ. lst1 ਅਤੇ lst2 ਦੇ ਵਿਚਕਾਰ ਵਟਾਂਦਰੇ ਵਾਲੇ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਦੀ ਕੋਈ ਸੀਮਾ ਨਹੀਂ ਹੈ. ਜੇ lst1 ਅਤੇ lst2 ਦੇ ਵਿਚਕਾਰ ਤੱਤਾਂ ਦਾ ਆਦਾਨ-ਪ੍ਰਦਾਨ ਕਰਨਾ ਸੰਭਵ ਹੈ ਤਾਂ ਕਿ lst1 ਦੇ ਸਾਰੇ ਤੱਤ ਵੀ ਹੋ ਸਕਣ, ""YES"" ਵਾਪਸ ਕਰੋ. ਨਹੀਂ ਤਾਂ, ""NO"" ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣ ਲਈਃ >>> exchange((std::vector<>(long) 1, (long) 2, (long) 3, (long) 4})), (std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}), (std::vector<>(long) 4}))) (""YES"") >>> exchange::{d::vector<>{(long>{1, (long) 2, (long) 3, (long) 4} (std::vector<>(long) NO: {5, (long)) (long) (long)) ਇਹ ਮੰਨ ਲਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇੰਪੁੱਟਣ ਗ਼ੈਰ-ਖਾਲੀ ਹੈ।
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਸਪੇਸ ਵੱਖਰੇ ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, ਸਭ ਤੋਂ ਵੱਧ ਦੁਹਰਾਉਣ ਵਾਲੇ ਅੱਖਰ ਦਾ ਨਕਸ਼ਾ ਵਾਪਸ ਕਰੋ ਅਤੇ ਇਸਦੀ ਗਿਣਤੀ ਸ਼ਾਮਲ ਕਰੋ. ਜੇ ਕਈ ਅੱਖਰਾਂ ਦੀ ਇੱਕੋ ਜਿਹੀ ਘਟਨਾ ਹੈ, ਤਾਂ ਉਨ੍ਹਾਂ ਸਾਰਿਆਂ ਨੂੰ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣਃ >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਬੀ ""}, ""{"" ਸੀ ""}) >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਬੀ ""}, ""{"" ਸੀ ""}) >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਏ ""}, ""{"" ਬੀ ""}) >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਏ ""}, ""{"" ਬੀ ""}) >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਏ ""}, ""{"" ਬੀ ""} "" >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਬੀ ""} >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, ""{"" ਬੀ ""}, ""{"" ਬੀ ""} >>> ਹਿਸਟੋਗ੍ਰਾਮ ""{"" ਏ ""}, "" (ਲੰ))
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਟਾਸਕ ਸਾਨੂੰ ਦੋ ਸਤਰਾਂ s ਅਤੇ c ਦਿੱਤੀਆਂ ਗਈਆਂ ਹਨ, ਤੁਹਾਨੂੰ s ਵਿੱਚ ਸਾਰੇ ਅੱਖਰਾਂ ਨੂੰ ਮਿਟਾਉਣਾ ਪਵੇਗਾ ਜੋ c ਵਿੱਚ ਕਿਸੇ ਵੀ ਅੱਖਰ ਦੇ ਬਰਾਬਰ ਹਨ ਫਿਰ ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਨਤੀਜਾ ਸਤਰ ਪਾਲੀਂਡਰੋਮ ਹੈ. ਇੱਕ ਸਤਰ ਨੂੰ ਪਾਲੀਂਡਰੋਮ ਕਿਹਾ ਜਾਂਦਾ ਹੈ ਜੇ ਇਹ ਅੱਗੇ ਦੇ ਸਮਾਨ ਪੜ੍ਹਦਾ ਹੈ. ਤੁਹਾਨੂੰ ਜਾਂਚ ਲਈ ਨਤੀਜਾ ਸਤਰ ਅਤੇ ਸੱਚਾ / ਗਲਤ ਵਾਲਾ ਇੱਕ ਟੁਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਉਦਾਹਰਨ >>> reverse_delete((""abcde""), (""ae"")) (std::make_tuple(""bcd"", false)) >>> reverse_delete(""abcdef""), (""b"") (std::make_tuple(""acdef"",)) >>> reverse_delete(""abcded"", false)) >>> reverse_delete((abcded"", false)) (std::make_tuple"", true))
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਤਰਾਂ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਜਿੱਥੇ ਹਰੇਕ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੰਕ ਹੁੰਦੇ ਹਨ, ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰੋ. ਆਉਟਪੁੱਟ ਦੇ ਹਰੇਕ ਤੱਤ i ਨੂੰ ""ਇਨਪੁਟ ਦੇ ਸਤਰ i ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ"" ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਜਿੱਥੇ ਸਾਰੇ i ਨੂੰ ਇੰਪੁੱਟ ਦੇ i'th ਸਤਰ ਵਿੱਚ ਅਜੀਬ ਅੰਕ ਦੀ ਗਿਣਤੀ ਨਾਲ ਬਦਲਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({stdstring) "" 4n ਦੇ str4ng 4 ਦੇ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ 4n. ""})) >>> odd_count(stdvector<stdstring>::{(stdstring) "", ""3 (stdstring) ""::""""1111""11""))) (stdvector<stdstring::{stdstring>:n) 1n. "" (((string) 1n. 8n. "" 8n. 8n. "" (string) ਦੇ 8n. 8n. ""
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ n ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਕਿਸੇ ਵੀ ਗੈਰ-ਖਾਲੀ ਸਬ-ਵੈਕਟਰ ਦਾ ਘੱਟੋ ਘੱਟ ਜੋੜ ਲੱਭੋ. ਉਦਾਹਰਨ >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਖੂਹਾਂ ਦਾ ਇੱਕ ਆਇਤਾਕਾਰ ਗਰਿੱਡ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਹਰ ਕਤਾਰ ਇੱਕ ਸਿੰਗਲ ਖੂਹ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, ਅਤੇ ਇੱਕ ਕਤਾਰ ਵਿੱਚ ਹਰੇਕ 1 ਪਾਣੀ ਦੀ ਇੱਕ ਇਕਾਈ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ. ਹਰੇਕ ਖੂਹ ਵਿੱਚ ਇੱਕ ਸੰਬੰਧਿਤ ਬਾਲਟੀ ਹੁੰਦੀ ਹੈ ਜਿਸਦੀ ਵਰਤੋਂ ਇਸ ਤੋਂ ਪਾਣੀ ਕੱractਣ ਲਈ ਕੀਤੀ ਜਾ ਸਕਦੀ ਹੈ, ਅਤੇ ਸਾਰੀਆਂ ਬਾਲਟੀਆਂ ਦੀ ਸਮਾਨ ਸਮਰੱਥਾ ਹੁੰਦੀ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਖੂਹਾਂ ਨੂੰ ਖਾਲੀ ਕਰਨ ਲਈ ਬਾਲਟੀਆਂ ਦੀ ਵਰਤੋਂ ਕਰਨਾ ਹੈ. ਬਕਸੇ ਨੂੰ ਘਟਾਉਣ ਲਈ ਤੁਹਾਨੂੰ ਕਿੰਨੀ ਵਾਰ ਲੋੜੀਂਦੀ ਹੈ ਦੀ ਗਿਣਤੀ ਆਉਟਪੁੱਟ ਕਰੋ. ਉਦਾਹਰਣ 1: >>> max_fill((std::vector<std::vector<std::vector<long>, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇਸ ਕਾਟਾ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਆਪਣੇ ਬਾਈਨਰੀ ਪ੍ਰਤੀਨਿਧਤਾ ਵਿੱਚ ਇੱਕ ਦੀ ਗਿਣਤੀ ਦੇ ਅਨੁਸਾਰ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰਨ ਦੀ ਲੋੜ ਹੈ। ਇੱਕ ਦੀ ਸਮਾਨ ਗਿਣਤੀ ਲਈ, ਦਸ਼ਮਲਵ ਮੁੱਲ ਦੇ ਅਧਾਰ ਤੇ ਕ੍ਰਮਬੱਧ ਕਰੋ. ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਲਾਗੂ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈਃ >>> sort_array((std:: vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std:: vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5})) >>> sort_array(std:: vector<long>{(long-2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std:: vector<long>{(long>{-6, (long) 5, (long) 4, (long) 3, (long) 2} >>> sort_array: vector<long>{(long>1, (long) 3, (long) 4, (long) 2, (long) (long)) (long) (long) (long)
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ s ਅਤੇ ਇੱਕ ਕੁਦਰਤੀ ਸੰਖਿਆ n ਦਿੱਤੀ ਗਈ ਹੈ, ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰਨ ਦਾ ਕੰਮ ਦਿੱਤਾ ਗਿਆ ਹੈ ਜੋ ਸਤਰ s ਦੇ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਬਿਲਕੁਲ n ਧੁਨੀ ਹੁੰਦੇ ਹਨ, ਤਾਂ ਜੋ ਇਹ ਸ਼ਬਦ ਸਤਰ s ਵਿੱਚ ਪ੍ਰਗਟ ਹੋਣ। ਜੇ ਸਤਰ s ਖਾਲੀ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਵੈਕਟਰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇੰਪੁੱਟ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੱਖਰ ਅਤੇ ਸਪੇਸ ਹਨ. ਉਦਾਹਰਣਃ >>> select_words((""ਮੈਰੀ ਕੋਲ ਇੱਕ ਛੋਟਾ ਲੇਲਾ ਸੀ""), (4)) (std::vector<std::string>({(std::string) ""ਛੋਟਾ""} >>> select_words""), (3)) (std::vector<std::string>) ""ਮੈਰੀ ਕੋਲ ਇੱਕ ਛੋਟਾ ਲੇਲਾ ਸੀ""), (3) (std::vector<std::string>) ""ਮੈਰੀ"", (std::string>) ""ਬ"" (b)) >>> select_words ""ਸਧਾਰਨ ਚਿੱਟਾ"" (""simple white""), (2) (std::vector<std::string>) ""<std::string>""::std::string> (""ਮੈਰੀ ਕੋਲ ਇੱਕ ਛੋਟਾ ਲੇਲਾ ਸੀ""), (4) (ਮੈਟਲੌਕ ਸੰਸਾਰ ਵਿੱਚ ""ਮੈਰੀ"" ਸੀ) >>> (<string> (<string>) >>> (<string> (ਹੈਟਰ ""ਹੈਲੋਟ""<string>) >>> (<string>)
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਸ਼ਬਦ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਸੱਜੇ ਪਾਸੇ ਤੋਂ ਦੋ ਧੁਨੀ ਦੇ ਵਿਚਕਾਰ ਖੜ੍ਹੇ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਵੋਕਲ ਨੂੰ ਲੱਭਣਾ ਹੈ (ਕੇਸ ਸੰਵੇਦਨਸ਼ੀਲ). ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ ਵੋਕਲ ਦੀ ਗਿਣਤੀ ਨਹੀਂ ਕੀਤੀ ਜਾਂਦੀ. ਜੇ ਤੁਸੀਂ ਉਪਰੋਕਤ ਸ਼ਰਤ ਨੂੰ ਪੂਰਾ ਕਰਨ ਵਾਲੇ ਕੋਈ ਵੀ ਵੋਕਲ ਨਹੀਂ ਲੱਭਦੇ ਤਾਂ ਖਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰੋ. ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਦਿੱਤੀ ਗਈ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੰਗਰੇਜ਼ੀ ਅੱਖਰ ਹਨ. ਉਦਾਹਰਨਃ >>> get_closest_vowel (((""yogurt"")) (""u"") >>> get_closest_vowel (((""FULL"")) (""U"") >>> get_closest_vowel (((""quick"")) ("""") >>> get_closest_vowel ((((ab"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਦੋ ਸਤਰਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਦੋਵੇਂ ਸਤਰਾਂ ਵਿੱਚ ਸਿਰਫ ਖੁੱਲੇ ਬਰਾਂਟੈਸੇਜ਼ '(' ਜਾਂ ਬੰਦ ਬਰਾਂਟੈਸੇਜ਼ ') ' ਸ਼ਾਮਲ ਹਨ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚਣਾ ਹੈ ਕਿ ਕੀ ਦੋ ਸਤਰਾਂ ਨੂੰ ਕਿਸੇ ਕ੍ਰਮ ਵਿੱਚ ਜੋੜਨਾ ਸੰਭਵ ਹੈ, ਕਿ ਨਤੀਜਾ ਸਤਰ ਚੰਗੀ ਹੋਵੇਗੀ. ਇੱਕ ਸਤਰ S ਨੂੰ ਚੰਗੀ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇ ਅਤੇ ਸਿਰਫ ਜੇ S ਵਿੱਚ ਸਾਰੇ ਬਰਾਂਟੈਸੇਜ਼ ਸੰਤੁਲਿਤ ਹਨ. ਉਦਾਹਰਣ ਲਈਃ ਸਤਰ '(())) ' ਚੰਗੀ ਹੈ, ਜਦੋਂ ਕਿ ਸਤਰ '()) ' ਨਹੀਂ ਹੈ. ਜੇ ਇੱਕ ਚੰਗੀ ਸਤਰ ਬਣਾਉਣ ਦਾ ਕੋਈ ਤਰੀਕਾ ਹੈ ਤਾਂ 'ਹਾਂ' ਵਾਪਸ ਕਰੋ, ਅਤੇ ਨਹੀਂ ਤਾਂ 'ਨਹੀਂ' ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣਃ >>> match_parens(std::vector<std::string>{((stdstring) "") "", ((std::string) "")) (""ਹਾਂ"") >>> match_parens<std::vector<std>{(std::string>"" ((std"") (""ਨਹੀਂ""))))
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਅਤੇ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਆਰਰ ਵਿੱਚ ਵੱਧ ਤੋਂ ਵੱਧ k ਨੰਬਰਾਂ ਦੇ ਨਾਲ ਲੰਬਾਈ k ਦੇ ਇੱਕ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰ ਨੂੰ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਨ 1: >>> ਅਧਿਕਤਮ (((std::vector<long>({(long) -3, (long) -4, (long) -4, (long) -5,)), (3)) (std::vector<long>({(long) -4, (long) -3, (long) -5}) ਉਦਾਹਰਨ 2: >>> ਅਧਿਕਤਮ (((std::vector<long>({(long) -4, (long) -4, (long) -4})), (2)) (std::vector<long>{(long) -4, (long) -4})) ਉਦਾਹਰਨ 3: >>> ਅਧਿਕਤਮ (((std::vector<<long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1,) (1) (std::vector<long>) -2: 1. ਵੈਕਟਰ ਦੀ ਲੰਬਾਈ 1000 ਦੇ ਅੰਦਰ ਹੋਵੇਗੀ. ਵੈਕਟਰ ਦੀ ਲੰਬਾਈ 1000 ਦੇ ਅੰਦਰ ਹੋਵੇਗੀ. ਨੋਟ ਕਰੋ ਕਿ ਵੈਕਟਰ ਦੀ ਲੰਬਾਈ 0 ਤੋਂ 1000 ਦੇ ਅੰਦਰ ਹੋਵੇਗੀ.
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਸਾਰੇ ਅਜੀਬ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ ਵੀ ਸਥਿਤੀ ਵਿੱਚ ਹਨ. ਉਦਾਹਰਣ >>> ਹੱਲ((std:: vector<long>({(long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> ਹੱਲ(((std:: vector<long>({(long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> ਹੱਲ(((std:: vector<>(({(long) 30, (long) 13, (long) 24, (long) 321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਪੂਰਨ ਅੰਕ arr ਅਤੇ ਪੂਰਨ ਅੰਕ k ਦੇ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, arr ਦੇ ਪਹਿਲੇ k ਤੱਤਾਂ ਤੋਂ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਅੰਕਾਂ ਵਾਲੇ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣਃ >>> add_elements((std::vector<long>({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) ਕੰਟਰੈਕਟਸਃ 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕਾਲੈਟਜ਼ ਕ੍ਰਮ ਵਿੱਚ ਅਜੀਬ ਨੰਬਰ ਹਨ. ਕੋਲੈਟਜ਼ ਅਨੁਮਾਨ ਗਣਿਤ ਵਿੱਚ ਇੱਕ ਅਨੁਮਾਨ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕ੍ਰਮ ਨਾਲ ਸਬੰਧਤ ਹੈਃ ਕਿਸੇ ਵੀ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਨਾਲ ਸ਼ੁਰੂ ਕਰੋ. ਫਿਰ ਹਰ ਅਵਧੀ ਨੂੰ ਪਿਛਲੇ ਅਵਧੀ ਤੋਂ ਪ੍ਰਾਪਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ ਜਿਵੇਂ ਕਿਃ ਜੇ ਪਿਛਲੀ ਅਵਧੀ ਜਮ੍ਹਾ ਹੈ, ਤਾਂ ਅਗਲੀ ਅਵਧੀ ਪਿਛਲੀ ਅਵਧੀ ਦਾ ਅੱਧਾ ਹੈ. ਜੇ ਪਿਛਲੀ ਅਵਧੀ ਅਜੀਬ ਹੈ, ਤਾਂ ਅਗਲੀ ਅਵਧੀ ਪਿਛਲੀ ਅਵਧੀ ਦੇ 3 ਗੁਣਾ ਹੈ ਅਤੇ 1. ਅਨੁਮਾਨ ਇਹ ਹੈ ਕਿ n ਦਾ ਕੋਈ ਵੀ ਮੁੱਲ ਹੋਵੇ, ਕ੍ਰਮ ਹਮੇਸ਼ਾਂ 1. ਨੋਟਃ 1. ਕੋਲੈਟਜ਼ (((1) ਹੈ [1] 2. ਵਾਪਸ ਕੀਤੇ ਵੈਕਟਰ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾਂਦਾ ਹੈ. ਉਦਾਹਰਣ ਲਈਃ get_odd_collatz5) ਵਾਪਸ ਕਰਦਾ ਹੈ [1, 5] 5 ਲਈ ਕੋਲੈਟਜ਼ ਕ੍ਰਮ [5, 8, 16, 4, 2, 1], ਇਸ ਲਈ ਅਜੀਬ ਨੰਬਰ ਸਿਰਫ 1, ਅਤੇ 5 ਹਨ >>> get_odd_collatz (((5) (ਸ੍ਟ੍ਰੀਟਵੈਕਟਰ::d (<<((ਲੰਮੇਰ} (ਲੰਮੇਰਃ (ਲੰ))
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਇੱਕ ਦਿੱਤੀ ਗਈ ਤਾਰੀਖ ਸਤਰ ਨੂੰ ਪ੍ਰਮਾਣਿਤ ਕਰਦੀ ਹੈ ਅਤੇ ਜੇ ਤਾਰੀਖ ਪ੍ਰਮਾਣਿਤ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਨਹੀਂ ਤਾਂ ਗਲਤ ਹੈ. ਤਾਰੀਖ ਪ੍ਰਮਾਣਿਤ ਹੈ ਜੇ ਹੇਠ ਲਿਖੇ ਸਾਰੇ ਨਿਯਮ ਸੰਤੁਸ਼ਟ ਹਨਃ 1. ਤਾਰੀਖ ਸਤਰ ਖਾਲੀ ਨਹੀਂ ਹੈ. 2. ਮਹੀਨਿਆਂ ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 31 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ 1,3,5,7,8,10,12. ਅਤੇ ਮਹੀਨਿਆਂ ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 30 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ 4,6,9,11. ਅਤੇ, ਮਹੀਨੇ ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 29 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ 2. ਮਹੀਨਿਆਂ ਤੋਂ ਘੱਟ ਜਾਂ 1 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੋਣਾ ਚਾਹੀਦਾ 4. ਤਾਰੀਖ ਫਾਰਮੈਟ ਵਿੱਚ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈਃ mm-dd-yyyy >>> valid_(date((103-11-2000"")) (ਸੱਚਾ >>> valid_date((15-01-2012"")) (ਗਲਤ) >>> valid_date(04-040-20"") (ਗਲਤ) >>> valid_(date_(06-2020"") (ਸੱਚਾ >>> valid_date""06/04/2020) (ਗਲਤ)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਵਾਈਟਸਪੇਸ ਤੇ ਵੰਡਿਆ ਸ਼ਬਦਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰੋ, ਜੇ ਟੈਕਸਟ ਵਿੱਚ ਕੋਈ ਵਾਈਟਸਪੇਸ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਤੁਹਾਨੂੰ ਕਾਮਿਆਂ 'ਤੇ ਵੰਡਣਾ ਚਾਹੀਦਾ ਹੈ,' ਜੇ ਕੋਈ ਕਾਮੇ ਮੌਜੂਦ ਨਹੀਂ ਹਨ ਤਾਂ ਤੁਹਾਨੂੰ ਅਲਫ਼ਾਬੈੱਟ ਵਿੱਚ ਅਜੀਬ ਕ੍ਰਮ ਦੇ ਨਾਲ ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ, ਆਰਡਰ (a) = 0, ਆਰਡਰ (b) = 1, . . . ਆਰਡਰ (z) = 25 ਉਦਾਹਰਣਾਂ >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d) >>> ਸਪਲਿਟ_ਵਰਡਸ (d)) 3
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਨੰਬਰਾਂ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਵਾਪਸ ਕਰੋ ਕਿ ਕੀ ਉਹ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਗਏ ਹਨ ਜਾਂ ਨਹੀਂ. ਜੇ ਵੈਕਟਰ ਵਿੱਚ ਇੱਕੋ ਨੰਬਰ ਦੀ 1 ਤੋਂ ਵੱਧ ਡੁਪਲੀਕੇਟ ਹੈ, ਤਾਂ ਗਲਤ ਵਾਪਸ ਕਰੋ. ਕੋਈ ਨਕਾਰਾਤਮਕ ਨੰਬਰ ਅਤੇ ਸਿਰਫ ਪੂਰਨ ਅੰਕ ਮੰਨ ਲਓ. ਉਦਾਹਰਣ >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long)
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਦੋ ਅੰਤਰਾਲ ਦਿੱਤੇ ਗਏ ਹਨ, ਜਿੱਥੇ ਹਰੇਕ ਅੰਤਰਾਲ ਪੂਰਨ ਅੰਕ ਦੀ ਜੋੜੀ ਹੈ। ਉਦਾਹਰਣ ਲਈ, ਅੰਤਰਾਲ = (ਸ਼ੁਰੂਆਤ, ਅੰਤ) = (1, 2). ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਬੰਦ ਹਨ ਜਿਸਦਾ ਮਤਲਬ ਹੈ ਕਿ ਅੰਤਰਾਲ (ਸ਼ੁਰੂਆਤ, ਅੰਤ) ਵਿੱਚ ਸ਼ੁਰੂਆਤ ਅਤੇ ਅੰਤ ਦੋਵੇਂ ਸ਼ਾਮਲ ਹਨ। ਹਰੇਕ ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਲਈ, ਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਸਦੀ ਸ਼ੁਰੂਆਤ ਇਸ ਦੇ ਅੰਤ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ। ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਇਨ੍ਹਾਂ ਦੋਵਾਂ ਅੰਤਰਾਲਾਂ ਦੀ ਲੜੀ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹੈ। ਉਦਾਹਰਣ ਵਜੋਂ, ਅੰਤਰਾਲਾਂ (1, 3), (2, 4) ਦੀ ਲੜੀ (2, 3) ਹੈ, ਜਿਸਦੀ ਲੰਬਾਈ 1 ਹੈ, ਜੋ ਕਿ ਇੱਕ ਪ੍ਰਾਇਮ ਨੰਬਰ ਨਹੀਂ ਹੈ। ਜੇ ਲੜੀ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹੈ, ਤਾਂ ""ਹਾਂ"" ਵਾਪਸ ਕਰੋ, ਨਹੀਂ ਤਾਂ ""ਨਹੀਂ"" ਵਾਪਸ ਕਰੋ। ਜੇ ਦੋ ਅੰਤਰਾਲ ਨਹੀਂ ਟਕਰਾਉਂਦੇ, ਤਾਂ ""ਨਹੀਂ"" ਵਾਪਸ ਕਰੋ. [input/output] ਨਮੂਨੇਃ >>> intersection::((dmake_tuple1, 2), ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦੇ ਅਕਾਰ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਨ ਦੀ ਜ਼ਰੂਰਤ ਹੈ ਜੋ ਵੈਕਟਰ ਵਿੱਚ ਹਰੇਕ ਨੰਬਰ ਦੇ ਸਾਰੇ ਸੰਕੇਤਾਂ ਦੇ ਉਤਪਾਦ ਦੁਆਰਾ ਗੁਣਾ ਕੀਤਾ ਗਿਆ ਹੈ, ਜਿਸਦਾ ਪ੍ਰਤੀਨਿਧਤਾ 1, -1 ਜਾਂ 0 ਦੁਆਰਾ ਕੀਤੀ ਗਈ ਹੈ. ਨੋਟਃ ਖਾਲੀ ਆਰ ਲਈ ਕੋਈ ਨਹੀਂ ਵਾਪਿਸ ਉਦਾਹਰਣਃ >>> prod_signs(((std::vector<long>{(long) 1, (long) 2, (long) 2, (long) -4}))) 9 >>> prod_signs(std::vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs((std::vector<long>(())) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// N ਕਤਾਰਾਂ ਅਤੇ N ਕਾਲਮਾਂ (N >= 2) ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k ਦੇ ਨਾਲ ਇੱਕ ਗਰਿੱਡ ਦਿੱਤੀ ਗਈ ਹੈ, ਗਰਿੱਡ ਦੇ ਹਰੇਕ ਸੈੱਲ ਵਿੱਚ ਇੱਕ ਮੁੱਲ ਹੁੰਦਾ ਹੈ. [1, N * N] ਦੀ ਰੇਂਜ ਵਿੱਚ ਹਰੇਕ ਪੂਰਨ ਅੰਕ ਗਰਿੱਡ ਦੇ ਸੈੱਲਾਂ ਤੇ ਬਿਲਕੁਲ ਇੱਕ ਵਾਰ ਦਿਖਾਈ ਦਿੰਦਾ ਹੈ. ਤੁਹਾਨੂੰ ਗਰਿੱਡ ਵਿੱਚ ਲੰਬਾਈ k ਦੀ ਘੱਟੋ ਘੱਟ ਮਾਰਗ ਲੱਭਣੀ ਪਵੇਗੀ. ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਸੈੱਲ ਤੋਂ ਸ਼ੁਰੂ ਕਰ ਸਕਦੇ ਹੋ, ਅਤੇ ਹਰ ਕਦਮ ਵਿੱਚ ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਗੁਆਂਢੀ ਸੈੱਲਾਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ, ਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਸੈੱਲਾਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ ਜੋ ਤੁਹਾਡੇ ਨਾਲ ਇੱਕ ਕਿਨਾਰੇ ਨੂੰ ਸਾਂਝਾ ਕਰਦੇ ਹਨ ਮੌਜੂਦਾ ਸੈੱਲ. ਕਿਰਪਾ ਕਰਕੇ ਨੋਟ ਕਰੋ ਕਿ k ਦੀ ਲੰਬਾਈ ਦਾ ਮਾਰਗ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਬਿਲਕੁਲ k ਸੈੱਲਾਂ ਦਾ ਦੌਰਾ ਕਰਨਾ (ਜ਼ਰੂਰੀ ਨਹੀਂ ਕਿ ਵੱਖਰਾ ਹੋਵੇ). ਤੁਸੀਂ ਗਰਿੱਡ ਤੋਂ ਬਾਹਰ ਨਹੀਂ ਜਾ ਸਕਦੇ. ਇੱਕ ਮਾਰਗ A (ਲੰਬਾਈ k) ਨੂੰ ਇੱਕ ਮਾਰਗ B (ਲੰਬਾਈ k) ਤੋਂ ਘੱਟ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇ ਸੈੱਲਾਂ ਤੇ ਮੁੱਲਾਂ ਦੇ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰਾਂ ਨੂੰ ਬਣਾਉਣ ਤੋਂ ਬਾਅਦ ਜੋ A ਅਤੇ B ਦੁਆਰਾ ਜਾਂਦੇ ਹਨ (ਆਓਏ ਉਨ੍ਹਾਂ ਨੂੰ l_st ਅਤੇ l_stA_st_Bst_B) ਕਹਿੰਦੇ ਹਨ), l_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਹਰ ਕੋਈ ਫਿਬੋਨਾਚੀ ਕ੍ਰਮ ਨੂੰ ਜਾਣਦਾ ਹੈ, ਇਸ ਨੂੰ ਪਿਛਲੇ ਕੁਝ ਸਦੀਆਂ ਵਿੱਚ ਗਣਿਤ ਵਿਗਿਆਨੀਆਂ ਦੁਆਰਾ ਡੂੰਘਾਈ ਨਾਲ ਅਧਿਐਨ ਕੀਤਾ ਗਿਆ ਸੀ. ਹਾਲਾਂਕਿ, ਜੋ ਲੋਕ ਨਹੀਂ ਜਾਣਦੇ ਉਹ ਟ੍ਰਿਬੋਨੈਚੀ ਕ੍ਰਮ ਹੈ. ਟ੍ਰਿਬੋਨੈਚੀ ਕ੍ਰਮ ਦੀ ਪਰਿਭਾਸ਼ਾ ਦੁਹਰਾਓ ਦੁਆਰਾ ਕੀਤੀ ਗਈ ਹੈਃ tri(1) = 3 tri(n) = 1 + n / 2, ਜੇ n ਜੂੜ ਹੈ. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ਜੇ n ਅਜੀਬ ਹੈ. ਉਦਾਹਰਣ ਲਈਃ tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 ਤੁਹਾਨੂੰ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਟ੍ਰਿਬੋਨੈਚੀ ਕ੍ਰਮ ਦੇ ਪਹਿਲੇ n + 1 ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਹੈ. ਉਦਾਹਰਣਃ >>> tri(3) (dst ਲੰਬੇ ਵੈਕਟਰ><<{(long} (1,3,2,8})
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਅਜੀਬ ਅੰਕ ਦੇ ਉਤਪਾਦ ਨੂੰ ਵਾਪਸ ਕਰੋ. 0 ਵਾਪਸ ਕਰੋ ਜੇ ਸਾਰੇ ਅੰਕ ਵੀ ਹਨ. ਉਦਾਹਰਣ ਲਈਃ >>> ਅੰਕ (((1)) (1) >>> ਅੰਕ (((4)) (0) >>> ਅੰਕ (((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਿਰਫ ਵਰਗ ਬਰੈਕਟ ਹੁੰਦੇ ਹਨ. ਫੰਕਸ਼ਨ ਨੂੰ ਸਹੀ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇ ਅਤੇ ਸਿਰਫ ਜੇ ਬਰੈਕਟਾਂ ਦਾ ਇੱਕ ਵੈਧ ਉਪ-ਕ੍ਰਮ ਹੈ ਜਿੱਥੇ ਘੱਟੋ ਘੱਟ ਇੱਕ ਬਰੈਕਟ ਉਪ-ਕ੍ਰਮ ਵਿੱਚ ਘੁੰਮਿਆ ਹੋਇਆ ਹੈ. >>> is_nested((""[[]]"")) (true) >>> is_nested((""[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਨੰਬਰ ਦੇ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਨੂੰ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਵਿੱਚ ਵਰਗ ਦੇ ਨੰਬਰ ਦੇ ਜੋੜ ਨੂੰ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ, ਪਹਿਲੇ ਵੈਕਟਰ ਵਿੱਚ ਹਰੇਕ ਤੱਤ ਨੂੰ ਉਪਰਲੇ ਇੰਟ (ਸੀਲਿੰਗ) ਤੱਕ ਗੋਲ ਕਰੋ. ਉਦਾਹਰਣਃ >>> lst (ਸੈੱਟ): vector<float> (ਸੈੱਟ) 1.0f, (ਫਲੋਟ) 2.0f, (ਫਲੋਟ) 3.0f)) (14) >>> lst (ਸੈੱਟ): vector<float> (ਸੈੱਟ) 1.0f, (ਫਲੋਟ) 4.0f, (ਫਲੋਟ) 9.0f)) >>> (98) lst (ਸੈੱਟ): vector<float> (ਸੈੱਟ) 1.0f, (ਫਲੋਟ) 3.0f, (ਫਲੋਟ) 5.0f, (ਫਲੋਟ) 7.0f)) (84) >>> lst (ਸੈੱਟ): vector<float> (ਸੈੱਟ) 1.4f, (ਫਲੋਟ) 2.0f, (ਫਲੋਟ) 3.0f)) (6) >>> lst (ਸੈੱਟ): vector<float> (ਫਲੋਟ) 2.0f, (ਫਲੋਟ) 6)) (ਸੈੱਟ): vector<float> (1.0f)
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇ ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਤਰ ਦਾ ਆਖਰੀ ਅੱਖਰ ਇੱਕ ਵਰਣਮਾਲਾ ਅੱਖਰ ਹੈ ਅਤੇ ਇੱਕ ਸ਼ਬਦ ਦਾ ਹਿੱਸਾ ਨਹੀਂ ਹੈ, ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ. ਨੋਟਃ ""ਸ਼ਬਦ"" ਅੱਖਰਾਂ ਦਾ ਇੱਕ ਸਮੂਹ ਹੈ ਜੋ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤਾ ਗਿਆ ਹੈ. ਉਦਾਹਰਣਃ >>> ਚੈੱਕ_ਇਫ_ਲਾਸਟ_ਚਾਰ_ਇਜ਼_ਏ_ਲੈਟਰ (((""ਐਪਲ ਪਾਈ"")) (ਝੂਠੀ) >>> ਚੈੱਕ_ਇਫ_ਲਾਸਟ_ਚਾਰ_ਇਜ਼_ਏ_ਲੈਟਰ (((""ਐਪਲ ਪਾਈ ਈ"")) (ਸੱਚ) >>> ਚੈੱਕ_ਇਫ_ਲਾਸਟ_ਚਾਰ_ਇਜ਼_ਏ_ਲੈਟਰ "")) (ਝੂਠੀ) >>> ਚੈੱਕ_ਇਫ_ਲਾਸਟ_ਚਾਰ_ਇਜ਼_ਏ_ਲੈਟਰ "")) (ਝੂਠੀ)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਕਿਸੇ ਐਲੀਮੈਂਟ ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਇੰਡੈਕਸ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਇਸ ਤੋਂ ਪਹਿਲਾਂ ਦੇ ਐਲੀਮੈਂਟ ਦੇ ਬਰਾਬਰ ਜਾਂ ਬਰਾਬਰ ਨਹੀਂ ਹੁੰਦਾ। ਜੇ ਅਜਿਹਾ ਕੋਈ ਐਲੀਮੈਂਟ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਵਾਪਸੀ -1. ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਵਿੱਚ ਡੁਪਲਿਕੇਟ ਮੁੱਲ ਨਹੀਂ ਹੋਣਗੇ। ਉਦਾਹਰਣਃ >>> can_arrange(((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਟੁਪਲ (ਏ, ਬੀ) ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿੱਥੇ 'ਏ' ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਹੈ, ਅਤੇ 'ਬੀ' ਇੱਕ ਵੈਕਟਰ ਵਿੱਚ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਾ ਸਭ ਤੋਂ ਛੋਟਾ ਹੈ. ਜੇ ਕੋਈ ਨਕਾਰਾਤਮਕ ਜਾਂ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ, ਤਾਂ ਉਹਨਾਂ ਨੂੰ ਨਾਨ ਦੇ ਤੌਰ ਤੇ ਵਾਪਸ ਕਰੋ. ਉਦਾਹਰਣਃ >>> ਸਭ ਤੋਂ ਵੱਡਾ_ਸਭ ਤੋਂ ਛੋਟਾ_ਇੰਟੇਜਰਜ਼ (((std::vector<long>{long>) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7}))) std::make_tuplestd::optional<long>{long>), std::optional<long>{long>) >>> ਸਭ ਤੋਂ ਵੱਡਾ_ਸਭ ਤੋਂ ਛੋਟਾ_ਇੰਟੇਜਰਜ਼ ({long>)
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਪੂਰਨ ਅੰਕ, ਫਲੋਟਸ, ਜਾਂ ਸਤਰਾਂ ਨੂੰ ਅਸਲ ਨੰਬਰਾਂ ਦੀ ਨੁਮਾਇੰਦਗੀ ਕਰਦਾ ਹੈ, ਅਤੇ ਇਸ ਦੇ ਦਿੱਤੇ ਗਏ ਪਰਿਵਰਤਨਸ਼ੀਲ ਕਿਸਮ ਵਿੱਚ ਵੱਡਾ ਪਰਿਵਰਤਨਸ਼ੀਲ ਵਾਪਸ ਕਰਦਾ ਹੈ। ਜੇ ਮੁੱਲ ਬਰਾਬਰ ਹੁੰਦੇ ਹਨ ਤਾਂ ਕੋਈ ਨਹੀਂ ਵਾਪਸ ਕਰਦਾ ਹੈ। ਨੋਟਃ ਜੇ ਇੱਕ ਅਸਲੀ ਨੰਬਰ ਨੂੰ ਸਤਰ ਦੇ ਤੌਰ ਤੇ ਦਰਸਾਇਆ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਹੋ ਸਕਦਾ ਹੈ . ਜਾਂ , >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, ""2,3"") ""2,3"" >>> compare_one(""5,1"", ""6"") ""6"" >>> compare_one(""1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਮੁਲਾਂਕਣ ਕਰੋ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ n ਨੂੰ ਬਿਲਕੁਲ 4 ਸਕਾਰਾਤਮਕ ਜੋੜ ਸੰਖਿਆਵਾਂ ਦੇ ਜੋੜ ਵਜੋਂ ਲਿਖਿਆ ਜਾ ਸਕਦਾ ਹੈ ਉਦਾਹਰਨ >>> is_equal_to_sum_even ((4)) (ਝੂਠ) >>> is_equal_to_sum_even ((6)) (ਝੂਠ) >>> is_equal_to_sum_even ((8)) (ਸੱਚ)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਬ੍ਰਾਜ਼ੀਲੀਅਨ ਫੈਕਟੋਰੀਅਲ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ ਬ੍ਰਾਜ਼ੀਲੀਅਨ_ਫੈਕਟੋਰੀਅਲ ((n) = n! * (n-1)! * (n-2)! * ... * 1! ਜਿੱਥੇ n > 0 ਉਦਾਹਰਣ ਲਈਃ >>> ਵਿਸ਼ੇਸ਼_ਫੈਕਟੋਰੀਅਲ (((4)) (288) ਫੰਕਸ਼ਨ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਇੱਕ ਪੂਰਨ ਅੰਕ ਪ੍ਰਾਪਤ ਹੋਵੇਗਾ ਅਤੇ ਇਸ ਪੂਰਨ ਅੰਕ ਦਾ ਵਿਸ਼ੇਸ਼ ਫੈਕਟੋਰੀਅਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ.
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ ਪਾਠ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਵਿੱਚ ਸਾਰੇ ਸਪੇਸ ਨੂੰ ਅੰਡਰਸਕੋਰ ਨਾਲ ਬਦਲੋ, ਅਤੇ ਜੇ ਇੱਕ ਸਤਰ ਵਿੱਚ 2 ਤੋਂ ਵੱਧ ਲਗਾਤਾਰ ਸਪੇਸ ਹਨ, ਤਾਂ ਸਾਰੇ ਲਗਾਤਾਰ ਸਪੇਸ ਨੂੰ - >>> ਫਿਕਸ_ਸਪੇਸਸ ਨਾਲ ਬਦਲੋ) (ਉਦਾਹਰਣ) (ਉਦਾਹਰਣ) >>> ਫਿਕਸ_ਸਪੇਸਸ (ਉਦਾਹਰਣ 1)) (ਉਦਾਹਰਣ 1"") >>> ਫਿਕਸ_ਸਪੇਸਸ (ਉਦਾਹਰਣ 2)) (ਉਦਾਹਰਣ 2)) >>> ਫਿਕਸ_ਸਪੇਸਸ (ਉਦਾਹਰਣ 3)) (ਉਦਾਹਰਣ 3))
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਫਾਈਲ ਦੇ ਨਾਮ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ, ਅਤੇ 'ਹਾਂ' ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇ ਫਾਈਲ ਦਾ ਨਾਮ ਵੈਧ ਹੈ, ਅਤੇ 'ਨਹੀਂ' ਵਾਪਸ ਕਰਦਾ ਹੈ. ਇੱਕ ਫਾਈਲ ਦਾ ਨਾਮ ਵੈਧ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇ ਅਤੇ ਸਿਰਫ ਤਾਂ ਹੀ ਜੇ ਹੇਠ ਲਿਖੀਆਂ ਸਾਰੀਆਂ ਸ਼ਰਤਾਂ ਪੂਰੀਆਂ ਹੁੰਦੀਆਂ ਹਨਃ - ਫਾਈਲ ਦੇ ਨਾਮ ਵਿੱਚ ਤਿੰਨ ਤੋਂ ਵੱਧ ਅੰਕ ('0'-'9') ਨਹੀਂ ਹੋਣੇ ਚਾਹੀਦੇ. - ਫਾਈਲ ਦੇ ਨਾਮ ਵਿੱਚ ਬਿਲਕੁਲ ਇੱਕ ਬਿੰਦੀ '.' ਸ਼ਾਮਲ ਹੈ. - ਬਿੰਦੀ ਤੋਂ ਪਹਿਲਾਂ ਸਬਸਟ੍ਰਿੰਗ ਖਾਲੀ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ, ਅਤੇ ਇਹ ਲਾਤੀਨੀ ਅੱਖਰ ('a'-'z' ਅਤੇ 'A'-Z') ਤੋਂ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ. - ਬਿੰਦੀ ਦੇ ਬਾਅਦ ਸਬਸਟ੍ਰਿੰਗ ਇਹਨਾਂ ਵਿੱਚੋਂ ਇੱਕ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈਃ ['txt', 'exe', 'll'] ਉਦਾਹਰਣਃ >>> file_name_check""((example.txt"") (""ਹਾਂ"") >>> file_name""(((((1d"" (""ਨਹੀਂ"")
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" ਇਹ ਫੰਕਸ਼ਨ ਪੂਰਨ ਅੰਕ ਦਾ ਵੈਕਟਰ ਲਵੇਗਾ। ਵੈਕਟਰ ਵਿਚਲੇ ਸਾਰੇ ਐਂਟਰੀਆਂ ਲਈ, ਫੰਕਸ਼ਨ ਪੂਰਨ ਅੰਕ ਐਂਟਰੀ ਨੂੰ ਵਰਗ ਬਣਾਏਗਾ ਜੇ ਇਸ ਦਾ ਇੰਡੈਕਸ 3 ਦਾ ਗੁਣਾ ਹੈ ਅਤੇ ਪੂਰਨ ਅੰਕ ਐਂਟਰੀ ਨੂੰ ਘਣ ਕਰੇਗਾ ਜੇ ਇਸ ਦਾ ਇੰਡੈਕਸ 4 ਦਾ ਗੁਣਾ ਹੈ ਅਤੇ 3 ਦਾ ਗੁਣਾ ਨਹੀਂ ਹੈ। ਫੰਕਸ਼ਨ ਵੈਕਟਰ ਵਿਚਲੇ ਐਂਟਰੀਆਂ ਨੂੰ ਨਹੀਂ ਬਦਲਦਾ ਜਿਸ ਦੇ ਇੰਡੈਕਸ 3 ਜਾਂ 4 ਦਾ ਗੁਣਾ ਨਹੀਂ ਹਨ। ਫੰਕਸ਼ਨ ਫਿਰ ਸਾਰੇ ਐਂਟਰੀਆਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੇਗਾ। ਉਦਾਹਰਣਃ >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst ((long)) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਵਾਕ ਨੂੰ ਦਰਸਾਉਣ ਵਾਲੀ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਵਾਕ ਵਿੱਚ ਕੁਝ ਸ਼ਬਦ ਹਨ ਜੋ ਇੱਕ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ ਹਨ, ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਪਵੇਗੀ ਜਿਸ ਵਿੱਚ ਮੂਲ ਵਾਕ ਦੇ ਸ਼ਬਦ ਹਨ, ਜਿਸ ਦੀ ਲੰਬਾਈ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹਨ, ਨਵੀਂ ਸਤਰ ਵਿੱਚ ਸ਼ਬਦਾਂ ਦਾ ਕ੍ਰਮ ਮੂਲ ਦੇ ਸਮਾਨ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ. ਉਦਾਹਰਨ 1: >>> words_in_sentence (((""ਇਹ ਇੱਕ ਟੈਸਟ ਹੈ"")) "") (""is"") ਉਦਾਹਰਨ 2: >>> words_in_sentence (((""lets go for swimming"")) (""go for"") ਪਾਬੰਦੀਆਂਃ * 1 <= len ((sentence) <= 100 * ਵਾਕ ਵਿੱਚ ਸਿਰਫ ਅੱਖਰ ਹਨ
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰਨਾ ਹੈ ਜੋ ਐਕਸਪ੍ਰੈਸ x * n ਨੂੰ ਸਰਲ ਬਣਾ ਦੇਵੇਗਾ. ਫੰਕਸ਼ਨ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇ x * n ਇੱਕ ਪੂਰਨ ਸੰਖਿਆ ਨੂੰ ਮੁਲਾਂਕਣ ਕਰਦਾ ਹੈ ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ. x ਅਤੇ n, ਇੱਕ ਭੰਡਾਰ ਦੀ ਸਤਰ ਪ੍ਰਤੀਨਿਧਤਾ ਹਨ, ਅਤੇ ਹੇਠ ਲਿਖੇ ਫਾਰਮੈਟ, <numerator> / <denominator> ਹੈ ਜਿੱਥੇ ਦੋਵੇਂ ਨੰਬਰ ਅਤੇ ਡੈਨੀਮਨੇਟਰ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਸੰਖਿਆਵਾਂ ਹਨ. ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ x, ਅਤੇ n ਵੈਧ ਭੰਡਾਰ ਹਨ, ਅਤੇ ਡੈਨੀਮਨੇਟਰ ਦੇ ਤੌਰ ਤੇ ਜ਼ੀਰੋ ਨਹੀਂ ਹੈ. >>> ਸਰਲ ਬਣਾਓ (((""1/5""), (""5/1"")) (ਸੱਚਾ) >>> ਸਰਲ ਬਣਾਓ (((""1/6""), (""2/1"")) (ਗਲਤ) >>> ਸਰਲ ਬਣਾਓ (((""7/10""), (""10/2"")) (ਗਲਤ)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਪੂਰਨ ਅੰਕ ਦੇ ਦਿੱਤੇ ਵੈਕਟਰ ਨੂੰ ਉਨ੍ਹਾਂ ਦੇ ਅੰਕ ਦੇ ਜੋੜ ਦੇ ਅਨੁਸਾਰ ਵੱਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰਦਾ ਹੈ. ਨੋਟਃ ਜੇ ਉਨ੍ਹਾਂ ਦੇ ਅੰਕ ਦੇ ਸਮਾਨ ਜੋੜ ਦੇ ਨਾਲ ਕਈ ਆਈਟਮਾਂ ਹਨ, ਤਾਂ ਉਨ੍ਹਾਂ ਨੂੰ ਮੂਲ ਵੈਕਟਰ ਵਿੱਚ ਉਨ੍ਹਾਂ ਦੇ ਇੰਡੈਕਸ ਦੇ ਅਧਾਰ ਤੇ ਕ੍ਰਮਬੱਧ ਕਰੋ. ਉਦਾਹਰਣ ਲਈਃ >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) 1, (long) -12, (long) 11})) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਨੰਬਰਾਂ ਦੇ ਵੈਕਟਰ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਵੈਕਟਰ ਵਿੱਚ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ 10 ਤੋਂ ਵੱਧ ਹੈ ਅਤੇ ਇੱਕ ਨੰਬਰ ਦੇ ਪਹਿਲੇ ਅਤੇ ਆਖਰੀ ਅੰਕ ਦੋਵੇਂ ਅਜੀਬ ਹਨ (1, 3, 5, 7, 9). ਉਦਾਹਰਣ ਲਈਃ >>> specialFilter((std::vector<long>({(long) 15, (long) -73, (long) -14, (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) 33, (long) -2, (long) -3, (long) -45, (long) 21, (long) 109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਨੂੰ ਲੰਬਾਈ n ਦਾ ਇੱਕ ਪੂਰਨ ਅੰਕ ਵੈਕਟਰ ਬਣਾਉਣਾ ਹੈ. ਹਰ i (1 ≤ i ≤ n) ਲਈ, a[i] = i * i - i + 1 ਦਾ ਮੁੱਲ. a ਦੇ ਟ੍ਰਿਪਲਜ਼ (a[i], a[j], a[k]) ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ ਜਿੱਥੇ i < j < k, ਅਤੇ a[i] + a[j] + a[k] 3 ਦਾ ਗੁਣਾ ਹੈ. ਉਦਾਹਰਨਃ >>> get_max_triples((5)) (1) ਵਿਆਖਿਆਃ a = [1, 3, 7, 13, 21] ਇਕੋ ਇਕ ਯੋਗ ਟ੍ਰਿਪਲ (1, 7, 13) ਹੈ.
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਸਾਡੇ ਸੂਰਜੀ ਪ੍ਰਣਾਲੀ ਵਿਚ ਅੱਠ ਗ੍ਰਹਿ ਹਨਃ ਸੂਰਜ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ ਮਰਕੁਰੀ ਹੈ, ਅਗਲਾ ਇਕ ਵੈਨਸ ਹੈ, ਫਿਰ ਧਰਤੀ, ਮੰਗਲ, ਜੁਪੀਟਰ, ਸ਼ਨੀ, ਯੂਰੇਨਸ, ਨੈਪਚੂਨ. ਇਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦੋ ਗ੍ਰਹਿਾਂ ਦੇ ਨਾਮ ਲੈਂਦਾ ਹੈ ਜਿਵੇਂ ਕਿ ਸਤਰਾਂ ਦਾ ਗ੍ਰਹਿ1 ਅਤੇ ਗ੍ਰਹਿ2. ਫੰਕਸ਼ਨ ਨੂੰ ਇਕ ਟੁਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜਿਸ ਵਿਚ ਸਾਰੇ ਗ੍ਰਹਿ ਹਨ ਜਿਨ੍ਹਾਂ ਦੇ ਚੱਕਰ ਗ੍ਰਹਿ1 ਦੇ ਚੱਕਰ ਅਤੇ ਗ੍ਰਹਿ2 ਦੇ ਚੱਕਰ ਦੇ ਵਿਚਕਾਰ ਸਥਿਤ ਹਨ, ਸੂਰਜ ਦੀ ਨੇੜਤਾ ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ. ਫੰਕਸ਼ਨ ਨੂੰ ਇਕ ਖਾਲੀ ਟੁਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇ ਗ੍ਰਹਿ1 ਜਾਂ ਗ੍ਰਹਿ2 ਸਹੀ ਗ੍ਰਹਿ ਨਾਮ ਨਹੀਂ ਹਨ. ਉਦਾਹਰਣ >>> bf((""ਜੁਪੀਟਰ""), (""ਜੁਪੀਟਰ"")) (std::vector<std::string>{((std::string)) ""ਸ਼ਨੀ"", (std::vector) (std::string) ""ਉਰਾਨਸ"" (Uranus)
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਇੱਕ ਪੈਰਾਮੀਟਰ ਦੇ ਤੌਰ ਤੇ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ, ਇਸ ਤੋਂ ਅਣਗਿਣਤ ਲੰਬਾਈ ਵਾਲੇ ਸਤਰਾਂ ਨੂੰ ਮਿਟਾਉਂਦਾ ਹੈ, ਅਤੇ ਨਤੀਜੇ ਵਜੋਂ ਵੈਕਟਰ ਨੂੰ ਇੱਕ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਨਾਲ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਵੈਕਟਰ ਹਮੇਸ਼ਾਂ ਸਤਰਾਂ ਦਾ ਵੈਕਟਰ ਹੁੰਦਾ ਹੈ ਅਤੇ ਕਦੇ ਵੀ ਸੰਖਿਆਵਾਂ ਦਾ ਵੈਕਟਰ ਨਹੀਂ ਹੁੰਦਾ, ਅਤੇ ਇਸ ਵਿੱਚ ਡੁਪਲਿਕੇਟ ਸ਼ਾਮਲ ਹੋ ਸਕਦੇ ਹਨ. ਵੈਕਟਰ ਦਾ ਕ੍ਰਮ ਹਰੇਕ ਸ਼ਬਦ ਦੀ ਲੰਬਾਈ ਦੁਆਰਾ ਚੜ੍ਹਨਾ ਚਾਹੀਦਾ ਹੈ, ਅਤੇ ਤੁਹਾਨੂੰ ਉਸ ਨਿਯਮ ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਜੇ ਦੋ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇਕੋ ਜਿਹੀ ਹੈ, ਤਾਂ ਵੈਕਟਰ ਨੂੰ ਵਰਣਮਾਲਾ ਅਨੁਸਾਰ ਕ੍ਰਮਬੱਧ ਕਰੋ. ਫੰਕਸ਼ਨ ਨੂੰ ਸਤਰਾਂ ਦਾ ਵੈਕਟਰ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇਕੋ ਜਿਹੀ ਹੋਵੇਗੀ. ਉਦਾਹਰਣ ਲਈਃ >>> list_sort{""}std::string{""}st:string{""}st:string{""}st:string{""}st:string{""}st:string{""string} (a) "" (a) "" (a) "" (a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਧਾਰਨ ਪ੍ਰੋਗਰਾਮ ਜਿਸ ਨੂੰ x ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ n ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ ਅਤੇ y ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਉਦਾਹਰਣਃ >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਨੰਬਰਾਂ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਵੈਕਟਰ ਵਿੱਚ ਨੰਬਰਾਂ ਦੇ ਵਰਗ ਦੇ ਜੋੜ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਅਜੀਬ ਹਨ. ਨਕਾਰਾਤਮਕ ਨੰਬਰਾਂ ਨੂੰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ ਜਾਂ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ. >>> ਡਬਲ_ਦਿ_ਡਿਫਰੈਂਸ (((ਸਟਰਡ:: ਵੈਕਟਰ<ਫਲੋਟ> (((ਲੰਬਾ) 1, (ਲੰਬਾ) 3, (ਲੰਬਾ) 2, (ਲੰਬਾ) 0}))) (10) >>> ਡਬਲ_ਦਿ_ਡਿਫਰੈਂਸ (((ਸਟਰਡ:: ਵੈਕਟਰ<ਫਲੋਟ> {(ਲੰਬਾ) -1, (ਲੰਬਾ) -2, (ਲੰਬਾ) 0}))) (0) >>> ਡਬਲ_ਦਿ_ਡਿਫਰੈਂਸ (((ਸਟਰਡ:: ਵੈਕਟਰ<ਫਲੋਟ> {(ਲੰਬਾ) -9, (ਲੰਬਾ) -2)))) (81) >>> ਡਬਲ_ਦਿ_ਡਿਫਰੈਂਸ (((ਸਟਰਡ:: ਵੈਕਟਰ<ਫਲੋਟ> {(ਲੰਬਾ) -0)) (0) ਜੇ ਇਨਪੁਟ ਵੈਕਟਰ ਖਾਲੀ ਹੈ, ਤਾਂ ਵਾਪਸ ਕਰੋ 0.
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਮੈਨੂੰ ਲਗਦਾ ਹੈ ਕਿ ਅਸੀਂ ਸਾਰੇ ਉਸ ਭਾਵਨਾ ਨੂੰ ਯਾਦ ਕਰਦੇ ਹਾਂ ਜਦੋਂ ਕਿਸੇ ਲੰਬੇ ਸਮੇਂ ਤੋਂ ਉਡੀਕ ਕੀਤੀ ਗਈ ਘਟਨਾ ਦਾ ਨਤੀਜਾ ਅੰਤ ਵਿੱਚ ਜਾਣਿਆ ਜਾਂਦਾ ਹੈ. ਉਸ ਸਮੇਂ ਤੁਹਾਡੇ ਕੋਲ ਜੋ ਭਾਵਨਾਵਾਂ ਅਤੇ ਵਿਚਾਰ ਹਨ ਉਹ ਨਿਸ਼ਚਤ ਤੌਰ ਤੇ ਨੋਟ ਕਰਨ ਅਤੇ ਤੁਲਨਾ ਕਰਨ ਦੇ ਯੋਗ ਹਨ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਕਿਸੇ ਵਿਅਕਤੀ ਨੇ ਕਈ ਮੈਚਾਂ ਦੇ ਨਤੀਜਿਆਂ ਦਾ ਸਹੀ ਅੰਦਾਜ਼ਾ ਲਗਾਇਆ ਹੈ. ਤੁਹਾਨੂੰ ਸਕੋਰਾਂ ਅਤੇ ਅੰਦਾਜ਼ਿਆਂ ਦੇ ਦੋ ਬਰਾਬਰ ਲੰਬਾਈ ਦੇ ਵੈਕਟਰ ਦਿੱਤੇ ਗਏ ਹਨ, ਜਿੱਥੇ ਹਰੇਕ ਇੰਡੈਕਸ ਇੱਕ ਮੈਚ ਦਰਸਾਉਂਦਾ ਹੈ. ਉਸੇ ਲੰਬਾਈ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰੋ ਜੋ ਦਰਸਾਉਂਦਾ ਹੈ ਕਿ ਹਰੇਕ ਅੰਦਾਜ਼ਾ ਕਿੰਨਾ ਦੂਰ ਸੀ. ਜੇ ਉਨ੍ਹਾਂ ਨੇ ਸਹੀ ਅੰਦਾਜ਼ਾ ਲਗਾਇਆ ਹੈ, ਤਾਂ ਮੁੱਲ 0, ਅਤੇ ਜੇ ਨਹੀਂ, ਮੁੱਲ ਅੰਦਾਜ਼ਾ ਅਤੇ ਸਕੋਰ ਦੇ ਵਿਚਕਾਰ ਪੂਰਨ ਅੰਤਰ ਹੈ. ਉਦਾਹਰਣਃ >>> (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਕਲਾਸ (ਇੱਕ ਸਤਰ) ਦਾ ਨਾਮ ਅਤੇ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਜਾਵੇਗਾ। ਐਕਸਟੈਂਸ਼ਨਾਂ ਨੂੰ ਕਲਾਸ ਵਿੱਚ ਵਾਧੂ ਕਲਾਸਾਂ ਲੋਡ ਕਰਨ ਲਈ ਵਰਤਿਆ ਜਾਣਾ ਹੈ। ਐਕਸਟੈਂਸ਼ਨ ਦੀ ਤਾਕਤ ਇਸ ਪ੍ਰਕਾਰ ਹੈਃ CAP ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ ਵੱਡੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਹੋਵੇ, ਅਤੇ SM ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਹੋਵੇ, ਤਾਕਤ CAP - SM ਦਰਾੜ ਦੁਆਰਾ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਲੱਭਣੀ ਚਾਹੀਦੀ ਹੈ ਅਤੇ ਇਸ ਫਾਰਮੈਟ ਵਿੱਚ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈਃ ClassName.StrongestExtensionName. ਜੇ ਦੋ ਜਾਂ ਵਧੇਰੇ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਇਕੋ ਤਾਕਤ ਹੈ, ਤਾਂ ਤੁਹਾਨੂੰ ਉਹ ਚੁਣਨਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਵੈਕਟਰ ਵਿੱਚ ਪਹਿਲਾਂ ਆਉਂਦੀ ਹੈ। ਉਦਾਹਰਣ ਲਈ, ਜੇ ਤੁਹਾਨੂੰ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਕਲਾਸ ਅਤੇ ਵੈਕਟਰ ਵਜੋਂ ""ਸਲਾਇਸ"" ਦਿੱਤਾ ਜਾਂਦਾ ਹੈਃ ['SEviviSliNGCes','Cheese','StuFed'] ਤਾਂ ਤੁਹਾਨੂੰ 'Slices.SviSliNGCes' ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ 'SviSliNGCes'::::::st:myst:myst:myst:myst:myst:myst:myst:myst:myst:myst:myst::st:myst:myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ 2 ਸ਼ਬਦ ਦਿੱਤੇ ਗਏ ਹਨ. ਤੁਹਾਨੂੰ ਸੱਚੇ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ ਜੇ ਦੂਜਾ ਸ਼ਬਦ ਜਾਂ ਇਸਦੇ ਕਿਸੇ ਵੀ ਘੁੰਮਣ ਪਹਿਲੇ ਸ਼ਬਦ ਵਿੱਚ ਇੱਕ ਸਬਸਟ੍ਰਿੰਗ ਹੈ >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""ਹੈਲੋ""), (""ell"")) (true) >>> cycpattern_check(""whassup""), (""psus"")) (false) >>> cycpattern_check(""abab""), (""baa"")) (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਇੱਕ ਟੁਪਲ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕ੍ਰਮਵਾਰ ਜਮ੍ਹਾਂ ਅਤੇ ਅਜੀਬ ਅੰਕ ਦੀ ਗਿਣਤੀ ਹੈ. ਉਦਾਹਰਨਃ >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2))
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਰੋਮਨ ਅੰਕਾਂ ਦੇ ਬਰਾਬਰ ਨੂੰ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਪ੍ਰਾਪਤ ਕਰੋ, ਅਤੇ ਇਸਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਵਾਪਸ ਕਰੋ। ਪਾਬੰਦੀਆਂਃ 1 <= num <= 1000 ਉਦਾਹਰਣਃ >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426)) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸਿਆਂ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ. ਜੇ ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਸਹੀ ਕੋਣ ਵਾਲੇ ਤਿਕੋਣ ਦਾ ਰੂਪ ਲੈਂਦੇ ਹਨ ਤਾਂ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੇ ਹਨ, ਨਹੀਂ ਤਾਂ ਗਲਤ. ਇੱਕ ਸਹੀ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣਾ ਇੱਕ ਤਿਕੋਣਾ ਹੈ ਜਿਸ ਵਿੱਚ ਇੱਕ ਕੋਣ ਸਹੀ ਕੋਣ ਜਾਂ 90 ਡਿਗਰੀ ਹੈ. ਉਦਾਹਰਨਃ >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ. ਵੈਕਟਰ ਵਿੱਚ ਵੱਖਰੇ ਸ਼ਬਦ ਹੁੰਦੇ ਹਨ. ਵੱਧ ਤੋਂ ਵੱਧ ਵਿਲੱਖਣ ਅੱਖਰਾਂ ਦੇ ਨਾਲ ਸ਼ਬਦ ਵਾਪਸ ਕਰੋ. ਜੇ ਕਈ ਸਤਰਾਂ ਵਿੱਚ ਵੱਧ ਤੋਂ ਵੱਧ ਵਿਲੱਖਣ ਅੱਖਰ ਹੁੰਦੇ ਹਨ, ਤਾਂ ਉਹ ਸ਼ਬਦ ਵਾਪਸ ਕਰੋ ਜੋ ਸ਼ਬਦਕੋਸ਼ਿਕ ਕ੍ਰਮ ਵਿੱਚ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ. >>> find_max((std::vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) """", (enam) >>> find_max(std::vector<std>{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਸੀਂ ਭੁੱਖੇ ਖਰਗੋਸ਼ ਹੋ, ਅਤੇ ਤੁਸੀਂ ਪਹਿਲਾਂ ਹੀ ਕੁਝ ਗਾਜਰ ਖਾ ਚੁੱਕੇ ਹੋ, ਪਰ ਹੁਣ ਤੁਹਾਨੂੰ ਦਿਨ ਦੇ ਖਾਣੇ ਨੂੰ ਪੂਰਾ ਕਰਨ ਲਈ ਹੋਰ ਗਾਜਰ ਖਾਣ ਦੀ ਜ਼ਰੂਰਤ ਹੈ. ਤੁਹਾਨੂੰ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ [ਤੁਹਾਡੇ ਖਾਣੇ ਤੋਂ ਬਾਅਦ ਖਾਧੇ ਗਏ ਗਾਜਰਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ, ਤੁਹਾਡੇ ਖਾਣੇ ਤੋਂ ਬਾਅਦ ਬਚੇ ਗਾਜਰਾਂ ਦੀ ਗਿਣਤੀ ] ਜੇ ਤੁਹਾਡੇ ਕੋਲ ਕਾਫ਼ੀ ਬਾਕੀ ਗਾਜਰ ਨਹੀਂ ਹਨ, ਤਾਂ ਤੁਸੀਂ ਬਾਕੀ ਸਾਰੇ ਗਾਜਰ ਖਾਓਗੇ, ਪਰ ਫਿਰ ਵੀ ਭੁੱਖੇ ਹੋਵੋਗੇ. ਉਦਾਹਰਣਃ >>> ਖਾਓ (((5), (6), (10)) (std::vector<long>{(()11, (long) 4})) >>> ਖਾਓ (((4), (8), (9) (std::vector<long>{() 12, ( () 1})) ਖਾਓ >>> ਗਾਜਰ (((1), (10), (10) (std::vector<long>{() 11, ()) ()) ()) ()) ()) (), ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) ()) (
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਦੋ ਵੈਕਟਰ ਆਪਰੇਟਰ ਅਤੇ ਓਪਰੇਂਡ ਦਿੱਤੇ ਗਏ ਹਨ। ਪਹਿਲੇ ਵੈਕਟਰ ਵਿੱਚ ਬੁਨਿਆਦੀ ਅਲਜਬਰਾ ਕਾਰਜ ਹੁੰਦੇ ਹਨ, ਅਤੇ ਦੂਜੇ ਵੈਕਟਰ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਹੁੰਦਾ ਹੈ। ਅਲਜਬਰਾ ਸਮੀਕਰਨ ਬਣਾਉਣ ਲਈ ਦਿੱਤੇ ਗਏ ਦੋ ਵੈਕਟਰਾਂ ਦੀ ਵਰਤੋਂ ਕਰੋ ਅਤੇ ਇਸ ਸਮੀਕਰਨ ਦਾ ਮੁਲਾਂਕਣ ਵਾਪਸ ਕਰੋ। ਬੁਨਿਆਦੀ ਅਲਜਬਰਾ ਓਪਰੇਸ਼ਨਃ ਜੋੜ (+) ਘਟਾਓ ()) - ਗੁਣਾ ( *) ਫਲੋਰ ਡਿਵੀਜ਼ਨ ( // ) ਐਕਸਪੋਨੇਂਟੇਸ਼ਨ ( **) ਉਦਾਹਰਣਃ ਆਪਰੇਟਰ['+', '*', '-'] ਵੈਕਟਰ = [2, 3, 4, 5] ਨਤੀਜਾ = 2 + 3 * 4 - 5 => ਨਤੀਜਾ = 9 ਨੋਟਃ ਓਪਰੇਟਰ ਵੈਕਟਰ ਦੀ ਲੰਬਾਈ ਓਪਰੇਂਡ ਵੈਕਟਰ ਦੀ ਲੰਬਾਈ ਦੇ ਬਰਾਬਰ ਹੈ ਘਟਾਓ ਇਕ. ਓਪਰੇਂਡ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਹੈ. ਓਪਰੇਟਰ ਵੈਕਟਰ ਵਿੱਚ ਘੱਟੋ ਘੱਟ ਇੱਕ ਓਪਰੇਟਰ ਹੁੰਦਾ ਹੈ, ਅਤੇ ਓਪਰੇਂਡ ਵੈਕਟਰ ਵਿੱਚ ਘੱਟੋ ਘੱਟ ਦੋ ਓਪਰੇਂਡ ਹੁੰਦੇ ਹਨ.
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ. ਜੇ s[i] ਇੱਕ ਅੱਖਰ ਹੈ, ਤਾਂ ਇਸਦੇ ਕੇਸ ਨੂੰ ਹੇਠਲੇ ਤੋਂ ਉੱਪਰ ਜਾਂ ਉਪਰ ਵੱਲ ਉਲਟਾ ਕਰੋ, ਨਹੀਂ ਤਾਂ ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਹੀ ਰੱਖੋ. ਜੇ ਸਤਰ ਵਿੱਚ ਕੋਈ ਅੱਖਰ ਨਹੀਂ ਹਨ, ਤਾਂ ਸਤਰ ਨੂੰ ਉਲਟਾ ਦਿਓ. ਫੰਕਸ਼ਨ ਨੂੰ ਨਤੀਜੇ ਵਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ. ਉਦਾਹਰਣ >>> solve((""1234"")) (""4321"") >>> solve(""ab"")) (""AB"") >>> solve(""#a@C"")) (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਇੱਕ ਸਤਰ 'text' ਦਿੱਤੀ ਗਈ ਹੈ, ਤਾਂ ਇਸਦੀ md5 ਹੈਸ਼ ਸਮਾਨ ਸਤਰ ਵਾਪਸ ਕਰੋ। ਜੇਕਰ 'text' ਇੱਕ ਖਾਲੀ ਸਤਰ ਹੈ, ਤਾਂ None ਵਾਪਸ ਕਰੋ। >>> string_to_md5((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,pan_Guru,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਿੱਤੇ ਗਏ ਹਨ, a ਅਤੇ b ਦੇ ਵਿਚਕਾਰ ਵੀ ਅੰਕ ਵਾਪਸ ਕਰੋ, ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ. ਉਦਾਹਰਣ ਲਈਃ >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
