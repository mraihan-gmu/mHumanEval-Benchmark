[{"task_id":"HumanEval_0","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ण ण ण ण ण ण ण ण ण ण ण ण ण    \/\/यदि संख्यायाः सूचीषु कस्यचित् द्वयोः संख्यायाः समीपता -रूपेण अस्ति चेत्, तदा जाँचं कुरुत।    \/\/ >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))\n    \/\/ (false)\n    \/\/ >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n    \/\/ (true)\n    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {\n","canonical_solution":"def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {\n      val sortedNumbers = numbers.sorted\n      for (i <- 1 until sortedNumbers.length) {\n        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {\n          return true\n        }\n      }\n      false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_1","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/इन्द्रियं चैवं चैवं चैवं चैवं चैवं चैवं चैवं चैवं चैवं चैवं चैवं चैवं चैवं च    \/\/पृथक् पृथक् समूहः समतोलः भवति (प्रत्येक उघृतं कण्ठं उचितं भवति) न च परस्परं निहितः भवति ।    \/\/समूहं पृथक् पृथक् कृत्वा तेषां सूचीं प्रतिपादयतु।    \/\/इदम् फलनम् अनेन सूत्रेण प्रविष्टम् अस्ति यत् अनेन सूत्रेण बहुभिः समूहैः अन्तर्बद्धं कोष्ठकं भवति ।    \/\/ >>> separateParenGroups((\"( ) (( )) (( )( ))\"))\n    \/\/ (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string : String) : List[String] = {\n","canonical_solution":"def separateParenGroups(paren_string: String): List[String] = {\n    val result = ListBuffer[String]()\n    val sanitizedInput = paren_string.replaceAll(\"\\\\s\", \"\")\n    var balance = 0\n    var currentGroup = new StringBuilder()\n\n    for (char <- sanitizedInput) {\n        currentGroup.append(char)\n        if (char == '(') balance += 1\n        else if (char == ')') balance -= 1\n\n        if (balance == 0 && currentGroup.nonEmpty) {\n            result += currentGroup.toString()\n            currentGroup = new StringBuilder()\n        }\n    }\n\n    result.toList\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_2","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/संख्यायाः दशमलवभागं प्रतिपादयतु।    \/\/(अतिरिक्तं भागं सदैव १-अधिकं भवति)    \/\/एवं पूर्णाङ्कः (प्रदत्तसंख्येयस्य लघुतमः बृहत् पूर्णाङ्कः) एवं दशमलवसंख्याः     \/\/यदि धनात्मकः अङ्कः अस्ति, तर्हि सः  इत्यनेन विभक्तः भवति।    \/\/ >>> truncateNumber((3.5f))\n    \/\/ (0.5f)\n    def truncateNumber(number : Float) : Float = {\n","canonical_solution":"val integerPart = number.floor\n        val decimalPart = number - integerPart\n        decimalPart.toFloat\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"},{"task_id":"HumanEval_3","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/तत्पक्षे कार्यस्य सत्यं प्रतिफलः भवेत् अन्यथा असत्यं प्रतिफलः भवेत् ।    \/\/शून्यसङ्ख्याः भवतां कार्यम् अस्ति यत् यदि कस्यचित् स्थाने खातासङ्ख्या शून्यस्य अधः गच्छति तर्हि अवलोकयतु, तथा     \/\/भवता एका सूची दीयते, येन णकारेण आरभ्यते, येन एका बैंकखाते जमा-उपहार-प्रक्रियाः कृतानि सन्ति ।    \/\/ >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (false)\n    \/\/ >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))\n    \/\/ (true)\n    def belowZero(operations : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def belowZero(operations: List[Long]): Boolean = {\n    var balance: Long = 0\n    for (operation <- operations) {\n      balance += operation\n      if (balance < 0) {\n        return true\n      }\n    }\n    false\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(belowZero(List(1L, 2L, 3L)))         \/\/ false\n    println(belowZero(List(1L, 2L, -4L, 5L)))    \/\/ true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(belowZero((List[Long]())) == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_4","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/MAD = average. x - x_mean.     \/\/तन्त्रे च मध्यस्थं (अस्मिन् प्रकरणे माध्यम्)    \/\/माध्यम् निरपेक्ष विचलनम् एव एव एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम् एवम्    \/\/अस्य डाटासेटस्य माध्यमे एव।    \/\/आगतसंख्यायाः सूचीयाः कृते, माध्यम् निरपेक्ष विचलनं गणनाय कुरुत।    \/\/ >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))\n    \/\/ (1.0f)\n    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {\n","canonical_solution":"val mean = numbers.sum \/ numbers.size\n    val deviations = numbers.map(num => math.abs(num - mean))\n    val mad = deviations.sum \/ deviations.size\n    mad\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));\n    }\n\n}\n"},{"task_id":"HumanEval_5","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/'इन्द्रियं च' इत्यस्य अनुक्रमिकयोः अवयवयोः मध्ये 'अन्तराल' इति संख्या प्रविष्टं कुरुत    \/\/ >>> intersperse((List[Long]()), (4l))\n    \/\/ (List[Long]())\n    \/\/ >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))\n    \/\/ (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))\n    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {\n","canonical_solution":"if (numbers.isEmpty) {\n        List()\n      } else {\n        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last\n      }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_6","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् - (() (()) मध्ये अधिकतमं द्वौ स्तरेषु नेस्टिङ्गः भवति, यदाकि ((())) मध्ये त्रयः स्तरेषु नेस्टिङ्गः भवति ।    \/\/समूहस्य प्रत्येकं कूटस्थस्य गहनतमं स्तरं निर्दिश्यते।    \/\/इदम् फलनम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम् इदम्    \/\/ >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def parseNestedParens(paren_string: String): List[Long] = {\n    paren_string.split(\" \").toList.map { group =>\n      var maxDepth = 0\n      var currentDepth = 0\n      group.foreach {\n        case '(' => \n          currentDepth += 1\n          maxDepth = max(maxDepth, currentDepth)\n        case ')' => \n          currentDepth -= 1\n      }\n      maxDepth.toLong\n    }\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    val result = parseNestedParens(\"(()()) ((())) () ((())()())\")\n    println(s\"Result: ${result.mkString(\", \")}\")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_7","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/केवलम् उपसङ्ख्यायाः उपसङ्ख्यायाः कृते प्रविष्टसूचीं फिल्टर् करोतु ।    \/\/ >>> filterBySubstring((List[String]()), (\"a\"))\n    \/\/ (List[String]())\n    \/\/ >>> filterBySubstring((List[String](\"abc\", \"bacd\", \"cde\", \"array\")), (\"a\"))\n    \/\/ (List[String](\"abc\", \"bacd\", \"array\"))\n    def filterBySubstring(strings : List[String], substring : String) : List[String] = {\n","canonical_solution":"strings.filter(_.contains(substring))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(filterBySubstring((List[String]()), (\"john\")).equals((List[String]())));\n    assert(filterBySubstring((List[String](\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"xxx\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xx\")).equals((List[String](\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"grunt\", \"trumpet\", \"prune\", \"gruesome\")), (\"run\")).equals((List[String](\"grunt\", \"prune\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_8","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/शून्यस्य योगस्य शून्यस्य च गुणस्य च एकस्य च योगः भवति ।    \/\/पूर्णाङ्काणां सूचीभ्यः, सूचीषु सर्वेषां पूर्णाङ्काणां योगः गुणः च युक्तं ट्यूप्लं प्रतिपादयतु ।    \/\/ >>> sumProduct((List[Long]()))\n    \/\/ ((0l, 1l))\n    \/\/ >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ ((10l, 24l))\n    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {\n","canonical_solution":"def sumProduct(numbers: List[Long]): (Long, Long) = {\n        val sum = numbers.sum\n        val product = numbers.foldLeft(1L)(_ * _)\n        (sum, product)\n    }\n\n    def main(args: Array[String]): Unit = {\n        \/\/ Test examples\n        println(sumProduct(List[Long]())) \/\/ (0L, 1L)\n        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) \/\/ (10L, 24L)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumProduct((List[Long]())).equals(((0l, 1l))));\n    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));\n    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));\n    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));\n    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));\n    }\n\n}\n"},{"task_id":"HumanEval_9","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अनुक्रमः     \/\/दिग्विधायकानां सूचीभ्यः, दिग्विधायकानां सूचिभ्यः, दिग्विधायकानां सूचिभ्यः, दिग्विधायकानां सूचिभ्यः, दिग्विधायकानां सूचिभ्यः, दिग्विधायकानां सूचिभ्यः, दिग्विधायकानां सूचिभ्यः, दिग्विधायकानां सूचिभ्यः    \/\/ >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rollingMax(numbers: List[Long]): List[Long] = {\n        var maxSoFar = Long.MinValue\n        numbers.map { num =>\n            maxSoFar = max(maxSoFar, num)\n            maxSoFar\n        }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_10","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/- अङ्गस्य अन्ते अङ्गस्य पूर्वपदस्य विपर्यासे अङ्गस्य पूर्वपदस्य उपसर्गस्य उपसर्गस्य पूर्वपदस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य पूर्वपदस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य पूर्वपदस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गस्य उपसर्गः    \/\/- प्रदत्तस्य स्ट्रन्गस्य दीर्घतमं पोस्टफिक्सं ज्ञातुं यच्च पालिन्ड्रोम् अस्ति ।    \/\/अल्गोरिदमस्य विचारः सरलः अस्ति:    \/\/लघुतमं पालिन्द्रोमम् ज्ञातुं प्रयतमानः।    \/\/ >>> makePalindrome((\"\"))\n    \/\/ (\"\")\n    \/\/ >>> makePalindrome((\"cat\"))\n    \/\/ (\"catac\")\n    \/\/ >>> makePalindrome((\"cata\"))\n    \/\/ (\"catac\")\n    def makePalindrome(string : String) : String = {\n","canonical_solution":"def makePalindrome(string: String): String = {\n    \/\/ Helper function to check if a string is a palindrome\n    def isPalindrome(s: String): Boolean = s == s.reverse\n\n    \/\/ Find the longest palindromic suffix\n    var endIndex = string.length\n    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {\n      endIndex -= 1\n    }\n\n    \/\/ Extract the non-palindromic prefix\n    val prefix = string.substring(0, endIndex - 1)\n\n    \/\/ Append the reverse of the prefix to form the shortest palindrome\n    string + prefix.reverse\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"},{"task_id":"HumanEval_11","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/एतयोः आगतानां विषये द्विवचनं XOR क्रियते, तथा च निष्पन्नं सूत्रं अपि लभते।    \/\/इन्द्रियं द्वौ शृङ्गाणि ए च बी च सन्ति, येषु केवलं १ च ० च सन्ति।    \/\/ >>> stringXor((\"010\"), (\"110\"))\n    \/\/ (\"100\")\n    def stringXor(a : String, b : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def stringXor(a: String, b: String): String = {\n    (a zip b).map { case (charA, charB) => \n      if (charA == charB) '0' else '1'\n    }.mkString\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"},{"task_id":"HumanEval_12","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/समान-लम्बाः शृङ्गाः। यदि आगतसूची रिक्तं भवति तर्हि None इत्यस्य परावर्तनं कुर्यात्।    \/\/अकारस्य दीर्घतमं वर्णं प्रतिपादयतु। यदि बहुव्रीहिः अस्ति तर्हि प्रथमं वर्णं प्रतिपादयतु।    \/\/ >>> longest((List[String]()))\n    \/\/ None\n    \/\/ >>> longest((List[String](\"a\", \"b\", \"c\")))\n    \/\/ Some(\"a\")\n    \/\/ >>> longest((List[String](\"a\", \"bb\", \"ccc\")))\n    \/\/ Some(\"ccc\")\n    def longest(strings : List[String]) : Option[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Out of list of strings, return the longest one. Return the first one in case of multiple\n    \/\/ strings of the same length. Return None in case the input list is empty.\n    def longest(strings: List[String]): Option[String] = {\n        if (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(Some(\"x\")));\n    assert(longest((List[String](\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(Some(\"zzzz\")));\n    }\n\n}\n"},{"task_id":"HumanEval_13","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/द्वयोः पूर्णाङ्काः a, b इत्ययोः सर्वाधिकं सामान्यविभाजकम् प्रतिपादयतु ।    \/\/ >>> greatestCommonDivisor((3l), (5l))\n    \/\/ (1l)\n    \/\/ >>> greatestCommonDivisor((25l), (15l))\n    \/\/ (5l)\n    def greatestCommonDivisor(a : Long, b : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Return a greatest common divisor of two integers a and b\n    \/\/ >>> greatestCommonDivisor((3l), (5l))\n    \/\/ (1l)\n    \/\/ >>> greatestCommonDivisor((25l), (15l))\n    \/\/ (5l)\n    def greatestCommonDivisor(a: Long, b: Long): Long = {\n        if (b == 0) a else greatestCommonDivisor(b, a % b)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(greatestCommonDivisor((3l), (7l)) == (1l));\n    assert(greatestCommonDivisor((10l), (15l)) == (5l));\n    assert(greatestCommonDivisor((49l), (14l)) == (7l));\n    assert(greatestCommonDivisor((144l), (60l)) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_14","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/इतः पूर्वं सर्वस्य पूर्वपदस्य लघतमात् दीर्घतमात् इतः पूर्वपदस्य सूचीः लभ्यते ।    \/\/ >>> allPrefixes((\"abc\"))\n    \/\/ (List[String](\"a\", \"ab\", \"abc\"))\n    def allPrefixes(string : String) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return list of all prefixes from shortest to longest of the input string\n  \/\/ >>> allPrefixes((\"abc\"))\n  \/\/ (List[String](\"a\", \"ab\", \"abc\"))\n  def allPrefixes(string: String): List[String] = {\n    (1 to string.length).map(i => string.substring(0, i)).toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(allPrefixes((\"\")).equals((List[String]())));\n    assert(allPrefixes((\"asdfgh\")).equals((List[String](\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"))));\n    assert(allPrefixes((\"WWW\")).equals((List[String](\"W\", \"WW\", \"WWW\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_15","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/0 तः n पर्यन्तं संख्यायाः अन्तरालसंज्ञकानि सन्ति।    \/\/ >>> stringSequence((0l))\n    \/\/ (\"0\")\n    \/\/ >>> stringSequence((5l))\n    \/\/ (\"0 1 2 3 4 5\")\n    def stringSequence(n : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def stringSequence(n: Long): String = {\n    (0L to n).mkString(\" \")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(stringSequence((0l)).equals((\"0\")));\n    assert(stringSequence((3l)).equals((\"0 1 2 3\")));\n    assert(stringSequence((10l)).equals((\"0 1 2 3 4 5 6 7 8 9 10\")));\n    }\n\n}\n"},{"task_id":"HumanEval_16","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि कस्यचित् अक्षरस्य वर्णः अस्ति, तर्हि तस्य संख्या ज्ञातुं प्रयतस्व।    \/\/ >>> countDistinctCharacters((\"xyzXYZ\"))\n    \/\/ (3l)\n    \/\/ >>> countDistinctCharacters((\"Jerry\"))\n    \/\/ (4l)\n    def countDistinctCharacters(string : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given a string, find out how many distinct characters (regardless of case) does it consist of\n  \/\/ >>> countDistinctCharacters((\"xyzXYZ\"))\n  \/\/ (3l)\n  \/\/ >>> countDistinctCharacters((\"Jerry\"))\n  \/\/ (4l)\n  def countDistinctCharacters(string: String): Long = {\n    string.toLowerCase.toSet.size.toLong\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countDistinctCharacters((\"\")) == (0l));\n    assert(countDistinctCharacters((\"abcde\")) == (5l));\n    assert(countDistinctCharacters((\"abcdecadeCADE\")) == (5l));\n    assert(countDistinctCharacters((\"aaaaAAAAaaaa\")) == (1l));\n    assert(countDistinctCharacters((\"Jerry jERRY JeRRRY\")) == (5l));\n    }\n\n}\n"},{"task_id":"HumanEval_17","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/'ऋक्' - चतुर्विंशतिवर्णः, एकं ध्रुवम् भवति ।    \/\/'ओऽस्ये' - अर्धं स्वरं, द्वौ धातौ भवति ।    \/\/'ओ' - पूर्णं सङ्केतं, चतुर्भिः धड्डैः भवति ।    \/\/अत्र एकं किंवदंति-    \/\/न च अन्तिमम्।    \/\/भवतां कार्यम् अस्ति यत् इयं स्ट्रिंग् विभज्य च पूर्णाङ्काणां सूचीं प्रति लभेत, येषु प्रत्येकं कति-अङ्कं करोति।    \/\/अस्य कार्यस्य आगतं विशेषेण ASCII स्वरूपेण सङ्गीतस्य सङ्केतं प्रतिपादयति।    \/\/ >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    \/\/ (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def parseMusic(music_string: String): List[Long] = {\n    val noteMap = Map(\"o\" -> 4L, \"o|\" -> 2L, \".|\" -> 1L)\n    val notes = music_string.split(\" \")\n    notes.toList.map(note => noteMap(note))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_18","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/मूलसूत्रे उपसूत्रस्य कति पुनरावृत्तिः सन्ति, ते ज्ञातुं शक्नुमः।    \/\/ >>> howManyTimes((\"\"), (\"a\"))\n    \/\/ (0l)\n    \/\/ >>> howManyTimes((\"aaa\"), (\"a\"))\n    \/\/ (3l)\n    \/\/ >>> howManyTimes((\"aaaa\"), (\"aa\"))\n    \/\/ (3l)\n    def howManyTimes(string : String, substring : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def howManyTimes(string: String, substring: String): Long = {\n        if (substring.isEmpty || string.isEmpty) return 0L\n        var count: Long = 0L\n        for (i <- 0 to (string.length - substring.length)) {\n            if (string.substring(i, i + substring.length) == substring) {\n                count += 1\n            }\n        }\n        count\n    }\n\n    \/\/ Test cases\n    def main(args: Array[String]): Unit = {\n        println(howManyTimes(\"\", \"a\"))    \/\/ Output: 0\n        println(howManyTimes(\"aaa\", \"a\")) \/\/ Output: 3\n        println(howManyTimes(\"aaaa\", \"aa\")) \/\/ Output: 3\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(howManyTimes((\"\"), (\"x\")) == (0l));\n    assert(howManyTimes((\"xyxyxyx\"), (\"x\")) == (4l));\n    assert(howManyTimes((\"cacacacac\"), (\"cac\")) == (4l));\n    assert(howManyTimes((\"john doe\"), (\"john\")) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_19","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/लघुतमात् बृहत्तमं प्रति सङ्ख्याभिः क्रमबद्धं शृङ्खलं प्रतिपादयतु ।    \/\/वैधानि विकल्पानि \"शून्य\", \"एक\", \"द्वय\", \"त्रय\", \"चत्वार\", \"पञ्च\", \"षट्\", \"सप्त\", \"आठ\" तथा \"नव\" इत्येवम् सन्ति ।    \/\/'शून्य' इत्यतः 'नौ' इत्यतः 'शून्य' इत्यतः 'नौ' इत्यतः 'शून्य' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः 'नौ' इत्यतः    \/\/ >>> sortNumbers((\"three one five\"))\n    \/\/ (\"one three five\")\n    def sortNumbers(numbers : String) : String = {\n","canonical_solution":"def sortNumbers(numbers: String): String = {\n    val numberWords = Map(\n      \"zero\" -> 0,\n      \"one\" -> 1,\n      \"two\" -> 2,\n      \"three\" -> 3,\n      \"four\" -> 4,\n      \"five\" -> 5,\n      \"six\" -> 6,\n      \"seven\" -> 7,\n      \"eight\" -> 8,\n      \"nine\" -> 9\n    )\n    \n    numbers.split(\" \")\n      .sortBy(word => numberWords(word))\n      .mkString(\" \")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortNumbers((\"\")).equals((\"\")));\n    assert(sortNumbers((\"three\")).equals((\"three\")));\n    assert(sortNumbers((\"three five nine\")).equals((\"three five nine\")));\n    assert(sortNumbers((\"five zero four seven nine eight\")).equals((\"zero four five seven eight nine\")));\n    assert(sortNumbers((\"six five four three two one zero\")).equals((\"zero one two three four five six\")));\n    }\n\n}\n"},{"task_id":"HumanEval_20","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अन्यः क्रमः (अल्पसंख्याः, अधिकसंख्याः) ।    \/\/अत्र प्रदत्तः सङ्ख्यासूची (अन्यतम द्वयोः दीर्घः) द्वयोः सङ्ख्याभ्यः समीपे स्थितं द्वयं चित्वा परावर्त्तयतु ।    \/\/ >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n    \/\/ ((2.0f, 2.2f))\n    \/\/ >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n    \/\/ ((2.0f, 2.0f))\n    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def findClosestElements(numbers: List[Float]): (Float, Float) = {\n    require(numbers.length >= 2, \"List must contain at least two elements\")\n    val sortedNumbers = numbers.sorted\n\n    var minDiff = Float.MaxValue\n    var closestPair = (0.0f, 0.0f)\n\n    for(i <- 0 until sortedNumbers.length - 1) {\n      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))\n      if(currentDiff < minDiff) {\n        minDiff = currentDiff\n        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))\n      }\n    }\n    \n    closestPair\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"},{"task_id":"HumanEval_21","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अतः लघुतमः संख्याः शून्यः भवति, बृहत्तमः संख्याः च एकः भवति।    \/\/संख्यायाः सूची (अन्यतम द्वयोः तत्वानां) दत्त्वा, तत् सूचीं प्रति रेखागतपरिवर्तनं क्रियताम्,    \/\/ >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    \/\/ (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers : List[Float]) : List[Float] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given list of numbers (of at least two elements), apply a linear transform to that list,\n  \/\/ such that the smallest number will become 0 and the largest will become 1\n  def rescaleToUnit(numbers: List[Float]): List[Float] = {\n    val minVal = numbers.min\n    val maxVal = numbers.max\n    numbers.map(num => (num - minVal) \/ (maxVal - minVal))\n  }\n}\n\n\/\/ Usage example\nobject Main extends App {\n  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)\n  val rescaledNumbers = Problem.rescaleToUnit(numbers)\n  println(rescaledNumbers) \/\/ Output: List(0.0, 0.25, 0.5, 0.75, 1.0)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"},{"task_id":"HumanEval_22","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/केवल पूर्णाङ्कं प्रति स्केलाथन-सङ्ख्यानां सूचीं फिल्टर् कराः ।    \/\/ >>> filterIntegers((List[Any](\"a\", 3.14f, 5l)))\n    \/\/ (List[Long](5l.toLong))\n    \/\/ >>> filterIntegers((List[Any](1l, 2l, 3l, \"abc\", Map[Long,Long](), List[Long]())))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    def filterIntegers(values : List[Any]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def filterIntegers(values: List[Any]): List[Long] = {\n    values.collect {\n      case l: Long => l\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(filterIntegers(List[Any](\"a\", 3.14f, 5l))) \/\/ List(5)\n    println(filterIntegers(List[Any](1l, 2l, 3l, \"abc\", Map[Long, Long](), List[Long]()))) \/\/ List(1, 2, 3)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(filterIntegers((List[Any]())).equals((List[Long]())));\n    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, \"adasd\"))).equals((List[Long](4l.toLong, 9l.toLong))));\n    assert(filterIntegers((List[Any](3l, \"c\", 3l, 3l, \"a\", \"b\"))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_23","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/दिशन्त्यस्य दीर्घत्वं प्रतिपादयतु ।    \/\/ >>> stringLength((\"\"))\n    \/\/ (0l)\n    \/\/ >>> stringLength((\"abc\"))\n    \/\/ (3l)\n    def strlen(string : String) : Long = {\n","canonical_solution":"def strlen(string: String): Long = {\n        string.length.toLong\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(strlen((\"\")) == (0l));\n    assert(strlen((\"x\")) == (1l));\n    assert(strlen((\"asdasnakj\")) == (9l));\n    }\n\n}\n"},{"task_id":"HumanEval_24","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/दिशति, अतः n-संख्यया n-संख्यया लघुतमं संख्यां ज्ञातव्यम्, यत् n-संख्यया समं विभजते।    \/\/ >>> largestDivisor((15l))\n    \/\/ (5l)\n    def largestDivisor(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n    \/\/ >>> largestDivisor(15l)\n    \/\/ (5l)\n    def largestDivisor(n: Long): Long = {\n        for (i <- (n \/ 2) to 1 by -1) {\n            if (n % i == 0) return i\n        }\n        1L  \/\/ if no divisor found, return 1 (since 1 divides any number)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(largestDivisor((3l)) == (1l));\n    assert(largestDivisor((7l)) == (1l));\n    assert(largestDivisor((10l)) == (5l));\n    assert(largestDivisor((100l)) == (50l));\n    assert(largestDivisor((49l)) == (7l));\n    }\n\n}\n"},{"task_id":"HumanEval_25","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/इदम् संख्यायाः गुणनम् अकारस्य गुणनम् भवति ।    \/\/प्रत्येकं कारकम् कारकविभागेषु कतिधा दृश्यते, तदनुरूपं संख्यायां सूचीबद्धं भवेत् ।    \/\/दिशति सूचिकां सर्वकारेण सूचिकां लघुतमात् बृहत्तमं क्रमात् ।    \/\/ >>> factorize((8l))\n    \/\/ (List[Long](2l.toLong, 2l.toLong, 2l.toLong))\n    \/\/ >>> factorize((25l))\n    \/\/ (List[Long](5l.toLong, 5l.toLong))\n    \/\/ >>> factorize((70l))\n    \/\/ (List[Long](2l.toLong, 5l.toLong, 7l.toLong))\n    def factorize(n : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def factorize(n: Long): List[Long] = {\n    var num = n\n    val factors = ListBuffer[Long]()\n    \n    var i = 2L\n    while (i <= sqrt(num).toLong) {\n      while (num % i == 0) {\n        factors += i\n        num \/= i\n      }\n      i += 1\n    }\n    \n    if (num > 1) {\n      factors += num\n    }\n    \n    factors.toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(factorize((2l)).equals((List[Long](2l.toLong))));\n    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));\n    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));\n    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_26","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/आद्युदात्तत्वे यथाक्रमं वामपार्श्वे स्थापयतु ।    \/\/पूर्णाङ्काणां सूचीभ्यः, एकं पुनः पुनः प्रादुर्भवन्ति सर्वान् अवयवान् निष्कास्यताम् ।    \/\/ >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    \/\/ (List[Long](1l.toLong, 3l.toLong, 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def removeDuplicates(numbers: List[Long]): List[Long] = {\n    val elementCount = numbers.groupBy(identity).mapValues(_.size)\n    numbers.filter(num => elementCount(num) == 1)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)\n    println(removeDuplicates(numbers)) \/\/ Output: List(1, 3, 4)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_27","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/दिशन्त्य्-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली-अङ्गुली    \/\/ >>> flipCase((\"Hello\"))\n    \/\/ (\"hELLO\")\n    def flipCase(string : String) : String = {\n","canonical_solution":"def flipCase(string: String): String = {\n    string.map {\n      case c if c.isLower => c.toUpper\n      case c if c.isUpper => c.toLower\n      case c => c\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(flipCase((\"\")).equals((\"\")));\n    assert(flipCase((\"Hello!\")).equals((\"hELLO!\")));\n    assert(flipCase((\"These violent delights have violent ends\")).equals((\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")));\n    }\n\n}\n"},{"task_id":"HumanEval_28","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/एकस्मिन् सूत्रे सूत्रसूचीं समाहितं कुरुत    \/\/ >>> concatenate((List[String]()))\n    \/\/ (\"\")\n    \/\/ >>> concatenate((List[String](\"a\", \"b\", \"c\")))\n    \/\/ (\"abc\")\n    def concatenate(strings : List[String]) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ Concatenate list of strings into a single string\n    \/\/ >>> concatenate((List[String]()))\n    \/\/ (\"\")\n    \/\/ >>> concatenate((List[String](\"a\", \"b\", \"c\")))\n    \/\/ (\"abc\")\n    def concatenate(strings: List[String]): String = {\n        strings.mkString(\"\")\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(concatenate((List[String]())).equals((\"\")));\n    assert(concatenate((List[String](\"x\", \"y\", \"z\"))).equals((\"xyz\")));\n    assert(concatenate((List[String](\"x\", \"y\", \"z\", \"w\", \"k\"))).equals((\"xyzwk\")));\n    }\n\n}\n"},{"task_id":"HumanEval_29","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/केवलम् उपसर्गात् आरभन्तेभ्यः सूत्रानां सूचीं फिल्टर् करोतु ।    \/\/ >>> filterByPrefix((List[String]()), (\"a\"))\n    \/\/ (List[String]())\n    \/\/ >>> filterByPrefix((List[String](\"abc\", \"bcd\", \"cde\", \"array\")), (\"a\"))\n    \/\/ (List[String](\"abc\", \"array\"))\n    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {\n","canonical_solution":"strings.filter(_.startsWith(prefix))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(filterByPrefix((List[String]()), (\"john\")).equals((List[String]())));\n    assert(filterByPrefix((List[String](\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"xxx\", \"xxxAAA\", \"xxx\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_30","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/सूचीषु केवलं धनात्मकं संख्यां प्रतिपादयतु।    \/\/ >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (List[Long](2l.toLong, 5l.toLong, 6l.toLong))\n    \/\/ >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))\n    \/\/ (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))\n    def getPositive(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getPositive(l: List[Long]): List[Long] = {\n        l.filter(_ > 0)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));\n    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));\n    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));\n    assert(getPositive((List[Long]())).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_31","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि दीयते तदा सत्यं परावर्त्तय, अन्यथा मिथ्या।    \/\/ >>> isPrime((6l))\n    \/\/ (false)\n    \/\/ >>> isPrime((101l))\n    \/\/ (true)\n    \/\/ >>> isPrime((11l))\n    \/\/ (true)\n    \/\/ >>> isPrime((13441l))\n    \/\/ (true)\n    \/\/ >>> isPrime((61l))\n    \/\/ (true)\n    \/\/ >>> isPrime((4l))\n    \/\/ (false)\n    \/\/ >>> isPrime((1l))\n    \/\/ (false)\n    def isPrime(n : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return true if a given number is prime, and false otherwise.\n  def isPrime(n: Long): Boolean = {\n    if (n <= 1) return false\n    if (n <= 3) return true\n    if (n % 2 == 0 || n % 3 == 0) return false\n    var i = 5\n    while (i * i <= n) {\n      if (n % i == 0 || n % (i + 2) == 0) return false\n      i += 6\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isPrime((6l)) == (false));\n    assert(isPrime((101l)) == (true));\n    assert(isPrime((11l)) == (true));\n    assert(isPrime((13441l)) == (true));\n    assert(isPrime((61l)) == (true));\n    assert(isPrime((4l)) == (false));\n    assert(isPrime((1l)) == (false));\n    assert(isPrime((5l)) == (true));\n    assert(isPrime((11l)) == (true));\n    assert(isPrime((17l)) == (true));\n    assert(isPrime((85l)) == (false));\n    assert(isPrime((77l)) == (false));\n    assert(isPrime((255379l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_33","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य णकारस्य    \/\/l' इत्यनेन सूत्रेण त्रयाणां विभक्तानां सूचकांशाणां मध्ये l इत्यनेन सूत्रेण एकं सूत्रं भवति, त्रयाणां विभक्तानां सूचकांशाणां मध्ये तस्य मानः एक एव भवति ।    \/\/इदम् फलनम् एकं सूची l गृहीत्वा, सूची l' इत्यनेन परावर्त्तयति यत्     \/\/ >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    \/\/ >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))\n    \/\/ (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))\n    def sortThird(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \n  def sortThird(l: List[Long]): List[Long] = {\n    \/\/ Get the elements at indices divisible by 3\n    val elementsAtThirdIndices = l.zipWithIndex.collect {\n      case (value, index) if index % 3 == 0 => value\n    }\n    \n    \/\/ Sort the collected elements\n    val sortedElements = elementsAtThirdIndices.sorted\n    \n    \/\/ Replace elements at indices divisible by 3 with the sorted ones\n    l.zipWithIndex.map {\n      case (_, index) if index % 3 == 0 => sortedElements(index \/ 3)\n      case (value, _) => value\n    }\n  }\n\n  \/\/ Example usage:\n  def main(args: Array[String]): Unit = {\n    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_34","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/सूचीमध्ये विसर्जिते अनन्यपदार्थेषु परावर्त्तनम्    \/\/ >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    \/\/ (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))\n    def unique(l : List[Long]) : List[Long] = {\n","canonical_solution":"def unique(l: List[Long]): List[Long] = {\n    l.toSet.toList.sorted\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_35","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/सूचीमध्ये अधिकतमः तत्वः परावर्त्त्यते ।    \/\/ >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))\n    \/\/ (123l)\n    def maxElement(l : List[Long]) : Long = {\n","canonical_solution":"def maxElement(l: List[Long]): Long = {\n    l.max\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));\n    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));\n    }\n\n}\n"},{"task_id":"HumanEval_36","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/11 वा 13 इत्यनेन विभाज्यमानानां पूर्णांशाः n-संख्ययाम् 7 इत्यस्य संख्यां प्रतिपादयतु।    \/\/ >>> fizzBuzz((50l))\n    \/\/ (0l)\n    \/\/ >>> fizzBuzz((78l))\n    \/\/ (2l)\n    \/\/ >>> fizzBuzz((79l))\n    \/\/ (3l)\n    def fizzBuzz(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fizzBuzz(n: Long): Long = {\n    var count = 0L\n    for (i <- 1L until n) {\n      if (i % 11 == 0 || i % 13 == 0) {\n        count += i.toString.count(_ == '7')\n      }\n    }\n    count\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fizzBuzz((50l)) == (0l));\n    assert(fizzBuzz((78l)) == (2l));\n    assert(fizzBuzz((79l)) == (3l));\n    assert(fizzBuzz((100l)) == (3l));\n    assert(fizzBuzz((200l)) == (6l));\n    assert(fizzBuzz((4000l)) == (192l));\n    assert(fizzBuzz((10000l)) == (639l));\n    assert(fizzBuzz((100000l)) == (8026l));\n    }\n\n}\n"},{"task_id":"HumanEval_37","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/इलः इक्-प्रत्ययः, किन्तु विभक्तः।    \/\/l' इत्यनेन l इत्यनेन समानं भवति, यदा इक्-प्रत्ययः भवति, तदा तस्य मानः इक्-प्रत्ययेषु समानः भवति ।    \/\/इदम् फलनम् एकं सूची l गृहीत्वा, सूची l' इत्यनेन परावर्त्तयति यत्     \/\/ >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    \/\/ >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))\n    def sortEven(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ This function takes a list l and returns a list l' such that\n  \/\/ l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  \/\/ to the values of the even indicies of l, but sorted.\n  def sortEven(l: List[Long]): List[Long] = {\n    val evenIndices = l.indices.filter(_ % 2 == 0)\n    val sortedEvens = evenIndices.map(l(_)).sorted\n\n    l.indices.map { index =>\n      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))\n      else l(index)\n    }.toList\n  }\n\n  \/\/ Examples\n  def main(args: Array[String]): Unit = {\n    println(sortEven(List[Long](1L, 2L, 3L)))\n    println(sortEven(List[Long](5L, 6L, 3L, 4L)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));\n    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));\n    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_39","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/prime_fib इत्यनेन n-अङ्कं प्राप्नोति यत् फिबोनैचि-संख्या अस्ति, सः अपि अङ्कः अस्ति ।    \/\/ >>> primeFib((1l))\n    \/\/ (2l)\n    \/\/ >>> primeFib((2l))\n    \/\/ (3l)\n    \/\/ >>> primeFib((3l))\n    \/\/ (5l)\n    \/\/ >>> primeFib((4l))\n    \/\/ (13l)\n    \/\/ >>> primeFib((5l))\n    \/\/ (89l)\n    def primeFib(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def primeFib(n: Long): Long = {\n    \/\/ Function to check if a number is prime\n    def isPrime(num: Long): Boolean = {\n      if (num <= 1) return false\n      if (num == 2) return true\n      if (num % 2 == 0) return false\n      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {\n        if (num % i == 0) return false\n      }\n      true\n    }\n\n    \/\/ Function to generate Fibonacci numbers\n    def fibonacciStream(): Stream[Long] = {\n      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)\n      fibs(0, 1)\n    }\n\n    \/\/ Find the n-th Fibonacci number that is also prime\n    val primeFibs = fibonacciStream().filter(isPrime)\n    primeFibs.take(n.toInt).last\n  }\n\n  \/\/ Test the function\n  def main(args: Array[String]): Unit = {\n    println(primeFib(1L)) \/\/ 2\n    println(primeFib(2L)) \/\/ 3\n    println(primeFib(3L)) \/\/ 5\n    println(primeFib(4L)) \/\/ 13\n    println(primeFib(5L)) \/\/ 89\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) == (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n    assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n    assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"},{"task_id":"HumanEval_40","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/शून्यस्य योगः, अन्यथा च मिथ्या।    \/\/यदि सूचीमध्ये त्रयः पृथक् पृथक् तत्वानि सन्ति, तदा सः सत्यं प्रतिपादयति।    \/\/triple_sum_to_zero इत्यनेन पूर्णाङ्कं प्रविष्टम्।    \/\/ >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))\n    \/\/ (false)\n    \/\/ >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))\n    \/\/ (true)\n    \/\/ >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))\n    \/\/ (false)\n    \/\/ >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))\n    \/\/ (true)\n    \/\/ >>> triplesSumToZero((List[Long](1l.toLong)))\n    \/\/ (false)\n    def triplesSumToZero(l : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ triples_sum_to_zero takes a list of integers as an input.\n    \/\/ it returns true if there are three distinct elements in the list that\n    \/\/ sum to zero, and false otherwise.\n    def triplesSumToZero(l: List[Long]): Boolean = {\n        val n = l.length\n        if (n < 3) return false\n\n        \/\/ Sort the list to use the two-pointer technique\n        val sortedList = l.sorted\n\n        \/\/ Iterate over the list\n        for (i <- 0 until n - 2) {\n            var left = i + 1\n            var right = n - 1\n\n            \/\/ Use two pointers to find the remaining two numbers\n            while (left < right) {\n                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)\n                if (currentSum == 0) {\n                    return true\n                } else if (currentSum < 0) {\n                    left += 1\n                } else {\n                    right -= 1\n                }\n            }\n        }\n\n        false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_41","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/इदम् फलनम् इदम् प्रकारस्य टकराणां संख्यां निर्दिशति ।    \/\/यथा ते न संयोगाः।    \/\/तथापि, कारः अतीव दृढः च भवति, अतः ते गतिं कुर्वन्ति ।    \/\/यदा वामतः दक्षिणतः गच्छन् वाहनं दायाम् वामतः गच्छन् वाहनं प्रति ध्रुवम् करोति।    \/\/सर्वे रथः समानं गच्छति। द्वयोः रथयोः टकराः भवन्ति।    \/\/कारयोः द्वयोः समूहः आरभते, तेषु दूरतः एव।    \/\/n कारः वामतः दक्षिणतः गच्छन्ति; समन्तात्, भिन्नं n कारं भवति ।    \/\/कल्पना करोत यत् एकं मार्गम् पूर्णतया सरलं असीमतः दीर्घं रेखाम् अस्ति ।    def carRaceCollision(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Imagine a road that's a perfectly straight infinitely long line.\n  \/\/ n cars are driving left to right; simultaneously, a different set of n cars\n  \/\/ are driving right to left. The two sets of cars start out being very far from\n  \/\/ each other. All cars move at the same speed. Two cars are said to collide\n  \/\/ when a car that's moving left to right hits a car that's moving right to left.\n  \/\/ However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  \/\/ in their trajectory as if they did not collide.\n  \/\/ This function outputs the number of such collisions.\n  def carRaceCollision(n: Long): Long = {\n    n\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"},{"task_id":"HumanEval_42","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/१-द्वारा वृद्धिं कृतं तत्वं सहितं प्रत्यागमनसूची ।    \/\/ >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    \/\/ >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    \/\/ (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Return list with elements incremented by 1.\n    def incrList(l: List[Long]): List[Long] = {\n        l.map(_ + 1)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_43","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/शून्यस्य योगः, अन्यथा च मिथ्या।    \/\/यदि द्वौ भिन्नौ तत्वौ सन्ति तदा TRUE इत्यस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य प्रत्ययस्य    \/\/pairs_sum_to_zero इत्यनेन पूर्णाङ्काणां सूची प्रविष्टेः ।    \/\/ >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))\n    \/\/ (false)\n    \/\/ >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))\n    \/\/ (false)\n    \/\/ >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))\n    \/\/ (false)\n    \/\/ >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    \/\/ (true)\n    \/\/ >>> pairsSumToZero((List[Long](1l.toLong)))\n    \/\/ (false)\n    def pairsSumToZero(l : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def pairsSumToZero(l: List[Long]): Boolean = {\n        val seen = HashSet[Long]()\n        for (num <- l) {\n            if (seen.contains(-num)) {\n                return true\n            }\n            seen.add(num)\n        }\n        false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_44","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/आधारसंख्या १०-अपेक्षा भवति ।    \/\/रूपांतरणेन पश्चात् स्ट्रिंग् प्रतिपादने प्रतिगमनम् ।    \/\/आगतसंख्याकस्य संख्यात्मकं आधारं आधारं प्रति परिवर्तय।    \/\/ >>> changeBase((8l), (3l))\n    \/\/ (\"22\")\n    \/\/ >>> changeBase((8l), (2l))\n    \/\/ (\"1000\")\n    \/\/ >>> changeBase((7l), (2l))\n    \/\/ (\"111\")\n    def changeBase(x : Long, base : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def changeBase(x: Long, base: Long): String = {\n        require(base > 1 && base < 10, \"Base must be between 2 and 9\")\n        \n        if (x == 0) return \"0\"\n\n        val result = new StringBuilder()\n        var number = x\n\n        while (number > 0) {\n            val remainder = number % base\n            result.append(remainder.toString)\n            number \/= base\n        }\n\n        result.reverse.toString()\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l), (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l), (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\")));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l), (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l), (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n"},{"task_id":"HumanEval_45","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/त्रिभुजस्य पार्श्वस्य दीर्घत्वं, उच्चतरं पुनरागमनक्षेत्रं च दत्त्वा।    \/\/ >>> triangleArea((5l), (3l))\n    \/\/ (7.5f)\n    def triangleArea(a : Long, h : Long) : Float = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Given length of a side and height, return area for a triangle.\n    \/\/ >>> triangleArea(5l, 3l)\n    \/\/ (7.5f)\n    def triangleArea(a: Long, h: Long): Float = {\n        (a * h \/ 2.0).toFloat\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(triangleArea((5l), (3l)) == (7.5f));\n    assert(triangleArea((2l), (2l)) == (2.0f));\n    assert(triangleArea((10l), (8l)) == (40.0f));\n    }\n\n}\n"},{"task_id":"HumanEval_46","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/कृपया एकं फलनं लिखत यत् fib4 क्रमेण n-तमः तत्वं कुशलतया गणनाय शक्नोति। पुनरावृत्तिः न प्रयुज्यते।    \/\/fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ।    \/\/fib4(3) -> 0     \/\/fib4(2) -> 2     \/\/fib4(1) -> 0     \/\/fib4(0) -> 0     \/\/Fib4 क्रमेण Fibbonacci क्रमेण सह समानः क्रमः अस्ति, यस् य परिभाषा अधोलिखितमस्ति:    \/\/ >>> fib4((5l))\n    \/\/ (4l)\n    \/\/ >>> fib4((6l))\n    \/\/ (8l)\n    \/\/ >>> fib4((7l))\n    \/\/ (14l)\n    def fib4(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fib4(n: Long): Long = {\n    if (n == 0 || n == 1) return 0\n    if (n == 2) return 2\n    if (n == 3) return 0\n\n    var a: Long = 0\n    var b: Long = 0\n    var c: Long = 2\n    var d: Long = 0\n    \n    var result: Long = 0\n    \n    for (i <- 4L to n) {\n      result = a + b + c + d\n      a = b\n      b = c\n      c = d\n      d = result\n    }\n    \n    result\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fib4((5l)) == (4l));\n    assert(fib4((8l)) == (28l));\n    assert(fib4((10l)) == (104l));\n    assert(fib4((12l)) == (386l));\n    }\n\n}\n"},{"task_id":"HumanEval_47","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/सूचीषु विद्यमानानां तत्वानां मध्यमाङ्कः l।    \/\/ >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ 3l\n    \/\/ >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))\n    \/\/ (15.0f)\n    def median(l : List[Long]) : Float = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return median of elements in the list l.\n  def median(l: List[Long]): Float = {\n    val sortedList = l.sorted\n    val n = sortedList.length\n    if (n % 2 == 1) {\n      sortedList(n \/ 2).toFloat\n    } else {\n      (sortedList(n \/ 2 - 1) + sortedList(n \/ 2)).toFloat \/ 2\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) \/\/ 3.0\n    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) \/\/ 15.0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);\n    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));\n    assert(median((List[Long](5l.toLong))) == 5l);\n    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));\n    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);\n    }\n\n}\n"},{"task_id":"HumanEval_48","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि दीयते तर्हि सः पालिन्द्रोम् अस्ति वा न इति जाँचयति ।    \/\/ >>> isPalindrome((\"\"))\n    \/\/ (true)\n    \/\/ >>> isPalindrome((\"aba\"))\n    \/\/ (true)\n    \/\/ >>> isPalindrome((\"aaaaa\"))\n    \/\/ (true)\n    \/\/ >>> isPalindrome((\"zbcd\"))\n    \/\/ (false)\n    def isPalindrome(text : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Checks if given string is a palindrome\n  def isPalindrome(text: String): Boolean = {\n    val length = text.length\n    for (i <- 0 until length \/ 2) {\n      if (text(i) != text(length - i - 1)) return false\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isPalindrome((\"\")) == (true));\n    assert(isPalindrome((\"aba\")) == (true));\n    assert(isPalindrome((\"aaaaa\")) == (true));\n    assert(isPalindrome((\"zbcd\")) == (false));\n    assert(isPalindrome((\"xywyx\")) == (true));\n    assert(isPalindrome((\"xywyz\")) == (false));\n    assert(isPalindrome((\"xywzx\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_49","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/2^n माड्यूलो p इत्यस्य प्रतिफलम् ददाति (अङ्केषु ध्यानं कुर्यात्) ।    \/\/ >>> modp((3l), (5l))\n    \/\/ (3l)\n    \/\/ >>> modp((1101l), (101l))\n    \/\/ (2l)\n    \/\/ >>> modp((0l), (101l))\n    \/\/ (1l)\n    \/\/ >>> modp((3l), (11l))\n    \/\/ (8l)\n    \/\/ >>> modp((100l), (101l))\n    \/\/ (1l)\n    def modp(n : Long, p : Long) : Long = {\n","canonical_solution":"def modp(n: Long, p: Long): Long = {\n    \/\/ Calculate 2^n modulo p using iterative exponentiation by squaring.\n    def powMod(base: Long, exp: Long, mod: Long): Long = {\n      var result = 1L\n      var b = base % mod\n      var e = exp\n      \n      while (e > 0) {\n        if ((e & 1) == 1) { \/\/ Check if e is odd\n          result = (result * b) % mod\n        }\n        e >>= 1\n        b = (b * b) % mod\n      }\n\n      result\n    }\n\n    powMod(2, n, p)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"},{"task_id":"HumanEval_51","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/remove_vowels इति कार्यम् अस्ति यत् अकारं गृहीत्वा अकारं विना लभते ।    \/\/ >>> removeVowels((\"\"))\n    \/\/ (\"\")\n    \/\/ >>> removeVowels((\"abcdef\"))\n    \/\/ (\"bcdf\")\n    \/\/ >>> removeVowels((\"aaaaa\"))\n    \/\/ (\"\")\n    \/\/ >>> removeVowels((\"aaBAA\"))\n    \/\/ (\"B\")\n    \/\/ >>> removeVowels((\"zbcd\"))\n    \/\/ (\"zbcd\")\n    def removeVowels(text : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def removeVowels(text: String): String = {\n        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n        text.filterNot(vowels.contains)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(removeVowels((\"\")).equals((\"\")));\n    assert(removeVowels((\"abcdef\\nghijklm\")).equals((\"bcdf\\nghjklm\")));\n    assert(removeVowels((\"fedcba\")).equals((\"fdcb\")));\n    assert(removeVowels((\"eeeee\")).equals((\"\")));\n    assert(removeVowels((\"acBAA\")).equals((\"cB\")));\n    assert(removeVowels((\"EcBOO\")).equals((\"cB\")));\n    assert(removeVowels((\"ybcd\")).equals((\"ybcd\")));\n    }\n\n}\n"},{"task_id":"HumanEval_52","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि सूची l-अन्तर्गतं सर्वम् संख्याः सीमा t-अन्तर्गतं भवति तर्हि TRUE इत्यस्य प्रतिफलं ददाति ।    \/\/ >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))\n    \/\/ (true)\n    \/\/ >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))\n    \/\/ (false)\n    def belowThreshold(l : List[Long], t : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return true if all numbers in the list l are below threshold t.\n  \/\/ >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))\n  \/\/ (true)\n  \/\/ >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))\n  \/\/ (false)\n  def belowThreshold(l: List[Long], t: Long): Boolean = {\n    l.forall(_ < t)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_53","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/द्वौ संख्याः x तथा y समासतः _    \/\/ >>> add((2l), (3l))\n    \/\/ (5l)\n    \/\/ >>> add((5l), (7l))\n    \/\/ (12l)\n    def add(x : Long, y : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Add two numbers x and y\n    \/\/ >>> add((2l), (3l))\n    \/\/ (5l)\n    \/\/ >>> add((5l), (7l))\n    \/\/ (12l)\n    def add(x: Long, y: Long): Long = {\n        x + y\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(add((0l), (1l)) == (1l));\n    assert(add((1l), (0l)) == (1l));\n    assert(add((2l), (3l)) == (5l));\n    assert(add((5l), (7l)) == (12l));\n    assert(add((7l), (5l)) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_54","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि द्वयोः शब्दयोः अक्षरयोः समरूपता अस्ति चेत् निरीक्षणीयम् ।    \/\/ >>> sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n    \/\/ (true)\n    \/\/ >>> sameChars((\"abcd\"), (\"dddddddabc\"))\n    \/\/ (true)\n    \/\/ >>> sameChars((\"dddddddabc\"), (\"abcd\"))\n    \/\/ (true)\n    \/\/ >>> sameChars((\"eabcd\"), (\"dddddddabc\"))\n    \/\/ (false)\n    \/\/ >>> sameChars((\"abcd\"), (\"dddddddabce\"))\n    \/\/ (false)\n    \/\/ >>> sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n    \/\/ (false)\n    def sameChars(s0 : String, s1 : String) : Boolean = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def sameChars(s0: String, s1: String): Boolean = {\n    def charSet(s: String): Set[Char] = s.toSet\n    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(sameChars((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(sameChars((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(sameChars((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(sameChars((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(sameChars((\"aabb\"), (\"aaccc\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_55","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/n-अन्ताम् फिबोनाची-संख्याम् प्रतिपाद्यताम् ।    \/\/ >>> fib((10l))\n    \/\/ (55l)\n    \/\/ >>> fib((1l))\n    \/\/ (1l)\n    \/\/ >>> fib((8l))\n    \/\/ (21l)\n    def fib(n : Long) : Long = {\n","canonical_solution":"def fib(n: Long): Long = {\n        if (n <= 1) n\n        else {\n            var a: Long = 0\n            var b: Long = 1\n            for (_ <- 2L to n) {\n                val temp = a + b\n                a = b\n                b = temp\n            }\n            b\n        }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fib((10l)) == (55l));\n    assert(fib((1l)) == (1l));\n    assert(fib((8l)) == (21l));\n    assert(fib((11l)) == (89l));\n    assert(fib((12l)) == (144l));\n    }\n\n}\n"},{"task_id":"HumanEval_56","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि प्रत्येकं उद्घाटनं ब्रैकेटस्य समानाधिकरणं समापनं ब्रैकेटं भवति तर्हि TRUE इत्युत्तरं ददाति ।    \/\/brackets इत्यस्य \"<\" तथा \">\" इत्यस्य शृङ्गाः सन्ति ।    \/\/ >>> correctBracketing((\"<\"))\n    \/\/ (false)\n    \/\/ >>> correctBracketing((\"<>\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\"<<><>>\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\"><<>\"))\n    \/\/ (false)\n    def correctBracketing(brackets : String) : Boolean = {\n","canonical_solution":"import scala.collection.mutable.Stack\n\nobject Problem {\n  def correctBracketing(brackets: String): Boolean = {\n    val stack = new Stack[Char]()\n    for (char <- brackets) {\n      if (char == '<') {\n        stack.push(char)\n      } else if (char == '>') {\n        if (stack.isEmpty || stack.pop() != '<') {\n          return false\n        }\n      }\n    }\n    stack.isEmpty\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"<>\")) == (true));\n    assert(correctBracketing((\"<<><>>\")) == (true));\n    assert(correctBracketing((\"<><><<><>><>\")) == (true));\n    assert(correctBracketing((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(correctBracketing((\"<<<><>>>>\")) == (false));\n    assert(correctBracketing((\"><<>\")) == (false));\n    assert(correctBracketing((\"<\")) == (false));\n    assert(correctBracketing((\"<<<<\")) == (false));\n    assert(correctBracketing((\">\")) == (false));\n    assert(correctBracketing((\"<<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>><<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>>><>\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_57","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि सूची-तत्त्वे एकवचनं वर्धते वा घटते तर्हि TRUE इत्युत्तरं ददाति ।    \/\/ >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))\n    \/\/ (true)\n    \/\/ >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))\n    \/\/ (false)\n    \/\/ >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))\n    \/\/ (true)\n    def monotonic(l : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return true if list elements are monotonically increasing or decreasing.\n  \/\/ >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))\n  \/\/ (true)\n  \/\/ >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))\n  \/\/ (false)\n  \/\/ >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))\n  \/\/ (true)\n  def monotonic(l: List[Long]): Boolean = {\n    if (l.isEmpty || l.length == 1) return true\n\n    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }\n    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }\n\n    increasing || decreasing\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));\n    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));\n    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));\n    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_58","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/द्वयोः सूत्राणां कृते एकं विशिष्टं सामान्यं तत्वं प्रतिपादयति ।    \/\/ >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n    \/\/ (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n    \/\/ >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n    \/\/ (List[Long](2l.toLong, 3l.toLong))\n    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return sorted unique common elements for two lists.\n  def common(l1: List[Long], l2: List[Long]): List[Long] = {\n    (l1.toSet intersect l2.toSet).toList.sorted\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))\n    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_59","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/n इत्यस्य प्रधानं कारकम् प्रतिपाद्य, n > 1 इति गृहीत्वा, सः प्रधानं न भवति।    \/\/ >>> largestPrimeFactor((13195l))\n    \/\/ (29l)\n    \/\/ >>> largestPrimeFactor((2048l))\n    \/\/ (2l)\n    def largestPrimeFactor(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def largestPrimeFactor(n: Long): Long = {\n        var number = n\n        var largestFactor = 1L\n\n        \/\/ Check for number of 2s that divide n\n        while (number % 2 == 0) {\n            largestFactor = 2L\n            number \/= 2\n        }\n\n        \/\/ n must be odd at this point, so a skip of 2 (i = i + 2) can be used\n        var i = 3\n        while (i <= sqrt(number)) {\n            while (number % i == 0) {\n                largestFactor = i\n                number \/= i\n            }\n            i += 2\n        }\n\n        \/\/ This condition is to check if number is a prime number greater than 2\n        if (number > 2) {\n            largestFactor = number\n        }\n\n        largestFactor\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(largestPrimeFactor((15l)) == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l)) == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l)) == (29l));\n    }\n\n}\n"},{"task_id":"HumanEval_60","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/sum_to_n इत्यस्य फलनम् अस्ति यत् 1 तः n पर्यन्तं संख्यायाः योगं करोति ।    \/\/ >>> sumToN((30l))\n    \/\/ (465l)\n    \/\/ >>> sumToN((100l))\n    \/\/ (5050l)\n    \/\/ >>> sumToN((5l))\n    \/\/ (15l)\n    \/\/ >>> sumToN((10l))\n    \/\/ (55l)\n    \/\/ >>> sumToN((1l))\n    \/\/ (1l)\n    def sumToN(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumToN(n: Long): Long = {\n        (1L to n).sum\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumToN((1l)) == (1l));\n    assert(sumToN((6l)) == (21l));\n    assert(sumToN((11l)) == (66l));\n    assert(sumToN((30l)) == (465l));\n    assert(sumToN((100l)) == (5050l));\n    }\n\n}\n"},{"task_id":"HumanEval_61","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि प्रत्येकं उद्घाटनं ब्रैकेटस्य समानाधिकरणं समापनं ब्रैकेटं भवति तर्हि TRUE इत्युत्तरं ददाति ।    \/\/\"{\"अन्तर्भावेन \"} इत्यस्य अङ्गस्य \"{\" इत्यस्य च\" इत्यस्य अङ्गस्य च\" इत्यस्य अङ्गस्य च।    \/\/ >>> correctBracketing((\"(\"))\n    \/\/ (false)\n    \/\/ >>> correctBracketing((\"()\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\"(()())\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\")(()\"))\n    \/\/ (false)\n    def correctBracketing(brackets : String) : Boolean = {\n","canonical_solution":"var balance = 0\n        for (ch <- brackets) {\n            if (ch == '(') balance += 1\n            else if (ch == ')') balance -= 1\n            \n            if (balance < 0) return false\n        }\n        balance == 0\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"()\")) == (true));\n    assert(correctBracketing((\"(()())\")) == (true));\n    assert(correctBracketing((\"()()(()())()\")) == (true));\n    assert(correctBracketing((\"()()((()()())())(()()(()))\")) == (true));\n    assert(correctBracketing((\"((()())))\")) == (false));\n    assert(correctBracketing((\")(()\")) == (false));\n    assert(correctBracketing((\"(\")) == (false));\n    assert(correctBracketing((\"((((\")) == (false));\n    assert(correctBracketing((\")\")) == (false));\n    assert(correctBracketing((\"(()\")) == (false));\n    assert(correctBracketing((\"()()(()())())(()\")) == (false));\n    assert(correctBracketing((\"()()(()())()))()\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_62","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः पुनः    \/\/xs[0] + xs[1] * x + xs[2] * x^2 + ....     \/\/xs इत्यनेन बहुपदस्य गुणाङ्कः भवति।    \/\/ >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))\n    \/\/ >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 6l.toLong))\n    def derivative(xs : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def derivative(xs: List[Long]): List[Long] = {\n    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));\n    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));\n    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));\n    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_63","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/कृपया एकं फलनं लिखत यत् फ्लिप्-फ्लप्-फ्लप्-संख्यकक्रमेण n-अंशं गणनाय समर्थं भवेत् ।    \/\/fibfib{\\ n (n) } == fibfib{\\ n (n-1) + fibfib{\\ n (n-2) + fibfib{\\ n (n-3) }) ==    \/\/fib fib ((२) == १     \/\/fib fib{}1) == 0     \/\/fib fib{}0) == 0     \/\/FibFib संख्याक्रमः Fibbonacci अनुक्रमस्य समानः अनुक्रमः अस्ति यत् अधोलिखितप्रकारेण परिभाषितः अस्ति:    \/\/ >>> fibfib((1l))\n    \/\/ (0l)\n    \/\/ >>> fibfib((5l))\n    \/\/ (4l)\n    \/\/ >>> fibfib((8l))\n    \/\/ (24l)\n    def fibfib(n : Long) : Long = {\n","canonical_solution":"def fibfib(n: Long): Long = {\n    if (n == 0) return 0\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a: Long = 0\n    var b: Long = 0\n    var c: Long = 1\n    var d: Long = 0\n\n    for (_ <- 3L to n) {\n      d = a + b + c\n      a = b\n      b = c\n      c = d\n    }\n    d\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fibfib((2l)) == (1l));\n    assert(fibfib((1l)) == (0l));\n    assert(fibfib((5l)) == (4l));\n    assert(fibfib((8l)) == (24l));\n    assert(fibfib((10l)) == (81l));\n    assert(fibfib((12l)) == (274l));\n    assert(fibfib((14l)) == (927l));\n    }\n\n}\n"},{"task_id":"HumanEval_64","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/स्वरः, किन्तु केवलं यदा सः विहितशब्देन अन्ते भवति।    \/\/अत्र 'अ', 'इ', 'इ', 'ओ', 'उ' इत्यनेन स्वरैः 'य' इत्यपि भवति।    \/\/शब्दः प्रविष्टः अस्ति, सः शब्दस्य अन्तर्गतस्य स्वरस्य सङ्ख्यां प्रति लभते।    \/\/एकं फलनम् लिखत, यः स्वरगणनम् करोति, यः  इत्यस्य प्रतिनिधित्वं करोति।    \/\/ >>> vowelsCount((\"abcde\"))\n    \/\/ (2l)\n    \/\/ >>> vowelsCount((\"ACEDY\"))\n    \/\/ (3l)\n    def vowelsCount(s : String) : Long = {\n","canonical_solution":"def vowelsCount(s: String): Long = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u')\n    val lowerCaseWord = s.toLowerCase\n    var count = 0L\n\n    for (i <- lowerCaseWord.indices) {\n      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {\n        count += 1\n      }\n    }\n\n    count\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(vowelsCount((\"abcde\")) == (2l));\n    assert(vowelsCount((\"Alone\")) == (3l));\n    assert(vowelsCount((\"key\")) == (2l));\n    assert(vowelsCount((\"bye\")) == (1l));\n    assert(vowelsCount((\"keY\")) == (2l));\n    assert(vowelsCount((\"bYe\")) == (1l));\n    assert(vowelsCount((\"ACEDY\")) == (3l));\n    }\n\n}\n"},{"task_id":"HumanEval_65","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि shift > संख्याः, तदा संख्याः प्रतिवर्त्यताम् ।    \/\/एवं च परिणामं शृङ्गाररूपेण प्रतिपादयति ।    \/\/वृत्तिकः स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने स्थाने    \/\/ >>> circularShift((12l), (1l))\n    \/\/ (\"21\")\n    \/\/ >>> circularShift((12l), (2l))\n    \/\/ (\"12\")\n    def circularShift(x : Long, shift : Long) : String = {\n","canonical_solution":"def circularShift(x: Long, shift: Long): String = {\n  val digits = x.toString\n  val length = digits.length\n  \n  if (shift >= length) {\n    digits.reverse\n  } else {\n    val effectiveShift = (length - shift % length).toInt\n    (digits.drop(effectiveShift) + digits.take(effectiveShift))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l), (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\")));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l), (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\")));\n    }\n\n}\n"},{"task_id":"HumanEval_66","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/ASCII कोडः     \/\/'इति सूत्रं लिखत, यस्मिन् इङ्पुटः क्तः भवति, तथा च केवलम् उपरि वर्णानां योगः लभते' इति सूत्रं लिखत।    \/\/कार्यम्     \/\/ >>> digitSum((\"\"))\n    \/\/ (0l)\n    \/\/ >>> digitSum((\"abAB\"))\n    \/\/ (131l)\n    \/\/ >>> digitSum((\"abcCd\"))\n    \/\/ (67l)\n    \/\/ >>> digitSum((\"helloE\"))\n    \/\/ (69l)\n    \/\/ >>> digitSum((\"woArBld\"))\n    \/\/ (131l)\n    \/\/ >>> digitSum((\"aAaaaXa\"))\n    \/\/ (153l)\n    def digitSum(s : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def digitSum(s: String): Long = {\n    s.filter(_.isUpper).map(_.toLong).sum\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(digitSum((\"\")) == (0l));\n    assert(digitSum((\"abAB\")) == (131l));\n    assert(digitSum((\"abcCd\")) == (67l));\n    assert(digitSum((\"helloE\")) == (69l));\n    assert(digitSum((\"woArBld\")) == (131l));\n    assert(digitSum((\"aAaaaXa\")) == (153l));\n    assert(digitSum((\" How are yOu?\")) == (151l));\n    assert(digitSum((\"You arE Very Smart\")) == (327l));\n    }\n\n}\n"},{"task_id":"HumanEval_67","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/प्रतिपाद्यार्थः     \/\/अङ्गुलफलानां संख्यां प्रतिपादयतु।    \/\/अनारङ्गेषु, सेफसु च, एकं पूर्णांकं, यानि फलानां संख्याः दर्शयन्ति।    \/\/णकारस्य णकारस्य णकारस्य च णकारस्य च णकारस्य च णकारस्य च णकारस्य च णकारस्य च णकारस्य च णकारस्य च णकारस्य च    \/\/फलानां कोशेषु वितरन्ति ये फलानि कोशेषु सन्ति।    \/\/अस्मिन् कार्ये, भवता एकं शृङ्खलं दत्ता भवति यत् अनेन संख्याभिः सेबैः, नारिकेलैः च प्रतिपादितं भवति ।    \/\/ >>> fruitDistribution((\"5 apples and 6 oranges\"), (19l))\n    \/\/ (8l)\n    \/\/ >>> fruitDistribution((\"0 apples and 1 oranges\"), (3l))\n    \/\/ (2l)\n    \/\/ >>> fruitDistribution((\"2 apples and 3 oranges\"), (100l))\n    \/\/ (95l)\n    \/\/ >>> fruitDistribution((\"100 apples and 1 oranges\"), (120l))\n    \/\/ (19l)\n    def fruitDistribution(s : String, n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fruitDistribution(s: String, n: Long): Long = {\n    val fruits = s.split(\" and \").map(_.split(\" \")(0).toLong)\n    val totalApplesAndOranges = fruits.sum\n    n - totalApplesAndOranges\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fruitDistribution((\"5 apples and 6 oranges\"), (19l)) == (8l));\n    assert(fruitDistribution((\"5 apples and 6 oranges\"), (21l)) == (10l));\n    assert(fruitDistribution((\"0 apples and 1 oranges\"), (3l)) == (2l));\n    assert(fruitDistribution((\"1 apples and 0 oranges\"), (3l)) == (2l));\n    assert(fruitDistribution((\"2 apples and 3 oranges\"), (100l)) == (95l));\n    assert(fruitDistribution((\"2 apples and 3 oranges\"), (5l)) == (0l));\n    assert(fruitDistribution((\"1 apples and 100 oranges\"), (120l)) == (19l));\n    }\n\n}\n"},{"task_id":"HumanEval_68","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् १:     \/\/यदि न च समं मूल्यम् अस्ति, अथवा सूची रिक्तः अस्ति, तर्हि पुनः [] प्रत्ययः प्राप्नोति ।    \/\/नपुंसकलिङ्गेन सूत्रेण इदम् प्रतिपादितम् अस्ति, [smallest_value, its index],     \/\/यदि बहुषु नोडस् मध्ये लघुतमः सममूल्यम् अस्ति, तर्हि लघुतमः सूचकः अस्ति इति नोडस् प्रति लभेत।    \/\/नपुंसकलिङ्गेन नपुंसकलिङ्गेन लघुतमः सममूल्यस्य नपुंसकलिङ्गेन प्राप्तः भवेत् ।    \/\/भवतां कार्यम् अस्ति यत् एकं नोडं विच्छेदयित्वा पुनः पुनर्स्थापयितव्।    \/\/\"अत्र सूची अस्ति, यस्मिन् वृक्षस्य शाखाः सन्ति, येषु न-ऋणात्मकः पूर्णाङ्कः अस्ति ।    \/\/ >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 1l.toLong))\n    \/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    \/\/ Example 2:\n    \/\/ >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 1l.toLong))\n    \/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    \/\/ Example 3:\n    \/\/ >>> pluck((List[Long]()))\n    \/\/ (List[Long]())\n    \/\/ Example 4:\n    \/\/ >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    \/\/ (List[Long](0l.toLong, 1l.toLong))\n    \/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n    \/\/ so we will choose the first zero, which has the smallest index.\n    \/\/ Constraints:\n    \/\/ * 1 <= nodes.length <= 10000\n    \/\/ * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def pluck(arr: List[Long]): List[Long] = {\n    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }\n    if (evenNodes.isEmpty) {\n      List.empty[Long]\n    } else {\n      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }\n      List(smallestValue, index.toLong)\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_69","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि एतादृशम् मूल्यम् न अस्ति तर्हि -१ इत्यस्य प्रतिफलम् ददाति ।    \/\/एकस्य पूर्णाङ्कः सूचीषु कतिधा दृश्यते, तत् एव तस्य आवृत्तिः भवति ।    \/\/शून्यः, एवं च तस्य आवृत्तिः पूर्णाङ्के स्वस्य मूल्यस्य वा अधिकः वा समः अस्ति ।    \/\/भवद्भ् यः धनात्मकपूर्णाङ्काणां सूची दीयते, अतः -तः अधिकं पूर्णसंख्यां लभेत    \/\/ >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\n    \/\/ (2l)\n    \/\/ >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n    \/\/ (-1l)\n    def search(lst : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def search(lst: List[Long]): Long = {\n    val frequencyMap = lst.groupBy(identity).mapValues(_.size)\n    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {\n      case x :: _ => x\n      case Nil => -1L\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong))) == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"},{"task_id":"HumanEval_70","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/ततः शेषपूर्णां संख्यानां अधिकतमं, ततः न्यूनं इत्यादीनि।    \/\/विचित्रः क्रमणीकरणः, यदा भवन्तः न्यूनतमं मूल्यम् आरभन्ते,     \/\/पूर्णाङ्काणां सूची प्राप्ते, सूची विचित्र क्रमेण लभ्यते।    \/\/ >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))\n    \/\/ >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))\n    \/\/ (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))\n    \/\/ >>> strangeSortList((List[Long]()))\n    \/\/ (List[Long]())\n    def strangeSortList(lst : List[Long]) : List[Long] = {\n","canonical_solution":"def strangeSortList(lst: List[Long]): List[Long] = {\n    val buffer = lst.sorted.toBuffer\n    val result = ArrayBuffer[Long]()\n    var takeMin = true\n\n    while (buffer.nonEmpty) {\n      if (takeMin) {\n        result += buffer.remove(0) \/\/ take the minimum\n      } else {\n        result += buffer.remove(buffer.length - 1) \/\/ take the maximum of the remaining\n      }\n      takeMin = !takeMin\n    }\n\n    result.toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_71","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/तृतीयपक्षस्य तु।    \/\/त्रयो पक्षः त्रिकोणाः भवन्ति यदा द्वयोः पक्षयोः योगः अधिकः भवति।    \/\/अन्यथा परतः -1     \/\/यदि त्रिषु पक्षेषु त्रिभुजः भवति, तर्हि त्रिकोणस्य द्विदशम्याम् अङ्कं कृत्वा परिमण्डलं कुर्यात् ।    \/\/त्रिकोणस्य त्रिषु पक्षेषु दीर्घत्वं दत्त्वा,  इत्यस्य क्षेत्रफलं प्रतिपाद्यताम्    \/\/ >>> triangleArea((3l), (4l), (5l))\n    \/\/ (6.0f)\n    \/\/ >>> triangleArea((1l), (2l), (10l))\n    \/\/ -1l\n    def triangleArea(a : Long, b : Long, c : Long) : Float = {\n","canonical_solution":"import scala.math._\n\nobject Problem {\n  def triangleArea(a: Long, b: Long, c: Long): Float = {\n    if (a + b > c && a + c > b && b + c > a) {\n      val s = (a + b + c) \/ 2.0\n      val area = sqrt(s * (s - a) * (s - b) * (s - c))\n      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat\n    } else {\n      -1f\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(triangleArea((3l), (4l), (5l)) == (6.0f));\n    assert(triangleArea((1l), (2l), (10l)) == -1l);\n    assert(triangleArea((4l), (8l), (5l)) == (8.18f));\n    assert(triangleArea((2l), (2l), (2l)) == (1.73f));\n    assert(triangleArea((1l), (2l), (3l)) == -1l);\n    assert(triangleArea((10l), (5l), (7l)) == (16.25f));\n    assert(triangleArea((2l), (6l), (3l)) == -1l);\n    assert(triangleArea((1l), (1l), (1l)) == (0.43f));\n    assert(triangleArea((2l), (2l), (10l)) == -1l);\n    }\n\n}\n"},{"task_id":"HumanEval_72","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/वस्तु q उड्डाणम् करोति यदि सः संतुलितः अस्ति (अयं एकं पालिन्द्रोमिक-सूची) एवं तस्य तत्वानां योगः अधिकतमसम्भाव्य भारात् (w) न्यूनः अथवा समः अस्ति ।    \/\/यदि वस्तु q उड्डाणम् करोति तर्हि सत्यं, अन्यथा मिथ्याम् इति फलनम् लिखत।    \/\/ >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\n    \/\/ (false)\n    \/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n    \/\/ >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))\n    \/\/ (false)\n    \/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n    \/\/ >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\n    \/\/ (true)\n    \/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n    \/\/ >>> willItFly((List[Long](3l.toLong)), (5l))\n    \/\/ (true)\n    \/\/ # 3 is less than the maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def willItFly(q: List[Long], w: Long): Boolean = {\n    val isPalindromic = q == q.reverse\n    val sumOfElements = q.sum\n    isPalindromic && sumOfElements <= w\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(willItFly(List[Long](1L, 2L), 5L)) \/\/ false\n    println(willItFly(List[Long](3L, 2L, 3L), 1L)) \/\/ false\n    println(willItFly(List[Long](3L, 2L, 3L), 9L)) \/\/ true\n    println(willItFly(List[Long](3L), 5L)) \/\/ true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_73","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/एकस्मिन् परिवर्तनकाले, भवन्तः एकं तत्वं अन्यं तत्वं प्रति परिवर्तयितुं शक्नुवन्ति ।    \/\/सूचीं पालिन्द्रोमिकायां कर्तुं परिवर्तनं करणीयम् ।    \/\/पूर्णाङ्काणां सूची आरः दत्त्वा,  इत्यनेन न्यूनतमानां संख्यां ज्ञातव्यम्    \/\/ >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    \/\/ (4l)\n    \/\/ >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))\n    \/\/ (0l)\n    def smallestChange(arr : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given a list arr of integers, find the minimum number of elements that\n  \/\/ need to be changed to make the list palindromic.\n\n  def smallestChange(arr: List[Long]): Long = {\n    var changes: Long = 0\n\n    for (i <- 0 until arr.length \/ 2) {\n      if (arr(i) != arr(arr.length - 1 - i)) {\n        changes += 1\n      }\n    }\n\n    changes\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  \/\/ Output: 4\n    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  \/\/ Output: 1\n    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  \/\/ Output: 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_74","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/यदि द्वयोः सूत्राणां संख्या समानं भवति, तर्हि प्रथमं सूचिः प्रतिपादितः भवति ।    \/\/सूचीषु सर्वेषु वर्णसूत्रेषु वर्णानां संख्या अन्यसूत्रेषु संख्यायां न्यूनम् अस्ति ।    \/\/क्त्वाः द्वयोः सूचीषु क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः क्त्वाः    \/\/ >>> totalMatch((List[String]()), (List[String]()))\n    \/\/ (List[String]())\n    \/\/ >>> totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"Hi\")))\n    \/\/ (List[String](\"hI\", \"Hi\"))\n    \/\/ >>> totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\", \"admin\", \"project\")))\n    \/\/ (List[String](\"hi\", \"admin\"))\n    \/\/ >>> totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hi\")))\n    \/\/ (List[String](\"hI\", \"hi\", \"hi\"))\n    \/\/ >>> totalMatch((List[String](\"4\")), (List[String](\"1\", \"2\", \"3\", \"4\", \"5\")))\n    \/\/ (List[String](\"4\"))\n    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {\n    val sum1 = lst1.map(_.length).sum\n    val sum2 = lst2.map(_.length).sum\n    if (sum1 <= sum2) lst1 else lst2\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\"))).equals((List[String](\"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\", \"admin\", \"project\"))).equals((List[String](\"hi\", \"admin\"))));\n    assert(totalMatch((List[String](\"4\")), (List[String](\"1\", \"2\", \"3\", \"4\", \"5\"))).equals((List[String](\"4\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"Hi\"))).equals((List[String](\"hI\", \"Hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hi\"))).equals((List[String](\"hI\", \"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hii\"))).equals((List[String](\"hi\", \"admin\"))));\n    assert(totalMatch((List[String]()), (List[String](\"this\"))).equals((List[String]())));\n    assert(totalMatch((List[String](\"this\")), (List[String]())).equals((List[String]())));\n    }\n\n}\n"},{"task_id":"HumanEval_75","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/(a) 100 इत्यतः न्यूनं भवति इति ज्ञात्वा।    \/\/अन्यथा मिथ्या।    \/\/यदि दीयते तदा ३ अभाज्यसंख्यायाः गुणनम् भवति इति फलनम् लिखत ।    \/\/ >>> isMultiplyPrime((30l))\n    \/\/ (true)\n    \/\/ 30 = 2 * 3 * 5\n    def isMultiplyPrime(a : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isMultiplyPrime(a: Long): Boolean = {\n    def isPrime(num: Long): Boolean = {\n      if (num <= 1) return false\n      if (num <= 3) return true\n      if (num % 2 == 0 || num % 3 == 0) return false\n      var i = 5\n      while (i * i <= num) {\n        if (num % i == 0 || num % (i + 2) == 0) return false\n        i += 6\n      }\n      true\n    }\n\n    val primes = (2L to 100L).filter(isPrime)\n    val primeList = primes.toList\n\n    for {\n      i <- primeList.indices\n      j <- i until primeList.size\n      k <- j until primeList.size\n      if primeList(i) * primeList(j) * primeList(k) == a\n    } return true\n\n    false\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isMultiplyPrime((5l)) == (false));\n    assert(isMultiplyPrime((30l)) == (true));\n    assert(isMultiplyPrime((8l)) == (true));\n    assert(isMultiplyPrime((10l)) == (false));\n    assert(isMultiplyPrime((125l)) == (true));\n    assert(isMultiplyPrime((105l)) == (true));\n    assert(isMultiplyPrime((126l)) == (false));\n    assert(isMultiplyPrime((729l)) == (false));\n    assert(isMultiplyPrime((891l)) == (false));\n    assert(isMultiplyPrime((1001l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_76","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/यदि n**int=x  भवति तर्हि x इत्यस्य n इत्यस्य सरलः गुणः भवति।    \/\/n-शक्त्या च अन्यत्र मिथ्या ।    \/\/भवतां कार्यम् अस्ति यत्, यदि संख्याः x अस्ति, तदा सः फलनम् लिखतु, यत् सत्यं प्रतिपादयतु।    \/\/ >>> isSimplePower((1l), (4l))\n    \/\/ (true)\n    \/\/ >>> isSimplePower((2l), (2l))\n    \/\/ (true)\n    \/\/ >>> isSimplePower((8l), (2l))\n    \/\/ (true)\n    \/\/ >>> isSimplePower((3l), (2l))\n    \/\/ (false)\n    \/\/ >>> isSimplePower((3l), (1l))\n    \/\/ (false)\n    \/\/ >>> isSimplePower((5l), (3l))\n    \/\/ (false)\n    def isSimplePower(x : Long, n : Long) : Boolean = {\n","canonical_solution":"def isSimplePower(x: Long, n: Long): Boolean = {\n        if (n == 1) {\n            return x == 1\n        }\n        \n        var value: Long = n\n        while (value <= x) {\n            if (value == x) {\n                return true\n            }\n            \n            if (value > Long.MaxValue \/ n) {\n                return false\n            }\n            value *= n\n        }\n        \n        false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_77","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/नोटः भवता अनुमानः क्रियते यत् आगतं सर्वदा वैधं भवति ।    \/\/यदि इङ्गेर् इङ्गेर् इति कस्यचित् पूर्णाङ्कः अस्ति, तर्हि इङ्गेर् इति कस्यचित् पूर्णाङ्कः अस्ति ।    \/\/एकं फलनम् लिखत, यस्मिन् पूर्णाङ्कः a भवति, अतः इदम् फलं भवति true.    \/\/ >>> iscube((1l))\n    \/\/ (true)\n    \/\/ >>> iscube((2l))\n    \/\/ (false)\n    \/\/ >>> iscube((-1l))\n    \/\/ (true)\n    \/\/ >>> iscube((64l))\n    \/\/ (true)\n    \/\/ >>> iscube((0l))\n    \/\/ (true)\n    \/\/ >>> iscube((180l))\n    \/\/ (false)\n    def iscube(a : Long) : Boolean = {\n","canonical_solution":"def iscube(a: Long): Boolean = {\n  val cubeRoot = math.cbrt(a.toDouble).round\n  cubeRoot * cubeRoot * cubeRoot == a\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(iscube((1l)) == (true));\n    assert(iscube((2l)) == (false));\n    assert(iscube((-1l)) == (true));\n    assert(iscube((64l)) == (true));\n    assert(iscube((180l)) == (false));\n    assert(iscube((1000l)) == (true));\n    assert(iscube((0l)) == (true));\n    assert(iscube((1729l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_78","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/एवं च A, B, C, D, E, F इति सङ्केताः सदैव अपरकेसिकाः भवन्ति ।    \/\/नोटः भवता अनुमानः कर्तुं शक्यते यत् आगतं सर्वदा उचितं वा रिक्तं भवति,     \/\/B (= दशमलव 11), D (= दशमलव 13) ।    \/\/अतः भवन्तः अधोलिखितानां संख्यायाः संख्यां निर्धारयितुम् आवश् यकाः सन् ति: 2, 3, 5, 7,     \/\/अभाज्यसंख्याः सन्ति २, ३, ५, ७, ११, १३, १७,...    \/\/षोडशसंख्यायाः अङ्काः सन्ति - ०,१,२,३,४,५,६,७,८,९, ए,बी,सी,डी,ई,एफ।    \/\/१-अधिकं यत् द्वयोः लघुतमयोः प्राकृतसंख्यानां गुणनफलं न भवति) ।    \/\/अभाज्यसंख्याः (अभाज्यसंख्याः, वा अभाज्यसंख्याः, एकं प्राकृतसंख्या अस्ति ।    \/\/षोडशसंख्यायाः सङ्ख्यां यथा शृङ्गारं कृत्वा षोडशसंख्यायाः सङ्ख्यां गणयति ।    \/\/भवद्भिः एकं फलनम् लिखितम् अस्ति यत् प्राप्तं करोति ।    \/\/ >>> hexKey((\"AB\"))\n    \/\/ (1l)\n    \/\/ >>> hexKey((\"1077E\"))\n    \/\/ (2l)\n    \/\/ >>> hexKey((\"ABED1A33\"))\n    \/\/ (4l)\n    \/\/ >>> hexKey((\"123456789ABCDEF0\"))\n    \/\/ (6l)\n    \/\/ >>> hexKey((\"2020\"))\n    \/\/ (2l)\n    def hexKey(num : String) : Long = {\n","canonical_solution":"def hexKey(num: String): Long = {\n  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')\n  num.count(ch => primeHexDigits.contains(ch)).toLong\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_79","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/अत्र अतिरिक्तवर्णः स्वरूपस्य सहाय्यं कर्तुम् अस्ति ।    \/\/अत्र क्त-प्रत्ययस्य आरम्भ-अन्ते क्त-प्रत्यययोः अतिरिक्तं क्त-प्रत्यययोः 'db' वर्णयोः प्रयोगः भवति ।    \/\/संख्याः। प्रत्येकं अक्षरं '0' अथवा '1' भवति।    \/\/द्विवचनरूपेण लिखत। कार्यस्य एकं स्ट्रिंगं प्रतिपादयितुम् अपेक्षते, यस्मिन् प्रत्येकं वर्णः द्विवचनरूपेण लिखत।    \/\/भवता दशमलवरूपेण संख्या दीयते, भवतां कार्यम् अस्ति यत् एतस्य रूपांतरं करणीयम्।    \/\/ >>> decimalToBinary((15l))\n    \/\/ (\"db1111db\")\n    \/\/ >>> decimalToBinary((32l))\n    \/\/ (\"db100000db\")\n    def decimalToBinary(decimal : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def decimalToBinary(decimal: Long): String = {\n    \"db\" + decimal.toBinaryString + \"db\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"},{"task_id":"HumanEval_80","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/यदि तस्य दीर्घत्वं कतमः 3 भवति, तथा च प्रत्येकं 3 अनुक्रमिकं अक्षरं विशिष्यते, तर्हि सः Hapscala इति कथ्यते.    \/\/भवतां कार्यम् अस्ति यत्, यदि स्ट्रन्ग् हप्स्केल् अस्ति अथवा न अस्ति तर्हि जाँचं कुरुत।    \/\/भवद्भिरपि क्तप्रत्ययस्य लकारः प्राप्नोति ।    \/\/ >>> isHappy((\"a\"))\n    \/\/ (false)\n    \/\/ >>> isHappy((\"aa\"))\n    \/\/ (false)\n    \/\/ >>> isHappy((\"abcd\"))\n    \/\/ (true)\n    \/\/ >>> isHappy((\"aabb\"))\n    \/\/ (false)\n    \/\/ >>> isHappy((\"adb\"))\n    \/\/ (true)\n    \/\/ >>> isHappy((\"xyy\"))\n    \/\/ (false)\n    def isHappy(s : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isHappy(s: String): Boolean = {\n    if (s.length < 3) return false \n\n    for (i <- 0 until s.length - 2) {\n      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {\n        return false\n      }\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isHappy((\"a\")) == (false));\n    assert(isHappy((\"aa\")) == (false));\n    assert(isHappy((\"abcd\")) == (true));\n    assert(isHappy((\"aabb\")) == (false));\n    assert(isHappy((\"adb\")) == (true));\n    assert(isHappy((\"xyy\")) == (false));\n    assert(isHappy((\"iopaxpoi\")) == (true));\n    assert(isHappy((\"iopaxioi\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_81","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/०.० ई     \/\/> 0.0 D-     \/\/> 0.7 D     \/\/> १.० D+     \/\/> १.३ C-     \/\/> 1.7 C     \/\/> 2.0 C+     \/\/> २.३ B-     \/\/> २.७ B     \/\/> ३.० B+     \/\/> ३.३ A-     \/\/> ३.७ अ     \/\/४.० अ+     \/\/GPA। अक्षर-गुणः।    \/\/एकं फलनम्, यः अधोलिखितम् सारणीं उपयुज्य अक्षरश्रेणीनां सूचीं निर्गमयति:     \/\/सा भवतः कियत् छात्राणां गुणसूचीं ददाति, भवता लिखितुं अपेक्षते।    \/\/केवलं समस्या अस्ति यत्, सा स्खलनार्थं प्रयुक्तं कोडं गमयति।    \/\/शिक्षकः स्वस्य गुणनिर्धारणस्य एल्गोरिदमं निर्मातवान् ।    \/\/अयं सेमेस्टरस्य अन्तिमः सप्ताहः अस्ति, अध्यापकः ग्रेडं ददाति।    \/\/ >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))\n    \/\/ (List[String](\"A+\", \"B\", \"C-\", \"C\", \"A-\"))\n    def numericalLetterGrade(grades : List[Float]) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def numericalLetterGrade(grades: List[Float]): List[String] = {\n    grades.map { gpa =>\n      gpa match {\n        case g if g == 4.0 => \"A+\"\n        case g if g > 3.7 => \"A\"\n        case g if g > 3.3 => \"A-\"\n        case g if g > 3.0 => \"B+\"\n        case g if g > 2.7 => \"B\"\n        case g if g > 2.3 => \"B-\"\n        case g if g > 2.0 => \"C+\"\n        case g if g > 1.7 => \"C\"\n        case g if g > 1.3 => \"C-\"\n        case g if g > 1.0 => \"D+\"\n        case g if g > 0.7 => \"D\"\n        case g if g > 0.0 => \"D-\"\n        case _ => \"E\"\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)\n    println(numericalLetterGrade(grades)) \/\/ Output: List(A+, B, C-, C, A-)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](\"A+\", \"B\", \"C-\", \"C\", \"A-\"))));\n    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](\"D+\"))));\n    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](\"D-\"))));\n    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](\"E\"))));\n    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](\"D\", \"D-\", \"C-\", \"B\", \"B+\"))));\n    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](\"E\", \"D-\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_82","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/दीर्घः अभाज्यसंख्या अस्ति अन्यथा असत्यम् अस्ति ।    \/\/यदि string इत्यस्य प्रत्ययः भवति तर्हि function इत्यस्य true इत्यस्य प्रत्ययः भवति ।    \/\/ >>> primeLength((\"Hello\"))\n    \/\/ (true)\n    \/\/ >>> primeLength((\"abcdcba\"))\n    \/\/ (true)\n    \/\/ >>> primeLength((\"kittens\"))\n    \/\/ (true)\n    \/\/ >>> primeLength((\"orange\"))\n    \/\/ (false)\n    def primeLength(string : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def primeLength(string: String): Boolean = {\n    val length = string.length\n\n    if (length <= 1) return false\n    \n    for (i <- 2 to sqrt(length).toInt) {\n      if (length % i == 0) return false\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(primeLength((\"Hello\")) == (true));\n    assert(primeLength((\"abcdcba\")) == (true));\n    assert(primeLength((\"kittens\")) == (true));\n    assert(primeLength((\"orange\")) == (false));\n    assert(primeLength((\"wow\")) == (true));\n    assert(primeLength((\"world\")) == (true));\n    assert(primeLength((\"MadaM\")) == (true));\n    assert(primeLength((\"Wow\")) == (true));\n    assert(primeLength((\"\")) == (false));\n    assert(primeLength((\"HI\")) == (true));\n    assert(primeLength((\"go\")) == (true));\n    assert(primeLength((\"gogo\")) == (false));\n    assert(primeLength((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(primeLength((\"Madam\")) == (true));\n    assert(primeLength((\"M\")) == (false));\n    assert(primeLength((\"0\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_83","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/धनात्मकं पूर्णाङ्कं यः १-अङ्कं आरभते वा अन्तयति।    \/\/धनात्मकं पूर्णाङ्कं n प्राप्नोति, अतः n-अङ्केषु संख्यायाः गणना करणीया भवति।    def startsOneEnds(n : Long) : Long = {\n","canonical_solution":"def startsOneEnds(n: Long): Long = {\n        if (n <= 0) return 0\n        \n        \/\/ Calculate numbers starting with 1: 1XX...X (n-1) digits after 1\n        val startWithOne: Long = math.pow(10, n - 1).toLong\n        \n        \/\/ Calculate numbers ending with 1: XX...X1 (n-1) digits before 1\n        \/\/ but without leading zeroes allowed, i.e., the first digit can't be zero\n        val endWithOne: Long = math.pow(10, n - 1).toLong\n        \n        \/\/ Reverse counting: numbers starting and ending with 1 (11XX...X)\n        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0\n        \n        \/\/ The total numbers starting or ending, or both, with 1\n        startWithOne + endWithOne - bothStartAndEndWithOne\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(startsOneEnds((1l)) == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l)) == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l)) == (18000l));\n    }\n\n}\n"},{"task_id":"HumanEval_84","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/धनात्मकं पूर्णाङ्कं N लभ्यते, तस्य द्विवचनसंख्यकानां योगं प्रतिपादयतु।    \/\/ >>> solve((1000l))\n    \/\/ (\"1\")\n    \/\/ >>> solve((150l))\n    \/\/ (\"110\")\n    \/\/ >>> solve((147l))\n    \/\/ (\"1100\")\n    \/\/ Variables:\n    \/\/ @N integer\n    \/\/ Constraints: 0 ≤ N ≤ 10000.\n    \/\/ Output:\n    \/\/ a string of binary number\n    def solve(N : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ Given a positive integer N, return the total sum of its digits in binary.\n    def solve(N: Long): String = {\n        val sumOfDigits = N.toString.map(_.asDigit).sum\n        sumOfDigits.toBinaryString\n    }\n\n    def main(args: Array[String]): Unit = {\n        println(solve(1000L))  \/\/ should print \"1\"\n        println(solve(150L))   \/\/ should print \"110\"\n        println(solve(147L))   \/\/ should print \"1100\"\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"},{"task_id":"HumanEval_85","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/पूर्णाङ्काणां सूचीः अस्ति, अतः प्रथमतः समं संख्यां योजयतु, यानि विषमसंख्यासु सन्ति।    \/\/ >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))\n    \/\/ (2l)\n    def add(lst : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given a non-empty list of integers lst. add the even elements that are at odd indices.\n  def add(lst: List[Long]): Long = {\n    lst.zipWithIndex.collect {\n      case (value, index) if index % 2 == 1 && value % 2 == 0 => value\n    }.sum\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));\n    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));\n    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));\n    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_86","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/टिप्पणी: वाक्यस्य शब्दानां क्रमः रिक्तस्थानानि च भवन्तः अनुरक्तः भवन्तु ।    \/\/असि मूल्यम् आधारितः आरोहणीयक्रमः।    \/\/ननु शब्दस्य स्थाने सर्वकार्येषु वर्णानां क्रमनिर्देशः भवति ।    \/\/आदेशितसंस्करणं, एकं शब्दसंज्ञकं भवति यत्र सर्वे शब्दाः (अन्तरं विभक्तः)     \/\/कस्यचित् सूत्रस्य आदेशं प्रतिपादयितुं कस्यचित् फलनम् लिखत।    \/\/ >>> antiShuffle((\"Hi\"))\n    \/\/ (\"Hi\")\n    \/\/ >>> antiShuffle((\"hello\"))\n    \/\/ (\"ehllo\")\n    \/\/ >>> antiShuffle((\"Hello World!!!\"))\n    \/\/ (\"Hello !!!Wdlor\")\n    def antiShuffle(s : String) : String = {\n","canonical_solution":"import scala.collection.mutable.ArrayBuffer\n\nobject Problem {\n  def antiShuffle(s: String): String = {\n    val words = s.split(\"(?<=\\\\s)\")\n    val sortedWords = words.map(word => {\n      val trimmedWord = word.trim\n      val sortedChars = trimmedWord.sorted\n      word.replace(trimmedWord, sortedChars)\n    })\n    sortedWords.mkString(\"\")\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(antiShuffle(\"Hi\"))\n    println(antiShuffle(\"hello\"))\n    println(antiShuffle(\"Hello World!!!\"))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(antiShuffle((\"Hi\")).equals((\"Hi\")));\n    assert(antiShuffle((\"hello\")).equals((\"ehllo\")));\n    assert(antiShuffle((\"number\")).equals((\"bemnru\")));\n    assert(antiShuffle((\"abcd\")).equals((\"abcd\")));\n    assert(antiShuffle((\"Hello World!!!\")).equals((\"Hello !!!Wdlor\")));\n    assert(antiShuffle((\"\")).equals((\"\")));\n    assert(antiShuffle((\"Hi. My name is Mister Robot. How are you?\")).equals((\".Hi My aemn is Meirst .Rboot How aer ?ouy\")));\n    }\n\n}\n"},{"task_id":"HumanEval_87","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/अपि च, पङ्क्तिः स्तम्भः क्रमात् अवरोहणपूर्वकं क्रमयतु।    \/\/निर्देशादयो क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः क्रमशः    \/\/प्रत्येकं ट्युपलम् एकं निर्देशाङ्कम् अस्ति -- (पंक्ति, स्तम्भः) -- 0-संज्ञायाः आरम्भः।    \/\/एवं तुल्येषु [(x1, y1), (x2, y2) ...] इत्यनेन सूचीः प्रतिपादितः भवति यत्     \/\/lst, तथा पूर्णाङ्कः x, सूचीतः पूर्णाङ्कः x,  प्राप्नोतु।    \/\/प्रत्येकं पङ्क्तिः भिन्नसंख्याकानां स्तम्भानां संख्येयसम्बन्धेन युक्तः भवति ।    \/\/यः मैट्रिक्सः इत्यनेन समानः अस्ति, किन्तु मैट्रिक्सस्य विपरीतः अस्ति,    \/\/भवद्भिरुपादानं द्वि-आयामिकं डाटा, यथा नेस्टेड सूची,     \/\/ >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    \/\/ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    \/\/ >>> getRow((List[List[Long]]()), (1l))\n    \/\/ (List[Tuple2[Long, Long]]())\n    \/\/ >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n    \/\/ (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {\n    val coordinates = for {\n      (row, rowIndex) <- lst.zipWithIndex\n      (value, colIndex) <- row.zipWithIndex\n      if value == x\n    } yield (rowIndex.toLong, colIndex.toLong)\n\n    coordinates\n      .groupBy(_._1)\n      .toList\n      .sortBy(_._1)\n      .flatMap { case (rowIndex, coords) =>\n        coords.sortBy(-_._2)\n      }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));\n    }\n\n}\n"},{"task_id":"HumanEval_88","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/* न चान्येषां सूत्राणां परिवर्तनं कर्त्तव्यम्।    \/\/टिप्पणीः     \/\/अथवा यदि योगः ((प्रथमः सूचकाङ्कः, अन्तिमः सूचकाङ्कः) समः अस्ति तर्हि घटक्रमेण वर्गीकृतं कुरुत।    \/\/यदि योगः ((प्रथमं सूचकांकमूल्यं, अन्तिमं सूचकांकमूल्यं) विषममस्ति, तर्हि भवन्तः सूचीं आरोहणक्रमेण विसर्जयन्ति,     \/\/नन्-ऋणात्मकानां पूर्णाङ्काणां सूची प्राप्ते, क्रमणीकरणानन्तरं उक्तसूचीयाः कोस्केला प्रतिपादयतु,     \/\/ >>> sortArray((List[Long]()))\n    \/\/ (List[Long]())\n    \/\/ >>> sortArray((List[Long](5l.toLong)))\n    \/\/ (List[Long](5l.toLong))\n    \/\/ >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    \/\/ (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    \/\/ >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def sortArray(array: List[Long]): List[Long] = {\n    if (array.isEmpty) {\n      array\n    } else {\n      val first = array.head\n      val last = array.last\n      val sum = first + last\n      if (sum % 2 == 0) {\n        array.sorted(Ordering[Long].reverse)\n      } else {\n        array.sorted\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(sortArray(List[Long]())) \/\/ (List[Long]())\n    println(sortArray(List[Long](5L))) \/\/ (List[Long](5L))\n    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) \/\/ (List[Long](0L, 1L, 2L, 3L, 4L, 5L))\n    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) \/\/ (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_89","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/द्वयोः स्थानेषु द्विगुणं गुणितं द्विगुणं स्थानं प्रति निवर्त्यताम् ।    \/\/अक्षरं यथाक्रमं विभज्य लिखत ।    \/\/वर्णमालायाः परिक्रमणम् कृत्वा एकं सङ्केतं शृङ्खलं प्रतिपादयति ।    \/\/कस्यचित् कार्यस्य कूटशब्दस्य निर्माणं कुरुत यत् कस्यचित् सूत्रस्य तर्कस्य रूपे गृहीतं भवति, तथा च     \/\/ >>> encrypt((\"hi\"))\n    \/\/ (\"lm\")\n    \/\/ >>> encrypt((\"asdfghjkl\"))\n    \/\/ (\"ewhjklnop\")\n    \/\/ >>> encrypt((\"gf\"))\n    \/\/ (\"kj\")\n    \/\/ >>> encrypt((\"et\"))\n    \/\/ (\"ix\")\n    def encrypt(s : String) : String = {\n","canonical_solution":"def encrypt(s: String): String = {\n  s.map(c => {\n    val rotatedChar = (c - 'a' + 4) % 26 + 'a'\n    rotatedChar.toChar\n  })\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\")).equals((\"e\")));\n    }\n\n}\n"},{"task_id":"HumanEval_90","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि न अस्ति तर्हि None इत्यस्य प्रतिफलम् ददाति ।    \/\/Next_smallest () इति फलनम् लिखत, येन सूचीयाः द्वितीयं लघुतमं तत्वं लभते ।    \/\/भवद्भिरुपादानं पूर्णाङ्कं सूचीकृतम्।    \/\/ >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ Some(2l)\n    \/\/ >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))\n    \/\/ Some(2l)\n    \/\/ >>> nextSmallest((List[Long]()))\n    \/\/ None\n    \/\/ >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))\n    \/\/ None\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def nextSmallest(lst: List[Long]): Option[Long] = {\n    if (lst.size < 2) return None\n\n    val distinctSorted = lst.distinct.sorted\n    if (distinctSorted.size < 2) None\n    else Some(distinctSorted(1))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));\n    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));\n    assert(nextSmallest((List[Long]())).equals(None));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));\n    }\n\n}\n"},{"task_id":"HumanEval_91","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/वाक्यानां सीमां '', '?' अथवा '!'. इति विधीयते ।    \/\/\"अहं\" शब्दात् आरभते वाक्यात् \"अहं\" इति वाक्यम् भवति।    \/\/भवद्भ् यः शब्दानां शृङ्खला दीयते, भवतां कार्यम् अस्ति संख्या गन् तुम् ।    \/\/ >>> isBored((\"Hello world\"))\n    \/\/ (0l)\n    \/\/ >>> isBored((\"The sky is blue. The sun is shining. I love this weather\"))\n    \/\/ (1l)\n    def isBored(S : String) : Long = {\n","canonical_solution":"def isBored(S: String): Long = {\n    \/\/ Split the input string into sentences using '.', '?' or '!' as delimiters\n    val sentences = S.split(\"[.!?]\").map(_.trim)\n\n    \/\/ Filter sentences that start with 'I' and count them\n    sentences.count(sentence => sentence.startsWith(\"I\"))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isBored((\"Hello world\")) == (0l));\n    assert(isBored((\"Is the sky blue?\")) == (0l));\n    assert(isBored((\"I love It !\")) == (1l));\n    assert(isBored((\"bIt\")) == (0l));\n    assert(isBored((\"I feel good today. I will be productive. will kill It\")) == (2l));\n    assert(isBored((\"You and I are going for a walk\")) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_92","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/अन्यत्र असत्यं प्रतिपादयति।    \/\/यदि संख्यायाः एकं योगः अन्ययोः योगे भवति, एवं सर्वे संख्याः पूर्णाङ्काः भवन्ति तर्हि सत्यं प्रतिपादयति।    \/\/३-संख्यां गृह्णाति इति फलनम् निर्मातुम् ।    \/\/ >>> anyInt(5l, 2l, 7l)\n    \/\/ (true)\n    \/\/ >>> anyInt(3l, 2l, 2l)\n    \/\/ (false)\n    \/\/ >>> anyInt(3l, -2l, 1l)\n    \/\/ (true)\n    \/\/ >>> anyInt((3.6f), (-2.2f), 2l)\n    \/\/ (false)\n    def anyInt(x : Float, y : Float, z : Float) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Create a function that takes 3 numbers.\n  \/\/ Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  \/\/ Returns false in any other cases.\n  def anyInt(x: Float, y: Float, z: Float): Boolean = {\n    val xLong = x.toLong\n    val yLong = y.toLong\n    val zLong = z.toLong\n\n    \/\/ Check if all inputs are actually integers\n    if (xLong == x && yLong == y && zLong == z) {\n      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong\n    }\n    false\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(anyInt(2l, 3l, 1l) == (true));\n    assert(anyInt((2.5f), 2l, 3l) == (false));\n    assert(anyInt((1.5f), 5l, (3.5f)) == (false));\n    assert(anyInt(2l, 6l, 2l) == (false));\n    assert(anyInt(4l, 2l, 2l) == (true));\n    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));\n    assert(anyInt(-4l, 6l, 2l) == (true));\n    assert(anyInt(2l, 1l, 1l) == (true));\n    assert(anyInt(3l, 4l, 7l) == (true));\n    assert(anyInt((3.0f), 4l, 7l) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_93","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/केवलम् अक्षरं गृहीत्वा।    \/\/अङ्ग्रेजी वर्णमालायाः स्वरः।    \/\/सन्देशः यस्मिन् अक्षरः द्वौ स्थानौ आगच्छति ।    \/\/अतः सः सर्व-अक्षरानां अक्षर-परिवर्तनं करोति,  इत्यस्य सर्व-अक्षर-परिवर्तनं करोति ।    \/\/एकं फलनम् लिखत यत् संदेशं गृहीत्वा, तत् प्रकारेण एन्कोडं करोति।    \/\/ >>> encode((\"test\"))\n    \/\/ (\"TGST\")\n    \/\/ >>> encode((\"This is a message\"))\n    \/\/ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def encode(message: String): String = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    val vowelMap = Map(\n      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',\n      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'\n    )\n    \n    message.map { char =>\n      if (vowels.contains(char)) {\n        vowelMap(char)\n      } else if (char.isLetter) {\n        if (char.isLower) char.toUpper else char.toLower\n      } else {\n        char\n      }\n    }.mkString\n  }\n\n  \/\/ Test cases\n  def main(args: Array[String]): Unit = {\n    println(encode(\"test\"))            \/\/ should print \"TGST\"\n    println(encode(\"This is a message\")) \/\/ should print \"tHKS KS C MGSSCGG\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"},{"task_id":"HumanEval_94","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/भवद्भिः सर्वतः अधिकं मूल्यं ज्ञातव्यं, तस्य अङ्कं च पुनः प्राप्तव्यम् ।    \/\/भवद्भिरुपादानं पूर्णाङ्कं सूचीकृतम्।    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n    \/\/ (10l)\n    \/\/ >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n    \/\/ (25l)\n    \/\/ >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))\n    \/\/ (13l)\n    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (11l)\n    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))\n    \/\/ (7l)\n    def skjkasdkd(lst : List[Long]) : Long = {\n","canonical_solution":"def skjkasdkd(lst: List[Long]): Long = {\n  def isPrime(n: Long): Boolean = {\n    if (n <= 1) false\n    else if (n == 2) true\n    else if (n % 2 == 0) false\n    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)\n  }\n\n  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum\n\n  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)\n  sumOfDigits(largestPrime)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));\n    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));\n    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));\n    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));\n    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));\n    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));\n    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));\n    }\n\n}\n"},{"task_id":"HumanEval_95","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि दीयते, तदा फलनम् असत्यं प्रति लप्स्यते, यदि दीयते, तदा न भवति।    \/\/यदि वा सर्वे कुञ्जाः अपरकेसमध्ये स्त्रिः भवन्ति, अन्यथा मिथ्या प्रतिपादयति.    \/\/यदि सर्वेषां कुञ्जाः निम्नस्थानेषु श्लोकाः सन्ति तर्हि सत्यं प्रतिपादयतु।    \/\/ >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    \/\/ (true)\n    \/\/ >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    \/\/ (false)\n    \/\/ >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    \/\/ (false)\n    \/\/ >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    \/\/ (false)\n    \/\/ >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    \/\/ (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def checkDictCase(dict: Map[String, String]): Boolean = {\n    if (dict.isEmpty) return false\n\n    val keys = dict.keys.toList\n    val allLowerCase = keys.forall(key => key == key.toLowerCase)\n    val allUpperCase = keys.forall(key => key == key.toUpperCase)\n\n    allLowerCase || allUpperCase\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_96","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/पूर्णाङ्काः ये प्रथमाङ्काः सन्ति, ते n-तः अल्पकाः सन्ति।    \/\/नन्-ऋणात्मकं पूर्णाङ्कं गृहीत्वा प्रथमं n-वर्णानां सूचीं प्रतिपादयति।    \/\/ >>> countUpTo((5l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong))\n    \/\/ >>> countUpTo((11l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    \/\/ >>> countUpTo((0l))\n    \/\/ (List[Long]())\n    \/\/ >>> countUpTo((20l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    \/\/ >>> countUpTo((1l))\n    \/\/ (List[Long]())\n    \/\/ >>> countUpTo((18l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n","canonical_solution":"def countUpTo(n: Long): List[Long] = {\n    def isPrime(num: Long): Boolean = {\n      if (num < 2) return false\n      for (i <- 2L to math.sqrt(num).toLong) {\n        if (num % i == 0) return false\n      }\n      true\n    }\n\n    (2L until n).filter(isPrime).map(_.toLong).toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_97","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/आगतं सर्वदा वैधं भवति इति गृहीतम् ।    \/\/तेषां एकाधिकसंख्यायाः गुणः भवति ।    \/\/द्वौ पूर्णाङ्कं गृहीत्वा फलनम् पूरयतु, ततः परतः     \/\/ >>> multiply((148l), (412l))\n    \/\/ (16l)\n    \/\/ >>> multiply((19l), (28l))\n    \/\/ (72l)\n    \/\/ >>> multiply((2020l), (1851l))\n    \/\/ (0l)\n    \/\/ >>> multiply((14l), (-15l))\n    \/\/ (20l)\n    def multiply(a : Long, b : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def multiply(a: Long, b: Long): Long = {\n        val unitDigitA = abs(a % 10)\n        val unitDigitB = abs(b % 10)\n        unitDigitA * unitDigitB\n    }\n\n    def main(args: Array[String]): Unit = {\n        println(multiply(148l, 412l))  \/\/ 16l\n        println(multiply(19l, 28l))    \/\/ 72l\n        println(multiply(2020l, 1851l)) \/\/ 0l\n        println(multiply(14l, -15l))   \/\/ 20l\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_98","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/यदि क्तः अस्ति, तर्हि समसूत्रेषु क्तस्य स्वरस्य संख्यां गणयतु।    \/\/ >>> countUpper((\"aBCdEf\"))\n    \/\/ (1l)\n    \/\/ >>> countUpper((\"abcdefg\"))\n    \/\/ (0l)\n    \/\/ >>> countUpper((\"dBBE\"))\n    \/\/ (0l)\n    def countUpper(s : String) : Long = {\n","canonical_solution":"def countUpper(s: String): Long = {\n  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')\n  s.zipWithIndex.collect {\n    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch\n  }.size.toLong\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countUpper((\"aBCdEf\")) == (1l));\n    assert(countUpper((\"abcdefg\")) == (0l));\n    assert(countUpper((\"dBBE\")) == (0l));\n    assert(countUpper((\"B\")) == (0l));\n    assert(countUpper((\"U\")) == (1l));\n    assert(countUpper((\"\")) == (0l));\n    assert(countUpper((\"EEEE\")) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_99","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/द्वयोः पूर्णाङ्कं शून्यात् दूरं कृत्वा परिमण्डलं कुरुत।    \/\/यदि संख्या समदूरस्थः अस्ति, तर्हि सः समीपस्थः पूर्णाङ्कः भवति।    \/\/संख्यायाः प्रतिनिधित्वं करणीयं (स्ट्रिंग) मानं गृह्णाति इति फलनम् निर्मितव्यम् ।    \/\/ >>> closestInteger((\"10\"))\n    \/\/ (10l)\n    \/\/ >>> closestInteger((\"15.3\"))\n    \/\/ (15l)\n    \/\/ Note:\n    \/\/ Rounding away from zero means that if the given number is equidistant\n    \/\/ from two integers, the one you should return is the one that is the\n    \/\/ farthest from zero. For example closest_integer(\"14.5\") should\n    \/\/ return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def closestInteger(value: String): Long = {\n    val num = value.toDouble\n    val lower = floor(num).toLong\n    val upper = ceil(num).toLong\n    \n    if (abs(num - lower) == abs(num - upper)) {\n      if (num > 0) upper else lower\n    } else {\n      round(num)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(closestInteger(\"10\"))  \/\/ 10\n    println(closestInteger(\"15.3\")) \/\/ 15\n    println(closestInteger(\"14.5\")) \/\/ 15\n    println(closestInteger(\"-14.5\")) \/\/ -15\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_100","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/i इति स्तरेषु (i+1) स्थानेषु शिलाः सन्ति ।    \/\/सूचीमध्ये प्रत्येकस्तरेषु शिलाः संख्यां प्रतिपादयति, यत्र तत्वम् index इत्यत्र भवति ।    \/\/- यदि n अपि अस्ति तर्हि अग्रे समः संख्या अस्ति।    \/\/- यदि n अस्वाभाविकः अस्ति तर्हि अग्रे असमङ्ख्यम् अस्ति ।    \/\/अग्रे स्तरस्य शिलायाः संख्या अस्ति:    \/\/प्रथमस्तरे n पाषाणाः सन्ति ।    \/\/यदि धनात्मकं पूर्णाङ्कं n प्राप्नुयात् तर्हि n स्तरीयानां पाषाणानां समूहं निर्मातव्यम् ।    \/\/ >>> makeAPile((3l))\n    \/\/ (List[Long](3l.toLong, 5l.toLong, 7l.toLong))\n    def makeAPile(n : Long) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable.ListBuffer\n\nobject Problem {\n    def makeAPile(n: Long): List[Long] = {\n        val pile = ListBuffer[Long]()\n        var currentStones = n\n        for (_ <- 0 until n.toInt) {\n            pile += currentStones\n            currentStones += (if (currentStones % 2 == 0) 2 else 2)\n        }\n        pile.toList\n    }\n\n    def main(args: Array[String]): Unit = {\n        val result = makeAPile(3L)\n        println(result)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_101","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/शब्दानां विभक्तिः कृत्वा शब्दानां सूचीं प्रति लभते    \/\/भवता कम्पायाः वा रिक्तस्थानानां द्वारा पृथक्कृतानि शब्दाः प्रदत्ताः सन्ति। भवता कार्यम् अस्ति     \/\/ >>> wordsString((\"Hi, my name is John\"))\n    \/\/ (List[String](\"Hi\", \"my\", \"name\", \"is\", \"John\"))\n    \/\/ >>> wordsString((\"One, two, three, four, five, six\"))\n    \/\/ (List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))\n    def wordsString(s : String) : List[String] = {\n","canonical_solution":"def wordsString(s: String): List[String] = {\n    s.split(\"[, ]+\").toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(wordsString((\"Hi, my name is John\")).equals((List[String](\"Hi\", \"my\", \"name\", \"is\", \"John\"))));\n    assert(wordsString((\"One, two, three, four, five, six\")).equals((List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))));\n    assert(wordsString((\"Hi, my name\")).equals((List[String](\"Hi\", \"my\", \"name\"))));\n    assert(wordsString((\"One,, two, three, four, five, six,\")).equals((List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))));\n    assert(wordsString((\"\")).equals((List[String]())));\n    assert(wordsString((\"ahmed     , gamal\")).equals((List[String](\"ahmed\", \"gamal\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_102","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/न हि संख्या अस्ति, अतः फलनम् -1 इत्युत्पादयति।    \/\/यदि                     \/\/इदम् फलनम् द्वयोः धनात्मकानां संख्याः x तथा y गृहीत्वा  इत्यस्य परिणामं ददाति ।    \/\/ >>> chooseNum((12l), (15l))\n    \/\/ (14l)\n    \/\/ >>> chooseNum((13l), (12l))\n    \/\/ (-1l)\n    def chooseNum(x : Long, y : Long) : Long = {\n","canonical_solution":"def chooseNum(x: Long, y: Long): Long = {\n    \/\/ Ensure x is the lesser value and y is the greater value\n    val (start, end) = if (x > y) (y, x) else (x, y)\n    \n    \/\/ Start from the end of the range and search backwards for an even number\n    for (i <- end to start by -1 if i % 2 == 0) {\n      return i\n    }\n    \n    \/\/ If no even number is found, return -1\n    -1\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(chooseNum((12l), (15l)) == (14l));\n    assert(chooseNum((13l), (12l)) == (-1l));\n    assert(chooseNum((33l), (12354l)) == (12354l));\n    assert(chooseNum((5234l), (5233l)) == (-1l));\n    assert(chooseNum((6l), (29l)) == (28l));\n    assert(chooseNum((27l), (10l)) == (-1l));\n    assert(chooseNum((7l), (7l)) == (-1l));\n    assert(chooseNum((546l), (546l)) == (546l));\n    }\n\n}\n"},{"task_id":"HumanEval_103","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि n-मध्यं भवति तर्हि -1 इत्यस्य परावर्तनं क्रियते।    \/\/उत्तरं समीपस्थं पूर्णाङ्कं कृत्वा द्विवचनं रूपान्तरितम्।    \/\/n-मध्यं पूर्णाङ्कं (n-m सहितम्)     \/\/भवद्भिरपि द्विविधं धनात्मकं पूर्णाङ्कं n तथा m प्राप्नोति, एवं भवद्भिरपि कार्यम् अस्ति यत्     \/\/ >>> roundedAvg((1l), (5l))\n    \/\/ \"0b11\"\n    \/\/ >>> roundedAvg((7l), (5l))\n    \/\/ -1l\n    \/\/ >>> roundedAvg((10l), (20l))\n    \/\/ \"0b1111\"\n    \/\/ >>> roundedAvg((20l), (33l))\n    \/\/ \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n  \/\/ Function to compute the average of the integers from n through m\n  def roundedAvg(n: Long, m: Long): Either[String, Long] = {\n    if (n > m) {\n      Right(-1L)\n    } else {\n      val count = m - n + 1\n      val sum = (n + m) * count \/ 2\n      val average = round(sum.toDouble \/ count)\n      Left(\"0b\" + average.toLong.toBinaryString)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(roundedAvg(1L, 5L))    \/\/ Left(\"0b11\")\n    println(roundedAvg(7L, 5L))    \/\/ Right(-1L)\n    println(roundedAvg(10L, 20L))  \/\/ Left(\"0b1111\")\n    println(roundedAvg(20L, 33L))  \/\/ Left(\"0b11010\")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n"},{"task_id":"HumanEval_104","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/नोटः पुनः प्राप्ताः सूचीः क्रमशः वर्धमानतया विसर्जितं भवेत् ।    \/\/न च इदम्+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि    \/\/धनात्मकपूर्णाङ्काणां सूची प्राप्ते, सर्वेषां  इत्यस्य सूची पुनः प्राप्ता।    \/\/ >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))\n    \/\/ (List[Long](1l.toLong, 15l.toLong, 33l.toLong))\n    \/\/ >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))\n    \/\/ (List[Long]())\n    def uniqueDigits(x : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def uniqueDigits(x: List[Long]): List[Long] = {\n    def hasEvenDigit(n: Long): Boolean = {\n      n.toString.exists(c => (c - '0') % 2 == 0)\n    }\n\n    x.filterNot(hasEvenDigit).sorted\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))\n    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));\n    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));\n    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));\n    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_105","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/\"एकः\", \"द्वयोः\", \"तृतीयः\", \"चत्वारः\", \"पञ्चः\", \"षट्\", \"सप्त\", \"आठः\", \"नवम्\" ।    \/\/ननु च, प्रत्ययस्य स्थाने प्रत्ययस्य नामकरणं क्रियते ।    \/\/पूर्णाङ्काणां सूची प्राप्ते, 1 तः 9 पर्यन्ताः पूर्णाङ्काः क्रमणीकृत्य,     \/\/ >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    \/\/ If the list is empty, return an empty list:\n    \/\/ >>> byLength((List[Long]()))\n    \/\/ (List[String]())\n    \/\/ If the list has any strange number ignore it:\n    \/\/ >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    \/\/ (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def byLength(arr: List[Long]): List[String] = {\n    \/\/ Map of digit to its corresponding name\n    val numToName = Map(\n      1L -> \"One\",\n      2L -> \"Two\",\n      3L -> \"Three\",\n      4L -> \"Four\",\n      5L -> \"Five\",\n      6L -> \"Six\",\n      7L -> \"Seven\",\n      8L -> \"Eight\",\n      9L -> \"Nine\"\n    )\n\n    \/\/ Filter numbers between 1 and 9\n    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)\n    \/\/ Map filtered and sorted numbers to their corresponding names\n    filteredAndSorted.map(numToName)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_106","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/i इत्यस्य गुणनफलम् 1 तः i इत्यपर्यन्तस्य संख्यायाः गुणनफलम् अस्ति (1 * 2 * ... * i) ।    \/\/i 1 इत्यतः आरभ्यते।    \/\/अथवा अन्यत्र १-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-१-२-२-२    \/\/तथा आकाराः n इत्यनेन सूचीं प्रतिपादयति, येन इन्द्रेषु i इत्यस्य गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम् गुणानाम्    \/\/f इत्यस्य फलनम् क्रियताम्, यत् n इत्यस्य परिमेयत्वेन गृह्यते,     \/\/ >>> f((5l))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))\n    def f(n : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def f(n: Long): List[Long] = {\n        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)\n        \n        (1L to n).map { i =>\n            if (i % 2 == 0) factorial(i) else (1L to i).sum\n        }.toList\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));\n    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));\n    assert(f((1l)).equals((List[Long](1l.toLong))));\n    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_107","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् १:     \/\/पूर्णाङ्कः पालिन्द्रोमः यः अन्तः अन्तः अस्ति ।    \/\/यदि धनात्मकं पूर्णाङ्कं n प्राप्नुयात् तर्हि, समं च विषमम् च  इति ट्यूप्लं प्रतिपाद्यताम् ।    \/\/ >>> evenOddPalindrome((3l))\n    \/\/ ((1l, 2l))\n    \/\/ Explanation:\n    \/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n    \/\/ Example 2:\n    \/\/ >>> evenOddPalindrome((12l))\n    \/\/ ((4l, 6l))\n    \/\/ Explanation:\n    \/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n    \/\/ Note:\n    \/\/ 1. 1 <= n <= 10^3\n    \/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\n    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n","canonical_solution":"def evenOddPalindrome(n: Long): (Long, Long) = {\n  def isPalindrome(x: Long): Boolean = {\n    val str = x.toString\n    str == str.reverse\n  }\n\n  var evenCount: Long = 0\n  var oddCount: Long = 0\n\n  for (i <- 1L to n) {\n    if (isPalindrome(i)) {\n      if (i % 2 == 0) evenCount += 1\n      else oddCount += 1\n    }\n  }\n\n  (evenCount, oddCount)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"},{"task_id":"HumanEval_108","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -123 इत्यस्य अङ्के -1, 2, 3 इत्यनेन हस्ताक्षरं भवति ।    \/\/यदि संख्या ऋणात्मकं भवति, तदा तस्य प्रथमं हस्ताक्षरित-अङ्कः ऋणात्मकः भवति:    \/\/अङ्केषु संख्यायाः योगः > 0 भवति।    \/\/count_nums इति फलनम् लिखत, यः पूर्णाङ्काणां सूची गृहीत्वा पुनः लभते।    \/\/ >>> countNums((List[Long]()))\n    \/\/ (0l)\n    \/\/ >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    \/\/ (3l)\n    def countNums(arr : List[Long]) : Long = {\n","canonical_solution":"def countNums(arr: List[Long]): Long = {\n  arr.count(num => {\n    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>\n      if (char == '-') acc else acc + (char - '0')\n    }\n    sumOfDigits > 0\n  }).toLong\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_109","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/नोटः अत्र दीयते सूची विशिष्टाः अवयवाः सन्ति इति निश्चितम्।    \/\/यदि दीयते सूची रिक्तं भवति तर्हि true इत्यस्य प्रतिगमनं कुरुत।    \/\/तर्हि true प्रतिपादयतु अन्यथा false प्रतिपादयतु।    \/\/यदि पूर्वोक्तक्रियायाः कृते क्रमबद्धसूची प्राप्तुं शक्यते तर्हि    \/\/सूचीस्थाने प्रारम्भस्थानं, अर्थात् शून्यम् सूचकं।    \/\/अधोलिखितेषु पृष्ठेषु अन्तिमः आद्युत्पदं  इत्यनेन परिवर्तयिष्यते ।    \/\/एकं दाशमपसारणं क्रियते, यानि सूचीषु विद्यमानानि सर्वाणि तत्वानि एकेन पसारयन्ति ।    \/\/भवता दाशमनुवर्तनं कर्तुं अनुमतिः अस्ति।    \/\/अधोलिखितानि क्रियायाः सूचीः    \/\/यदि इदम् कार्यम् क्रियते तर्हि सूचीः अव्ययीभावः न भवति ।    \/\/सूचीषु संख्याः यादृच्छिकरूपेण विहितानि भवन्ति। भवतां कार्यम् अस्ति यत् भवतां नामः    \/\/अस्मिन् सूची 'अर्' इत्यस्मिन् N पूर्णाङ्काः सन्ति, यानि सन्ति arr[1], arr[2], ..., arr[N]।    \/\/ >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    \/\/ (true)\n    \/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n    \/\/ be achieved for the given list.\n    \/\/ >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))\n    \/\/ (false)\n    \/\/ Explanation:It is not possible to get non-decreasing order for the given\n    \/\/ list by performing any number of right shift operations.\n    def moveOneBall(arr : List[Long]) : Boolean = {\n","canonical_solution":"def moveOneBall(arr: List[Long]): Boolean = {\n  if (arr.isEmpty) return true\n\n  \/\/ Find how many times the array needs to be shifted to become sorted\n  val n = arr.length\n  var shiftIndex = -1\n\n  for (i <- 0 until n) {\n    if (arr(i) > arr((i + 1) % n)) {\n      \/\/ More than one place where the order breaks means it can't be sorted with a shift\n      if (shiftIndex != -1) return false\n      shiftIndex = i + 1\n    }\n  }\n\n  \/\/ If no break in order was found, the array is already sorted\n  if (shiftIndex == -1) return true\n\n  \/\/ Check if shifting by the found index sorts the array\n  for (i <- 1 until n) {\n    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false\n  }\n  \n  true\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]())) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_110","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/अन्यथा \"न\" इति प्रतिपादयतु।    \/\/lst1 इत्यस्य सर्वम् अवयवम् समं भवेत्, अतः \"YES\" प्रत्ययः प्राप्नोति ।    \/\/यदि इदम् सम्भवति तर्हि इष्ट-१-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-३-इष्ट-४-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२-इष्ट-२    \/\/अत्र lst1 तथा lst2 इत्ययोः मध्ये विनिमयस्य अवयवानां सङ्ख्यायाः कोऽपि सीमा नास्ति ।    \/\/अतः इष्टतमः सङ्ख्याः केवलम् समसंख्याभिः युक्तः भवति ।    \/\/एवं च निर्धारयति यत् तत्वानां विनिमयम् सम्भवति वा न ।    \/\/अस्मिन् समस्यायां, भवन्तः एकं फलनं प्रवर्तयन्ति यत् द्वयोः संख्यासूत्राणि गृहीत्वा,    \/\/ >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (\"YES\")\n    \/\/ >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (\"NO\")\n    \/\/ It is assumed that the input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def exchange(lst1: List[Long], lst2: List[Long]): String = {\n    \/\/ Check if all elements in lst1 are already even\n    if (lst1.forall(_ % 2 == 0)) return \"YES\"\n\n    \/\/ Find if there's any even number in lst2 to exchange with lst1\n    val lst2EvensExist = lst2.exists(_ % 2 == 0)\n\n    \/\/ Check if there's also at least one odd in lst1 to swap it out\n    val lst1OddsExist = lst1.exists(_ % 2 != 0)\n\n    \/\/ Only possible if both an even element in lst2 and an odd element in lst1 exist\n    if (lst2EvensExist && lst1OddsExist) \"YES\" else \"NO\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"},{"task_id":"HumanEval_111","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि अनेकेषु अक्षरषु समानं भवति, तदा सर्वेषु एव प्रत्ययान् लिखत।    \/\/अतः अस्य अक्षरस्य संख्याः अधिकतरं भवति।    \/\/यदि कस्यचित् अक्षरस्य स्थाने लघुवर्णं भवति, तर्हि तस्य प्रतिपाद्यमानः मानचित्रः भवति ।    \/\/ >>> histogram((\"a b c\"))\n    \/\/ (Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l))\n    \/\/ >>> histogram((\"a b b a\"))\n    \/\/ (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    \/\/ >>> histogram((\"a b c a b\"))\n    \/\/ (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    \/\/ >>> histogram((\"b b b b a\"))\n    \/\/ (Map[String,Long](\"b\" -> 4l))\n    \/\/ >>> histogram((\"\"))\n    \/\/ (Map[String,Long]())\n    def histogram(test : String) : Map[String,Long] = {\n","canonical_solution":"def histogram(test: String): Map[String, Long] = {\n        val words = test.split(\" \")\n        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)\n\n        if (frequencyMap.isEmpty) return Map.empty[String, Long]\n\n        val maxCount = frequencyMap.values.max\n        frequencyMap.filter { case (_, count) => count == maxCount }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(histogram((\"a b b a\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"a b c a b\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"a b c d g\")).equals((Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l, \"d\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"b b b b a\")).equals((Map[String,Long](\"b\" -> 4l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"\")).equals((Map[String,Long]())));\n    assert(histogram((\"a\")).equals((Map[String,Long](\"a\" -> 1l))));\n    }\n\n}\n"},{"task_id":"HumanEval_112","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/भवता तु प्रत्ययान्तः प्राप्तः, सत्याः\/असत्यः च अस्ति ।    \/\/यदि पूर्ववत् पूर्ववत् च समानं पाठं भवति तर्हि तत् पालिन्द्रोम् इति कथ्यते ।    \/\/तदा जाँचं कुरुत यदि फलं स्ट्रिंग् प्रत्ययान्तरमस्ति।    \/\/अस्मिन् सूत्रे द्वौ वर्णसूत्रेषु s, c, भवन्तः s इत्यस्मिन् वर्णस्य समानाः सर्वे वर्णः विलोप्स्यन्ते, ये c इत्यस्मिन् वर्णस्य समानाः सन्ति ।    \/\/कार्यम्     \/\/ >>> reverseDelete((\"abcde\"), (\"ae\"))\n    \/\/ ((\"bcd\", false))\n    \/\/ >>> reverseDelete((\"abcdef\"), (\"b\"))\n    \/\/ ((\"acdef\", false))\n    \/\/ >>> reverseDelete((\"abcdedcba\"), (\"ab\"))\n    \/\/ ((\"cdedc\", true))\n    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {\n","canonical_solution":"def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {\n    \/\/ Convert the characters to be deleted into a set for quick lookup\n    val deleteSet = c.toSet\n    \n    \/\/ Filter out characters from s that are present in deleteSet\n    val filteredString = s.filterNot(deleteSet.contains)\n    \n    \/\/ Check if the filtered string is a palindrome\n    val isPalindrome = filteredString == filteredString.reverse\n    \n    \/\/ Return the tuple with the filtered string and the palindrome check result\n    (filteredString, isPalindrome)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(reverseDelete((\"abcde\"), (\"ae\")).equals(((\"bcd\", false))));\n    assert(reverseDelete((\"abcdef\"), (\"b\")).equals(((\"acdef\", false))));\n    assert(reverseDelete((\"abcdedcba\"), (\"ab\")).equals(((\"cdedc\", true))));\n    assert(reverseDelete((\"dwik\"), (\"w\")).equals(((\"dik\", false))));\n    assert(reverseDelete((\"a\"), (\"a\")).equals(((\"\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"\")).equals(((\"abcdedcba\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"v\")).equals(((\"abcdedcba\", true))));\n    assert(reverseDelete((\"vabba\"), (\"v\")).equals(((\"abba\", true))));\n    assert(reverseDelete((\"mamma\"), (\"mia\")).equals(((\"\", true))));\n    }\n\n}\n"},{"task_id":"HumanEval_113","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च इत्थं च    \/\/\" इत्यत्र 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' इत्यस्य स्थाने 'i' भवति ।    \/\/प्रत्येकं तत्वं I आउटपुटस्य \"अनौपचारिकानां तत्वानां संख्या\" भवेत् ।    \/\/यदि कस्यचित् सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः    \/\/ >>> oddCount((List[String](\"1234567\")))\n    \/\/ (List[String](\"the number of odd elements 4n the str4ng 4 of the 4nput.\"))\n    \/\/ >>> oddCount((List[String](\"3\", \"11111111\")))\n    \/\/ (List[String](\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"))\n    def oddCount(lst : List[String]) : List[String] = {\n","canonical_solution":"def oddCount(lst: List[String]): List[String] = {\n    lst.map { str =>\n      val oddCount = str.count(c => c.asDigit % 2 != 0)\n      val replacedString = s\"the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.\"\n      replacedString\n    }\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(oddCount(List(\"1234567\")))  \/\/ List(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")\n    println(oddCount(List(\"3\", \"11111111\")))  \/\/ List(\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(oddCount((List[String](\"1234567\"))).equals((List[String](\"the number of odd elements 4n the str4ng 4 of the 4nput.\"))));\n    assert(oddCount((List[String](\"3\", \"11111111\"))).equals((List[String](\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"))));\n    assert(oddCount((List[String](\"271\", \"137\", \"314\"))).equals((List[String](\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_114","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/नमः ।    \/\/पूर्णाङ्काणां सूची प्राप्ते, कस्यचित् न-खाली उप-सूचीयाः न्यूनतमं योगं ज्ञातव्यम् ।    \/\/ >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))\n    \/\/ (-6l)\n    def minSubArraySum(nums : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def minSubArraySum(nums: List[Long]): Long = {\n    var minEndingHere = nums.head\n    var minSoFar = nums.head\n    \n    for (i <- 1 until nums.length) {\n      minEndingHere = min(nums(i), minEndingHere + nums(i))\n      minSoFar = min(minSoFar, minEndingHere)\n    }\n    \n    minSoFar\n  }\n\n  \/\/ Test Cases\n  def main(args: Array[String]): Unit = {\n    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) \/\/ Output: 1\n    println(minSubArraySum(List(-1l, -2l, -3l))) \/\/ Output: -6\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n    }\n\n}\n"},{"task_id":"HumanEval_115","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् १:     \/\/भवद्भिः कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन।    \/\/भवतां कार्यम् अस्ति यत् कुण्डं रिक्तं कर्तुम् बाल्टिनां उपयोगं करणीयम् ।    \/\/तथा च सर्व्वस्य बाल्टिः समानं क्षमता अस्ति ।    \/\/प्रत्येकं कुण्डं एकं बक्कं धारयति यस्मात् जलम् उत्कर्षयितुं शक्यते ।    \/\/प्रत्येकं 1 इति पङ्क्तिः एकं जल-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक-एक    \/\/भवद्भिः कुण्डानां चतुर्भुजः ग्रिडः प्रदत्तः। प्रत्येकं पंक्तिः एकं कुण्डं प्रतिपादयति,     \/\/ >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n    \/\/ (6l)\n    \/\/ Example 2:\n    \/\/ >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    \/\/ (5l)\n    \/\/ Example 3:\n    \/\/ >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    \/\/ (0l)\n    \/\/ Constraints:\n    \/\/ * all wells have the same length\n    \/\/ * 1 <= grid.length <= 10^2\n    \/\/ * 1 <= grid[:,1].length <= 10^2\n    \/\/ * grid[i][j] -> 0 | 1\n    \/\/ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {\n","canonical_solution":"def maxFill(grid: List[List[Long]], capacity: Long): Long = {\n  var totalWaterUnits = 0L\n\n  for (row <- grid) {\n    totalWaterUnits += row.sum\n  }\n\n  \/\/ Calculate the number of times you need to lower the buckets\n  val bucketOperations = totalWaterUnits \/ capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)\n\n  bucketOperations\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_116","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अस्य कार्यान्वयनं यथा-    \/\/समानसंख्याकानां संख्यायां दशमलवमूल्यस्य आधारतः वर्गीकरणं क्रियते ।    \/\/द्विवचनप्रतीकारे एकानां संख्याः वर्धमानक्रमेण भवति ।    \/\/अस्मिन् कटा-अध्याये, भवता णकारे न सन्निहितानां पूर्णाङ्काणां सूचीं क्रमणीकर्तुम् अपेक्षते।    \/\/ >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    \/\/ >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    \/\/ (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    \/\/ >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long]) : List[Long] = {\n","canonical_solution":"def sortArray(arr: List[Long]): List[Long] = {\n        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_117","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/नोटः भवता अनुमानः कर्तुं शक्यते यत् आगतसूत्रे केवलं अक्षरं रिक्तस्थानं च अस्ति ।    \/\/यदि string s रिक्तः अस्ति तर्हि फलनम् रिक्तसूचीम् प्रतिपादयति ।    \/\/n व्यञ्जनानि, येन एते शब्दाः s-प्रत्ययेषु विद्यन्ते ।    \/\/एकं फलनम् अस्ति यत् सर्वशब्दाः सूचीं प्रति लभते, यस्मिन् अक्षरशृङ्गाः सन्ति, यस्मिन्  इत्यनेन पाठः अस्ति ।    \/\/यदि क्तः अस्ति, तदा तस्य संख्याः n भवति।    \/\/ >>> selectWords((\"Mary had a little lamb\"), (4l))\n    \/\/ (List[String](\"little\"))\n    \/\/ >>> selectWords((\"Mary had a little lamb\"), (3l))\n    \/\/ (List[String](\"Mary\", \"lamb\"))\n    \/\/ >>> selectWords((\"simple white space\"), (2l))\n    \/\/ (List[String]())\n    \/\/ >>> selectWords((\"Hello world\"), (4l))\n    \/\/ (List[String](\"world\"))\n    \/\/ >>> selectWords((\"Uncle sam\"), (3l))\n    \/\/ (List[String](\"Uncle\"))\n    def selectWords(s : String, n : Long) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def selectWords(s: String, n: Long): List[String] = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    def consonantCount(word: String): Int = {\n      word.count(c => c.isLetter && !vowels.contains(c))\n    }\n\n    if (s.isEmpty) {\n      List()\n    } else {\n      s.split(\"\\\\s+\").filter(word => consonantCount(word) == n).toList\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(selectWords((\"Mary had a little lamb\"), (4l)).equals((List[String](\"little\"))));\n    assert(selectWords((\"Mary had a little lamb\"), (3l)).equals((List[String](\"Mary\", \"lamb\"))));\n    assert(selectWords((\"simple white space\"), (2l)).equals((List[String]())));\n    assert(selectWords((\"Hello world\"), (4l)).equals((List[String](\"world\"))));\n    assert(selectWords((\"Uncle sam\"), (3l)).equals((List[String](\"Uncle\"))));\n    assert(selectWords((\"\"), (4l)).equals((List[String]())));\n    assert(selectWords((\"a b c d e f\"), (1l)).equals((List[String](\"b\", \"c\", \"d\", \"f\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_118","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/अत्र केवलम् आङ्ग्लभाषायाः अक्षरं विद्यते इति भवन्तः अनुमानं करिष्यन्ति ।    \/\/उपरि स्थितौ कस्यचित् स्वरस्य मिलनं प्राप्नोति।    \/\/यदि न अस्ति तर्हि रिक्तः स्ट्रन्गः प्रतिपादयतु।    \/\/शब्दस्य दक्षिणपार्श्वे द्वौ व्यञ्जनौ (case sensitive) ।    \/\/भवद्भ् यः एकं शब्दं दत्ताः अस्ति। भवद् भ् यः कार्यम् अस्ति यत्, निकटतमं स्वरं, यस् य मध्यम् अस्ति, प्राप् नुत।    \/\/ >>> getClosestVowel((\"yogurt\"))\n    \/\/ (\"u\")\n    \/\/ >>> getClosestVowel((\"FULL\"))\n    \/\/ (\"U\")\n    \/\/ >>> getClosestVowel((\"quick\"))\n    \/\/ (\"\")\n    \/\/ >>> getClosestVowel((\"ab\"))\n    \/\/ (\"\")\n    def getClosestVowel(word : String) : String = {\n","canonical_solution":"def getClosestVowel(word: String): String = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    for (i <- word.length - 2 until 0 by -1) {\n      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {\n        return word(i + 1).toString\n      }\n    }\n    \n    \"\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"},{"task_id":"HumanEval_119","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि भवान् कस्यचित् प्रकारस्य अच्-प्रत्ययस्य निर्माणं कर्तुं शक्नोति तर्हि 'Yes' इति प्रतिपादयतु, अन्यथा 'No' इति प्रतिपादयतु।    \/\/\" (()) \" इति न भवति ।    \/\/उदाहरणार्थः '(((() ' इति सूत्रं उत्तमं भवति, जबकि  इति सूत्रं उत्तमम् भवति ।    \/\/यदि च केवलं यदि च S इत्यस्य सर्व्वपरिच्छेदेषु S  इति सूत्रं भवति तर्हि सः string S इत्यस्य गुणः भवति ।    \/\/ननु च, यदि कस्यचित् आदेशः भवति, तदा परिणामादिसङ्ख्या उत्तमा भवति ।    \/\/भवद्भिः कार्यम् अस्ति यत् भवद्भिः द्वयोः तारयोः सम्बद्धं कर्तुम् शक्यते ।    \/\/केवलम् \" (--) \" अथवा \" (--) \" इति कोष्ठकात् ।    \/\/भवद्भिरपि द्वयोः सूत्रयोः सूची दीयते, द्वयोः सूत्रयोः मध्ये उघारः अस्ति ।    \/\/ >>> matchParens((List[String](\"()(\", \")\")))\n    \/\/ (\"Yes\")\n    \/\/ >>> matchParens((List[String](\")\", \")\")))\n    \/\/ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n","canonical_solution":"def matchParens(lst: List[String]): String = {\n    def isBalanced(s: String): Boolean = {\n      var balance = 0\n      for (char <- s) {\n        if (char == '(') balance += 1\n        else if (char == ')') balance -= 1\n        if (balance < 0) return false\n      }\n      balance == 0\n    }\n    \n    val combinations = List(\n      lst(0) + lst(1),\n      lst(1) + lst(0)\n    )\n    \n    if (combinations.exists(isBalanced)) \"Yes\" else \"No\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n"},{"task_id":"HumanEval_120","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् १:     \/\/दीर्घत्वे k इत्यनेन अधिकतमः k सङ्ख्याः आर्कः भवति ।    \/\/पूर्णाङ्काणां सूची आरः, धनात्मकं पूर्णाङ्कं केः च दत्त्वा, क्रमबद्धसूचीं प्रति लभेत ।    \/\/ >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    \/\/ (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    \/\/ Example 2:\n    \/\/ >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    \/\/ (List[Long](4l.toLong, 4l.toLong))\n    \/\/ Example 3:\n    \/\/ >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    \/\/ (List[Long](2l.toLong))\n    \/\/ Note:\n    \/\/ 1. The length of the list will be in the range of [1, 1000].\n    \/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n    \/\/ 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n","canonical_solution":"def maximum(arr: List[Long], k: Long): List[Long] = {\n    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_121","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/न च शून्यसूचीयाम् पूर्णाङ्काणां योगः परतः प्राप्नोति।    \/\/ >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))\n    \/\/ (12l)\n    \/\/ >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))\n    \/\/ (9l)\n    \/\/ >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))\n    \/\/ (0l)\n    def solution(lst : List[Long]) : Long = {\n","canonical_solution":"def solution(lst: List[Long]): Long = {\n  lst.zipWithIndex.collect {\n    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num\n  }.sum\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));\n    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));\n    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));\n    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));\n    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));\n    }\n\n}\n"},{"task_id":"HumanEval_122","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/प्रथमं k अङ्कं युक्तं आकृतेः गुणानां योगः।    \/\/पूर्णाङ्कायाम् अङ्केषु च, k इत्यनेन, परतः     \/\/ >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))\n    \/\/ (24l)\n    \/\/ Constraints:\n    \/\/ 1. 1 <= len(arr) <= 100\n    \/\/ 2. 1 <= k <= len(arr)\n    def addElements(arr : List[Long], k : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def addElements(arr: List[Long], k: Long): Long = {\n    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum\n  }\n\n  def main(args: Array[String]): Unit = {\n    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)\n    println(result) \/\/ Output will be 24L\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));\n    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));\n    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));\n    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));\n    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_123","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/get_odd_collatz(5) इत्यनेन [१, ५] इत्यस्य प्रत्ययस्य अनुक्रमः भवति [५, १६, ८, ४, २, १], अतः अप्राकृतसंख्याः केवलं १, ५ च भवन्ति ।    \/\/उदाहरणम् -    \/\/2. प्रतिपादितसूची क्रमशः वर्धते।    \/\/1. कोलाट्जः (१) इति [1] ।    \/\/टिप्पणीः     \/\/पदम्+१। अनुमानं भवति यत् n-स्य कस्य मूल्यस्य विषये अपि अनुक्रमः सदैव 1 प्राप्नोति।    \/\/यदि पूर्वपदम् अप्राप्तं भवति, तर्हि अग्रेपदम् पूर्वपदस्य त्रिगुणा भवति।    \/\/पूर्वपदम् इत्यनेन सूत्रेण लिखत- यदि पूर्वपदम् समः अस्ति, तर्हि अग्रेपदम्  इत्यस्य अर्धं भवति।    \/\/यथा - कस्यचित् धनात्मकः पूर्णाङ्कः n इत्यनेन आरम्भः। ततः प्रत्येकं पदं  इत्यस्मात् प्राप्नोति।    \/\/कोलाट्स् अनुमानः गणितस्य एकः अनुमानः अस्ति, यः एकं अनुक्रमं निर्दिष्टं करोति ।    \/\/धनात्मकं पूर्णाङ्कं n प्राप्नोति, अतः क्रमेण सूचीं प्रति लभेत, यत्र कोलाट्ज-क्रमस्य विषमसंख्याः सन्ति ।    \/\/ >>> getOddCollatz((5l))\n    \/\/ (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable.ListBuffer\n\nobject Problem {\n  def getOddCollatz(n: Long): List[Long] = {\n    val oddNumbers = ListBuffer[Long]()\n    var number = n\n    while (number != 1) {\n      if (number % 2 == 1) {\n        oddNumbers += number\n      }\n      number = if (number % 2 == 0) number \/ 2 else 3 * number + 1\n    }\n    oddNumbers += 1\n    oddNumbers.sorted.toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_124","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/4. दिनाङ्कः MM-DD-YYYY इति स्वरूपेण लिखत।    \/\/3. मासानां संख्या 1 मासाः 12 मासाः च न भवेत् ।    \/\/2. मास 1,3,5,7,8,10,12 इत्यस्य कृते दिने संख्या 1 न न्यूनं वा 31 दिनं न अधिकं भवति। मास 4,6,9,11 इत्यस्य कृते दिने संख्या 1 न न्यूनं वा 30 दिनं न अधिकं भवति। मास 2 इत्यस्य कृते दिने संख्या 1 न न्यूनं वा 29 दिनं न अधिकं भवति।    \/\/1. दिनांक-श्रृङ्खला रिक्तं नास्ति।    \/\/यदि अधोलिखितानि नियमाणि सर्वे अपि पूर्णाः सन्ति तर्हि तिथिः वैधः भवति:    \/\/यदि दिनाङ्कः वैधः अस्ति तर्हि TRUE प्रत्ययस्य प्राप्तिः भवति अन्यथा FALSE प्रत्ययस्य प्राप्तिः भवति ।    \/\/भवद् भ् यः एकं फलनम् लिखत यत् एकं दिशति दिनाङ्कः    \/\/ >>> validDate((\"03-11-2000\"))\n    \/\/ (true)\n    \/\/ >>> validDate((\"15-01-2012\"))\n    \/\/ (false)\n    \/\/ >>> validDate((\"04-0-2040\"))\n    \/\/ (false)\n    \/\/ >>> validDate((\"06-04-2020\"))\n    \/\/ (true)\n    \/\/ >>> validDate((\"06\/04\/2020\"))\n    \/\/ (false)\n    def validDate(date : String) : Boolean = {\n","canonical_solution":"import scala.util.Try\n\nobject Problem {\n  def validDate(date: String): Boolean = {\n    if (date.isEmpty) return false\n    \n    val datePattern = \"\"\"^(\\d{2})-(\\d{2})-(\\d{4})$\"\"\".r\n\n    date match {\n      case datePattern(monthStr, dayStr, yearStr) => \n        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {\n          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>\n            month match {\n              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31\n              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30\n              case 2 => day >= 1 && day <= 29\n              case _ => false\n            }\n          case _ => false\n        }\n      case _ => false\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(validDate((\"03-11-2000\")) == (true));\n    assert(validDate((\"15-01-2012\")) == (false));\n    assert(validDate((\"04-0-2040\")) == (false));\n    assert(validDate((\"06-04-2020\")) == (true));\n    assert(validDate((\"01-01-2007\")) == (true));\n    assert(validDate((\"03-32-2011\")) == (false));\n    assert(validDate((\"\")) == (false));\n    assert(validDate((\"04-31-3000\")) == (false));\n    assert(validDate((\"06-06-2005\")) == (true));\n    assert(validDate((\"21-31-2000\")) == (false));\n    assert(validDate((\"04-12-2003\")) == (true));\n    assert(validDate((\"04122003\")) == (false));\n    assert(validDate((\"20030412\")) == (false));\n    assert(validDate((\"2003-04\")) == (false));\n    assert(validDate((\"2003-04-12\")) == (false));\n    assert(validDate((\"04-2003\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_125","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/वर्णमाला, ord{\"a\") = 0, ord{\"b\") = 1, ... ord{\"z\") = 25     \/\/यदि कम्पायां विभक्तेः ',' यदि कम्पायां न विभक्तेः तर्हि  इत्यस्य स्थाने कम्पायां विरचितेः लघुवर्णानां संख्यां प्रतिपादयतु ।    \/\/यदि वाक्यानां शृङ्खला दीयते, तर्हि वाक्यानां सूचीं रिक्तस्थानैः विभज्य परावर्त्तयतु, यदि वाक्यानां मध्ये रिक्तस्थानं न विद्यते तर्हि पाठः पुनः प्राप्तः करणीयः ।    \/\/ >>> splitWords((\"Hello world!\"))\n    \/\/ List[String](\"Hello\", \"world!\")\n    \/\/ >>> splitWords((\"Hello,world!\"))\n    \/\/ List[String](\"Hello\", \"world!\")\n    \/\/ >>> splitWords((\"abcdef\"))\n    \/\/ 3l\n    def splitWords(txt : String) : Either[List[String], Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def splitWords(txt: String): Either[List[String], Long] = {\n    if (txt.contains(\" \")) {\n      Left(txt.split(\"\\\\s+\").toList)\n    } else if (txt.contains(\",\")) {\n      Left(txt.split(\",\").toList)\n    } else {\n      val oddOrderCount = txt.toCharArray\n        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)\n      Right(oddOrderCount.toLong)\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(splitWords((\"Hello world!\")).equals(List[String](\"Hello\", \"world!\")));\n    assert(splitWords((\"Hello,world!\")).equals(List[String](\"Hello\", \"world!\")));\n    assert(splitWords((\"Hello world,!\")).equals(List[String](\"Hello\", \"world,!\")));\n    assert(splitWords((\"Hello,Hello,world !\")).equals(List[String](\"Hello,Hello,world\", \"!\")));\n    assert(splitWords((\"abcdef\")).equals(3l));\n    assert(splitWords((\"aaabb\")).equals(2l));\n    assert(splitWords((\"aaaBb\")).equals(1l));\n    assert(splitWords((\"\")).equals(0l));\n    }\n\n}\n"},{"task_id":"HumanEval_126","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/संख्या, return false. न च ऋणात्मकं संख्या, केवलम् पूर्णाङ्कं गृहीत्वा।    \/\/यदि सूचीयां एकस्य तुल्यस्य अधिकः प्रतिलिपिः अस्ति, तर्हि अधोलिखितानि पत्राणि क्रमशः पठनीयानि भवन्तु:    \/\/संख्यायाः सूची दीयते, अतः तेषां क्रमणीकरणं करणीयम्।    \/\/ >>> isSorted((List[Long](5l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ (false)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))\n    \/\/ (false)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (false)\n    def isSorted(lst : List[Long]) : Boolean = {\n","canonical_solution":"def isSorted(lst: List[Long]): Boolean = {\n    if (lst.isEmpty || lst.length == 1) return true\n\n    var hasDuplicate = false\n\n    for (i <- 1 until lst.length) {\n        if (lst(i) < lst(i - 1)) {\n            return false\n        }\n        if (lst(i) == lst(i - 1)) {\n            if (hasDuplicate) return false\n            hasDuplicate = true\n        } else {\n            hasDuplicate = false\n        }\n    }\n\n    true\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isSorted((List[Long](5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));\n    assert(isSorted((List[Long]())) == (true));\n    assert(isSorted((List[Long](1l.toLong))) == (true));\n    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_127","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/[इनपुट\/आउटपुट] नमुनेः     \/\/यदि द्वयोः अन्तरालयोः अन्तः न भवति, तर्हि \"न\" प्रत्ययः प्राप्नोति।    \/\/अन्यथा \"न\" इति प्रतिपादयतु।    \/\/यदि क्रमाङ्कः अभाज्यः अस्ति, तर्हि \"YES\" प्रत्ययः प्राप्नोति,     \/\/तस्य दीर्घत्वं १, यस्मात् इदम् अभाज्यसंख्यम् न भवति ।    \/\/उदाहरणम् - अन्तरालानां (1, 3), (2, 4) अन्तरालानां अन्तरालः (2, 3) ।    \/\/अन्तरालः एकं प्रधानं संख्या अस्ति ।    \/\/भवतां कार्यम् अस्ति यत् भवतां कार्यम् इदम् निर्धारयितुं अस्ति यत् इदम् द्वयोः अन्तःकरणस्य लम्बाई अस्ति वा नास्ति ।    \/\/प्रत्येकं दिशन्तरालं तस्य आरम्भः तस्य अन्ते वा लघुः भवति इति गृहीतम् ।    \/\/अत्र आरम्भः समाप्तः च समाविष्टः अस्ति ।    \/\/अत्र अन्तरालः समाहितः अस्ति, अतः अन्तरालः (प्रारम्भः, अन्तः)     \/\/अत्र प्रत्येकं अन्तरालः पूर्णाङ्काणां जोडी भवति। उदाहरणार्थम् अन्तरालः = (प्रारम्भः, अन्तः) = (1, 2) ।    \/\/भवद्भिरुच्यते द्वौ अन्तरालौ,     \/\/ >>> intersection(((1l, 2l)), ((2l, 3l)))\n    \/\/ (\"NO\")\n    \/\/ >>> intersection(((-1l, 1l)), ((0l, 4l)))\n    \/\/ (\"NO\")\n    \/\/ >>> intersection(((-3l, -1l)), ((-5l, 5l)))\n    \/\/ (\"YES\")\n    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {\n","canonical_solution":"import scala.math._\n\nobject Problem {\n  def isPrime(n: Long): Boolean = {\n    if (n <= 1) return false\n    if (n <= 3) return true\n    if (n % 2 == 0 || n % 3 == 0) return false\n    var i = 5\n    while (i * i <= n) {\n      if (n % i == 0 || n % (i + 2) == 0) return false\n      i += 6\n    }\n    true\n  }\n\n  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {\n    val start = max(interval1._1, interval2._1)\n    val end = min(interval1._2, interval2._2)\n    if (start > end) return \"NO\"\n\n    val length = end - start\n    if (isPrime(length)) \"YES\" else \"NO\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"},{"task_id":"HumanEval_128","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/टिप्पणीः रिक्त आर्कः हेतुः None प्रतिपादितं भवति।    \/\/सूचीषु प्रत्येकं संख्याः १, -१, ० इति प्रतिपादितम् अस्ति ।    \/\/पूर्णाङ्काणां परिमाणानां योगः सर्वसंज्ञाणां गुणनफलैः गुणितः।    \/\/भवद्भिरुपादानं पूर्णाङ्कं भवति, अतः भवद्भिरुपादानं करणीयम् ।    \/\/ >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))\n    \/\/ Some(9l)\n    \/\/ >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n    \/\/ Some(0l)\n    \/\/ >>> prodSigns((List[Long]()))\n    \/\/ None\n    def prodSigns(arr : List[Long]) : Option[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def prodSigns(arr: List[Long]): Option[Long] = {\n    if (arr.isEmpty) return None\n\n    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))\n    val sumOfMagnitudes = arr.map(_.abs).sum\n\n    Some(sumOfMagnitudes * productOfSigns)\n  }\n\n  private def sign(num: Long): Long = {\n    if (num > 0) 1\n    else if (num < 0) -1\n    else 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));\n    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));\n    }\n\n}\n"},{"task_id":"HumanEval_129","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/कक्षानां मूल्यानां क्रमबद्धसूचीं प्रतिपादयति यानि कक्षानां न्यूनतममार्गः गच्छति ।    \/\/उत्तरं एकमेव इति निश्चितम् अस्ति ।    \/\/lst_A[j] = lst_B[j] ।    \/\/अतः इत्थं भवति यत् lst_A[i] < lst_B[i] च कस्यचित् j (1 <= j < i) कृते अस्मिन्     \/\/lst_B-संख्ययाम्+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपि+अपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपिअपि    \/\/(तान् lst_A तथा lst_B इति नामनिर्दिष्टं) lst_A इत्यनेन शब्दकोशस्य संख्या न्यूनम् अस्ति ।    \/\/कक्षानां मूल्यानां क्रमबद्धसूचीं कृत्वा, ए, बी, ए, बी, ए, बी, ए, बी, ए, बी, ए, बी, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए, ए।    \/\/यदि कम्पाउण्डः कम्पाउण्डः भवति, तदा कम्पाउण्डः कम्पाउण्डः भवति ।    \/\/भवन् तः न गन्तुं शक् नुयुः।    \/\/न चैवम्) ।    \/\/कृपया विवक्षितं यत् k-लम्बायां पथस्य अर्थः अस्ति यत् k-कोशिकायां (न तु     \/\/ण्वुल्    \/\/अन्यत्र च, भवन्तः तेषु कोष्ठेषु गन्तुं शक्नुवन्ति, येषु भवतां वर्तमानाः कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन कानिचन।    \/\/कस्यचित् कक्षस्य, प्रत्येकं चरणं भवद्भिः कस्यचित् समीपस्थ कक्षं प्रति गन्तुं शक्यते,     \/\/भवन्तः ग्रिडस्य लघुतमं पथं k लम्बं ज्ञातुं शक्नुवन्ति।    \/\/समावेशेन ग्रिडस्य कोष्ठेषु एकवारं एव दृश्यते ।    \/\/प्रत्येकं कक्षं एकं मूल्यम् अन्तर्भवति। [१, एन * एन] इत्यस्य अन्तर्गतस्य प्रत्येकं पूर्णाङ्कः अस्ति।    \/\/N पंक्तीनां N स्तम्भानां च (N >= 2) च धनात्मकं पूर्णाङ्कं k,     \/\/ >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n    \/\/ >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))\n    \/\/ (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def minPath(grid: List[List[Long]], k: Long): List[Long] = {\n    val n = grid.length\n    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n\n\n    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {\n      if (path.length == k) return path\n      var minPath: List[Long] = List.fill(k)(Long.MaxValue)\n      for ((dx, dy) <- directions) {\n        val nx = x + dx\n        val ny = y + dy\n        if (isValid(nx, ny)) {\n          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))\n          if (lexCompare(newPath, minPath)) {\n            minPath = newPath\n          }\n        }\n      }\n      minPath\n    }\n\n    def lexCompare(a: List[Long], b: List[Long]): Boolean = {\n      a.zip(b).find { case (x, y) => x != y } match {\n        case Some((x, y)) => x < y\n        case None => false\n      }\n    }\n\n    var minPathOverall = List.fill(k)(Long.MaxValue)\n    for {\n      i <- 0 until n\n      j <- 0 until n\n    } {\n      val startingPath = List(grid(i)(j))\n      val currentPath = dfs(i, j, startingPath)\n      if (lexCompare(currentPath, minPathOverall)) {\n        minPathOverall = currentPath\n      }\n    }\n    minPathOverall\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_130","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/प्रथमं n + 1 संख्या त्रिबोनक्की-क्रमस्य अस्ति ।    \/\/यदि भवता अकारान्तरसंख्या n दीयते, तर्हि भवता  इत्यस्य सूची परावर्त्तनीया अस्ति    \/\/= 2 + 3 + 3 = 8     \/\/त्रिः (३) = त्रिः (२) + त्रिः (१) + त्रिः (४)    \/\/त्रि ((4) = 3 ।    \/\/त्रिः (२) = १ + (२ \/ २) = २ ।    \/\/उदाहरणम् -    \/\/त्र्यन्ताङ्कः = त्र्यन्ताङ्कः - १ + त्र्यन्ताङ्कः - २ + त्र्यन्ताङ्कः - १, यदि n अस्वाभाविकः अस्ति।    \/\/त्रि (n) = 1 + n \/ 2, यदि n समः अस्ति।    \/\/त्रिः (१) = ३    \/\/त्रिबोनाची-क्रमः पुनः पुनरावृत्तिरूपेण परिभाषितः अस्ति:    \/\/तथापि, जनैः त्रिबोनाची-अनुक्रमः न ज्ञातः।    \/\/सर्वे जनाः फिबोनाची-क्रमेण परिचिताः, गणितज्ञैः १९६० तमे वर्षे अस्य गहनं अध्ययनं कृतम् ।    \/\/ >>> tri((3l))\n    \/\/ (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable.ListBuffer\n\nobject Problem {\n  def tri(n: Long): List[Long] = {\n    \/\/ Initialize list with the first element of the Tribonacci sequence\n    val tribonacciSeq = ListBuffer[Long](3)\n\n    \/\/ Generate remaining elements up to the nth element\n    for (i <- 1L to n) {\n      if (i % 2 == 0) {\n        \/\/ If even, the formula is 1 + n \/ 2\n        tribonacciSeq.append(1 + i \/ 2)\n      } else {\n        \/\/ If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)\n        \/\/ tri(n + 1) is handled as we iterate further\n        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0\n        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0\n        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) \/ 2 else 0 \/\/ calculated as if the next is even\n        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)\n      }\n    }\n\n    \/\/ Return as a list\n    tribonacciSeq.toList\n  }\n\n  \/\/ Test examples\n  def main(args: Array[String]): Unit = {\n    println(tri(3)) \/\/ List(3, 2, 8)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_131","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/यदि सर्वेषां अङ्कं समं भवति तर्हि 0 इत्यस्य प्रतिफलं ददाति।    \/\/धनात्मकं पूर्णाङ्कं n प्राप्नोति, अतः विषमसंख्यानां गुणनफलम् लभेत।    \/\/ >>> digits((1l))\n    \/\/ (1l)\n    \/\/ >>> digits((4l))\n    \/\/ (0l)\n    \/\/ >>> digits((235l))\n    \/\/ (15l)\n    def digits(n : Long) : Long = {\n","canonical_solution":"def digits(n: Long): Long = {\n    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product\n    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l)) == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l)) == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_132","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यत्र कमतः एकः क्रमेण उपसङ्ख्यानं भवति ।    \/\/यदि च केवलम् कण्ठस्थानां वैधः उपसङ्ख्यानं भवति तर्हि फलनम् सत्यम् प्रतिपादयति ।    \/\/अत्र केवलम् वर्गस्य कोष्ठकं युक्तं क्तस्य क्तस्य इङ्पुटं गृह्णाति ।    \/\/ >>> isNested((\"[[]]\"))\n    \/\/ (true)\n    \/\/ >>> isNested((\"[]]]]]]][[[[[]\"))\n    \/\/ (false)\n    \/\/ >>> isNested((\"[][]\"))\n    \/\/ (false)\n    \/\/ >>> isNested((\"[]\"))\n    \/\/ (false)\n    \/\/ >>> isNested((\"[[][]]\"))\n    \/\/ (true)\n    \/\/ >>> isNested((\"[[]][[\"))\n    \/\/ (true)\n    def isNested(string : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isNested(string: String): Boolean = {\n    var stack = new Stack[Char]()\n    var nested = false\n\n    for (char <- string) {\n      char match {\n        case '[' => stack.push(char)\n        case ']' =>\n          if (stack.nonEmpty) {\n            stack.pop()\n            if (stack.nonEmpty) {\n              nested = true\n            }\n          }\n      }\n      if (nested) return true\n    }\n\n    false\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isNested((\"[[]]\")) == (true));\n    assert(isNested((\"[]]]]]]][[[[[]\")) == (false));\n    assert(isNested((\"[][]\")) == (false));\n    assert(isNested((\"[]\")) == (false));\n    assert(isNested((\"[[[[]]]]\")) == (true));\n    assert(isNested((\"[]]]]]]]]]]\")) == (false));\n    assert(isNested((\"[][][[]]\")) == (true));\n    assert(isNested((\"[[]\")) == (false));\n    assert(isNested((\"[]]\")) == (false));\n    assert(isNested((\"[[]][[\")) == (true));\n    assert(isNested((\"[[][]]\")) == (true));\n    assert(isNested((\"\")) == (false));\n    assert(isNested((\"[[[[[[[[\")) == (false));\n    assert(isNested((\"]]]]]]]]\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_133","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/प्रत्येकं तत्वं प्रथमं उपरि इण्ट्-अङ्कं (Intr-A-List) (Intr-A-List) (Intr-A-List) (Intr-A-List) (Intr-A-List) (Intr-A-List) (Intr-A-List) इति वर्णाभ्यां परिमण्डलं कुर्वन्तु ।    \/\/भवद्भिः सूचीमध्ये स्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्क्वायरस्    \/\/भवद्भिः संख्यासूची प्रदत्तम् अस्ति ।    \/\/ >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))\n    \/\/ (14l)\n    \/\/ >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))\n    \/\/ (98l)\n    \/\/ >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))\n    \/\/ (84l)\n    \/\/ >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))\n    \/\/ (29l)\n    \/\/ >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))\n    \/\/ (6l)\n    def sumSquares(lst : List[Float]) : Long = {\n","canonical_solution":"import scala.math._\n\nobject Problem {\n  def sumSquares(lst: List[Float]): Long = {\n    lst.map(x => ceil(x.toDouble).toLong)\n      .map(x => x * x)\n      .sum\n  }\n\n  \/\/ Example usage, you can test the function with the given examples:\n  def main(args: Array[String]): Unit = {\n    println(sumSquares(List(1.0f, 2.0f, 3.0f))) \/\/ Output: 14\n    println(sumSquares(List(1.0f, 4.0f, 9.0f))) \/\/ Output: 98\n    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) \/\/ Output: 84\n    println(sumSquares(List(1.4f, 4.2f, 0.0f))) \/\/ Output: 29\n    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) \/\/ Output: 6\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_134","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/\"शब्दः\" इत्यत्र वर्णानां समूहः अस्ति, यानि स्थानद्वारा पृथक्कृतानि सन्ति ।    \/\/शब्दस्य अंशः, अन्यथा मिथ्या।    \/\/अकारस्य वर्णः अस्ति, न तु  इति    \/\/यदि अन्तिमः अक्षरः  अस्ति तर्हि फलनम् इदम् प्रतिपादयतु    \/\/ >>> checkIfLastCharIsALetter((\"apple pie\"))\n    \/\/ (false)\n    \/\/ >>> checkIfLastCharIsALetter((\"apple pi e\"))\n    \/\/ (true)\n    \/\/ >>> checkIfLastCharIsALetter((\"apple pi e \"))\n    \/\/ (false)\n    \/\/ >>> checkIfLastCharIsALetter((\"\"))\n    \/\/ (false)\n    def checkIfLastCharIsALetter(txt : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def checkIfLastCharIsALetter(txt: String): Boolean = {\n        if (txt.isEmpty) return false\n        val trimmed = txt.trim\n        if (trimmed.isEmpty) return false\n        val parts = trimmed.split(\" \")\n        val lastChars = parts.map(_.last)\n        if (lastChars.isEmpty) return false\n        val lastChar = trimmed.last\n        lastChars.contains(lastChar) && lastChar.isLetter\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(checkIfLastCharIsALetter((\"apple\")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pi e\")) == (true));\n    assert(checkIfLastCharIsALetter((\"eeeee\")) == (false));\n    assert(checkIfLastCharIsALetter((\"A\")) == (true));\n    assert(checkIfLastCharIsALetter((\"Pumpkin pie \")) == (false));\n    assert(checkIfLastCharIsALetter((\"Pumpkin pie 1\")) == (false));\n    assert(checkIfLastCharIsALetter((\"\")) == (false));\n    assert(checkIfLastCharIsALetter((\"eeeee e \")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pie\")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pi e \")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_135","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/न द्वित्वं विद्यते।    \/\/न हि तत्सन्निधौ तत्सन्निधौ पुनः परावर्त्तते -१।    \/\/न तु तत्पूर्वं तत्समानं वा तत्समानम्। यदि     \/\/कस्यचित् अवयवस्य सर्वतः अधिकं सूचकं प्रतिपादयितुं एकं फलनं निर्मितव्यम्    \/\/ >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (-1l)\n    def canArrange(arr : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n  def canArrange(arr: List[Long]): Long = {\n    for (i <- arr.indices.drop(1)) {\n      if (arr(i) < arr(i - 1)) return i.toLong\n    }\n    -1L\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) == (-1l));\n    }\n\n}\n"},{"task_id":"HumanEval_136","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि न अस्ति, तर्हि None इत्यनेन प्रतिपाद्यताम् ।    \/\/धनात्मकं पूर्णाङ्कं सूचीषु लभ्यते।    \/\/अतः \"b\" इत्यस्य लघुतमः गुणः भवति ।    \/\/'a' इत्यत्र 'a, b' इत्यस्य ट्यूप्ले (tuple) इत्यस्य प्रतिफलं ददाति ।    \/\/ >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    \/\/ (Some(None), Some(1l))\n    \/\/ >>> largestSmallestIntegers((List[Long]()))\n    \/\/ (Some(None), Some(None))\n    \/\/ >>> largestSmallestIntegers((List[Long](0l.toLong)))\n    \/\/ (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {\n    val negativeIntegers = lst.filter(_ < 0)\n    val positiveIntegers = lst.filter(_ > 0)\n\n    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None\n    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None\n\n    (largestNegative, smallestPositive)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    }\n\n}\n"},{"task_id":"HumanEval_138","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/यदि दीयते तर्हि चतुर्णां समानां संख्याणां योगः भवति ।    \/\/ >>> isEqualToSumEven((4l))\n    \/\/ (false)\n    \/\/ >>> isEqualToSumEven((6l))\n    \/\/ (false)\n    \/\/ >>> isEqualToSumEven((8l))\n    \/\/ (true)\n    def isEqualToSumEven(n : Long) : Boolean = {\n","canonical_solution":"def isEqualToSumEven(n: Long): Boolean = {\n    \/\/ Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.\n    n >= 8 && n % 2 == 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isEqualToSumEven((4l)) == (false));\n    assert(isEqualToSumEven((6l)) == (false));\n    assert(isEqualToSumEven((8l)) == (true));\n    assert(isEqualToSumEven((10l)) == (true));\n    assert(isEqualToSumEven((11l)) == (false));\n    assert(isEqualToSumEven((12l)) == (true));\n    assert(isEqualToSumEven((13l)) == (false));\n    assert(isEqualToSumEven((16l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_139","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/यत्र n > 0     \/\/brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1!     \/\/ब्राजीलस्य कारकान्तः इत्यनेन परिभाषितः अस्ति:     \/\/ >>> specialFactorial((4l))\n    \/\/ (288l)\n    \/\/ The function will receive an integer as input and should return the special\n    \/\/ factorial of this integer.\n    def specialFactorial(n : Long) : Long = {\n","canonical_solution":"def specialFactorial(n: Long): Long = {\n        def factorial(x: Long): Long = {\n            if (x == 0 || x == 1) 1L\n            else x * factorial(x - 1)\n        }\n\n        (1L to n).map(factorial).product\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(specialFactorial((4l)) == (288l));\n    assert(specialFactorial((5l)) == (34560l));\n    assert(specialFactorial((7l)) == (125411328000l));\n    assert(specialFactorial((1l)) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_140","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ततः सर्वान् अनुक्रमिकान् रिक्तस्थानान् प्रतिस्थापयतु -     \/\/यदि च सूत्रस्य द्वयोः क्रमेण स्थानयोः अधिकः अस्ति,     \/\/पाठस्य शृङ्गारं दत्वा, तस्य सर्वानि रिक्तस्थानानि अधोलिखितानि अक्षरैः प्रतिपाद्यताम्,     \/\/ >>> fixSpaces((\" Example\"))\n    \/\/ (\"Example\")\n    \/\/ >>> fixSpaces((\" Example 1\"))\n    \/\/ (\"Example_1\")\n    \/\/ >>> fixSpaces((\" Example 2\"))\n    \/\/ (\"_Example_2\")\n    \/\/ >>> fixSpaces((\" Example 3\"))\n    \/\/ (\"_Example-3\")\n    def fixSpaces(text : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fixSpaces(text: String): String = {\n    val result = new StringBuilder()\n    var spaceCount = 0\n    var leadingSpace = true\n    \n    for (ch <- text) {\n      if (ch == ' ') {\n        spaceCount += 1\n      } else {\n        if (spaceCount > 0) {\n          if (leadingSpace && result.isEmpty) {\n            result.append('_')\n          } else if (spaceCount == 1) {\n            result.append('_')\n          } else if (spaceCount > 1) {\n            result.append('-')\n          }\n          spaceCount = 0\n        }\n        result.append(ch)\n        leadingSpace = false\n      }\n    }\n    \n    if (spaceCount == 1) {\n      result.append('_')\n    } else if (spaceCount > 1) {\n      result.append('-')\n    }\n    \n    result.toString()\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fixSpaces((\"Example\")).equals((\"Example\")));\n    assert(fixSpaces((\"Mudasir Hanif \")).equals((\"Mudasir_Hanif_\")));\n    assert(fixSpaces((\"Yellow Yellow  Dirty  Fellow\")).equals((\"Yellow_Yellow__Dirty__Fellow\")));\n    assert(fixSpaces((\"Exa   mple\")).equals((\"Exa-mple\")));\n    assert(fixSpaces((\"   Exa 1 2 2 mple\")).equals((\"-Exa_1_2_2_mple\")));\n    }\n\n}\n"},{"task_id":"HumanEval_141","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/- उप-सङ्ख्यानं विन्दु-सङ्ख्यानं पश्चात् इदम् एकः भवेत्: ['txt', 'exe', 'dll']     \/\/लातिनि वर्णमाला (अ-ज्, अ-ज्) ।    \/\/- उप-सङ्ख्यानं पूर्वं न तु रिक्तं भवेत्, तथा च अस्य आरम्भः  इत्यनेन अक्षरेण भवति    \/\/- फाइलस्य नाम्ने एकं बिन्दुः अस्ति '.'    \/\/- फाइल नामस्य नामत्रयेषु अधिकं संख्या नास्ति ('0'-'9') ।    \/\/पूर्यन्ते:     \/\/यदि च केवलं यदि सर्वेषु अधोलिखितानि शर्तेषु विद्यन्ते तर्हि संचिकायाः नाम वैधः इति मन्यते ।    \/\/यदि संचिकायाः नाम वैधं भवति तर्हि 'Yes' इति, अन्यथा 'No' इति च लभ्यते ।    \/\/एकं फलनम् निर्मितव्यम्, यत् फाइलस्य नामं प्रतिपादयति, तथा च  इत्यस्य प्रतिफलम् ददाति ।    \/\/ >>> fileNameCheck((\"example.txt\"))\n    \/\/ (\"Yes\")\n    \/\/ >>> fileNameCheck((\"1example.dll\"))\n    \/\/ (\"No\")\n    def fileNameCheck(file_name : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fileNameCheck(file_name: String): String = {\n    val validExtensions = Set(\"txt\", \"exe\", \"dll\")\n    val dotIndex = file_name.lastIndexOf('.')\n\n    if (dotIndex == -1) return \"No\"\n\n    val beforeDot = file_name.substring(0, dotIndex)\n    val afterDot = file_name.substring(dotIndex + 1)\n\n    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return \"No\"\n\n    val digitCount = beforeDot.count(_.isDigit)\n    if (digitCount > 3) return \"No\"\n\n    if (!validExtensions.contains(afterDot)) return \"No\"\n\n    \"Yes\"\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(fileNameCheck(\"example.txt\")) \/\/ \"Yes\"\n    println(fileNameCheck(\"1example.dll\")) \/\/ \"No\"\n    println(fileNameCheck(\"test123.exe\")) \/\/ \"Yes\"\n    println(fileNameCheck(\".hidden.txt\")) \/\/ \"No\"\n    println(fileNameCheck(\"file..txt\")) \/\/ \"No\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fileNameCheck((\"example.txt\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"1example.dll\")).equals((\"No\")));\n    assert(fileNameCheck((\"s1sdf3.asd\")).equals((\"No\")));\n    assert(fileNameCheck((\"K.dll\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"MY16FILE3.exe\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"His12FILE94.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"_Y.txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"?aREYA.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"\/this_is_valid.dll\")).equals((\"No\")));\n    assert(fileNameCheck((\"this_is_valid.wow\")).equals((\"No\")));\n    assert(fileNameCheck((\"this_is_valid.txt\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"this_is_valid.txtexe\")).equals((\"No\")));\n    assert(fileNameCheck((\"#this2_i4s_5valid.ten\")).equals((\"No\")));\n    assert(fileNameCheck((\"@this1_is6_valid.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"this_is_12valid.6exe4.txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"all.exe.txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"I563_No.exe\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"Is3youfault.txt\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"no_one#knows.dll\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"1I563_Yes3.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"I563_Yes3.txtt\")).equals((\"No\")));\n    assert(fileNameCheck((\"final..txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"final132\")).equals((\"No\")));\n    assert(fileNameCheck((\"_f4indsartal132.\")).equals((\"No\")));\n    assert(fileNameCheck((\".txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"s.\")).equals((\"No\")));\n    }\n\n}\n"},{"task_id":"HumanEval_142","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि इदम् सूत्रम् न भवति, तर्हि इदम् सूत्रं पुनः पुनः लिखत, अतः इदम् सूत्रं पुनः लिखत, अतः इदम् सूत्रं पुनः लिखत, अतः इदम् सूत्रं पुनः लिखत।    \/\/यदि तस्य सूचकाङ्कः 4 इत्यस्य गुणकः न तु 3 इत्यस्य गुणकः अस्ति तर्हि सः पूर्णाङ्कः प्रविष्टः भवति, एवं 3 इत्यस्य गुणकः भवति।    \/\/यदि इण्डेक्सः अ  भवति, तदा इण्डेक्सः पूर्णाङ्कः भवति।    \/\/\"     \/\/ >>> lst\n    \/\/ List[Long](1l.toLong, 2l.toLong, 3l.toLong)\n    \/\/ >>> lst\n    \/\/ List[Long]()\n    \/\/ >>> lst\n    \/\/ List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)\n    def sumSquares(lst : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def sumSquares(lst: List[Long]): Long = {\n        lst.zipWithIndex.map { case (value, index) =>\n            if (index % 3 == 0) {\n                value * value\n            } else if (index % 4 == 0) {\n                value * value * value\n            } else {\n                value\n            }\n        }.sum\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));\n    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));\n    assert(sumSquares((List[Long]())) == (0l));\n    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));\n    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));\n    assert(sumSquares((List[Long](0l.toLong))) == (0l));\n    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));\n    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));\n    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));\n    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));\n    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));\n    }\n\n}\n"},{"task_id":"HumanEval_143","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् १:     \/\/ननु शब्दानां क्रमः मूलशब्दानां क्रमस्य अनुरूपः भवेत् ।    \/\/यस्मै दीर्घः प्रथमाङ्कः अस्ति,    \/\/तथा च मूलवाक्येषु शब्दानां समावेशं कृत्वा,     \/\/वाक्यस्य अन्तर्गतं कानिचन शब्दानि सन्ति, येषु रिक्तस्थानं विधीयते,     \/\/भवद्भिरपि वाक्यस्य सङ्ख्यायाम् एकं सूत्रं दत्ता अस्ति,    \/\/ >>> wordsInSentence((\"This is a test\"))\n    \/\/ (\"is\")\n    \/\/ Example 2:\n    \/\/ >>> wordsInSentence((\"lets go for swimming\"))\n    \/\/ (\"go for\")\n    \/\/ Constraints:\n    \/\/ * 1 <= len(sentence) <= 100\n    \/\/ * sentence contains only letters\n    def wordsInSentence(sentence : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isPrime(n: Int): Boolean = {\n    if (n < 2) false\n    else if (n == 2) true\n    else !(2 to sqrt(n).toInt).exists(n % _ == 0)\n  }\n\n  def wordsInSentence(sentence: String): String = {\n    val words = sentence.split(\" \")\n    val primeLengthWords = words.filter(word => isPrime(word.length))\n    primeLengthWords.mkString(\" \")\n  }\n  \n  \/\/ Example usage:\n  \/\/ println(wordsInSentence(\"This is a test\"))\n  \/\/ println(wordsInSentence(\"lets go for swimming\"))\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(wordsInSentence((\"This is a test\")).equals((\"is\")));\n    assert(wordsInSentence((\"lets go for swimming\")).equals((\"go for\")));\n    assert(wordsInSentence((\"there is no place available here\")).equals((\"there is no place\")));\n    assert(wordsInSentence((\"Hi I am Hussein\")).equals((\"Hi am Hussein\")));\n    assert(wordsInSentence((\"go for it\")).equals((\"go for it\")));\n    assert(wordsInSentence((\"here\")).equals((\"\")));\n    assert(wordsInSentence((\"here is\")).equals((\"is\")));\n    }\n\n}\n"},{"task_id":"HumanEval_144","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/भवद्भिः अनुमानं कर्तुं शक्यते यत् x, तथा n इत्य् अव्ययीभावः अस्ति, तथा च शून्यम् उदात्तं नास्ति।    \/\/<numerator>\/<denominator> यत्र संख्याकारः तथा नामकारः अपि धनात्मकः पूर्णाङ्कः भवति।    \/\/अन्यथा, x तथा n, द्वयोः च भिन्नानां संख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः सङ्ख्यायाः।    \/\/x * n. यदि x * n इत्यस्य मूल्यम् पूर्णाङ्कः भवति, तथा false  इति भवति तर्हि फलनम् सत्यं प्रति परावर्त्तयति.    \/\/भवतां कार्यम् अस्ति यत् एकं फलनं निर्मातुं यत् इदम् अभिव्यक्तिम् सरलं करिष्यति ।    \/\/ >>> simplify((\"1\/5\"), (\"5\/1\"))\n    \/\/ (true)\n    \/\/ >>> simplify((\"1\/6\"), (\"2\/1\"))\n    \/\/ (false)\n    \/\/ >>> simplify((\"7\/10\"), (\"10\/2\"))\n    \/\/ (false)\n    def simplify(x : String, n : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def simplify(x: String, n: String): Boolean = {\n    def parseFraction(fraction: String): (Int, Int) = {\n      val parts = fraction.split(\"\/\")\n      (parts(0).toInt, parts(1).toInt)\n    }\n\n    val (numX, denX) = parseFraction(x)\n    val (numN, denN) = parseFraction(n)\n\n    val multipliedNumerator = numX * numN\n    val multipliedDenominator = denX * denN\n\n    multipliedNumerator % multipliedDenominator == 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(simplify((\"1\/5\"), (\"5\/1\")) == (true));\n    assert(simplify((\"1\/6\"), (\"2\/1\")) == (false));\n    assert(simplify((\"5\/1\"), (\"3\/1\")) == (true));\n    assert(simplify((\"7\/10\"), (\"10\/2\")) == (false));\n    assert(simplify((\"2\/10\"), (\"50\/10\")) == (true));\n    assert(simplify((\"7\/2\"), (\"4\/2\")) == (true));\n    assert(simplify((\"11\/6\"), (\"6\/1\")) == (true));\n    assert(simplify((\"2\/3\"), (\"5\/2\")) == (false));\n    assert(simplify((\"5\/2\"), (\"3\/5\")) == (false));\n    assert(simplify((\"2\/4\"), (\"8\/4\")) == (true));\n    assert(simplify((\"2\/4\"), (\"4\/2\")) == (true));\n    assert(simplify((\"1\/5\"), (\"5\/1\")) == (true));\n    assert(simplify((\"1\/5\"), (\"1\/5\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_145","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/मूलसूचीयां तेषां सूचकाङ्के आधारेण क्रमेण विधीयताम् ।    \/\/यदि अनेकानि पदानि सन्ति, तदा तेषां संख्यायाः योगः समानः भवति,     \/\/तेषां संख्यायाः योगानुसारं वर्धमान क्रमेण।    \/\/एकं फलनम् लिखत, यं पूर्णाङ्काणां सूचीं विसर्जयति।    \/\/ >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))\n    \/\/ (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))\n    \/\/ >>> orderByPoints((List[Long]()))\n    \/\/ (List[Long]())\n    def orderByPoints(nums : List[Long]) : List[Long] = {\n","canonical_solution":"def orderByPoints(nums: List[Long]): List[Long] = {\n    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum\n    \n    nums.zipWithIndex\n      .sortBy { case (num, index) => (digitSum(num), index) }\n      .map(_._1)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_146","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/संख्यायाः प्रथमं च अन्तिमं च अंकं विषम (1, 3, 5, 7, 9) ।    \/\/सूचीषु दशपेक्षा अधिकानि च अवयवानां संख्याः    \/\/संख्यायाः सूचीं प्रविष्टं कृत्वा परावर्त्तनं करोति ।    \/\/ >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))\n    \/\/ (2l)\n    def specialFilter(nums : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def specialFilter(nums: List[Long]): Long = {\n    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'\n    \n    nums.count { num =>\n      val absNumStr = num.abs.toString\n      val firstDigit = absNumStr.head\n      val lastDigit = absNumStr.last\n      \n      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)\n    }.toLong\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(specialFilter(List(15L, -73L, 14L, -15L))) \/\/ Output: 1\n    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) \/\/ Output: 2\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));\n    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));\n    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));\n    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));\n    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));\n    assert(specialFilter((List[Long](1l.toLong))) == (0l));\n    assert(specialFilter((List[Long]())) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_147","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:    \/\/तथा च a[i] + a[j] + a[k] इत्यत्र 3 इत्यस्य गुणकः भवति।    \/\/a इत्यस्य त्रिगुणानां संख्यां प्रतिपादयतु (a[i], a[j], a[k]) यत्र i < j < k,     \/\/प्रत्येकं i (1 ≤ i ≤ n) इत्यनेन a[i] = i * i - i + 1 इत्यस्य मूल्यम् भवति ।    \/\/भवता धनात्मकः पूर्णाङ्कः n दीयते। भवता पूर्णाङ्काणि n-लङ्घनेन सूचीकृतानि भवितव्याः।    \/\/ >>> getMaxTriples((5l))\n    \/\/ (1l)\n    \/\/ Explanation: \n    \/\/ a = [1, 3, 7, 13, 21]\n    \/\/ The only valid triple is (1, 7, 13).\n    def getMaxTriples(n : Long) : Long = {\n","canonical_solution":"def getMaxTriples(n: Long): Long = {\n    val a = (1L to n).map(i => i * i - i + 1).toList\n    var count = 0L\n\n    for {\n      i <- 0L until n\n      j <- i + 1 until n\n      k <- j + 1 until n\n    } {\n      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {\n        count += 1\n      }\n    }\n\n    count\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getMaxTriples((5l)) == (1l));\n    assert(getMaxTriples((6l)) == (4l));\n    assert(getMaxTriples((10l)) == (36l));\n    assert(getMaxTriples((100l)) == (53361l));\n    }\n\n}\n"},{"task_id":"HumanEval_148","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/न च ग्रहानाम् उचितम् अस्ति ।    \/\/यदि planet1 अथवा planet2  इति तर्हि फलनम् रिक्तं ट्यूप्ल प्रतिपादयति ।    \/\/सूर्यस्य समीपस्थः।    \/\/ग्रह-१ च ग्रह-२ च च कक्षायां स्थितं,     \/\/कार्यम् एव एव ग्रहान् प्रतिपादयति ।    \/\/एकं फलनम् लिखत, यस्मिन् ग्रहयोः नामः ग्रहः १, ग्रहः २ इति सूत्रेण प्राप्नोति।    \/\/यूरेनसः, नेप्च्यूनः।    \/\/बुधः, अग्ने शुक्रः, ततः पृथिवी, मार्सः, बृहस्पतिः, शनिः,    \/\/अस्मिन् सौरमण्डले अष्टौ ग्रहाः सन्ति , सूर्यस्य समीपे ये सन्ति ।    \/\/ >>> bf((\"Jupiter\"), (\"Neptune\"))\n    \/\/ (List[String](\"Saturn\", \"Uranus\"))\n    \/\/ >>> bf((\"Earth\"), (\"Mercury\"))\n    \/\/ (List[String](\"Venus\"))\n    \/\/ >>> bf((\"Mercury\"), (\"Uranus\"))\n    \/\/ (List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def bf(planet1: String, planet2: String): List[String] = {\n    val planets = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    \n    \/\/ Find the indices of the given planets\n    val index1Opt = planets.indexOf(planet1)\n    val index2Opt = planets.indexOf(planet2)\n    \n    \/\/ If either planet is not found, return an empty list\n    if (index1Opt == -1 || index2Opt == -1) {\n      return List.empty\n    }\n    \n    \/\/ Sort indices to ensure proper traversal direction\n    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)\n    \n    \/\/ Get the planets between the indices\n    planets.slice(startIndex + 1, endIndex)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"},{"task_id":"HumanEval_149","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/भवन् तः अनुमानं करिष्यन्ति यत् सर्वेषां शब्देन एकस्य दीर्घः भविष्यति।    \/\/कार्यम् अनुक्रमात् क्रमात् सूची प्रतिपादयति।    \/\/यदि द्वयोः शब्दयोः लम्बाई एकसमानः भवति, तर्हि सूचीं वर्णमालाक्रमेण क्रमबद्धं कुरुत।    \/\/एतस्य नियमस्य अनुसारं सूचीं विसृज्य पुनः प्रेषयतु ।    \/\/सूचीयाः क्रमः प्रत्येकं शब्दस्य दीर्घत्वेन आरोहणीयः भवितुम् अर्हति, तथा भवन्तः    \/\/एवं च कदाचित् द्वित्वं भवति ।    \/\/सूचीः सदैव सङ्ख्यासूची, न तु सङ्ख्यासूची,     \/\/एवं प्राप्ते सूचीं क्रमबद्धं प्रति लभते,     \/\/अकारान्तस्य दीर्घः अस्ति, अतः सः अकारान्तस्य दीर्घः भवति।    \/\/क्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य पदान्तस्य    \/\/ >>> listSort((List[String](\"aa\", \"a\", \"aaa\")))\n    \/\/ (List[String](\"aa\"))\n    \/\/ >>> listSort((List[String](\"ab\", \"a\", \"aaa\", \"cd\")))\n    \/\/ (List[String](\"ab\", \"cd\"))\n    def sortedListSum(lst : List[String]) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def listSort(lst: List[String]): List[String] = {\n        lst.filter(_.length % 2 == 0)\n           .sorted\n           .sortBy(_.length)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortedListSum((List[String](\"aa\", \"a\", \"aaa\"))).equals((List[String](\"aa\"))));\n    assert(sortedListSum((List[String](\"school\", \"AI\", \"asdf\", \"b\"))).equals((List[String](\"AI\", \"asdf\", \"school\"))));\n    assert(sortedListSum((List[String](\"d\", \"b\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"d\", \"dcba\", \"abcd\", \"a\"))).equals((List[String](\"abcd\", \"dcba\"))));\n    assert(sortedListSum((List[String](\"AI\", \"ai\", \"au\"))).equals((List[String](\"AI\", \"ai\", \"au\"))));\n    assert(sortedListSum((List[String](\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"aaaa\", \"bbbb\", \"dd\", \"cc\"))).equals((List[String](\"cc\", \"dd\", \"aaaa\", \"bbbb\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_150","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/अभाज्यसंख्याः, अतः y इत्यस्य मूल्यं प्रतिपादयतु अन्यथा।    \/\/यदि n  भवति तर्हि x इत्यस्य मूल्यम् प्रतिपादयितुम् एकं सरलप्रोग्राम् अस्ति ।    \/\/ >>> xOrY((7l), (34l), (12l))\n    \/\/ (34l)\n    \/\/ >>> xOrY((15l), (8l), (5l))\n    \/\/ (5l)\n    def xOrY(n : Long, x : Long, y : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \n  def isPrime(num: Long): Boolean = {\n    if (num <= 1) return false\n    if (num <= 3) return true\n    if (num % 2 == 0 || num % 3 == 0) return false\n    var i = 5\n    while (i * i <= num) {\n      if (num % i == 0 || num % (i + 2) == 0) return false\n      i += 6\n    }\n    true\n  }\n\n  def xOrY(n: Long, x: Long, y: Long): Long = {\n    if (isPrime(n)) x else y\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(xOrY((7l), (34l), (12l)) == (34l));\n    assert(xOrY((15l), (8l), (5l)) == (5l));\n    assert(xOrY((3l), (33l), (5212l)) == (33l));\n    assert(xOrY((1259l), (3l), (52l)) == (3l));\n    assert(xOrY((7919l), (-1l), (12l)) == (-1l));\n    assert(xOrY((3609l), (1245l), (583l)) == (583l));\n    assert(xOrY((91l), (56l), (129l)) == (129l));\n    assert(xOrY((6l), (34l), (1234l)) == (1234l));\n    assert(xOrY((1l), (2l), (0l)) == (0l));\n    assert(xOrY((2l), (2l), (0l)) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_151","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अकारान्ताः संख्याः अनवधानं कुर्वन्तु ।    \/\/संख्यायाः सूची दत्त्वा, संख्यायाः वर्गस्य योगं प्रतिपादयतु।    \/\/ >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))\n    \/\/ (10l)\n    \/\/ >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))\n    \/\/ (0l)\n    \/\/ >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))\n    \/\/ (81l)\n    \/\/ >>> doubleTheDifference((List[Float](0l.toLong)))\n    \/\/ (0l)\n    \/\/ If the input list is empty, return 0.\n    def doubleTheDifference(lst : List[Float]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def doubleTheDifference(lst: List[Float]): Long = {\n    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)\n      .map(x => x.toLong * x.toLong)\n      .sum\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(doubleTheDifference((List[Float]())) == (0l));\n    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));\n    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));\n    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));\n    }\n\n}\n"},{"task_id":"HumanEval_152","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि न भवति, तर्हि अनुमानस्य तथा स्कोर्स्-लक्षणस्य निरपेक्षभेदः भवति ।    \/\/यदि तेभ्यः अनुमानं सुयोग्यम् अस्ति, तर्हि     \/\/भवद्भिः समान-लम्बाः स्कोर्स् तथा अनुमानानां द्वयोः सूचयः प्रदत्ताः, यत्र प्रत्येकं सूचकः समानाधिकरणं दर्शयति ।    \/\/भवता कार्यम् अस्ति यत् भवता निश्चितं भवेत् यत् कश्चित् व्यक्तिः कतिषु क्रीडावसरेषु फलं अच्युतं ज्ञातवान् वा न।    \/\/न चैवं, न चैवं, न चैवं, न चैवं, न चैवं, न चैवं, न चैवं।    \/\/भवता तत् क्षणम् अस्मिन् स्थिते यत् अनुभूयते, तत् विचारं च भवता ज्ञातम् अस्ति ।    \/\/मम विचारतः अस्मिन् विषये सर्वे जनाः स्मरन्ति यत् यदा दीर्घकालं प्रतीक्षितः परिणामः भवति तदा कस्मैचित् व्यक्तेः जीवनं सुखम् भवति ।    \/\/ >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))\n    \/\/ (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))\n    \/\/ >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))\n    \/\/ (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def compare(game: List[Long], guess: List[Long]): List[Long] = {\n    game.zip(guess).map { case (g, gs) => abs(g - gs) }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_153","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/(अस्य शक्तिः -१) ।    \/\/return 'Slices.SErviNGSliCes' इत्यनेन 'SrviNGSliCes' इत्यस्य प्रबलतमः विस्ताराः सन्ति ।    \/\/['सेर्व् इङ् स् लिस् सीस्', 'चिज्', 'स्टुफ् फ् ड् '] तर्हि भवता     \/\/उदाहरणार्थम्, यदि \"स्लाईस्\" वर्गः एवं वर्गस्य सूची च दीयते, तर्हि     \/\/सूचीमध्ये प्रथमं आगच्छतीति च्छिद्यत।    \/\/यदि द्वौ वा अधिकौ विस्तारौ समानशक्तौ सन्ति, तर्हि भवता     \/\/स्वरूपः ClassName.StrongestExtensionName.     \/\/भवद् भ् यः इदम् अन्वेषणम् करणीयम् यत् इदम् अधिकः अस्ति, अतः इदम् प्रतिपादयतु ।    \/\/विस्तारेण नामतः शक्तिः CAP-SM इत्यनेन दशांशेण दीयते ।    \/\/विस्तारनामस्य अक्षरं, लघु अक्षरानां संख्याः SM भवेत् ।    \/\/विस्ताराणां शक्तिः यथा, -- CAP इत्यस्य संख्याः अपरकेस     \/\/वर्गस्य अतिरिक्तं वर्गं लोडयितुं विस्ताराः प्रयुज्यते ।    \/\/भवता वर्गस्य नाम (एकः स्ट्रिंग) एवं विस्ताराणां सूची दीयते ।    \/\/ >>> StrongestExtension((\"my_class\"), (List[String](\"AA\", \"Be\", \"CC\")))\n    \/\/ (\"my_class.AA\")\n    def StrongestExtension(class_name : String, extensions : List[String]) : String = {\n","canonical_solution":"def StrongestExtension(class_name: String, extensions: List[String]): String = {\n        extensions.map { extension =>\n            val capCount = extension.count(_.isUpper)\n            val lowerCount = extension.count(_.isLower)\n            val strength = capCount - lowerCount\n            (extension, strength)\n        }.maxBy(_._2)._1\n    } match {\n        case strongest => s\"$class_name.$strongest\"\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"},{"task_id":"HumanEval_154","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि द्वितीयः शब्दः अथवा तस्य कस्यचित् परिक्रमणं प्रथमस्य शब्दस्य उपसङ्ख्यानं भवति तर्हि भवता सत्यं प्रति लभेत।    \/\/ >>> cycpatternCheck((\"abcd\"), (\"abd\"))\n    \/\/ (false)\n    \/\/ >>> cycpatternCheck((\"hello\"), (\"ell\"))\n    \/\/ (true)\n    \/\/ >>> cycpatternCheck((\"whassup\"), (\"psus\"))\n    \/\/ (false)\n    \/\/ >>> cycpatternCheck((\"abab\"), (\"baa\"))\n    \/\/ (true)\n    \/\/ >>> cycpatternCheck((\"efef\"), (\"eeff\"))\n    \/\/ (false)\n    \/\/ >>> cycpatternCheck((\"himenss\"), (\"simen\"))\n    \/\/ (true)\n    def cycpatternCheck(a : String, b : String) : Boolean = {\n","canonical_solution":"def cycpatternCheck(a: String, b: String): Boolean = {\n  val bLength = b.length\n  val bDouble = b + b \/\/ Create a string with b concatenated with itself to represent all rotations\n  for (i <- 0 until bLength) {\n    val rotation = bDouble.substring(i, i + bLength) \/\/ Get the current rotation\n    if (a.contains(rotation)) return true\n  }\n  false\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(cycpatternCheck((\"xyzw\"), (\"xyw\")) == (false));\n    assert(cycpatternCheck((\"yello\"), (\"ell\")) == (true));\n    assert(cycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n    assert(cycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    assert(cycpatternCheck((\"abab\"), (\"aabb\")) == (false));\n    assert(cycpatternCheck((\"winemtt\"), (\"tinem\")) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_155","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/पूर्णाङ्कः प्राप्नोति, अतः इकारस्य संख्याः समः, विषमश्च भवति ।    \/\/ >>> evenOddCount((-12l))\n    \/\/ ((1l, 1l))\n    \/\/ >>> evenOddCount((123l))\n    \/\/ ((1l, 2l))\n    def evenOddCount(num : Long) : Tuple2[Long, Long] = {\n","canonical_solution":"def evenOddCount(num: Long): Tuple2[Long, Long] = {\n  val digits = num.abs.toString.map(_.asDigit)\n  val evenCount = digits.count(_ % 2 == 0).toLong\n  val oddCount = digits.count(_ % 2 != 0).toLong\n  (evenCount, oddCount)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(evenOddCount((7l)).equals(((0l, 1l))));\n    assert(evenOddCount((-78l)).equals(((1l, 1l))));\n    assert(evenOddCount((3452l)).equals(((2l, 2l))));\n    assert(evenOddCount((346211l)).equals(((3l, 3l))));\n    assert(evenOddCount((-345821l)).equals(((3l, 3l))));\n    assert(evenOddCount((-2l)).equals(((1l, 0l))));\n    assert(evenOddCount((-45347l)).equals(((2l, 3l))));\n    assert(evenOddCount((0l)).equals(((1l, 0l))));\n    }\n\n}\n"},{"task_id":"HumanEval_156","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/प्रतिबन्धः 1 <= num <= 1000     \/\/एवं लघुवर्णेण प्रतिपादयतु।    \/\/धनात्मकं पूर्णाङ्कं दत्त्वा तस्य रोमनसंख्यात्मकं समकलं सूत्रं प्राप्तं,     \/\/ >>> intToMiniRoman((19l))\n    \/\/ (\"xix\")\n    \/\/ >>> intToMiniRoman((152l))\n    \/\/ (\"clii\")\n    \/\/ >>> intToMiniRoman((426l))\n    \/\/ (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def intToMiniRoman(number: Long): String = {\n    val romanMap: List[(Int, String)] = List(\n      (1000, \"m\"),\n      (900, \"cm\"),\n      (500, \"d\"),\n      (400, \"cd\"),\n      (100, \"c\"),\n      (90, \"xc\"),\n      (50, \"l\"),\n      (40, \"xl\"),\n      (10, \"x\"),\n      (9, \"ix\"),\n      (5, \"v\"),\n      (4, \"iv\"),\n      (1, \"i\")\n    )\n\n    var num = number.toInt\n    val stringBuilder = new StringBuilder\n\n    for ((value, roman) <- romanMap) {\n      while (num >= value) {\n        stringBuilder.append(roman)\n        num -= value\n      }\n    }\n\n    stringBuilder.toString()\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n}\n"},{"task_id":"HumanEval_157","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/९० डिग्री।    \/\/एकं विषुववृत्तं त्रिकोणं भवति यत्र एकः कोणः विषुववृत्तः भवति अथवा     \/\/पक्षेषु एकं समकोण त्रिभुजं भवति, अन्यथा असत्यम् ।    \/\/त्रिकोणस्य त्रिषु पक्षेषु लम्बं ददाति। यदि त्रिषु पक्षेषु लम्बं ददाति तर्हि लम्बं लभते।    \/\/ >>> rightAngleTriangle((3l), (4l), (5l))\n    \/\/ (true)\n    \/\/ >>> rightAngleTriangle((1l), (2l), (3l))\n    \/\/ (false)\n    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {\n","canonical_solution":"def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {\n        val sides = List(a, b, c).sorted\n        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));\n    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));\n    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));\n    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));\n    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));\n    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));\n    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));\n    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));\n    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));\n    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));\n    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_158","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अक्षरं प्रति, शब्दकोशानुक्रमात् प्रथमं आगच्छति ।    \/\/यदि बहुव्रीहिः अस्ति, तर्हि अनोक्तवर्णानां संख्याः अधिकतमः अस्ति ।    \/\/अत्र विभिन्नाः शब्दः सन्ति। अधिकतमः शब्दः प्रतिपाद्यताम्।    \/\/क्तप्रत्ययस्य सूचीं स्वीकरोति इति फलनम् लिखत।    \/\/ >>> findMax((List[String](\"name\", \"of\", \"string\")))\n    \/\/ (\"string\")\n    \/\/ >>> findMax((List[String](\"name\", \"enam\", \"game\")))\n    \/\/ (\"enam\")\n    \/\/ >>> findMax((List[String](\"aaaaaaa\", \"bb\", \"cc\")))\n    \/\/ (\"aaaaaaa\")\n    def findMax(words : List[String]) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def findMax(words: List[String]): String = {\n    words.maxBy(word => (word.toSet.size, -word.toLowerCase))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(findMax((List[String](\"name\", \"of\", \"string\"))).equals((\"string\")));\n    assert(findMax((List[String](\"name\", \"enam\", \"game\"))).equals((\"enam\")));\n    assert(findMax((List[String](\"aaaaaaa\", \"bb\", \"cc\"))).equals((\"aaaaaaa\")));\n    assert(findMax((List[String](\"abc\", \"cba\"))).equals((\"abc\")));\n    assert(findMax((List[String](\"play\", \"this\", \"game\", \"of\", \"footbott\"))).equals((\"footbott\")));\n    assert(findMax((List[String](\"we\", \"are\", \"gonna\", \"rock\"))).equals((\"gonna\")));\n    assert(findMax((List[String](\"we\", \"are\", \"a\", \"mad\", \"nation\"))).equals((\"nation\")));\n    assert(findMax((List[String](\"this\", \"is\", \"a\", \"prrk\"))).equals((\"this\")));\n    assert(findMax((List[String](\"b\"))).equals((\"b\")));\n    assert(findMax((List[String](\"play\", \"play\", \"play\"))).equals((\"play\")));\n    }\n\n}\n"},{"task_id":"HumanEval_159","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्:     \/\/यदि पर्याप्तं शेषं गाजरं न भवति, तर्हि भवन्तः शेषं गाजरं खादयन्ति, तथापि भक्षयन्ति।    \/\/भोजनानन्तरं शेषं गाजरं ]     \/\/[ भोजनात् अनन्तरं जर्जरस्य कुलसंख्येयम् ]    \/\/इदानीं भवता दिनस्य भोजनं पूर्णं कर्तुम् अधिकं गाजरं खादन्तु।    \/\/भवन् क्षुधाग्रं कर्णिका, भवन् च अगोचरं कार्त्तिकं खादितवान्,    \/\/ >>> eat((5l), (6l), (10l))\n    \/\/ (List[Long](11l.toLong, 4l.toLong))\n    \/\/ >>> eat((4l), (8l), (9l))\n    \/\/ (List[Long](12l.toLong, 1l.toLong))\n    \/\/ >>> eat((1l), (10l), (10l))\n    \/\/ (List[Long](11l.toLong, 0l.toLong))\n    \/\/ >>> eat((2l), (11l), (5l))\n    \/\/ (List[Long](7l.toLong, 0l.toLong))\n    \/\/ Variables:\n    \/\/ @number : integer\n    \/\/ the number of carrots that you have eaten.\n    \/\/ @need : integer\n    \/\/ the number of carrots that you need to eat.\n    \/\/ @remaining : integer\n    \/\/ the number of remaining carrots thet exist in stock\n    \/\/ Constrain:\n    \/\/ * 0 <= number <= 1000\n    \/\/ * 0 <= need <= 1000\n    \/\/ * 0 <= remaining <= 1000\n    \/\/ Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def eat(number: Long, need: Long, remaining: Long): List[Long] = {\n    val totalNeeded = number + need\n    if (remaining >= need) {\n      List(totalNeeded, remaining - need)\n    } else {\n      List(number + remaining, 0)\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_160","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/अपरेटरसूचीयां एकः अपरेटरः अस्ति, अपरेण्डसूचीयां द्वयोः अपरेण्डः सन्ति ।    \/\/अपरान्दस्य सूची न ऋणात्मकानां पूर्णाङ्काणां सूची भवति ।    \/\/अपरेन्ड्-सूचीयाः लम्बाईः अपरेन्ड्-सूचीयाः लम्बाईः शून्य-एक-अङ्कः भवति ।    \/\/टिप्पणीः     \/\/=> परिणामः = ९     \/\/परिणामः = 2 + 3 * 4 - 5     \/\/सूची = [२,३,४,५]     \/\/प्रचालकः['+', '*', '-']     \/\/उदाहरणम्:     \/\/गुणाङ्कितम् (**)     \/\/अधः विभाजनम् (\/\/)    \/\/गुणनम् (*)     \/\/घटः (--)     \/\/अङ्गुष्ठम् (+)     \/\/मूलभूतबीजक्रियाः     \/\/अतः इदम् अव्ययम् अव्ययम् इति विवक्षितम् ।    \/\/द्वितीयसूची पूर्णाङ्काणां सूची अस्ति।    \/\/द्वौ सूचीषु ऑपरेटरः, तथा ऑपरेण्डः च दीयते। प्रथमसूचीयां मूलभूतबीजक्रियाः सन्ति, तथा     def doAlgebra(op : List[String], operand : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def doAlgebra(op: List[String], operand: List[Long]): Long = {\n    var result = operand.head\n    for (i <- 0 until op.length) {\n      op(i) match {\n        case \"+\" => result += operand(i + 1)\n        case \"-\" => result -= operand(i + 1)\n        case \"*\" => result *= operand(i + 1)\n        case \"\/\/\" => result \/= operand(i + 1)\n        case \"**\" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong\n      }\n    }\n    result\n  }\n\n  def main(args: Array[String]): Unit = {\n    val operators = List(\"+\", \"*\", \"-\")\n    val operands = List(2L, 3L, 4L, 5L)\n    println(doAlgebra(operators, operands)) \/\/ Output: 9\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\/\/\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"},{"task_id":"HumanEval_161","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम्     \/\/कार्यस्य निष्पन्नस्य स्ट्रिंगस्य प्रतिफलं दातव्यम् ।    \/\/यदि अक्षरं न भवति, तर्हि अक्षरं विलोमयेत् ।    \/\/अन्यथा यथास्थितं कुर्यात्।    \/\/यदि s[i] अक्षरं भवति, तर्हि तस्य अक्षरस्य अपरम् अपरम् अनवस्थितं भवति, अथवा अपरम् अपरम् अनवस्थितं भवति,     \/\/भवद्भिरपि क्तप्रत्ययस्य लकारः प्राप्नोति ।    \/\/ >>> solve((\"1234\"))\n    \/\/ (\"4321\")\n    \/\/ >>> solve((\"ab\"))\n    \/\/ (\"AB\")\n    \/\/ >>> solve((\"#a@C\"))\n    \/\/ (\"#A@c\")\n    def solve(s : String) : String = {\n","canonical_solution":"def solve(s: String): String = {\n    if (s.exists(_.isLetter)) {\n      s.map {\n        case c if c.isLetter && c.isLower => c.toUpper\n        case c if c.isLetter && c.isUpper => c.toLower\n        case c => c\n      }.mkString\n    } else {\n      s.reverse\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(solve((\"AsDf\")).equals((\"aSdF\")));\n    assert(solve((\"1234\")).equals((\"4321\")));\n    assert(solve((\"ab\")).equals((\"AB\")));\n    assert(solve((\"#a@C\")).equals((\"#A@c\")));\n    assert(solve((\"#AsdfW^45\")).equals((\"#aSDFw^45\")));\n    assert(solve((\"#6@2\")).equals((\"2@6#\")));\n    assert(solve((\"#$a^D\")).equals((\"#$A^d\")));\n    assert(solve((\"#ccc\")).equals((\"#CCC\")));\n    }\n\n}\n"},{"task_id":"HumanEval_162","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/यदि 'text' इत्यत्र रिक्तः सूत्रः अस्ति तर्हि None इत्यस्य प्रतिगमनं कुरुत।    \/\/'text' इति सूत्रं प्राप्नोति, तस्मिन् md5 hash equivalent string इत्यस्य सूत्रं प्रतिपादयतु।    \/\/ >>> stringToMd5((\"Hello world\"))\n    \/\/ Some(\"3e25960a79dbc69b674cd4ec67a72c62\")\n    def stringToMd5(text : String) : Option[String] = {\n","canonical_solution":"import java.security.MessageDigest\n\nobject Problem {\n  def stringToMd5(text: String): Option[String] = {\n    if (text.isEmpty) None\n    else {\n      val md = MessageDigest.getInstance(\"MD5\")\n      val digest = md.digest(text.getBytes)\n      Some(digest.map(\"%02x\".format(_)).mkString)\n    }\n  }\n}\n\n\/\/ Example usage:\n\/\/ println(Problem.stringToMd5(\"Hello world\"))  \/\/ Output: Some(\"3e25960a79dbc69b674cd4ec67a72c62\")","tests":"    }\n    def main(args: Array[String]) = {\n    assert(stringToMd5((\"Hello world\")).equals(Some(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert(stringToMd5((\"\")).equals(None));\n    assert(stringToMd5((\"A B C\")).equals(Some(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert(stringToMd5((\"password\")).equals(Some(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n    }\n\n}\n"},{"task_id":"HumanEval_163","nl":"san_Deva","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/उदाहरणम् -    \/\/तथा च, b, वृद्धिक्रमात्।    \/\/यदि द्वौ धनात्मकौ पूर्णाङ्काः a, b, इति प्राप्नुवन्ति तर्हि a  इत्यस्य मध्ये समं संख्यां लभेत।    \/\/ >>> generateIntegers((2l), (8l))\n    \/\/ (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))\n    \/\/ >>> generateIntegers((8l), (2l))\n    \/\/ (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))\n    \/\/ >>> generateIntegers((10l), (14l))\n    \/\/ (List[Long]())\n    def generateIntegers(a : Long, b : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def generateIntegers(a: Long, b: Long): List[Long] = {\n    val start = min(a, b)\n    val end = max(a, b)\n    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i\n    evenNumbers.map(_.toLong).toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((17l), (89l)).equals((List[Long]())));\n    }\n\n}\n"}]