[
    {
        "task_id": "HumanEval/0",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چیک کرِو اگر دِنہٕ آمتین نمبرن ہند ویکٹر منز، کنٛہہ تہٕ دۄن نمبرن ہند اکھ ایکِس بییس سٕتۍ دِنہٕ آمٕتۍ حد کھوتہٕ زیادٕہ قریب چِھ ۔ >>> has_close_elements{\"{\"{\"{\"{\"{\"{\"{\"{\"{\"{\"{\"{\"{\"{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}{\"}}{\"}{\"}}{\"}{\"}}{\"}{\"}{\"}}{\"}}{\"}}{\"}{\"}}{\"}}{\"}}{\"}{\"}}}{\"}}}{\"}}{\"}}{\"}}}{\"}}}{\"}}}{\"}}{\"}}}{\"}}\"}\"}\"}\"}\"}\"}\"}\"}\"}\"{\"}\"}\"}\"}\"}\"{\"}\"}\"}\"}\"}\"}\"{\"}\"}\"}\"}\"}\"{\"}\"}\"}\"}\"}\"}\"{\"}\"}\"}\"}\"{\"}\"}\"}\"}\"}\"{\"}\"}\"}\"}\"{\"}\"}\"}\"}\"}\"{\"}\"}\"}\"{\"}\"}\"}\"}\"}\"}\"{\"}\"}\"}\"{\"}\"}\"}\"}\"}\"{\"}\"}\"\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ اکھ سٹرنگ ان پٹ ییتھ منٛز نیسٹڈ پیرنٹسس ہنٛد متعدد گروپ چِھ آسان۔ توہیہٕ چِھ یمن گروپن الگ الگ سٹرنگن منٛز الگ کرنہٕ تہٕ یمن ہیند ویکٹر واپس کرن۔ الگ الگ گروپ چِھ متوازن (ہر کھلہٕ بریکٹ چُھ صحیح پأٹھۍ بند) تہٕ اکھ اکس منٛز چِھ نہٕ نیسٹڈ ان پٹ سٹرنگس منٛز کنہہ خلا نظر انداز کران۔ >>> separate_paren_groups(\"( ) (() (( ) ))))) (std::vector<std::string>({(std::string) \")\", ((((())\", (std::string) \"((()))))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت فلوٹنگ پوائنٹ نمبر دنہٕ آمت، یہ ہیکو انٹیجر حصہٕ (بڑین نمبرن ہندسہٕ کھوتہٕ لوکٹ) تہٕ اعشاریہ (باقی حصہٕ ہمیشہ 1 کھوتہٕ لوکٹ) منٛز تقسیم کٔرتھ۔ نمبر کس اعشاریہ کس حصس واپس ییہٕ دنہٕ۔ >>> truncate_number((3.5f)) (0.5f)\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھِ بینک اکاونٹس پیٹھ جمع تہٕ واپسی ہنز کارروائیہٕ ہند اکھ ویکٹر دِنہٕ آمُت یوس صفرٕ کھوتہٕ ہیو شروع گژھان۔ توہیہٕ سُند کٲم چھُ یہٕ پتہ لگاون کہ اگر کنہٕ وقتہٕ کھاتہٕ ہند بیلنس صفرٕ کھوتہٕ کم چُھ گژھان تہٕ اتھ وقتس پیٹھ گژھہٕ فنکشن درست واپس گژھُن۔ بصورت دیگر یہٕ گژھہٕ غلط واپس گژھُن۔ >>> below_zero((std::vector<long>({long) 1، (long) 2، (long) 3}))) (false) >>> below_zero(std::vector<long>({long) 1، (long) 2، (long) 4، (long) 5}))) (true)\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ان پٹ نمبرن ہندِس اکس ویکٹرٕ خٲطرٕہ، ایم ڈی اے ڈی ایس ڈی ایم چُھ ڈیٹاسیٹ کہِ اوسط کہِ ارد گرد اوسطُک حساب لگاونہٕ یوان۔ ایم ڈی اے ڈی چُھ ہر عنصر تہٕ مرکز کہِ نقطہ کہِ درمیان اوسط مطلق فرق (یمہِ صورتہِ منز اوسط): ایم اے ڈی = اوسط ۔ ایکس - ایکس_میئن ۔ >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ان پٹ ویکٹر کہ ہر دو مسلسل عناصرن درمیان چُھ اکھ نمبر 'ڈیلی میٹر' داخل یوان کرنہٕ۔ `numbers' >>> intersperse{}{}{}{}{}}{}}{}}{}{}{}{}}{}{}{}{}{}{}{}}{}{}{}{}}{}{}}{}{}}{}{}{}}{}{}}{}{}{}{}{}{}{}{}{}}{}{}}{}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}{}}{}}{}{}{}}{}{}}{}}{}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}}{}}{}}{}}}{}}}{}}}{}}}{}}}{}}}{}}}}{}}}{}}}}{}}}{}}}}{}}}}{}}}}}{}}}{}}}}{}}}}}{}}}}{}}}}}{}}}}}}{}}}}}}{}}}}}{}}}}}{}}}}}}{}}}}}}{}}}}{}}}}}}}}{}}}}}{}}}}}}}{}}}}}}}}}}{}}}}}}}}}{}}}}}}}{}}}}}}}}{}}}}}}}}}{}}}}}}}}{}}}}}}}}{}}}}}}}}}}}{}}}}}}}}}}{}}}}}}}}}}}}}{}}}}}}}}}}}{}}}}\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ اکھ سٹرنگ یس نیسٹڈ پیرنٹس خٲطرٕ چِھ واریاہ گروپن ہنز نمائندگی کران یُس اسپیسس سۭتۍ الگ چُھ گژھان۔ گروپ کس ہر اکہٕ خٲطرٕ، پیرنٹسچ نیسٹنگچ گہری سطح چُھ آؤٹ پٹ کران۔ مثلن (())) چِھ زیادہ کھوتہٕ زیادٕ دوٛن نیسٹنگ لیولن ہنز ضرورت ییلہٕ زن ((())) چِھ تریہ۔ >>> parse_nested_parens((\"((()) ((())) () ((()))))))) (std::vector<long>({(long) 2، (long) 3، (long) 1، (long) 3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صرف ان پٹ ویکٹر فلٹر کرٕن سٹرنگن خٲطرٕہ یوس دِنہٕ آمُت ذیلی تار چُھ آسان >>> filter_by_substring(((std::vector<std::string>() ، (\"a\")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"}) ، (\"a\") (std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرزن ہندس اکس ویکٹرس خٲطرٕ، اکھ ٹپل یُس اکس ویکٹرس منٛز موجود تمام انٹیجرن ہند مجموعہ تہٕ ضربس پیٹھ مشتمل چُھ واپس کران۔ خٲلی مجموعہ گژھہِ 0 برابر آسن تہٕ خٲلی ضرب گژھہِ 1 برابر آسن۔ >>> sum_product((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرزن ہند دیتٕج ویکٹرٕ پیٹھہٕ، ترتیبس منز دِنہٕ آمتِس لمحس تام چُھ ملن وول میکسِم عنصرُک ویکٹرٕ جِنریٹ کٔرِتھ۔ >>> rolling_max(((std::vector<long>({long) 1، (long) 2، (long) 3، (long) 2، (long) 3، (long) 4، (long) 2}))) (std::vector<long>({long) 1، (long) 2، (long) 3، (long) 3، (long) 3، (long) 4، (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ساروی کھوتہٕ مختصر پالینڈوم تلاش کرُن یُس سپلائی کرنہٕ آمت سٹرنگہٕ سۭتۍ شروع چُھ گژھان۔ الگورتھم خیال چُھ آسان: - سپلائی کرنہٕ آمت سٹرنگک ساروی کھوتہٕ زیوٹھ پوسٹ فکس تلاش کرُن یُس اکھ پالینڈوم چُھ۔ - سٹرنگ کس اختتامس پیٹھ سٹرنگ پریفیکسک ریورس جوڑُن یُس پالینڈومک سرفیس برونٹھ چُھ یوان۔ >>> make_palindrome((\"\")) (\"\") >>> make_palindrome((\"cat\")) (\"catac\") >>> make_palindrome((\"cata\")) (\"catac\")\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ان پٹ چِھ زٕ تار a تہٕ b یِم صرف 1s تہٕ 0s پیٹھ مشتمل چِھ۔ یمن ان پٹسن پیٹھ چُھ بائنری XOR کٔرِتھ نتیجہٕ چُھ سٹرنگ کِس طورس پیٹھ تہٕ واپس کران۔ >>> string_xor((\"010\"), (\"110\")) (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سٹرنگس ہندس ویکٹرس منزہ، چُھ ساروی کھوتہٕ زیوٹھ واپس کران۔ ایکِس ہی لمبٲئی ہند متعدد سٹرنگس ہندِس صورتس منز چُھ گوڈنُک واپس کران۔ ان پٹ ویکٹر چُھ خٲلی آسنہٕ کہِ صورتس منز چُھ واپس نِنہٕ یوان۔ >>> longest((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) \"a\" >>> longest(((std::vector<std::string>({(std::string) \"a\", (std::string) \"bb\", (stdstring) \"ccc\"}))) \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دوٛن عددن a تہٕ b یُس >>> greatest_common_divisor((3) ، (5)) (1) >>> greatest_common_divisor((25) ، (15)) (5) سٕتۍ چُھ بڑُھ مشترک تقسیم کار واپس کران۔\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ان پٹ سٹرنگ >>> all_prefixes((\"abc\") پیٹھہٕ ساروی کھوتہٕ مختصر پیٹھہٕ زیوٹھس تام تمام پریفیکسزک واپسی ویکٹر) (std::vector<std::string>({(std::string) \"a\", (std::string) \"ab\", (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سٹرنگ چُھ اکھ سٹرنگ رٹان یتھ منز 0 پیٹھہٕ n تام جاۓ سٕتۍ محدود نمبر چِھ شروع گژھان۔ >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ سٹرنگ دیتھ، ژھانٛڈو کیت تام الگ الگ کرل وٲلۍ حروف (کیس سٕتۍ قطع نظر) یہٕ چُھ >>> count_distinct_characters((\"xyzXYZ\")) (3) >>> count_distinct_characters((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ اکھ سٹرنگ یوس میوزک نوٹس چُھ ASCII فارمیٹس منز ظٲہر کران۔ توہیہ چُھ سٹرنگ ویکٹر ہند تجزیہ کرن یتھ منز انٹیجر چِھ آسان یم وارہٕن بیٹسس سٕتۍ چِھ مطابقت تھاوان۔ یہٕ چُھ اکھ لیجنڈ: 'o' نوٹ، آخری بیٹس 'o 112' - آخری نصف نوٹ، آخری دو بیٹس 'o 112' - آخری کوارٹر نوٹ، آخری ایکہِ بیٹس >>> parse_music.\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ ژھانٛڈِو زِ اصل سٹرنگس منز کِتھہٕ کٕن چُھ اکھ ذیلی سٹرنگ ملان۔ اوورلیپنگ کیسز گنزرو۔ >>> how_many_times((\"\") ، (\"a\")) (0) >>> how_many_times(\"aaa\"), (\"a\") (3) >>> how_many_times(\"aaaa\"), (\"aa\") (3)\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ان پٹ چُھ 'صفر' پیٹھہٕ 'نوے' تام عددن ہند اکھ جاۓ ہند محدود تار۔ درست انتخاب چِھ 'صفر'، 'اکھ'، 'دو'، 'تین'، 'ژور'، 'پانچ'، 'چھ'، 'سات'، 'آٹھ' تہٕ 'نِژھ'۔ نمبرن سٕتۍ سٹرنگ چُھ لوکٹہٕ پیٹھہٕ بڑس تام ترتیب دِنہٕ یوان >>> sort_numbers((\"تین اکھ پانژھ\")) (\"اکھ تریہ پانژھ\")\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اعدادن ہندس فراہم کردہ ویکٹرٕ (مطول کم از کم زٕ) پیٹھہٕ دو منتخب تہٕ دو واپس یُس اکس بیکس قریب چُھ تہٕ تہٕ یمن ترتیبس منٛز واپس ییہٕ کرنہٕ (ننہٕ نمبر، بڑ نمبر) ۔ >>> find_closest_elements{std::vector<float>{(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.2f}))) (std::make_tuple{std::vector<float>{std::float}1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اعدادن ہندس اکس ویکٹرس (کم از کم زٕ عناصرن) دنہٕ آمت، اتھ ویکٹرس پیٹھ چُھ اکھ لکیری تبدیلی لاگو کرنہٕ یوان، یتھ پٲنٹھ ساروی کھوتہٕ لوکٹ نمبر گژھ 0 تہٕ ساری کھوتہٕ بڑ نمبر گژھ 1 >>> rescale_to_unit{(std::vector<float>{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) (std::vector<float>{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فلٹر دیتُن cppthon ویلیو صرف انٹیجرز خٲطرٕ >>> filter_integers((std::vector<std::any>({(std::string) \"a\", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::<long,map>), std::vector<long>((}))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دِنہٕ آمت سٹرنگچ لمبائی واپس کرنہٕ >>> string_length((\"\")) (0) >>> string_length((\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دِنہٕ آمتِس نمبرس n خاطرٕ، ساروی کھوتہٕ بوٕڑ نمبر تلاش کرو یوس n یکساں طور پأنٹھ تقسیم چُھ کران، n کھوتہٕ لوکٹ >>> largest_divisor ({} ({15)) (5)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دِنہٕ آمت انٹیجرُک پرائم فیکٹرُک ریٹرن ویکٹر چُھ ساروی کھوتہٕ لوکٹھ پیٹھہٕ بڑس ترتیبس منز۔ فیکٹرُک پرتھ اکھ نمبر گژھہِ فیکٹرِزِشنس منز کُنہِ وٕہتھہِ وقتُک نمبر گژھہِ برابر آسن۔ ان پٹ نمبر گژھہِ تمام فیکٹرُک پروڈکٹُک برابر آسن >>> فیکٹرِزِٹ کریں ((8)) (std::vector<long> ({(long) 2، (long) 2، (long) 2}) >>> فیکٹرِزِٹ کریں ((25)) (std::vector<long> ({(long) 5، (long) 5}) >>> فیکٹرِزِٹ کریں (((70)) (std::vector<long> ({(long) 2، (long) 5، (long) 7}))\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرز ہندس ویکٹرٕ پیٹھہٕ، تمام عناصر یوس ایکہِ کھوتہٕ زیادٕہ لٹہِ پیدہ گژھان چُھ ہٹٲوِو۔ عناصرن ہند ترتیب چُھ ہاوان یتھے پٲٹھۍ زِ ان پٹس منز چُھ ۔ >>> remove_duplicates\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڈاٹا سٹرنگہٕ خٲطرٕ، لوکسر کیریکرن اپرکیسز تہٕ اپرکیسز لوکسرس منز پلٹٲوِو۔ >>> flip_case (((\"ہیلو\")) (\"ہیلو\")\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سٹرنگس چُھ اکھ سٹرنگس منز کنکیٹنٹ ویکٹر بناوان >>> کنکیٹنٹ(((std::vector<std::string>())) (\"\") >>> کنکیٹنٹ(((std::vector<std::string>({(std::string) \"a\"، (std::string) \"b\"، (std::string) \"c\"}))) (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صرف ان پٹ ویکٹر فلٹر کرُن یمو سٹرنگن صرف تمن ویکٹرن خٲطرٕہ چُھ یُس کُنہِ دِنہٕ آمٕژِ پریفیکسس سٕتۍ شروع چُھ گژھان۔ >>> filter_by_prefix((std::vector<std::string>() ، (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string) \"cde\", (stdstring) \"array\"}) ، (\"a\") (std::vector<std::string>(({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صرف مثبت نمبر چِھ ویکٹرس منٛز واپس کران۔ >>> get_positive((std::vector<long>({long) - 1، (long) 2، (long) - 4، (long) 5، (long) 6}))) (std::vector<long>({long) 2، (long) 5، (long) 6})) >>> get_positive((std::vector<long>({long) 5، (long) 3، (long) 5، (long) 5، (long) 2، (long) 3، (long) 9، (long) 0، (long) 123، (long) 1، (long) 10}))) (std::vector<long>{(long) 5، (long) 3، (long) 2، (long) 3، (long) 9، (long) 12، (long) 13، (long) 1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اگر اکھ دِنہٕ آمت نمبر پرائم چُھ تیلہٕ چُھ صحیح واپس یوان، تہٕ بییہٕ غلط۔ >>> is_prime((6)) (غلط) >>> is_prime((101)) (سچ) >>> is_prime((11) (سچ) >>> is_prime((13441)) (سچ) >>> is_prime(61)) (سچ) >>> is_prime(4) (غلط) >>> is_prime(1) (غلط)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ اکھ ویکٹر l نوان تہٕ چُھ اکھ ویکٹر l' واپس کران یتھ کٔن زَن l' چُھ یمن انڈیکسن منٛز l سٕتۍ مماثل آسان یم ترین سۭتۍ تقسیم گژھن چِھ نہٕ آسان، ییلہِ زَن کہ یمن انڈیکسن پیٹھ یم ترین سۭتۍ تقسیم گژھن چِھ تمن ہند ویلیو چِھ l کہ متعلقہٕ انڈیکسن ہند ویلیو برابر آسان، مگر ترتیب چِھ دنہٕ یوان۔ >>> sort_third: vector<long>{(long>1, (long) 2, (long) 3}))) (std: vector<long>{(long>1, (long) 2, (long) 3})) >>> sort_third: vector<long>{(long>5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std: vector<(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long 5})\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ایکِس ویکٹرس منز چُھ ترتیب شدہ منفرد عناصر واپس کران >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) (std::vector<long>{(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ویکٹرس منٛز زیادٕ کھوتہٕ زیادٕ عنصر واپس کران۔ >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ چُھ 7 ہندسہٕ ہند تعداد واپس کران یُس n کھوتہٕ کم عددن منٛز چُھ ظاہر گژھان یم 11 یا 13 سۭتۍ تقسیم گژھہٕ۔ >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ اکھ ویکٹر l نوان تہٕ چُھ اکھ ویکٹر l' واپس کران یتھکن زِ odd انڈیکسس منٛز چُھ l' ییتھ کیٛن زِ even انڈیکسس منٛز چِھ امچ قدر l کہ برابر، مگر ترتیب چُھ آمُت دینہٕ۔ >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<(long>{(long) 3, (long) 6, (long) 5, (long) 4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib چُھ نٔمِس نمبرس واپس کران یوس اکھ فبونیکی نمبر چُھ تہٕ چُھ یہٕ تہٕ اکھ پرائم۔ >>> prime_fib((1)) (2) >>> prime_fib(2) (3) >>> prime_fib(3)) (5) >>> prime_fib(4)) (13) >>> prime_fib(5)) (89)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero چُھ ان پٹ کِس طورس پیٹھ انٹیجرزُک ویکٹر نوان۔ یہٕ چُھ صحیح واپس کران اگر ویکٹرس منز چِھ ترے الگ الگ عناصر یم صفرس تام جمع چِھ گژھان، تہٕ بصورت دیگر غلط۔ >>> triples_sum_to_zero(std::vector<long>(long) 1، (long) 3، (long) 5، (long) 0}))) (false) >>> triples_sum_to_zero(std::vector<long>(long) 1، (long) 3، (long) 2، (long) 1} (true) >>> triples_sum_to_zero(std::vector<long>(long) 1، (long) 2، (long) 3، (long) 7}))) (se) >>> triples_sum_to_zero(std::vector<long> (long) 2، (long) 4، (long) 5، (long) 3، (long) 9، (long) 7))) (true) >>> triples_sum_to_long))) (long_vector) >>>\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ سڑک تصور کرو یس اکھ بالکل سیدھی لامحدود زیچھر چِھ۔ n کار چِھ بائیں پیٹھہٕ دائیں گژھان۔ بیک وقت، n کارن ہند اکھ مختلف سیٹ چِھ دائیں پیٹھہٕ بائیں گژھان۔ کارن ہندۍ زٕ سیٹہٕ چِھ اکس بییس نش واریاہ دور آسان۔ تمام کارہٕ چِھ ایکسی رفتارس پیٹھ حرکت کران۔ زٕ کارہٕ چِھ ٹکراوان ییلہِ اکھ کار چِھ بائیں پیٹھہٕ دائیں طرفہٕ حرکت کران تہٕ چِھ اکھ کارس ٹکران یُس دائیں پیٹھہٕ بائیں طرفہٕ حرکت چِھ کران۔ تاہم، کارہٕ چِھ لامحدود مضبوط تہٕ مضبوط۔ نتیجس منٛز، چِھ تم پننہٕ رفتارس منٛز حرکت کران گویا تم چِھنہٕ ٹکراوان۔ یہٕ فنکشن چُھ یتھ ٹکراون ہنٛز تعداد ظٲہر کران۔\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// عناصرن سۭتۍ چُھ 1 سۭتۍ اضافہٕ گژھن وٲل ویکٹر واپس گژھان۔ >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>({long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>({long) 5, (long) 3, (long) 5, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>({long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جوڑ_سَم_تَن_صفر چُھ اَکہِ انٹیجر ویکٹرٕچ ان پٹ کِس طورس پیٹھ نوان۔ یہٕ چُھ صیح واپس کران اگر ویکٹرس منز چِھ زٕ الگ الگ عناصر یم صفرس سٕتۍ چِھ ملان، تہٕ بییہٕ غلط۔ >>> جوڑ_سَم_تَن_صفر چِھ\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ان پٹ نمبر x ہٕنٛز عددی بنیاد چُھ بیسسس منٛز تبدیل کران۔ تبدیل کرنہٕ پتہٕ چُھ سٹرنگ ریٚپرایزیشن واپس کران۔ بیسٕکۍ نمبر چھِ 10 کھۄتہٕ کم۔ >>> change_base((8), (3)) (\"22\") >>> change_base(8), (2)) (\"1000\") >>> change_base(7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثلث خاطرٕ اکھ طرفچ لمبائی تہٕ زیادٕ واپسی ہنٛد علاقہٕ دنہٕ آمت۔ >>> مثلث_علاقہٕ ({} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } } ، { } } ، { } } ، { } ، { } } } ، { } } ، { } } } ، { } } } ، { } } } ، { } } } } ، { } } } } } } ، { { { } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فبونیکی نمبر سیکوینس چِھ فبونیکی سیکوینس ہیوۍ اکھ سیکوینس یمک تعریف چِھ یتھہ پاٹھۍ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). براہ کرم fib4 نمبر سیکوینس ہند n-th عنصر موثر اندازس منز شمار کرنہٕ خٲطرٕہ اکھ فنکشن لیوکھو۔ ریکوریشن استعمال مت کٔرِتھ۔ >>> fib4((5)) (4) >>> fib4(6) (8) >>>4((7)) (14)\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ویکٹر l منٛز عناصرن ہٕنٛز میڈین واپس کرنہٕ آمٕژ۔ >>> میڈین (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ چُھ جانچ کران زِ کیا یہٕ ڈگری چِھ اکھ پالنڈروم >>> is_palindrome((\"\")) (true) >>> is_palindrome((\"aba\")) (true) >>> is_palindrome((\"aaaaa\")) (true) >>> is_palindrome((\"zbcd\")) (false)\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ریٹرن 2 ^ n ماڈیولو p (نمبرس سٕتۍ آگاہ گژھُن) ۔ >>> modp(((3) ، (5)) (3) >>> modp((1101) ، (101)) (2) >>> modp((0) ، (101)) (1) >>> modp((3), (11)) (8) >>> modp((100) ، (101) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels چُھ اکھ فنکشن یُس سٹرنگ چُھ نوان تہٕ وولن وراۓ سٹرنگ چُھ واپس کران۔ >>> remove_vowels((\"\")) (\"\") >>> remove_vowels((\"abcdef\")) (\"bcdf\") >>> remove_vowels((\"aaaaa\")) (\"\") >>> remove_vowels(\"aaBAA\")) (\"B\") >>> remove_vowels((\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ریٹرن true اگر ویکٹر l منٛز چھ تمام نمبر دہلیز t کھوتہٕ کم۔ >>> below_threshold((std::vector<long>({(long) 1، (long) 2، (long) 4، (long) 10}) ، (100)) (true) >>> below_threshold((std::vector<long>({(long) 1، (long) 20، (long) 4، (long) 10}) ، (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// زٕ عدد x تہٕ y چِھ جمع کرنہٕ یوان، تہٕ چُھ جمع کرنہٕ یوان (2) ، (3)) (5) ، تہٕ چُھ جمع کرنہٕ یوان (5) ، (7) ، (12)\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چیک کرو اگر زٕ لفظن منٛز چھِ اَکیٛن حروفن ہنٛد۔ >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) (true) >>> same_chars((\"abcd\"), (\"dddddddabc\")) (true) >>> same_chars(\"dddddddabc\"), (\"abcd\") (true) >>> same_chars((\"eabcd\"), (\"dddddddabc\")) (false) same_chars >>>\"((abcd\"), (\"dddddddddabce\") (false) >>> same_chars((\"eabcd\"), (\"ddddzzzzzdzzdddabc\") (false)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// واپس n-th فبونیکی نمبر۔ >>> فبونیکی نمبر 10 (فبونیکی نمبر 10) (55) >>> فبونیکی نمبر 1 (فبونیکی نمبر 1) (1) >>> فبونیکی نمبر 8 (فبونیکی نمبر 21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets چُھ \"<\" تہٕ \">\" ہند اکھ سٹرنگ۔ اگر پرتھ اوپننگ بریکٹس منز چُھ اکھ مُطابقہ بند کرن وول بریکٹ تہٕ تیلہٕ چُھ ریٹرن true۔ >>> correct_bracketing((\"<\")) (false) >>> correct_bracketing(\"<>\")) (true) >>> correct_bracketing(\"<><>\")) (true) >>> correct_bracketing(\">(<>\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ریٹرن ٹرٛو چھ ویکٹر ایلیمنٹن ہنٛد مونٹونک پانٹھ بڑھان یا کم گژھن۔ >>> monotonic(((std::vector<long>({(long) 1، (long) 2، (long) 4، (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1، (long) 20، (long) 4، (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4، (long) 1، (long) 0، (long) 10}))) (true)\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دوٛن ویکٹرن خٲطرٕ چھ ترتیب شدٕ منفرد مشترکہ عناصر واپس کران۔ >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}) ، (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long>{long}2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// n ہٕنٛدس بڑس پرائم فاکٹرس واپس ییہٕ دنہٕ۔ فرض کرو n > 1 تہٕ یہ چھ نہٕ پرائم۔ >>> largest_prime_factor((13195)) (29) >>> largest_prime_factor((2048) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n چُھ اکھ فنکشن یُس 1 پیٹھ n تام نمبرن ہنز جَمح چُھ کران۔ >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets چُھ \"1\" تہٕ \"3\" ہند اکھ سٹرنگ۔) اگر پرتھ اوپننگ بریکٹس منز چُھ اکھ مُطابقہ بند کرن وول بریکٹ تہٕ تیلہٕ چُھ ریٹرن true۔ >>> correct_bracketing \"2\" (جھوٹ) >>> correct_bracketing \"4\" (جھوٹ) (سچ) >>> correct_bracketing \"4\" (جھوٹ)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs چُھ کثیر الثانیس ہند کوفیسنٹ۔ xs[0] + xs[1] * x + xs[2] * x^2 + .... اتھ کثیر الثانیس ہند ماخوذ واپس کرن یژھی شکلہِ منز۔ >>> derivative((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> derivative::std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فبوفب نمبر سیکوینس چِھ فبوبونکی سیکوینس ہیوۍ اکھ سیکوینس یمیچ تعریف ییتھ کیٛن چِھ کرنہٕ آمژ: فبوفب (۰) == 0 فبوفب (۱) == 0 فبوفب (۲) == 1 فبوفب (ن) == فبوفب (ن - ۱) + فبوفب (ن - ۲) + فبوفب (ن - ۳) براہ کرم اکھ فنکشن لیوکھو تاکہ فبوفب نمبر سیکوینس ہند n-th عنصر موثر اندازس منٛز شمار کرنہٕ ییہٕ۔ >>> فبوفب (ن - ۱) (0) >>> فبوفب (ن - ۵) (4) >>> فبوفب (ن - ۸) (24)\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لکھو vowels_count یُس اکھ لفظچ نمائندگی کرن وول سٹرنگ ان پٹ کہ طور پأنٹھ چُھ نیوان تہٕ سٹرنگس منٛز وولن ہنٛد تعداد چُھ واپس کران۔ اتھ صورتس منٛز وول چِھ 'a'، 'e'، 'i'، 'o'، 'u'۔ ییتہٕ چُھ 'y' تییہٕ اکھ وول، مگر صرف ییلہٕ یہٕ دِنہٕ آمت لفظ کس آخرس منٛز چُھ۔ مثال: >>> vowels_count (((\"abcde\")) (2) >>> vowels_count ((\"ACEDY\") (3)\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجر x ہند ہندسہٕ سرکلر شیپ کرُن، ہندسہٕ دٲیچ شفٹ کرُن تہٕ نتیجہٕ سٹرنگ کہِ طورس پیٹھ واپس کرُن۔ اگر شفٹ > ہندسن ہند تعداد، تو واپس ہندسہٕ الٹہٕ کرُن۔ >>> circular_shift((12), (1)) (\"21\") >>> circular_shift((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٹاسک اکھ فنکشن لیوکھن یوس ان پٹ کہِ طورس پیٹھ چُھ اکھ سٹرنگ نوان تہٕ چُھ صرف بالٲئی حروفن ہند مجموعہ ASCII کوڈس منز واپس کران۔ مثال: >>> digitSum((\"\")) (0) >>> digitSum((\"abAB\")) (131) >>> digitSum((\"abcCd\")) (67) >>> digitSum((\"helloE\")) (69) >>> digitSum((\"woArBld\")) (131) >>> digitSum((\"aAXaaaa\") (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اتھ کامہِ منز، چھےٚ توٚہۍ سٕنٛدس اکس سٹرینٛگس سۭتۍ اکھ عدد وٕچھنہٕ یوان یس اپیل تہٕ نارنجٕچ تعداد چھےٚ ہاونہٕ یوان یم میون ہٕنٛزِ ٹوکری منٛز تقسیم کرنہٕ آمژٕ چھےٚ۔ اتھ ٹوکری منٛز چھِ اپیل، نارنج تہٕ مانگو میون شٲمل۔ سٹرنگس سۭتۍ یس نارنجٕچ تہٕ اپیلٕچ مجموعی تعداد تہٕ اکھ عدد وٕچھنہٕ چھُ یس ٹوکری منٛز میون ہٕنٛز مجموعی تعداد چھِ ہاونہٕ یوان، اتھ سٹرنگس سۭتۍ چھِ ٹوکری منٛز موجود مانگو میون ہٕنٛز تعداد واپس کرنہٕ یوان۔ مثال: >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"اگر اکھ ویکٹر چُھ اکس کُلۍ کِس شاخس ہنز نمائندگی کران یتھ منز غٲر منفی عدد نود چِھ آسان تہٕ توہیہٕ سُند کٲم چُھ یہٕ زِ کنہٕ نوڈس پُھٹرو تہٕ بییہٕ بییہٕ لٲوِو۔ پُھٹرن وول گژھہٕ سُہ نوڈ آسن یتھ منز ساروی کھوتہٕ لوکٹ even ویلیو چُھ۔ اگر اکسی لٲٹہٕ even ویلیو ہند متعدد نوڈ چِھ ملان تہٕ بییہٕ کرِو نوڈس واپس یتھ منز ساروی کھوتہٕ لوکٹ انڈیکس چُھ۔ پُھٹرن وول گژھہٕ بییہٕ وول ویلیو واپس ویکٹرس منز، [smallest_value، its index]، اگر نہٕ کنہِ even ویلیو چُھ نہٕ یا یہٕ وول ویکٹر چُھ خٲلی، تہٕ بییہٕ بییہٕ کرِو []۔ مثال 1: >>> pluck{((((stdvector<long>{long}{long}4, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long) (long (long)\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھیہ مثبت عددن ہند اکھ غٲر خالی ویکٹر۔ زیرو کھوتہ بوڑ عدد واپس کرو، تہ امچ فریکوئنسی چھہ پورہ عددس برابر یا اسہِ کھوتہ زیوٹھ۔ پورہ عددچ فریکوئنسی چھہ ویکٹرس منز ظٲہر گژھن وٲلۍ وۅنۍ تعداد۔ اگر نہ یتھ ویلیو موجود آسہِ، تہ واپس کرو -1. مثال: >>> search(((std::vector<long>{(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search(std::vector<(long>{(long) 1, (long) 2, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>>(std::vector<(long>{(long) 5, (long) 5, (long) 4, (long) 4, (long) 4-1} (long)))\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرز ہند ویکٹر دنہٕ آمت، عجیب ترتیب سۭتۍ چُھ ویکٹر واپس یوان۔ عجیب ترتیب، چُھ ییلہِ تہٕ کم کھوتہٕ کم قدر سۭتۍ شروع گژھِ، تہٕ پتہٕ بقیہ انٹیجرن ہنٛد زیادٕ کھوتہٕ زیادٕ، تہٕ پتہٕ کم کھوتہٕ کم تہٕ بییہٕ۔ مثالہٕ: >>> strange_sort_list{((((std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<(((std::vector<long>{(long) 5, (long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<(((((std::vector<(long)) (std::vector))\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثلث کہ ترٛیٚو طرفو ہٕنٛز لمبٲیی دنہٕ آمژ۔ مثلث کس رقبس چھ 2 اعشاریہ پوائنٹس تام پھیرنہٕ ییلہ ترٛیٚو طرفو اکھ درست مثلث بناوان چھ۔ بصورت دیگر -1 واپس ییٚلہ ترٛیٚو طرفو ہنٛد مجموعہ ترٛیٚیمہٕ طرفہ کھۄتہٕ زیٛادٕ آسہ، تہٕ سہارٕ طرفہٕ چھ درست مثلث بناوان۔ مثال: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھمُت یُس صحیح چُھ واپس کران اگر آبجیکٹ q اڑان چُھ، تہٕ غلط بیترِ۔ آبجیکٹ q اڑان چُھ اگر یہٕ متوازن چُھ (یہٕ چُھ اکھ پالنڈرومک ویکٹر) تہٕ امہٕ کیٛن عناصرن ہنٛد مجموعہ چُھ زیادٕ کھوتہٕ کم یا برابر زیادٕ کھوتہٕ زیادٕ ممکنہ وزن w۔ مثال: >>> will_it_fly((std::vector<long>(long>{long>{long>{long}}1, (long>{long}2}) ، (5)) (false) # 1+2 چُھ زیادٕ کھوتہٕ کم ممکنہ وزن، مگر یہٕ چُھ متوازن۔ >>> will_it_fly{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرزن ہندس اکس ویکٹرس arr دنہٕ آمت، ویکٹرس پالینڈروم بناونہٕ خاطرٕ کم کھوتہٕ کم عناصرن ہنٛز تعداد تلاش کرُن۔ اکھ پالینڈروم ویکٹر چُھ اکھ ویکٹر یُس پٔتمیو پیٹھہٕ برونٹھ چُھ یوان وُچھنہٕ۔ اکہٕ تبدیلی منٛز، ہیٛکو اکھ عنصر دیمس عنصرس منٛز تبدیل کرتھ۔ مثلن: >>> smallest_change(std::vector<long>({long) 1، (long) 2، (long) 3، (long) 5، (long) 4، (long) 7، (long) 9، (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1، (long) 2، (long) 3، (long) 2، (long) 2} (1) >>> smallest_change(std::vector<long>{(long) 1، (long) 2، (long) 3، (long) 2، (long) 1)))\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھ یتھ ز سٹرنگک زٕ ویکٹر چِھ قبول کران تہٕ چُھ سٹرنگک سٹرنگس منٛز کیٛن ویکٹرن ہنٛد کل تعدادس دیمس ویکٹر کھوتہٕ کم واپس کران۔ اگر زٕ ویکٹرن منٛز کیٛن ویکٹرن ہنٛد کل تعداد آسہٕ کم، تیلہٕ گوڑنک ویکٹر چُھ واپس کران۔ مثالہٕ >>> total_match ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}، ({\"}) ، ({\"}) ، ({\"}) ، ({\"}) ، ({\"}) ، ({\"}) ،\" ({\"}) ،\" ({\"}) ({\"}) ({\"}) ({\"}) ،\" ({\"} ({\"}) (}) ({\"}) ({\"}) (}) ({\"}) ({\"}) (}) ({\" (}) ({\" (}) (}) ({\" (}) (}) ({\" (}) (}) ({\" (}) ({\" (}) (}) (}) ({\" (}) (}) ({\" (}) (}) (}) ({\" (}) (}) (}) ({\" (}) (}) ({\" (}) (}) (} (}) (}) (} (}) ({\" (}) (}) (} (}) (}) ({\" (}) (} (}) (}) (} (}) (\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھو یُس صحیح چُھ واپس کران اگر دِنہٕ آمُت نمبر چُھ 3 پرائم نمبرن ہند ضرب تہٕ بییہٕ غلط۔ یہ زانُن کہ (a) چُھ 100 کھوتہٕ کم۔ مثال: >>> is_multiply_prime((30)) (سچ) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہُند کٲم چھُ اکھ فنکشن لیکھُن یُس ٹُرٛیُن لٲگِتھ چھُ اگر کانٛہہ نمبر x چھُ n کِس سادٕس پوٗرٹس منز تہٕ بیٚین صورتن منٛز چھُ جھوٚٹ۔ x چھُ n کِس سادٕس پوٗرٹس منز اگر n**int=x مثالہٕ پٲٹھۍ: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھن یوس اکھ انٹیجر a چُھ نوان تہٕ اگر یہٕ انٹیجر کنٛہہ انٹیجر نمبرُک کیوب چُھ تیلہٕ چُھ صحیح واپس کران۔ نوٹ: توہیہ ہیکہِ یہٕ فرض کرِتھ زِ ان پٹ چُھ ہمیشہٕ درست۔ مثال: >>> iscube((1)) (true) >>> iscube(2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180)) (false)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھیہ اکھ فنکشن لیکھنک کٲم آمت کرنہ یتھ ہیکساڈسیمل نمبر چھ سٹرنگہِ پٲٹھۍ وصول کران تہٕ ہیکساڈسیمل ہندسن ہند تعداد چھ گنتی کران یم پرائم چھ (پرائم نمبر، یا پرائم، چھ اکھ قدرتی نمبر یس 1 کھوتہٕ زیادٕ چھ یس زٕ لکٕٹۍ قدرتی نمبرن ہند پروڈکٹ چُھ نہٕ) ۔ ہیکساڈسیمل ہندسہٕ چھ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F۔ پرائم نمبر چھ 2, 3, 5, 7, 11, 13, 17،...۔ توہیہ چھیہ درج ذیل ہندسن ہند اکھ تعداد مقرر کرن: 2, 3, 5, 7, B (=ڈیسیمل 11), D (=ڈیسیمل 13) ۔ نوٹ: توہیہ ہیکو یہٕ فرض کٔرتھ زِ ان پٹ چُھ ہمیشہ صحیح یا خالی سٹرنگ، تہٕ علامت A،B،C،D،E،F چِھ ہمیشہ اپر لیٹر۔ مثالہ: >>> hex_((AB\"کی\") >>> hex_{1} hex_{2}{10}{10{10}{10}{10}{7}{2}{2}{2}{2}{3}{3}{3}3{3}3{3}3{4}3{}3{}3{3}3{}3}3{}3{}4}3{}3{}3{}3{}3}3{}3}3{}4}3{}3{}3{}3}3{}3{}3}3{}4}3{}3}3}3{}3{}3{}3}3}3{}4}3{}3}3}3{}3{}3}3{}3}3}3{}3}3{}3}4}3{}3}3}3{}3}3{}3}3}3{}3{}3}3}3{}3}4}3{}3}3}3{}3}3}3{}3}3}3{}3}3}3{}3\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چِھ اکھ اعشاریہ شکلہٕ منٛز اکھ نمبر دنہٕ یوان تہٕ توہیہٕ ہنٛد کٲم چِھ یہٕ بائنری شکلہٕ منٛز تبدیل کرن۔ فنکشن گژھہٕ اکھ سٹرنگ واپس ین، یتھ منٛز پرتھ کردارس سۭتۍ چُھ اکھ بائنری نمبرچ نمائندگی کران۔ سٹرنگس منٛز پرتھ کردار گژھہٕ '0' یا '1' آسن۔ سٹرنگ کس شروعس تہٕ اختتامس پیٹھ گژھہٕ 'db' ہنٛد اکھ اضأفی جوڑٕ حروف آسن۔ اضأفی حروف چِھ فارمیٹس منٛز مدد کرنہٕ خاطرٕ موجود۔ مثالہٕ: >>> decimal_to_binary((15)) (\"db1111db\") >>> decimal_to_binary(32) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھیہ اکھ سٹرنگ دیتمت۔ توہیہ چھوہ یہ چیک کرن کہ سٹرنگ چھا hapcpp یا نہ۔ اکھ سٹرنگ چھا hapcpp اگر امچ لمبائی کم از کم 3 تہ پرتھ 3 ترتیب وار حروف چھہِ الگ الگ۔ مثال: >>> is_happy((\"a\")) (false) >>> is_happy((\"aa\")) (false) >>> is_happy((\"abcd\")) (true) >>> is_happy((\"aabb\")) (false) >>> is_happy(\"adb\")) (true) >>> is_happy((\"xyy\") (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہ چھ سمسٹرُک ٲخری ہفتہٕ تہٕ اساتذہ چھ طلباءن گریڈ دوان۔ اساتذہ چھ گریڈنگ خٲطرٕ پنن الگورتھم بناوان۔ صرف اکھ مسئلہ چھ یہ زِ سُہ چھ گریڈنگ خٲطرٕ استعمال گژھن وٲل کوڈ کھوژان۔ سُہ چھ توہیہ کینژن طلباءن خٲطرٕ GPAs ہٕنٛدس ویکٹرس دتمت تہ تہٕ توہیہ چھ اکھ فنکشن لیکھان یس لیٹر گریڈس ہٕنٛدس ویکٹرس پٮ۪ٹھ استعمال کران چھ یتھ ٹیبلہٕ استعمال کران: GPA لیٹر گریڈ 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E مثال: >>>_grade_equation\"\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھمُت یُس سٹرنگ چُھ نوان تہٕ اگر سٹرنگچ لمبائی چِھ پرائم نمبر یا غلط آسن تیلہٕ چُھ صحیح واپس کران۔ مثالہٕ >>> prime_length(((\"ہیلو\")) (سچ) >>> prime_length((\"abcdcba\")) (سچ) >>> prime_length((\"کیٹن\")) (سچ) >>> prime_length((\"اورنج\")) (غلط)\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ مثبت انٹیجر n دینہٕ آمت، n ہندسہٕ ہند مثبت انٹیجرن ہند تعداد یُس 1 سۭتۍ شروع یا ختم چُھ گژھان، یُس گنتی چُھ کران۔\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد N دنہٕ آمت، امہٕ کہ ہندسن ہند مجموعہ چُھ بائنری منٛز واپس کران۔ مثال >>> حل کریں((1000)) (\"1\") >>> حل کریں((150)) (\"110\") >>> حل کریں((147)) (\"1100\") متغیرات: @N انٹیجر پابندیاں: 0 ≤ N ≤ 10000. آؤٹ پٹ: بائنری نمبرن ہنٛز اکھ تار\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرزن ہند اکھ غٲر خٲلی ویکٹر دِنہٕ آمت۔ lst۔ جوڑٕ جوڑ عناصر یم عجیب انڈیکسس پیٹھ چِھ ۔ مثالہٕ: >>> add((std::vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھ یتھ سٹرنگ چُھ نیوان تہٕ امک اکھ آرڈرڈ ورژن چُھ واپس کران۔ سٹرنگک آرڈرڈ ورژن چُھ اکھ سٹرنگ ییتہٕ تمام الفاظ (جدا کرتھ) اکس نئس لفظس سۭتۍ چِھ تبدیل یوان کرنہٕ یتہٕ تمام کردار چِھ ascii ویلیو کہ بنیادس پیٹھ بڑھون ترتیبس منٛز ترتیب دینہٕ یوان۔ نوٹ: توہیہ گژھہٕ جملس منٛز الفاظ تہٕ خالی جگہوں ہینز ترتیب برقرار تھون۔ مثلن: >>> anti_shuffle((\"Hi\")) (\"Hi\") >>> anti_shuffle((\"hello\")) (\"ehllo\") >>> anti_shuffle\"(Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھِ اکھ 2 جہتی ڈیٹا، یس نیسٹڈ ویکٹرز کہ طور پٲنٹھ، میٹرکس ہشہٕ، تاہم، میٹرکس برعکس، پرتھ صفس منٛز ہیکہٕ کالمن ہینز اکھ مختلف تعداد آستھ۔ lst، تہٕ انٹیجر x دنہٕ آمت، ویکٹرس منٛز انٹیجرز x ژھانٛڈو، تہٕ ٹپلزن ہنٛد واپسی ویکٹر، [(x1, y1), (x2, y2) ...] یتھ پٲنٹھ زِ پرتھ ٹپل چُھ اکھ کوآرڈینیٹ - (صف، کالم) ، شروع گژھن وٲل 0. ابتدائی طور پٲنٹھ چُھ کوآرڈینیٹس چُھ صفن پیٹھہٕ آرڈر کران۔ نیز، کالمن ہنٛد کوآرڈینیٹس چُھ آرڈرنگس منٛز ترتیب دینہٕ یوان۔ مثالہٕ: >>> get_row(std::vector<std::vector<st><long>، تاہم، ہر صف ہیکہٕ مختلف تعدادس منٛز کالمن پیٹھ مشتمل آستھ۔ (1) ، تہٕ انٹیجر x دنہٕ آمت، تہٕ واپسی ویکٹر چھِ ٹپلزن ہنٛد ویکٹر، [(x1, y1), یتھ پٲن کہ پرتھ ٹپللن ہنٛد واپسی ویکٹر چُھ 0 سۭتۍ شروع گژھان۔\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// غیر منفی عددن ہند ویکٹر دنہٕ آمت، ترتیب دینہٕ پتہٕ دینہٕ آمت ویکٹرُک کوکی پی پی واپس کرُن، اگر رقم (پہلا انڈیکس ویلیو، آخری انڈیکس ویلیو) عجیب چُھ، تہٕ اگر رقم (پہلا انڈیکس ویلیو، آخری انڈیکس ویلیو) چُھ جڑتھ، تہٕ اگر یہٕ ترتیب ترتیب ترتیب ترتیب چُھ، تہٕ اگر یہٕ رقم (پہلا انڈیکس ویلیو، آخری انڈیکس ویلیو) چُھ ہموار، تہٕ توہیہ چِھ ترتیب دینہٕ آمت۔ نوٹ: * دیتمت ویکٹر مت بدلاون۔ مثالہٕ: >>> sort_array{d}: vector<long> ({d}: vector<long>) ({d}: vector<long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long> (long>) (long>) (long> (long>) (long>) (long> (long>) (long>) (long> (long>) (long> (long>) (long>) (long> (long>) (long> (long>) (long>long> (long>) (long>long>) (long>long> (long>) (long>long>long> (long>) (long>long>long>long> (long>) (long>long>long>long>long>long> (long>long>long>long>long>) (long>long>long>long>long>long>long>long>long>long> (<<<<<<<) (long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long (long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن انکرپٹ بناو یُس اکھ سٹرنگ بطور دلیل چُھ نیوان تہٕ اکھ سٹرنگ چُھ واپس کران یتھ منٛز الفٔبیٹ چُھ روٹ کرنہٕ یوان۔ الفٔبیٹ گژھہٕ یتھ پأٹھۍ روٹ کرنہٕ ین زِ حرف گژھن دوٛن مقاماتن پیٹھ زٕ ضرب سۭتۍ نیبَر منتقل۔ مثلن: >>> انکرپٹ (((\"hi\")) (\"lm\") >>> انکرپٹ (((\"asdfghjkl\")) (\"ewhjklnop\") >>> انکرپٹ (((\"gf\")) (\"kj\") >>> انکرپٹ (((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھہِ انٹیجرزک اکھ ویکٹر دنہ آمت۔ اکھ فنکشن لیوکھ next_smallest() یوس ویکٹرُک 2nd لۄکُٹ عنصر واپس چھُ کران۔ ییلہِ نہٕ یتھہِ کٔنۍ عنصر آسہِ واپس چھُ نٔن۔ >>> next_smallest(std::vector<long>(long) 1، 2، 3، 4، 5، 6، 7، 8، 9، 11، 12، 13، 14، 15، 16، 17، 18، 19، 19، 20، 20، 20، 20، 20، 21، 21، 22، 22، 23، 22، 23، 24، 23، 24، 25، 25، 26، 27، 28، 29، 29، 29، 29، 29، 29، 29، 30، 30، 30، 30، 30، 31، 31، 31، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 33، 32، 32، 32، 32، 32، 33، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چِھ لفظن ہند اکھ تار وون، تہٕ توہیہ چِھ ٹاسک بورڈمن ہند تعداد گنُن۔ بورڈ چُھ اکھ جملہ یوس لفظ \"I\" سٕتۍ شروع چُھ گژھان۔ جملہ چِھ '.', '?' یا '! سٕتۍ محدود۔ مثالہٕ پٲٹھۍ: >>> is_bored((\"ہیلو ورلڈ\")) (0) >>> is_bored((\"آسمان چُھ نیلا۔ آفتاب چُھ چمکان۔ میہ چُھ یتھہِ موسمس پسند کران\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ یُس 3 نمبرن نِش ہیکہِ تھٲوِتھ۔ اگر اکھ نمبر بیین دۄن ہندس مجموعس برابر آسہِ تہٕ تمام نمبر آسہِ انٹیجر۔ بیین صورتن منز چُھ غلط واپس گژھان۔ مثالہٕ >>> any_int{(float{(5)) ، (float{(2)) ، (float{(7))) (true) >>> any_int{(((float{(3)) ، (float{(2)) ، (float{(2))) (false) >>> any_int{((float{(3)) ، (float{(-2) ، (float{(1))) (true) >>> any_int{(((3.6f) ، (-2.2f) ، (float{(2))) (false)\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھُن یُس اکھ پیغام چُھ نوان، تہٕ اتھ پٮ۪ٹھ کوڈ چُھ لگٲون یتھ پٮ۪ٹھ یہ تمام حروفن ہٕندۍ کیس بدلاوان چُھ، تہٕ تمام وولن چُھ میسجس منز اتھ حروفس سٕتۍ بدلاوان یُس انگریزی الفبِیہ منز وولس برونٛہہ 2 جایہٕ چُھ آسان۔ صرف حروف چِھ فرض کران۔ مثالہٕ: >>> encode((\"test\")) (\"TGST\") >>> encode((\"یہ چُھ اکھ پیغام\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھہِ انٹیجرن ہند اکھ ویکٹر دنہ آمت۔ توہہ چھہِ امہِ ہند زیٹھین پرائم ویلیو ژھانڈنہ تہ امہِ ہند ہندسن ہند مجموعہ واپس کرنہ۔ مثالہ: >>> skjkasdkdd((std::vector<long>((long) 0، (long) 3، (long) 2، (long) 1، (long) 3، (long) 4، (long) 7، (long) 5، (long) 5، (long) 2، (long) 2، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 4، (long) 3، (long) 3، (long) 3، (long) 8، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long)\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// نقشہٕ دنہٕ آمت، اگر تمام چابہٕ لوئر کیس منٛز تار چِھ یا تمام چابہٕ ہیرن منٛز تار چِھ آسان تہٕ اگر نہٕ تیلہٕ غلط چُھ واپس کران۔ فنکشن گژھ غلط واپس کرن دیتمت چُھ نقشہٕ خٲلی۔ مثالہٕ: >>> check_dict_case(((std::map<std::string,std::string>(({{\"a\", \"apple\"}, {\"b\", \"banana\"}}))) (true) >>> check_dict_case((((std::map,std::string>{{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) (غلط) >>> check_dict_case_map{\"a\", \"banana\"}, {\"B\", \"map\"}}))) (غلط) >>> check_dict_case_map{\"a\", \"apple\"}, {\"banana\"}, {\"a\", {\"a\", \"}, {\"apple\"}:std::std::string:std::string> (غلط) >>> check_case_string>{{\"A\", \"{{\"A\", \"apple\"std\"apple\"}}، {\"std}}، \"{{\"apple\":std_std_std}}\"apple\":std\"std\"}}</string> ({{\"A\", \"{{\"apple\"apple\"apple\"apple\"apple\"}}، \"}}\"}}\"}}</string_st:st:st:std \"{{\"}}\"}}\"{{\"}}\"Ctrue\": \"{{\"}}\"}}\"{{\"Ctrue:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن چُھ نافذ کران یُس اکھ غأر منفی عدد چُھ نیوان تہٕ گۄڈنکی n عددن ہنٛد ویکٹر چُھ واپس کران یم پرائم نمبر چِھ تہٕ n کھوتہٕ کم چِھ۔ مثلن: >>> count_up_to((5)) (std::vector<long>{(long) 2، (long) 3)) >>> count_up_to(11) (std::vector<long>{(long) 2، (long) 3، (long) 5، (long) 7)) >>> count_up_to(0)) (std::vector<long>) >>> count_up_to(20)) (std::vector<long>{(2, (long) 3، (long) 5، (long) 7، (long) 11، (long) 13، (long) 17، (long) >>> count_up_to_1) (std::vector<long>1، (long) 8، (long) 3، (long) 5، (long) 17، (long) (long) 1، (long) (long) 3، (long)) (long)\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فنکشن مکمل یُس زٕ انٹیجر چھ نوان تہٕ یمن ہٕنٛدیٚن اکٲیی ہندسن ہٕنٛدۍ پٲداوار واپس چھ کران۔ فرض کرو ز ان پٹ چھ ہمیشہ موٗجوٗد۔ مثال: >>> ضرب (۱۴۸) (۴۱۲) (۱۶) >>> ضرب (۱۹) (۲۸) (۷۲) >>> ضرب (۲۰) (۱۸۵۱) (۰) >>> ضرب (۱۴) (۱۵) (۲۰)\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ سٹرنگ s دنہٕ آمت، اپرکیسٕل ووکلن ہندس تعدادس چُھ برابر انڈیکسس منز شمار کران۔ مثالہٕ پٲٹھۍ: >>> count_upper((\"aBCdEf\")) (1) >>> count_upper((\"abcdefg\")) (0) >>> count_upper((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ یُس اکھ قدر (سٹرینگ) چُھ ننیوان یوس اکھ نمبرٕچ نمائندگی کران چُھ تہٕ اتھ قریب ترین عدد چُھ واپس کران۔ اگر یہ نمبر زٕ عددن سٕتۍ چُھ برابر، تہٕ چُھس صفرٕ نِش دور کران۔ مثالہٕ >>> closest_integer((\"10\")) (10) >>> closest_integer((\"15.3\")) (15) نوٹ: صفرٕ نِش دور گژھنُک مطلب چُھ یہ زِ اگر دِنہٕ آمُت عدد زٕ عددن سٕتۍ چُھ برابر، تہٕ توہیہ گژھہِ یہٕ واپس کرنُک زِ یوس صفرٕ نِش دور چُھ آسان سُہٕ چُھ یوس صفرٕ نِش دور چُھ۔ مثلن closest_integer(\"14.5\") گژھہِ 15 واپس کرن تہٕ closest_integer\"-14.5\") گژھہِ -15.\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ مثبت عدد n دنہٕ آمت، توہیہ چُھ پتھرن ہنٛد n سطحن ہنٛد اکھ ڈھیر بناون۔ گۄڈنچ سطحس منٛز چِھ n پتھر۔ پتکین سطحن ہنٛد تعداد چُھ: - اگر n عجیب چُھ تیلہٕ چُھ اگمی عجیب نمبر۔ - اگر n جوڑ چُھ تیلہٕ چُھ اگمی جوڑ نمبر۔ ہر سطحس منٛز پتھرن ہنٛد تعداد چُھ ویکٹر منٛز واپس کران، یتہٕ عنصر انڈیکس i سطحس منٛز پتھرن ہنٛد تعدادچ نمائندگی چُھ کران (i+1) ۔ مثال: >>> make_a_pile(3) (std::vector<long>{long) 3، (long) 5، (long) 7}))\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھِ لفظن ہند اکھ تار یتھ کما یا اسپیسن سۭتۍ الگ کرنہٕ آمت۔ توہیہ چھِ سٹرنگس لفظن منٛز تقسیم کرُن تہٕ لفظن ہند ویکٹر واپس کرُن۔ مثال: >>> words_string((\"ہیو، میہٕ ناو چھُ جان\")) (std::vector<std::string>({(std::string) \"ہیو، (std::string) \"میٛون\"، (std::string) \"نام\"، (std::string) \"یہٕ چُھ\"، (std::string) \"جان\"}) >>> words_string((\"اکھ، زٕ، ترٛے، ژور، پانٛژ، شۄد\")) (std::vector<std::string>{(stdstring) \"اکھ، زٕ، زٕ، زٕ، ترٛے\"، \" (stdstring) \"، (stdstring) \" (std::string) \" (stdstring) \"): (stdstring))\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ زٕ مثبت نمبر x تہٕ y نوان تہٕ چُھ ساری کھوتہٕ بڑُھ جُز تعداد واپس کران یُس حد [x، y] تام چُھ آسان۔ اگر ییتھ نمبر چُھ نہٕ، تیلہٕ فنکشن گژھ -1 واپس کرن۔ مثلن: >>> choose_num (((12), (15)) (14) >>> choose_num (((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// توہہ چھہِ زہ مثبت عدد n تہٕ m دنہ آمت، تہٕ توہہِ کامہ چھہ n پیٹھہٕ m تام عددن ہنز اوسطُک حساب لگاون۔ جوابس قریب ترین عددس تام کرو کرو گول تہٕ یہِ بائنری نمبرس منز تبدیل کرُن۔ اگر n چُھ m کھوتہٕ بڈ، تہٕ -1 واپس کرُن۔ مثال: >>> rounded_avg((1), (5)) \"0b11\" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) \"0b1111\" >>> rounded_avg(20), (33) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد x ہند ویکٹر دیتھ، تمام عناصرن ہند اکھ ترتیب شدہ ویکٹر چُھ واپس کران یتھ منز کنٛہہ تہٕ عدد چُھ نہٕ آسان۔ نوٹ: واپس کرنہٕ آمُت ویکٹر گژھہِ بڑن واجنہِ ترتیبس منز ترتیب دنہٕ یِن۔ مثال: >>> unique_digits(std::vector<long>({long) 15، (long) 33، (long) 142، (long) 1}))) (std::vector<long>{(long) 1، (long) 15، (long) 33})) >>> unique_digits(std::vector<long>{(long) 152، (long) 323، (long) 142، (long) 10}))) (std::vector<long>(long))\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرزن ہند ویکٹر دنہٕ آمت، انٹیجرزن یِم 1 تہٕ 9 شٲمل چِھ آسان، ترتیب دیو، نتیجہٕ ویکٹر الٹہٕ، تہٕ پَتہٕ پرتھ ہندسہٕ امہٕ کہ متعلقہٕ ناوٕ سۭتۍ تبدیل کرو \"1\"، \"2\"، \"3\"، \"4\"، \"5\"، \"6\"، \"7\"، \"8\"، \"9\" مثلن: >>> by_length:{st:string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string: (long:}<string:}<string: (long:}<string: (long:}<string: ({st:string:}<string:}<string: ({st:}<string:}<string: ({string:}<string: ({string:}<string: (string: (string: (string: (string) (string: (string) (string: (string) (string: (string) (string: (string) (string: (string) (string) (string: (string) (string) (string: (string) (string) (string (string) (string) (string (string) (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string (\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فنکشن f یُس n بطور پیرامیٹر چُھ نوان، تہٕ n سائزُک ویکٹر چُھ واپس کران، یتھ کٔنۍ زِ انڈیکس i پیٹھ عنصرچ قدر i ہند فیکٹوریل چِھ اگر i چُھ برابر یا 1 پیٹھ i تام اعدادن ہند مجموعہ۔ i چُھ 1 پیٹھ شروع گژھان۔ i ہند فیکٹوریل چُھ 1 پیٹھ i تام اعدادن ہند ضرب (1 * 2 * ... * i) ۔ مثال: >>> f((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد n دنہٕ آمت، اکھ ٹپل واپس ییتھ منٛز even تہٕ odd انٹیجر پالنڈرومچ تعداد آسہٕ یُس حدٕ اندر چُھ آسان (تجزیہ: 1) ۔ >>> even_odd_palindrome ({1, n}) ، بشمول۔ مثال 1: >>> even_odd_palindrome ({1, n}) (std::make_tuple ({1, 2)) وضاحت: انٹیجر پالنڈروم چِھ 1، 2، 3۔ یمن منٛز چُھ اکھ even تہٕ دۄن چِھ odd۔ مثال 2: >>> even_odd_palindrome ({1}) (std::make_tuple ({4, 6)) وضاحت: انٹیجر پالنڈروم چِھ 1، 2، 3، 4، 5، 6، 7، 8، 9، 11۔ یمن منٛز چِھ ژور even تہٕ 6 odd۔ نوٹ: 1 <= n = 10 ^ 3 2۔ واپس آو ٹپلچ تعداد بالترتیب even تہٕ odd انٹیجر پالنڈرومچ چِھ۔\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لکھو count_nums یُس انٹیجرزن ہیند ویکٹر چُھ نیوان تہٕ چُھ عناصرک تعداد واپس کران یتھ منٛز ہندسن ہند مجموعہ چُھ > 0۔ اگر اکھ نمبر منفی چُھ، تیلہٕ چُھ امک گوڑنک دستخط شدہ ہندسہ منفی آسہٕ: مثلن -123 چُھ ہندسن -1، 2، تہٕ 3 پیٹھ دستخط آمت کرنہٕ: >>> count_nums{(std::vector<long>())) (0) >>> count_nums{(std::vector<long>{(long) - 1، (long) 11، (long) - 11}))) (1) >>> count_nums::std::vector<long>{(long) 1، (long) 1، (long) 2} (3))))\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اسہِ چِھ اکھ ویکٹر 'آرر' N عددن ہند۔ ویکٹر چِھ بے ترتیب ترتیب آمت کرنہٕ۔ توہیہٕ سُہٕ ییہٕ وَننہٕ زِ کیاہ چُھ ممکن زِ ویکٹر گژھہٕ غٲر کم گژھنہٕ والین ترتیبس منٛز ترتیب دنہٕ۔ توہیہٕ چِھ یہٕ وَننہٕ یِوان زِ کیاہ چُھ ممکن کہ اکھ ویکٹر گژھہٕ غٲر کم گژھنہٕ والین ترتیبس منٛز ترتیب دنہٕ یُس دِنہٕ آمت آپریشن چُھ کران۔ توہیہٕ چِھ دِنہٕ آمت دٲیکھہٕ پیٹھہٕ بۄن آپریشن کرُن: توہیہٕ چِھ دٲیکھس پیٹھہٕ بۄن آپریشن کرُن یُس وَنُن چُھ کہ ویکٹر کہ تمام عناصرن دٲیکھس پوزیشنہٕ پیٹھہٕ دٲیکھس سمتہٕ منتقل کرُن۔ ویکٹرُک ٲخری عنصر چُھ وُن ویکٹر کہ آغاز کہ پوزیشنس پیٹھ منتقل کرنہٕ یُن یعنی 0th انڈیکس انڈیکس۔ اگر یہٕ آپریشن کرُن چُن ممکن چُن تہٕ تہٕ صحیح چُہٕ بیاکھ واپس بیاکھ واپس بیاکھ کرنہٕ یُن۔ اگر دٲس ویکٹر چُک خٲلی چُہٕ تہٕ تہٕ بیاکھ خٲلی چُن بیاکھ تہٕ واپس بیاکھ بیاکھ واپس۔ نو بیاکھ صحیح۔ نو بیاکھ واپس بیاکھ کرنہٕ۔ نو بیاکھ وُن۔ نوٹہٕ۔\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اتھ مسلس منز، کرِہ توہی اکھ فنکشن یم زٕ نمبر ویکٹر لیوکھ، تہٕ یہٕ طے کرِہ زِ کیا یمن درمیان چُھ عناصرن ہند تبادلہ کرن ممکن تاکہ صرف lst1 ہیکو even نمبرن ہند ویکٹر بناوِتھ۔ lst1 تہٕ lst2 درمیان چُھ نہٕ تبدیل کرنہٕ آمتین عناصرن ہندس تعدادس پیٹھ کنہہ حد۔ اگر lst1 تہٕ lst2 درمیان عناصرن ہند تبادلہ کرن ممکن چُھ تاکہ lst1 ہیک تمام عناصر برابر آستھ، توہی چِھ \"YES\" واپس کران۔ بصورت دیگر، توہی چِھ \"NO\" واپس کران۔ مثالہٕ پٲٹھۍ: >>> exchange(std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long 1، (long) 3، (long) 4)) (\"YES\") >>> exchange:{(std::vector<>{(long}، (long) (long 4) (\"YES\") (\"YES\") (\"YES\") پیٹھہٕچِہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕ\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اگر اکھ سٹرنگ چُھ اکھ اسپیس سیپیرایڈ لۄکٹسٹری حروفچ نمائندگی کران، تیلہٕ لیٹرچ نقشہٕ ییتھ منٛز زیادٕ تر تکرار چِھ آسان تہٕ اتھ منٛز چُھ متعلقہ گنتی آسان واپس کرٕن۔ اگر کنہہ حروف چِھ اَکیٛن واقعاتن ہنٛد، تیلہٕ یمن تمام لوٛب واپس کرٕن۔ مثال: >>> histogram{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}) >>> histogram{\"a\", 2}, {\"b\", 2}})) >>> histogram{\"a, b, c, b\") (std::map{\"a, b, b, b\"} >>> histogram{\"a, b, b, b, b, b, b, b, b, b, b, b, b, b, b, c, d, e, f, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٹاسک چِھ دوٛن سٹرنگن s تہٕ c دنہٕ آمت، توہیہ چُھ اتھ منٛز موجود تمام کردار حذف کرنچ ضرورت یُس c منٛز کنہٕ تہٕ کردارس برابر چُھ تہٕ پتہٕ چیک کرٕ اگر نتیجہٕ سٹرنگ چھ پالینڈروم۔ سٹرنگس چُھ پالینڈروم وننہٕ یوان اگر یہٕ برونٹھ پتھ کُن چُھ ہاوان۔ توہیہ پزِ چیک کرنہٕ خاطرٕ نتیجہٕ سٹرنگ تہٕ صحیح/غلطس پیٹھ مشتمل ٹپل واپس کرُن۔ مثال >>> reverse_delete{\"abcde\"}، (\"ae\")) (std::make_tuple{\"bcd\"}، false)) >>> reverse_delete{\"abcdef\"}، (\"b\") (std::make_tuple{\"acdef\"}، (\"b\") (std::make_tuple{\"abcded\"}، false))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سٹرنگن ہند اکھ ویکٹر، یتہِ پرتھ سٹرنگس منز چِھ صرف ہندسہٕ آسان، چُھ اکھ ویکٹر واپس کران۔ آؤٹ پٹُک پرتھ عنصر i گژھہِ \"1\" ان پٹ کہِ سٹرنگ i منز عجیب عناصرن ہند تعداد \"1\" آسن۔ یتہِ تمام i گژھہِ ان پٹ کہِ i مہِ سٹرنگس منز عجیب ہندسن ہند تعداد سٕتۍ تبدیل گژھُن ۔ >>> odd_count{\"}{\"}} ({\"}):{\"} ({\"}:{\"}:{\"} ({\"}:{\"}:{\"}:{\"}:{\"} ({\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}:{\"}: 8}: 8}: 8}: 8}: 8 \"8\" سٹرنگسٹرنگس منز چُھ عجیب عناصرن ہند تعداد 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 5۔\"})\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرز اینومرز ہندس ویکٹرس دیتتھ، نمبرن ہند کنہ تہٕ غٲر خٲلی ذیلی ویکٹرُک کم کھوتہٕ کم مجموعہٕ ژھانٛڈٕو۔ مثال >>> minSubArraySum(((std::vector<long>({long) 2، (long) 3، (long) 4، (long) 1، (long) 2، (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) 1، (long) 2، (long) 3}))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھہِ کنہِ ہندِس بُتھس منز اکھ مستطیل گرڈ دِنہ آمت۔ پرتھ صفس منز چھیہ اکھ بُتھ تہٕ پرتھ صفس منز چھیہ اکھ آبچ اکٲئی۔ پرتھ بُتھس منز چھیہ اکھ بالٹی یس اتھ منز آب ننہ خاطرہ استعمال ہکو کٔرتھ۔ تہٕ تمام بالٹی چھہِ ہوی گنجٲیشہ تھاوان۔ توہہُند کٲم چھہ بُتھہِ ہندِ استعمال کرُن بُتھہ خالی کرنُک۔ بُتھہِ ہند تعداد آوٹ پٹ کرنہٕ خٲطرٕ۔ مثال 1: >>> max_fill((std::vector<std::vector<std::vector<long><long>0, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long)\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اتھ کٹاہس منز چُھ توہیہِ منفی عددن ہند ویکٹر ترتیب دینہٕ یوان تہٕ تہندِ بائنری نمائندگی منز چُھ یمن ہند تعداد بڑھنہٕ یوان۔ یتھی تعدادس خٲطرٕہ چُھ اعشاریہ قدرس پیٹھ مبنی ترتیب دینہٕ یوان۔ اتھ گژھہِ ییتہٕ نافذ کرنہٕ: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4، (long) 5))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5)) >>> sort_array(std::vector<long>{(long>{(long-2, (long) 3, (long) 4, (long) 5, (long) 6} (std::vector<long>{(long>{-6, (long) 5, (long-4, (long) 3, (long) 2} >>> array_array:d::vector<long>{(long>0, (long>long}{long}long 2, (long)) (long) 3, (long)) (long) 4، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long (long) (long) (long) (long)) (long (long (long)) (long))\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اگر سٹرنگ s چُھ خٲلی تہٕ فنکشن گژھہٕ خٲلی ویکٹر واپس۔ نوٹ: توہہ ہیکہِ یہٕ فرض کٔرِتھ زِ ان پٹ سٹرنگ چِھ صرف لیٹرز تہٕ سپیسز۔ مثالہٕ: >>> select_words((\"مارۍ ٲس اکھ لَکٹِچ لَمل\"\") ، (4)) (std::vector<std::string>({(std::string) \"لَکٹِچ\"}) ، >>> select_words<(\"مارۍ ٲس اکھ لَکٹِچ لَمل\") ، (3)) (std::vector<std::string>({(std::string) \"مارۍ\"، (std::string) \"لَمل\"}، >>> select_words\"سادہ سفید\"\"، (2) (std::vector<std::string>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھ اکھ لفظ دنہ آمت۔ توہیہ چھوہ اکھ وۅنۍ نزدیک وول وچھان یس دۅن مصمتن درمیان چھہ (لفظن ہنز ترتیب) ۔ لفظس آغاز تہ اختتامس منز وۅنۍ وۅنۍ وۅنۍ وۅنۍ چھنہ شمار کرنہ یوان۔ اگر توہیہ وۅنۍ کنہِ تہِ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ چھہ صرف انگریزی حرف۔ مثال: >>> get_closest_vowel \" ((\"yogurt\")) (\"u\") >>> get_closest_vowel \" (FULL\") (\"U\") >>> get_closest_vowel \" (quick\") (\"\")\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھہِ دوٛن تارن ہند اکھ ویکٹر دِنہ آمت، دۄنوے تار چِھ صرف اوپن parentheses '(' یا بند parentheses ') ' پیٹھ مشتمل۔ توہیہُن کامہ چُھ یہ چیک کرن زِ کیاہ چھہِ دوٛن تارن کنہِ ترتیبس منز جوڑنہٕ آمت، زِ نتیجہٕ گژھہِ سٹرنگ اصل۔ اکھ سٹرنگ S چُھ اصل اگر تہٕ صرف اگر S منز چِھ تمام parentheses متوازن۔ مثالہٕ پٲٹھۍ: سٹرنگ '((()) ' چِھ اصل، ییلہِ زَن سٹرنگ '(()) ' چِھ نہٕ اصل۔ اگر اکھ اصل سٹرنگ بناونک طریقہٕ آسہِ، تہٕ 'YES' واپس کرِتھ، تہٕ بییہٕ 'NO' واپس کرِتھ۔ مثالہ: >>> match_parens(std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ ویکٹر arr یُس انٹیجرز تہٕ اکھ مثبت انٹیجر k چُھ دیوان، آر آر منٛز زیادٕ کھوتہٕ زیادٕ k نمبرن سۭتۍ لمبائی k ہنٛد ترتیب دینہٕ آمت ویکٹر واپس ییہٕ دنہٕ۔ مثال 1: >>> maximum((std::vector<long>({long) - 3، (long) -4، (long) -5}) ، (3)) (std::vector<long>({long) -4، (long) -3، (long) -5}) مثال 2: >>> maximum(std::vector<long>({long) 4، (long) -4، (long) 4}) ، (2)) (std::vector<long>{long}4، (long) 4)) مثال 3: >>> maximum(std::vector<long>{long} - 3، (long) 2، (long) 1، (long) 2، (long) 1، (long) 1، (long) (1) (std::vector<long>2}) ویکٹرچ لمبائی 1000 کہِ اندر گژھہٕ ۔ نوٹ: ویکٹر چُھ 1000 کہِن عناصرن ہنٛز حدس منٛز آسان۔ لین -1، 2، 1000۔\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٹیجرزن ہند اکھ غٲر خٲلی ویکٹر دِنہٕ آمت، تمام عجیب عناصرن ہند مجموعہٕ یُس برابر پوزیشنن پیٹھ چُھ، چُھ واپس کران۔ مثالہٕ >>> solution((std::vector<long>({long) 5، (long) 8، (long) 7، (long) 1}))) (12) >>> solution(((std::vector<long>({long) 3، (long) 3، (long) 3، (long) 3}))) (9) >>> solution((std::vector<long>({long) 30، (long) 13، (long) 24، (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// آر آر تہٕ اکھ انٹیجر k ہنٛد غٲر خٲلی ویکٹر دِنہٕ آمت، آر آر کیٛن گوڑنکیٛن k عناصرن منٛز زیادٕ کھوتہٕ زیادٕ دوٛن ہندسن سۭتۍ عناصرن ہیند مجموعہٕ چُھ واپس کران۔ مثال: >>> add_elements{}std::vector<long>{(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}) ، (4)) (24) پابندیاں: 1. 1 <= len{arr) <= 100 2. 1 <= k <= len{arr})\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد n دنہٕ آمت، چھُ اکھ ترتیب وٕچھنہٕ آمت ویکٹر واپس یوان یتھ منٛز کُلٹز ترتیبس منٛز عجیب نمبر آسن۔ کُلٹز قیاس چُھ ریاضی منٛز اکھ قیاس یُس اکس ترتیبس متعلق چھُ یتھ کٔنۍ بیان کرنہٕ آمت: کنہ تہٕ مثبت عددس سۭتۍ شروع کرو n۔ پَتہٕ پرتھ اصطلاحس پٔتِمہٕ اصطلاح سۭتۍ یِتھہٕ پأنٹھ حٲصل یِوان: اگر پٔتِمہٕ اصطلاح چِھ برابر، تیلہٕ چِھ ینہٕ وٲل اصطلاح پچھم اصطلاحک اکھ نصف۔ اگر پٔتِمہٕ اصطلاح چِھ عجیب، تیلہٕ چِھ ینہٕ وٲل اصطلاح پچھم اصطلاحک 3 گنا زیادٕ 1۔ قیاس چُھ یہٕ زِ n یُس قدر آسہٕ نہٕ، ترتیب چِھ ہمیشہ 1 تام واتان۔ نوٹ: 1. کُلٹز ((1) چُھ [1] ۔ 2. واپس آمت ویکٹر چُھ بڑھون ترتیبس منٛز ترتیب دینہٕ آمت۔ مثال پٲٹھ: get_odd_collatz5) واپس چُھ یوان [1, 5] 5 خاطرٕ کُھ کُلٹز ترتیب 5 خاطرٕ [5, 8, 16, 4, 2, 1، لہذا عجیب نمبر چِھ 1، تہٕ 5۔ >>> کُلٹز_کولیٹز (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھِ اکھ فنکشن لیکھان یُس دِنہٕ آمتِس ڈیٹ سٹرنگس درست کران چھِ تہٕ اگر ڈیٹ چھِ درست تیلہٕ چُھ غلط واپس کران۔ ڈیٹ چِھ درست اگر یم تمام قواعد پورٕ گژھن: 1. ڈیٹ سٹرنگ چِھ نہٕ خٲلی۔ 2. مہینن خاطرٕ چِھ دوہن ہینز تعداد کم کھوتہٕ کم 1 یا زیادٕ 31 دوہ۔ تہٕ مہینن خاطرٕ چِھ دوہن ہینز تعداد کم کھوتہٕ کم 1 یا زیادٕ 30 دوہ۔ تہٕ، مہینن خاطرٕ چِھ دوہن ہینز تعداد کم کھوتہٕ کم 1 یا زیادٕ 29 دوہ۔ 3. مہینن ہینز تعداد گژھ نہٕ کم کھوتہٕ کم 1 یا زیادٕ گژھت۔ 4. ڈیٹ گژھہٕ فارمیٹس منٛز آسن: mm-dd-yyyy >>> valid_(date(((01-15-2012)) (true) >>> valid_date(((01-15-2012\")) (false) >>> valid_date((04-2040\") (false) >>>valid_(((((06-2020) (true) >>>valid_date (false)\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// لفظن ہندس تارس دیتتھ، سفیدس پیٹھ تقسیم گژھن والن الفاظن ہندس ویکٹرس واپس کرُن، اگر متنس منٛز سفیدس پیٹھ کنہہ تہٕ جایہٕ نہٕ آسن تم گژھن کماہس پیٹھ تقسیم گژھت۔'، اگر کنہہ تہٕ جایہٕ نہٕ آسن تہٕ تہٕ توہہٕ الفباہس منٛز عجیب ترتیب سۭتۍ لوئر کیسزک حروفن ہنٛز تعداد گژھہٕ واپس کرُن، آرڈ (a) = 0، آرڈ (b) = 1، ... آرڈ (z) = 25 مثالہٕ >>> تقسیم_ الفاظ (d) >>> تقسیم_ الفاظ (d) >>> تقسیم_ الفاظ (d) >>> تقسیم_ الفاظ (d)\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اعدادن ہندس ویکٹرس دنہٕ آمت، ییہٕ واپس کرنہٕ اگر تم چِھ بڑھون ترتیبس منٛز ترتیب دینہٕ آمت۔ اگر ویکٹرس منٛز اکس کھوتہٕ زیادٕ نمبر چِھ آسان، تیلہٕ غلط چُھ واپس کرنہٕ یوان۔ کنہہ منفی نمبرن ہنٛد تصور کرو تہٕ صرف انٹیجرز۔ مثالہٕ >>> چُھ ترتیب دینہٕ آمت ({(std::vector<long>{(long>5}))) (true) >>> چُھ ترتیب دینہٕ آمت ({(std::vector<long>1) ، ({(long>2، ({(long>3، ({(long>4}) ، (true) >>> چُھ ترتیب دینہٕ آمت ({(long>1، ({(long>2، ({(long>3، ({(long>4}) ، (long>6، ({(long>6، ({(long>1، (long>6، (long>6، (long)) ، (long>7، (long>6، (long)) ، (long>long>long>6، (long>long)) ، (long>long>long>long>long>long)) ، (long>long>long>long>long>long>long)) ، (long>long>long>long>long>long>long)) ، (<long>long>long>long>long>long>long>long>long>long>long>long)) ، (<long>long>long>long>long>long>long>long>long>long)) ، (<<<long>long>long>long>long>long>long)) ، (<<<<<<<<<<<<<<<<<<<<<<<>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long)) ،</>long>long>long)) ،</>long)) (<<<<>long>long>long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھہ دۅن وقفہ دنہ آمت، یتہ پرٛیٚتھ وقفہ چھہ انٹیجرزن ہند جوڑ۔ مثلن، وقفہ = (شروع، اختتام) = (1, 2) ۔ دِنہٕ آمت وقفہ چھہ بند، امہ کنۍ زِ وقفہ (شروع، اختتام) چُھ شروع تہٕ اختتام دۄنوے شٲمل کران۔ پرٛیٚتھ وقفہ خٲطرٕ، یہ فرض چھہ یوان کرنہٕ ز امک آغاز چھہ امہ کس اختتامس برابر یا امہ کس کمس برابر۔ تہند کٲم چھہ یہ دٔریافت کرن زِ یمن دۄن وقفن ہنٛد انٹرسیکشنچ لمبٲیی چھہ اکھ پرائم نمبر۔ مثال، وقفن ہنٛد انٹرسیکشن (1, 3) ، (2، 4) چھہ (2، 3) یمک لمبٲیی چھہ 1، یُس نہٕ اکھ پرائم نمبر چھہ۔ اگر انٹرسیکشنچ لمبٲیی چھہ اکھ پرائم نمبر، تیلہ کٔرِ \"YES\" واپس، بصورت دیگر کٔرِ \"NO\" واپس۔ اگر زٕہٕہٕن وقفہ چھنہ انٹرسی سۭتۍ متٲفل، کٔر \"NO\" واپس۔ [input/output] نمونے: >>>intersection::((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھِ پورٕ اعدادن ہند اکھ ویکٹر دنہٕ آمت تہٕ توہہ چھِ پورٕ اعدادن ہنز مقدارُک مجموعہٕ پورٕ اعدادن ہند ضرب ویکٹرس منز ہر نمبر کہ تمام نشاناتن ہند پروڈکٹہٕ سۭتۍ واپس کرنچ ضرورت، یمچ نمائندگی 1، -1 یا 0 سۭتۍ چِھ یوان کرنہٕ۔ نوٹ: خالی arr خاطرٕ چُھ نہٕ کنہہ تہٕ واپس کرنہٕ یُن۔ مثال: >>> prod_signs{(std::vector<long>{(long) 1، (long) 2، (long) 2، (long) 4}))) 9 >>> prod_signs{(std::vector<long>{(long) 0، (long) 1}))) 0 >>> prod_signs{(std::vector<long>((d))) std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// N راین تہٕ N کالمن (N >= 2) تہٕ اکھ مثبت انٹیجر k سۭتۍ اکھ گرڈ دینہٕ آمت، گرڈک پرتھ سیل چُھ اکھ قدرس پیٹھ مشتمل۔ رینجچ ہر انٹیجر چُھ گرڈک سیلن پیٹھ بالکل اکہٕ لٹہٕ ظأہر گژان۔ توہیہ چُھ گرڈس منٛز لمبائی k ہنٛد کم کھوتہٕ کم وتھ ژھانٛڈن پیٛوان۔ توہیہ ہیکہِ کُنہٕ تہٕ سیل نش شروع گژھت، تہٕ پرتھ مرحلس منٛز ہیکہِ توہہٕ ہمسایہٕ سیلن منٛز گژھت، بیین لفظن منٛز، توہیہ ہیکہِ سوٛن سیلن منٛز گژھت یم توہیہٕ موجودٕ سیلن سۭتۍ اکھ کنڈ چھ شیئر کران۔ براہ کرم نوٹ کٔرو کہ لمبائی k ہنٛد پاتھ چُھ مطلب بالکل k سیلن ہنٛد دورٕ کرن (ضروری طور پٲن چُھنہٕ الگ) ۔ توہیہ ہیکہِ نہٕ گرڈس نیبر گژھت۔ A (لمبائی k) چُھ اکھ پاتھ B (لمبائی k) کھوتہٕ کم سمجھنہٕ ییلہٕ اگر A تہٕ B (آوٛو تمن lst_A تہٕ l_st_A تہٕ l_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_J تہٕ) پیٹھ قدرن ترتیب دینہٕ والن والن ویک ترتیب دینہٕ ویک ترتیب بناون پتہٕ (ت چُن) ، توہی چُہٕ اکھ ویکٹ ویکٹ ویکٹ ویکٹ ویک لحاظ سۭتۍ کم چُک خیال چُک اکھ ویکٹٕ لوٛت اگر A (آ k_j_j_j_j_j_j_j_j_j_j_j_j_j تہٕ l تہٕ l_j_j_j_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فبونیکی ترتیب چِھ ساروی کھوتہٕ زیادٕ مشہور، ریاضی دانو چُھ امچ گہری مطالعہٕ کرمُت۔ تاہم، یُس لوکھ چِھ نہٕ زانان چُھ ٹریبونیکی ترتیب۔ ٹریبونیکی ترتیبچ تعریف چِھ تکرارس سۭتۍ کرنہٕ یوان: tri(1) = 3 tri(n) = 1 + n / 2 ، اگر n چُھ برابر۔ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، اگر n چُھ عجیب۔ مثلن: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 اگر توہہٕ چِھ اکھ غأر منفی عدد n دنہٕ آمت، توہہٕ چِھ ٹریبونیکی ترتیبچ گوڑنچ n + 1 ویکٹر واپس کرن۔ مثال: >>> tri(3) (longdst vector><<{(long} (long1, long (3, long) (long) (8, long))\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ مثبت عدد n دنہٕ آمت، عجیب ہندسن ہند پیداوار واپس ییہٕ دنہٕ۔ 0 ییہٕ واپس ییہٕ دنہٕ اگر تمام ہندسہٕ چِھ یکساں۔ مثال: >>> ہندسہٕ (۱) (۱) >>> ہندسہٕ (۲) (۴) (۰) >>> ہندسہٕ (۲۳۵) (۱۵)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ یُس صرف مربع بریکٹس وٲل سٹرنگ ان پٹ کٔرِ۔ فنکشن گژھہِ ٹرو لٲوِتھ اگر تہٕ صرف اگر بریکٹسٕچ اکھ درست ذیلی ترتیب آسہِ یتھ منز ذیلی ترتیبس منز کم از کم اکھ بریکٹ چُھ نیسٹڈ۔ >>> is_nested((\"[[]]\")) (true) >>> is_nested((\"[]]]]]]]]]][[[[[[[]\")) (false) >>> is_nested((\"[][]\") (false) >>> is_nested(\"[]\") (false) >>> is_nested(\"[[]]\") (true) >>> is_nested(\"[[]]\") (true)\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھ اعدادن ہند اکھ ویکٹر دنہ آمت۔ توہہ چھ دراو ویکٹرس منز مربع نمبرن ہند مجموعہ واپس کرنچ ضرورت، تہٕ ویکٹرس منز پرتھ عنصرس گوڈٕ پیٹھہٕ ہیر کٔرتھ۔ مثالہٕ: >>> lst: vector<float>{(float) 1.0f, (float) 2.0f, (float) 3.0f)) (14) >>> lst: vector<float>{(float) 1.0f, (float) 4.0f, (float) 9.0f))) >>> (98) lst: vector<float>{(float) 1.0f, (float) 3.0f, (float) 5.0f, (float) 7.0f)) (84) >>> lst: vector<float>{((float) 1.4f, (float) 2.4.2f, (float) 3.0f)) (6) >>> lst: vector<float>{(float) 2.4.0f, (float) 2.4.0f, (float) (6) >>> (float) 2.4.0f, (float)\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ یُس ٹرٕ چُھ واپس کران اگر دِنہٕ آمتِس سٹرنگُک ٲخری کردار چُھ اکھ حروف تہجی ہند کردار تہٕ چُھ نہٕ کنٛہہ لفظُک حصہ تہٕ بییہٕ غلط۔ نوٹ: \"1\" لفظ \"2\" چُھ حروفن ہند اکھ گروپ یوس اسپیسس سٕتۍ چُھ الگ کرنہٕ آمُت۔ مثالہٕ: >>> check_if_last_char_is_a_letter\" (((\"apple pie\")) (false) >>> check_if_last_char_is_a_letter\" ((apple pi e\")) (true) >>> check_if_last_char_is_a_letter \" (((apple pi e)) (false) >>> check_if_last_char_is_a_letter \" (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ اکھ ایلیمنٹس سٕنز ساروی کھوتہٕ بٕڑ انڈیکس چُھ واپس کران یوس ایمہِ برونٛہہ کہِ ایلیمنٹس سٕتۍ زیادٕہ یا مسٲوی چُھ نہٕ کینٛہہ۔ اگر ایمہِ قٕسمُک ایلیمنٹس موجود آسہِ نہٕ تیلہِ چُھ واپس کران -1۔ دِنہٕ آمُتۍ ویکٹر منز چُھ نہٕ ڈپلیکیٹ ویلیوز آسان کینٛہہ۔ مثال: >>> can_arrange(((std::vector<long>({long) 1، (long) 2، (long) 4، (long) 3، (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1، (long) 2، (long) 3}))) (-1)\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ یُس ٹپل (a، b) چُھ رٹان، یتہِ 'a' منفی عددن منز ساروی کھوتہٕ بوٕڑ چُھ، تہٕ 'b' چُھ ویکٹرس منز مثبت عددن منز ساروی کھوتہٕ لوکٹ۔ اگر نہٕ منفی تہٕ نہٕ مثبت عدد آسہِ، تہٕ بییہِ ایمِچ واپسی None کِس طورس پیٹھ۔ مثالہٕ: >>> largest_smallest_integers((std::vector<long>{long>) 2، (long) 4، (long) 1، (long) 3، (long) 5، (long) 7))) std::make_tuplest_d::optional<long>{long>) ، std::optional<long>{long>) >>> largest_smallest_integers{long>{long>}، std::optional<long>{long>) ، std::optional<long>{long>{long>}، std::optional<long>{long>}، std::optional<long>{long>}<optional<optional>\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// اکھ فنکشن بنٲوِتھ یُس انٹیجر، فلوٹس، یا سٹرنگس چُھ ننان یوس حقیقی نمبرن ہنز نمائندگی کران چُھ، تہٕ چُھ بڑٕے متغیرس اتھ متغیر ٹائپس منز واپس کران۔ اگر ویلیو برابر آسن تہٕ چُھ نون واپس کران۔ نوٹ: اگر اکھ حقیقی نمبر چُھ سٹرنگ کہِ طورس پیٹھ پیش کرنہٕ یوان، تہٕ فلوٹنگ پوائنٹ ہیکہِ ٲسٕتۍ . یا ، >>> compare_one{1,2.5f} 2.5f >>> compare_one{1, \"2,3\") \"2,3\" >>> compare_one{5,1\", \"6\") \"6\" >>> compare_one{1\", 1) std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// تشخیص کٔرو زِ کیا دِنہٕ آمت نمبر n ہیکو بالکل 4 پازِٹو Even نمبرن ہندس مجموعس طورس پیٹھ لیکھتھ مثال >>> is_equal_to_sum_even ({\\displaystyle n_{\\displaystyle _{\\displaystyle _{\\displaystyle _{\\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\\displaystyle _{\\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\\displaystyle _{\\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\\displaystyle _{\\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\\displaystyle _{\\frac {e}}}) (جھوٹ)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// برازیلی فیکٹریئل چُھ یتھ کٔنۍ بیان کرنہٕ آمت: برازیلی_فیکٹریئل ((n) = n! * (n-1)! * (n-2)! * ... * 1! یتین n > 0 مثلن: >>> خصوصی_فیکٹریئل (((4)) (288) فنکشن ان پٹ کس طورس پیٹھ چُھ اکھ انٹیجر حٲصل کران تہٕ اتھ انٹیجرس سٔتۍ گژھہٕ خصوصی فیکٹریئل واپس گژھت۔\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ سٹرنگ متن دیتھ، اتھ منٛز موجود تمام خالی جگہوں پیٹھ زیرکورس سۭتۍ تبدیل کرُن، تہٕ اگر سٹرنگس منٛز 2 کھوتہٕ زیادٕ لگاتار خالی جگہوں چِھ آسان، تیلہٕ تمام لگاتار خالی جگہوں پیٹھ تبدیل کرُن - >>> fix_spaces((\"مثال\")) (\"مثال\") >>> fix_spaces((\"مثال 1\")) (\"مثال_1\") >>> fix_spaces((\"مثال 2\")) (\"_مثال_2\") >>> fix_spaces((\"مثال 3\")) (\"_مثال-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن بنٲوِتھ یُس اکھ سٹرنگ چُھ نوان یوس فائلُک ناو چُھ ظٲہر کران، تہٕ اگر سٹرنگُک ناو چُھ درست، تہٕ اگر سٹرنگُک ناو چُھ غلط تہٕ چُھ \"نٔ\" واپس کران۔ اکھ فائلُک ناو چُھ صیح ماننہٕ یوان اگر تہٕ صرف اگر سٹرنگُک تمام درج ذیل شرطہٕ پورٕ گژھِ: - فائلُک ناو گژھِ نہٕ تریو ہندسن سٕتۍ زیادٕہ آسن ('0'-'9') ۔ - فائلُک ناوس منز گژھِ نہٕ بالکل اکھ ڈاٹ '۔ - ڈاٹ برونٹھ چُھ سبسٹنگ خٲلی گژھُن، تہٕ یہٕ گژھہِ نہٕ ڈاٹ برونٹھ اکہِ حرفہٕ سٕتۍ شروع گژھُن ('a'-'z' تہٕ 'A'-Z') ۔ ڈاٹ برونٹھ چُھ سبسٹنگ یُس اَتھ منزٕ اکھ آسہٕ: ['txt'، 'exe', 'll'] مثالہٕ: >>> file_name_check_{\"{\"{example.txt\") (\"Yes\") >>> file_name_check_{\"{example.d1}\"{example.t\"} (\"No\")\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// یہٕ فنکشن چُھ انٹیجرزن ہند ویکٹر نوان۔ ویکٹر کہِ تمام اندراجاتٕ خٲطرٕہ، فنکشن چُھ انٹیجر انٹریس مربع کرُن اگر ایمِچ انڈیکس 3 ہند ضرب چُھ تہٕ انٹیجر انٹریس کوب کرُن اگر ایمِچ انڈیکس 4 ہند ضرب چُھ تہٕ نہٕ کہ 3 ہند ضرب۔ فنکشن چُھ نہٕ ویکٹر کہِ انٹریزن تبدیل کران یمیوک انڈیکس 3 یا 4 ہند ضرب چُھ نہٕ کینٛہہ۔ فنکشن چُھ پتہٕ تمام اندراجاتُک جمع واپس کران۔ مثالہٕ: >>> lst (long({(long) 1، (long) 2، (long) 3})) >>> lst (long) 1، (long) 2، (long) 1، (long) 5})\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چھہ اکھ جملہ پیش کرنہ آمت، جملس منز چھہ کینہہ لفظ یس پرایس سٹیج سیتۍ الگ چھہ، تہ توہیہ چھہ اکھ جملہ واپس کرنۍ یمہ منز اصل جملک لفظ آسہ، یمچ لمبائی پرائم نمبر آسہ، نٔوِس سٹرنگس منز لفظن ہنز ترتیب گژھہِ اصلی ہندس ہیوۍ آسن۔ مثال 1: >>> words_in_sentence (((\"یہ چھیہ اکھ ٹیسٹ\")) (\"is\") مثال 2: >>> words_in_sentence (((\"چھیہ سوئمنگس منز وۅتلان\")) (\"go for\") پابند: * 1 <= len ((sentence) <= 100 * جملس منز چھہِ صرف حرف\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہند کٲم چھ اکھ فنکشن لاگو کرن یُس اظہار x * n آسان بناوٕ۔ یہٕ فنکشن چھ صحیح واپس کران اگر x * n چُھ اکھ پورٕ نمبر تہٕ بصورت دیگر غلط۔ x تہٕ n، چھ اکھ فریکشنچ سٹرنگ نمائندگی، تہٕ یمن منٛز چھِ درج ذیل شکل، <numerator>/<denominator> ییتھ منٛز ننیومنٹر تہٕ ڈینومینٹر دۄنوے مثبت پورٕ نمبر چِھ۔ توہیہ ہیکو یہٕ فرض کرتھ زِ x، تہٕ n چھ درست فریکشن، تہٕ ڈینومینٹر چھُ نہٕ صفر۔ >>> آسان بناوُن (((\"1/5\") ، (\"5/1\")) (حقیقت) >>> آسان بناوُن ((\"1/6\") ، (\"2/1\") (غلط) >>> آسان بناوُن (((\"7/10\") ، (\"10/2\") (غلط)\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھ یتھ منز انٹیجرزن ہند دِنہٕ آمُت ویکٹر چُھ دِنہٕ یوان تہٕ چُھ دِنہٕ یوان تہندین ہندسن ہندس مجموعس مطابق۔ نوٹ: اگر ہیوی ہندسن ہندس مجموعس سٕتۍ چِھ واریاہ چیز، تہٕ توٲی چُھ تہندِس اصل ویکٹرس منز تہندِس انڈیکس کہِ بنیادس پیٹھ ترتیب دِنہٕ یوان۔ مثال کہِ طورس پیٹھ: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) -1, (long) -12, (long) -11}) >>> order_by_points\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھ یتھ منز اعدادن ہند ویکٹر ان پٹ چُھ یوان کرنہٕ تہٕ ویکٹر چِھ عناصرک تعداد واپس کران یم 10 کھوتہٕ زیادٕ چِھ آسان تہٕ نمبرٕک گوڈنِک تہٕ ٲخری ہندسہٕ چِھ عجیب آسان (1, 3, 5, 7, 9) ۔ مثالہٕ پٲٹھۍ: >>> specialFilter((std::vector<long>({long) 15, (long) -73، (long) 14، (long) -15}))) (1) >>> specialFilter((std::vector<long>({long) 33، (long) - 2، (long) - 3، (long) 45، (long) 21، (long) 109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھوہ اکھ مثبت عدد n دنہ آمت۔ توہہ چھوہ اکھ عدد ویکٹر بناون پیوان a زیچھر n ہچ۔ پرتھ i (1 ≤ i ≤ n) خاطرٕ ، a[i] = i * i - i + 1چ قدر۔ a a کیٛن ٹرپلزن ہنٛز تعداد واپس کرو (a[i] ، a[j] ، a[k]) ییتہ i < j < k چُھ، تہٕ a[i] + a[j] + a[k] چُھ 3 ہند ضرب۔ مثال: >>> get_max_triples((5)) (1) وضاحت: a = [1, 3, 7, 13, 21] واحد درست ٹرپل چُھ (1, 7, 13) ۔\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// شمسی نظامس منز چِھ آٹھ سیارٕ: آفتابس قریب ترین سیارٕ چُھ مرکری، برونٹھ چُھ ونرس، تہٕ پتہٕ زمین، مریخ، مشتری، زحل، یورینس، نیپچون۔ اکھ فنکشن لیوکھو یوس زٕ سیارن ہند ناو چُھ سیارٕ1 تہٕ سیارٕ2 کِس سٹرنگس منز نوان۔ فنکشنس گژھہِ اکھ ٹپل واپس انِن یوس تمام سیارن ہند مدار چُھ سیارٕ1 تہٕ سیارٕ2 کِس مدارس درمیان واقع، آفتابس قریبیتس مطابق چُھ ترتیب دِنہٕ آمُت۔ اگر سیارٕ1 یا سیارٕ2 چِھ نہٕ سیارن ہند صحیح ناو کینٛہہ تہٕ فنکشن گژھہِ خٲلی ٹپل واپس انِن۔ مثالہٕ >>> bf((\"جوبائٹر\") ، (\"نیپٹن\")) (std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھ یتھ منٛز تارن ہنٛد اکھ ویکٹر پیرامیٹر کس طورس پیٹھ چُھ قبول کرنہٕ یوان، تمن تارن چُھ ہٹان یمن منٛز عجیب لمبائی چِھ آسان، تہٕ ترتیب دینہٕ آمت ویکٹر چُھ واپس کران۔ ویکٹر چُھ ہمیشہ تارن ہنٛد ویکٹر آسان تہٕ نہٕ چُھ کُنہٕ ویکٹر نمبرن ہنٛد تہٕ اتھ منٛز ہیکن نقلہٕ شأمل أستھ۔ ویکٹرچ ترتیب گژھہٕ پرتھ لفظ کس لمبائی سۭتۍ چلان گژھت، تہٕ توہیہ گژھہٕ ویکٹر اَتھ قأیلس مطأبق ترتیب دینہٕ یُن۔ اگر دشویی لفظ چِھ اَکی لمبائی سۭتۍ، تیلہٕ ویکٹر چُھ الفبأتی ترتیب سۭتۍ ترتیب دینہٕ یُن۔ فنکشن گژھہٕ ترتیب دینہٕ آمت تارن ہنٛد ویکٹر واپس کرُن۔ توہیہ ہیکہٕ یہٕ فرض کرتھ کہ تمام الفاظن چِھ اَکی لمبائی۔ مثال کہ طور: >>> list_sort{\"}std::stdvector<stdstring>{\"}st:{\"}st:d\"d\"d\"d\"d\"a\"a\" (d\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ سادٕ پروگرام یُس xچ قدر یلہٕ n پرائم نمبر آسہٕ تہٕ yچ قدر یلہٕ بییہٕ واپس آسہٕ۔ مثالہٕ: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اعدادن ہندس ویکٹرس دیتھ، ویکٹرس منز اعدادن ہند مربعٕ ہند رقم واپس یُس عجیب چُھ ۔ منفی یا نہٕ عدد چِھ اعداد نظر انداز کران۔ >>> double_the_difference{((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference{(std::vector<float>{(long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference{(std::vector<float>{(long) -9, (long) -2}))) (81) >>> double_the_difference{(std::vector<float>{(long) -0}))) (0) اگر ان پٹ ویکٹر چُھ خٲلی، توہیہٕ چُھ 0 واپس کران۔\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// میہ چُھ سونچ زِ ییلہٕ کنہہ طویل انتظارک نتیجہ چُھ أخٕرکار معلوم گژان تہٕ تمن احساسن تہٕ خیالاتن یُس تٔمۍ اسہِ چُھ آسان تم چِھ یقینی طورس پیٹھ نوٹ کرنچ تہٕ موازنہٕ کرنک قٲبل۔ تہند کٲم چِھ یہٕ طے کرُن کہ کیا اکس نفرن چُھ واریاہ میچچچرن ہنٛد نتائج صحیح اندازٕ لگاون۔ توہیہ چِھ آمٕتۍ دوٛن ویکٹرن ہنٛد اسکور تہٕ برابر لمبائی ہنٛد اندازٕ لگاون، یتہٕ پرتھ انڈیکس چُھ اکھ میچچچچ ظٲہر کران۔ اکہ ویکٹرک چُھ ہیوی لمبائی دیوان یمہٕ سۭتۍ یہٕ چُھ ظٲہر گژھان زِ ہر اندازٕ کتھ کتھ حدس تام اوس۔ اگر تمو صحیح اندازٕ لگاون، تیلہٕ چُھ ویلیو 0، تہٕ اگر نہٕ، تیلہٕ چُھ ویلیو اندازٕ تہٕ تہٕ اسکورس درمیان مطلق فرق۔ مثال: >>> (long (long) (long (long) (long (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long)\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ آیہ کلاسک ناو (اکھ سٹرنگ) تہٕ توسیعک ویکٹر دنہٕ۔ توسیعہٕ چھ اضٲفی کلاسس کلاسس منٛز لوڈ کرنہٕ خٲطرٕ استعمال کرنہٕ ین۔ توسیعچ طاقت چھ ییتھ کیٛن: سی اے پی ییہ توسیع کس ناوس منٛز بڑے حروفن ہنٛز تعداد، تہٕ ایس ایم ییہ توسیع کس ناوس منٛز لوئرسیٹس حروفن ہنٛز تعداد، طاقت چھ کسر سی اے پی - ایس ایم سۭتۍ دنہٕ آمژ۔ توہیہ گژھ مضبوط ترین توسیع تلاش کرتھ تہٕ امہٕ شکلہٕ منٛز سٹرنگ واپس ین: ClassName.StrongestExtensionName۔ اگر اکسی طاقتک زٕ یا زیادٕ توسیعہٕ آسہٕ، توہیہ گژھ ویکٹرس منٛز گۄڈنیتھ ینس منتخب کرُن۔ مثلن، اگر توہیہ چُھ \"سلائسز\" کلاس تہٕ توسیعک ویکٹر کس طورس پیٹھ دنہٕ آمت: ['SErviSliNGCes'، 'Cheese', 'StuFfed'] تہٕ توہیہ گژھ توہیہ 'Slices.SliSliSliCliSviC' واپس کرن ییتھ ییتھ ییتھ توہیہ توہیہ گژھ 'SviSliC::::st::::::::: my: my: my: my: my: my: my: my:st: ایس ایس ایس ایس ایس ایس ایس ایس ایس ایس ایس ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہیہ چِھ 2 لفظ دنہٕ آمت۔ توہیہ چُھ ضرورت صحیح واپس کرن کہ اگر دیم لفظ یا امچ کنہہ گردش گوڑنک لفظس منٛز چِھ اکھ سبسٹنگ >>> cycpattern_check((\"abcd\") ، (\"abd\")) (غلط) >>> cycpattern_check((\"ہیلو\") ، (\"ell\")) (سچ) >>> cycpattern_check(\"whassup\") ، (\"psus\")) (غلط) >>> cycpattern_check(\"abab\") ، (\"baa\")) (سچ) >>> cycpattern_(check\"efef\") ، (\"eeff\") (غلط) >>> cycpattern_check(\"himens\") ، (\"simen\") (سچ)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ انٹیجر دنہٕ آمت، اکھ ٹپل چُھ واپس کران یتھ منٛز بالترتیب برابر تہٕ عجیب ہندسن ہند تعداد آسہٕ۔ مثال: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ مثبت انٹیجر دینہٕ آمت، امک رومن ہندسہٕ مساوی سٹرنگ کس طورس پیٹھ حٲصل کرُن، تہٕ لوئر کیسٹس منٛز واپس کرُن۔ پابندیاں: 1 <= num <= 1000 مثالہٕ: >>> int_to_mini_roman((19)) (\"xix\") >>> int_to_mini_roman((152)) (\"clii\") >>> int_to_mini_roman(426) (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثلثن ہند تریو اطرافن ہنز لمبائی دِنہٕ آمٕژ۔ اگر تریو اطراف اکھ مستحکم مثلث چِھ بناوان تہٕ دیمہٕ صورتس منٛز غلط چُھ واپس کران۔ اکھ مستحکم مثلث چِھ اکھ مثلث ییتھ منٛز اکھ زاویہ چُھ سیدھ زاویہ یا 90 ڈگری۔ مثال: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اکھ فنکشن لیوکھ یتھ منٛز سٹرنگن ہنٛد ویکٹر چُھ قبول کرنہٕ یوان۔ ویکٹرس منٛز چِھ مختلف الفاظ آسان۔ لفظ چُھ زیادہ سے زیادہ منفرد کردارن سۭتۍ واپس کران۔ اگر کنہہ سٹرنگن منٛز چِھ زیادٕ سے زیادٕ منفرد کردارن ہنٛد تعداد آسان، تیلہٕ چُھ سُوٛ لَبہٕ واپس یُس پہلے لغوی ترتیبس منٛز چُھ یوان۔ >>> find_max{(std::vector<std::string>({(std::string) \"name\", (std::string) \"of\", (std::string) \"string\"}))) (\"string\") >>> find_max{(std::vector<std::string>({(std::string) \"name\", (std::string) \"enam\") >>> find_max{(std::vector<std::string>{(std:string) \"aaaaaa\" >>> find_max{(std::vector<std>{(std:string}\"bb\"string\"} (\"string\")\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توہہ چھہِ بھوک مٲرۍ، تہ توہہ چھہِ گارٹین ہنز اکھ مخصوص تعداد کھٲم کرمت، مگر از چھہِ توہہ دنہک کھین مکمل کرنہ خاطرہ مزید گارٹین کھینچ ضرورت۔ توہہ پزِ [ کھینس پتہ گارٹین ہنز کل تعداد، کھینس پتہ گارٹین ہنز تعداد ] اکھ ویکٹر واپس کرُن اگر نہٕ پورہ گارٹین روزِ، توہہ چھہِ باقی گارٹین کھینن، مگر توہہ گژھہِ وُنہِ بھوک۔ مثال: >>> کھین (((5), (6), (10)) (std::vector<long>{()11, (long) 4}) >>> کھین ((4), (8), (9) (std::vector<long>{() 12, ( (1})) >>> کھین ((1), (10), (10) (std::vector<long>{(11, (long) 0)) >>> کھین ((2), (11), (5) (std::vector<<d>{0, (long)) V: integer number of remaining carrots that you need to eat in stock: 1000) * کنٹریٹرینٹ = انٹیجر: 0 = انٹیجر: 0 انٹیجر: 0 @ تمن ہند تعداد یمہِ باقی یمہِ گارٹین گارٹین ہنز ضرورت چھہ کھینن۔\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دوٚن ویکٹر آپریٹر تہٕ آپریڈنڈس دنہٕ آمت۔ گۄڈنیُک ویکٹر چُھ بنیادی الجبرا آپریشنہٕ، تہٕ دوٚیم ویکٹر چُھ انٹیجرزُک ویکٹر۔ الجبرا اظہارٕ بنانہٕ خٲطرٕ دوٚن دیتمتن ویکٹرن ہنٛد استعمال کٔرو تہٕ امہ اظہارچ تشخیص واپس وٲتھ۔ بنیادی الجبرا آپریشن: جمع (+) گھٹاؤ (-) ضرب (*) فلور ڈویژن (//) ایکسپوننسیشن (**) مثال: آپریٹر['+'، '*'، '-'] ویکٹر = [2, 3, 4, 5] نتیجہ = 2 + 3 * 4 - 5 => نتیجہ = 9 نوٹ: آپریٹرن ویکٹرچ لمبائی چِھ آپریٹرن ویکٹر کس لمبائی برابر مائنس ون۔ آپریٹرن ویکٹر چُھ غٲر منفی انٹیجرن ہنٛد ویکٹر۔ آپریٹر ویکٹر چُھ کم کھوتہٕ کم اکھ آپریٹر آسان، تہٕ آپریٹرن ویکٹر چُک کم کھوتہٕ کم زٕ آپریٹرن چِھ آسان۔\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اگر s[i] چُھ اکھ حرف، تہٕ توہیہ چِھ اتھ پیٹھ پنن کیس تبدیل کرُن، یا بییہٕ ییہٕ برقرار تھاوُن۔ اگر سٹرنگس منٛز چُھنہٕ کنہہ حرف، سٹرنگس تبدیل کرُن۔ فنکشن گژھہٕ نتائجی سٹرنگ واپس کرٕن۔ مثالہٕ >>> حل کریں((\"1234\")) (\"4321\") >>> حل کریں((\"ab\")) (\"AB\") >>> حل کریں\"#a@C\") (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اگر اکھ سٹرنگ 'ٹیکسٹ' چُھ دِنہٕ آمُت، تہٕ ایم ڈی 5 ہیش مساوی سٹرنگ چُھ واپس کران۔ اگر 'ٹیکسٹ' اکھ خٲلی سٹرنگ چُھ، تہٕ چُھ واپس نون۔ >>> string_to_md5((\"ہیلو ورلڈ\")) \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "kas_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دوٛن مثبت انٹیجرزن a تہٕ b دنہٕ آمت، a تہٕ b درمیان چُھ ہندسن ہند تعداد بڑھنہٕ کہِ ترتیبس منز واپس کران۔ مثال کہِ طورس پیٹھ: >>> generate_integers((2), (8)) (std::vector<long>({long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]