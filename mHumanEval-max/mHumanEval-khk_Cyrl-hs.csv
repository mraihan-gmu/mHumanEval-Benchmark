task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,khk_Cyrl,hs,"--Энэ нь тодорхой хэмжээний хэмжээ юм.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> hasCloseElements [1.0,2.0,3.0] 0.5
--  False
--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3
--  True
hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold =","hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold = any (\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a /= b]","
main :: IO ()
main = do
  let candidate = hasCloseElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_1,khk_Cyrl,hs,"--Оролцох дугаарт ямар ч орон зай байхгүй.--Тус бүрээ бие даасан бүлэгүүд нь тэнцвэртэй (хүн бүрийн нээлттэй хаалттай нь зөвөөр хаагдсан) бөгөөд нэгний дотор нэг нь хоорондоо нийлдэггүй.--эдгээр бүлэгүүдийг тусдаа дараалж, тэдгээрийн жагсаалтыг буцааж өгнө. --Энэ функцын нэвтрүүлэг нь олон бүлэгтэй, холимог дугуйлуудыг агуулсан үсгийн хувьд, таны зорилго нь--  >>> separateParenGroups ""( ) (( )) (( )( ))""
--  [""()"",""(())"",""(()())""]
separateParenGroups :: String -> [String]
separateParenGroups paren_string =","separateParenGroups :: String -> [String]
separateParenGroups paren_string = go paren_string 0 [] """" []
  where
    go [] _ _ current acc = if null current then acc else acc ++ [current]
    go (x:xs) depth stack current acc
      | x == ' ' = go xs depth stack current acc
      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc
      | x == ')' =
          let newCurrent = current ++ [x]
              newDepth = depth - 1
          in if newDepth == 0
             then go xs newDepth (tail stack) """" (acc ++ [newCurrent])
             else go xs newDepth (tail stack) newCurrent acc
      | otherwise = error ""Unexpected character""","
main :: IO ()
main = do
  let candidate = separateParenGroups
  if candidate ""(()()) ((())) () ((())()())"" == [""(()())"",""((()))"",""()"",""((())()())""] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [""()"",""(())"",""((()))"",""(((())))""] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [""(()(())((())))""] then pure () else error ""assertion failed""
  if candidate ""( ) (( )) (( )( ))"" == [""()"",""(())"",""(()())""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_2,khk_Cyrl,hs,"--Тооноос арван хэсгийг буцаах. --(Халдаг хэсэг нь үргэлж 1-ээс бага байх ёстой).--болон бүтэн тооны хэсэг (үлсэлсэн тооноос бага хамгийн том бүтэн тоо) болон арванхоёрдугаар хэсэг --Энэ нь нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд нэг их тооны хувьд--  >>> truncateNumber 3.5
--  0.5
truncateNumber :: Float -> Float
truncateNumber number =","truncateNumber :: Float -> Float
truncateNumber number = number - fromIntegral (floor number)","
main :: IO ()
main = do
  let candidate = truncateNumber
  if candidate 3.5 == 0.5 then pure () else error ""assertion failed""
  if candidate 1.25 == 0.25 then pure () else error ""assertion failed""
  if candidate 123.0 == 0.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_3,khk_Cyrl,hs,"--Энэ үед функц нь True-г буцаах ёстой. Эсвэл False-г буцаах ёстой.--Таны ажил бол ямар нэг үед дансны тэнцвэр нөлөөс доош буурсан эсэхийг илрүүлэх, мөн --                                                                    --  >>> belowZero [1,2,3]
--  False
--  >>> belowZero [1,2,(-4),5]
--  True
belowZero :: [Int] -> Bool
belowZero operations =","belowZero :: [Int] -> Bool
belowZero operations = any (< 0) $ scanl (+) 0 operations","
main :: IO ()
main = do
  let candidate = belowZero
  if candidate [] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-4),5,6] == True then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error ""assertion failed""
  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_4,khk_Cyrl,hs,"--MAD = дундаж. x - x_mean.--элемент ба төв цэг (Энэ тохиолдолд дундаж): --Дундаж абсолют тайван нь  хоорондын дундаж абсолют ялгаа юм.--Энэ өгөгдлийн дунджийн орчимд.-- өгөгдсөн тооны жагсаалтын хувьд, дундаж абсолют тайван байдлыг тооцоолох--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]
--  1.0
meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers =","meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers = sum absoluteDifferences / fromIntegral (length numbers)
  where
    mean = sum numbers / fromIntegral (length numbers)
    absoluteDifferences = map (\x -> abs (x - mean)) numbers","
main :: IO ()
main = do
  let candidate = meanAbsoluteDeviation
  if candidate [1.0,2.0] == 0.5 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_5,khk_Cyrl,hs,"--∀Дэлхийн жагсаалтын дараалан гарч буй 2 элементийн хооронд ""delimeter"" тоонууд оруулна.--  >>> intersperse [] 4
--  []
--  >>> intersperse [1,2,3] 4
--  [1,4,2,4,3]
intersperse :: [Int] -> Int -> [Int]
intersperse numbers delimeter =","intersperse :: [Int] -> Int -> [Int]
intersperse [] _ = []
intersperse [x] _ = [x]
intersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","
main :: IO ()
main = do
  let candidate = intersperse
  if candidate [] 7 == [] then pure () else error ""assertion failed""
  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error ""assertion failed""
  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_6,khk_Cyrl,hs,"--Жишээ нь (() (()) нь хамгийн ихдээ хоёр түвшинд, ((())) нь гурван түвшинд ордог.--Багийн аль нэг хэсэгт хамгийн гүн гүнзгий дугуйлангийн гүнзгий түвшинг гаргана.--Энэхүү функцын нэвтрүүлэг нь хооронд нь хоорондоо хуваагдсан хаалттай дугуйлуудыг олон бүлэгээр илэрхийлдэг үсгийн тоо юм.--  >>> parseNestedParens ""(()()) ((())) () ((())()())""
--  [2,3,1,3]
parseNestedParens :: String -> [Int]
parseNestedParens paren_string =","parseNestedParens :: String -> [Int]
parseNestedParens paren_string = map maxDepth (words paren_string)
  where
    maxDepth :: String -> Int
    maxDepth = go 0 0
      where
        go :: Int -> Int -> String -> Int
        go currentDepth maxDepth [] = maxDepth
        go currentDepth maxDepth (c:cs)
          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs
          | c == ')'  = go (currentDepth - 1) maxDepth cs
          | otherwise = go currentDepth maxDepth cs","
main :: IO ()
main = do
  let candidate = parseNestedParens
  if candidate ""(()()) ((())) () ((())()())"" == [2,3,1,3] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [4] then pure () else error ""assertion failed""
  pure ()"
HumanEval_7,khk_Cyrl,hs,"-- Зөвхөн өгөгдсөн дэд үсгийн үсгийн жагсаалтыг нь филтрлэнэ.--  >>> filterBySubstring [] ""a""
--  []
--  >>> filterBySubstring [""abc"",""bacd"",""cde"",""array""] ""a""
--  [""abc"",""bacd"",""array""]
filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring =","filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring = filter (substring `isInfixOf`) strings
  where isInfixOf = isInfixOf","
main :: IO ()
main = do
  let candidate = filterBySubstring
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""aaaxxy"",""john doe"",""xxxAAA"",""xxx""] ""xx"" == [""xxx"",""aaaxxy"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""grunt"",""trumpet"",""prune"",""gruesome""] ""run"" == [""grunt"",""prune""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_8,khk_Cyrl,hs,"--Бусдын нийлбэр нь 0-тэй тэнцүү, бусдын үр дүн нь 1-тэй тэнцүү байх ёстой.--│ бүтэн тооны жагсаалтыг өгвөл, жагсаалтын бүх бүтэн тооны нийлбэр болон үр дүнгээс бүрддэг тупл буцаана.--  >>> sumProduct []
--  (0, 1)
--  >>> sumProduct [1,2,3,4]
--  (10, 24)
sumProduct :: [Int] -> (Int, Int)
sumProduct numbers =","sumProduct :: [Int] -> (Int, Int)
sumProduct numbers = (sum numbers, product numbers)","
main :: IO ()
main = do
  let candidate = sumProduct
  if candidate [] == (0, 1) then pure () else error ""assertion failed""
  if candidate [1,1,1] == (3, 1) then pure () else error ""assertion failed""
  if candidate [100,0] == (100, 0) then pure () else error ""assertion failed""
  if candidate [3,5,7] == (15, 105) then pure () else error ""assertion failed""
  if candidate [10] == (10, 10) then pure () else error ""assertion failed""
  pure ()"
HumanEval_9,khk_Cyrl,hs,"--дараалал нь.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> rollingMax [1,2,3,2,3,4,2]
--  [1,2,3,3,3,4,4]
rollingMax :: [Int] -> [Int]
rollingMax numbers =","rollingMax :: [Int] -> [Int]
rollingMax = scanl1 max","
main :: IO ()
main = do
  let candidate = rollingMax
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error ""assertion failed""
  pure ()"
HumanEval_10,khk_Cyrl,hs,"--- Палиндром суффиксээс өмнө байгаа string prefix-ийг string-ийн сүүл рүү нэмнэ.--- Тухайн үсгийн хамгийн урт палиндром болох дараах хэсгийг олох.--Алгоритмын санаа нь энгийн: --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> makePalindrome """"
--  """"
--  >>> makePalindrome ""cat""
--  ""catac""
--  >>> makePalindrome ""cata""
--  ""catac""
makePalindrome :: String -> String
makePalindrome string =","makePalindrome :: String -> String
makePalindrome string = string ++ reverse (take (length string - palindromeLength) string)
  where
    palindromeLength = longestPalindromicSuffix string

longestPalindromicSuffix :: String -> Int
longestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]

isPalindrome :: String -> Bool
isPalindrome s = s == reverse s","
main :: IO ()
main = do
  let candidate = makePalindrome
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""x"" == ""x"" then pure () else error ""assertion failed""
  if candidate ""xyz"" == ""xyzyx"" then pure () else error ""assertion failed""
  if candidate ""xyx"" == ""xyx"" then pure () else error ""assertion failed""
  if candidate ""jerry"" == ""jerryrrej"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_11,khk_Cyrl,hs,"--Эдгээр нэвтрүүлэг дээр бинар XOR гүйцэтгэж, үр дүнг ч гэсэн string болгон буцаана. -- А, б хоёр нь зөвхөн 1 болон 0-той үсэг юм.--  >>> stringXor ""010"" ""110""
--  ""100""
stringXor :: String -> String -> String
stringXor a b =","stringXor :: String -> String -> String
stringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","
main :: IO ()
main = do
  let candidate = stringXor
  if candidate ""111000"" ""101010"" == ""010010"" then pure () else error ""assertion failed""
  if candidate ""1"" ""1"" == ""0"" then pure () else error ""assertion failed""
  if candidate ""0101"" ""0000"" == ""0101"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_12,khk_Cyrl,hs,"--ижил урттай үсгийн дугаар.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> longest []
--  Just (Nothing)
--  >>> longest [""a"",""b"",""c""]
--  Just (""a"")
--  >>> longest [""a"",""bb"",""ccc""]
--  Just (""ccc"")
longest :: [String] -> Maybe String
longest strings =","longest :: [String] -> Maybe String
longest [] = Nothing
longest strings = Just $ foldl1 (\acc x -> if length x > length acc then x else acc) strings","
main :: IO ()
main = do
  let candidate = longest
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == Just (""x"") then pure () else error ""assertion failed""
  if candidate [""x"",""yyy"",""zzzz"",""www"",""kkkk"",""abc""] == Just (""zzzz"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_13,khk_Cyrl,hs,"--А, В гэсэн хоёр бүтэн тооны хамгийн их хамтарсан хуваагчийг буцаана.--  >>> greatestCommonDivisor 3 5
--  1
--  >>> greatestCommonDivisor 25 15
--  5
greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b =","greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b
  | b == 0    = a
  | otherwise = greatestCommonDivisor b (a `mod` b)","
main :: IO ()
main = do
  let candidate = greatestCommonDivisor
  if candidate 3 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 15 == 5 then pure () else error ""assertion failed""
  if candidate 49 14 == 7 then pure () else error ""assertion failed""
  if candidate 144 60 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_14,khk_Cyrl,hs,"--│ Нэвтрүүлгийн үсгийн хамгийн богинононоос хамгийн урт хүртэлх бүх өмнөх үсгийн жагсаалтыг буцаана.--  >>> allPrefixes ""abc""
--  [""a"",""ab"",""abc""]
allPrefixes :: String -> [String]
allPrefixes string =","allPrefixes :: String -> [String]
allPrefixes string = [take n string | n <- [1 .. length string]]","
main :: IO ()
main = do
  let candidate = allPrefixes
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""asdfgh"" == [""a"",""as"",""asd"",""asdf"",""asdfg"",""asdfgh""] then pure () else error ""assertion failed""
  if candidate ""WWW"" == [""W"",""WW"",""WWW""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_15,khk_Cyrl,hs,"--0-аас n хүртэлх орон зайгаар хязгаарлагдсан тоонуудыг агуулсан string-г буцаана.--  >>> stringSequence 0
--  ""0""
--  >>> stringSequence 5
--  ""0 1 2 3 4 5""
stringSequence :: Int -> String
stringSequence n =","stringSequence :: Int -> String
stringSequence n = unwords $ map show [0..n]","
main :: IO ()
main = do
  let candidate = stringSequence
  if candidate 0 == ""0"" then pure () else error ""assertion failed""
  if candidate 3 == ""0 1 2 3"" then pure () else error ""assertion failed""
  if candidate 10 == ""0 1 2 3 4 5 6 7 8 9 10"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_16,khk_Cyrl,hs,"-- Нэг үсгийн тоог авч, хэдэн өөр тэмдэгтээс бүрдэж байгааг олж мэдээрэй (хэмжээг үл харгалзан) --  >>> countDistinctCharacters ""xyzXYZ""
--  3
--  >>> countDistinctCharacters ""Jerry""
--  4
countDistinctCharacters :: String -> Int
countDistinctCharacters string =","import Data.Char (toLower)
import Data.Set (fromList, size)

countDistinctCharacters :: String -> Int
countDistinctCharacters string = size . fromList $ map toLower string","
main :: IO ()
main = do
  let candidate = countDistinctCharacters
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abcde"" == 5 then pure () else error ""assertion failed""
  if candidate ""abcdecadeCADE"" == 5 then pure () else error ""assertion failed""
  if candidate ""aaaaAAAAaaaa"" == 1 then pure () else error ""assertion failed""
  if candidate ""Jerry jERRY JeRRRY"" == 5 then pure () else error ""assertion failed""
  pure ()"
HumanEval_17,khk_Cyrl,hs,"--""Хайх"" - дөрвөн бүсийн тэмдэглэл, нэг цохилтоор үргэлжилнэ.--""ооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооо--""О"" - бүтэн тэмдэглэл, дөрвөн цохилтыг үргэлжлэнэ.--Энд домог бий:--Эцсийн биш.--Таны ажил нь энэ суваггг шинжилж, хэдэн цохилт хийхэд нийцсэн бүтэн тооны жагсаалтыг буцаах юм.--Энэхүү функц нь ASCII хэлбэрээр хөгжмийн нотойг илэрхийлсэн суваг юм.--  >>> parseMusic ""o o| .| o| o| .| .| .| .| o o""
--  [4,2,1,2,2,1,1,1,1,4,4]
parseMusic :: String -> [Int]
parseMusic music_string =","parseMusic :: String -> [Int]
parseMusic music_string = map beats (words music_string)
  where
    beats ""o"" = 4
    beats ""o|"" = 2
    beats "".|"" = 1
    beats _ = 0","
main :: IO ()
main = do
  let candidate = parseMusic
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""o o o o"" == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate "".| .| .| .|"" == [1,1,1,1] then pure () else error ""assertion failed""
  if candidate ""o| o| .| .| o o o o"" == [2,2,1,1,4,4,4,4] then pure () else error ""assertion failed""
  if candidate ""o| .| o| .| o o| o o|"" == [2,1,2,1,4,2,4,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_18,khk_Cyrl,hs,"--│Гэрсэн суваг нь эх сувагт хэдэн удаа гарч ирэхийг хайж олох. │--  >>> howManyTimes """" ""a""
--  0
--  >>> howManyTimes ""aaa"" ""a""
--  3
--  >>> howManyTimes ""aaaa"" ""aa""
--  3
howManyTimes :: String -> String -> Int
howManyTimes string substring =","howManyTimes :: String -> String -> Int
howManyTimes string substring
  | null substring = 0
  | otherwise = length . filter isPrefixOfSubstring $ tails string
  where
    isPrefixOfSubstring = isPrefixOf substring
    isPrefixOf :: Eq a => [a] -> [a] -> Bool
    isPrefixOf prefix str = prefix `isPrefixOf` str","
main :: IO ()
main = do
  let candidate = howManyTimes
  if candidate """" ""x"" == 0 then pure () else error ""assertion failed""
  if candidate ""xyxyxyx"" ""x"" == 4 then pure () else error ""assertion failed""
  if candidate ""cacacacac"" ""cac"" == 4 then pure () else error ""assertion failed""
  if candidate ""john doe"" ""john"" == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_19,khk_Cyrl,hs,"--Хамгийн багаас хамгийн том хүртэл дараалсан тоо бүхий үсгийн тоог буцаана --""Нүх"", ""нэг"", ""хоёр"", ""үч"", ""хоёр"", ""биш"", ""шүүн"", ""бороон"", ""эмэг"" болон ""хоёр"" гэсэн сонголт хүчин төгөлдөр болно. -- Ашиглалт нь 0-ээс 9-г хүртэлх тооны орон зайтай бүлэг юм.--  >>> sortNumbers ""three one five""
--  ""one three five""
sortNumbers :: String -> String
sortNumbers numbers =","import Data.List (sort)
import Data.Maybe (fromJust)
import Data.Map (Map, fromList, lookup)

sortNumbers :: String -> String
sortNumbers numbers = unwords $ map snd $ sort $ map (\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)
  where
    wordToNumber :: Map String Int
    wordToNumber = fromList [(""zero"", 0), (""one"", 1), (""two"", 2), (""three"", 3), (""four"", 4),
                             (""five"", 5), (""six"", 6), (""seven"", 7), (""eight"", 8), (""nine"", 9)]","
main :: IO ()
main = do
  let candidate = sortNumbers
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""three"" == ""three"" then pure () else error ""assertion failed""
  if candidate ""three five nine"" == ""three five nine"" then pure () else error ""assertion failed""
  if candidate ""five zero four seven nine eight"" == ""zero four five seven eight nine"" then pure () else error ""assertion failed""
  if candidate ""six five four three two one zero"" == ""zero one two three four five six"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_20,khk_Cyrl,hs,"--бусад нь, тэдгээрийг дарааллаар буцааж өгнө (хэдэнх нь бага, хэд нь их).--│ Нийтдээ 2 тооны жагсаалтаас хамгийн ойрын 2 тоог сонгож, буцааж өгнө.--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]
--  (2.0, 2.2)
--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]
--  (2.0, 2.0)
findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers =","findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)
  where
    sortedNumbers = sort numbers
    minByDiff (a1, b1) (a2, b2)
      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)
      | otherwise = (a2, b2)","
main :: IO ()
main = do
  let candidate = findClosestElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_21,khk_Cyrl,hs,"--Хамгийн бага тоо 0 болж, хамгийн том нь 1 болно.--│ тооны жагсаалтыг өгөөд (ийм дундаа хоёр элементийн), энэ жагсаалтад хязгаарлагдмал хувиргалт хэрэглэнэ, │--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]
--  [0.0,0.25,0.5,0.75,1.0]
rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers =","rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers = map (\x -> (x - minVal) / range) numbers
  where
    minVal = minimum numbers
    maxVal = maximum numbers
    range = maxVal - minVal","
main :: IO ()
main = do
  let candidate = rescaleToUnit
  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error ""assertion failed""
  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error ""assertion failed""
  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  pure ()"
HumanEval_23,khk_Cyrl,hs,"--│ өгөгдсөн string-ийн урт буцаах--  >>> strlen """"
--  0
--  >>> strlen ""abc""
--  3
strlen :: String -> Int
strlen string =","strlen :: String -> Int
strlen string = length string","
main :: IO ()
main = do
  let candidate = strlen
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""x"" == 1 then pure () else error ""assertion failed""
  if candidate ""asdasnakj"" == 9 then pure () else error ""assertion failed""
  pure ()"
HumanEval_24,khk_Cyrl,hs,"-- n тооны хувьд n-г тэгш хувааж болох хамгийн том тоог олох, n-ээс бага тоог олох--  >>> largestDivisor 15
--  5
largestDivisor :: Int -> Int
largestDivisor n =","largestDivisor :: Int -> Int
largestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = largestDivisor
  if candidate 3 == 1 then pure () else error ""assertion failed""
  if candidate 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 == 5 then pure () else error ""assertion failed""
  if candidate 100 == 50 then pure () else error ""assertion failed""
  if candidate 49 == 7 then pure () else error ""assertion failed""
  pure ()"
HumanEval_25,khk_Cyrl,hs,"--Хэвлэх тоо нь бүх хүчин зүйлсийн үр дүнтэй тэнцүү байх ёстой.--Оролцогч бүр нь оруулах түвшинд хэдэн удаа гарч ирснийг нь тооцно.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> factorize 8
--  [2,2,2]
--  >>> factorize 25
--  [5,5]
--  >>> factorize 70
--  [2,5,7]
factorize :: Int -> [Int]
factorize n =","factorize :: Int -> [Int]
factorize n = factorize' n 2
  where
    factorize' 1 _ = []
    factorize' m f
      | m `mod` f == 0 = f : factorize' (m `div` f) f
      | otherwise      = factorize' m (f + 1)","
main :: IO ()
main = do
  let candidate = factorize
  if candidate 2 == [2] then pure () else error ""assertion failed""
  if candidate 4 == [2,2] then pure () else error ""assertion failed""
  if candidate 8 == [2,2,2] then pure () else error ""assertion failed""
  if candidate 57 == [3,19] then pure () else error ""assertion failed""
  if candidate 3249 == [3,3,19,19] then pure () else error ""assertion failed""
  if candidate 185193 == [3,3,3,19,19,19] then pure () else error ""assertion failed""
  if candidate 20577 == [3,19,19,19] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_26,khk_Cyrl,hs,"--Элементүүдийн дарааллыг оруулсантай адил байлгана.--│ бүтэн тооны жагсаалтаас нэгээс илүү удаа гарч байгаа бүх элементийг хасах.--  >>> removeDuplicates [1,2,3,2,4]
--  [1,3,4]
removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers =","removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers = filter (\x -> count x numbers == 1) numbers
  where
    count x = length . filter (== x)","
main :: IO ()
main = do
  let candidate = removeDuplicates
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error ""assertion failed""
  pure ()"
HumanEval_27,khk_Cyrl,hs,"-- Бичил үсгийг том, том үсгийг бага үсгээр өөрчлөх.--  >>> flipCase ""Hello""
--  ""hELLO""
flipCase :: String -> String
flipCase string =","flipCase :: String -> String
flipCase = map flipChar
  where
    flipChar c
      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)
      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)
      | otherwise = c","
main :: IO ()
main = do
  let candidate = flipCase
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hello!"" == ""hELLO!"" then pure () else error ""assertion failed""
  if candidate ""These violent delights have violent ends"" == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_28,khk_Cyrl,hs,"-- Шилүүдийн жагсаалтыг нэг л шүлэгт нэгтгэх--  >>> concatenate []
--  """"
--  >>> concatenate [""a"",""b"",""c""]
--  ""abc""
concatenate :: [String] -> String
concatenate strings =","concatenate :: [String] -> String
concatenate strings = concat strings","
main :: IO ()
main = do
  let candidate = concatenate
  if candidate [] == """" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == ""xyz"" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z"",""w"",""k""] == ""xyzwk"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_29,khk_Cyrl,hs,"-- Зөвхөн өгөгдсөн префиксээр эхлэх string-ийн жагсаалтыг филтрлэнэ.--  >>> filterByPrefix [] ""a""
--  []
--  >>> filterByPrefix [""abc"",""bcd"",""cde"",""array""] ""a""
--  [""abc"",""array""]
filterByPrefix :: [String] -> String -> [String]
filterByPrefix strings prefix =","filterByPrefix strings prefix = filter (isPrefixOf prefix) strings
  where
    isPrefixOf pfx str = take (length pfx) str == pfx","
main :: IO ()
main = do
  let candidate = filterByPrefix
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_30,khk_Cyrl,hs,"--Зөвхөн эерэг тоонуудыг л буцаана.--  >>> getPositive [(-1),2,(-4),5,6]
--  [2,5,6]
--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  [5,3,2,3,9,123,1]
getPositive :: [Int] -> [Int]
getPositive l =","getPositive :: [Int] -> [Int]
getPositive l = filter (> 0) l","
main :: IO ()
main = do
  let candidate = getPositive
  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error ""assertion failed""
  if candidate [(-1),(-2)] == [] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_31,khk_Cyrl,hs,"-- Хэрэв өгөгдсөн тоо нь нэгдүгээр тоо бол үнэн, эсвэл буруу гэж буцаана.--  >>> isPrime 6
--  False
--  >>> isPrime 101
--  True
--  >>> isPrime 11
--  True
--  >>> isPrime 13441
--  True
--  >>> isPrime 61
--  True
--  >>> isPrime 4
--  False
--  >>> isPrime 1
--  False
isPrime :: Int -> Bool
isPrime n =","isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = not (any (\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","
main :: IO ()
main = do
  let candidate = isPrime
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 101 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 13441 == True then pure () else error ""assertion failed""
  if candidate 61 == True then pure () else error ""assertion failed""
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 1 == False then pure () else error ""assertion failed""
  if candidate 5 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 17 == True then pure () else error ""assertion failed""
  if candidate 85 == False then pure () else error ""assertion failed""
  if candidate 77 == False then pure () else error ""assertion failed""
  if candidate 255379 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_33,khk_Cyrl,hs,"--Энэ нь l-ийн харьцуулахад тохиромжтой, гэхдээ ангилагдсан.--l' нь 3 -ээр хувана гэж байхгүй индексүүд дээр l-тэй ижил байдаг бол 3 -ээр хувана гэж байгаа индексүүд дээр түүний үнэ цэнэ ижил байдаг.--Энэ функц нь l жагсаалтыг авч, ийм төрлийн l жагсаалтыг эргүүлнэ.--  >>> sortThird [1,2,3]
--  [1,2,3]
--  >>> sortThird [5,6,3,4,8,9,2]
--  [2,6,3,4,8,9,5]
sortThird :: [Int] -> [Int]
sortThird l =","sortThird :: [Int] -> [Int]
sortThird l = map selectElem indexed
  where
    indexed = zip [0..] l
    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]
    sortedThirdElems = sortedElems thirdIndicesElems
    sortedElems = id -- or List.sort if imported
    selectElem (i, x)
      | i `mod` 3 == 0 = head sortedThirdElems
      | otherwise = x
    replaceSortedElem xs sorted = map selectElem indexed
      where
        replaceElem i (x:xs)
          | i == 0 = x:xs
          | otherwise = replaceElem (i - 1) xs
        selectElem (i, x)
          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)
          | otherwise = x","
main :: IO ()
main = do
  let candidate = sortThird
  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error ""assertion failed""
  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error ""assertion failed""
  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error ""assertion failed""
  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_34,khk_Cyrl,hs,"--│ Тодорхой жагсаалтын нэгдсэн элементүүдийг буцаах--  >>> unique [5,3,5,2,3,3,9,0,123]
--  [0,2,3,5,9,123]
unique :: [Int] -> [Int]
unique l =","unique :: [Int] -> [Int]
unique l = sort $ nub l
  where
    -- | Remove duplicate elements from a list.
    nub :: (Eq a) => [a] -> [a]
    nub [] = []
    nub (x:xs) = x : nub (filter (/= x) xs)

    -- | Sort a list of elements (using QuickSort algorithm).
    sort :: (Ord a) => [a] -> [a]
    sort [] = []
    sort (x:xs) =
      let smallerSorted = sort [a | a <- xs, a <= x]
          biggerSorted = sort [a | a <- xs, a > x]
      in  smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = unique
  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error ""assertion failed""
  pure ()"
HumanEval_35,khk_Cyrl,hs,"--│ жагсаалтын хамгийн их элементийг буцаана.--  >>> maxElement [1,2,3]
--  3
--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  123
maxElement :: [Int] -> Int
maxElement l =","maxElement :: [Int] -> Int
maxElement [] = error ""List cannot be empty""
maxElement (x:xs) = maxElementHelper xs x
  where
    maxElementHelper [] currentMax = currentMax
    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","
main :: IO ()
main = do
  let candidate = maxElement
  if candidate [1,2,3] == 3 then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error ""assertion failed""
  pure ()"
HumanEval_36,khk_Cyrl,hs,"--│ 11 эсвэл 13-д хуваагдах n-ээс бага бүтэн тооны дотор 7 гэсэн тоог хэдэн удаа гаргана.--  >>> fizzBuzz 50
--  0
--  >>> fizzBuzz 78
--  2
--  >>> fizzBuzz 79
--  3
fizzBuzz :: Int -> Int
fizzBuzz n =","fizzBuzz :: Int -> Int
fizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","
main :: IO ()
main = do
  let candidate = fizzBuzz
  if candidate 50 == 0 then pure () else error ""assertion failed""
  if candidate 78 == 2 then pure () else error ""assertion failed""
  if candidate 79 == 3 then pure () else error ""assertion failed""
  if candidate 100 == 3 then pure () else error ""assertion failed""
  if candidate 200 == 6 then pure () else error ""assertion failed""
  if candidate 4000 == 192 then pure () else error ""assertion failed""
  if candidate 10000 == 639 then pure () else error ""assertion failed""
  if candidate 100000 == 8026 then pure () else error ""assertion failed""
  pure ()"
HumanEval_37,khk_Cyrl,hs,"--l-ийн тэгш индексийн үнэд нийцсэн, гэхдээ ангилагдсан.--l' нь l-тэй ижил төстэй байдаг бол тэгш тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо--Энэ функц нь l жагсаалтыг авч, ийм төрлийн l жагсаалтыг буцааж өгнө.--  >>> sortEven [1,2,3]
--  [1,2,3]
--  >>> sortEven [5,6,3,4]
--  [3,6,5,4]
sortEven :: [Int] -> [Int]
sortEven l =","sortEven :: [Int] -> [Int]
sortEven l = merge odds sortedEvens
  where
    (odds, evens) = partitionList l
    sortedEvens = sort evens

    partitionList :: [Int] -> ([Int], [Int])
    partitionList [] = ([], [])
    partitionList [x] = ([x], [])
    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)
      where
        (xsOdds, xsEvens) = partitionList xs

    merge :: [Int] -> [Int] -> [Int]
    merge [] ys = ys
    merge (x:xs) [] = x:xs
    merge (x:xs) (y:ys) = x:y:merge xs ys","
main :: IO ()
main = do
  let candidate = sortEven
  if candidate [1,2,3] == [1,2,3] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error ""assertion failed""
  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_39,khk_Cyrl,hs,"--prime_fib нь n-р тоог эргүүлнэ. Энэ нь Фибоначчигийн тоо бөгөөд бас анхны тоо юм.--  >>> primeFib 1
--  2
--  >>> primeFib 2
--  3
--  >>> primeFib 3
--  5
--  >>> primeFib 4
--  13
--  >>> primeFib 5
--  89
primeFib :: Int -> Int
primeFib n =","primeFib :: Int -> Int
primeFib n = primeFibs !! (n - 1)
  where
    primeFibs = filter isPrime fibs
    fibs = map fst $ iterate (\(a, b) -> (b, a + b)) (0, 1)

isPrime :: Int -> Bool
isPrime k
  | k < 2 = False
  | k == 2 = True
  | even k = False
  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]
  where
    upperLimit = floor . sqrt $ fromIntegral k","
main :: IO ()
main = do
  let candidate = primeFib
  if candidate 1 == 2 then pure () else error ""assertion failed""
  if candidate 2 == 3 then pure () else error ""assertion failed""
  if candidate 3 == 5 then pure () else error ""assertion failed""
  if candidate 4 == 13 then pure () else error ""assertion failed""
  if candidate 5 == 89 then pure () else error ""assertion failed""
  if candidate 6 == 233 then pure () else error ""assertion failed""
  if candidate 7 == 1597 then pure () else error ""assertion failed""
  if candidate 8 == 28657 then pure () else error ""assertion failed""
  if candidate 9 == 514229 then pure () else error ""assertion failed""
  if candidate 10 == 433494437 then pure () else error ""assertion failed""
  pure ()"
HumanEval_40,khk_Cyrl,hs,"--0-д нийлүүлж, өөр тохиолдолд False болно.-- гэж нэрлэгдэх 3 өөр элемент байгаа бол True-г буцаана.--Triple_sum_to_zero нь бүтэн тооны жагсаалтыг оруулж ирдэг.--  >>> triplesSumToZero [1,3,5,0]
--  False
--  >>> triplesSumToZero [1,3,(-2),1]
--  True
--  >>> triplesSumToZero [1,2,3,7]
--  False
--  >>> triplesSumToZero [2,4,(-5),3,9,7]
--  True
--  >>> triplesSumToZero [1]
--  False
triplesSumToZero :: [Int] -> Bool
triplesSumToZero l =","triplesSumToZero :: [Int] -> Bool
triplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]
  where
    tails [] = []
    tails xs@(_:xs') = xs : tails xs'","
main :: IO ()
main = do
  let candidate = triplesSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-1)] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [1,2,5,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,9,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-100)] == False then pure () else error ""assertion failed""
  if candidate [100,3,5,(-100)] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_41,khk_Cyrl,hs,"--Энэ функц нь иймэрхүү мөргөлдөөнүүдийн тоог гаргадаг.--Тэд хоорондоо мөргөлдөхгүй мэт эргэлдэж байна.--Гэхдээ машин нь маш хүчтэй, хүчтэй байдаг. Тиймээс тэд хөдөлгөөнд үргэлжлэх боломжтой.--зүүнээс баруун руу явж байгаа машин баруун зүүн рүү явж байгаа машиныг цохих үед.--Бүх машин ижил хурдтай явж байна. Хоёр машин мөргөлдөж байна гэж ярьдаг.--Хоёр баг машин нь эхлээд маш хол явж байна.--n машин нь зүүнээс баруун руу явж байна.----Тэгээд төгс тэгш, хязгааргүй урт шугамтай зам гэж төсөөл.carRaceCollision :: Int -> Int
carRaceCollision n =","carRaceCollision :: Int -> Int
carRaceCollision n = n","
main :: IO ()
main = do
  let candidate = carRaceCollision
  if candidate 2 == 4 then pure () else error ""assertion failed""
  if candidate 3 == 9 then pure () else error ""assertion failed""
  if candidate 4 == 16 then pure () else error ""assertion failed""
  if candidate 8 == 64 then pure () else error ""assertion failed""
  if candidate 10 == 100 then pure () else error ""assertion failed""
  pure ()"
HumanEval_42,khk_Cyrl,hs,"--Элементүүд нь 1 -ээр нэмэгдсэн жагсаалтыг буцаана.--  >>> incrList [1,2,3]
--  [2,3,4]
--  >>> incrList [5,3,5,2,3,3,9,0,123]
--  [6,4,6,3,4,4,10,1,124]
incrList :: [Int] -> [Int]
incrList l =","incrList :: [Int] -> [Int]
incrList l = map (+1) l","
main :: IO ()
main = do
  let candidate = incrList
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [4,3,2] then pure () else error ""assertion failed""
  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error ""assertion failed""
  pure ()"
HumanEval_43,khk_Cyrl,hs,"--0-д нийлүүлж, өөр тохиолдолд False болно.-- гэж нэрлэгдэх хоёр өөр элемент байгаа бол True-г буцаана.--Pairs_sum_to_zero нь бүтэн тооны жагсаалтыг оруулж ирдэг.--  >>> pairsSumToZero [1,3,5,0]
--  False
--  >>> pairsSumToZero [1,3,(-2),1]
--  False
--  >>> pairsSumToZero [1,2,3,7]
--  False
--  >>> pairsSumToZero [2,4,(-5),3,5,7]
--  True
--  >>> pairsSumToZero [1]
--  False
pairsSumToZero :: [Int] -> Bool
pairsSumToZero l =","pairsSumToZero :: [Int] -> Bool
pairsSumToZero l = any (\x -> -x `elem` l) l && (length l > 1)","
main :: IO ()
main = do
  let candidate = pairsSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,5,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_44,khk_Cyrl,hs,"--үндсэн тоо нь 10-аас бага.--хөрвүүлэлтийн дараах string төлөөллийг буцааж өгнө.-- Хөрсний тоо х-ийн тооны суурийг тооны суурийг болгон өөрчлөх.--  >>> changeBase 8 3
--  ""22""
--  >>> changeBase 8 2
--  ""1000""
--  >>> changeBase 7 2
--  ""111""
changeBase :: Int -> Int -> String
changeBase x base =","changeBase :: Int -> Int -> String
changeBase x base
  | x < base  = show x
  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","
main :: IO ()
main = do
  let candidate = changeBase
  if candidate 8 3 == ""22"" then pure () else error ""assertion failed""
  if candidate 9 3 == ""100"" then pure () else error ""assertion failed""
  if candidate 234 2 == ""11101010"" then pure () else error ""assertion failed""
  if candidate 16 2 == ""10000"" then pure () else error ""assertion failed""
  if candidate 8 2 == ""1000"" then pure () else error ""assertion failed""
  if candidate 7 2 == ""111"" then pure () else error ""assertion failed""
  if candidate 2 3 == ""2"" then pure () else error ""assertion failed""
  if candidate 3 4 == ""3"" then pure () else error ""assertion failed""
  if candidate 4 5 == ""4"" then pure () else error ""assertion failed""
  if candidate 5 6 == ""5"" then pure () else error ""assertion failed""
  if candidate 6 7 == ""6"" then pure () else error ""assertion failed""
  if candidate 7 8 == ""7"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_45,khk_Cyrl,hs,"-- Гурван талын талын урт, өндөр эргэлтийн талбайг авч үзвэл--  >>> triangleArea 5 3
--  7.5
triangleArea :: Int -> Int -> Float
triangleArea a h =","triangleArea :: Int -> Int -> Float
triangleArea a h = 0.5 * fromIntegral a * fromIntegral h","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 5 3 == 7.5 then pure () else error ""assertion failed""
  if candidate 2 2 == 2.0 then pure () else error ""assertion failed""
  if candidate 10 8 == 40.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_46,khk_Cyrl,hs,"--fib4 тооны дарааллын n-р элементийг үр дүнтэй тооцох функцийг бичих. Рекурсийг ашиглахгүй. --fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --Fib4 тооны дарааллын дараалал нь Фибоначчигийн дарааллын нэгэн адил дараалал бөгөөд дараах байдлаар тодорхойлогддог:--  >>> fib4 5
--  4
--  >>> fib4 6
--  8
--  >>> fib4 7
--  14
fib4 :: Int -> Int
fib4 n =","fib4 :: Int -> Int
fib4 n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 2
  | n == 3 = 0
  | otherwise = iter 0 0 2 0 n
  where
    iter a b c d 4 = a + b + c + d
    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","
main :: IO ()
main = do
  let candidate = fib4
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 28 then pure () else error ""assertion failed""
  if candidate 10 == 104 then pure () else error ""assertion failed""
  if candidate 12 == 386 then pure () else error ""assertion failed""
  pure ()"
HumanEval_47,khk_Cyrl,hs,"--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> median [3,1,2,4,5]
--  3.0
--  >>> median [(-10),4,6,1000,10,20]
--  15.0
median :: [Int] -> Float
median l =","median :: [Int] -> Float
median l 
  | odd n     = fromIntegral $ sorted !! mid
  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) / 2
  where
    sorted = sort l
    n = length l
    mid = n `div` 2
    sort = sortBy compare","
main :: IO ()
main = do
  let candidate = median
  if candidate [3,1,2,4,5] == 3.0 then pure () else error ""assertion failed""
  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error ""assertion failed""
  if candidate [5] == 5.0 then pure () else error ""assertion failed""
  if candidate [6,5] == 5.5 then pure () else error ""assertion failed""
  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_48,khk_Cyrl,hs,"-- өгөгдсөн string нь palindrome эсэхийг шалгана.--  >>> isPalindrome """"
--  True
--  >>> isPalindrome ""aba""
--  True
--  >>> isPalindrome ""aaaaa""
--  True
--  >>> isPalindrome ""zbcd""
--  False
isPalindrome :: String -> Bool
isPalindrome text =","isPalindrome :: String -> Bool
isPalindrome text = text == reverse text","
main :: IO ()
main = do
  let candidate = isPalindrome
  if candidate """" == True then pure () else error ""assertion failed""
  if candidate ""aba"" == True then pure () else error ""assertion failed""
  if candidate ""aaaaa"" == True then pure () else error ""assertion failed""
  if candidate ""zbcd"" == False then pure () else error ""assertion failed""
  if candidate ""xywyx"" == True then pure () else error ""assertion failed""
  if candidate ""xywyz"" == False then pure () else error ""assertion failed""
  if candidate ""xywzx"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_49,khk_Cyrl,hs,"--2^n modulo p-г буцааж өгнө.--  >>> modp 3 5
--  3
--  >>> modp 1101 101
--  2
--  >>> modp 0 101
--  1
--  >>> modp 3 11
--  8
--  >>> modp 100 101
--  1
modp :: Int -> Int -> Int
modp n p =","modp :: Int -> Int -> Int
modp n p = powMod 2 n p

powMod :: Int -> Int -> Int -> Int
powMod base exp modulus
  | modulus == 1 = 0
  | exp == 0     = 1
  | exp == 1     = base `mod` modulus
  | otherwise    = if odd exp
                   then (base * halfExp * halfExp) `mod` modulus
                   else (halfExp * halfExp) `mod` modulus
  where
    halfExp = powMod base (exp `div` 2) modulus","
main :: IO ()
main = do
  let candidate = modp
  if candidate 3 5 == 3 then pure () else error ""assertion failed""
  if candidate 1101 101 == 2 then pure () else error ""assertion failed""
  if candidate 0 101 == 1 then pure () else error ""assertion failed""
  if candidate 3 11 == 8 then pure () else error ""assertion failed""
  if candidate 100 101 == 1 then pure () else error ""assertion failed""
  if candidate 30 5 == 4 then pure () else error ""assertion failed""
  if candidate 31 5 == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_51,khk_Cyrl,hs,"--remove_vowels нь үсэггүй үсэг авч, үсэггүй үсэг буцаан өгдөг функц юм.--  >>> removeVowels """"
--  """"
--  >>> removeVowels ""abcdef""
--  ""bcdf""
--  >>> removeVowels ""aaaaa""
--  """"
--  >>> removeVowels ""aaBAA""
--  ""B""
--  >>> removeVowels ""zbcd""
--  ""zbcd""
removeVowels :: String -> String
removeVowels text =","removeVowels :: String -> String
removeVowels text = filter (`notElem` ""aeiouAEIOU"") text","
main :: IO ()
main = do
  let candidate = removeVowels
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""abcdef
ghijklm"" == ""bcdf
ghjklm"" then pure () else error ""assertion failed""
  if candidate ""fedcba"" == ""fdcb"" then pure () else error ""assertion failed""
  if candidate ""eeeee"" == """" then pure () else error ""assertion failed""
  if candidate ""acBAA"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""EcBOO"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""ybcd"" == ""ybcd"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_52,khk_Cyrl,hs,"--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> belowThreshold [1,2,4,10] 100
--  True
--  >>> belowThreshold [1,20,4,10] 5
--  False
belowThreshold :: [Int] -> Int -> Bool
belowThreshold l t =",belowThreshold l t = all (< t) l,"
main :: IO ()
main = do
  let candidate = belowThreshold
  if candidate [1,2,4,10] 100 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 5 == False then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 21 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 22 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 11 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_53,khk_Cyrl,hs,"--X, y гэсэн хоёр тоог нэмнэ.--  >>> add 2 3
--  5
--  >>> add 5 7
--  12
add :: Int -> Int -> Int
add x y =","add :: Int -> Int -> Int
add x y = x + y","
main :: IO ()
main = do
  let candidate = add
  if candidate 0 1 == 1 then pure () else error ""assertion failed""
  if candidate 1 0 == 1 then pure () else error ""assertion failed""
  if candidate 2 3 == 5 then pure () else error ""assertion failed""
  if candidate 5 7 == 12 then pure () else error ""assertion failed""
  if candidate 7 5 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_54,khk_Cyrl,hs,"--│ │ хоёр үг ижил тэмдэгттэй эсэхийг шалгана. │--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc""
--  True
--  >>> sameChars ""abcd"" ""dddddddabc""
--  True
--  >>> sameChars ""dddddddabc"" ""abcd""
--  True
--  >>> sameChars ""eabcd"" ""dddddddabc""
--  False
--  >>> sameChars ""abcd"" ""dddddddabce""
--  False
--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc""
--  False
sameChars :: String -> String -> Bool
sameChars s0 s1 =","import Data.List (nub, sort)

sameChars :: String -> String -> Bool
sameChars s0 s1 = sort (nub s0) == sort (nub s1)","
main :: IO ()
main = do
  let candidate = sameChars
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" == True then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabc"" == True then pure () else error ""assertion failed""
  if candidate ""dddddddabc"" ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""eabcd"" ""dddddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabcf"" == False then pure () else error ""assertion failed""
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""aabb"" ""aaccc"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_55,khk_Cyrl,hs,"--Фибоначчийн n-р тоог буцаана.--  >>> fib 10
--  55
--  >>> fib 1
--  1
--  >>> fib 8
--  21
fib :: Int -> Int
fib n =","fib :: Int -> Int
fib n = fibHelper 0 1 n
  where
    fibHelper a _ 0 = a
    fibHelper a b n = fibHelper b (a + b) (n - 1)","
main :: IO ()
main = do
  let candidate = fib
  if candidate 10 == 55 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 8 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 89 then pure () else error ""assertion failed""
  if candidate 12 == 144 then pure () else error ""assertion failed""
  pure ()"
HumanEval_56,khk_Cyrl,hs,"--Хэрэв нээлт хийх бүлэгт хаалтын бүлэгтэй холбогдох бол True гэж буцаана.--""<"" ба "">"" гэсэн үсгийн дугаар юм.--  >>> correctBracketing ""<""
--  False
--  >>> correctBracketing ""<>""
--  True
--  >>> correctBracketing ""<<><>>""
--  True
--  >>> correctBracketing ""><<>""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBrackets brackets 0 == 0

checkBrackets :: String -> Int -> Int
checkBrackets [] n = n
checkBrackets (x:xs) n
  | n < 0 = -1
  | x == '<' = checkBrackets xs (n + 1)
  | x == '>' = checkBrackets xs (n - 1)
  | otherwise = checkBrackets xs n","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""<>"" == True then pure () else error ""assertion failed""
  if candidate ""<<><>>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<<><><>><>><<><><<>>>"" == True then pure () else error ""assertion failed""
  if candidate ""<<<><>>>>"" == False then pure () else error ""assertion failed""
  if candidate ""><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<"" == False then pure () else error ""assertion failed""
  if candidate ""<<<<"" == False then pure () else error ""assertion failed""
  if candidate "">"" == False then pure () else error ""assertion failed""
  if candidate ""<<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>>><>"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_57,khk_Cyrl,hs,"--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> monotonic [1,2,4,20]
--  True
--  >>> monotonic [1,20,4,10]
--  False
--  >>> monotonic [4,1,0,(-10)]
--  True
monotonic :: [Int] -> Bool
monotonic l =","monotonic :: [Int] -> Bool
monotonic l = increasing l || decreasing l
  where
    increasing xs = all (uncurry (<=)) (zip xs (tail xs))
    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","
main :: IO ()
main = do
  let candidate = monotonic
  if candidate [1,2,4,10] == True then pure () else error ""assertion failed""
  if candidate [1,2,4,20] == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] == False then pure () else error ""assertion failed""
  if candidate [4,1,0,(-10)] == True then pure () else error ""assertion failed""
  if candidate [4,1,1,0] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,2,5,60] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,60] == True then pure () else error ""assertion failed""
  if candidate [9,9,9,9] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_58,khk_Cyrl,hs,"--│ Хоёр жагсаалтын нэгдсэн элементүүдийг ангилан буцаах.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]
--  [1,5,653]
--  >>> common [5,3,2,8] [3,2]
--  [2,3]
common :: [Int] -> [Int] -> [Int]
common l1 l2 =","common :: [Int] -> [Int] -> [Int]
common l1 l2 = uniqueSortedCommon
  where
    commonElements = filter (`elem` l2) l1
    uniqueCommon = removeDuplicates commonElements
    uniqueSortedCommon = sort uniqueCommon

    removeDuplicates :: [Int] -> [Int]
    removeDuplicates = foldr (\x seen -> if x `elem` seen then seen else x : seen) []

    sort :: [Int] -> [Int]
    sort [] = []
    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)
      where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs","
main :: IO ()
main = do
  let candidate = common
  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error ""assertion failed""
  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_59,khk_Cyrl,hs,"--Хамгийн том n-ийн анхны хүчин зүйлсийг буцаана. n > 1 гэж үзвэл энэ нь анхны тоо биш.--  >>> largestPrimeFactor 13195
--  29
--  >>> largestPrimeFactor 2048
--  2
largestPrimeFactor :: Int -> Int
largestPrimeFactor n =","largestPrimeFactor :: Int -> Int
largestPrimeFactor n = helper n 2
  where
    helper n factor
      | factor * factor > n = n
      | n `mod` factor == 0 = helper (n `div` factor) factor
      | otherwise = helper n (factor + 1)","
main :: IO ()
main = do
  let candidate = largestPrimeFactor
  if candidate 15 == 5 then pure () else error ""assertion failed""
  if candidate 27 == 3 then pure () else error ""assertion failed""
  if candidate 63 == 7 then pure () else error ""assertion failed""
  if candidate 330 == 11 then pure () else error ""assertion failed""
  if candidate 13195 == 29 then pure () else error ""assertion failed""
  pure ()"
HumanEval_60,khk_Cyrl,hs,"--Sum_to_n нь 1 -ээс n хүртэлх тоонуудыг нийлүүлэх функц юм.--  >>> sumToN 30
--  465
--  >>> sumToN 100
--  5050
--  >>> sumToN 5
--  15
--  >>> sumToN 10
--  55
--  >>> sumToN 1
--  1
sumToN :: Int -> Int
sumToN n =","sumToN :: Int -> Int
sumToN n = sum [1..n]","
main :: IO ()
main = do
  let candidate = sumToN
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 66 then pure () else error ""assertion failed""
  if candidate 30 == 465 then pure () else error ""assertion failed""
  if candidate 100 == 5050 then pure () else error ""assertion failed""
  pure ()"
HumanEval_61,khk_Cyrl,hs,"--Хэрэв нээлт хийх бүлэгт хаалтын бүлэгтэй холбогдох бол True гэж буцаана.-- нь ""("" болон """") гэсэн үсгийн үсэг юм.--  >>> correctBracketing ""(""
--  False
--  >>> correctBracketing ""()""
--  True
--  >>> correctBracketing ""(()())""
--  True
--  >>> correctBracketing "")(()""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBalance brackets 0
  where
    checkBalance [] 0 = True
    checkBalance [] _ = False
    checkBalance (x:xs) n
      | x == '('  = checkBalance xs (n + 1)
      | x == ')' && n > 0 = checkBalance xs (n - 1)
      | otherwise = False","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""()"" == True then pure () else error ""assertion failed""
  if candidate ""(()())"" == True then pure () else error ""assertion failed""
  if candidate ""()()(()())()"" == True then pure () else error ""assertion failed""
  if candidate ""()()((()()())())(()()(()))"" == True then pure () else error ""assertion failed""
  if candidate ""((()())))"" == False then pure () else error ""assertion failed""
  if candidate "")(()"" == False then pure () else error ""assertion failed""
  if candidate ""("" == False then pure () else error ""assertion failed""
  if candidate ""(((("" == False then pure () else error ""assertion failed""
  if candidate "")"" == False then pure () else error ""assertion failed""
  if candidate ""(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())())(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())()))()"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_62,khk_Cyrl,hs,"--Энэ олон үсгийн хослуудыг ижил хэлбэрээр буцаана.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --X нь олон үсгийн тооны тооцол юм.--  >>> derivative [3,1,2,4,5]
--  [1,4,12,20]
--  >>> derivative [1,2,3]
--  [2,6]
derivative :: [Int] -> [Int]
derivative xs =","derivative :: [Int] -> [Int]
derivative xs = zipWith (*) (tail xs) [1..]","
main :: IO ()
main = do
  let candidate = derivative
  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,6] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [2,2] then pure () else error ""assertion failed""
  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error ""assertion failed""
  if candidate [1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_63,khk_Cyrl,hs,"--fibfib тооны дарааллын n-р элементийг үр дүнтэй тооцох функцийг бичих. --fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).--fib fib ((2) == 1 --fib fib ((1) == 0 --fib fib ((0) == 0 --FibFib тооны дарааллын дараалал нь Fibbonacci дарааллын нэгэн адил дараалал бөгөөд дараах байдлаар тодорхойлогддог:--  >>> fibfib 1
--  0
--  >>> fibfib 5
--  4
--  >>> fibfib 8
--  24
fibfib :: Int -> Int
fibfib n =","fibfib :: Int -> Int
fibfib n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 1
  | otherwise = fibs !! n
  where
    fibs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","
main :: IO ()
main = do
  let candidate = fibfib
  if candidate 2 == 1 then pure () else error ""assertion failed""
  if candidate 1 == 0 then pure () else error ""assertion failed""
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 24 then pure () else error ""assertion failed""
  if candidate 10 == 81 then pure () else error ""assertion failed""
  if candidate 12 == 274 then pure () else error ""assertion failed""
  if candidate 14 == 927 then pure () else error ""assertion failed""
  pure ()"
HumanEval_64,khk_Cyrl,hs,"--Жишээ нь:--Үг үгний төгсгөлд байх үед л.--Энэ тохиолдолд ""a"", ""e"", ""i"", ""o"", ""u"" гэсэн өнгөтэй.--үг оруулж, үсгийн үсэгний тоог буцааж өгдөг.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> vowelsCount ""abcde""
--  2
--  >>> vowelsCount ""ACEDY""
--  3
vowelsCount :: String -> Int
vowelsCount s =","vowelsCount :: String -> Int
vowelsCount s = length $ filter isVowel $ zip s [1..]
  where
    isVowel (c, pos) =
      let lowercaseC = toLower c
          isRegularVowel = lowercaseC `elem` ""aeiou""
          isLastCharY = lowercaseC == 'y' && pos == length s
      in isRegularVowel || isLastCharY","
main :: IO ()
main = do
  let candidate = vowelsCount
  if candidate ""abcde"" == 2 then pure () else error ""assertion failed""
  if candidate ""Alone"" == 3 then pure () else error ""assertion failed""
  if candidate ""key"" == 2 then pure () else error ""assertion failed""
  if candidate ""bye"" == 1 then pure () else error ""assertion failed""
  if candidate ""keY"" == 2 then pure () else error ""assertion failed""
  if candidate ""bYe"" == 1 then pure () else error ""assertion failed""
  if candidate ""ACEDY"" == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_65,khk_Cyrl,hs,"--Хэрэв shift > тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо--үр дүнг дарааллаар буцаана. --X бүтэн тооны тоонуудыг тойрог замаар шилжүүлэн, шилжилтээр шилжих.--  >>> circularShift 12 1
--  ""21""
--  >>> circularShift 12 2
--  ""12""
circularShift :: Int -> Int -> String
circularShift x shift =","circularShift :: Int -> Int -> String
circularShift x shift =
  let digits = show x
      len = length digits
      effectiveShift = shift `mod` len
  in if shift > len
     then reverse digits
     else let (begin, end) = splitAt (len - effectiveShift) digits
          in end ++ begin","
main :: IO ()
main = do
  let candidate = circularShift
  if candidate 100 2 == ""001"" then pure () else error ""assertion failed""
  if candidate 12 2 == ""12"" then pure () else error ""assertion failed""
  if candidate 97 8 == ""79"" then pure () else error ""assertion failed""
  if candidate 12 1 == ""21"" then pure () else error ""assertion failed""
  if candidate 11 101 == ""11"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_66,khk_Cyrl,hs,"--Жишээ нь: --ASCII код. --Гүйцлийг бичнэ үү. Энэ нь өгөгдлийн үсгийн тоог оруулж, зөвхөн дээд үсгийн тоог өгнө"" --Ажлын хэсэг--  >>> digitsum """"
--  0
--  >>> digitsum ""abAB""
--  131
--  >>> digitsum ""abcCd""
--  67
--  >>> digitsum ""helloE""
--  69
--  >>> digitsum ""woArBld""
--  131
--  >>> digitsum ""aAaaaXa""
--  153
digitsum :: String -> Int
digitsum s =","digitsum :: String -> Int
digitsum s = sum $ map fromEnum $ filter isUpper s","
main :: IO ()
main = do
  let candidate = digitsum
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abAB"" == 131 then pure () else error ""assertion failed""
  if candidate ""abcCd"" == 67 then pure () else error ""assertion failed""
  if candidate ""helloE"" == 69 then pure () else error ""assertion failed""
  if candidate ""woArBld"" == 131 then pure () else error ""assertion failed""
  if candidate ""aAaaaXa"" == 153 then pure () else error ""assertion failed""
  if candidate "" How are yOu?"" == 151 then pure () else error ""assertion failed""
  if candidate ""You arE Very Smart"" == 327 then pure () else error ""assertion failed""
  pure ()"
HumanEval_67,khk_Cyrl,hs,"--examble-д: --Багцанд байгаа мангогийн үр жимсний тоог буцаана.--Аранжуу, элсэн мандал болон жимс жимсгэнэсийн тоог илэрхийлэх бүтэн тоо --Алма, апельсин, манго жимс.--Энэ саванд байгаа жимс жимсгэнэний сав дотор хуваагдана.--Энэ даалгаврын хувьд танд хэдэн ширхэг элбэг, будааг илэрхийлэх цуврал өгнө.--  >>> fruitDistribution ""5 apples and 6 oranges"" 19
--  8
--  >>> fruitDistribution ""0 apples and 1 oranges"" 3
--  2
--  >>> fruitDistribution ""2 apples and 3 oranges"" 100
--  95
--  >>> fruitDistribution ""100 apples and 1 oranges"" 120
--  19
fruitDistribution :: String -> Int -> Int
fruitDistribution s n =","import Text.Read (readMaybe)

fruitDistribution :: String -> Int -> Int
fruitDistribution s n = n - totalApplesOranges
  where
    totalApplesOranges = sum $ map (readNumber . words) [""apples"", ""oranges""]
    readNumber keyword = case dropWhile (not . (=="" "") . dropWhile (/=' ')) $ words s of
      [] -> 0
      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","
main :: IO ()
main = do
  let candidate = fruitDistribution
  if candidate ""5 apples and 6 oranges"" 19 == 8 then pure () else error ""assertion failed""
  if candidate ""5 apples and 6 oranges"" 21 == 10 then pure () else error ""assertion failed""
  if candidate ""0 apples and 1 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""1 apples and 0 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 100 == 95 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 5 == 0 then pure () else error ""assertion failed""
  if candidate ""1 apples and 100 oranges"" 120 == 19 then pure () else error ""assertion failed""
  pure ()"
HumanEval_68,khk_Cyrl,hs,"--1-р жишээ: --Хэрэв тэгш тоо байхгүй бол [] буцаана.--Хурдсан үнийг [smallest_value, its index] нэртэй жагсаалтад буцааж өгөх хэрэгтэй.--Хэрэв хамгийн бага тэгш үнэ цэнэтэй хэд хэдэн үүлдэр илэрвэл хамгийн бага индекстэй үүлдрийг буцаана. --Хурдсан үдэр нь хамгийн бага тэгш үнэтэй үдэр байх ёстой.--Таны ажил бол нэг үдсийг хурааж, буцаах явдал юм.--""Хэрэг бус бүтэн тооны үдэртэй модны салбарыг илэрхийлдэг жагсаалтыг өгвөл--  >>> pluck [4,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 2:
--  >>> pluck [1,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 3:
--  >>> pluck []
--  []
--  Example 4:
--  >>> pluck [5,0,3,0,4,2]
--  [0,1]
--  Explanation: 0 is the smallest value, but  there are two zeros,
--  so we will choose the first zero, which has the smallest index.
--  Constraints:
--  * 1 <= nodes.length <= 10000
--  * 0 <= node.value
pluck :: [Int] -> [Int]
pluck arr =","pluck :: [Int] -> [Int]
pluck arr = case filter (\(x, _) -> even x) (zip arr [0..]) of
    [] -> []
    evens -> let (value, index) = minimum evens in [value, index]","
main :: IO ()
main = do
  let candidate = pluck
  if candidate [4,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error ""assertion failed""
  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error ""assertion failed""
  if candidate [5,4,8,4,8] == [4,1] then pure () else error ""assertion failed""
  if candidate [7,6,7,1] == [6,1] then pure () else error ""assertion failed""
  if candidate [7,9,7,1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_69,khk_Cyrl,hs,"--Жишээ нь: --Хэрэв ийм үнэт зүйл байхгүй бол -1 буцаана.--Тоо бүтэн тооны давтамж нь түүний жагсаалтад гарч буй удаагийн тоо юм.--0 бөгөөд бүтэн тооны үнийн дүнгээс илүү эсвэл тэнцүү давтамжтай.--Та бүхэнд эерэг бүтэн тооны жагсаалтыг өгөөд байгаа.--  >>> search [4,1,2,2,3,1]
--  2
--  >>> search [1,2,2,3,3,3,4,4,4]
--  3
--  >>> search [5,5,4,4,4]
--  (-1)
search :: [Int] -> Int
search lst =","import Data.List (group, sort)
import Data.Ord (comparing)

search :: [Int] -> Int
search lst = 
    let frequencies = map (\g -> (head g, length g)) . group . sort $ lst
        candidates = filter (\(val, freq) -> freq >= val) frequencies
    in case candidates of
         [] -> -1
         _  -> fst . maximum $ candidates","
main :: IO ()
main = do
  let candidate = search
  if candidate [5,5,5,5,1] == 1 then pure () else error ""assertion failed""
  if candidate [4,1,4,1,4,4] == 4 then pure () else error ""assertion failed""
  if candidate [3,3] == (-1) then pure () else error ""assertion failed""
  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error ""assertion failed""
  if candidate [2,3,3,2,2] == 2 then pure () else error ""assertion failed""
  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error ""assertion failed""
  if candidate [3,2,8,2] == 2 then pure () else error ""assertion failed""
  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error ""assertion failed""
  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error ""assertion failed""
  if candidate [1,9,10,1,3] == 1 then pure () else error ""assertion failed""
  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error ""assertion failed""
  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error ""assertion failed""
  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error ""assertion failed""
  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error ""assertion failed""
  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error ""assertion failed""
  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error ""assertion failed""
  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error ""assertion failed""
  if candidate [10] == (-1) then pure () else error ""assertion failed""
  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error ""assertion failed""
  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error ""assertion failed""
  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error ""assertion failed""
  if candidate [3,10,10,9,2] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_70,khk_Cyrl,hs,"--Жишээ нь: --дараа нь үлдсэн бүтэн тоонуудын хамгийн их, дараа нь хамгийн бага гэх мэт.--Хэдэн төрлийн ангиллын хувьд хамгийн бага үнэ цэнэээс эхлэхэд,-- Цэнгэг тооны жагсаалтыг өгвөл, жагсаалтыг ер бусын дарааллаар буцаана.--  >>> strangeSortList [1,2,3,4]
--  [1,4,2,3]
--  >>> strangeSortList [5,5,5,5]
--  [5,5,5,5]
--  >>> strangeSortList []
--  []
strangeSortList :: [Int] -> [Int]
strangeSortList lst =","strangeSortList :: [Int] -> [Int]
strangeSortList [] = []
strangeSortList lst = go (sort lst) True
  where
    go [] _ = []
    go xs toggle
      | toggle    = head xs : go (tail xs) False
      | otherwise = last xs : go (init xs) True","
main :: IO ()
main = do
  let candidate = strangeSortList
  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error ""assertion failed""
  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error ""assertion failed""
  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error ""assertion failed""
  if candidate [111111] == [111111] then pure () else error ""assertion failed""
  pure ()"
HumanEval_71,khk_Cyrl,hs,"--Жишээ нь:--Гурав дахь тал нь.--Гурван талын нийлбэр нь аль ч талын хоёр талын нийлбэрээс их бол гурван талын гурвалжин болно.--Үгүй бол -1  гэж буцаана.--Гурван талын гурван талыг хүчин төгөлдөр гурвалжин хэлбэрээр хэлбэл, гурвалжинг арванхоёрдугаар шилжинд хүргэх.--Гурван талын гурван талын урт нь өгвөл, √3 -ийн талбайг буцаана.--  >>> triangleArea 3 4 5
--  6.0
--  >>> triangleArea 1 2 10
--  (-1).0
triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c =","import Text.Printf (printf)

triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c
    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))
    | otherwise = -1
  where
    s = (fromIntegral (a + b + c)) / 2
    isValidTriangle x y z = x + y > z && x + z > y && y + z > x
    roundToTwoDecimals x = read (printf ""%.2f"" x) :: Float","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 3 4 5 == 6.0 then pure () else error ""assertion failed""
  if candidate 1 2 10 == (-1).0 then pure () else error ""assertion failed""
  if candidate 4 8 5 == 8.18 then pure () else error ""assertion failed""
  if candidate 2 2 2 == 1.73 then pure () else error ""assertion failed""
  if candidate 1 2 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 10 5 7 == 16.25 then pure () else error ""assertion failed""
  if candidate 2 6 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 1 1 1 == 0.43 then pure () else error ""assertion failed""
  if candidate 2 2 10 == (-1).0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_72,khk_Cyrl,hs,"--Жишээ нь:--q объект тэнцвэртэй (ул бол палиндром жагсаалт) бөгөөд түүний элементүүдийн нийлбэр нь хамгийн их жинтэй тэнцүү эсвэл илүү бол ниснэ.-- л нисэх бол True, өөр тохиолдолд False гэсэн функцийг бичих.--  >>> willItFly [1,2] 5
--  False
--  # 1+2 is less than the maximum possible weight, but it's unbalanced.
--  >>> willItFly [3,2,3] 1
--  False
--  # it's balanced, but 3+2+3 is more than the maximum possible weight.
--  >>> willItFly [3,2,3] 9
--  True
--  # 3+2+3 is less than the maximum possible weight, and it's balanced.
--  >>> willItFly [3] 5
--  True
--  # 3 is less than the maximum possible weight, and it's balanced.
willItFly :: [Int] -> Int -> Bool
willItFly q w =","willItFly :: [Int] -> Int -> Bool
willItFly q w = isPalindrome q && sum q <= w

isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs","
main :: IO ()
main = do
  let candidate = willItFly
  if candidate [3,2,3] 9 == True then pure () else error ""assertion failed""
  if candidate [1,2] 5 == False then pure () else error ""assertion failed""
  if candidate [3] 5 == True then pure () else error ""assertion failed""
  if candidate [3,2,3] 1 == False then pure () else error ""assertion failed""
  if candidate [1,2,3] 6 == False then pure () else error ""assertion failed""
  if candidate [5] 5 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_73,khk_Cyrl,hs,"--Жишээ нь: --Нэг өөрчлөлтийн үеэр та нэг элементийг өөр аль нэг элементэд өөрчилж болно.--жагсаалтыг палиндром болгохын тулд өөрчлөх шаардлагатай. Палиндром жагсаалт бол --Бүх тооны жагсаалтыг өгвөл хамгийн бага тооны элементүүдийг олох хэрэгтэй.--  >>> smallestChange [1,2,3,5,4,7,9,6]
--  4
--  >>> smallestChange [1,2,3,4,3,2,2]
--  1
--  >>> smallestChange [1,2,3,2,1]
--  0
smallestChange :: [Int] -> Int
smallestChange arr =","smallestChange :: [Int] -> Int
smallestChange arr = sum $ zipWith (\x y -> if x /= y then 1 else 0) arr (reverse arr)","
main :: IO ()
main = do
  let candidate = smallestChange
  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error ""assertion failed""
  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,2,3,2,1] == 0 then pure () else error ""assertion failed""
  if candidate [3,1,1,3] == 0 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_74,khk_Cyrl,hs,"--Жишээ нь:--Хэрэв хоёр жагсаалт ижил тооны тэмдэгттэй бол эхний жагсаалтыг буцаана.--жагсаалтын бүх мөртөгт байгаа тэмдэгтийн тоо бусад жагсаалтаас бага байна.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> totalMatch [] []
--  []
--  >>> totalMatch [""hi"",""admin""] [""hI"",""Hi""]
--  [""hI"",""Hi""]
--  >>> totalMatch [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""]
--  [""hi"",""admin""]
--  >>> totalMatch [""hi"",""admin""] [""hI"",""hi"",""hi""]
--  [""hI"",""hi"",""hi""]
--  >>> totalMatch [""4""] [""1"",""2"",""3"",""4"",""5""]
--  [""4""]
totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2 =","totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2
  | totalChars lst1 < totalChars lst2 = lst1
  | totalChars lst1 > totalChars lst2 = lst2
  | otherwise = lst1
  where
    totalChars = sum . map length","
main :: IO ()
main = do
  let candidate = totalMatch
  if candidate [] [] == [] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi""] == [""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [""4""] [""1"",""2"",""3"",""4"",""5""] == [""4""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""Hi""] == [""hI"",""Hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hi""] == [""hI"",""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hii""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [] [""this""] == [] then pure () else error ""assertion failed""
  if candidate [""this""] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_75,khk_Cyrl,hs,"--Жишээ нь:--(а) нь 100-аас бага гэдгийг мэдэж байгаа бол.--бусад нь худал.-- Хэрэв өгөгдсөн тоо нь 3 үндсэн тооны үржүүлэлт бол үнэн гэсэн функцийг бичих--  >>> isMultiplyPrime 30
--  True
--  30 = 2 * 3 * 5
isMultiplyPrime :: Int -> Bool
isMultiplyPrime a =","isMultiplyPrime :: Int -> Bool
isMultiplyPrime a = any isTriplePrimeProduct primeTriples
  where
    primes = filter isPrime [2..99]
    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]
    isTriplePrimeProduct (x, y, z) = x * y * z == a

isPrime :: Int -> Bool
isPrime n 
  | n < 2     = False
  | otherwise = not (any (\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","
main :: IO ()
main = do
  let candidate = isMultiplyPrime
  if candidate 5 == False then pure () else error ""assertion failed""
  if candidate 30 == True then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == False then pure () else error ""assertion failed""
  if candidate 125 == True then pure () else error ""assertion failed""
  if candidate 105 == True then pure () else error ""assertion failed""
  if candidate 126 == False then pure () else error ""assertion failed""
  if candidate 729 == False then pure () else error ""assertion failed""
  if candidate 891 == False then pure () else error ""assertion failed""
  if candidate 1001 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_76,khk_Cyrl,hs,"--Жишээ нь: --x нь n-ийн энгийн хүч юм бол n**int=x --n-ийн хүч, бусад тохиолдолд false.--Таны ажил бол х тоо нь энгийн тоо бол үнэн гэсэн функцийг бичих юм.--  >>> isSimplePower 1 4
--  True
--  >>> isSimplePower 2 2
--  True
--  >>> isSimplePower 8 2
--  True
--  >>> isSimplePower 3 2
--  False
--  >>> isSimplePower 3 1
--  False
--  >>> isSimplePower 5 3
--  False
isSimplePower :: Int -> Int -> Bool
isSimplePower x n =","isSimplePower :: Int -> Int -> Bool
isSimplePower x n
  | x < 1 || n < 1 = False
  | n == 1 = x == 1
  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","
main :: IO ()
main = do
  let candidate = isSimplePower
  if candidate 16 2 == True then pure () else error ""assertion failed""
  if candidate 143214 16 == False then pure () else error ""assertion failed""
  if candidate 4 2 == True then pure () else error ""assertion failed""
  if candidate 9 3 == True then pure () else error ""assertion failed""
  if candidate 16 4 == True then pure () else error ""assertion failed""
  if candidate 24 2 == False then pure () else error ""assertion failed""
  if candidate 128 4 == False then pure () else error ""assertion failed""
  if candidate 12 6 == False then pure () else error ""assertion failed""
  if candidate 1 1 == True then pure () else error ""assertion failed""
  if candidate 1 12 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_77,khk_Cyrl,hs,"--Жишээ нь: --тэмдэглэл: та өгөгдлийг үргэлж хүчин төгөлдөр гэж үзэж болно.--Энэ нь ямар нэг бүтэн тооны куб юм бол.--А бүхэл тоог авч True-г буцаан өгөгдсөн функцийг бичих.--  >>> iscube 1
--  True
--  >>> iscube 2
--  False
--  >>> iscube (-1)
--  True
--  >>> iscube 64
--  True
--  >>> iscube 0
--  True
--  >>> iscube 180
--  False
iscube :: Int -> Bool
iscube a =","iscube :: Int -> Bool
iscube a = let n = round (fromIntegral a ** (1/3)) in n^3 == a","
main :: IO ()
main = do
  let candidate = iscube
  if candidate 1 == True then pure () else error ""assertion failed""
  if candidate 2 == False then pure () else error ""assertion failed""
  if candidate (-1) == True then pure () else error ""assertion failed""
  if candidate 64 == True then pure () else error ""assertion failed""
  if candidate 180 == False then pure () else error ""assertion failed""
  if candidate 1000 == True then pure () else error ""assertion failed""
  if candidate 0 == True then pure () else error ""assertion failed""
  if candidate 1729 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_78,khk_Cyrl,hs,"--Жишээ нь: --А, Б, С, Д, Е, Ф гэсэн тэмдэгтүүд нь үргэлж том үсгээр бичигддэг.--тэмдэглэл: та оролт нь үргэлж зөв эсвэл хоосон string гэж үзэж болно, --B (= арваннэгдүгээр 11), D (= арваннэгдүгээр 13).--Тэгэхээр та дараах тоонуудын тоог тодорхойлох хэрэгтэй: 2, 3, 5, 7, --Ерөнхий тоо нь 2, 3, 5, 7, 11, 13, 17,...--Гэдэсний тоон цэгт 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, А, Б, С, Д, Е, Ф гэсэн тоо байдаг.--1 -ээс илүү, хоёр жижиг натуралын үр дүн биш).--(Prime буюу prime нь натураль тоо юм)--зургаан арван доод цэгт тооны тооны тоог тооцдог --Таныг хүлээн авах функцийг бичих үүрэг өглөө.--  >>> hexKey ""AB""
--  1
--  >>> hexKey ""1077E""
--  2
--  >>> hexKey ""ABED1A33""
--  4
--  >>> hexKey ""123456789ABCDEF0""
--  6
--  >>> hexKey ""2020""
--  2
hexKey :: String -> Int
hexKey num =","hexKey :: String -> Int
hexKey num = length . filter (`elem` primeHexDigits) $ num
  where
    primeHexDigits = ""2357BD""","
main :: IO ()
main = do
  let candidate = hexKey
  if candidate ""AB"" == 1 then pure () else error ""assertion failed""
  if candidate ""1077E"" == 2 then pure () else error ""assertion failed""
  if candidate ""ABED1A33"" == 4 then pure () else error ""assertion failed""
  if candidate ""2020"" == 2 then pure () else error ""assertion failed""
  if candidate ""123456789ABCDEF0"" == 6 then pure () else error ""assertion failed""
  if candidate ""112233445566778899AABBCCDDEEFF00"" == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_79,khk_Cyrl,hs,"--Жишээ нь: --Нэмэлт тэмдэгт нь форматтай тусалж өгдөг.--Энэ нь эхэнд болон төгсгөлд нэмэлт хоёр тэмдэгт болох 'db' болно.--дугаар. Шүлгийн бүх тэмдэгт нь ""0"" эсвэл ""1"" байх болно.--функц нь нэг үсгийн дугаарыг буцааж өгөх ёстой бөгөөд үсгийн бүр нь хоёрдугаар --Та нарт арванхоёрдугаар хэлбэрээр тоо өгнө. Та нарын ажил нь үүнийг ...--  >>> decimalToBinary 15
--  ""db1111db""
--  >>> decimalToBinary 32
--  ""db100000db""
decimalToBinary :: Int -> String
decimalToBinary decimal =","decimalToBinary :: Int -> String
decimalToBinary decimal = ""db"" ++ toBinary decimal ++ ""db""
  where
    toBinary 0 = ""0""
    toBinary n = reverse (binaryHelper n)

    binaryHelper 0 = """"
    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","
main :: IO ()
main = do
  let candidate = decimalToBinary
  if candidate 0 == ""db0db"" then pure () else error ""assertion failed""
  if candidate 32 == ""db100000db"" then pure () else error ""assertion failed""
  if candidate 103 == ""db1100111db"" then pure () else error ""assertion failed""
  if candidate 15 == ""db1111db"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_80,khk_Cyrl,hs,"--Жишээ нь: --Хэрэв үсгийн урт нь 3 ба дараалан 3 үсэг тус тусдаа байвал үсгийн урт нь хагас байна.--Таны ажил бол хэрхэх нь хагас байна уу, үгүй юу гэдгийг шалгах юм.--Та нарт string s өгөгдсөн байна.--  >>> isHappy ""a""
--  False
--  >>> isHappy ""aa""
--  False
--  >>> isHappy ""abcd""
--  True
--  >>> isHappy ""aabb""
--  False
--  >>> isHappy ""adb""
--  True
--  >>> isHappy ""xyy""
--  False
isHappy :: String -> Bool
isHappy s =","isHappy :: String -> Bool
isHappy s
  | length s < 3 = False
  | otherwise = all distinctTriples (windows 3 s)
  where
    distinctTriples [x, y, z] = x /= y && y /= z && x /= z
    distinctTriples _ = False
    windows n xs
      | length xs < n = []
      | otherwise = take n xs : windows n (tail xs)","
main :: IO ()
main = do
  let candidate = isHappy
  if candidate ""a"" == False then pure () else error ""assertion failed""
  if candidate ""aa"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""adb"" == True then pure () else error ""assertion failed""
  if candidate ""xyy"" == False then pure () else error ""assertion failed""
  if candidate ""iopaxpoi"" == True then pure () else error ""assertion failed""
  if candidate ""iopaxioi"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_81,khk_Cyrl,hs,"--Жишээ нь:--0.0 Е --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 С--> 2.0 C+ --> 2.3 Б- --> 2.7 B --> 3.0 B+ --> 3.3 А- --> 3.7 А --4.0 А+ --Дунд дунджаа.--дараах хүснэгт ашиглан үсгийн ангилал жагсаалтыг гаргаж чадах функц: --Тэр танд зарим сурагчдын дунджааг өгсөн бөгөөд та нар бичиж өгөх ёстой.--Зөвхөн нэг асуудал байна, тэр нь үнэлгээ өгөх код алдсан байна.--Багш нь үнэлгээ өгөх өөрийн алгоритмийг бүтээдэг.--Энэ бол улирлын сүүлийн долоо хоног бөгөөд багш нь үнэлгээ өгөх ёстой.--  >>> gradeEquation [4.0,3,1.7,2,3.5]
--  [""A+"",""B"",""C-"",""C"",""A-""]
numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades =","numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades = map gpaToLetterGrade grades
  where
    gpaToLetterGrade gpa
      | gpa == 4.0 = ""A+""
      | gpa > 3.7  = ""A""
      | gpa > 3.3  = ""A-""
      | gpa > 3.0  = ""B+""
      | gpa > 2.7  = ""B""
      | gpa > 2.3  = ""B-""
      | gpa > 2.0  = ""C+""
      | gpa > 1.7  = ""C""
      | gpa > 1.3  = ""C-""
      | gpa > 1.0  = ""D+""
      | gpa > 0.7  = ""D""
      | gpa > 0.0  = ""D-""
      | otherwise  = ""E""","
main :: IO ()
main = do
  let candidate = numericalLetterGrade
  if candidate [4.0,3,1.7,2,3.5] == [""A+"",""B"",""C-"",""C"",""A-""] then pure () else error ""assertion failed""
  if candidate [1.2] == [""D+""] then pure () else error ""assertion failed""
  if candidate [0.5] == [""D-""] then pure () else error ""assertion failed""
  if candidate [0.0] == [""E""] then pure () else error ""assertion failed""
  if candidate [1.0,0.3,1.5,2.8,3.3] == [""D"",""D-"",""C-"",""B"",""B+""] then pure () else error ""assertion failed""
  if candidate [0.0,0.7] == [""E"",""D-""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_82,khk_Cyrl,hs,"--Жишээ нь:--length нь нэгдүгээр тоо юм уу False өөр тохиолдолд -- хэрэв string нь true бол true гэж өгөгдсөн функцийг бичих--  >>> primeLength ""Hello""
--  True
--  >>> primeLength ""abcdcba""
--  True
--  >>> primeLength ""kittens""
--  True
--  >>> primeLength ""orange""
--  False
primeLength :: String -> Bool
primeLength string =","primeLength :: String -> Bool
primeLength string = isPrime (length string)

isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | n == 2    = True
  | even n    = False
  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = primeLength
  if candidate ""Hello"" == True then pure () else error ""assertion failed""
  if candidate ""abcdcba"" == True then pure () else error ""assertion failed""
  if candidate ""kittens"" == True then pure () else error ""assertion failed""
  if candidate ""orange"" == False then pure () else error ""assertion failed""
  if candidate ""wow"" == True then pure () else error ""assertion failed""
  if candidate ""world"" == True then pure () else error ""assertion failed""
  if candidate ""MadaM"" == True then pure () else error ""assertion failed""
  if candidate ""Wow"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""HI"" == True then pure () else error ""assertion failed""
  if candidate ""go"" == True then pure () else error ""assertion failed""
  if candidate ""gogo"" == False then pure () else error ""assertion failed""
  if candidate ""aaaaaaaaaaaaaaa"" == False then pure () else error ""assertion failed""
  if candidate ""Madam"" == True then pure () else error ""assertion failed""
  if candidate ""M"" == False then pure () else error ""assertion failed""
  if candidate ""0"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_83,khk_Cyrl,hs,"--1-ээс эхлэх эсвэл 1-ээр дуусах эерэг бүтэн тоо.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │startsOneEnds :: Int -> Int
startsOneEnds n =","startsOneEnds :: Int -> Int
startsOneEnds n
  | n <= 0    = 0
  | n == 1    = 1
  | otherwise = 18 * 10^(n-2)","
main :: IO ()
main = do
  let candidate = startsOneEnds
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 2 == 18 then pure () else error ""assertion failed""
  if candidate 3 == 180 then pure () else error ""assertion failed""
  if candidate 4 == 1800 then pure () else error ""assertion failed""
  if candidate 5 == 18000 then pure () else error ""assertion failed""
  pure ()"
HumanEval_84,khk_Cyrl,hs,"--Жишээ -- N гэсэн эерэг бүтэн тоог өгвөл, түүний тооны тоонуудын нийлбэрийг хоёрдугаар хэлбэрээр буцаана. --  >>> solve 1000
--  ""1""
--  >>> solve 150
--  ""110""
--  >>> solve 147
--  ""1100""
--  Variables:
--  @N integer
--  Constraints: 0 ≤ N ≤ 10000.
--  Output:
--  a string of binary number
solve :: Int -> String
solve N =","solve :: Int -> String
solve N = toBinary (sumOfDigits N)
  where
    sumOfDigits 0 = 0
    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)

    toBinary 0 = ""0""
    toBinary n = reverse (toBinary' n)
      where
        toBinary' 0 = """"
        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","
main :: IO ()
main = do
  let candidate = solve
  if candidate 1000 == ""1"" then pure () else error ""assertion failed""
  if candidate 150 == ""110"" then pure () else error ""assertion failed""
  if candidate 147 == ""1100"" then pure () else error ""assertion failed""
  if candidate 333 == ""1001"" then pure () else error ""assertion failed""
  if candidate 963 == ""10010"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_85,khk_Cyrl,hs,"--Жишээ нь: -- Цэнгэг тооны жагсаалтыг өгвөл, эхлээд хос тооны элементүүдийг нэгтгэнэ.--  >>> add [4,2,6,7]
--  2
add :: [Int] -> Int
add lst =","add :: [Int] -> Int
add lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","
main :: IO ()
main = do
  let candidate = add
  if candidate [4,88] == 88 then pure () else error ""assertion failed""
  if candidate [4,5,6,7,2,122] == 122 then pure () else error ""assertion failed""
  if candidate [4,0,6,7] == 0 then pure () else error ""assertion failed""
  if candidate [4,4,6,8] == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_86,khk_Cyrl,hs,"--Жишээ нь: --Анхааруулга: Та үгний дарааллыг, өгүүлбэр дэх хоосон орон зайг хадгалах хэрэгтэй.--ASCII-ийн үнэлгээний дагуу өсөх дарааллаар.-- гэж орсон бүх тэмдэгтүүд нь шинэ үгээр оршино.--Захидалтай хувилбар нь бүх үг (сэлбэгээр тусгаарлагдсан) --. . . . . . . . . . . . . . . . . .--  >>> antiShuffle ""Hi""
--  ""Hi""
--  >>> antiShuffle ""hello""
--  ""ehllo""
--  >>> antiShuffle ""Hello World!!!""
--  ""Hello !!!Wdlor""
antiShuffle :: String -> String
antiShuffle s =","import Data.List (sort)
import Data.Char (isAlpha)

antiShuffle :: String -> String
antiShuffle s = unwords $ map sortWord (wordsAndSpaces s)
  where
    sortWord word = if all isAlpha word then sort word else word
    wordsAndSpaces [] = []
    wordsAndSpaces xs = if head xs == ' ' 
                        then "" "" : wordsAndSpaces (dropWhile (== ' ') xs)
                        else let (word, rest) = break (== ' ') xs
                             in word : wordsAndSpaces rest","
main :: IO ()
main = do
  let candidate = antiShuffle
  if candidate ""Hi"" == ""Hi"" then pure () else error ""assertion failed""
  if candidate ""hello"" == ""ehllo"" then pure () else error ""assertion failed""
  if candidate ""number"" == ""bemnru"" then pure () else error ""assertion failed""
  if candidate ""abcd"" == ""abcd"" then pure () else error ""assertion failed""
  if candidate ""Hello World!!!"" == ""Hello !!!Wdlor"" then pure () else error ""assertion failed""
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hi. My name is Mister Robot. How are you?"" == "".Hi My aemn is Meirst .Rboot How aer ?ouy"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_87,khk_Cyrl,hs,"--Жишээ нь: --Мөн, суудлын координатуудыг суудлын дагуу уналтын дарааллаар дараарай.--Координатуудыг эхлээд суваг дээрээс дээш дарааллаар дараарай.--Тупл нь 0-ээс эхлэх координатууд юм.--Мөн [(x1, y1), (x2, y2) ...] гэсэн цуврал жагсаалтыг буцааж өгнө.--lst, x бүхэл тоог авч үзвэл, жагсаалтын x бүхэл тоог олох, --нэг суудалд өөр өөр тооны суудлууд байж болно.--матрицаас ялгаатай нь матрицаас ялгаатай нь--Та 2 хэмжээст өгөгдлийг, нэгтгэсэн жагсаалтыг авна.--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1
--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]
--  >>> getRow [] 1
--  []
--  >>> getRow [[],[1],[1,2,3]] 3
--  [(2, 2)]
getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x =","getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x = concatMap processRow (zip [0..] lst)
  where
    processRow (rowIndex, row) = 
      let colIndices = reverse $ findIndices (== x) row
      in [(rowIndex, colIndex) | colIndex <- colIndices]

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","
main :: IO ()
main = do
  let candidate = getRow
  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error ""assertion failed""
  if candidate [] 1 == [] then pure () else error ""assertion failed""
  if candidate [[1]] 2 == [] then pure () else error ""assertion failed""
  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_88,khk_Cyrl,hs,"--Жишээ нь: --* өгөгдсөн жагсаалтыг өөрчлөхгүй байх.--тэмдэглэл: --эсвэл тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо--Хэрэв тооны нийлбэр (( эхний индекс, сүүлийн индекс) хос байвал та жагсаалтыг өсөх дарааллаар дараална.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> sortArray []
--  []
--  >>> sortArray [5]
--  [5]
--  >>> sortArray [2,4,3,0,1,5]
--  [0,1,2,3,4,5]
--  >>> sortArray [2,4,3,0,1,5,6]
--  [6,5,4,3,2,1,0]
sortArray :: [Int] -> [Int]
sortArray array =","sortArray :: [Int] -> [Int]
sortArray array
  | null array = array
  | otherwise =
    let first = head array
        last = last array
        sumFirstLast = first + last
    in if odd sumFirstLast
       then sort array
       else reverse (sort array)","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5] == [5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error ""assertion failed""
  if candidate [2,1] == [1,2] then pure () else error ""assertion failed""
  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error ""assertion failed""
  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error ""assertion failed""
  pure ()"
HumanEval_89,khk_Cyrl,hs,"--Жишээ нь: --2 дахин нэмэгдэж 2 байранд хүрнэ.--Алфавитыг эргэлтэд оруулбал үсгийн --эргүүлэн эргүүлэн эргүүлэн шифрлүүлсэн үсгийн үсэг буцааж өгнө.-- функц шифрлүүлэх нь аргумент болон string авч --  >>> encrypt ""hi""
--  ""lm""
--  >>> encrypt ""asdfghjkl""
--  ""ewhjklnop""
--  >>> encrypt ""gf""
--  ""kj""
--  >>> encrypt ""et""
--  ""ix""
encrypt :: String -> String
encrypt s =","encrypt :: String -> String
encrypt s = map shiftChar s
  where
    shiftChar c
      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')
      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')
      | otherwise = c","
main :: IO ()
main = do
  let candidate = encrypt
  if candidate ""hi"" == ""lm"" then pure () else error ""assertion failed""
  if candidate ""asdfghjkl"" == ""ewhjklnop"" then pure () else error ""assertion failed""
  if candidate ""gf"" == ""kj"" then pure () else error ""assertion failed""
  if candidate ""et"" == ""ix"" then pure () else error ""assertion failed""
  if candidate ""faewfawefaewg"" == ""jeiajeaijeiak"" then pure () else error ""assertion failed""
  if candidate ""hellomyfriend"" == ""lippsqcjvmirh"" then pure () else error ""assertion failed""
  if candidate ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"" == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" then pure () else error ""assertion failed""
  if candidate ""a"" == ""e"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_90,khk_Cyrl,hs,"--Хэрэв тийм элемент байхгүй бол юу ч эргүүлэхгүй.--Дараагийн хамгийн бага () функцийг бичих. Энэ нь жагсаалтын 2-р хамгийн бага элементийг буцааж өгдөг.-- Чи бүхэл тооны жагсаалтыг авдаг.--  >>> nextSmallest [1,2,3,4,5]
--  Just (2)
--  >>> nextSmallest [5,1,4,3,2]
--  Just (2)
--  >>> nextSmallest []
--  Just (Nothing)
--  >>> nextSmallest [1,1]
--  Just (Nothing)
nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =","nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =
  let uniqueSorted = removeDuplicates $ quicksort lst
  in if length uniqueSorted < 2
     then Nothing
     else Just (uniqueSorted !! 1)

removeDuplicates :: (Ord a) => [a] -> [a]
removeDuplicates = foldr (\x acc -> if x `elem` acc then acc else x : acc) []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = nextSmallest
  if candidate [1,2,3,4,5] == Just (2) then pure () else error ""assertion failed""
  if candidate [5,1,4,3,2] == Just (2) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1,1,1,0] == Just (1) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error ""assertion failed""
  pure ()"
HumanEval_91,khk_Cyrl,hs,"--Жишээ нь: --Суудлыг """", ""?"" эсвэл ""!""-ээр хязгаарлана.--""I"" үгээр эхэлдэг үг бол ""boredom"" юм.--Та бүхэнд хэд хэдэн үг өгнө. Таны ажил бол тоог тоолох.--  >>> isBored ""Hello world""
--  0
--  >>> isBored ""The sky is blue. The sun is shining. I love this weather""
--  1
isBored :: String -> Int
isBored S =","isBored :: String -> Int
isBored s = length $ filter (startsWithI . words) $ splitSentences s
  where
    splitSentences :: String -> [String]
    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters "".?!""
    
    splitOnDelimiters :: String -> String -> [String]
    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of
      """" -> []
      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''
    
    startsWithI :: [String] -> Bool
    startsWithI [] = False
    startsWithI (x:_) = map toLower x == ""i""","
main :: IO ()
main = do
  let candidate = isBored
  if candidate ""Hello world"" == 0 then pure () else error ""assertion failed""
  if candidate ""Is the sky blue?"" == 0 then pure () else error ""assertion failed""
  if candidate ""I love It !"" == 1 then pure () else error ""assertion failed""
  if candidate ""bIt"" == 0 then pure () else error ""assertion failed""
  if candidate ""I feel good today. I will be productive. will kill It"" == 2 then pure () else error ""assertion failed""
  if candidate ""You and I are going for a walk"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_92,khk_Cyrl,hs,"--Жишээ нь:--Бусад тохиолдолд false өгнө.--Нэг тоо нь нөгөө хоёр тооны нийлбэртэй тэнцүү бол үнэн гэж буцаана.--3 тооны функцийг бий болго.--  >>> anyInt 5 2 7
--  True
--  >>> anyInt 3 2 2
--  False
--  >>> anyInt 3 (-2) 1
--  True
--  >>> anyInt 3.6 -2.2 2
--  False
anyInt :: Float -> Float -> Float -> Bool
anyInt x y z =","anyInt :: Float -> Float -> Float -> Bool
anyInt x y z
  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =
      x == y + z || y == x + z || z == x + y
  | otherwise = False","
main :: IO ()
main = do
  let candidate = anyInt
  if candidate 2.0 3.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 2.5 2.0 3.0 == False then pure () else error ""assertion failed""
  if candidate 1.5 5.0 3.5 == False then pure () else error ""assertion failed""
  if candidate 2.0 6.0 2.0 == False then pure () else error ""assertion failed""
  if candidate 4.0 2.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.2 2.2 2.2 == False then pure () else error ""assertion failed""
  if candidate (-4).0 6.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.0 1.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_93,khk_Cyrl,hs,"--Жишээ нь: --Зөвхөн үсэг л хэрэглэнэ.--Англи хэлний үсэгт үсэг.--2 байрлал өмнө нь байгаа үсгийн мэдээ --Энэ нь бүх үсгийн зургийг солиж, бүх үсэгт -г орлох арга юм.--Мэдээг авч, иймэрхүү байдлаар кодлох функцийг бичих--  >>> encode ""test""
--  ""TGST""
--  >>> encode ""This is a message""
--  ""tHKS KS C MGSSCGG""
encode :: String -> String
encode message =","encode :: String -> String
encode = map transformChar
  where
    transformChar :: Char -> Char
    transformChar c
      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c
      | otherwise      = swapCase c c
      where
        lowerC = toLower c

    isVowel :: Char -> Bool
    isVowel c = c `elem` ""aeiou""

    swapCase :: Char -> Char -> Char
    swapCase origC c
      | isUpper origC = toLower c
      | otherwise     = toUpper c","
main :: IO ()
main = do
  let candidate = encode
  if candidate ""TEST"" == ""tgst"" then pure () else error ""assertion failed""
  if candidate ""Mudasir"" == ""mWDCSKR"" then pure () else error ""assertion failed""
  if candidate ""YES"" == ""ygs"" then pure () else error ""assertion failed""
  if candidate ""This is a message"" == ""tHKS KS C MGSSCGG"" then pure () else error ""assertion failed""
  if candidate ""I DoNt KnOw WhAt tO WrItE"" == ""k dQnT kNqW wHcT Tq wRkTg"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_94,khk_Cyrl,hs,"--Жишээ нь: --Хамгийн том анхны үнэ цэнийг олж, түүний тооны тоонуудын нийлбэрийг буцаах хэрэгтэй.-- Чи бүхэл тооны жагсаалтыг авдаг.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]
--  10
--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]
--  25
--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]
--  13
--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]
--  11
--  >>> skjkasdkd [0,81,12,3,1,21]
--  3
--  >>> skjkasdkd [0,8,1,2,1,7]
--  7
skjkasdkd :: [Int] -> Int
skjkasdkd lst =","skjkasdkd :: [Int] -> Int
skjkasdkd lst = sumDigits (largestPrime lst)

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]

-- Integer square root using binary search, O(log n)
isqrt :: Int -> Int
isqrt n = floor . sqrt $ fromIntegral n

-- Function to find the largest prime in the list
largestPrime :: [Int] -> Int
largestPrime = foldr (\x acc -> if isPrime x && x > acc then x else acc) 0

-- Function to calculate the sum of the digits of a number
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = n `mod` 10 + sumDigits (n `div` 10)","
main :: IO ()
main = do
  let candidate = skjkasdkd
  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error ""assertion failed""
  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error ""assertion failed""
  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error ""assertion failed""
  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error ""assertion failed""
  if candidate [0,81,12,3,1,21] == 3 then pure () else error ""assertion failed""
  if candidate [0,8,1,2,1,7] == 7 then pure () else error ""assertion failed""
  if candidate [8191] == 19 then pure () else error ""assertion failed""
  if candidate [8191,123456,127,7] == 19 then pure () else error ""assertion failed""
  if candidate [127,97,8192] == 10 then pure () else error ""assertion failed""
  pure ()"
HumanEval_95,khk_Cyrl,hs,"--Жишээ нь: --Функц нь False буцаах ёстой бол өгөгдсөн холбооны жагсаалт хоосон байна. --case эсвэл бүх түлхүүр нь том томьёотой string юм бол False гэж буцаана.--Бүх түлхүүрүүд нь доод цэгүүд бол холбооны жагсаалтыг өгнө.--  >>> checkDictCase [(""a"", ""apple""), (""b"", ""banana"")]
--  True
--  >>> checkDictCase [(""a"", ""apple""), (""A"", ""banana""), (""B"", ""banana"")]
--  False
--  >>> checkDictCase [(""a"", ""apple""), (8, ""banana""), (""a"", ""apple"")]
--  False
--  >>> checkDictCase [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")]
--  False
--  >>> checkDictCase [(""STATE"", ""NC""), (""ZIP"", ""12345"")]
--  True
checkDictCase :: [(String, String)] -> Bool
checkDictCase dict =","import Data.Char (isUpper, isLower)

checkDictCase :: [(String, String)] -> Bool
checkDictCase [] = False
checkDictCase dict = all isLower allKeys || all isUpper allKeys
  where
    allKeys = concatMap fst dict","
main :: IO ()
main = do
  let candidate = checkDictCase
  if candidate [(""p"", ""pineapple""), (""b"", ""banana"")] == True then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""A"", ""banana""), (""B"", ""banana"")] == False then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""5"", ""banana""), (""a"", ""apple"")] == False then pure () else error ""assertion failed""
  if candidate [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")] == False then pure () else error ""assertion failed""
  if candidate [(""STATE"", ""NC""), (""ZIP"", ""12345"")] == True then pure () else error ""assertion failed""
  if candidate [(""fruit"", ""Orange""), (""taste"", ""Sweet"")] == True then pure () else error ""assertion failed""
  if candidate [] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_96,khk_Cyrl,hs,"--Жишээ нь: --n-ээс бага, нэгдүгээр тооны бүтэн тоо.--Эцсийн n тооны жагсаалтыг буцааж өгөх функцийг хэрэгжүүлнэ--  >>> countUpTo 5
--  [2,3]
--  >>> countUpTo 11
--  [2,3,5,7]
--  >>> countUpTo 0
--  []
--  >>> countUpTo 20
--  [2,3,5,7,11,13,17,19]
--  >>> countUpTo 1
--  []
--  >>> countUpTo 18
--  [2,3,5,7,11,13,17]
countUpTo :: Int -> [Int]
countUpTo n =","countUpTo :: Int -> [Int]
countUpTo n = filter isPrime [2..n-1]

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = countUpTo
  if candidate 5 == [2,3] then pure () else error ""assertion failed""
  if candidate 6 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 7 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 10 == [2,3,5,7] then pure () else error ""assertion failed""
  if candidate 0 == [] then pure () else error ""assertion failed""
  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error ""assertion failed""
  if candidate 1 == [] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error ""assertion failed""
  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error ""assertion failed""
  pure ()"
HumanEval_97,khk_Cyrl,hs,"--Жишээ нь: --Энэ нь үргэлж хүчин төгөлдөр гэж үзнэ.--нэгжийн тоонуудын үр дүн. --2 бүтэн тоог авч, буцаан өгөгдсөн функцийг гүйцэтгэнэ.--  >>> multiply 148 412
--  16
--  >>> multiply 19 28
--  72
--  >>> multiply 2020 1851
--  0
--  >>> multiply 14 (-15)
--  20
multiply :: Int -> Int -> Int
multiply a b =","multiply :: Int -> Int -> Int
multiply a b = (abs a `mod` 10) * (abs b `mod` 10)","
main :: IO ()
main = do
  let candidate = multiply
  if candidate 148 412 == 16 then pure () else error ""assertion failed""
  if candidate 19 28 == 72 then pure () else error ""assertion failed""
  if candidate 2020 1851 == 0 then pure () else error ""assertion failed""
  if candidate 14 (-15) == 20 then pure () else error ""assertion failed""
  if candidate 76 67 == 42 then pure () else error ""assertion failed""
  if candidate 17 27 == 49 then pure () else error ""assertion failed""
  if candidate 0 1 == 0 then pure () else error ""assertion failed""
  if candidate 0 0 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_98,khk_Cyrl,hs,"--Жишээ нь: -- S үсгийн тоог авч үзвэл, том үсэгт байгаа том үсэгтнүүдийн тоог тооц.--  >>> countUpper ""aBCdEf""
--  1
--  >>> countUpper ""abcdefg""
--  0
--  >>> countUpper ""dBBE""
--  0
countUpper :: String -> Int
countUpper s =","countUpper :: String -> Int
countUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` ""AEIOU""]","
main :: IO ()
main = do
  let candidate = countUpper
  if candidate ""aBCdEf"" == 1 then pure () else error ""assertion failed""
  if candidate ""abcdefg"" == 0 then pure () else error ""assertion failed""
  if candidate ""dBBE"" == 0 then pure () else error ""assertion failed""
  if candidate ""B"" == 0 then pure () else error ""assertion failed""
  if candidate ""U"" == 1 then pure () else error ""assertion failed""
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""EEEE"" == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_99,khk_Cyrl,hs,"--Жишээ нь:--2 бүтэн тоог 0-ээс холдуулан тойрч авна.--Энэ тоо нь тэнцүү зайтай бол -- Хэлэлцээрийн тоог илэрхийлэх утга (хүсэл) авах функцийг бий болгох--  >>> closestInteger ""10""
--  10
--  >>> closestInteger ""15.3""
--  15
--  Note:
--  Rounding away from zero means that if the given number is equidistant
--  from two integers, the one you should return is the one that is the
--  farthest from zero. For example closest_integer(""14.5"") should
--  return 15 and closest_integer(""-14.5"") should return -15.
closestInteger :: String -> Int
closestInteger value =","closestInteger :: String -> Int
closestInteger value = 
  let n = read value :: Double
  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","
main :: IO ()
main = do
  let candidate = closestInteger
  if candidate ""10"" == 10 then pure () else error ""assertion failed""
  if candidate ""14.5"" == 15 then pure () else error ""assertion failed""
  if candidate ""-15.5"" == (-16) then pure () else error ""assertion failed""
  if candidate ""15.3"" == 15 then pure () else error ""assertion failed""
  if candidate ""0"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_100,khk_Cyrl,hs,"--Жишээ нь: --i нь түвшинд (i+1) байгаа чулууны тоог илэрхийлдэг.-- индекс дээр элемент нь жагсаалтын аль нэг түвшинд чулуудын тоог буцааж өгнө.--- дараагийн тэгш тоо бол n тэгш тоо.--- дараагийн хос тоо бол n хос тоо юм.--Дараагийн түвшинд байгаа чулууны тоо: --Эхний түвшинд n чулуу байдаг.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> makeAPile 3
--  [3,5,7]
makeAPile :: Int -> [Int]
makeAPile n =","makeAPile :: Int -> [Int]
makeAPile n = take n [n, n + 2 ..]","
main :: IO ()
main = do
  let candidate = makeAPile
  if candidate 3 == [3,5,7] then pure () else error ""assertion failed""
  if candidate 4 == [4,6,8,10] then pure () else error ""assertion failed""
  if candidate 5 == [5,7,9,11,13] then pure () else error ""assertion failed""
  if candidate 6 == [6,8,10,12,14,16] then pure () else error ""assertion failed""
  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error ""assertion failed""
  pure ()"
HumanEval_101,khk_Cyrl,hs,"--Жишээ нь: --үгсийг хувааж, үгийн жагсаалтыг буцаах.--Та нар үгийн дараалалтай болно, үгээ холимог болон хооронд нь хувааж болно.--  >>> wordsString ""Hi, my name is John""
--  [""Hi"",""my"",""name"",""is"",""John""]
--  >>> wordsString ""One, two, three, four, five, six""
--  [""One"",""two"",""three"",""four"",""five"",""six""]
wordsString :: String -> [String]
wordsString s =","wordsString :: String -> [String]
wordsString s = words $ map (\c -> if c == ',' then ' ' else c) s","
main :: IO ()
main = do
  let candidate = wordsString
  if candidate ""Hi, my name is John"" == [""Hi"",""my"",""name"",""is"",""John""] then pure () else error ""assertion failed""
  if candidate ""One, two, three, four, five, six"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate ""Hi, my name"" == [""Hi"",""my"",""name""] then pure () else error ""assertion failed""
  if candidate ""One,, two, three, four, five, six,"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""ahmed     , gamal"" == [""ahmed"",""gamal""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_102,khk_Cyrl,hs,"--Жишээ нь: --Ийм тоо байхгүй бол функц нь -1 буцааж өгөх ёстой.--хамгийн том хос бүтэн тоо нь [x, y] хүрээний дотор байдаг.--Энэ функц нь x болон y гэсэн хоёр эерэг тоог авч, --  >>> chooseNum 12 15
--  14
--  >>> chooseNum 13 12
--  (-1)
chooseNum :: Int -> Int -> Int
chooseNum x y =","chooseNum :: Int -> Int -> Int
chooseNum x y
    | x > y = -1
    | even upperBound = upperBound
    | even (upperBound - 1) = upperBound - 1
    | otherwise = -1
  where
    upperBound = max x y","
main :: IO ()
main = do
  let candidate = chooseNum
  if candidate 12 15 == 14 then pure () else error ""assertion failed""
  if candidate 13 12 == (-1) then pure () else error ""assertion failed""
  if candidate 33 12354 == 12354 then pure () else error ""assertion failed""
  if candidate 5234 5233 == (-1) then pure () else error ""assertion failed""
  if candidate 6 29 == 28 then pure () else error ""assertion failed""
  if candidate 27 10 == (-1) then pure () else error ""assertion failed""
  if candidate 7 7 == (-1) then pure () else error ""assertion failed""
  if candidate 546 546 == 546 then pure () else error ""assertion failed""
  pure ()"
HumanEval_104,khk_Cyrl,hs,"--Жишээ нь: --Эскертүү: Буцаасан жагсаалтыг өсөх дарааллаар ангилах хэрэгтэй.--Элементүүд нь тэгш тоотой биш.--│ │х нь эерэг бүтэн тооны жагсаалтыг өгвөл, │ │ │ бүх │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> uniqueDigits [15,33,1422,1]
--  [1,15,33]
--  >>> uniqueDigits [152,323,1422,10]
--  []
uniqueDigits :: [Int] -> [Int]
uniqueDigits x =","uniqueDigits :: [Int] -> [Int]
uniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","
main :: IO ()
main = do
  let candidate = uniqueDigits
  if candidate [15,33,1422,1] == [1,15,33] then pure () else error ""assertion failed""
  if candidate [152,323,1422,10] == [] then pure () else error ""assertion failed""
  if candidate [12345,2033,111,151] == [111,151] then pure () else error ""assertion failed""
  if candidate [135,103,31] == [31,135] then pure () else error ""assertion failed""
  pure ()"
HumanEval_105,khk_Cyrl,hs,"--Жишээ нь: --Нэг, Хоёр, Гурван, Дөрвөн, Таван, Зургаан, Долоон, Найман, Есөн.--үр дүнг нь жагсаалтыг буцааж, дараа нь -аас тухайн дугаарыг тухайн дугаарын нэрээр солих-- Цэнгэг тооны жагсаалтыг авч, 1-9 хүртэлх тоонуудыг ангилан, --  >>> byLength [2,1,1,4,5,8,2,3]
--  [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""]
--  If the list is empty, return an empty list:
--  >>> byLength []
--  []
--  If the list has any strange number ignore it:
--  >>> byLength [1,(-1),55]
--  [""One""]
byLength :: [Int] -> [String]
byLength arr =","byLength :: [Int] -> [String]
byLength arr = map digitName . reverse . sort . filter isValid $ arr
  where
    isValid x = x >= 1 && x <= 9
    digitName x = case x of
      1 -> ""One""
      2 -> ""Two""
      3 -> ""Three""
      4 -> ""Four""
      5 -> ""Five""
      6 -> ""Six""
      7 -> ""Seven""
      8 -> ""Eight""
      9 -> ""Nine""
      _ -> error ""Unexpected number""","
main :: IO ()
main = do
  let candidate = byLength
  if candidate [2,1,1,4,5,8,2,3] == [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-1),55] == [""One""] then pure () else error ""assertion failed""
  if candidate [1,(-1),3,2] == [""Three"",""Two"",""One""] then pure () else error ""assertion failed""
  if candidate [9,4,8] == [""Nine"",""Eight"",""Four""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_106,khk_Cyrl,hs,"--Жишээ нь:--i-ийн факториел нь 1 - i хүртэлх тоонуудын үржүүлэлт юм (1 * 2 * ... * i).--i 1-ээс эхэлнэ.--эсвэл 1-ээс i хүртэлх тоонуудын нийлбэр.--i нь тэгш байвал i-ийн i-ийн хүчин зүйл болох хэмжээ n-ийн жагсаалтыг буцааж өгдөг.--""n"" хэмжээнд ""f"" функцийг хэрэгжүүлнэ.--  >>> f 5
--  [1,2,6,24,15]
f :: Int -> [Int]
f n =","f :: Int -> [Int]
f n = map g [1..n]
  where
    g i
      | even i    = factorial i
      | otherwise = sum [1..i]
    
    factorial 0 = 1
    factorial m = product [1..m]","
main :: IO ()
main = do
  let candidate = f
  if candidate 5 == [1,2,6,24,15] then pure () else error ""assertion failed""
  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  if candidate 3 == [1,2,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_107,khk_Cyrl,hs,"--1-р жишээ: --бүтэн тооны палиндром нь ((1, n), багтаан ордог.-- Эерэг бүтэн тоо n-г өгвөл тэг ба хос тоотой тупл буцаана.--  >>> evenOddPalindrome 3
--  (1, 2)
--  Explanation:
--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
--  Example 2:
--  >>> evenOddPalindrome 12
--  (4, 6)
--  Explanation:
--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
--  Note:
--  1. 1 <= n <= 10^3
--  2. returned tuple has the number of even and odd integer palindromes respectively.
evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n =","evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n = (length evens, length odds)
  where
    isPalindrome x = show x == reverse (show x)
    palindromes = filter isPalindrome [1..n]
    evens = filter even palindromes
    odds  = filter odd palindromes","
main :: IO ()
main = do
  let candidate = evenOddPalindrome
  if candidate 123 == (8, 13) then pure () else error ""assertion failed""
  if candidate 12 == (4, 6) then pure () else error ""assertion failed""
  if candidate 3 == (1, 2) then pure () else error ""assertion failed""
  if candidate 63 == (6, 8) then pure () else error ""assertion failed""
  if candidate 25 == (5, 6) then pure () else error ""assertion failed""
  if candidate 19 == (4, 6) then pure () else error ""assertion failed""
  if candidate 9 == (4, 5) then pure () else error ""assertion failed""
  if candidate 1 == (0, 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_108,khk_Cyrl,hs,"--Жишээ нь -123 нь -1, 2, 3-д тэмдэглэгдсэн тоотой.--Хэрэв тоо сөрөг бол түүний анхны тэмдэглэгдсэн цифр нь сөрөг болно: --0-ээс дээш тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо--Count_nums функцийг бичих. Энэ функц нь бүхэл тоонуудын жагсаалтыг авч, буцааж өгнө.--  >>> countNums []
--  0
--  >>> countNums [(-1),11,(-11)]
--  1
--  >>> countNums [1,1,2]
--  3
countNums :: [Int] -> Int
countNums arr =","countNums :: [Int] -> Int
countNums arr = length $ filter ((> 0) . sumDigits) arr
  where
    sumDigits 0 = 0
    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)
                  in sum digits","
main :: IO ()
main = do
  let candidate = countNums
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),0] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error ""assertion failed""
  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error ""assertion failed""
  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error ""assertion failed""
  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_109,khk_Cyrl,hs,"--Жишээ нь: --Нэмэлт: Энэ жагсаалтад онцгой элементүүд байх нь баталгаатай.--Хэрэв өгөгдсөн жагсаалт хоосон бол True-г буцаана.--true эсвэл false гэж буцааж өг.--Дээрх үйлдлийг хийж, ангилагдсан жагсаалтыг олж авах боломжтой бол --жагсаалтын эхлэл байршил буюу 0-р индекс.--жагсаалтын сүүлчийн элемент нь  руу шилжинэ.--Нэг баруун шилжих үйлдэл нь жагсаалтын бүх элементүүдийг нэгээр шилжүүлэх гэсэн үг юм.--Та баруун шилжилтийн үйлдлийг ямар ч тооны удаа хийх боломжтой.--дараах үйл ажиллагааг өгсөн жагсаалтад: -- гэж үйлдснээр жагсаалтыг буурч байгаа бус дарааллаар ангилах боломжтой.--Танд дараахь зүйлсийг зааж өгөх болно.--Бидэнд N бүтэн тооны жагсаалт байна arr[1], arr[2], ..., arr[N].--  >>> moveOneBall [3,4,5,1,2]
--  True
--  Explanation: By performin 2 right shift operations, non-decreasing order can
--  be achieved for the given list.
--  >>> moveOneBall [3,5,4,1,2]
--  False
--  Explanation:It is not possible to get non-decreasing order for the given
--  list by performing any number of right shift operations.
moveOneBall :: [Int] -> Bool
moveOneBall arr =","moveOneBall :: [Int] -> Bool
moveOneBall [] = True
moveOneBall arr = canBeSorted (arr ++ arr)
  where
    n = length arr
    canBeSorted xs = any isSorted (take n <$> tails xs)
    isSorted ys = and $ zipWith (<=) ys (tail ys)
    tails [] = []
    tails l@(_:xs) = l : tails xs","
main :: IO ()
main = do
  let candidate = moveOneBall
  if candidate [3,4,5,1,2] == True then pure () else error ""assertion failed""
  if candidate [3,5,10,1,2] == True then pure () else error ""assertion failed""
  if candidate [4,3,1,2] == False then pure () else error ""assertion failed""
  if candidate [3,5,4,1,2] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_110,khk_Cyrl,hs,"--Жишээ нь: --Үгүй бол ""Үгүй"" гэж буцаана.--lst1 -ийн бүх элементүүд тэгш байхын тулд ""YES"" гэж буцаана.--Хэрэв lst1 ба lst2 хооронд элементүүдийг солилцох боломжтой бол--LST1 болон LST2 хооронд солилцох элементийн тоог хязгаарлахгүй.--Энэ нь зөвхөн хос тоонуудын жагсаалтыг бүрдүүлэхэд тустай.--элементүүдийг солилцох боломжтой эсэхийг тодорхойлдог.--Энэ асуудлаар та хоёр жагсаалтыг авч, функцийг хэрэгжүүлнэ.--  >>> exchange [1,2,3,4] [1,2,3,4]
--  ""YES""
--  >>> exchange [1,2,3,4] [1,5,3,4]
--  ""NO""
--  It is assumed that the input lists will be non-empty.
exchange :: [Int] -> [Int] -> String
exchange lst1 lst2 =","exchange :: [Int] -> [Int] -> String
exchange lst1 lst2
  | all even lst1 = ""YES""
  | null oddLst1 || null evenLst2 = ""NO""
  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)
                in if possibility then ""YES"" else ""NO""
  where
    oddLst1 = filter odd lst1
    evenLst2 = filter even lst2","
main :: IO ()
main = do
  let candidate = exchange
  if candidate [1,2,3,4] [1,2,3,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [1,5,3,4] == ""NO"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [2,1,4,3] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,3] == ""NO"" then pure () else error ""assertion failed""
  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == ""NO"" then pure () else error ""assertion failed""
  if candidate [100,200] [200,200] == ""YES"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_111,khk_Cyrl,hs,"--Жишээ нь:--Хэрэв хэд хэдэн үсгийг ижил утгаар нь бичсэн бол бүгдийг нь буцааж өг.--Хамгийн их давтагдсан, мөн тоотой үсэг.-- Буудал тус тусдаалах бага үсгийг илэрхийлдэг суваг өгөөд холбооны жагсаалтыг буцааж өгнө.--  >>> histogram ""a b c""
--  [(""a"", 1), (""b"", 1), (""c"", 1)]
--  >>> histogram ""a b b a""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""a b c a b""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""b b b b a""
--  [(""b"", 4)]
--  >>> histogram """"
--  []
histogram :: String -> [(String, Int)]
histogram test =","import Data.List (group, sort)
import Data.Ord (comparing)

histogram :: String -> [(String, Int)]
histogram input =
  let wordsList = words input
      grouped = group $ sort wordsList
      countList = map (\ws -> (head ws, length ws)) grouped
      maxCount = if null countList then 0 else maximum $ map snd countList
  in filter ((== maxCount) . snd) countList","
main :: IO ()
main = do
  let candidate = histogram
  if candidate ""a b b a"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c a b"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c d g"" == [(""a"", 1), (""b"", 1), (""c"", 1), (""d"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""b b b b a"" == [(""b"", 4)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""a"" == [(""a"", 1)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_112,khk_Cyrl,hs,"--Жишээ --Та үр дүнгийн string болон True/False-г агуулсан тупелийг шалгахын тулд буцааж өгөх ёстой. --Хэрэв тэр нь өмнөх болон цааш нь ижил уншдаг бол үсгийн үсэг нь палиндром гэж нэрлэгддэг.--дараа нь үр дүнгийн үсгийн palindrome эсэхийг шалгана. --Бидэнд s болон c гэсэн хоёр үсгийн тэмдэгт өгөгдсөн бөгөөд та s-ийн бүх тэмдэгтүүдийг устгах ёстой бөгөөд энэ нь c-ийн ямар ч тэмдэгттэй тэнцүү.--Ажлын хэсэг--  >>> reverseDelete ""abcde"" ""ae""
--  (""bcd"", False)
--  >>> reverseDelete ""abcdef"" ""b""
--  (""acdef"", False)
--  >>> reverseDelete ""abcdedcba"" ""ab""
--  (""cdedc"", True)
reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =","import Data.List (filter)

reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =
  let result = filter (`notElem` c) s
  in (result, result == reverse result)","
main :: IO ()
main = do
  let candidate = reverseDelete
  if candidate ""abcde"" ""ae"" == (""bcd"", False) then pure () else error ""assertion failed""
  if candidate ""abcdef"" ""b"" == (""acdef"", False) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""ab"" == (""cdedc"", True) then pure () else error ""assertion failed""
  if candidate ""dwik"" ""w"" == (""dik"", False) then pure () else error ""assertion failed""
  if candidate ""a"" ""a"" == ("""", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" """" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""v"" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""vabba"" ""v"" == (""abba"", True) then pure () else error ""assertion failed""
  if candidate ""mamma"" ""mia"" == ("""", True) then pure () else error ""assertion failed""
  pure ()"
HumanEval_113,khk_Cyrl,hs,"--нэвтрүүлэгт i-р дугаарт нэг бус тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны--Энэ нь бүх i-г  гэсэн тооноор орлуулах ёстой.--Бүтээгдэхүүний i элемент нь -- Өгөгдсөн үсгийн жагсаалтыг өгөөд, үсэг бүр зөвхөн тооны тоонуудаас бүрддэг бол жагсаалтыг буцааж өгнө.--  >>> oddCount [""1234567""]
--  [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
--  >>> oddCount [""3"",""11111111""]
--  [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""]
oddCount :: [String] -> [String]
oddCount lst =","oddCount :: [String] -> [String]
oddCount lst = map formatString lst
  where
    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""

    countOdds :: String -> Int
    countOdds str = length $ filter isOddDigit str

    formatString :: String -> String
    formatString str =
      let oddCount = countOdds str in
      ""the number of odd elements "" ++ show oddCount ++ 
      ""n the str"" ++ show oddCount ++ ""ng "" ++ show oddCount ++
      "" of the "" ++ show oddCount ++ ""nput.""","
main :: IO ()
main = do
  let candidate = oddCount
  if candidate [""1234567""] == [""the number of odd elements 4n the str4ng 4 of the 4nput.""] then pure () else error ""assertion failed""
  if candidate [""3"",""11111111""] == [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""] then pure () else error ""assertion failed""
  if candidate [""271"",""137"",""314""] == [""the number of odd elements 2n the str2ng 2 of the 2nput."",""the number of odd elements 3n the str3ng 3 of the 3nput."",""the number of odd elements 2n the str2ng 2 of the 2nput.""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_114,khk_Cyrl,hs,"--Жишээ --тооны .--Бүх бүтэн тооны жагсаалтыг авч үзвэл, хоосон биш бүх тооны жагсаалтын хамгийн бага нийлбэрийг олох хэрэгтэй.--  >>> minsubarraysum [2,3,4,1,2,4]
--  1
--  >>> minsubarraysum [(-1),(-2),(-3)]
--  (-6)
minsubarraysum :: [Int] -> Int
minsubarraysum nums =","minsubarraysum :: [Int] -> Int
minsubarraysum nums = minimum $ scanl1 (\acc x -> min x (acc + x)) nums","
main :: IO ()
main = do
  let candidate = minsubarraysum
  if candidate [2,3,4,1,2,4] == 1 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error ""assertion failed""
  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error ""assertion failed""
  if candidate [0,10,20,1000000] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [10,11,13,8,3,4] == 3 then pure () else error ""assertion failed""
  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error ""assertion failed""
  if candidate [(-10)] == (-10) then pure () else error ""assertion failed""
  if candidate [7] == 7 then pure () else error ""assertion failed""
  if candidate [1,(-1)] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_115,khk_Cyrl,hs,"--1-р жишээ: --Баярыг бууруулах шаардлагатай удаагаа оруул.--Таны ажил бол савнуудыг ашиглан буудлыг хооронд нь буулгах явдал юм.--Бүх савны багтаамж ижил.--Усны орд бүрээс ус авахын тулд усан сандалтай байдаг.--1 нь нэг усны нэгжийг илэрхийлдэг.--Та бүхэнд усан ордын дөрвөлжин хэлбэртэй сүлжээ бий.--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1
--  6
--  Example 2:
--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2
--  5
--  Example 3:
--  >>> maxFill [[0,0,0],[0,0,0]] 5
--  0
--  Constraints:
--  * all wells have the same length
--  * 1 <= grid.length <= 10^2
--  * 1 <= grid[:,1].length <= 10^2
--  * grid[i][j] -> 0 | 1
--  * 1 <= capacity <= 10
maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity =","maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity = ceiling (fromIntegral totalWater / fromIntegral capacity)
  where
    totalWater = sum (map sum grid)","
main :: IO ()
main = do
  let candidate = maxFill
  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error ""assertion failed""
  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error ""assertion failed""
  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_116,khk_Cyrl,hs,"--Үүнийг дараах байдлаар хэрэгжүүлэх ёстой: --Нэгтэй ижил тооны хувьд арванхоёрдугаар цэгт суурилсан ангилах.--Хоёрдугаар дугаарт байгаа нэгүүдийн тоо өсөх дарааллаар.--Энэ ката дээр та сөрөг бус бүхэл тоонуудын жагсаалтыг дараах байдлаар ангилах хэрэгтэй.--  >>> sortArray [1,5,2,3,4]
--  [1,2,3,4,5]
--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]
--  [(-6),(-5),(-4),(-3),(-2)]
--  >>> sortArray [1,0,2,3,4]
--  [0,1,2,3,4]
sortArray :: [Int] -> [Int]
sortArray arr =","import Data.Bits (popCount)
import Data.List (sortBy)

sortArray :: [Int] -> [Int]
sortArray arr = sortBy compareOnesAndValues arr
  where
    compareOnesAndValues x y =
      let onesX = popCount x
          onesY = popCount y
      in if onesX == onesY
         then compare x y
         else compare onesX onesY","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error ""assertion failed""
  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error ""assertion failed""
  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error ""assertion failed""
  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  pure ()"
HumanEval_117,khk_Cyrl,hs,"--Жишээ нь: --тэмдэглэл: та оролт шугам зөвхөн үсэг, орон зай байдаг гэж үзвэл болно. --Хэрэв s үсгийн тоо хоосон бол функц нь хоосон жагсаалтыг буцаах ёстой. --n салаа үгс, эдгээр үгс s салаа үгсийн дараалалтай.--яг  гэсэн үгтэй s үсгийн бүх үгийн жагсаалтыг буцаан өгөгдсөн функц--Сэтгэлэгт s, натураль n тоо өгвөл та нар үүнийг хэрэгжүүлэх үүрэг хүлээсэн.--  >>> selectWords ""Mary had a little lamb"" 4
--  [""little""]
--  >>> selectWords ""Mary had a little lamb"" 3
--  [""Mary"",""lamb""]
--  >>> selectWords ""simple white space"" 2
--  []
--  >>> selectWords ""Hello world"" 4
--  [""world""]
--  >>> selectWords ""Uncle sam"" 3
--  [""Uncle""]
selectWords :: String -> Int -> [String]
selectWords s n =","selectWords :: String -> Int -> [String]
selectWords s n = filter (\word -> countConsonants word == n) (words s)
  where
    countConsonants = length . filter (`elem` consonants)
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""","
main :: IO ()
main = do
  let candidate = selectWords
  if candidate ""Mary had a little lamb"" 4 == [""little""] then pure () else error ""assertion failed""
  if candidate ""Mary had a little lamb"" 3 == [""Mary"",""lamb""] then pure () else error ""assertion failed""
  if candidate ""simple white space"" 2 == [] then pure () else error ""assertion failed""
  if candidate ""Hello world"" 4 == [""world""] then pure () else error ""assertion failed""
  if candidate ""Uncle sam"" 3 == [""Uncle""] then pure () else error ""assertion failed""
  if candidate """" 4 == [] then pure () else error ""assertion failed""
  if candidate ""a b c d e f"" 1 == [""b"",""c"",""d"",""f""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_118,khk_Cyrl,hs,"--Жишээ нь:--Та өгөгдсөн string нь зөвхөн англи хэлний үсэг агуулдаг гэж үзэж болно. --дээр дурдсан нөхцөлд нийцсэн ямар ч үсэг олох.--Эхлэл, төгсгөлд байгаа үсэгүүд тооцогдохгүй. Хэрэв та тэгээгүй бол хоосон үсэг буцаана.--үгний баруун талд хоёр сурталчилгаа (хэмжээний хувьд хялбар).--Та нарт үг өгөөд байна. Таны ажил бол хамгийн ойрхон үсэгтэй үгийн хооронд орсон үгийн үсэг олох юм.--  >>> getClosestVowel ""yogurt""
--  ""u""
--  >>> getClosestVowel ""FULL""
--  ""U""
--  >>> getClosestVowel ""quick""
--  """"
--  >>> getClosestVowel ""ab""
--  """"
getClosestVowel :: String -> String
getClosestVowel word =","getClosestVowel :: String -> String
getClosestVowel word = go (reverse word) False
  where
    vowels = ""aeiouAEIOU""
    go [] _ = """"
    go (x:xs) lastWasConsonant
      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False
      | x `notElem` vowels = go xs True
      | otherwise = go xs False","
main :: IO ()
main = do
  let candidate = getClosestVowel
  if candidate ""yogurt"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""full"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""easy"" == """" then pure () else error ""assertion failed""
  if candidate ""eAsy"" == """" then pure () else error ""assertion failed""
  if candidate ""ali"" == """" then pure () else error ""assertion failed""
  if candidate ""bad"" == ""a"" then pure () else error ""assertion failed""
  if candidate ""most"" == ""o"" then pure () else error ""assertion failed""
  if candidate ""ab"" == """" then pure () else error ""assertion failed""
  if candidate ""ba"" == """" then pure () else error ""assertion failed""
  if candidate ""quick"" == """" then pure () else error ""assertion failed""
  if candidate ""anime"" == ""i"" then pure () else error ""assertion failed""
  if candidate ""Asia"" == """" then pure () else error ""assertion failed""
  if candidate ""Above"" == ""o"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_119,khk_Cyrl,hs,"--Жишээ нь: --Хэрэв сайн үсгийн бүтэц бий бол ""Yes"" гэж, өөр тохиолдолд ""No"" гэж өгнө.--""()) "" гэж байхгүй.--Жишээ нь: ""((((() "" үсгийн дугаар нь сайн, харин  үсгийн дугаар нь сайн.--S-ийн бүх дугуй нь S-ийн бүх дугуй нь сайн бол зөвхөн сайн гэж тооцогддог.--ямар нэг дарааллаар, үр дүнд гарсан string сайн байх болно.--Таны ажил нь хоёр үрийг нэгтгэх боломжтой эсэхийг шалгах явдал юм.--зөвхөн ""("" эсвэл "") "" гэсэн дугаарыг ашиглах.--Та хоёр үсгийн жагсаалтыг авч, аль аль нь нээлттэй үсэг юм.--  >>> matchParens [""()("","")""]
--  ""Yes""
--  >>> matchParens ["")"","")""]
--  ""No""
matchParens :: [String] -> String
matchParens lst =","matchParens :: [String] -> String
matchParens [a, b] =
    if isValid (a ++ b) || isValid (b ++ a) then ""Yes"" else ""No""
  where
    isValid :: String -> Bool
    isValid = go 0
      where
        go 0 [] = True
        go _ [] = False
        go n (x:xs)
            | x == '('  = go (n + 1) xs
            | x == ')'  = n > 0 && go (n - 1) xs
    isValid _ = False","
main :: IO ()
main = do
  let candidate = matchParens
  if candidate [""()("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"","")""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()(())"",""())())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")())"",""(()()(""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(())))"",""(()())((""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""()"",""())""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()("",""()))()""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(((("",""((())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")(()"",""(()(""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")("","")(""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"",""(""] == ""Yes"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_120,khk_Cyrl,hs,"--1-р жишээ: --k урттай хамгийн их k тоотой нь arr. -- бүтэн тооны жагсаалтыг өгөөд, k эерэг бүтэн тоог өгөөд, ангилагдсан жагсаалтыг буцааж өгнө.--  >>> maximum [(-3),(-4),5] 3
--  [(-4),(-3),5]
--  Example 2:
--  >>> maximum [4,(-4),4] 2
--  [4,4]
--  Example 3:
--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1
--  [2]
--  Note:
--  1. The length of the list will be in the range of [1, 1000].
--  2. The elements in the list will be in the range of [-1000, 1000].
--  3. 0 <= k <= len(arr)
maximum :: [Int] -> Int -> [Int]
maximum arr k =","maximum :: [Int] -> Int -> [Int]
maximum arr k = take k $ reverse $ sort arr","
main :: IO ()
main = do
  let candidate = maximum
  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error ""assertion failed""
  if candidate [4,(-4),4] 2 == [4,4] then pure () else error ""assertion failed""
  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error ""assertion failed""
  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error ""assertion failed""
  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error ""assertion failed""
  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error ""assertion failed""
  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error ""assertion failed""
  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error ""assertion failed""
  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error ""assertion failed""
  if candidate [(-10),10] 2 == [(-10),10] then pure () else error ""assertion failed""
  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_121,khk_Cyrl,hs,"--Жишээ нь:--│Цагаан тооны хоосон бус жагсаалтыг авч, тэгш байрлалд байгаа бүх хос элементийн нийлбэрийг буцаана.--  >>> solution [5,8,7,1]
--  12
--  >>> solution [3,3,3,3,3]
--  9
--  >>> solution [30,13,24,321]
--  0
solution :: [Int] -> Int
solution lst =","solution :: [Int] -> Int
solution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","
main :: IO ()
main = do
  let candidate = solution
  if candidate [5,8,7,1] == 12 then pure () else error ""assertion failed""
  if candidate [3,3,3,3,3] == 9 then pure () else error ""assertion failed""
  if candidate [30,13,24,321] == 0 then pure () else error ""assertion failed""
  if candidate [5,9] == 5 then pure () else error ""assertion failed""
  if candidate [2,4,8] == 0 then pure () else error ""assertion failed""
  if candidate [30,13,23,32] == 23 then pure () else error ""assertion failed""
  if candidate [3,13,2,9] == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_122,khk_Cyrl,hs,"--Жишээ нь:--arr-ийн эхний k элементийн хамгийн ихдээ хоёр оронтой элементийн нийлбэр. --Арт нь бүтэн тооны жагсаалтыг өгөөд, k бүтэн тоог өгнө.--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4
--  24
--  Constraints:
--  1. 1 <= len(arr) <= 100
--  2. 1 <= k <= len(arr)
addElements :: [Int] -> Int -> Int
addElements arr k =","addElements :: [Int] -> Int -> Int
addElements arr k = sum $ filter (\x -> x >= -99 && x <= 99) $ take k arr","
main :: IO ()
main = do
  let candidate = addElements
  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error ""assertion failed""
  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error ""assertion failed""
  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error ""assertion failed""
  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error ""assertion failed""
  if candidate [1] 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_123,khk_Cyrl,hs,"--get_odd_collatz(5) нь [1, 5] # 5 -ийн collatz дарааллын тоо нь [5, 16, 8, 4, 2, 1], тиймээс хос тоо нь зөвхөн 1, 5 байдаг. --Жишээ нь: --2. буцаасан жагсаалтыг өсөх дарааллаар ангилан. --1. Collatz(1) нь [1].--тэмдэглэл: --n-ийн ямар ч үнэ цэнийг үл харгалзан дараалал нь үргэлж 1 хүрнэ.--Хэрэв өмнөх тоо нь хос бол дараагийн тоо нь өмнөх тооны 3 дахин их болно.--өмнөх үе нь дараах байдлаар: өмнөх үе нь тэгш бол дараагийн үе нь -ийн хагас нь болно.--дараах байдлаар: ямар ч эерэг бүтэн тоо n-ээс эхлэнэ. Дараа нь бүх тоог -ээс олж авна.--Collatz-ийн таамаглал нь математикийн тодорхойлсон дарааллыг хамарсан таамаглал юм .--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> getOddCollatz 5
--  [1,5]
getOddCollatz :: Int -> [Int]
getOddCollatz n =","getOddCollatz :: Int -> [Int]
getOddCollatz n = sort . filter odd $ collatzSequence n
  where
    collatzSequence 1 = [1]
    collatzSequence x
      | even x    = x : collatzSequence (x `div` 2)
      | otherwise = x : collatzSequence (3 * x + 1)","
main :: IO ()
main = do
  let candidate = getOddCollatz
  if candidate 14 == [1,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 5 == [1,5] then pure () else error ""assertion failed""
  if candidate 12 == [1,3,5] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_124,khk_Cyrl,hs,"--4. Сана нь mm-dd-yyyy хэлбэртэй байх ёстой.--3. Сарын тоо нь 1ээс багагүй, 12ээс ихгүй байх ёстой.--2. Өдөр тоо нь 1,3,5,7,8,10,12 сарын хувьд 1ээс багагүй эсвэл 31 өдрөөс ихгүй. Өдөр тоо нь 4,6,9,11 сарын хувьд 1ээс багагүй эсвэл 30 өдрөөс ихгүй. Өдөр тоо нь 2-р сарын хувьд 1ээс багагүй эсвэл 29 өдрөөс ихгүй.--1. Өдөр тэмдэгтийн үсэг хоосон биш.--Дараах дүрмүүдийн бүгдийг нь биелүүлсэн бол энэ өдөр хүчин төгөлдөр болно: --Хэрэв өдөр хүчин төгөлдөр бол True, эсвэл False өгнө. --Та өгөгдсөн хугацааны үсгийн баталгаажуулагч функцийг бичих хэрэгтэй.--  >>> validDate ""03-11-2000""
--  True
--  >>> validDate ""15-01-2012""
--  False
--  >>> validDate ""04-0-2040""
--  False
--  >>> validDate ""06-04-2020""
--  True
--  >>> validDate ""06/04/2020""
--  False
validDate :: String -> Bool
validDate date =","import Text.Read (readMaybe)
import Data.List.Split (splitOn)

validDate :: String -> Bool
validDate date =
    case splitOn ""-"" date of
        [m, d, y] -> isValidMonthDayYear m d y
        _         -> False

isValidMonthDayYear :: String -> String -> String -> Bool
isValidMonthDayYear m d y =
    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of
        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day
        _ -> False

isValidMonth :: Int -> Bool
isValidMonth month = month >= 1 && month <= 12

isValidDay :: Int -> Int -> Bool
isValidDay month day
    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31
    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30
    | month == 2                           = day >= 1 && day <= 29
    | otherwise                            = False","
main :: IO ()
main = do
  let candidate = validDate
  if candidate ""03-11-2000"" == True then pure () else error ""assertion failed""
  if candidate ""15-01-2012"" == False then pure () else error ""assertion failed""
  if candidate ""04-0-2040"" == False then pure () else error ""assertion failed""
  if candidate ""06-04-2020"" == True then pure () else error ""assertion failed""
  if candidate ""01-01-2007"" == True then pure () else error ""assertion failed""
  if candidate ""03-32-2011"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""04-31-3000"" == False then pure () else error ""assertion failed""
  if candidate ""06-06-2005"" == True then pure () else error ""assertion failed""
  if candidate ""21-31-2000"" == False then pure () else error ""assertion failed""
  if candidate ""04-12-2003"" == True then pure () else error ""assertion failed""
  if candidate ""04122003"" == False then pure () else error ""assertion failed""
  if candidate ""20030412"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04-12"" == False then pure () else error ""assertion failed""
  if candidate ""04-2003"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_126,khk_Cyrl,hs,"--Жишээ нь:--тоо, False буцаах. Санасан тоогүй, зөвхөн бүтэн тоо гэж үзнэ.--Хэрэв жагсаалтад нэгээс илүү давхар бичиг байгаа бол -- Хэлэлцээрийн жагсаалтыг авч, тэдгээрийг ангилан эсэх нь эсэх нь эргүүлнэ.--  >>> isSorted [5]
--  True
--  >>> isSorted [1,2,3,4,5]
--  True
--  >>> isSorted [1,3,2,4,5]
--  False
--  >>> isSorted [1,2,3,4,5,6]
--  True
--  >>> isSorted [1,2,3,4,5,6,7]
--  True
--  >>> isSorted [1,3,2,4,5,6,7]
--  False
--  >>> isSorted [1,2,2,3,3,4]
--  True
--  >>> isSorted [1,2,2,2,3,4]
--  False
isSorted :: [Int] -> Bool
isSorted lst =","isSorted :: [Int] -> Bool
isSorted lst = go lst Nothing
  where
    go [] _ = True
    go [x] _ = True
    go (x:y:xs) prev
      | x > y = False
      | x == y && prev == Just x = False
      | otherwise = go (y:xs) (Just x)","
main :: IO ()
main = do
  let candidate = isSorted
  if candidate [5] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,7] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  if candidate [1] == True then pure () else error ""assertion failed""
  if candidate [3,2,1] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,2,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,3,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,3,3,4] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_127,khk_Cyrl,hs,"--[оно/оно] жишээнүүд: --Хэрэв хоёр дугаар зөрүүгүй бол ""NO"" гэж буцаана.--Үгүй бол ""ҮҮН"" гэж буцаана.--Хэрэв хажуугийн урт нь нэг үндсэн тоо бол ""YES"" гэж буцаана.--Энэ нь нэг, нэгэн тоо биш.--Жишээ нь, (1, 3), (2, 4) интервалын хажуугийн цэг нь (2, 3) --Энэ нь нэг үндсэн тоо юм.--Таны ажил нь эдгээр хоёр цэгцлэх урт нь --Аливаа интервалын эхэн нь төгсгөлөөс нь бага эсвэл тэгш гэж үздэг.--эхлэл, төгсгөл хоёрыг багтаадаг.--Энэ интервалууд нь хаагдсан байна гэсэн үг юм. Энэ нь интервалын (ахиц, эх) --Тухайлбал, интервал = (хурц, төгсгөл) = (1, 2).--Та хоёр удаагийн интервалтай.--  >>> intersection (1, 2) (2, 3)
--  ""NO""
--  >>> intersection ((-1), 1) (0, 4)
--  ""NO""
--  >>> intersection ((-3), (-1)) ((-5), 5)
--  ""YES""
intersection :: (Int, Int) -> (Int, Int) -> String
intersection interval1 interval2 =","intersection :: (Int, Int) -> (Int, Int) -> String
intersection (start1, end1) (start2, end2) = 
    if intersectionLength > 0 && isPrime intersectionLength
    then ""YES""
    else ""NO""
  where
    intersectionStart = max start1 start2
    intersectionEnd = min end1 end2
    intersectionLength = intersectionEnd - intersectionStart + 1
    
    isPrime :: Int -> Bool
    isPrime n
      | n <= 1 = False
      | n == 2 = True
      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","
main :: IO ()
main = do
  let candidate = intersection
  if candidate (1, 2) (2, 3) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-1), 1) (0, 4) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-3), (-1)) ((-5), 5) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-2), 2) ((-4), 0) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-11), 2) ((-1), (-1)) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (3, 5) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (1, 2) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-2), (-2)) ((-3), (-2)) == ""NO"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_128,khk_Cyrl,hs,"--Жишээ нь:--тэмдэглэл: хоосон ордны хувьд юу ч эргүүлэхгүй.--жагсаалтын дугаар бүр 1, -1 эсвэл 0-ээр илэрхийлэгддэг.--Бүх тэмдэгтүүдийн үр дүнг бүтэн тооны хэмжээний нийлбэрээр үржүүлнэ --Та бүхэл тооны жагсаалтыг авч, эргэж оруулах хэрэгтэй.--  >>> prodSigns [1,2,2,(-4)]
--  Just (9)
--  >>> prodSigns [0,1]
--  Just (0)
--  >>> prodSigns []
--  Just (Nothing)
prodSigns :: [Int] -> Maybe Int
prodSigns arr =","prodSigns :: [Int] -> Maybe Int
prodSigns [] = Nothing
prodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","
main :: IO ()
main = do
  let candidate = prodSigns
  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error ""assertion failed""
  if candidate [0,1] == Just (0) then pure () else error ""assertion failed""
  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error ""assertion failed""
  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,0] == Just (0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_129,khk_Cyrl,hs,"--Жишээ нь: --Хамгийн бага зам дамнасан ячейгуудын үнэ цэнийн дараалсан жагсаалтыг буцаана. --Хариулт нь цорын ганц байх нь баталгаатай. --lst_A[j] = lst_B[j].--Ийм л lst_A[i] < lst_B[i] болон ямар ч j (1 <= j < i) -д бид --lst_B-ээс илүү, өөрөөр хэлбэл, i (1 <= i <= k) гэсэн бүтэн тооны индекс байдаг.--lst_A нь үг хэлний хувьд бага байдаг.--A болон B гэж заасан өрөөнүүдийн үнэ цэнийг дараалсан жагсаалтад оруулсны дараа--A зам (k урттай) нь B зам (k урттай) -аас бага гэж тооцогддог бол --Та цацагдаад чадахгүй.--заавал өөр өөр байх ёстой).--k урттай зам нь яг k сэлбэгт (одоогийн байдлаар биш) зочилсон гэсэн үг гэдгийг анхаарна уу.--Утасны дугуй--Өөрөөр хэлбэл, та одоогийн --аль ч цонх, болон та аль ч алхам дээр та хөрш цонх руу шилжих боломжтой, --Та K урттай хамгийн бага замыг хайж олох хэрэгтэй.--inclusive нь сүлжээний ястнууд дээр яг нэг удаа гарч ирдэг.--сүлжээний бүх цүнхүүд нь үнэ цэнийг агуулдаг. [1, N * N] хүрээний бүх бүтэн тоо--N мөр, N суурьтай (N >= 2) ба k гэсэн эерэг бүтэн тоотой сүлжээг авч үзвэл,--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3
--  [1,2,1]
--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1
--  [1]
minpath :: [[Int]] -> Int -> [Int]
minpath grid k =","import Data.List (sort, sortBy)
import Data.Ord (comparing)
import Control.Monad (guard)

minpath :: [[Int]] -> Int -> [Int]
minpath grid k = head $ sort paths
  where
    n = length grid
    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]
    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
      where
        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n
    value (r, c) = grid !! r !! c
    paths = do
      start <- cells
      findPaths k [start]
    findPaths 1 path = return $ map value path
    findPaths l path@(current:_) = do
      next <- neighbors current
      findPaths (l-1) (next : path)","
main :: IO ()
main = do
  let candidate = minpath
  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error ""assertion failed""
  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error ""assertion failed""
  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error ""assertion failed""
  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error ""assertion failed""
  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error ""assertion failed""
  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error ""assertion failed""
  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_130,khk_Cyrl,hs,"--Жишээ нь: --Трибоначчигийн дараалал дахь эхний n + 1 тоо.--Та нарт сөрөг бус бүтэн тоо n өгвөл та нар -ийн жагсаалтыг буцааж өгөх хэрэгтэй.--= 2 + 3 + 3 = 8 --tri(3) = tri(2) + tri(1) + tri(4)--tri(4) = 3 --tri(2) = 1 + (2 / 2) = 2 --Жишээ нь: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), хэрэв n нь хос юм бол. --tri ((n) = 1 + n / 2, хэрэв n нь тэгш байна. --tri(1) = 3 --Трибоначчигийн дарааллыг дараахь тохиолдлоор тодорхойлдог:--Гэвч хүмүүс Трибоначчигийн дараалал гэж юу болохыг мэдэхгүй.--Фибоначчийн дарааллыг бүгд мэднэ. Энэ дарааллыг математикчид их судалсан.--  >>> tri 3
--  [1,3,2,8]
tri :: Int -> [Int]
tri n =","tri :: Int -> [Int]
tri n = map tribonacci [0..n]
  where
    -- Define the recursive function to calculate the tribonacci value for a given n
    tribonacci :: Int -> Int
    tribonacci 0 = 1
    tribonacci 1 = 3
    tribonacci x
      | even x    = 1 + x `div` 2
      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","
main :: IO ()
main = do
  let candidate = tri
  if candidate 3 == [1,3,2,8] then pure () else error ""assertion failed""
  if candidate 4 == [1,3,2,8,3] then pure () else error ""assertion failed""
  if candidate 5 == [1,3,2,8,3,15] then pure () else error ""assertion failed""
  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error ""assertion failed""
  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error ""assertion failed""
  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error ""assertion failed""
  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error ""assertion failed""
  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error ""assertion failed""
  if candidate 0 == [1] then pure () else error ""assertion failed""
  if candidate 1 == [1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_131,khk_Cyrl,hs,"--Жишээ нь: --Бүх тоо нь тэгш байвал 0-г буцаана. -- Эерэг бүтэн тоо n-г өгвөл хос тооны үр дүнг буцаана. --  >>> digits 1
--  1
--  >>> digits 4
--  0
--  >>> digits 235
--  15
digits :: Int -> Int
digits n =","digits :: Int -> Int
digits n
  | null oddDigits = 0
  | otherwise      = product oddDigits
  where
    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","
main :: IO ()
main = do
  let candidate = digits
  if candidate 5 == 5 then pure () else error ""assertion failed""
  if candidate 54 == 5 then pure () else error ""assertion failed""
  if candidate 120 == 1 then pure () else error ""assertion failed""
  if candidate 5014 == 5 then pure () else error ""assertion failed""
  if candidate 98765 == 315 then pure () else error ""assertion failed""
  if candidate 5576543 == 2625 then pure () else error ""assertion failed""
  if candidate 2468 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_132,khk_Cyrl,hs,"--Энэ нь дараалалд хамгийн багадаа нэг багц нь нийлсэн байна.--Функц нь зөвхөн хүчин төгөлдөр хуудасны дараалал байгаа бол True-г буцаах ёстой .-- Зөвхөн квадрат дугуйгаар байгуулсан string-г оруулж ирэх функцийг бий болгох.--  >>> isNested ""[[]]""
--  True
--  >>> isNested ""[]]]]]]][[[[[]""
--  False
--  >>> isNested ""[][]""
--  False
--  >>> isNested ""[]""
--  False
--  >>> isNested ""[[][]]""
--  True
--  >>> isNested ""[[]][[""
--  True
isNested :: String -> Bool
isNested string =","isNested :: String -> Bool
isNested string = go string 0 False
  where
    go [] _ nested = nested
    go (x:xs) depth nested
      | x == '['  = go xs (depth + 1) (nested || depth >= 1)
      | x == ']' && depth > 0 = go xs (depth - 1) nested
      | otherwise = go xs depth nested","
main :: IO ()
main = do
  let candidate = isNested
  if candidate ""[[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]][[[[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[][]"" == False then pure () else error ""assertion failed""
  if candidate ""[]"" == False then pure () else error ""assertion failed""
  if candidate ""[[[[]]]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]]]]]"" == False then pure () else error ""assertion failed""
  if candidate ""[][][[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[]]"" == False then pure () else error ""assertion failed""
  if candidate ""[[]][["" == True then pure () else error ""assertion failed""
  if candidate ""[[][]]"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""[[[[[[[["" == False then pure () else error ""assertion failed""
  if candidate ""]]]]]]]]"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_133,khk_Cyrl,hs,"--Жишээ нь: --жагсаалтын элемент болгон дээр нь дугуйлах int ((Tiling) хамгийн түрүүнд.--Та өгөгдсөн жагсаалтын дугаар дугаарт нь нийлүүлсэн тоонуудын дугаарт нь нийлүүлсэн тоонуудын тоог буцаах хэрэгтэй, --Та бүхэнд тооны жагсаалт өгнө.--  >>> lst [1.0,2.0,3.0]
--  14
--  >>> lst [1.0,4.0,9.0]
--  98
--  >>> lst [1.0,3.0,5.0,7.0]
--  84
--  >>> lst [1.4,4.2,0.0]
--  29
--  >>> lst [-2.4,1.0,1.0]
--  6
sumSquares :: [Float] -> Int
sumSquares lst =","import Data.List (foldl')
import Prelude hiding (sum)

sumSquares :: [Float] -> Int
sumSquares lst = foldl' (\acc x -> acc + ceiling x ^ 2) 0 lst","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error ""assertion failed""
  if candidate [1.4,4.2,0.0] == 29 then pure () else error ""assertion failed""
  if candidate [-2.4,1.0,1.0] == 6 then pure () else error ""assertion failed""
  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error ""assertion failed""
  if candidate [10000.0,10000.0] == 200000000 then pure () else error ""assertion failed""
  if candidate [-1.4,4.6,6.3] == 75 then pure () else error ""assertion failed""
  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error ""assertion failed""
  if candidate [0.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0] == 1 then pure () else error ""assertion failed""
  if candidate [-1.0,1.0,0.0] == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_134,khk_Cyrl,hs,"--Жишээ нь: --тэмдэглэл: ""word"" нь орон зайгаар тус тусдаа хуваагдсан тэмдэгтүүдийн бүлэг юм.--үгний нэг хэсэг, бусад нь худал.--өгөгдсөн үсгийн тэмдэгт нь цагаан толгойн тэмдэгт бөгөөд  биш юм.--Хамгийн сүүлчийн тэмдэгт нь True бол буцаах функцийг бий болгоно.--  >>> checkIfLastCharIsALetter ""apple pie""
--  False
--  >>> checkIfLastCharIsALetter ""apple pi e""
--  True
--  >>> checkIfLastCharIsALetter ""apple pi e ""
--  False
--  >>> checkIfLastCharIsALetter """"
--  False
checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt =","checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt = 
    let trimmed = reverse . dropWhile (== ' ') $ reverse txt
    in case trimmed of
        [] -> False
        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","
main :: IO ()
main = do
  let candidate = checkIfLastCharIsALetter
  if candidate ""apple"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e"" == True then pure () else error ""assertion failed""
  if candidate ""eeeee"" == False then pure () else error ""assertion failed""
  if candidate ""A"" == True then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie "" == False then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie 1"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""eeeee e "" == False then pure () else error ""assertion failed""
  if candidate ""apple pie"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e "" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_135,khk_Cyrl,hs,"--Жишээ нь: --дугуй үнэ цэнийг .--ийм элемент байхгүй бол -1-ийг буцаана.--нь шууд өмнөх элементээс илүү эсвэл тэгш биш юм.--Элементийн хамгийн том индексийг эргүүлэн өгөгдсөн функцийг бий болгох--  >>> canArrange [1,2,4,3,5]
--  3
--  >>> canArrange [1,2,3]
--  (-1)
canArrange :: [Int] -> Int
canArrange arr =","canArrange :: [Int] -> Int
canArrange arr = go arr (-1) 0
  where
    go [] maxIdx _ = maxIdx
    go [_] maxIdx _ = maxIdx
    go (x:y:xs) maxIdx idx
      | x >= y    = go (y:xs) idx (idx + 1)
      | otherwise = go (y:xs) maxIdx (idx + 1)","
main :: IO ()
main = do
  let candidate = canArrange
  if candidate [1,2,4,3,5] == 3 then pure () else error ""assertion failed""
  if candidate [1,2,4,5] == (-1) then pure () else error ""assertion failed""
  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error ""assertion failed""
  if candidate [4,8,5,7,3] == 4 then pure () else error ""assertion failed""
  if candidate [] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_136,khk_Cyrl,hs,"--Жишээ нь: --Хэрэв сөрөг эсвэл эерэг бүтэн тоо байхгүй бол тэдгээрийг Nothing гэж буцаана.--Тодорхой жагсаалтад байгаа бүх тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо--хамгийн том нь сөрөг бүтэн тоо бөгөөд ""b"" нь хамгийн бага нь --""a"" нь ""a, b"" гэсэн дугаартай тул ""a, b"" гэсэн дугаартай буцаах функцийг бий болгоно.--  >>> largestSmallestIntegers [2,4,1,3,5,7]
--  (Nothing, 1)
--  >>> largestSmallestIntegers []
--  (Nothing, Nothing)
--  >>> largestSmallestIntegers [0]
--  (Nothing, Nothing)
largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst =","largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst = (largestNegative, smallestPositive)
  where
    negatives = filter (< 0) lst
    positives = filter (> 0) lst
    largestNegative = if null negatives then Nothing else Just (maximum negatives)
    smallestPositive = if null positives then Nothing else Just (minimum positives)","
main :: IO ()
main = do
  let candidate = largestSmallestIntegers
  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error ""assertion failed""
  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error ""assertion failed""
  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error ""assertion failed""
  if candidate [] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [0] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_138,khk_Cyrl,hs,"--Жишээ -- өгөгдсөн n тоог яг 4 эерэг тэгш тооны нийлбэр болгон бичиж болох эсэхийг үнэлнэ.--  >>> isEqualToSumEven 4
--  False
--  >>> isEqualToSumEven 6
--  False
--  >>> isEqualToSumEven 8
--  True
isEqualToSumEven :: Int -> Bool
isEqualToSumEven n =","isEqualToSumEven :: Int -> Bool
isEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","
main :: IO ()
main = do
  let candidate = isEqualToSumEven
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == True then pure () else error ""assertion failed""
  if candidate 11 == False then pure () else error ""assertion failed""
  if candidate 12 == True then pure () else error ""assertion failed""
  if candidate 13 == False then pure () else error ""assertion failed""
  if candidate 16 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_139,khk_Cyrl,hs,"--Жишээ нь: --n > 0 --brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! --Бразилийн факториал нь:--  >>> specialFactorial 4
--  288
--  The function will receive an integer as input and should return the special
--  factorial of this integer.
specialFactorial :: Int -> Int
specialFactorial n =","specialFactorial :: Int -> Int
specialFactorial n = product [factorial x | x <- [1..n]]
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)","
main :: IO ()
main = do
  let candidate = specialFactorial
  if candidate 4 == 288 then pure () else error ""assertion failed""
  if candidate 5 == 34560 then pure () else error ""assertion failed""
  if candidate 7 == 125411328000 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_140,khk_Cyrl,hs,"--дараа нь дараалан орсон бүх орон зайг -  гэж солих--Хэрэв нэг үсгийн дараалан 2 гаруй орон зайтай бол, -- Бичгийн суваг өгвөл бүх орон зайг нь доргуур тэмдэгтээр солих, --  >>> fixSpaces "" Example""
--  ""Example""
--  >>> fixSpaces "" Example 1""
--  ""Example_1""
--  >>> fixSpaces "" Example 2""
--  ""_Example_2""
--  >>> fixSpaces "" Example 3""
--  ""_Example-3""
fixSpaces :: String -> String
fixSpaces text =","fixSpaces :: String -> String
fixSpaces text = concatMap replaceSpaces (groupSpaces text)
  where
    groupSpaces :: String -> [String]
    groupSpaces [] = []
    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest

    replaceSpaces :: String -> String
    replaceSpaces spaces@(x:_)
      | x == ' ' && length spaces > 2 = ""-""
      | x == ' ' = replicate (length spaces) '_'
      | otherwise = spaces","
main :: IO ()
main = do
  let candidate = fixSpaces
  if candidate ""Example"" == ""Example"" then pure () else error ""assertion failed""
  if candidate ""Mudasir Hanif "" == ""Mudasir_Hanif_"" then pure () else error ""assertion failed""
  if candidate ""Yellow Yellow  Dirty  Fellow"" == ""Yellow_Yellow__Dirty__Fellow"" then pure () else error ""assertion failed""
  if candidate ""Exa   mple"" == ""Exa-mple"" then pure () else error ""assertion failed""
  if candidate ""   Exa 1 2 2 mple"" == ""-Exa_1_2_2_mple"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_141,khk_Cyrl,hs,"--Жишээ нь: --- Тоон үсгийн дараах суваг нь ['txt', 'exe', 'dll'] нуудын нэг байх ёстой.--Латин үсэгт (""a""-""z"" болон ""A""-""Z"") --- Тоон цэгээс өмнөх суваг нь хоосон байх ёсгүй бөгөөд энэ нь -ээс эхлэх үсгээр эхэлдэг.--- Файлын нэр нь яг нэг цэгтэй.--- Файл нэр нь гурван тоодон (""0""-""9"") -аас илүү байх ёсгүй.--биелсэн байна: --Дараах бүх нөхцөл бүрдэх тохиолдолд зөвхөн дараахь нөхцөл бүрдэх тохиолдолд файлын нэр нь хүчин төгөлдөр гэж тооцогддог.--Хэрэв файлын нэр нь хүчин төгөлдөр бол ""Тийм"" гэж, өөр тохиолдолд ""Үгүй"" гэж өгнө.--Файл нэртэй string-г авч, --  >>> fileNameCheck ""example.txt""
--  ""Yes""
--  >>> fileNameCheck ""1example.dll""
--  ""No""
fileNameCheck :: String -> String
fileNameCheck file_name =","import Data.Char (isDigit, isLetter)

fileNameCheck :: String -> String
fileNameCheck file_name 
  | countDots /= 1 = ""No""
  | length digits > 3 = ""No""
  | null beforeDot || not (isLetter (head beforeDot)) = ""No""
  | afterDot `notElem` validExtensions = ""No""
  | otherwise = ""Yes""
  where 
    (beforeDot, afterDot) = span (/= '.') file_name
    countDots = length $ filter (== '.') file_name
    digits = filter isDigit file_name
    validExtensions = [""txt"", ""exe"", ""dll""]
    afterDot = if null dotAndAfter then """" else tail dotAndAfter
    dotAndAfter = dropWhile (/= '.') file_name","
main :: IO ()
main = do
  let candidate = fileNameCheck
  if candidate ""example.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1example.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s1sdf3.asd"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""K.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""MY16FILE3.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""His12FILE94.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_Y.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""?aREYA.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""/this_is_valid.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.wow"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txtexe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""#this2_i4s_5valid.ten"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""@this1_is6_valid.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_12valid.6exe4.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""all.exe.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_No.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""Is3youfault.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""no_one#knows.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1I563_Yes3.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_Yes3.txtt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final..txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final132"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_f4indsartal132."" == ""No"" then pure () else error ""assertion failed""
  if candidate "".txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s."" == ""No"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_142,khk_Cyrl,hs,"--Жишээ нь: --Энэ функц нь дараа нь бүх нэрийн нийлбэр дүнг буцааж өгдөг.--3 -ийн олон тооны тоо бөгөөд индекс нь 3 -ийн олон тооны тоо биш 4 -ийн олон тооны тоо бол бүтэн тооны тоог нэгтгэх болно.--Энэ функц нь бүхэл тооны жагсаалтыг авах болно.--"" --  >>> lst
--  [1,2,3]
--  >>> lst
--  []
--  >>> lst
--  [(-1),(-5),2,(-1),(-5)]
sumSquares :: [Int] -> Int
sumSquares lst =","sumSquares :: [Int] -> Int
sumSquares lst = sum $ zipWith transform [0..] lst
  where
    transform idx x
      | idx `mod` 3 == 0 = x * x
      | idx `mod` 4 == 0 = x * x * x
      | otherwise        = x","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1,2,3] == 6 then pure () else error ""assertion failed""
  if candidate [1,4,9] == 14 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error ""assertion failed""
  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error ""assertion failed""
  if candidate [0] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error ""assertion failed""
  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error ""assertion failed""
  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error ""assertion failed""
  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error ""assertion failed""
  pure ()"
HumanEval_143,khk_Cyrl,hs,"--1-р жишээ: --шинэ дугаарын үгсийн дарааллыг анхны дугаарынхтай адил байх ёстой.-- нь нэгдүгээр тоо юм.--Мөн эх өгүүлбэрээс үгсийг агуулсан үсгийн дарааллыг буцааж өгөх хэрэгтэй, --дуудлагад зарим үгс хоорондоо хоорондоо тусгаарлагдсанаас --Та бүхэнд өгүүлбэрийг илэрхийлэх үсгийн дугайг өгнө.--  >>> wordsInSentence ""This is a test""
--  ""is""
--  Example 2:
--  >>> wordsInSentence ""lets go for swimming""
--  ""go for""
--  Constraints:
--  * 1 <= len(sentence) <= 100
--  * sentence contains only letters
wordsInSentence :: String -> String
wordsInSentence sentence =","import Data.List (intercalate)

wordsInSentence :: String -> String
wordsInSentence sentence = intercalate "" "" $ filter (isPrime . length) (words sentence)

isPrime :: Int -> Bool
isPrime n | n < 2     = False
          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = wordsInSentence
  if candidate ""This is a test"" == ""is"" then pure () else error ""assertion failed""
  if candidate ""lets go for swimming"" == ""go for"" then pure () else error ""assertion failed""
  if candidate ""there is no place available here"" == ""there is no place"" then pure () else error ""assertion failed""
  if candidate ""Hi I am Hussein"" == ""Hi am Hussein"" then pure () else error ""assertion failed""
  if candidate ""go for it"" == ""go for it"" then pure () else error ""assertion failed""
  if candidate ""here"" == """" then pure () else error ""assertion failed""
  if candidate ""here is"" == ""is"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_144,khk_Cyrl,hs,"--Та x, n нь хүчин төгөлдөр хэсэг гэж үзэж болно, мөн ноль нь нэрлэгчийн хувьд байхгүй.--<ашигт тоо>/<ашигт тоо> гэж тооцвол тооцол, тооцол хоёулаа эерэг бүтэн тоо юм.--x ба n хоёулаа нь хэсэгт хамааралтай, дараах хэлбэртэй:--x * n. Хэдэн бүтэн тоо болон False  гэж үнэлвэл функц нь True-г буцаана.--Таны ажил бол энэ үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн үгийн--  >>> simplify ""1/5"" ""5/1""
--  True
--  >>> simplify ""1/6"" ""2/1""
--  False
--  >>> simplify ""7/10"" ""10/2""
--  False
simplify :: String -> String -> Bool
simplify x n =","import Data.Ratio (denominator, numerator, (%))

simplify :: String -> String -> Bool
simplify x n =
  let (xNum, xDen) = toFraction x
      (nNum, nDen) = toFraction n
      result = (xNum * nNum) % (xDen * nDen)
  in denominator result == 1

toFraction :: String -> (Integer, Integer)
toFraction s =
  let (numStr, _:denStr) = break (=='/') s
  in (read numStr, read denStr)","
main :: IO ()
main = do
  let candidate = simplify
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/6"" ""2/1"" == False then pure () else error ""assertion failed""
  if candidate ""5/1"" ""3/1"" == True then pure () else error ""assertion failed""
  if candidate ""7/10"" ""10/2"" == False then pure () else error ""assertion failed""
  if candidate ""2/10"" ""50/10"" == True then pure () else error ""assertion failed""
  if candidate ""7/2"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""11/6"" ""6/1"" == True then pure () else error ""assertion failed""
  if candidate ""2/3"" ""5/2"" == False then pure () else error ""assertion failed""
  if candidate ""5/2"" ""3/5"" == False then pure () else error ""assertion failed""
  if candidate ""2/4"" ""8/4"" == True then pure () else error ""assertion failed""
  if candidate ""2/4"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""1/5"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_145,khk_Cyrl,hs,"--Жишээ нь: --Тэдгээрийг анхны жагсаалтад байгаа индексээр нь дараарай.--тэмдэглэл: хэрэв хэд хэдэн тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо--тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо-- өгөгдсөн бүтэн тоонуудын жагсаалтыг ангилах функцийг бичих--  >>> orderByPoints [1,11,(-1),(-11),(-12)]
--  [(-1),(-11),1,(-12),11]
--  >>> orderByPoints []
--  []
orderByPoints :: [Int] -> [Int]
orderByPoints nums =","import Data.List (sortBy)
import Data.Function (on)

orderByPoints :: [Int] -> [Int]
orderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums
  where
    sumOfDigits :: Int -> Int
    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)
    
    indexedNums :: [(Int, Int)]
    indexedNums = zip (map sumOfDigits nums) nums","
main :: IO ()
main = do
  let candidate = orderByPoints
  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error ""assertion failed""
  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error ""assertion failed""
  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_146,khk_Cyrl,hs,"--Жишээ нь: --тооны эхний болон сүүлийн тоо нь хос (1, 3, 5, 7, 9) байна.--жагсаалтад 10-аас дээш элементийн тоо, хоёулаа -- Хэлэлцэх болон буцаан ирүүлэх тооны жагсаалтыг авч буй функцийг бичих--  >>> specialfilter [15,(-73),14,(-15)]
--  1
--  >>> specialfilter [33,(-2),(-3),45,21,109]
--  2
specialfilter :: [Int] -> Int
specialfilter nums =","specialfilter :: [Int] -> Int
specialfilter nums = length $ filter isSpecial nums
  where
    isSpecial n = n > 10 && isOddFirstAndLast (abs n)

    isOddFirstAndLast :: Int -> Bool
    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit
      where
        xStr = show x
        firstDigit = head xStr
        lastDigit = last xStr

    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""","
main :: IO ()
main = do
  let candidate = specialfilter
  if candidate [5,(-2),1,(-5)] == 0 then pure () else error ""assertion failed""
  if candidate [15,(-73),14,(-15)] == 1 then pure () else error ""assertion failed""
  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error ""assertion failed""
  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error ""assertion failed""
  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_147,khk_Cyrl,hs,"--Жишээ нь:--а[i] + а[j] + а[k] нь 3-ын үржүүлэг юм.--i < j < k,  гэсэн а-ийн 3 удаагийн тоог (a[i], a[j], a[k]) буцаана.--i (1 ≤ i ≤ n) болгонд a[i] = i * i - i + 1 гэсэн утгатай.--Та бүхэл бүтэн тоог n гэж авч үзнэ үү. Та бүхэл бүтэн тооны жагсаалтыг n урттай болгох хэрэгтэй.--  >>> getMaxTriples 5
--  1
--  Explanation: 
--  a = [1, 3, 7, 13, 21]
--  The only valid triple is (1, 7, 13).
getMaxTriples :: Int -> Int
getMaxTriples n =","getMaxTriples :: Int -> Int
getMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]
  where
    a = [i * i - i + 1 | i <- [1..n]]","
main :: IO ()
main = do
  let candidate = getMaxTriples
  if candidate 5 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 4 then pure () else error ""assertion failed""
  if candidate 10 == 36 then pure () else error ""assertion failed""
  if candidate 100 == 53361 then pure () else error ""assertion failed""
  pure ()"
HumanEval_149,khk_Cyrl,hs,"--Жишээ нь: --Бүх үг ижил урттай гэж та бодож болох юм.--Функц нь дараалсан дарааллаар дараалсан дарааллын жагсаалтыг буцаах ёстой. --Хэрэв хоёр үг ижил урттай бол жагсаалтыг цагаан толгойн дарааллаар дараарай.--Энэ дүрмийн дагуу жагсаалтыг дараалсан байдлаар буцааж өгөх ёстой.--Тогтоолын дарааллын дагуу үгс нь өсч байх ёстой.--Энэ нь дублик байж болно.--Жагсаал нь үргэлж тооны жагсаал биш, үсгийн жагсаал байдаг.-- нь дараалалтайгаар жагсаалтыг буцааж өгдөг.--энэ нь хос урттай string-ийг устгадаг, --. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .--  >>> listSort [""aa"",""a"",""aaa""]
--  [""aa""]
--  >>> listSort [""ab"",""a"",""aaa"",""cd""]
--  [""ab"",""cd""]
sortedListSum :: [String] -> [String]
sortedListSum lst =","sortedListSum :: [String] -> [String]
sortedListSum lst = sortBy compareStrings (filter evenLength lst)
  where
    evenLength s = even (length s)
    compareStrings s1 s2
      | length s1 == length s2 = compare s1 s2
      | otherwise = compare (length s1) (length s2)","
main :: IO ()
main = do
  let candidate = sortedListSum
  if candidate [""aa"",""a"",""aaa""] == [""aa""] then pure () else error ""assertion failed""
  if candidate [""school"",""AI"",""asdf"",""b""] == [""AI"",""asdf"",""school""] then pure () else error ""assertion failed""
  if candidate [""d"",""b"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""d"",""dcba"",""abcd"",""a""] == [""abcd"",""dcba""] then pure () else error ""assertion failed""
  if candidate [""AI"",""ai"",""au""] == [""AI"",""ai"",""au""] then pure () else error ""assertion failed""
  if candidate [""a"",""b"",""b"",""c"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""aaaa"",""bbbb"",""dd"",""cc""] == [""cc"",""dd"",""aaaa"",""bbbb""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_150,khk_Cyrl,hs,"--Жишээ нь: --нэгдүгээр тоо бөгөөд y-ийн үнэ цэнийг буцааж өгөх ёстой.--Хэдэн энгийн програм нь n бол x-ийн үнэ цэнийг буцааж өгөх ёстой.--  >>> xOrY 7 34 12
--  34
--  >>> xOrY 15 8 5
--  5
xOrY :: Int -> Int -> Int -> Int
xOrY n x y =","xOrY :: Int -> Int -> Int -> Int
xOrY n x y = if isPrime n then x else y

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = xOrY
  if candidate 7 34 12 == 34 then pure () else error ""assertion failed""
  if candidate 15 8 5 == 5 then pure () else error ""assertion failed""
  if candidate 3 33 5212 == 33 then pure () else error ""assertion failed""
  if candidate 1259 3 52 == 3 then pure () else error ""assertion failed""
  if candidate 7919 (-1) 12 == (-1) then pure () else error ""assertion failed""
  if candidate 3609 1245 583 == 583 then pure () else error ""assertion failed""
  if candidate 91 56 129 == 129 then pure () else error ""assertion failed""
  if candidate 6 34 1234 == 1234 then pure () else error ""assertion failed""
  if candidate 1 2 0 == 0 then pure () else error ""assertion failed""
  if candidate 2 2 0 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_151,khk_Cyrl,hs,"--Санасан тоог тооцвол, энэ нь нэг тоо юм.-- Хэлэлцээрийн жагсаалтыг авч, тоонуудын квадратын нийлбэрийг буцааж өгнө үү.--  >>> doubleTheDifference [1,3,2,0]
--  10
--  >>> doubleTheDifference [(-1),(-2),0]
--  0
--  >>> doubleTheDifference [9,(-2)]
--  81
--  >>> doubleTheDifference [0]
--  0
--  If the input list is empty, return 0.
doubleTheDifference :: [Float] -> Int
doubleTheDifference lst =","doubleTheDifference :: [Float] -> Int
doubleTheDifference lst = 
    sum [x * x | x <- map round lst, x > 0, odd x]","
main :: IO ()
main = do
  let candidate = doubleTheDifference
  if candidate [.0] == 0 then pure () else error ""assertion failed""
  if candidate [5.0,4.0] == 25 then pure () else error ""assertion failed""
  if candidate [0.1,0.2,0.3] == 0 then pure () else error ""assertion failed""
  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error ""assertion failed""
  if candidate [0.2,3.0,5.0] == 34 then pure () else error ""assertion failed""
  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error ""assertion failed""
  pure ()"
HumanEval_152,khk_Cyrl,hs,"--жишээ: --үнэ цэнэ нь 0 бөгөөд үгүй бол үнэ цэнэ нь таамаглал ба онооны хоорондын төгс ялгаа юм. --Хэрэв тэд зөв таамагласан бол, --Та хоёр жагсаалтыг авч, ижил урттай оноо, таамаглалтай болно.--Таны ажил бол хэд хэдэн тоглолтын үр дүнг зөв таамагласан эсэхийг тодорхойлох явдал юм.--Энэ нь заавал тэмдэглэж, харьцуулах хэрэгтэй.--Энэ үед таны мэдрэмж, бодол санаа нь ямар байсныг мэдэхэд л хангалттай.--Бид бүгд л удаан хүлээсэн ямар нэг зүйл үр дүнд хүрэх тухай мэдрэмжийг санаж байгаа байх.--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]
--  [0,0,0,0,3,3]
--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]
--  [4,4,1,0,0,6]
compare :: [Int] -> [Int] -> [Int]
compare game guess =","compare :: [Int] -> [Int] -> [Int]
compare game guess = zipWith (\g s -> abs (g - s)) game guess","
main :: IO ()
main = do
  let candidate = compare
  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error ""assertion failed""
  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error ""assertion failed""
  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error ""assertion failed""
  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_153,khk_Cyrl,hs,"--Жишээ нь:--(ажлын хүч нь -1) --""Slices.SERVINGSliCes"" гэж буцааж өгнө. Учир нь ""SERVINGSliCes"" бол хамгийн хүчтэй өргөтгөл юм.--['SERVINGSliCes', 'Cheese', 'StuFfed'] гэж нэмж бичвэл та --Жишээ нь, хэрэв та ""Slices"" анги болон --жагсаалтад хамгийн түрүүнд гарч байгаа нэг зүйлийг сонгоно.--Хэрэв ижил хүчтэй хоёр эсвэл түүнээс дээш өргөтгөл байгаа бол та--формат: ClassName.StrongestExtensionName. --Та хамгийн хүчтэй өргөтгөлийг олж, эндээс үсгийн үсэг буцаах хэрэгтэй.--өргөтгөлийн нэр дээр CAP - SM фракцээр хүч чадал нь тодорхойлогддог. --өргөтгөлийн нэр дээрх үсгүүд, SM нь бага үсгийн тоо байх ёстой --CAP нь том үсгийн тоо бол --Өргөн дэлгэрэнгүйг нь ангид нэмэлт ангиудыг тавих зорилгоор ашигладаг.-- Та нэг анги (хүсэл) болон сунгалын жагсаалтыг авна.--  >>> strongestExtension ""my_class"" [""AA"",""Be"",""CC""]
--  ""my_class.AA""
strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions =","strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions = class_name ++ ""."" ++ strongestExt
  where
    calculateStrength :: String -> Int
    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)
    
    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)
    
    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)
    maxStrength ext1 ext2
      | snd ext1 > snd ext2 = ext1
      | otherwise           = ext2","
main :: IO ()
main = do
  let candidate = strongestExtension
  if candidate ""Watashi"" [""tEN"",""niNE"",""eIGHt8OKe""] == ""Watashi.eIGHt8OKe"" then pure () else error ""assertion failed""
  if candidate ""Boku123"" [""nani"",""NazeDa"",""YEs.WeCaNe"",""32145tggg""] == ""Boku123.YEs.WeCaNe"" then pure () else error ""assertion failed""
  if candidate ""__YESIMHERE"" [""t"",""eMptY"",""nothing"",""zeR00"",""NuLl__"",""123NoooneB321""] == ""__YESIMHERE.NuLl__"" then pure () else error ""assertion failed""
  if candidate ""K"" [""Ta"",""TAR"",""t234An"",""cosSo""] == ""K.TAR"" then pure () else error ""assertion failed""
  if candidate ""__HAHA"" [""Tab"",""123"",""781345"",""-_-""] == ""__HAHA.123"" then pure () else error ""assertion failed""
  if candidate ""YameRore"" [""HhAas"",""okIWILL123"",""WorkOut"",""Fails"",""-_-""] == ""YameRore.okIWILL123"" then pure () else error ""assertion failed""
  if candidate ""finNNalLLly"" [""Die"",""NowW"",""Wow"",""WoW""] == ""finNNalLLly.WoW"" then pure () else error ""assertion failed""
  if candidate ""_"" [""Bb"",""91245""] == ""_.Bb"" then pure () else error ""assertion failed""
  if candidate ""Sp"" [""671235"",""Bb""] == ""Sp.671235"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_154,khk_Cyrl,hs,"--Та хоёр үг өгөөд байна. Хэрэв хоёр дахь үг эсвэл түүний ямар нэг эргэлт нь эхний үгийн дэд үсэг бол True-г буцаах хэрэгтэй.--  >>> cycpatternCheck ""abcd"" ""abd""
--  False
--  >>> cycpatternCheck ""hello"" ""ell""
--  True
--  >>> cycpatternCheck ""whassup"" ""psus""
--  False
--  >>> cycpatternCheck ""abab"" ""baa""
--  True
--  >>> cycpatternCheck ""efef"" ""eeff""
--  False
--  >>> cycpatternCheck ""himenss"" ""simen""
--  True
cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b =","cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b = any (`isInfixOf` a) rotations
  where
    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","
main :: IO ()
main = do
  let candidate = cycpatternCheck
  if candidate ""xyzw"" ""xyw"" == False then pure () else error ""assertion failed""
  if candidate ""yello"" ""ell"" == True then pure () else error ""assertion failed""
  if candidate ""whattup"" ""ptut"" == False then pure () else error ""assertion failed""
  if candidate ""efef"" ""fee"" == True then pure () else error ""assertion failed""
  if candidate ""abab"" ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""winemtt"" ""tinem"" == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_155,khk_Cyrl,hs,"--Жишээ нь:--│ бүтэн тоо өгвөл, тэгш болон хос тоотой туплейг буцаана.--  >>> evenOddCount (-12)
--  (1, 1)
--  >>> evenOddCount 123
--  (1, 2)
evenOddCount :: Int -> (Int, Int)
evenOddCount num =","evenOddCount :: Int -> (Int, Int)
evenOddCount num = (length evens, length odds)
  where
    digits = map (read . (:[])) . show . abs $ num
    evens = filter even digits
    odds  = filter odd digits","
main :: IO ()
main = do
  let candidate = evenOddCount
  if candidate 7 == (0, 1) then pure () else error ""assertion failed""
  if candidate (-78) == (1, 1) then pure () else error ""assertion failed""
  if candidate 3452 == (2, 2) then pure () else error ""assertion failed""
  if candidate 346211 == (3, 3) then pure () else error ""assertion failed""
  if candidate (-345821) == (3, 3) then pure () else error ""assertion failed""
  if candidate (-2) == (1, 0) then pure () else error ""assertion failed""
  if candidate (-45347) == (2, 3) then pure () else error ""assertion failed""
  if candidate 0 == (1, 0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_156,khk_Cyrl,hs,"--Жишээ нь: --Хязгаарлалт: 1 <= num <= 1000 -- гэж бичнэ.--Эерэг бүтэн тоог авч, түүний ромын тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон--  >>> intToMiniRoman 19
--  ""xix""
--  >>> intToMiniRoman 152
--  ""clii""
--  >>> intToMiniRoman 426
--  ""cdxxvi""
intToMiniRoman :: Int -> String
intToMiniRoman number =","intToMiniRoman :: Int -> String
intToMiniRoman number = concatMap (replicateSymbol number) romanNumerals
  where
    romanNumerals = [(1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
                     (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
                     (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""), (1, ""i"")]
    
    replicateSymbol :: Int -> (Int, String) -> String
    replicateSymbol n (value, symbol)
      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)
      | otherwise = """"","
main :: IO ()
main = do
  let candidate = intToMiniRoman
  if candidate 19 == ""xix"" then pure () else error ""assertion failed""
  if candidate 152 == ""clii"" then pure () else error ""assertion failed""
  if candidate 251 == ""ccli"" then pure () else error ""assertion failed""
  if candidate 426 == ""cdxxvi"" then pure () else error ""assertion failed""
  if candidate 500 == ""d"" then pure () else error ""assertion failed""
  if candidate 1 == ""i"" then pure () else error ""assertion failed""
  if candidate 4 == ""iv"" then pure () else error ""assertion failed""
  if candidate 43 == ""xliii"" then pure () else error ""assertion failed""
  if candidate 90 == ""xc"" then pure () else error ""assertion failed""
  if candidate 94 == ""xciv"" then pure () else error ""assertion failed""
  if candidate 532 == ""dxxxii"" then pure () else error ""assertion failed""
  if candidate 900 == ""cm"" then pure () else error ""assertion failed""
  if candidate 994 == ""cmxciv"" then pure () else error ""assertion failed""
  if candidate 1000 == ""m"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_157,khk_Cyrl,hs,"--Жишээ нь:--90 градус.--Төв булант гурвалжин нь нэг өнцөг нь тэгш өнцөг эсвэл --Хоёр талд нь тэгш өнцөгт гурвалжин үүснэ, өөр тохиолдолд буруу.--Гурван талын гурван талын урт нь True бол--  >>> rightAngleTriangle 3 4 5
--  True
--  >>> rightAngleTriangle 1 2 3
--  False
rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c =","rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c = 
    let [x, y, z] = sort [a, b, c]
    in x^2 + y^2 == z^2
    where sort = Data.List.sort","
main :: IO ()
main = do
  let candidate = rightAngleTriangle
  if candidate 3 4 5 == True then pure () else error ""assertion failed""
  if candidate 1 2 3 == False then pure () else error ""assertion failed""
  if candidate 10 6 8 == True then pure () else error ""assertion failed""
  if candidate 2 2 2 == False then pure () else error ""assertion failed""
  if candidate 7 24 25 == True then pure () else error ""assertion failed""
  if candidate 10 5 7 == False then pure () else error ""assertion failed""
  if candidate 5 12 13 == True then pure () else error ""assertion failed""
  if candidate 15 8 17 == True then pure () else error ""assertion failed""
  if candidate 48 55 73 == True then pure () else error ""assertion failed""
  if candidate 1 1 1 == False then pure () else error ""assertion failed""
  if candidate 2 2 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_158,khk_Cyrl,hs,"--тэмдэгт, лексикографийн дарааллаар хамгийн түрүүнд гарч байгаа тэмдэгтийг буцаана. --олон тооны дараалсан тэмдэгтүүд нь хамгийн ихдээ ганц ч тэмдэгтгүй байх юм бол--Тогтоолд өөр өөр үгс байдаг. Хамгийн их тоотой үгийг буцааж өгөөч.--strings-ийн жагсаалтыг хүлээн зөвшөөрдөг функцийг бичих.--  >>> findMax [""name"",""of"",""string""]
--  ""string""
--  >>> findMax [""name"",""enam"",""game""]
--  ""enam""
--  >>> findMax [""aaaaaaa"",""bb"",""cc""]
--  ""aaaaaaa""
findMax :: [String] -> String
findMax words =","import Data.List (nub, sort)

findMax :: [String] -> String
findMax words = 
    head . sort . map snd . filter (\(n, _) -> n == maxUnique) $ wordUniquePairs
  where
    wordUniquePairs = [(length . nub $ word, word) | word <- words]
    maxUnique = maximum $ map fst wordUniquePairs","
main :: IO ()
main = do
  let candidate = findMax
  if candidate [""name"",""of"",""string""] == ""string"" then pure () else error ""assertion failed""
  if candidate [""name"",""enam"",""game""] == ""enam"" then pure () else error ""assertion failed""
  if candidate [""aaaaaaa"",""bb"",""cc""] == ""aaaaaaa"" then pure () else error ""assertion failed""
  if candidate [""abc"",""cba""] == ""abc"" then pure () else error ""assertion failed""
  if candidate [""play"",""this"",""game"",""of"",""footbott""] == ""footbott"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""gonna"",""rock""] == ""gonna"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""a"",""mad"",""nation""] == ""nation"" then pure () else error ""assertion failed""
  if candidate [""this"",""is"",""a"",""prrk""] == ""this"" then pure () else error ""assertion failed""
  if candidate [""b""] == ""b"" then pure () else error ""assertion failed""
  if candidate [""play"",""play"",""play""] == ""play"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_159,khk_Cyrl,hs,"--Жишээ нь:--Хэрэв хангалттай цөцгийн үлдэгдэл байхгүй бол та бүх үлдсэн цөцгийг идэх боловч өлсгөлөнд үлдэх болно.--хоолны дараа үлдсэн гурилын тоо ] --[ хоолны дараа идсэн гурилын тоог --Гэхдээ одоо өдөрт хоолныхаа хуваарийг дуусгахын тулд илүү их цагаан будаа идэх хэрэгтэй.--Та өлсгөлөнтэй харваган бөгөөд тодорхой тооны гурилыг идсэн байна.--  >>> eat 5 6 10
--  [11,4]
--  >>> eat 4 8 9
--  [12,1]
--  >>> eat 1 10 10
--  [11,0]
--  >>> eat 2 11 5
--  [7,0]
--  Variables:
--  @number : integer
--  the number of carrots that you have eaten.
--  @need : integer
--  the number of carrots that you need to eat.
--  @remaining : integer
--  the number of remaining carrots thet exist in stock
--  Constrain:
--  * 0 <= number <= 1000
--  * 0 <= need <= 1000
--  * 0 <= remaining <= 1000
--  Have fun :)
eat :: Int -> Int -> Int -> [Int]
eat number need remaining =","eat :: Int -> Int -> Int -> [Int]
eat number need remaining
  | remaining >= need = [number + need, remaining - need]
  | otherwise = [number + remaining, 0]","
main :: IO ()
main = do
  let candidate = eat
  if candidate 5 6 10 == [11,4] then pure () else error ""assertion failed""
  if candidate 4 8 9 == [12,1] then pure () else error ""assertion failed""
  if candidate 1 10 10 == [11,0] then pure () else error ""assertion failed""
  if candidate 2 11 5 == [7,0] then pure () else error ""assertion failed""
  if candidate 4 5 7 == [9,2] then pure () else error ""assertion failed""
  if candidate 4 5 1 == [5,0] then pure () else error ""assertion failed""
  pure ()"
HumanEval_160,khk_Cyrl,hs,"--Operator list нь дор хаяж нэг оператор, operand list нь дор хаяж хоёр операндтай байдаг.--Operand нь сөрөг бус бүх бүтэн тоонуудын жагсаалт юм.--Операторын жагсаалтын урт нь операнд жагсаалтын урт - нэгтэй тэнцүү.--тэмдэглэл: --=> үр дүн = 9 --үр дүн = 2 + 3 * 4 - 5 --жагсаалт = [2, 3, 4, 5] --оператор['+', '*', '-'] --Жишээ нь:--Хэтсэлтийн тоо (**) --Цэцэрлэгт хуваарилсан ( // ) --Өргөтгөх (*) --Хямарлах ( - ) --Нэмэлт (+) --Алгебрийн үндсэн үйлдлүүд:--Энэ үгсийн үнэлгээг буцааж өгнө.--альгебрийг бүтээхэд өгөгдсөн хоёр жагсаалтыг ашигла.--Эхний жагсаалтад алгебрийн үндсэн үйлдлүүд байдаг.doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand =","doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand = evaluate operand operator
  where
    evaluate [x] [] = x
    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops
      where
        result = applyOperation op x y

    applyOperation ""+"" a b = a + b
    applyOperation ""-"" a b = a - b
    applyOperation ""*"" a b = a * b
    applyOperation ""//"" a b = a `div` b
    applyOperation ""**"" a b = a ^ b
    applyOperation _ _ _ = error ""Unsupported operation""","
main :: IO ()
main = do
  let candidate = doAlgebra
  if candidate [""**"",""*"",""+""] [2,3,4,5] == 37 then pure () else error ""assertion failed""
  if candidate [""+"",""*"",""-""] [2,3,4,5] == 9 then pure () else error ""assertion failed""
  if candidate [""//"",""*""] [7,3,4] == 8 then pure () else error ""assertion failed""
  pure ()"
HumanEval_161,khk_Cyrl,hs,"--Жишээ нь:--Функц нь үр дүнг нь буцааж өгөх ёстой.--Хэрэв string нь ямар ч үсэг агуулсангүй бол string-ийг буцааж үз.--Эсвэл одоо байгаагаар нь үлдээ.--s[i] нь үсэг бол, түүний хэргийг доод талаас дээш талаас эсвэл эсрэгээр нь буцаана, --Та нарт string s өгөгдсөн байна.--  >>> solve ""1234""
--  ""4321""
--  >>> solve ""ab""
--  ""AB""
--  >>> solve ""#a@C""
--  ""#A@c""
solve :: String -> String
solve s =","solve :: String -> String
solve s
  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s
  | otherwise = reverse s
  where
    toggleCase c
      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char
      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char
      | otherwise = c","
main :: IO ()
main = do
  let candidate = solve
  if candidate ""AsDf"" == ""aSdF"" then pure () else error ""assertion failed""
  if candidate ""1234"" == ""4321"" then pure () else error ""assertion failed""
  if candidate ""ab"" == ""AB"" then pure () else error ""assertion failed""
  if candidate ""#a@C"" == ""#A@c"" then pure () else error ""assertion failed""
  if candidate ""#AsdfW^45"" == ""#aSDFw^45"" then pure () else error ""assertion failed""
  if candidate ""#6@2"" == ""2@6#"" then pure () else error ""assertion failed""
  if candidate ""#$a^D"" == ""#$A^d"" then pure () else error ""assertion failed""
  if candidate ""#ccc"" == ""#CCC"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_162,khk_Cyrl,hs,"--Хэрэв 'text' бол хоосон үсгийн үсэг бол Nothing буцаана. --│ 'text' string өгөөд md5 hash-тэй тэнцэх string-ийг буцааж өгнө.--  >>> stringToMd5 ""Hello world""
--  Just (""3e25960a79dbc69b674cd4ec67a72c62"")
stringToMd5 :: String -> Maybe String
stringToMd5 text =","import qualified Data.ByteString.Char8 as C
import qualified Data.Digest.Pure.MD5 as MD5

stringToMd5 :: String -> Maybe String
stringToMd5 text
  | null text = Nothing
  | otherwise = Just $ show $ MD5.md5 $ C.pack text","
main :: IO ()
main = do
  let candidate = stringToMd5
  if candidate ""Hello world"" == Just (""3e25960a79dbc69b674cd4ec67a72c62"") then pure () else error ""assertion failed""
  if candidate """" == Just (Nothing) then pure () else error ""assertion failed""
  if candidate ""A B C"" == Just (""0ef78513b0cb8cef12743f5aeb35f888"") then pure () else error ""assertion failed""
  if candidate ""password"" == Just (""5f4dcc3b5aa765d61d8327deb882cf99"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_163,khk_Cyrl,hs,"--Жишээ нь: --b, өсөх дарааллаар.--A, b гэсэн хоёр эерэг бүтэн тоог авч, a, b хоорондын тэгш тоог буцааж өгье.--  >>> generateIntegers 2 8
--  [2,4,6,8]
--  >>> generateIntegers 8 2
--  [2,4,6,8]
--  >>> generateIntegers 10 14
--  []
generateIntegers :: Int -> Int -> [Int]
generateIntegers a b =","generateIntegers :: Int -> Int -> [Int]
generateIntegers a b = filter even [min a b .. max a b]","
main :: IO ()
main = do
  let candidate = generateIntegers
  if candidate 2 10 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 10 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 132 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 17 89 == [] then pure () else error ""assertion failed""
  pure ()"
