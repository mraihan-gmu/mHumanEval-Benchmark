[
    {
        "task_id": "HumanEval/0",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"بەلگىلەنگەن سانلار تىزىملىكىدە، بەلگىلەنگەن چەكتىن بىر-بىرىگە يېقىن ئىككى سان بار-يوقلۇقىنى تەكشۈرۈڭ. مىسال: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) يالغان >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) توغرا \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"بۇ فۇنكسىيەنىڭ كىرگۈزگۈچ قىسمى بىر قانچە گۇرۇپپا يۇشۇرۇن قوساقلارنى ئۆز ئىچىگە ئالغان بىر تار تار تارماق. سىزنىڭ مەقسىتىڭىز بۇ گۇرۇپپىنى ئايرىم تارماقلارغا ئايرىپ، بۇلارنىڭ تىزىملىكىنى قايتۇرۇشتۇر. ئايرىم گۇرۇپپىلار تەڭپۇڭ (ھەر بىر ئوچۇق قوساق توغرا تاقالغان) ، بىر-بىرىنىڭ ئىچىگە يۇشۇرۇن ئەمەس. كىرگۈزگۈچ تارماقتىكى بوشلۇقلارنى چەتكە قاق. مىسال: >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ) ' ('() ', '(()) ', '((()) ')\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"بىر خىل قوشۇمچە ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا بىر خىل ئۇسلۇبتا\"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"سىز بانكا ھېساباتىدا 0 دىن باشلانغان پۇل تاپشۇرۇش ۋە پۇل ئېلىش مەشغۇلاتلىرى تىزىملىكىگە ئىگە بولىسىز. سىزنىڭ ۋەزىپىڭىز ھېسابات سالاھىيىتىنىڭ ھەرقانداق بىر نۇقتىدا 0 دىن تۆۋەنلەپ كەتسە، ئۇنى بايقىش، شۇ نۇقتىدا فۇنكسىيە True نى قايتۇرۇش. بولمىسا False نى قايتۇرۇش كېرەك. مىسال: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"مەلۇم بىر تىزىملىك كىرگۈزۈش سانى ئۈچۈن، بۇ سانلىق مەلۇماتنىڭ ئوتتۇرىچە قىممىتى ئەتراپىدا ئوتتۇرىچە مۇتلەق پەرقنى ھېسابلايمىز. ئوتتۇرىچە مۇتلەق پەرق ھەر بىر ئېلمىنت بىلەن مەركىزىي نۇقتا ئوتتۇرىچە مۇتلەق پەرق (بۇنىڭدا ئوتتۇرىچە): MAD = ئوتتۇرىچە █ x - x_mean █ مىسال: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"كىرگۈزگۈچ تىزىملىكىدىكى ھەر ئىككى ئارقا-ئارقىدىن كەلگەن ئېلمىنتنىڭ ئارىسىغا بىر ساننى \"مەزكۇر چەكلىمە\" دەپ كىرگۈزۈڭ. `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"بۇ فۇنكسىيەنىڭ كىرگۈزگۈچ قىسمى بولسا بىر قاتار تىزىملىك بولۇپ، بىر قانچە گۇرۇپپاغا ئايرىلىپ، بوشلۇق بىلەن ئايرىلىپ قويۇلغان. ھەر بىر گۇرۇپپاغا نىسبەتەن، ئەڭ چوڭقۇر گۇرۇپپا گۇرۇپپىسى چىقىرىلىدۇ. مەسىلەن: (() (()) نىڭ ئەڭ چوڭ ئىككى گۇرۇپپا گۇرۇپپىسى بار، ((())) نىڭ ئۈچ گۇرۇپپى بار. >>> parse_nested_parens (('((()) ((())) () ((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"پەقەت مەلۇم تارماق تىزىملىكىدىن <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>\"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"بىر تاللانغان پۈتۈن سانلار تىزىملىكىگە، بىر تاللانغان سانلارنىڭ يىغىندىسى ۋە كۆپىيىشىدىن تەركىپ تاپقان بىر توپ قايتۇرۇلىدۇ. بوش سومما 0 غا، بوش كۆپىيىشى 1 غا تەڭ. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24)\"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"بىر تاللانغان پۈتۈن سانلار تىزىملىكىدىن، تىزىملىكتىكى مەلۇم ۋاقىتقىچە تېپىلغان ئەڭ چوڭ ئېلېمېنتنى چىقىرىپ چىقىرىدۇ. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"بىر تال تاردىن باشلانغان ئەڭ قىسقا پاليندرومنى تېپىش. ئالگورىتمىنىڭ پىكرى ئاددىي: - بىر تال تارنىڭ ئەڭ ئۇزۇن ئارقا قوشۇمچىنى تېپىش. - بىر تال تارنىڭ ئارقا قوشۇمچىسىنى بىر تال تارنىڭ ئاخىرىغا قوشۇش. >>> make_palindrome (('') ' ' >>> make_palindrome (('cat') 'catac' >>> make_palindrome (('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"بۇ string نىڭ پالىندروم ئىكەنلىكىنى سىناپ بېقىڭ .\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"كىرگۈزگۈچ ئىككى تار a ۋە b بولۇپ، ئۇلاردا پەقەت 1 ۋە 0 بار. بۇ كىرگۈزگۈچلەرگە قوش XOR ئىجرا قىلىپ، نەتىجىنى يەنە بىر تار قىلىپ قايتۇرۇپ بىرىمىز. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"تىزىملىكتىكى ھەرپلەر ئىچىدىن ئەڭ ئۇزۇنسىنى قايتۇرۇپ بىرىڭ. ئوخشاش ئۇزۇنلۇقتىكى ھەرپلەر كۆپ بولغان ئەھۋالدا، بىرىنچىسىنى قايتۇرۇڭ. كىرگۈزۈش تىزىملىكى بوش بولسا، يوقنى قايتۇرۇڭ. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"a ۋە b ئىككى پۈتۈن ساننىڭ ئەڭ چوڭ ئورتاق بۆلگۈچىنى قايتۇرۇپ بىرىمىز >>> ئەڭ چوڭ_ئورتاق_ بۆلگۈچ ((3, 5) 1 >>> ئەڭ چوڭ_ئورتاق_ بۆلگۈچ ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"كىرگۈزگۈچ سىتېنگنىڭ ئەڭ قىسقا سىتېنگدىن ئەڭ ئۇزۇنغىچە بولغان بارلىق ئالدىغا قوشۇلغان سۆز تىزىملىكى >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"0 دىن باشلاپ n گىچە بولغان بوشلۇق بىلەن چەكلەنگەن سانلارنى ئۆز ئىچىگە ئالغان بىر تار تارماق قايتۇرۇلىدۇ. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"بىر ھەرپ تىزىملىكىدە، ھەرپ تىزىملىكىدە قانچە ھەرپ بار؟ (ئەرەب ھەرپىدىن قەتئىينەزەر) تېپىلسۇن:\"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"بۇ فۇنكسىيەگە كىرگۈزگەن نۇتۇقلار ئالاھىدە ASCII فورماتىدا مۇزىكا نۇتۇقلىرىنى ئىپادىلەيدۇ. سىزنىڭ ۋەزىپىڭىز بىر قانچە قېتىملىق نۇتۇققا ماس كېلىدىغان پۈتۈن نۇتۇقلار تىزىملىكىنى پارسلاش: 'o' نۇتۇق، ئاخىرقى تۆت قېتىملىق نۇتۇق 'o'n't' - يېرىم نۇتۇق، ئاخىرقى ئىككى قېتىملىق نۇتۇق 'n't' - تۆت قېتىملىق نۇتۇق، ئاخىرقى بىر قېتىملىق نۇتۇق >>> parse_music. 'o'n't . o'n't . o'n't . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"مەلۇم بىر تارماق تىزىملىكنىڭ ئەسلى تارماق تىزىملىكىدە قانچە قېتىم تېپىلىدىغانلىقىنى تېپىش. ئۇدا قاتناشقان ئەھۋاللارنى سانا. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"كىرگۈزگەن سانلار تىزىملىكى بولسا \"نۆل\" دىن \"توققۇز\" گىچە بولغان سانلار تىزىملىكى بولۇپ، بوشلۇق بىلەن چەكلەنگەن. مۇۋاپىق تاللاشلار: \"نۆل\"، \"بىر\"، \"ئىككى\"، \"ئۈچ\"، \"تۆت\"، \"بەش\"، \"ئالتە\"، \"يەتتە\"، \"سەككىز\" ۋە \"توققۇز\". تىزىملىكنى ئەڭ كىچىك ساندىن ئەڭ چوڭ سانغا رەتلەپ قايتۇرىدۇ >>> sort_numbers (('ئۈچ بىر بەش') 'بىر ئۈچ بەش' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"بىر تىزىملىكتىن (ئۇزۇنلۇقى ئەڭ ئاز بولغاندا ئىككى) بىر-بىرىگە ئەڭ يېقىن بولغان ئىككىنى تاللاپ، رەت تەرتىپ بويىچە قايتۇرۇپ بېرىڭ. >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"بىر تىزىملىك سانلارنى (ئاز دېگەندە ئىككى تۈردىن) ، تىزىملىككە سىزىقلىق ئۆزگەرتىشنى ئىشلىتىمىز، يەنى ئەڭ كىچىك سان 0غا، ئەڭ چوڭ سان 1غا ئايلىنىدۇ >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"پەقەت پۈتۈن سانلار ئۈچۈنلا python قىممىتىنى تاللاپ سۈزۈۋېلىڭ >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"بىر تال string نىڭ قايتىش ئۇزۇنلۇقى >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"بىر نۇمۇرغا نىسبەتەن، n دىن كىچىك، n نى تەڭ بۆلىدىغان ئەڭ چوڭ نۇمۇرنى تېپىپ چىقىڭ.\"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"مەلۇم بىر پۈتۈن ساننىڭ ئەڭ كىچىكدىن ئەڭ چوڭغىچە بولغان تەرتىپ بويىچە نۇپۇزلۇق ئامىللار تىزىملىكىنى قايتۇرۇپ بىرىش. ھەر بىر ئامىلنىڭ ئامىل سانى ئۇنىڭ ئامىل سانى بىلەن ئوخشاش بولۇشى كېرەك. كىرگۈزۈش سانى بارلىق ئامىللارنىڭ مەھسۇلاتىغا تەڭ بولۇشى كېرەك >>> ئامىل سانى ((8) [2, 2, 2] >>> ئامىل سانى ((25) [5, 5] >>> ئامىل سانى ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"پۈتۈن سانلار تىزىملىكىدىن بىر قېتىمدىن كۆپ ئۇچرايدىغان بارلىق تۈرلەرنى چىقىرىۋېتىڭ. كىرگۈزگەن تۈرلەرنىڭ تەرتىپىنى ئوخشاش ساقلاڭ. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\".مەلۇم بىر تارماق ئۈچۈن، كىچىك ھەرپلەرنى چوڭ ھەرپكە ۋە چوڭ ھەرپلەرنى كىچىك ھەرپكە ئايلاندۇرۇڭ. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"بىرلا تارماقتىكى ھەرپلەرنى بىر قاتارغا قوشۇش >>> بىر قاتاردا قوشۇش (([]) '' >>> بىر قاتاردا قوشۇش ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"پەقەت مەلۇم بىرىكمە بىلەن باشلىنىدىغان بىرىكمە تىزىملىكىنى سۈزۈۋېلىڭ. >>> بىرىكمە بىلەن سۈزۈۋېلىڭ (prefix) ({}[]، (a) [] >>> بىرىكمە بىلەن سۈزۈۋېلىڭ (prefix) ({'abc'، (bcd'، (cde'، (array'), (a) ['abc'، (array'])\"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"تىزىملىكتىكى پەقەت ئىجابىي سانلارنى قايتۇرۇپ بىرىمىز. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1]\"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"ئەگەر بىر سان باشتا توغرا بولسا true نى قايتۇرۇپ بىرىمىز، بولمىسا خاتا. >>> is_prime (ئەسلى) (6) False (يالغان) >>> is_prime (ئەسلى) (101) True (ھەقىقى) >>> is_prime (ئەسلى) (11) True (ھەقىقى) >>> is_prime (ئەسلى) (13441) True (ھەقىقى) >>> is_prime (ئەسلى) (61) True (ھەقىقى) >>> is_prime (ئەسلى) (4) False (يالغان) >>> is_prime (ئەسلى) (1) False (يالغان) \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs بىر كۆپ نومۇرنىڭ قوشۇمچىسى. find_zero find x such that poly(x) = 0. find_zero پەقەتلا نۆل نۇقتىنى قايتۇرۇپ بېرىدۇ، ھەتتا كۆپ بولغان تەقدىردىمۇ. بۇنىڭدىن باشقا، find_zero پەقەتلا قوشۇمچە سانى ھەم نۆلدىن باشقا ئەڭ چوڭ قوشۇمچە سانى بار xs تىزىملىكىنى ئالىدۇ، چۈنكى ئۇ ھەل قىلىش كاپالىتىگە ئىگە. >>> round(find_zero[(1, 2]، 2) # f(x) = 1 + 2x -0.5 >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 1.0 \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"xs نوقتىسىدىكى xs قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە\"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"بۇ فۇنكسىيە بىر تىزىملىك l نى ئېلىپ، بىر تىزىملىك l' نى قايتۇرۇپ بېرىدۇ. بۇنىڭدا l' نىڭ ئۈچكە بۆلۈنمەيدىغان كۆرسەتكۈچلەردىكى قىممىتى l بىلەن ئوخشاش بولىدۇ. ئۈچكە بۆلۈنۈپ بولمايدىغان كۆرسەتكۈچلەردىكى قىممىتى l نىڭ ئوخشاش بولىدۇ. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"تىزىملىكتىكى رەتلەنگەن ئۆزگىچە تۈرلەرنى قايتۇرۇش >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"تىزىملىكتىكى ئەڭ چوڭ ئېلېمېنتنى قايتۇرۇپ بېرىدۇ. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"7 خانىسىنىڭ 11 ياكى 13 غا بۆلۈنۈپ بولىدىغان ن دىن كىچىك پۈتۈن سانلاردا پەيدا بولغان قېتىم سانىنى قايتۇرۇپ بىرىمىز. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"بۇ فۇنكسىيە بىر تىزىملىك l نى ئېلىپ بىر تىزىملىك l' نى قايتۇرۇپ بېرىدۇ، بۇنىڭدا l' نىڭ بىر قانچە سانلىق مەلۇماتتا l بىلەن ئوخشاش بولىدۇ، ئۇنىڭ بىر قانچە سانلىق مەلۇماتتا قىممىتى l نىڭ بىر قانچە سانلىق مەلۇماتىنىڭ قىممىتىگە باراۋەر بولىدۇ، لېكىن رەتلىنىدۇ. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"بۇ encode_cyclic فۇنكسىيە بىلەن كودلانغان كىرگۈزگۈچ سىترىنگنى قوبۇل قىلىدۇ. كودىنى چۈشەندۈرگەن سىترىنگنى قايتۇرىدۇ.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\".ئۈچ ھەرپنىڭ تۈرلىرىنى تۈرگە ئايرىپ بىر تەرەپ قىلغۇچقا ئايلاندۇرۇپ بىر تەرەپ قىلىدۇ\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib يەنە بىر نوقتا فىبوناتچى سانى بولۇپ، ئۇمۇ نوقتا سان. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triple_sum_to_zero بىر پۈتۈن سانلار تىزىملىكىدىن كىرگۈزۈش ئالىدۇ. ئەگەر تىزىملىكتە ئۈچ خىل ئايرىم ساننىڭ جۈملىسى نۆل بولسا True نى قايتۇرۇپ بېرىدۇ، بولمىسا False نى قايتۇرۇپ بېرىدۇ. >>> triple_sum_to_zero (([1, 3, 5, 0]) False >>> triple_sum_to_zero (([1, 3, -2, 1]) True >>> triple_sum_to_zero (([1, 2, 3, 7]) False >>> triple_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triple_sum_to_zero ([1, 3, -2, 1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"بىر يولنى تەسەۋۋۇر قىلىڭ. بۇ يول چەكسىز ئۇزۇن، مۇكەممەل تۈز سىزىق. n ماشىنا سولدىن ئوڭغا ماڭىدۇ. بىرلا ۋاقىتتا، باشقا بىر تۈركۈم n ماشىنا ئوڭدىن سولغا ماڭىدۇ. ئىككى تۈركۈم ماشىنا بىر-بىرىدىن بەك يىراقتىن باشلىنىدۇ. ھەممە ماشىنا ئوخشاش سۈرئەتتە ماڭىدۇ. ئىككى ماشىنا سولدىن ئوڭغا ماڭغان ماشىنا ئوڭدىن سولغا ماڭغان ماشىنا بىلەن سوقۇشقاندا سوقۇشۇپ كېتىدۇ. بىراق، ماشىنا چەكسىز كۈچلۈك، نەتىجىدە، ئۇلار ئۆز مۇساپىسى بويىچە ھەرىكەت قىلىشنى داۋاملاشتۇرىدۇ. بۇ فۇنكىسىيەدە، بۇ خىل سوقۇشلارنىڭ سانى چىقىدۇ.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"[2,3,4] ([5,3,5,2,3,3,9,0,123]) [6,4,6,3,4,4,10,1,124] بىلەن كۆپەيگەن تۈرلەر بىلەن قايتىدىغان تىزىملىك\"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero بىر پۈتۈن سانلار تىزىملىكىدىن كىرگۈزۈش ئالىدۇ. ئەگەر تىزىملىكتە ئىككى خىل ئېلمىنت بولسا True نى قايتۇرۇپ بېرىدۇ. ئەگەر ئۇنداق بولمىسا False نى قايتۇرۇپ بېرىدۇ. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"كىرگۈزگەن سان x نىڭ سان ئاساسىنى ئاساسقا ئۆزگەرتىش. ئۆزگەرتكەندىن كېيىن string نىڭ ئىپادىسىنى قايتۇرۇش. ئاساس سانى 10 دىن كىچىك. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"ئۈچبۇلۇڭنىڭ بىر تەرەپ ئۇزۇنلۇقى ۋە يۇقىرى قايتىش كۆلىمى. >>> ئۈچبۇلۇڭ_مەيدان (5,3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4 سانلار تىزمىسى بولسا Fibbonacci سانلار تىزمىسىغا ئوخشاش تىزىملىك بولۇپ، تۆۋەندىكىدەك ئېنىقلىنىدۇ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4 سانلار تىزمىسىنىڭ n-ئولۇقىنى ئۈنۈملۈك ھېسابلايدىغان فۇنكسىيە يېزىڭ. تەكرارلاشنى ئىشلەتمەڭ. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"تىزىملىكتىكى ئېلېمېنتلارنىڭ ۋارىسلىق مىديانى l. >>> مىديانى (([3, 1, 2, 4, 5]) 3 >>> مىديانى (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"بىر تال تارنىڭ بىر تال تال تاللىما بار-يوقلۇقىنى تەكشۈرىدۇ >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2^n modulo p نى قايتۇرۇپ بىرىمىز (نۇمۇرلۇقنى بىلىۋېلىڭ). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1\"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"-- بۇ بىر كىرگۈزگۈچ سىتونى، بۇ سىتوندا encode_shift ئىقتىدارى بىلەن كودلانغان. بۇ سىتوننى چۈشەندۈرۈپ قايتۇرىدۇ.\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"ھەربىر ھەرپنى 5 كە يۆتكەپ ھەرپ سانىغاندىن كېيىن .سىزگە يەنە بىر قېتىم ئۆزگەرتىش ئېلىپ كېلىدۇ\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels بولسا stringنى ئېلىپ، ۋاكالسىز string نى قايتۇرغان فۇنكسىيە. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd'\"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"ئەگەر تىزىملىكتىكى بارلىق سانلار t نىڭ ئاستىدا بولسا True نى قايتۇرۇپ بېرىدۇ. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"ئىككى ساننى قوشۇپ x ۋە y نى قوشىمىز: (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) * (x، y) *\"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"ئىككى سۆزنىڭ ھەرپى ئوخشاشمۇ؟ >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') توغرا >>> same_chars (('abcd', 'dddddddabc') توغرا >>> same_chars (('dddddddabc', 'abcd') توغرا >>> same_chars (('eabcd', 'dddddddddabc') خاتا >>> same_chars ((('abcd', 'dddddddabddce') خاتا >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') خاتا \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-چىنجى فىبوناتچى سانىنى قايتۇر. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets بولسا \"<\" ۋە \">\" ھەر بىر ئېچىلىش كويىدا ئوخشاش بىر يېپىلىش كويى بار بولسا True نى قايتۇر. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") True >>> correct_bracketing(\"<><>>\") True >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"راست قايتۇرىمىز بولسا تىزىملىك ئېلمىنتلىرى بىر خىل كۈچىيىۋاتىدۇ ياكى بىر خىل تۆۋەنلىمەكتە. >>> بىر خىل كۈچىيىۋاتىدۇ (([1, 2, 4, 20]) True >>> بىر خىل كۈچىيىۋاتىدۇ (([1, 20, 4, 10]) False >>> بىر خىل كۈچىيىۋاتىدۇ (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"ئىككى تىزىملىكنىڭ تەرتىپكە سېلىنغان ئۆزگىچە ئورتاق ئېلمىنتلىرىنى قايتۇرۇپ بېرىدۇ. >>> common (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> common (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"n نىڭ ئەڭ چوڭ نۇپۇس ئامىلىنى قايتۇرۇپ بىرىمىز. n > 1 دەپ پەرەز قىلساق نۇپۇس ئامىلى ئەمەس. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n بولسا 1 دىن n گىچە بولغان سانلارنى قوشۇپ چىقىدىغان فۇنكسىيە. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets بولسا \"(\" ۋە \"\") دېگەن ھەر بىر قۇرنىڭ ئېچىلىش قۇرنىڭمۇ ئوخشاش بىر قۇرنىڭ يېپىلىشى بولسا True نى قايتۇرۇپ بېرىدۇ. >>> correct_bracketing(\"(\") False >>> correct_bracketing(\"() True >>> correct_bracketing(\"() True >>> correct_bracketing(\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs كۆپ نومۇرنىڭ قوشۇمچە نىسبىتىنى كۆرسىتىدۇ. xs[0] + xs[1] * x + xs[2] * x^2 + .... بۇ كۆپ نومۇرنىڭ ئوخشاش شەكىلدىكى مشتۇرىسىنى قايتۇرۇپ بىرىڭ. >>> مشتۇرى (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> مشتۇرى ([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"FibFib سانلار تىزىملىكى بولسا Fibbonacci سانلار تىزىملىكىگە ئوخشاش تىزىملىك بولۇپ، تۆۋەندىكىدەك ئېنىقلىنىدۇ: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). fibfib سانلار تىزىملىكىنىڭ n-ئولقۇنىنى ئۈنۈملۈك ھېسابلايدىغان فۇنكسىيە يېزىڭ. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"بىر فونكىسىيە vowels_count نى يېزىڭ. بۇ فونكىسىيە بىر سۆزنى ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئىنگلىزچە ئى\"\"\"\n\ndef vowels_count(s):\n    \"\"\".يەنە بىرنەچچە سىناق مىسالنى قوشۇپ باقايلى\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"ئايلانما x نىڭ ھەربىر خانىسىنى يۆتكەپ، ھەربىر خانىنى يۆتكەپ ئوڭغا يۆتكەپ، نەتىجىنى تار شەكلىدە قايتۇرۇپ بىرىمىز. ئەگەر يۆتكەپ > ھەربىر خانىنى يۆتكەپ، نەتىجىنى ئەكسىچە قايتۇرۇپ بىرىمىز. >>> ئايلانما_يۆتكەپ ((12,1) \"21\" >>> ئايلانما_يۆتكەپ ((12,2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"ۋەزىپە بىر فۇنكسىيە يېزىڭ، ئۇنىڭدا بىر ھەرپ تىزمىسى كىرگۈزگۈچكە ئايلىنىپ، پەقەت يۇقىرىقى ھەرپلەرنىڭ يىغىندىسى ASCII كودى بولۇپ قايتۇرۇلىدۇ. مىسال: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"بۇ ۋەزىپىدە، سىز بىر تال سىتونغا ئېرىشەلەيسىز، بۇ سىتوندا ئالما، ئاپېلسىن ۋە مانگو بار. بۇ سىتوندا جەمئىي ئاپېلسىن ۋە ئاپېلسىن سانى ۋە سىتوندىكى جەمىئەت سانىنى ئىپادىلەيدىغان بىر پۈتۈن سانغا ئېرىشەلەيسىز. مەسىلەن: fruit_distribution\"5(ئالما ۋە 6 ئاپېلسىن\"، 19) ->19 - 5 - 6 = 8 fruit_distribution\"0ئالما ۋە 1 ئاپېلسىن\"،3) -> 3 - 0 - 1 = 2 fruit_distribution\"2ئالما ۋە 3 ئاپېلسىن\"،100) -> 100 - 2 - 3 = 95 fruit_distribution\"100ئالما ۋە 1 ئاپېلسىن\"20) -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"بىر تىزىملىكنىڭ بىر تارمىقىدا سەلبىي ئەمەس پۈتۈن سانلىق چەمبەرلەر بار، سىز بىر چەمبەرنى تاللاپ، ئۇنى قايتۇرۇپ بېرىسىز. تاللانغان چەمبەر ئەڭ كىچىك جۈپ قىممىتى بار چەمبەر بولۇشى كېرەك. ئەگەر ئوخشاش كىچىك جۈپ قىممىتى بار كۆپ چەمبەر تېپىلسا، ئەڭ كىچىك كۆرسەتكۈچ بار چەمبەرنى قايتۇرۇپ بېرىسىز. تاللانغان چەمبەر تىزىملىكتە قايتۇرۇپ بېرىلىشى كېرەك، [smallest_value، ئۇنىڭ كۆرسەتكۈچى]، ئەگەر جۈپ قىممەتلەر بولمىسا ياكى بېرىلگەن تىزىملىك بوش بولسا، قايتۇرۇپ بېرىسىز. []. مىسال1: كىرگۈزۈش: [4,2,3] چىقىرىش: [2, 1] ئىزاھات: 2 نىڭ ئەڭ كىچىك جۈپ قىممىتى بار، 2 نىڭ ئەڭ كىچىك كۆرسەتكۈچى بار. مىسال2: كىرگۈزۈش: [1,2,3] چىقىرىش: [2, 1] ئىزاھات: 2 نىڭ ئەڭ كىچىك قىممىتى بار، 2 نىڭ ئەڭ كىچىك كۆرسەتكۈچى بار. مىسال3: كىرگۈزۈش: [] چىقىرىش: [] كىرگۈزۈش: [4: [5, 3, 4, 2] كىرگۈزۈش: [0, 0] چىقىرىش: ئەڭ كىچىك چەمبەر: ئەڭ كىچىك كۆرسەتكۈچ بار، ئەمما ئەڭ كىچىك كۆرسەتكۈچ بار.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''سىز بىر پۈتۈن سانلارنىڭ قۇرۇق ئەمەس تىزىملىكىگە ئىگە. ئەڭ چوڭ پۈتۈن ساننى قايتۇرۇڭ. بۇ پۈتۈن ساننىڭ قىممىتىدىن چوڭ ياكى باراۋەر. بىر پۈتۈن ساننىڭ قېتىم سانى تىزىملىكتە پەيدا بولغان قېتىم سانى. ئەگەر بۇنداق قىممەت مەۋجۇت بولمىسا، -1 نى قايتۇرۇڭ. مىسال: ئىزدەش: (([4, 1, 2, 2, 3, 1]) == 2 ئىزدەش: (([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3 ئىزدەش: (([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''پۈتۈن سانلار تىزىملىكى بېرىلگەن بولسا، تىزىملىكنى غەلىتە تەرتىپ بويىچە قايتۇرۇپ بېرىدۇ. غەلىتە رەتلەش، ئەڭ تۆۋەن قىممەتتىن باشلاپ، ئاندىن قالغان پۈتۈن سانلارنىڭ ئەڭ يۇقىرى قىممىتىدىن باشلاپ، ئاندىن ئەڭ تۆۋەن قىممەتتىن باشلاپ، شۇنداقلا يەنە داۋاملىشىدۇ. مىساللار: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''ئۈچ بۇلۇڭنىڭ ئۈچ تەرىپىنىڭ ئۇزۇنلۇقىغا قاراپ. ئەگەر ئۈچ بۇلۇڭ توغرا ئۈچ بۇلۇڭنى شەكىللەندۈرسە، ئۈچ بۇلۇڭنىڭ يۈزىنى 2 ئونلۇق نۇقتىغا ئايلاندۇرۇپ قايتۇرۇپ بىرىمىز. بولمىسا -1 نى قايتۇرۇپ بىرىمىز. ئەگەر ئىككى بۇلۇڭنىڭ سوممىسى ئۈچىنچى بۇلۇڭدىن چوڭ بولسا، ئۈچ بۇلۇڭ توغرا ئۈچ بۇلۇڭنى شەكىللەندۈرىدۇ. مەسىلەن: ئۈچ بۇلۇڭ_ياشاسىسى ({3,4,5) == 6.00 ئۈچ بۇلۇڭ_ياشاسىسى ({1,2,10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''ئەگەر q جىسىم ئۇچسا True، ئەگەر ئۇچمىسا False دەپ قايتۇرغان فۇنكسىيەنى يازىمىز. ئەگەر q جىسىم تەڭپۇڭ بولسا (بۇ بىر پاليندروم تىزىملىكى) ۋە ئۇنىڭ ئېلېمېنتلىرىنىڭ سوممىسى ئەڭ چوڭ ئىمكانىيەتلىك ئېغىرلىق w دىن كىچىك ياكى باراۋەر بولسا True دەپ قايتۇرۇلىدۇ. مەسىلەن: will_it_fly (([1, 2], 5) â -> False # 1+2 ئەڭ چوڭ ئىمكانىيەتلىك ئېغىرلىقتىن كىچىك، ئەمما تەڭپۇڭ ئەمەس. will_it_fly (([3, 2, 3], 1) â -> False # تەڭپۇڭ، ئەمما 3+2+3 ئەڭ چوڭ ئىمكانىيەتلىك ئېغىرلىقتىن چوڭ. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 ئەڭ چوڭ ئىمكانىيەتلىك ئېغىرلىقتىن كىچىك، شۇڭا تەڭپۇڭ. will_it_fly ((([3], â 5) -> True # 3 ئەڭ چوڭ ئىمكانىيەتلىك ئېغىرلىقتىن كىچىك، شۇڭا تەڭپۇڭ.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"بىر جۈملىدە پۈتۈن سانلارنى كۆرسەك، جۈملىنىڭ پاليندروم بولۇشى ئۈچۈن ئۆزگەرتىشكە تېگىشلىك ئەڭ ئاز ساندىكى ئېلېمېنتلارنى تېپىپ چىقىمىز. پاليندروم جۈملىسى بولسا، ئارقا-ئارقىدىن ئوخشاشلا ئوقۇلىدىغان جۈملىدۇر. بىر قېتىم ئۆزگەرتىش جەريانىدا، سىز بىر ئېلېمېنتنى باشقا ئېلېمېنتقا ئۆزگەرتەلەيسىز. مەسىلەن: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''ئىككى تال تىزىملىكنى قوبۇل قىلىپ، تىزىملىكنىڭ ھەر بىر تارىدىكى ھەرپ سانى باشقا تىزىملىكتىن ئاز بولغان تىزىملىكنى قايتۇرۇپ بېرىدىغان فۇنكسىيە يېزىڭ. ئەگەر ئىككى تىزىملىكنىڭ ھەرپ سانى ئوخشاش بولسا، بىرىنچى تىزىملىكنى قايتۇرۇڭ. total_match (([]، []) -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , ['5']) -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"ئەگەر بېرىلگەن سان 3 نۇپۇسنىڭ ھەسسىلەپ بىرىكىشى بولسا true، ئەگەر بولمىسا false دەپ قايتۇرغان فۇنكسىيەنى يازىمىز. (a) نىڭ 100 دىن كىچىك ئىكەنلىكىنى بىلىش. مەسىلەن: is_multiply_prime ((30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"سىزنىڭ ۋەزىپىڭىز: ئەگەر بىر سان x بولسا n نىڭ بىر دەرىجىسى بولسا true نى قايتۇرۇپ بېرىدىغان، باشقا ئەھۋاللاردا false نى قايتۇرۇپ بېرىدىغان بىر فۇنكسىيە يېزىش. x بولسا n نىڭ بىر دەرىجىسى بولسا n**int=x مەسىلەن: is_simple_power ({1, 4) => true is_simple_power ({2, 2) => true is_simple_power ({8, 2) => true is_simple_power ({3, 2) => false is_simple_power ({3, 1) => false is_simple_power ({5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''بىر پۈتۈن ساننى قوبۇل قىلىپ True نى قايتۇرغان فۇنكسىيەنى يازىمىز. ئەگەر بۇ بىر پۈتۈن ساننىڭ كۇبىسى بولسا. دىققەت: كىرگۈزگەن ئۇچۇرنى ھەر ۋاقىت كۈچكە ئىگە دەپ قارىساق بولىدۇ. مەسىلەن: iscube ({1) ==> True ({2) ==> False ({-1)) ==> True ({64) ==> True ({0) ==> True ({180) ==> False ({1}) '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"سىز بىر فۇنكسىيە يېزىشنى تاپشۇرۇۋالدىڭىز، ئۇ بىر ئون ئالتىنجى ساننى بىر تارماق قىلىپ قوبۇل قىلىدۇ ۋە ئون ئالتىنجى ساننىڭ نۇمۇرىنىڭ نۇمۇرىنى سانايدۇ (نۇمۇرى 1 دىن چوڭ بولغان بىر خىل تەبىئىي سان بولۇپ، ئۇ ئىككى كىچىك تەبىئىي ساننىڭ مەھسۇلاتى ئەمەس). ئون ئالتىنجى ساننىڭ نۇمۇرى 0،1،2،3،4،5،6،7،8،9، A،B،C،D،E،F. نۇمۇرىنىڭ نۇمۇرى 2،3،5،7،11،13،17،... .شۇڭا سىز تۆۋەندىكى نۇمۇرىنىڭ بىر قىسمىنى بېكىتىشىڭىز كېرەك: 2،3،5،7،B (= ئون ئالتىنجى سان 11),D (= ئون ئالتىنجى سان 13) دىققەت: سىز كىرگۈزگەن ساننى دائىم توغرا ياكى بوش دەپ قاراشقا بولىدۇ، A،B،C،D،E،F دېگەن سىمۋوللار ھەمىشە چوڭ ھەرپ بىلەن يېزىلىدۇ. مىسال: num = \"AB\" ئۈچۈن، چىقىش نۇمۇرى 1 بولۇشى كېرەك. num = 1077E ئۈچۈن چىقىش نۇمۇرى 2 بولۇشى كېرەك. num = \"AB\" ئۈچۈن num = \"AB\" نۇمۇرى 1 بولۇشى كېرەك.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"سىز بىر ساننى ئونلۇق شەكىلدە بىرىلگەن ۋە سىزنىڭ ۋەزىپىڭىز ئۇنى ئىككىلىك شەكىلگە ئايلاندۇرۇش. فۇنكسىيە بىر ھەرپ بىلەن ئىككىلىك ساننى ئىپادىلەيدىغان بىر تار قايتۇرۇشى كېرەك. ھەر بىر ھەرپنىڭ سىمدىكى ھەر بىر ھەرپى 0 ياكى 1 بولىدۇ. سىمنىڭ بېشىدا ۋە ئاخىرىدا بىر قانچە ھەرپ \"db\" بولىدۇ. ئارتۇق ھەرپلەر شەكلىگە ياردەم بېرىش ئۈچۈن بار. مىسال: decimal_to_binary (\\15) # \"db1111db\" نى قايتۇرىدۇ decimal_to_binary (\\22) # \"db100000db\" نى قايتۇرىدۇ\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"سىز بىر ھەرپ تارىنى s دەپ ئاتىۋالىسىز. سىزنىڭ ۋەزىپىڭىز ئۇنىڭ خۇشال ياكى ئەمەسلىكىنى تەكشۈرۈش. ھەرپ تارىنىڭ ئۇزۇنلۇقى ئاز دېگەندە 3 دانە بولسا ۋە ئارقا-ئارقىدىن ھەر 3 ھەرپ ئوخشىمىسا، ئۇ خۇشال بولىدۇ. مەسىلەن: is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"بۇ مەۋسۈمنىڭ ئاخىرقى ھەپتىسى بولۇپ، ئوقۇتقۇچى ئوقۇغۇچىلارغا نومۇر بېرىشكە توغرا كېلىدۇ. ئوقۇتقۇچى ئۆزىنىڭ نومۇر بېرىش ئالگورىتمىسىنى ياساپ چىقتى. پەقەت بىر مەسىلە بار، ئۇ نومۇر بېرىش ئۈچۈن ئىشلەتكەن كودنى يوقىتىپ قويغان. ئۇ سىزگە بەزى ئوقۇغۇچىلارنىڭ نومۇر سانى تىزىملىكىنى بەردى، سىز تۆۋەندىكى جەدۋەلنى ئىشلىتىپ، خەت نومۇر تىزىملىكىنى چىقىرىدىغان فۇنكسىيە يېزىشىڭىز كېرەك: GPA  خەت نومۇرى 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"بىر سىتوننى ئېلىپ، سىتوننىڭ ئۇزۇنلۇقى نۇپۇزلۇق سان بولسا True ياكى False دەپ قايتۇرغان فۇنكسىيەنى يازىمىز. مەسىلەن prime_length (ئەسلى سان) == True prime_length (ئەسلى سان) == True prime_length (ئەسلى سان) == True prime_length (ئەسلى سان) == True prime_length (ئەسلى سان) == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"بىر قېتىملىق ئىجابىي پۈتۈن سان nنى بېكىتىمىز، ئاندىن 1 دىن باشلانغان ياكى 1 بىلەن ئاخىرلاشقان ن-نۇمۇرلۇق ئىجابىي پۈتۈن سانلارنى بېكىتىمىز.\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"بىر قوش نۇمۇرى N بولسا، ئۇنىڭ قوش نۇمۇرىدىكى ھەربىر خانىنىڭ ئومۇمىي سوممىسى قايتۇرۇلىدۇ. مىسال: N = 1000 بولسا، ھەربىر خانىنىڭ سوممىسى 1 بولسا، چىقىش نۇمۇرى \"1\" بولىدۇ. N = 150 بولسا، ھەربىر خانىنىڭ سوممىسى 6 بولسا، چىقىش نۇمۇرى \"110\" بولىدۇ. N = 147 بولسا، ھەربىر خانىنىڭ سوممىسى 12 بولسا، چىقىش نۇمۇرى \"1100\" بولىدۇ. ئۆزگىرىشچانلار: @N پۈتۈن سان چەكلىمىسى: 0 â‰¤ N â‰¤ 10000. چىقىش نۇمۇرى: قوش نۇمۇرلار تىزمىسى \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"بىر پۈتۈن ساننىڭ قۇرۇق بولمىغان تىزىملىكىدە، ئالدى بىلەن بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننىڭ بىر پۈتۈن سانىنى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشب قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشۇپ قوشب قوشب قوشۇپ قوشۇپ قوشب قوشۇپ قوشب قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش قوش\"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"بىر ھەرپ تىزگىنى ئېلىپ ئۇنىڭ تەرتىپلىك نۇسخىسىنى قايتۇرۇپ بېرىدىغان فۇنكسىيە يېزىڭ. تەرتىپلىك ھەرپ تىزگىنى بولسا، ھەر بىر سۆز (ئورۇن بىلەن ئايرىلىپ) نىڭ ئورنىغا يېڭى سۆز (ئورۇن بىلەن ئايرىلىپ) نىڭ ئورنىنى ئالىدۇ. ھەر بىر ھەرپنىڭ تەرتىپى ۋە بوشلۇقنىڭ تەرتىپى ھەرپنىڭ ASCII قىممىتىگە ئاساسەن ئۆرلەپ ئورۇنلاشتۇرۇلىدۇ. ئەسكەرتىش: سىز سۆز ۋە بوشلۇقلارنىڭ تەرتىپىنى جۈملىدە ساقلىشىڭىز كېرەك. مەسىلەن: anti_shuffle (ئەسسالامۇ ئەلەيكۇم) 'Hi' anti_shuffle (ئەسسالامۇ ئەلەيكۇم) 'ehllo' anti_shuffle (ئەسسالامۇ ئەلەيكۇم!!!) 'Hello !!!Wdlor' 'Hello !!!Wdlor' 'Hello !!!Wdlor' 'Hello !!!Wdlor' 'Hello !!!Wdlor' 'Hello !!!Wdlor' 'Hello !!!Wdlor' 'Hello !!!Wdlor'\"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"سىز بىر 2 ئۆلچەملىك سانلىق مەلۇماتقا ئىگە، ئۇ بىر گۆشلىك تىزىملىك بولۇپ، ماتىرىكىغا ئوخشايدۇ، لېكىن ماتىرىكىدىن پەرقلىق ھالدا، ھەر بىر قۇردا ھەر خىل ساندىكى ئىستىرالار بولۇشى مۇمكىن. lst ۋە پۈتۈن سان x نى بەرگەندە، تىزىملىكتىن پۈتۈن سان x نى تېپىپ، ھەر بىر تىپنىڭ كودېنتىنى 0 دىن باشلايدىغان كودېنتنى (سۇرەت، ئىستىرالار) تېپىپ بېرىڭ. يەنە، تىزىملىكتىكى كودېنتنى ئىستىرالار بويىچە تۆۋەنلەش تەرتىپى بويىچە رەتلەڭ. مىسال: get_row[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0,0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(], 1) [] == [[،1، 2، 3، 2، 3، 2]]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"بىر قاتار سەلبىي بولمىغان پۈتۈن سانلارنى بېكىتىپ، رەتلەشنى ئاخىرلاشتۇرغاندىن كېيىن، بۇ تىزىملىكنىڭ نۇسخىسىنى قايتۇرۇپ، ئەگەر جۈملىسى ((ئالدىقى كۆرسەتكۈچ قىممىتى، ئاخىرقى كۆرسەتكۈچ قىممىتى) جۈپ بولسا، بۇ تىزىملىكنى ئۆرلەپ رەتلەيمىز. ئەگەر جۈملىسى ((ئالدىقى كۆرسەتكۈچ قىممىتى، ئاخىرقى كۆرسەتكۈچ قىممىتى) جۈپ بولسا، تۆۋەنلەپ رەتلەيمىز. دىققەت: * بۇ تىزىملىكنى ئۆزگەرتمەڭ. مىساللار: * sort_array[(]) => [] * sort_array([5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"بىر فۇنكسىيە encrypt قۇرۇپ، بىر سىترىنگنى ئارگومېنت قىلىپ ئېلىپ، ئالىپبىتى ئايلاندۇرۇلۇپ، بىر سىترىنگنى قايتۇرۇپ بېرىدۇ. ئالىپبىتى ھەرپلەر ئىككىگە كۆپەيتىلىپ ئىككى ئورۇنغا يۆتكىلىش ھالىتىدە ئايلاندۇرۇلىدۇ. مەسىلەن: encrypt (('hi') return 'lm' encrypt (('asdfghjkl') return 'ewhjklnop' encrypt (('gf') return 'kj' encrypt (('et') return 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"سىز بىر پۈتۈن سانلار تىزىملىكىگە ئىگە. next_smallest () فۇنكسىيەسىنى يېزىپ، تىزىملىكتىكى ئىككىنچى كىچىك ساننى قايتۇرۇپ بېرىدۇ. ئەگەر بۇنداق سان بولمىسا، None نى قايتۇرۇپ بېرىدۇ. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () []) == next_smallest () [1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"سىز بىر قاتار سۆزلەرنى تاپشۇرۇۋالىسىز، سىزنىڭ ۋەزىپىڭىز زېرىكىشلىك سۆزلەرنىڭ سانىنى سانىشتۇر. زېرىكىشلىك سۆز \"I\" سۆزىدىن باشلانغان جۈملىدۇر. جۈملىلەر '.', '?' ياكى '! ' بىلەن چەكلىنىدۇ. مەسىلەن: >>> is_bored ((\"ئەسسالامۇ ئەلەيكۇم دۇنيا\") 0 >>> is_bored ((\"ئاسمان كۆك. قۇياش پارلاپ تۇرىدۇ. مەن بۇ ھاۋارايىغا ئامراق\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''3نومۇرنى قوبۇل قىلىدىغان فۇنكسىيە تۈزۈڭ. ئەگەر بىر نۇمۇر باشقا ئىككى نۇمۇرنىڭ سوممىسىغا تەڭ بولسا true نى قايتۇرۇپ بېرىدۇ، بارلىق نۇمۇرلار پۈتۈن سان بولسا false نى قايتۇرۇپ بېرىدۇ. باشقا ئەھۋاللاردا false نى قايتۇرۇپ بېرىدۇ. مەسىلەن: any_int{5,2,7} -> True any_int{3,2,2} -> False any_int{3, -2,1} -> True any_int{3.6, -2.2,2} -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"ئۇچۇرنى قوبۇل قىلىپ، ئۇنىڭدا ھەرپلەرنىڭ چوڭ-كىچىكلىكىنى ئالماشتۇرۇپ، ئۇچۇردىكى ھەر بىر ۋوكالنى ئېنگىلىزچە ھەرپنىڭ ئالدىدىكى 2 ئورۇنغا چىققان ھەرپ بىلەن ئالماشتۇرۇپ، ئۇنى بىر خىل فۇنكسىيە قىلىپ يازىمىز. پەقەت ھەرپلەرنىلا قوبۇل قىلىمىز. مىسال: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"سىز بىر پۈتۈن سانلار تىزىملىكىگە ئىگە. سىز ئەڭ چوڭ نۇپۇزلۇق قىممەتنى تېپىپ ئۇنىڭ ھەربىر خانىسىنىڭ سانىنى قايتۇرۇڭ. مەسىلەن: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ، چىقىش قىممىتى 10 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] ، چىقىش قىممىتى 25 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ، چىقىش قىممىتى 13 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ، چىقىش قىممىتى 11 lst = [0,81,12,31,21] ، چىقىش قىممىتى 3 lst = [0,1,8,1,2,1,7] ، چىقىش قىممىتى 7 lst = [0,1,1,2,7,8,1,7]\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"سۆزلۈكنى بەرسەك، ئەگەر ھەممە كۇنۇپكا كىچىك ھەرپلەر ياكى ھەممە كۇنۇپكا چوڭ ھەرپلەر بولسا True نى قايتۇرۇپ بىرىمىز، بولمىسا False نى قايتۇرۇپ بىرىمىز. ئەگەر سۆزلۈك بوش بولسا، فۇنكسىيە False نى قايتۇرۇشى كېرەك. مەسىلەن: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) True نى قايتۇرۇشى كېرەك. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) False نى قايتۇرۇشى كېرەك. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) False نى قايتۇرۇشى كېرەك. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False نى قايتۇرۇشى كېرەك. check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"}) False نى قايتۇرۇشى كېرەك.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"بىر خىل فۇنكسىيەنى ئىجرا قىلىڭ، ئۇ بىر خىل سالاھىيەتكە ئىگە بولغان نۆلدىن كىچىك نۆلدىن چوڭ بولغان نۆلدىن چوڭ بولغان بىر توپ نۆلنى قايتۇرۇپ بېرىدۇ. مەسىلەن: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"ئىككى پۈتۈن ساننى ئېلىپ، بىرلىك خانىسىنىڭ ھاسىلاتىنى قايتۇرۇپ بېرىدىغان فۇنكسىيەنى تاماملاڭ. كىرگۈزگەن ساننى ھەر ۋاقىت كۈچكە ئىگە دەپ پەرەز قىلىڭ. مىسال: كۆپەيتىش ({148}، (412) 16 نى قايتۇرۇشى كېرەك كۆپەيتىش ({19}، 28) 72 نى قايتۇرۇشى كېرەك كۆپەيتىش ({2020}، 1851) 0 نى قايتۇرۇشى كېرەك كۆپەيتىش ({14}، (15) 20 نى قايتۇرۇشى كېرەك.\"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"بىر تارماق s بولسا، چوڭ ھەرپلەرنىڭ سانىنى جۈپ ئىندېكسلار بويىچە سانىۋېلىڭ. مەسىلەن: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 قايتۇرىدۇ.\"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''بىر خىل فۇنكسىيە قۇرۇپ، بىر ساننى ئىپادىلەيدىغان قىممەت (سىناق) نى ئېلىپ، ئۇنىڭغا ئەڭ يېقىن بولغان پۈتۈن ساننى قايتۇرۇپ بېرىدۇ. ئەگەر سان ئىككى سىنجىدىن تەڭ يىراق بولسا، ئۇنى نۆلدىن يىراقلاشتۇرۇپ يۇمۇرىمىز. مىساللار >>> ئەڭ يېقىن_سىنج (((\"10\") 10 >>> ئەڭ يېقىن_سىنج (((\"15.3\") 15 ئەسكەرتىش: نۆلدىن يىراقلاشتۇرۇش: ئەگەر بېرىلگەن سان ئىككى سىنجىدىن تەڭ يىراق بولسا، قايتۇرۇش كېرەك بولغان سان نۆلدىن ئەڭ يىراق بولغان ساننى كۆرسىتىدۇ. مەسىلەن، ئەڭ يېقىن_سىنجىدىن\" (((14.5\") 15 نى قايتۇرۇشى كېرەك، ئەڭ يېقىن_سىنجىدىن\" (((-14.5\") 15 نى قايتۇرۇشى كېرەك.'''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"بىر پۈتۈن سان n بولسا، سىز n دەرىجىلىك تاشلارنى توپلىۋېلىڭ. بىرىنچى دەرىجىدە n تاش بار. كېيىنكى دەرىجىدىكى تاشلارنىڭ سانى: - n بىر خىل سان بولسا، كېيىنكى بىر خىل سان. - n بىر خىل سان بولسا، كېيىنكى بىر خىل سان. i سانىدىكى ئېلېمېنتنىڭ دەرىجىدىكى تاشلارنىڭ سانىنى ئىپادىلەيدىغان تىزىملىكتىكى ھەر بىر دەرىجىدىكى تاشلارنىڭ سانىنى قايتۇرۇڭ (i+1). مىسال: >>> make_a_pile ((3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"سىز بىر قۇر سۆزلەرنى قوشۇمچە ياكى بوشلۇق بىلەن ئايرىپ قويىسىز. سىزنىڭ ۋەزىپىڭىز: سۆزلەرنى سۆزگە بۆلۈپ، سۆزلەرنىڭ بىر تىزىملىكىنى قايتۇرۇش. مەسىلەن: words_string ((\"ئەسسالامۇ ئەلەيكۇم، مېنىڭ ئىسمىم جون\") == [\"ئەسسالامۇ ئەلەيكۇم\"، \"مېنىڭ\"، \"ئىسمىم\"، \"ئۇ\"، \"جون\"] words_string ((\"بىر، ئىككى، ئۈچ، تۆت، بەش، ئالتە\") == [\"بىر\"، \"ئىككى\"، \"ئۈچ\"، \"تۆت\"، \"بەش\"، \"ئالتە\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"بۇ فۇنكسىيە ئىككى ئىجابىي سان x ۋە y نى قوبۇل قىلىدۇ ۋە ئەڭ چوڭ قوش پۈتۈن ساننى قايتۇرۇپ بېرىدۇ. ئەگەر بۇ سان بولمىسا، فۇنكسىيە -1 نى قايتۇرۇپ بېرىدۇ. مەسىلەن: select_num ({12}، {15) = 14 select_num ({13) ، {12) = -1 .\"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"سىز ئىككى خىل ئىجابىي پۈتۈن سان n ۋە m نى تاپشۇرۇۋالسىڭىز، سىزنىڭ ۋەزىپىڭىز n دىن m گىچە بولغان پۈتۈن سانلارنىڭ ئوتتۇرىسىنى ھېسابلاش بولىدۇ. جاۋابنى ئەڭ يېقىن پۈتۈن سانغا ئايلاندۇرۇپ، ئۇنى ئىككىلىك سانغا ئايلاندۇرۇڭ. ئەگەر n دىن چوڭ بولسا، -1 نى قايتۇرۇڭ. مەسىلەن: rounded_avg{1, 5} => \"0b11\" rounded_avg{7, 5} => -1 rounded_avg{10, 20} => \"0b1111\" rounded_avg{20, 33} => \"0b11010\"\"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"بىر تىزىملىك قوشۇمچە پۈتۈن سانلارنى كۆرسىتىپ، بىر تىزىملىكتىن بىرنى قايتۇرۇپ، ئۇنىڭدا ھەر قانداق بىر جۈپ سان يوق. ئەسكەرتىش: قايتۇرۇلغان تىزىملىك بارغانسېرى كۆپىيىش تەرتىپى بويىچە رەتلىنىشى كېرەك. مەسىلەن: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) []\"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"بىر قاتار پۈتۈن سانلارنى بېكىتىپ، 1 دىن 9 گىچە بولغان پۈتۈن سانلارنى رەتلەپ، نەتىجە تىزىملىكىنى ئەكسىچە قىلىپ، ھەر بىر خانىنى \"بىر\"، \"ئىككى\"، \"ئۈچ\"، \"تۆت\"، \"بەش\"، \"ئالتە\"، \"يەتتە\"، \"سەككىز\"، \"توققۇز\" دىن ئۆز نامى بىلەن ئالماشتۇرۇپ بېكىتىمىز. مەسىلەن: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> رەتلەش arr -> [1, 1, 2, 3, 4, 5, 8] -> ئەكسىچە رەتلەش arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"ئۆتۈش\"، \"ئۈچ\"، \"ئۈچ\"، \"ئىككى\"، \"ئىككى\"، \"بىر\"، \"بىر\"] ئەگەر تىزىملىك بوش بولسا، بىر رەت قايتۇرۇپ: arr = [] return [] ئەگەر تىزىملىكتە غەيرىي سان بولسا، ئۇنى سەل قارايمىز: arr = [1, -1 ] -> arr = 55 , -> arr -> [1, 1, 55] -> reverse arr = [51] return = ['1,'] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"f نىڭ فاكتورى n نى پارامېتىر قىلىپ، n چوڭلۇقتىكى تىزىملىك قايتۇرۇپ بىرىلىدۇ. بۇنىڭدا، ئەگەر i جۈپ بولسا، i نىڭ فاكتورى i نىڭ فاكتورى ياكى 1 دىن i گە باراۋەر بولغان سانلارنىڭ سوممىسى بولىدۇ. i نىڭ فاكتورى 1 دىن باشلىنىدۇ. i نىڭ فاكتورى 1 دىن i گە باراۋەر بولغان سانلارنىڭ ھەسسىلەش مىقدارىدۇر (1 * 2 * ... * i). مىسال: f ({}5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"بىر قوشۇمچە نۇمۇرى n بولسا، بىر قوشۇمچە نۇمۇرىنى قايتۇرۇپ بىرىمىز. بۇ قوشۇمچە نۇمۇرىنىڭ ئىچىدە {1, n} ، {1, n} قاتارلىق قوشۇمچە نۇمۇرى بار. مىسال1: كىرگۈزۈش: 3 چىقىش: (1, 2) چۈشەندۈرۈش: پۈتۈن نۇمۇرىنىڭ ئىچىدە 1، 2، 3 بار، بۇنىڭ ئىچىدە 1، 2، 3 بار، بۇنىڭ ئىچىدە 2 نۇمۇرى نۇمۇر بار. مىسال2: كىرگۈزۈش: 12 چىقىش: (4, 6) چۈشەندۈرۈش: پۈتۈن نۇمۇرىنىڭ ئىچىدە 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 بار، بۇنىڭ ئىچىدە 4 نۇمۇرى نۇمۇر، 6 نۇمۇرى نۇمۇر بار. ئەسكەرتىش: 1 <= n <= 10^3 2. قوشۇمچە نۇمۇرىنىڭ ئىچىدە ئايرىم-ئايرىم قوشۇمچە نۇمۇرى بار.\"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"count_nums () فۇنكسىيەسىنى يېزىڭ. بۇ فۇنكسىيە بىر پۈتۈن سانلار تىزمىسىدىن بىرنى ئېلىپ، سانلىق بەلگىسى 0 دىن يۇقىرى بولغان سانلىق بەلگىلەرنى قايتۇرۇپ بېرىدۇ. ئەگەر بىر سان سەلبىي بولسا، ئۇنىڭ بىرىنچى ئىمزالانغان خانىسىمۇ سەلبىي بولىدۇ. مەسىلەن: -123 نىڭ ئىمزالانغان خانىسى -1,2,3 بولىدۇ. >>> count_nums (([]) == 0 >>> count_nums ([-1, 11, -11]) == 1 >>> count_nums ([(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"بىزدە بىر جۈملىنىڭ N پۈتۈن ساندىن ئىبارەت 'arr' جۈملىسى بار arr[1], arr[2], ..., arr[N. جۈملىدىكى سانلار تاساددىپىي رەتلىنىدۇ. سىزنىڭ ۋەزىپىڭىز تۆۋەندىكى مەشغۇلاتنى قىلىش ئارقىلىق جۈملىنىڭ تۆۋەنلەپ كەتمەسلىكى ئۈچۈن رەتلەش مۇمكىنمۇ؟ بەلگىلەش: سىز بەلگىلەنگەن جۈملىدە خالىغانچە كۆپ قېتىم ئوڭغا يۆتكەش مەشغۇلاتىنى قىلالايسىز. بىر ئوڭغا يۆتكەش مەشغۇلاتى جۈملىدىكى بارلىق ئېلېمېنتلارنى ئوڭغا يۆتكەشنى كۆرسىتىدۇ. جۈملىنىڭ ئاخىرقى ئېلېمېنتى جۈملىنىڭ باشلىنىش ئورنىغا يۆتكىلىدۇ يەنى 0-نومۇر. ئەگەر يۇقارقى مەشغۇلاتنى قىلىش ئارقىلىق رەتلەنگەن جۈملىنى ئېلىش مۇمكىن بولسا True نى قايتۇرۇپ بېرىڭ، بولمىسا False نى قايتۇرۇپ بېرىڭ. بەلگىلەنگەن جۈملىدە بوش بولسا True نى قايتۇرۇپ بېرىڭ. بەلگىلەنگەن تىزىمدە ئۆزگىچە ئېلېمېنتلارنىڭ بولۇشىغا كاپالەتلىك قىلىنىدۇ. مەسىلەن: move_one_(ball_[4,3,5,5,2] True چۈشەندۈرۈش: بەلگىلەنگەن تىزىمدە بەلگىلەنگەن مەشغۇلاتنى قىلىش ئارقىلىق، جۈملىنىڭ ئوڭغا يۆتكەش مەشغۇلاتىنى قىلغىلى بولىدۇ.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"بۇ مەسىلىدە، سىز بىر فۇنكسىيەنى ئىجرا قىلىسىز، ئۇ ئىككى سان تىزىملىكىدىن ئېلىپ، ئۇلارنىڭ ئارىسىدىكى ئېلېمېنتلارنى ئالماشتۇرۇپ lst1 نى پەقەت جۈپ سانلار تىزىملىكى قىلىپ چىقىرىش مۇمكىنمۇ يوقلىغىنى بېكىتىدۇ. lst1 بىلەن lst2 ئارىسىدىكى ئالماشتۇرۇلغان ئېلېمېنتلارنىڭ سانىغا چەك قويۇلمايدۇ. lst1 ۋە lst2 ئارىسىدىكى ئېلېمېنتلارنى ئالماشتۇرۇپ lst1 نىڭ بارلىق ئېلېمېنتلىرىنى جۈپ قىلىپ چىقىرىش مۇمكىن بولسا، \"YES\" نى قايتۇرۇڭ. بولمىسا، \"NO\" نى قايتۇرۇڭ. مەسىلەن: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" كىرگۈزگۈچ تىزىملىكلەرنىڭ بوش ئەمەسلىكى تەخمىن قىلىنىدۇ.\"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"بىر تال ھەرپنى ۋەكىللىك قىلىدىغان بوشلۇق ئايرىم كىچىك ھەرپلەرنى بېكىتىپ، ئەڭ كۆپ تەكرارلانغان ھەرپنىڭ سۆزلۈكنى قايتۇرۇپ، ئۇنىڭغا مۇناسىۋەتلىك ساننى قوشۇپ يازىمىز. بىر قانچە ھەرپ ئوخشاش تەكرارلانغان بولسا، ئۇلارنىڭ ھەممىسىنى قايتۇرۇپ يازىمىز. مىسال: ھىستوگىرام (a b c) == {'a': 1, 'b': 1, 'c': 1} ھىستوگىرام (a b a') == {'a': 2, 'b': 2} ھىستوگىرام (a b c a b') == {'a': 2, 'b': 2} ھىستوگىرام (b b a') == {'b 4}: ھىستوگىرام (a b') == {'b 4}: ھىستوگىرام (a b') == {} {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"خىزمەت بىز ئىككى تار s ۋە c نى تاپشۇرۇۋالدۇق، سىز s نىڭ ھەر قانداق بىر ھەرپ بىلەن باراۋەر بولغان ھەرپلەرنى ئۆچۈرۈۋېتىشىڭىز كېرەك، ئاندىن نەتىجە تارىنىڭ پاليندروم ئىكەنلىكىنى تەكشۈرۈڭ. بىر تار ئارقىغا قاراپ ئوقۇغان بىلەن ئالدىغا قاراپ ئوقۇغان ئوخشاش بولسا، ئۇنى پاليندروم دەپ ئاتىلىدۇ. نەتىجە تارىنى ۋە True/False نى ئۆز ئىچىگە ئالغان بىر توپنى قايتۇرۇش كېرەك. مەسىلەن: s = \"abcde\", c = \"ae\" بولسا، نەتىجە ('bcd',False) بولۇشى كېرەك. s = \"abcdef\", c = \"b\" بولسا، نەتىجە ('acdef',False) بولۇشى كېرەك. s = \"abcdedcba\", c = \"ab\", نەتىجە ('cdedc',True) بولۇشى كېرەك.\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"ھەر بىر تار پەقەت خانلىق ساندىن تەركىب تاپقان بىر تىزىملىك بولسا، تىزىملىكنى قايتۇرۇپ بېرىڭ. چىقىشنىڭ ھەر بىر i ئېلمىنتى بولسا \" كىرگۈزگۈچنىڭ i تارىدىكى بىر قانچە بىرخىلسىز ئېلمىنتلارنىڭ سانى\" بولۇپ، بۇ يەردە i لارنىڭ ھەممىسى كىرگۈزگۈچنىڭ i- تارىدىكى بىر قانچە بىرخىلسىز سانلار بىلەن ئالماشتۇرۇلۇشى كېرەك. >>> odd_count['1234567']) [\" 4n str4ng 4 of the 4nput.\"] >>> odd_count['3',\"111111\"]) [\" 1n str1ng 1 of the 1nput. \"، \" 8n str8ng 8 of the 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"بىر قاتار پۈتۈن سانلارنى كۆرسەك، ھەر قانداق بوش بولمىغان سانلار تارماق تىزىملىكىنىڭ ئەڭ كىچىك سوممىسىنى تېپىپ چىقىمىز. مىسال minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"سىز بىر تال قۇدۇقنىڭ تۆت بۇلۇڭلۇق تورىنى تاپالايسىز. ھەر بىر قۇر بىر قۇدۇقنى كۆرسىتىدۇ، ھەر بىر قۇردىكى 1 بىر سۇ بىرلىكىنى كۆرسىتىدۇ. ھەر بىر قۇدۇقنىڭ سۇ چىقىرىش ئۈچۈن ئىشلىتىلىدىغان بىر قۇدىسى بار، ھەممە قۇدۇقنىڭ سۇ چىقىرىش مىقدارى ئوخشاش. سىزنىڭ ۋەزىپىڭىز قۇدۇقلارنى بوشىتىش ئۈچۈن قۇدۇقلارنى ئىشلىتىش. قۇدۇقلارنى چۈشۈرۈش ئۈچۈن قانچىلىك قېتىم چىقىش كېرەكلىكىنى چىقىش. مىسال 1: كىرگۈزۈش: تور: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] قۇدىسى: 1 چىقىش: 6 مىسال 2: كىرگۈزۈش: تور: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] قۇدىسى: 2 چىقىش: 5 مىسال 3: كىرگۈزۈش: [[0,0,0], [0,0,0]] قۇدىسى: 5 چىقىش: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"بۇ كاتادا سىز بىر قاتار سەلبىي بولمىغان پۈتۈن سانلارنى قوش نومۇرلۇق ئىپادىلەش شەكلىدىكى بىرلىك سانىغا ئاساسەن ئۆرلەپ رەتلەش كېرەك. ئوخشاش ساندىكى بىرلىك سانى ئۈچۈن، ئونلۇق قىممەتنى ئاساس قىلىپ رەتلەش كېرەك. بۇ مۇنداق ئىجرا قىلىنىدۇ: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"بىر سىتون s ۋە بىر تەبىئىي سان n بولسا، سىز بىر فۇنكسىيە ئىجرا قىلىش ۋەزىپىسىنى تاپشۇرۇۋالدىڭىز، ئۇ سىتون s دىن بارلىق سۆزلەرنىڭ تىزىملىكىنى قايتۇرۇپ بېرىدۇ، بۇ سۆزلەر سىتون s دا ئېنىق n قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە قوشۇمچە\"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"سىز بىر سۆزنى تاپتىڭىز. سىزنىڭ ۋەزىپىڭىز سۆزنىڭ ئوڭ تەرىپىدىكى ئىككى قوشۇمچە بىلەن ئوتتۇرىسىدىكى ئەڭ يېقىن بولغان تاۋۇشنى تېپىش (ئەسلىگە دىققەت قىلىش). باش ۋە ئاخىرقى تاۋۇشلار ھېسابلانمايدۇ. ئەگەر يۇقارقى شەرتكە ئۇيغۇن كېلىدىغان تاۋۇش تاپالمىسىڭىز قۇرۇق سىتوننى قايتۇرۇڭ. سىز بۇ سىتوندا پەقەت ئىنگلىزچە ھەرپ بار دەپ پەرەز قىلىشىڭىز مۇمكىن. مەسىلەن: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"UULL\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" ((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''سىز ئىككى تار تىزىملىك بېرىلىۋاتىدۇ، ھەر ئىككى تار پەقەت ئېچىلغان قوساق '(' ياكى قوساق ') ' دىنلا تەركىب تاپىدۇ. سىزنىڭ ۋەزىپىڭىز ئىككى تارنى بىر تەرتىپتە بىرلەشتۈرۈش مۇمكىنمۇ، نەتىجىدە تارنىڭ ياخشى بولىدىغانلىقىنى تەكشۈرۈش. بىر تار S بولسا، ئەگەر S دىكى بارلىق قوساقلار تەڭپۇڭ بولسا، ئاندىن ئاندىن ئۇنىڭ ياخشى ئىكەنلىكىنى ھېسابلىنىدۇ. مەسىلەن: تار '((()) ' ياخشى بولسا، تار '()) ' ئۇنداق ئەمەس. ئەگەر بىر ياخشى تارنى ياساش ئۇسۇلى بولسا، 'Yes' نى قايتۇرۇڭ، ئەگەر بولمىسا 'No' نى قايتۇرۇڭ. مىساللار: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"بىر تەرتىپ arr نىڭ پۈتۈن سانلار بىلەن بىر پۈتۈن سان k بولسا، تەرتىپتىكى ئەڭ كۆپ k سانلىق تىزىملىك بىلەن ئۇزۇنلۇقى k بولغان رەتلەنگەن تىزىملىكنى قايتۇرۇپ بىرىمىز. مىسال1: كىرگۈزۈش: arr = [-3, -4, 5], k = 3 چىقىش: [-4, -3, 5] مىسال2: كىرگۈزۈش: arr = [4, -4, 4], k = 2 چىقىش: [4, 4] مىسال3: كىرگۈزۈش: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 چىقىش: [2] ئەسكەرتىش: 1. تەرتىپنىڭ ئۇزۇنلۇقى [1, 1000] دائىرىسىدە بولىدۇ. 2. تەرتىپتىكى ئېلمىنتلار [-1000, 1000] دائىرىسىدە بولىدۇ. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"بىر پۈتۈن ساننىڭ قۇرۇق بولمىغان تىزىملىكىگە ئاساسەن، تەڭ ئورۇنغا چىققان پۈتۈن بىر قىسىم ئېلمىنتلارنىڭ سوممىسىنى قايتۇرۇپ بىرىمىز. مىساللار ھەل قىلىش ([5, 8, 7, 1]) ==> 12 ھەل قىلىش ([3, 3, 3, 3, 3]) ==> 9 ھەل قىلىش ([30, 13, 24, 321]) ==>0\"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"بىر پۈتۈن سان ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار ئار\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"بىر قېتىملىق بىر پۈتۈن ساننى بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىمدا بىر قېتىم\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"سىز بىر فۇنكسىيە يېزىپ بېرىشىڭىز كېرەك، ئۇ مەلۇم بىر كۈن سىترىنگنى تەستىقلايدۇ ۋە ئەگەر كۈن توغرا بولسا True نى قايتۇرۇپ بېرىدۇ، ئەگەر توغرا بولمىسا False نى قايتۇرۇپ بېرىدۇ. تۆۋەندىكى قائىدىلەرنىڭ ھەممىسى ئىجرا قىلىنسا، كۈن توغرا بولىدۇ: 1.تۈن سىترىنگى بوش ئەمەس. 2.كۈن سانى 1- ئايدا 1 دىن تۆۋەن ئەمەس ياكى 31 كۈندىن يۇقىرى ئەمەس. 4.6,9,11 ئايدا 1 دىن تۆۋەن ئەمەس ياكى 30 كۈندىن يۇقىرى ئەمەس. ئايدا 1 دىن تۆۋەن ئەمەس ياكى 29 كۈندىن يۇقىرى ئەمەس. 2.ئايدا 1 دىن تۆۋەن ئەمەس ياكى 12 دىن يۇقىرى ئەمەس. 4.تۈن شەكلى: mm-dd-yyyy-yy. مەسىلەن: valid_date (('03-11-2000') => valid_date ((15-01-2012') => valid_date (('04-01-2040') => valid_date (((06-04-2020') => valid_date ((06/04/2020') => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''سۆز تىزىملىكىگە قاراپ، بىر تىزىملىك سۆزنى ئايرىپ، بوشلۇققا بۆلۈپ قايتۇرۇپ بېرىڭ، ئەگەر تېكىستتە بوشلۇق بولمىسا، سىز '،'، '،'، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '، '،'''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''بىر تىزىملىك سانلارنى كۆرسەك، ئۇلارنىڭ رەت تەرتىپى ئۆرلەپ ياكى ئۆرلەپ كەتمەي، رەت تەرتىپى ئوخشاش ياكى رەت تەرتىپى ئوخشاش دەپ قايتۇرۇپ بېرىمىز. ئەگەر تىزىملىكتە ئوخشاش ساننىڭ بىردىن ئارتۇق كۆپەيتىلگەن نۇسخىسى بولسا، False نى قايتۇرۇپ بېرىمىز. سەلبىي سانلارنى ئەمەس، پەقەت پۈتۈن سانلارنى قوبۇل قىلىمىز. مىساللار is_sorted (يەنى رەتلەنگەن) ([1]) -> True is_sorted ([1, 2, 3, 4, 5, 5]) -> True is_sorted ([1, 2, 3, 4, 5, 6]) -> True is_sorted ([1, 2, 3, 4, 5, 6, 7]) -> True is_sorted ([1, 3, 2, 4, 5, 6, 7]) -> False is_sorted ([1, 3, 2, 4, 5, 6, 7]) -> False is_sorted ([1, 2, 2, 3, 3, 4]) -> True is_sorted ([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"سىز ئىككى ئارىلىقنى ئالسىڭىز، ھەر بىر ئارىلىق بىر جۈپ پۈتۈن سان بولىدۇ. مەسىلەن، ئارىلىق = (باشلىنىش، ئاخىرلاش) = (1, 2). بېرىلگەن ئارىلىقلار يېپىق بولىدۇ، يەنى ئارىلىق (باشلىنىش، ئاخىرلاش) نىڭ باشلىنىش ۋە ئاخىرلاش ئىككىسىنى ئۆز ئىچىگە ئالىدۇ. ھەر بىر ئارىلىق ئۈچۈن، ئۇنىڭ باشلىنىشنىڭ ئاخىرلىشىشىغا تەڭ ياكى ئاز ئىكەنلىكىنى پەرەز قىلىمىز. سىزنىڭ ۋەزىپىڭىز بۇ ئىككى ئارىلىقنىڭ كېسىش ئۇزۇنلۇقىنىڭ نۇپۇزلۇق سانغا توغرا كېلىدىغان ياكى توغرا كەلمەيدىغانلىقىنى بېكىتىش. مەسىلەن، ئارىلىقلارنىڭ كېسىش ئۇزۇنلۇقى (1, 3), (2, 4) نىڭ كېسىش ئۇزۇنلۇقى (2, 3) نىڭ نۇپۇزلۇق سانغا توغرا كەلمەيدىغانلىقىنى بېكىتىش. ئەگەر كېسىش ئۇزۇنلۇقى نۇپۇزلۇق سانغا توغرا كەلسە، \"YES\" نى قايتۇرۇڭ، بولمىسا \"NO\" نى قايتۇرۇڭ. ئەگەر ئىككى ئارىلىق كېسىش بولمىسا، \"NO\" نى قايتۇرۇڭ. [input/output] ئۈلگە: كېسىش\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"سىز بىر قاتار پۈتۈن سانلارنى تاپشۇرۇۋالسىڭىز، سىز بۇ سانلارنىڭ چوڭ-كىچىكلىكىنىڭ جۈملىسىنى ھەر بىر ساننىڭ 1، -1 ياكى 0 بىلەن ئىپادىلەنگەن ھەر بىر ساننىڭ ھەر بىر بەلگىسىنىڭ مەھسۇلاتىغا كۆپەيتىپ قايتۇرسىڭىز بولىدۇ. دىققەت: بوش ئار ئار ئار ئۈچۈن ھېچنىمىنى قايتۇرماڭ. مىسال: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) ==  ھېچنىمىنى قايتۇرماڭ\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"بىر توردا N قۇر ۋە N قۇر (N >= 2) ۋە بىر قوش تولا سان k بولسا، تورنىڭ ھەر بىر ھۈجەيرىسىدە بىر قىممەت بار. [1, N * N] دائىرىسىدىكى ھەر بىر تولا سان تورنىڭ ھۈجەيرىلىرىدە دەل بىر قېتىم كۆرۈنىدۇ. سىز توردىكى ئۇزۇنلۇقى k بولغان ئەڭ كىچىك يولنى تېپىپ چىقىشىڭىز كېرەك. سىز ھەرقانداق بىر ھۈجەيرىدىن باشلىيالايسىز، ھەر بىر قەدەمدە سىز نۆۋەتتىكى ھۈجەيرىڭىز بىلەن بىر چېكىنى ئورتاقلايدىغان قوشنا ھۈجەيرىلەرگە يۆتكىلىشىڭىز مۇمكىن. دىققەت قىلىڭكى، ئۇزۇنلۇقى k بولغان يول دەل k ھۈجەيرىنى زىيارەت قىلىشنى (ئەسلىدە ئوخشىمايدۇ) كۆرسىتىدۇ. سىز توردىن چىقالمايسىز. A (k ئۇزۇنلۇقىدىكى) يول B (k ئۇزۇنلۇقىدىكى) يولدىن كىچىك دەپ قارىلىدۇ، ئەگەر A ۋە B (يەنى l_st ۋە l_stA دەپ ئاتايلى) ھۈجەيرىدىكى قىممەتلەرنىڭ رەتلەنگەن تىزىملىكىنى تۈزگەندىن كېيىن، l_stA ۋە l_stB (يەنى l_stA ۋە l_stA دەپ ئاتايلى) ، l_stA (ئەڭ كىچىك) لىكسىوگرافىكىلىق جەھەتتىن l_stA (j_stA) دىن كىچىك، يەنى، بىر پۈتۈن سانى k، يەنى بىر پۈتۈن سانى بىلەن بىر پۈتۈن ھۈجەيرىگە ئوخشاش بولغان ھۈجەيرىگە يۆجەيرىگە يۆتكىلىنى ئىزدەش ئارقىلىق يۆتكىلىش كېرەك. [j = 1، [j = j_j = j_j = 1، j = j = j_j = 1، j = j = [4, j = j = j = 1، j = j = j = j = 1، j = j = [، j = 1، j = [، j = 1، j = 1، j = [، j = 1] [، [] [] [، [] [] [] [، []، [j = j = 1، [=5,]، [=1، [=1، [=8، [=1، [=،]، [=، [=،]، [=، [=،]، [=، [=]، [=]، [=]، [=\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"فىبوناتچى تەرتىپى ھەممىگە تونۇشلۇق، بۇنى ماتېماتىكا ئالىملىرى يېقىنقى بىر قانچە ئەسىردە چوڭقۇر تەتقىق قىلغان. بىراق، كىشىلەر تىربوناچى تەرتىپىنى بىلمەيدۇ. تىربوناچى تەرتىپى تەكرارلىنىش ئارقىلىق بەلگىلەنگەن: tri(1) = 3 tri(n) = 1 + n / 2, ئەگەر n جۈپ بولسا. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ئەگەر n جۈپ بولسا. مەسىلەن: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 سىز بىر سەلبىي بولمىغان پۈتۈن سان n نى تاپشۇرۇۋالسىڭىز، سىز تىربوناچى تەرتىپىنىڭ بىرىنچى n + 1 سانلىرىنىڭ تىزىملىكىنى قايتۇرۇشىڭىز كېرەك. مىسال: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر پۈتۈن ساننى قوشۇپ، بىر تاللاش\"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''بىر فۇنكسىيە قۇرۇپ، ئۇنىڭ كىرگۈزگۈچ شەكلىدە پەقەت تۆت بۇلۇڭلۇق قۇرلار بار بولغان بىر تارنى قوبۇل قىلىدۇ. ئەگەر ۋە پەقەت بىر تال قۇرنىڭ ئىچىدە ئاز دېگەندە بىر قۇرنىڭ يۇشۇرۇنغانلىقى توغرا بولسا، فۇنكسىيە True نى قايتۇرۇشى كېرەك. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]') â -> False is_nested '[[][]]') â -> True is_nested'[[]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"سىز بىر تىزىملىك سانلارنى تاپشۇرۇۋالسىڭىز، سىز بۇ تىزىملىكتىكى ھەربىر ساننىڭ كۇۋادىراتىنى قايتۇرۇپ، تىزىملىكتىكى ھەربىر ئېلېمېنتنى ئەڭ يۇقىرىدىكى int{\\}}}ئۈستۈنلۈككە ئايلاندۇرسىڭىز بولىدۇ. مەسىلەن: lst = [1,2,3] نىڭ چىقىمى 14 lst = [1,4,9] نىڭ چىقىمى 98 lst = [1,3,5,7] نىڭ چىقىمى 84 lst = [1.4,4.2,0] نىڭ چىقىمى 29 lst = [-2.4,1,1] نىڭ چىقىمى 6 \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''بىر فۇنكسىيە قۇرۇپ، ئەگەر بىر ھەرپنىڭ ئاخىرقى ھەرپى بىر ھەرپ بولۇپ، سۆزنىڭ بىر قىسمى بولمىسا True نى قايتۇرۇپ، باشقا ئەھۋالدا False نى قايتۇرۇپ بېرىدۇ. ئەسكەرتىش: \"word\" بولسا بوشلۇق بىلەن ئايرىلىپ تۇرىدىغان ھەرپلەر گۇرۇپپىسى. مىساللار: check_if_last_char_is_a_letter (ئەسلى: \"ئالما تورت\") â -> False check_if_last_char_is_a_letter (ئەسلى: \"ئالما پىچەت\") â -> True check_if_last_char_is_a_letter (ئەسلى: \"ئالما پىچەت\") â -> False check_if_last_char_is_a_letter (ئەسلى: \"ئالما پىچەت\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"ئەگەر بۇ خىلدىكى ئېلېمېنت بولمىسا، -1 نى قايتۇرۇپ بىرىمىز. بۇ خىلدىكى ئېلېمېنتلار تىزىملىكىدە ئوخشاش بولمىغان قىممەتلەر بولمايدۇ. مەسىلەن: can_arrange ([1,2,4,3,5]) = 3 can_arrange ([1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''بىر خىل فۇنكسىيە قۇرۇپ، بىر خىل (a, b) لىك بىر لىكنى قايتۇرۇپ بېرىدۇ. بۇنىڭدا 'a' بىر خىل سلبىي پۈتۈن سانلارنىڭ ئەڭ چوڭى، 'b' بىر خىل ئىجابىي پۈتۈن سانلارنىڭ ئەڭ كىچىكسى بولىدۇ. ئەگەر سلبىي ياكى ئىجابىي پۈتۈن سانلار بولمىسا، ئۇلارنى None شەكلىدە قايتۇرۇپ بېرىدۇ. مىسال: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None)'''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"بىر فونكىسىيە قۇرۇپ، ئۇ پۈتۈن سانلارنى، كۆك سانلارنى ياكى ھەرپلەرنى ئىپادىلەيدۇ ۋە چوڭ ئۆزگەرگۈچىنى بەلگىلىگەن ئۆزگەرگۈچى تىپىدا قايتۇرۇپ بېرىدۇ. قىممەتلەر ئوخشاش بولسا، ھېچنىمىنى قايتۇرمايدۇ. ئەسكەرتىش: ئەگەر بىر ھەرپ بىر ھەرپ شەكلىدە ئىپادىلەنسە، ئۈزۈلۈپ تۇرىدىغان نۇقتا . ياكى ، compare_one{1,2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> ھېچنىمە \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"n نىڭ دەل 4 خىل قوش قوش قوش ساننىڭ قوشۇمچە سانى بولۇپ يازىلىدىغان-يىزىلمەيدىغانلىقىنى باھالاش. مىسال: is_equal_to_sum_even ({4) == يالغان is_equal_to_sum_even ({6) == يالغان is_equal_to_sum_even ({8) == توغرا \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"برازىلىيە فاكتورىيەسى مۇنداق ئېنىقلىنىدۇ: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! n > 0 مەسىلەن: >>> special_factorial ((4) 288 بۇ فۇنكسىيەگە بىر پۈتۈن سان كىرگۈزۈلىدۇ ۋە بۇ پۈتۈن ساننىڭ ئالاھىدە فاكتورىيەسىنى قايتۇرۇشى كېرەك. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_ مىسال-3كۆرگەندە، ئۇنىڭدىكى بوشلۇقلارنى ئاستى سىزىقلار بىلەن ئالماشتۇرۇڭ، ئەگەر بىر تارنىڭ ئارقا-ئارقىدىن 2 دىن ئارتۇق بوشلۇق بولسا، ئارقا-ئارقىدىن كەلگەن بوشلۇقلارنى - fix_spaces (_Example) == \"ئەسلى\" fix_spaces (_Example1\") == \"ئەسلى_1\" fix_spaces (_Example2\") == \"_Example_2\" fix_spaces (_Example3\") == \"_Example-3\"  بىلەن ئالماشتۇرۇڭ.\"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"ھۆججەت نامى تۆۋەندىكى شەرتلەرگە ئۇيغۇن بولسا، ھۆججەت نامى \"Yes\" نى قايتۇرۇپ بېرىدۇ. ھۆججەت نامىدا ئۈچتىن ئارتۇق خانقا ('0'-'9') بولمىسىلا، ھۆججەت نامى كۈچكە ئىگە بولىدۇ. ھۆججەت نامىدا دەل بىر دانە نۇقتا بولىدۇ. ھۆججەت نامىنىڭ ئالدىدىكى تارماق قۇرۇق بولماسلىقى كېرەك، ئۇ لاتىن ھەرپىدىن باشلىنىدۇ.\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"بۇ فۇنكسىيە پۈتۈن سانلار تىزىملىكىدىن بىرنى تاللايدۇ. ئەگەر فۇنكسىيەنىڭ كۆرسەتكۈچى 3 نىڭ كۆپلىكى بولسا، فۇنكسىيە پۈتۈن ساننى كۇبۇرۇت قىلىدۇ. ئەگەر كۆرسەتكۈچى 4 نىڭ كۆپلىكى بولسا، فۇنكسىيە ئۇنى كۇبۇرۇت قىلىدۇ. ئەگەر كۆرسەتكۈچى 3 ياكى 4 نىڭ كۆپلىكى بولمىسا، فۇنكسىيە فۇنكسىيەنىڭ كۆرسەتكۈچلىرىنى ئۆزگەرتەلمەيدۇ. فۇنكسىيە ئاندىن بارلىق سانلارنىڭ سوممىسىنى قايتۇرىدۇ. مىسال: lst = [1,2,3] ئۈچۈن چىقىش قىممىتى 6 lst = [] ئۈچۈن چىقىش قىممىتى 0 lst = [-1,-5,2,-1,-5] ئۈچۈن چىقىش قىممىتى -126 \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"سىز بىر جۈملىگە ۋەكىللىك قىلىدىغان بىر تار تار تارقىتىسىز، جۈملىدە بىر بوشلۇق بىلەن ئايرىلىپ بىر قىسىم سۆزلەر بار، سىز ئەسلى جۈملىدىكى سۆزلەرنى ئۆز ئىچىگە ئالغان بىر تار تار تارقىتىشنى قايتۇرۇشىڭىز كېرەك، ئۇنىڭ ئۇزۇنلۇقى نۇپۇزلۇق سانلار، يېڭى تارقىتىشتىكى سۆزلەرنىڭ تەرتىپى ئەسلىدىكى بىلەن ئوخشاش بولۇشى كېرەك. مىسال1: كىرگۈزۈش: جۈملىگە = \"بۇ بىر سىناق\" چىقىش: \"is\" مىسال2: كىرگۈزۈش: جۈملىگە = \"lets go for swimming\" چىقىش: \"go for\" چەكلىمىلەر: * 1 <= len(sentence) <= 100 * جۈملىگە پەقەت ھەرپلەرلا قوشۇلىدۇ \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"سىزنىڭ ۋەزىپىڭىز x * n ئىپادىسىنى ئاددىيلاشتۇرىدىغان فۇنكسىيەنى ئىجرا قىلىش. ئەگەر x * n پۈتۈن سانغا تەڭشەلسە ۋە باشقا ئەھۋالدا خاتا بولسا، فۇنكسىيە True نى قايتۇرۇپ بېرىدۇ. x ۋە n ئىككىلىسى بىر بۆلەكنىڭ سىتون ئىپادىسى بولۇپ، تۆۋەندىكى شەكىلگە ئىگە: < سانلىغۇچ>/< ئاتلىغۇچ>، بۇنىڭدا سانلىغۇچ ۋە ئاتلىغۇچ ئىككىلىسى قوش پۈتۈن سانلار. سىز x ۋە n نىڭ توغرا بۆلەك ئىكەنلىكىنى ھەمدە ئاتلىغۇچنىڭ نۆل ئىكەنلىكىنى پەرەز قىلالايسىز. ئاددىيلاشتۇر ({\"1/5\", \"5/1\") = True ({\"1/6\", \"2/1\") = False ({\"7/10\", \"10/2\") = False)\"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"بىر خىل فۇنكسىيە يېزىپ، بۇ فۇنكسىيە ئارقىلىق پۈتۈن سانلارنىڭ تىزىملىكىنى ئۇلارنىڭ ھەر بىر خانىسىنىڭ تەڭپۇڭلۇقى بويىچە ئۆرلەپ تىزىملىتىش. دىققەت: ئەگەر ئوخشاش بىر قانچە خانىلىق سان بار بولسا، ئەسلى تىزىملىكتىكى ئىندېكس بويىچە رەتلەش. مەسىلەن: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"بىر فۇنكسىيە يېزىپ بىرىڭ، بۇ فۇنكسىيە بىر قاتار سانلارنى كىرگۈزۈش شەكلىدە ئېلىپ، 10 دىن چوڭ بولغان ئارىئومېنت سانىنى قايتۇرۇپ بىرىدۇ. بۇنىڭدا بىر ساننىڭ بىرىنچى ۋە ئاخىرقى خانىسى جىپسىز بولىدۇ. مەسىلەن: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"سىز بىر قوش تولا ن سانغا ئىگە. سىز ئۇزۇنلۇقى n بولغان بىر پۈتۈن سانلار تىزىملىكى a نى ياساپ چىقىشىڭىز كېرەك. ھەر i (1 ‰¤ i ‰¤ n) نىڭ قىممىتى a[i] = i * i - i + 1. a نىڭ ئۈچ قېتىملىق (a[i], a[j], a[k]) سانىنى قايتۇرۇڭ. بۇنىڭدا i < j < k، a[i] + a[j] + a[k] نىڭ كۆپ قېتىملىق سانى 3. مىسال: كىرگۈزۈش: n = 5 چىقىش: 1 ئىزاھات: a = [1, 3, 7, 13, 21] بىردىنبىر توغرا ئۈچ قېتىملىق سان (1, 7, 13) \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''قۇياش سىستېمىسىدا سەككىز چوڭ پىلانىت بار: قۇياشقا ئەڭ يېقىن بولغان پىلانىت مېركۇرىي، كېيىنكىسى ۋېنۇس، ئاندىن يەر شارى، مارس، جۇبېيتىر، ساتۇرن، ئۇران، نېپۇتۇن. بىر فۇنكسىيە يېزىپ، ئىككى چوڭ پىلانىت نامىنى پىلانىت1 ۋە پىلانىت2 قاتارىغا كىرگۈزۈڭ. فۇنكسىيە قۇياشقا يېقىنلىقى بويىچە رەتلەنگەن، پىلانىت1 بىلەن پىلانىت2نىڭ ئوربىتى ئارىسىدىكى ئوربىتىدىكى پىلانىتلارنى ئۆز ئىچىگە ئالغان بىر تىپنى قايتۇرۇپ بېرىدۇ. ئەگەر پىلانىت1 ياكى پىلانىت2نىڭ نامى توغرا بولمىسا، فۇنكسىيە بوش تىپنى قايتۇرۇپ بېرىدۇ. مىساللار bf\"(جۇبېيىت\"، \"نەپۇتۇن\") ==> (\"شۇن\"، \"ئوران\") bf(\"يەر شارى\"، \"مېركۇرىي\") ==> (\"ۋېنۇس\") bf\"(مېركۇرىي\"، \"ئۇران\") ==> (\"ۋېنۇس\"، \"يەر شارى\"، \"جۇ، \"جۇبېيىت\"، \"جۇبېيىت\"، \"شەن\")'''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"بىر فۇنكسىيە يېزىڭ، ئۇ فۇنكسىيە بىر تىزىملىك تارلارنى پارامېتىر قىلىپ قوبۇل قىلىدۇ، ئۇ تىزىملىكتىن جىپ ئۇزۇنلۇقتىكى تارلارنى چىقىرىپ تاشلايدۇ، ھەمدە نەتىجىدە تىزىملىكنىڭ تەرتىپى رەتلەنگەن ھالدا قايتۇرۇلىدۇ. تىزىملىك دائىم بىر تىزىملىك تارلار بولۇپ، ھەرگىزمۇ بىر قاتار سانلار بولۇپ، ئۇ كۆپەيتىلگەنلەرنى ئۆز ئىچىگە ئالماسلىقى مۇمكىن. تىزىملىكنىڭ تەرتىپى ھەر بىر سۆزنىڭ ئۇزۇنلۇقى بويىچە ئۆرلەپ، سىز بۇ قائىدى بويىچە رەتلەنگەن تىزىملىكنى قايتۇرۇشىڭىز كېرەك. ئەگەر ئىككى سۆزنىڭ ئۇزۇنلۇقى ئوخشاش بولسا، تىزىملىكنى ئالىپبىتى بويىچە رەتلەڭ. فۇنكسىيە بىر تىزىملىك تارلارنى رەتلەنگەن تەرتىپتە قايتۇرۇشى كېرەك. سىز بارلىق سۆزلەرنىڭ ئۇزۇنلۇقى ئوخشاش بولىدۇ دەپ پەرەز قىلىشىڭىز مۇمكىن. مەسىلەن: assert list_sort[\"aa\"\"، \"a\", \"aaa\"]) => assert list_sort[\"ab\"\"، \"aaaa\"\"، \"cd\" => \"abd\")\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"ئاددىي پروگرامما بولسا x نىڭ قىممىتىنى قايتۇرۇپ بىرىدۇ ئەگەر n بىر ئاساسى سان بولسا ۋە y نىڭ قىممىتىنى قايتۇرۇپ بىرىدۇ. مەسىلەن: x_or_y{7, 34, 12) == 34 x_or_y{15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''بىر تىزىملىك سانلارنى بېكىتىپ، تىزىملىكتىكى بىر قانچە ساننىڭ كۇۋادىرات سوممىسىنى قايتۇرۇپ بىرىمىز. سەلبىي سانلارنى ياكى پۈتۈن سانلارنى كۆرمەيمىز. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 ئەگەر كىرگۈزگەن تىزىملىك بوش بولسا، 0 نى قايتۇرمىز. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"مەنچە ھەممىمىز ئۇزۇن كۈتكەن ھادىسەنىڭ نەتىجىسى ئاخىرقى قېتىم مەلۇم بولغاندىكى ھېسسىياتنى ئەسلەيمىز. شۇ ۋاقىتتا سىزدە بولغان ھېسسىيات ۋە ئوي-پىكىرلەرنى چوقۇم خاتىرىلەپ سېلىشتۇرۇشقا ئەرزىيدۇ. سىزنىڭ ۋەزىپىڭىز بىر ئادەمنىڭ بىر قانچە قېتىملىق مۇسابىقىنىڭ نەتىجىسىنى توغرا تاپقان-تۇتمىغانلىقىنى ئېنىقلاش. سىزگە ئوخشاش ئۇزۇنلۇقتىكى ئىككى گۇرۇپپا نەتىجە ۋە پەرەز بېرىلىدۇ، ھەر بىر كۆرسەتكۈچ بىر قېتىملىق مۇسابىقىنى كۆرسىتىدۇ. ئوخشاش ئۇزۇنلۇقتىكى بىر گۇرۇپپىنى قايتۇرۇپ بېرىپ، ھەر بىر پەرەزنىڭ قانچىلىك يىراقلىقتا ئىكەنلىكىنى كۆرسىتىدۇ. ئەگەر ئۇلار توغرا تاپقان بولسا، قىممىتى 0 بولىدۇ، بولمىسا، قىممىتى پەرەز بىلەن نەتىجىنىڭ ئوتتۇرىسىدىكى مۇتلەق پەرق بولىدۇ. مىسال: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,2,4]) -> [4,0,4,0,1,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"سىز بىر سىنىپنىڭ نامى (سىناق) ۋە بىر تىزىملىك كېڭەيتىشلەرنى تاپشۇرۇۋالىسىز. كېڭەيتىشلەر بۇ سىنىپقا قوشۇمچە سىنىپلارنى يۈكلەش ئۈچۈن ئىشلىتىلىدۇ. كېڭەيتىشنىڭ كۈچ-قۇدرىتى تۆۋەندىكىچە: CAP كېڭەيتىش نامىدىكى چوڭ ھەرپلەرنىڭ سانى بولسا، SM كېڭەيتىش نامىدىكى كىچىك ھەرپلەرنىڭ سانى بولسا، كۈچ-قۇدرىتى CAP-SM كسىمى ئارقىلىق بېرىلىدۇ. سىز ئەڭ كۈچلۈك كېڭەيتىشنى تېپىپ، تۆۋەندىكى شەكىلدىكى بىر تارنى قايتۇرسىڭىز بولىدۇ: ClassName.StrongestExtensionName. ئەگەر ئوخشاش كۈچ-قۇدرىتىگە ئىگە ئىككى ياكى ئۇنىڭدىن ئارتۇق كېڭەيتىش بولسا، تىزىملىكتىن بىرىنچى بولۇپ كەلگەننى تاللىشىڭىز كېرەك. مەسىلەن، ئەگەر سىزگە \"Slices\" سىنىپ ۋە كېڭەيتىشلەر تىزىملىكى بېرىلسە: ['SEviviRNGCliES'، 'Cheese'، 'StuFed'] ئۇنداقتا سىز 'Slices.SEviRNGCliES'، 'SEviRNGCliES' (mySviRNGCliES') نىڭ كۈچ-قۇدرىتى كۈچلۈك بولغاچقا، 'Slices'نى قايتۇرسىڭىز بولىدۇ. (مەسىلەن: 'AA_Class' = '_StrongestExtension_') ، '[' = 'AA'_Class_{Strongest_{'}'}' Strongest extension}' = Strongest'{Class} '_{Class}'}'}'{Strongest}}}، مەسىلەن: '_class'{AA'_ئەڭ كۈچلۈك'}\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"سىز ئىككى سۆزنى تاپشۇرۇۋالسىڭىز، ئەگەر ئىككىنچى سۆز ياكى ئۇنىڭ ھەرقايسى ئايلىنىشى بىرىنچى سۆزدىكى تار تار تار بولسا True نى قايتۇرسىڭىز بولىدۇ. cycpattern_check (ئەسلى: \"abcd\",\"abd\") => False cycpattern_check (ئەسلى: \"hello\",\"ell\") => True cycpattern_check (ئەسلى: \"whassup\",\"psus\") => False cycpattern_check (ئەسلى: \"abab\",\"baa\") => True cycpattern_check (ئەسلى: \"efef\",\"eeff\") => False cycpattern_check (ئەسلى: \"hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"بىر پۈتۈن سان بېرىلسە. بىر قوشۇمچە بولۇپ، ئۇ بىر جۈپ سان بىلەن بىر جۈپ ساننىڭ ئوخشاش سانىنى ئىپادىلەيدۇ. مىسال: جۈپ_قىزىق_ سان ((-12) ==> (1, 1) جۈپ_قىزىق_ سان ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"بىر قوشۇمچە پۈتۈن ساننى بىر تارماق قىلىپ، ئۇنىڭ رىم سانلىق قىممىتىگە تەڭ كېلىدىغان بىر تارماقنى تېپىپ، ئۇنى كىچىك ھەرپلەر بىلەن قايتۇرۇپ بېرىڭ. چەكلىمە: 1 <= num <= 1000 مىساللار: >>> int_to_mini_roman{19} == 'xix' >>> int_to_mini_roman{152} == 'clii' >>> int_to_mini_roman{426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''ئۈچ بۇلۇڭلۇق ئۈچ بۇلۇڭنىڭ ئۇزۇنلۇقىغا قاراپ. ئەگەر ئۈچ بۇلۇڭلۇق ئۈچ بۇلۇڭلۇق تۈز بۇلۇڭلۇق ئۈچ بۇلۇڭلۇق بولسا True نى قايتۇرۇپ بىرىمىز، بولمىسا False نى قايتۇرۇپ بىرىمىز. توغرا بۇلۇڭلۇق ئۈچ بۇلۇڭلۇق ئۈچ بۇلۇڭلۇق ئۈچ بۇلۇڭلۇقنىڭ بىرى 90 گىرادۇس توغرا بۇلۇڭلۇق ئۈچ بۇلۇڭلۇقتىن ئىبارەت. مىسال: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"بىر فۇنكسىيە يېزىپ، بىر تىزىملىك تارلارنى قوبۇل قىلىدۇ. تىزىملىكتە ئوخشىمىغان سۆزلەر بار. ئەڭ كۆپ خىل خەت سانى بار سۆزنى قايتۇرۇپ بېرىدۇ. ئەگەر بىر قانچە تاردا ئەڭ كۆپ خىل خەت سانى بار بولسا، لىكسىكوگرافىك تەرتىپ بويىچە بىرىنچى بولۇپ كەلگەن سۆزنى قايتۇرۇپ بېرىدۇ. find_max (([\"name\", \"of\", \"string\"]) == \"string\" find_max (([\"name\", \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"سىز بىر ئاچ خەنجىر، سىز بىر مۇنچە گۇرۇچ گۇرۇچ يېگەن، لېكىن ھازىر بىر كۈنلۈك تاماقنى تولۇقلاش ئۈچۈن يەنە گۇرۇچ يېيىش كېرەك. سىز بىر تىزىملىك قايتۇرۇش كېرەك [ تاماقتىن كېيىن يېگەن گۇرۇچنىڭ ئومۇمىي سانى، تاماقتىن كېيىن قالغان گۇرۇچنىڭ سانى ] ئەگەر يېتەرلىك گۇرۇچ قالمىسا، سىز قالغان گۇرۇچلارنى يەپلا قالىسىز، لېكىن يەنىلا ئاچ قالىسىز. مىسال: * يەپ ((5, 6, 10) -> [11, 4] * يەپ ((4, 8, 9) -> [12, 1] * يەپ ((1, 10, 10) -> [11, 0] * يەپ ((2, 11, 5) -> [7, 0] ئۆزگىرىشچانلار: @number: يېگەن گۇرۇچ سانىنى تولدۇرۇش. @need: يېيىش كېرەك بولغان گۇرۇچ سانىنى تولدۇرۇش. @remaining: ساقلانغان گۇرۇچ سانىنى تولدۇرۇش: * number = 0 <= 0 * 1000 <= 0 * number = 1000 <= 0 = 1000 <= 0 = 1000:\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"ئىككى تىزىملىكتە ئوپېراتور ۋە ئوپېرانت بار. بىرىنچى تىزىملىكتە ئاساسلىق ئالگېبرا مەشغۇلاتلىرى بار، ئىككىنچى تىزىملىكتە پۈتۈن سانلار بار. ئىككى تىزىملىكتىن پايدىلىنىپ، ئالگېبرا ئىپادىسىنى قۇرۇپ، بۇ ئىپادىنىڭ باھالاش قىممىتىنى قايتۇرۇپ بېرىڭ. ئاساسلىق ئالگېبرا مەشغۇلاتلىرى: قوشۇش (+) ئايرىش (- ) كۆپەيتىش (- *) يەر بۆلۈش (- /) دەرىجە بۆلۈش (- **) مىسال: ئوپېراتور['+'، '*', '-'] جەدۋىلى = [2, 3, 4, 5] نەتىجە = 2 + 3 * 4 - 5 => نەتىجە = 9 ئەسكەرتىش: ئوپېراتور تىزىملىكىنىڭ ئۇزۇنلۇقى ئوپېرانت تىزىملىكىنىڭ ئۇزۇنلۇقىغا تەڭ. ئوپېرانت بولسا سالمىقىسىز پۈتۈن سانلار تىزىملىكى. ئوپېراتور تىزىملىكىدە ئاز دېگەندە بىر ئوپېراتور بار، ئوپېراتور تىزىملىكىدە ئاز دېگەندە ئىككى ئوپېرانت بار.\"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"سىز بىر ھەرپ s نى تاپشۇرۇۋالسىڭىز، ئەگەر s[i] ھەرپ بولسا، ئۇنىڭ چوڭ-كىچىكلىكىنى تۆۋەندىن يۇقىرىغا ياكى ئەكسىچە ئۆرلىتىڭ، بولمىسا ئوخشاشلا قالدۇرۇڭ. ئەگەر ھەرپلەر بولمىسا، ھەرپلەرنى ئۆرلىتىڭ. فۇنكسىيە نەتىجە ھەرپنى قايتۇرۇشى كېرەك. مەسىلەن: solve{\"1234\") = \"4321\"{\"ab\") = \"AB\"{\"#a@C\") = \"#A@c\"\"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"بىر تار 'text' بولسا، ئۇنىڭ md5 خەش تەڭ تارىنى قايتۇر. ئەگەر 'text' بوش تار بولسا، None نى قايتۇر. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "uig_Arab",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"ئىككى خىل ئىجابىي پۈتۈن سان a ۋە b نى بېكىتىپ، a بىلەن b نىڭ ئارىسىدىكى جۈپ سانلارنى ئۆرلەپ قايتۇرىمىز. مەسىلەن: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]