task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,bos_Latn,go_test.go,"package has_close_elements_test

import (
    ""testing""
    ""fmt""
)

//            //Provjerite da li su u datoj listi brojeva, bilo koji dva broja bliža jedno drugome od // >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)
// false
// >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
// true
func has_close_elements(numbers []float64, threshold float64) bool {
","package has_close_elements_test

import (
	""math""
	""sort""
	""testing""
)

// Check if in given list of numbers, are any two numbers closer to each other than
// given threshold.
func has_close_elements(numbers []float64, threshold float64) bool {
	sort.Float64s(numbers)
	for i := 0; i < len(numbers)-1; i++ {
		if math.Abs(numbers[i+1]-numbers[i]) < threshold {
			return true
		}
	}
	return false
}

func TestHasCloseElements(t *testing.T) {
	testCases := []struct {
		numbers   []float64
		threshold float64
		expected  bool
	}{
		{[]float64{1.0, 2.0, 3.0}, 0.5, false},
		{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},
		{[]float64{1.5, 1.8, 2.2}, 0.3, true},
		{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},
	}

	for i, tc := range testCases {
		t.Run(fmt.Sprintf(""TestCase%d"", i+1), func(t *testing.T) {
			result := has_close_elements(tc.numbers, tc.threshold)
			if result != tc.expected {
				t.Errorf(""expected %v, got %v"", tc.expected, result)
			}
		})
	}
}","func TestHas_Close_Elements(t *testing.T) {
  candidate := has_close_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_1,bos_Latn,go_test.go,"package separate_paren_groups_test

import (
    ""testing""
    ""fmt""
)

//Ignoriraj sve praznine u ulaznom nizu.//Odvojene grupe su uravnotežene (svaka otvorena brace je pravilno zatvorena) i nisu ugnezdene jedna u drugu.//Odvojite te grupe u zasebne nizove i vratite listu tih.//Uvod u ovu funkciju je niz koji sadrži više grupa ugnežđenih zagrada.// >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// []string{""()"", ""(())"", ""(()())""}
func separate_paren_groups(paren_string string) []string {
","package separate_paren_groups

func separate_paren_groups(paren_string string) []string {
	var result []string
	var currentGroup []rune
	openCount := 0

	for _, char := range paren_string {
		if char == '(' {
			openCount++
			currentGroup = append(currentGroup, char)
		} else if char == ')' {
			openCount--
			currentGroup = append(currentGroup, char)

			if openCount == 0 {
				result = append(result, string(currentGroup))
				currentGroup = nil
			}
		}
	}

	return result
}","func TestSeparate_Paren_Groups(t *testing.T) {
  candidate := separate_paren_groups
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""(()()) ((())) () ((())()())""), expected: []string{""(()())"", ""((()))"", ""()"", ""((())()())""} },
     { actual: candidate(""() (()) ((())) (((())))""), expected: []string{""()"", ""(())"", ""((()))"", ""(((())))""} },
     { actual: candidate(""(()(())((())))""), expected: []string{""(()(())((())))""} },
     { actual: candidate(""( ) (( )) (( )( ))""), expected: []string{""()"", ""(())"", ""(()())""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_2,bos_Latn,go_test.go,"package truncate_number_test

import (
    ""testing""
    ""fmt""
)

//Vraća decimalni dio broja.//(Ostali deo je uvek manji od 1).//i cjeloviti dio (najveći cjeloviti broj manji od datog broja) i decimalni //Ako je broj u kružnoj tački pozitivan, može se razložiti na // >>> truncate_number(3.5)
// 0.5
func truncate_number(number float64) float64 {
","package truncate_number_test

import (
    ""testing""
    ""fmt""
)

// Given a positive floating point number, it can be decomposed into
// an integer part (largest integer smaller than given number) and decimals
// (leftover part always smaller than 1).
// Return the decimal part of the number.
// >>> truncate_number(3.5)
// 0.5
func truncate_number(number float64) float64 {
    integerPart := int(number)
    return number - float64(integerPart)
}

func TestTruncateNumber(t *testing.T) {
    testCases := []struct {
        input float64
        expected float64
    }{
        {3.5, 0.5},
        {0.0, 0.0},
        {7.25, 0.25},
        {4.99, 0.99},
        {2.0, 0.0},
    }

    for _, tc := range testCases {
        result := truncate_number(tc.input)
        if result != tc.expected {
            t.Errorf(""Expected %.2f, got %.2f"", tc.expected, result)
        }
    }
}

func main() {
    fmt.Println(truncate_number(3.5)) // Should print 0.5
    fmt.Println(truncate_number(7.25)) // Should print 0.25
}","func TestTruncate_Number(t *testing.T) {
  candidate := truncate_number
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3.5), expected: 0.5 },
     { actual: candidate(1.25), expected: 0.25 },
     { actual: candidate(123.0), expected: 0.0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_3,bos_Latn,go_test.go,"package below_zero_test

import (
    ""testing""
    ""fmt""
)

//U tom trenutku funkcija bi trebala da vrati tačno. U suprotnom bi trebala da vrati lažno.//Vaš zadatak je da otkrijete da li je u bilo kom trenutku saldo računa ispod nule, i //Dobiješ listu depozita i povlačenja na bankovnom računu koji počinje sa // >>> below_zero([]int{1, 2, 3})
// false
// >>> below_zero([]int{1, 2, -4, 5})
// true
func below_zero(operations []int) bool {
","package below_zero_test

import (
    ""testing""
    ""fmt""
)

func below_zero(operations []int) bool {
    balance := 0
    for _, op := range operations {
        balance += op
        if balance < 0 {
            return true
        }
    }
    return false
}

func TestBelowZero(t *testing.T) {
    testCases := []struct {
        operations []int
        expected   bool
    }{
        {[]int{1, 2, 3}, false},
        {[]int{1, 2, -4, 5}, true},
        {[]int{0, -1, 1}, true},
        {[]int{}, false},
        {[]int{-1, 1, -1, 1}, true},
    }
    for _, tc := range testCases {
        result := below_zero(tc.operations)
        if result != tc.expected {
            t.Errorf(""below_zero(%v) = %v; want %v"", tc.operations, result, tc.expected)
        }
    }
}","func TestBelow_Zero(t *testing.T) {
  candidate := below_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: false },
     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },
     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },
     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },
     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },
     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_4,bos_Latn,go_test.go,"package mean_absolute_deviation_test

import (
    ""testing""
    ""fmt""
)

//MAD = prosek. x - x_mean.//element i središnju tačku (u ovom slučaju sredina): //Prosječna apsolutna devijacija je prosječna apsolutna razlika između svakog od njih.//oko sredine ovog skupa podataka.//Za dat popis ulaznih brojeva, izračunati srednju apsolutnu devijaciju // >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})
// 1.0
func mean_absolute_deviation(numbers []float64) float64 {
","package mean_absolute_deviation_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func mean_absolute_deviation(numbers []float64) float64 {
    var sum float64
    for _, num := range numbers {
        sum += num
    }
    mean := sum / float64(len(numbers))

    var madSum float64
    for _, num := range numbers {
        madSum += math.Abs(num - mean)
    }
    return madSum / float64(len(numbers))
}

func TestMeanAbsoluteDeviation(t *testing.T) {
    tests := []struct {
        input []float64
        want  float64
    }{
        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},
        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},
        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""mean_absolute_deviation(%v)"", test.input), func(t *testing.T) {
            got := mean_absolute_deviation(test.input)
            if got != test.want {
                t.Errorf(""mean_absolute_deviation(%v) = %v; want %v"", test.input, got, test.want)
            }
        })
    }
}","func TestMean_Absolute_Deviation(t *testing.T) {
  candidate := mean_absolute_deviation
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_5,bos_Latn,go_test.go,"package intersperse_test

import (
    ""testing""
    ""fmt""
)

//Ustaviti broj ""delimiter"" između svake dvije uzastopne elemente ulazne liste `brojevi"" // >>> intersperse([]int{}, 4)
// []int{}
// >>> intersperse([]int{1, 2, 3}, 4)
// []int{1, 4, 2, 4, 3}
func intersperse(numbers []int, delimeter int) []int {
","package intersperse_test

import (
    ""testing""
    ""fmt""
)

func intersperse(numbers []int, delimiter int) []int {
    if len(numbers) == 0 {
        return []int{}
    }

    result := make([]int, 0, len(numbers)*2-1)
    for i, num := range numbers {
        if i > 0 {
            result = append(result, delimiter)
        }
        result = append(result, num)
    }
    return result
}

func TestIntersperse(t *testing.T) {
    testCases := []struct{
        input []int
        delimiter int
        expected []int
    }{
        {[]int{}, 4, []int{}},
        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},
        {[]int{1}, 4, []int{1}},
        {[]int{1, 2}, 4, []int{1, 4, 2}},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf(""%v, %d"", tc.input, tc.delimiter), func(t *testing.T) {
            result := intersperse(tc.input, tc.delimiter)
            if !equal(result, tc.expected) {
                t.Errorf(""Expected %v, but got %v"", tc.expected, result)
            }
        })
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    
    return true
}","func TestIntersperse(t *testing.T) {
  candidate := intersperse
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}, 7), expected: []int{} },
     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },
     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_6,bos_Latn,go_test.go,"package parse_nested_parens_test

import (
    ""testing""
    ""fmt""
)

//Na primer, (() (()) ima najviše dva nivoa gniježđenja, dok ((())) ima tri. //Za svaku od grupa, iznos najdužeg nivoa ugnežđivanja zagrada. //Uvod za ovu funkciju je niz koji predstavlja više grupa za ugnežđene zagrade odvojene prostorima.// >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// []int{2, 3, 1, 3}
func parse_nested_parens(paren_string string) []int {
","func parse_nested_parens(paren_string string) []int {
    groups := strings.Fields(paren_string)
    depths := make([]int, len(groups))

    for i, group := range groups {
        maxDepth, currentDepth := 0, 0
        for _, char := range group {
            if char == '(' {
                currentDepth++
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == ')' {
                currentDepth--
            }
        }
        depths[i] = maxDepth
    }

    return depths
}","func TestParse_Nested_Parens(t *testing.T) {
  candidate := parse_nested_parens
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""(()()) ((())) () ((())()())""), expected: []int{2, 3, 1, 3} },
     { actual: candidate(""() (()) ((())) (((())))""), expected: []int{1, 2, 3, 4} },
     { actual: candidate(""(()(())((())))""), expected: []int{4} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_7,bos_Latn,go_test.go,"package filter_by_substring_test

import (
    ""testing""
    ""fmt""
)

//Filtrirajte ulaznu listu niza samo za one koji sadrže datog podniza // >>> filter_by_substring([]string{}, ""a"")
// []string{}
// >>> filter_by_substring([]string{""abc"", ""bacd"", ""cde"", ""array""}, ""a"")
// []string{""abc"", ""bacd"", ""array""}
func filter_by_substring(strings []string, substring string) []string {
","package filter_by_substring_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func filter_by_substring(strings []string, substring string) []string {
    var result []string
    for _, str := range strings {
        if strings.Contains(str, substring) {
            result = append(result, str)
        }
    }
    return result
}

func TestFilterBySubstring(t *testing.T) {
    tests := []struct {
        input    []string
        substring string
        expected []string
    }{
        {[]string{}, ""a"", []string{}},
        {[]string{""abc"", ""bacd"", ""cde"", ""array""}, ""a"", []string{""abc"", ""bacd"", ""array""}},
    }

    for _, test := range tests {
        result := filter_by_substring(test.input, test.substring)
        if fmt.Sprintf(""%q"", result) != fmt.Sprintf(""%q"", test.expected) {
            t.Errorf(""filter_by_substring(%q, %q) = %q; expected %q"", test.input, test.substring, result, test.expected)
        }
    }
}","func TestFilter_By_Substring(t *testing.T) {
  candidate := filter_by_substring
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, ""john""), expected: []string{} },
     { actual: candidate([]string{""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xxx""), expected: []string{""xxx"", ""xxxAAA"", ""xxx""} },
     { actual: candidate([]string{""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xx""), expected: []string{""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""} },
     { actual: candidate([]string{""grunt"", ""trumpet"", ""prune"", ""gruesome""}, ""run""), expected: []string{""grunt"", ""prune""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_8,bos_Latn,go_test.go,"package sum_product_test

import (
    ""testing""
    ""fmt""
)

//Prazna suma treba da bude jednaka 0 a prazan proizvod jednaka 1.//Za datog popisa cijelih brojeva, vratite popis koji se sastoji od zbroja i proizvoda svih cijelih brojeva na listi. // >>> sum_product([]int{})
// []interface{}{0, 1}
// >>> sum_product([]int{1, 2, 3, 4})
// []interface{}{10, 24}
func sum_product(numbers []int) []interface{} {
","func sum_product(numbers []int) []interface{} {
    sum := 0
    product := 1
    for _, number := range numbers {
        sum += number
        product *= number
    }
    return []interface{}{sum, product}
}","func TestSum_Product(t *testing.T) {
  candidate := sum_product
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []interface{}{0, 1} },
     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },
     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },
     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },
     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_9,bos_Latn,go_test.go,"package rolling_max_test

import (
    ""testing""
    ""fmt""
)

//u nizu.//Iz date liste cijelih brojeva, generirajte listu najviša broja elemenata pronađenih do datog trenutka.// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})
// []int{1, 2, 3, 3, 3, 4, 4}
func rolling_max(numbers []int) []int {
","package rolling_max_test

import (
    ""testing""
    ""fmt""
)

// From a given list of integers, generate a list of rolling maximum element found until given moment
// in the sequence.
// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})
// []int{1, 2, 3, 3, 3, 4, 4}
func rolling_max(numbers []int) []int {
    if len(numbers) == 0 {
        return []int{}
    }
    result := make([]int, len(numbers))
    maxSoFar := numbers[0]
    for i, num := range numbers {
        if num > maxSoFar {
            maxSoFar = num
        }
        result[i] = maxSoFar
    }
    return result
}

func TestRollingMax(t *testing.T) {
    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) // should output []int{1, 2, 3, 3, 3, 4, 4}
}","func TestRolling_Max(t *testing.T) {
  candidate := rolling_max
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },
     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },
     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_10,bos_Latn,go_test.go,"package make_palindrome_test

import (
    ""testing""
    ""fmt""
)

//- Dodajte na kraj reversa niza prefiks koji dolazi prije palindromskog sufiksa.//- Nađi najduži postfix ponuđenog niza koji je palindrom. //Ideja algoritma je jednostavna://Nađi najkraći palindrom koji počinje sa datim nizom.// >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
func make_palindrome(myString string) string {
","package make_palindrome_test

import (
    ""testing""
)

func make_palindrome(myString string) string {
    if len(myString) <= 1 {
        return myString
    }
    
    // Helper function to check if a string is a palindrome
    isPalindrome := func(s string) bool {
        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
            if s[i] != s[j] {
                return false
            }
        }
        return true
    }

    // Start from the whole string and reduce until we find a palindrome
    for i := len(myString); i > 0; i-- {
        if isPalindrome(myString[len(myString)-i:]) {
            prefix := myString[:len(myString)-i]
            // Reverse the prefix and append to original string
            reversedPrefix := reverse(prefix)
            return myString + reversedPrefix
        }
    }

    // If no palindromic suffix is found, return original string with reverse appended
    return myString + reverse(myString)
}

// Helper function to reverse a string
func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func TestMakePalindrome(t *testing.T) {
    tests := []struct {
        input    string
        expected string
    }{
        {"""", """"},
        {""cat"", ""catac""},
        {""cata"", ""catac""},
    }

    for _, test := range tests {
        result := make_palindrome(test.input)
        if result != test.expected {
            t.Errorf(""make_palindrome(%q) = %q; expected %q"", test.input, result, test.expected)
        }
    }
}","func TestMake_Palindrome(t *testing.T) {
  candidate := make_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""x""), expected: ""x"" },
     { actual: candidate(""xyz""), expected: ""xyzyx"" },
     { actual: candidate(""xyx""), expected: ""xyx"" },
     { actual: candidate(""jerry""), expected: ""jerryrrej"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_11,bos_Latn,go_test.go,"package string_xor_test

import (
    ""testing""
    ""fmt""
)

//Izvedite binarni XOR na ovim ulazima i vratite rezultat također kao niz.//Ulaz su dva niza a i b koja se sastoje samo od 1 i 0 .// >>> string_xor(""010"", ""110"")
// ""100""
func string_xor(a string, b string) string {
","result := make([]byte, len(a))
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			result[i] = '0'
		} else {
			result[i] = '1'
		}
	}
	return string(result)
}","func TestString_Xor(t *testing.T) {
  candidate := string_xor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""111000"", ""101010""), expected: ""010010"" },
     { actual: candidate(""1"", ""1""), expected: ""0"" },
     { actual: candidate(""0101"", ""0000""), expected: ""0101"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_13,bos_Latn,go_test.go,"package greatest_common_divisor_test

import (
    ""testing""
    ""fmt""
)

//Vrati najveći zajednički delitelj dva cijela broja a i b // >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
func greatest_common_divisor(a int, b int) int {
","package greatest_common_divisor_test

import (
    ""testing""
    ""fmt""
)

// Return a greatest common divisor of two integers a and b
// >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
func greatest_common_divisor(a int, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func TestGreatestCommonDivisor(t *testing.T) {
    tests := []struct {
        a, b   int
        expect int
    }{
        {3, 5, 1},
        {25, 15, 5},
        {54, 24, 6},
        {48, 18, 6},
        {101, 103, 1},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d,%d"", test.a, test.b), func(t *testing.T) {
            result := greatest_common_divisor(test.a, test.b)
            if result != test.expect {
                t.Errorf(""expected %d, got %d"", test.expect, result)
            }
        })
    }
}","func TestGreatest_Common_Divisor(t *testing.T) {
  candidate := greatest_common_divisor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 7), expected: 1 },
     { actual: candidate(10, 15), expected: 5 },
     { actual: candidate(49, 14), expected: 7 },
     { actual: candidate(144, 60), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_14,bos_Latn,go_test.go,"package all_prefixes_test

import (
    ""testing""
    ""fmt""
)

//Vraća popis svih prefiksa od najkraćeg do najdužeg ulaznog niza // >>> all_prefixes(""abc"")
// []string{""a"", ""ab"", ""abc""}
func all_prefixes(myString string) []string {
","package all_prefixes_test

import (
    ""testing""
    ""fmt""
)

// Return list of all prefixes from shortest to longest of the input string
// >>> all_prefixes(""abc"")
// []string{""a"", ""ab"", ""abc""}
func all_prefixes(myString string) []string {
    var prefixes []string
    for i := 1; i <= len(myString); i++ {
        prefixes = append(prefixes, myString[:i])
    }
    return prefixes
}

func TestAllPrefixes(t *testing.T) {
    result := all_prefixes(""abc"")
    expected := []string{""a"", ""ab"", ""abc""}
    for i, v := range result {
        if v != expected[i] {
            t.Errorf(""Test failed, expected %v, got %v"", expected[i], v)
        }
    }
    fmt.Println(""Test passed"")
}","func TestAll_Prefixes(t *testing.T) {
  candidate := all_prefixes
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: []string{} },
     { actual: candidate(""asdfgh""), expected: []string{""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""} },
     { actual: candidate(""WWW""), expected: []string{""W"", ""WW"", ""WWW""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_15,bos_Latn,go_test.go,"package string_sequence_test

import (
    ""testing""
    ""fmt""
)

//Vraća niz koji sadrži brojeve ograničene prostorom počevši od 0 do n.// >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
func string_sequence(n int) string {
","package string_sequence_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
func string_sequence(n int) string {
    var parts []string
    for i := 0; i <= n; i++ {
        parts = append(parts, fmt.Sprintf(""%d"", i))
    }
    return strings.Join(parts, "" "")
}

func TestStringSequence(t *testing.T) {
    result := string_sequence(0)
    expected := ""0""
    if result != expected {
        t.Errorf(""Expected %s, got %s"", expected, result)
    }
    
    result = string_sequence(5)
    expected = ""0 1 2 3 4 5""
    if result != expected {
        t.Errorf(""Expected %s, got %s"", expected, result)
    }
}","func TestString_Sequence(t *testing.T) {
  candidate := string_sequence
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0), expected: ""0"" },
     { actual: candidate(3), expected: ""0 1 2 3"" },
     { actual: candidate(10), expected: ""0 1 2 3 4 5 6 7 8 9 10"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_16,bos_Latn,go_test.go,"package count_distinct_characters_test

import (
    ""testing""
    ""fmt""
)

//Ako je dat niz, saznajte koliko različitih znakova (bez obzira na slučaj) ima.// >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
func count_distinct_characters(myString string) int {
","package count_distinct_characters_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func count_distinct_characters(myString string) int {
    characterMap := make(map[rune]bool)
    for _, char := range strings.ToLower(myString) {
        characterMap[char] = true
    }
    return len(characterMap)
}

func TestCountDistinctCharacters(t *testing.T) {
    testCases := []struct{
        input string
        expected int
    }{
        {""xyzXYZ"", 3},
        {""Jerry"", 4},
        {"""", 0},
        {""Hello, World!"", 10},
    }

    for _, testCase := range testCases {
        result := count_distinct_characters(testCase.input)
        if result != testCase.expected {
            t.Errorf(""For input '%s', expected %d but got %d"", testCase.input, testCase.expected, result)
        } else {
            fmt.Printf(""Test passed for input '%s': got %d\n"", testCase.input, result)
        }
    }
}","func TestCount_Distinct_Characters(t *testing.T) {
  candidate := count_distinct_characters
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""abcde""), expected: 5 },
     { actual: candidate(""abcdecadeCADE""), expected: 5 },
     { actual: candidate(""aaaaAAAAaaaa""), expected: 1 },
     { actual: candidate(""Jerry jERRY JeRRRY""), expected: 5 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_17,bos_Latn,go_test.go,"package parse_music_test

import (
    ""testing""
    ""fmt""
)

//'Hajka' - četvrti nota, traje jedan ritam.//""O"" je pola note, traje dva takta.//'O' - cijela nota, traje četiri udarca.//Evo legende://Ne poslednji.//Vaš zadatak je da analizirate ovaj niz i vratite listu cijelih brojeva koji odgovaraju broju otkucaja svakog.//Uvod za ovu funkciju je niz koji predstavlja muzičke note u posebnom ASCII formatu.// >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
func parse_music(music_string string) []int {
","package parse_music_test

import (
    ""strings""
)

func parse_music(music_string string) []int {
    notes := strings.Fields(music_string)
    beats := make([]int, len(notes))
    for i, note := range notes {
        switch note {
        case ""o"":
            beats[i] = 4
        case ""o|"":
            beats[i] = 2
        case "".|"":
            beats[i] = 1
        }
    }
    return beats
}","func TestParse_Music(t *testing.T) {
  candidate := parse_music
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: []int{} },
     { actual: candidate(""o o o o""), expected: []int{4, 4, 4, 4} },
     { actual: candidate("".| .| .| .|""), expected: []int{1, 1, 1, 1} },
     { actual: candidate(""o| o| .| .| o o o o""), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },
     { actual: candidate(""o| .| o| .| o o| o o|""), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_18,bos_Latn,go_test.go,"package how_many_times_test

import (
    ""testing""
    ""fmt""
)

//Pronađite koliko puta se određeni podstrin može naći u izvornom nizu.// >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
func how_many_times(myString string, substring string) int {
","func how_many_times(myString string, substring string) int {
    if len(substring) == 0 {
        return 0
    }

    count := 0
    for i := 0; i <= len(myString)-len(substring); i++ {
        if myString[i:i+len(substring)] == substring {
            count++
        }
    }
    return count
}

func TestHowManyTimes(t *testing.T) {
    tests := []struct {
        myString  string
        substring string
        expected  int
    }{
        {"""", ""a"", 0},
        {""aaa"", ""a"", 3},
        {""aaaa"", ""aa"", 3},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%s in %s"", test.substring, test.myString), func(t *testing.T) {
            result := how_many_times(test.myString, test.substring)
            if result != test.expected {
                t.Errorf(""Expected %d but got %d"", test.expected, result)
            }
        })
    }
}","func TestHow_Many_Times(t *testing.T) {
  candidate := how_many_times
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate("""", ""x""), expected: 0 },
     { actual: candidate(""xyxyxyx"", ""x""), expected: 4 },
     { actual: candidate(""cacacacac"", ""cac""), expected: 4 },
     { actual: candidate(""john doe"", ""john""), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_19,bos_Latn,go_test.go,"package sort_numbers_test

import (
    ""testing""
    ""fmt""
)

//Vraća niz sa brojevima sortiranim od najmanjeg do najvećeg //Važeći izbori su ""nula"", ""jedan"", ""dva"", ""tri"", ""četiri"", ""pet"", ""šest"", ""sedam"", ""osam"" i ""devet"". //Unos je prostorom ograničen niz brojeva od ""nula"" do ""devet"".// >>> sort_numbers(""three one five"")
// ""one three five""
func sort_numbers(numbers string) string {
","package sort_numbers_test

import (
    ""strings""
    ""sort""
)

func sort_numbers(numbers string) string {
    wordsToNumbers := map[string]int{
        ""zero"":  0,
        ""one"":   1,
        ""two"":   2,
        ""three"": 3,
        ""four"":  4,
        ""five"":  5,
        ""six"":   6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"":  9,
    }
    
    numbersToWords := []string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""}
    
    words := strings.Fields(numbers)
    numberInts := make([]int, len(words))
    
    for i, word := range words {
        numberInts[i] = wordsToNumbers[word]
    }
    
    sort.Ints(numberInts)
    
    sortedWords := make([]string, len(words))
    for i, num := range numberInts {
        sortedWords[i] = numbersToWords[num]
    }
    
    return strings.Join(sortedWords, "" "")
}","func TestSort_Numbers(t *testing.T) {
  candidate := sort_numbers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""three""), expected: ""three"" },
     { actual: candidate(""three five nine""), expected: ""three five nine"" },
     { actual: candidate(""five zero four seven nine eight""), expected: ""zero four five seven eight nine"" },
     { actual: candidate(""six five four three two one zero""), expected: ""zero one two three four five six"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_20,bos_Latn,go_test.go,"package find_closest_elements_test

import (
    ""testing""
    ""fmt""
)

//drugi i vrati ih po redu (manji broj, veći broj).//Iz ponuđene liste brojeva (dužine najmanje dva) odaberite i vratite dva koja su najbliža svakom // >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})
// []interface{}{2.0, 2.2}
// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})
// []interface{}{2.0, 2.0}
func find_closest_elements(numbers []float64) []interface{} {
","package find_closest_elements_test

import (
    ""math""
    ""sort""
)

func find_closest_elements(numbers []float64) []interface{} {
    if len(numbers) < 2 {
        return nil
    }
    
    // Create a sorted copy of the numbers
    sortedNumbers := make([]float64, len(numbers))
    copy(sortedNumbers, numbers)
    sort.Float64s(sortedNumbers)
    
    // Initialize the minimum difference and result
    minDiff := math.MaxFloat64
    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}
    
    // Iterate over the sorted numbers to find the closest pair
    for i := 1; i < len(sortedNumbers); i++ {
        diff := sortedNumbers[i] - sortedNumbers[i-1]
        if diff < minDiff {
            minDiff = diff
            result[0] = sortedNumbers[i-1]
            result[1] = sortedNumbers[i]
        }
    }
    
    return result
}","func TestFind_Closest_Elements(t *testing.T) {
  candidate := find_closest_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_21,bos_Latn,go_test.go,"package rescale_to_unit_test

import (
    ""testing""
    ""fmt""
)

//Tako da će najmanji broj postati 0 a najveći broj će postati 1 .//Ako je data lista brojeva (od najmanje dva elementa), primijeni linearnu transformaciju na tu listu, // >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})
// []float64{0.0, 0.25, 0.5, 0.75, 1.0}
func rescale_to_unit(numbers []float64) []float64 {
","package rescale_to_unit_test

import (
	""testing""
	""fmt""
)

func rescale_to_unit(numbers []float64) []float64 {
	if len(numbers) < 2 {
		return numbers
	}
	
	minVal := numbers[0]
	maxVal := numbers[0]
	for _, num := range numbers {
		if num < minVal {
			minVal = num
		} else if num > maxVal {
			maxVal = num
		}
	}

	scale := maxVal - minVal
	if scale == 0 {
		return make([]float64, len(numbers))
	}

	rescaled := make([]float64, len(numbers))
	for i, num := range numbers {
		rescaled[i] = (num - minVal) / scale
	}

	return rescaled
}

func TestRescaleToUnit(t *testing.T) {
	tests := []struct {
		input    []float64
		expected []float64
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},
		{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},
		{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},
		{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},
	}

	for _, test := range tests {
		result := rescale_to_unit(test.input)
		for i, v := range result {
			if v != test.expected[i] {
				t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
				break
			}
		}
	}
}","func TestRescale_To_Unit(t *testing.T) {
  candidate := rescale_to_unit
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },
     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },
     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },
     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_22,bos_Latn,go_test.go,"package filter_integers_test

import (
    ""testing""
    ""fmt""
)

//Filter datog popisa svih gothon vrijednosti samo za cifre // >>> filter_integers([]float64{""a"", 3.14, 5})
// []int{5}
// >>> filter_integers([]interface{}{1, 2, 3, ""abc"", map[interface{}]interface{}{}, []interface{}{}})
// []int{1, 2, 3}
func filter_integers(values []interface{}) []int {
","func filter_integers(values []interface{}) []int {
    var result []int
    for _, v := range values {
        if intValue, ok := v.(int); ok {
            result = append(result, intValue)
        }
    }
    return result
}

func TestFilterIntegers(t *testing.T) {
    cases := []struct {
        input    []interface{}
        expected []int
    }{
        {
            input:    []interface{}{1, 2, 3, ""abc"", map[interface{}]interface{}{}, []interface{}{}},
            expected: []int{1, 2, 3},
        },
        {
            input:    []interface{}{""a"", 3.14, 5},
            expected: []int{5},
        },
    }

    for _, c := range cases {
        result := filter_integers(c.input)
        if !equal(result, c.expected) {
            t.Errorf(""filter_integers(%v) == %v, expected %v"", c.input, result, c.expected)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}","func TestFilter_Integers(t *testing.T) {
  candidate := filter_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]interface{}{}), expected: []int{} },
     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, ""adasd""}), expected: []int{4, 9} },
     { actual: candidate([]interface{}{3, ""c"", 3, 3, ""a"", ""b""}), expected: []int{3, 3, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_23,bos_Latn,go_test.go,"package strlen_test

import (
    ""testing""
    ""fmt""
)

//Vraća dužinu datog niza // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
func strlen(myString string) int {
","return len(myString)
}","func TestStrlen(t *testing.T) {
  candidate := strlen
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""x""), expected: 1 },
     { actual: candidate(""asdasnakj""), expected: 9 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_24,bos_Latn,go_test.go,"package largest_divisor_test

import (
    ""testing""
    ""fmt""
)

//Za dat broj n, pronađite najveći broj koji n podijeli ravnomjerno, manji od n // >>> largest_divisor(15)
// 5
func largest_divisor(n int) int {
","package largest_divisor_test

import (
    ""testing""
    ""fmt""
)

// For a given number n, find the largest number that divides n evenly, smaller than n
// >>> largest_divisor(15)
// 5
func largest_divisor(n int) int {
    for i := n/2; i > 0; i-- {
        if n%i == 0 {
            return i
        }
    }
    return 1
}

func TestLargestDivisor(t *testing.T) {
    cases := []struct {
        input    int
        expected int
    }{
        {15, 5},
        {100, 50},
        {49, 7},
        {81, 27},
        {1, 1},
    }

    for _, c := range cases {
        result := largest_divisor(c.input)
        if result != c.expected {
            t.Errorf(""largest_divisor(%d) == %d, expected %d"", c.input, result, c.expected)
        }
    }
}

func main() {
    fmt.Println(largest_divisor(15))
}","func TestLargest_Divisor(t *testing.T) {
  candidate := largest_divisor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: 1 },
     { actual: candidate(7), expected: 1 },
     { actual: candidate(10), expected: 5 },
     { actual: candidate(100), expected: 50 },
     { actual: candidate(49), expected: 7 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_25,bos_Latn,go_test.go,"package factorize_test

import (
    ""testing""
    ""fmt""
)

//Ulazni broj treba da bude jednak proizvodu svih faktora.//Svaki od faktora treba da bude naveden broj puta koji odgovara broju puta kada se pojavljuje u faktorizaciji.//Vraća listu primarnih faktora datog broja u redoslijedu od najmanjeg do najvećeg.// >>> factorize(8)
// []int{2, 2, 2}
// >>> factorize(25)
// []int{5, 5}
// >>> factorize(70)
// []int{2, 5, 7}
func factorize(n int) []int {
","package factorize

func factorize(n int) []int {
	var factors []int
	for i := 2; i*i <= n; i++ {
		for n%i == 0 {
			factors = append(factors, i)
			n /= i
		}
	}
	if n > 1 {
		factors = append(factors, n)
	}
	return factors
}","func TestFactorize(t *testing.T) {
  candidate := factorize
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: []int{2} },
     { actual: candidate(4), expected: []int{2, 2} },
     { actual: candidate(8), expected: []int{2, 2, 2} },
     { actual: candidate(57), expected: []int{3, 19} },
     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },
     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },
     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },
     { actual: candidate(18), expected: []int{2, 3, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_26,bos_Latn,go_test.go,"package remove_duplicates_test

import (
    ""testing""
    ""fmt""
)

//Ostavite redosled elemenata isti kao i u ulazu.//Iz liste cijelih brojeva, uklonite sve elemente koji se pojavljuju više od jednom.// >>> remove_duplicates([]int{1, 2, 3, 2, 4})
// []int{1, 3, 4}
func remove_duplicates(numbers []int) []int {
","package remove_duplicates_test

import (
	""testing""
	""fmt""
)

func remove_duplicates(numbers []int) []int {
	counts := make(map[int]int)
	for _, num := range numbers {
		counts[num]++
	}

	result := []int{}
	for _, num := range numbers {
		if counts[num] == 1 {
			result = append(result, num)
		}
	}
	return result
}

func TestRemoveDuplicates(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},
		{[]int{1, 1, 1, 1}, []int{}},
		{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},
		{[]int{5, 5, 5, 6}, []int{6}},
		{[]int{9, 8, 9, 8, 7}, []int{7}},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""remove_duplicates(%v)"", test.input), func(t *testing.T) {
			result := remove_duplicates(test.input)
			if len(result) != len(test.expected) {
				t.Errorf(""Expected length %d, got %d"", len(test.expected), len(result))
			}
			for i, v := range result {
				if v != test.expected[i] {
					t.Errorf(""Expected %v, got %v"", test.expected, result)
					break
				}
			}
		})
	}
}","func TestRemove_Duplicates(t *testing.T) {
  candidate := remove_duplicates
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },
     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_27,bos_Latn,go_test.go,"package flip_case_test

import (
    ""testing""
    ""fmt""
)

//Za dat niz, prebacite male znakove u velike i velike u male. // >>> flip_case(""Hello"")
// ""hELLO""
func flip_case(myString string) string {
","func flip_case(myString string) string {
	var result []rune
	for _, char := range myString {
		if char >= 'a' && char <= 'z' {
			result = append(result, char-('a'-'A'))
		} else if char >= 'A' && char <= 'Z' {
			result = append(result, char+('a'-'A'))
		} else {
			result = append(result, char)
		}
	}
	return string(result)
}","func TestFlip_Case(t *testing.T) {
  candidate := flip_case
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""Hello!""), expected: ""hELLO!"" },
     { actual: candidate(""These violent delights have violent ends""), expected: ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_28,bos_Latn,go_test.go,"package concatenate_test

import (
    ""testing""
    ""fmt""
)

//Konkatenirati listu niza u jedan niz.// >>> concatenate([]string{})
// """"
// >>> concatenate([]string{""a"", ""b"", ""c""})
// ""abc""
func concatenate(strings []string) string {
","result := """"
    for _, str := range strings {
        result += str
    }
    return result
}","func TestConcatenate(t *testing.T) {
  candidate := concatenate
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}), expected: """" },
     { actual: candidate([]string{""x"", ""y"", ""z""}), expected: ""xyz"" },
     { actual: candidate([]string{""x"", ""y"", ""z"", ""w"", ""k""}), expected: ""xyzwk"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_29,bos_Latn,go_test.go,"package filter_by_prefix_test

import (
    ""testing""
    ""fmt""
)

//Filtrirajte ulaznu listu niza samo za one koji počinju sa datim prefiksom.// >>> filter_by_prefix([]string{}, ""a"")
// []string{}
// >>> filter_by_prefix([]string{""abc"", ""bcd"", ""cde"", ""array""}, ""a"")
// []string{""abc"", ""array""}
func filter_by_prefix(strings []string, prefix string) []string {
","package filter_by_prefix_test

import (
    ""testing""
)

// Filter an input list of strings only for ones that start with a given prefix.
func filter_by_prefix(strings []string, prefix string) []string {
    var result []string
    for _, str := range strings {
        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {
            result = append(result, str)
        }
    }
    return result
}

func TestFilterByPrefix(t *testing.T) {
    tests := []struct {
        input    []string
        prefix   string
        expected []string
    }{
        {[]string{}, ""a"", []string{}},
        {[]string{""abc"", ""bcd"", ""cde"", ""array""}, ""a"", []string{""abc"", ""array""}},
        {[]string{""hello"", ""helium"", ""world""}, ""he"", []string{""hello"", ""helium""}},
        {[]string{""banana"", ""band"", ""bandana""}, ""ban"", []string{""banana"", ""band"", ""bandana""}},
        {[]string{""apple"", ""ape"", ""apricot""}, ""ap"", []string{""apple"", ""ape"", ""apricot""}},
    }

    for _, test := range tests {
        result := filter_by_prefix(test.input, test.prefix)
        if !equal(result, test.expected) {
            t.Errorf(""filter_by_prefix(%v, %s) = %v; expected %v"", test.input, test.prefix, result, test.expected)
        }
    }
}

func equal(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestFilter_By_Prefix(t *testing.T) {
  candidate := filter_by_prefix
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, ""john""), expected: []string{} },
     { actual: candidate([]string{""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xxx""), expected: []string{""xxx"", ""xxxAAA"", ""xxx""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_30,bos_Latn,go_test.go,"package get_positive_test

import (
    ""testing""
    ""fmt""
)

//Vraća samo pozitivne brojeve iz liste.// >>> get_positive([]int{-1, 2, -4, 5, 6})
// []int{2, 5, 6}
// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// []int{5, 3, 2, 3, 9, 123, 1}
func get_positive(l []int) []int {
","package get_positive_test

import (
    ""testing""
    ""fmt""
)

// Return only positive numbers in the list.
func get_positive(l []int) []int {
    var positiveNumbers []int
    for _, num := range l {
        if num > 0 {
            positiveNumbers = append(positiveNumbers, num)
        }
    }
    return positiveNumbers
}

func TestGetPositive(t *testing.T) {
    tests := []struct {
        input  []int
        output []int
    }{
        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},
        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},
    }
    
    for _, test := range tests {
        result := get_positive(test.input)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", test.output) {
            t.Errorf(""Expected %v, got %v"", test.output, result)
        }
    }
}","func TestGet_Positive(t *testing.T) {
  candidate := get_positive
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },
     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },
     { actual: candidate([]int{-1, -2}), expected: []int{} },
     { actual: candidate([]int{}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_31,bos_Latn,go_test.go,"package is_prime_test

import (
    ""testing""
    ""fmt""
)

//Vrati tačno ako je dat broj prvi, i pogrešno inače.// >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
func is_prime(n int) bool {
","package is_prime_test

import (
    ""testing""
    ""fmt""
)

func is_prime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func TestIsPrime(t *testing.T) {
    testCases := []struct {
        number   int
        expected bool
    }{
        {6, false},
        {101, true},
        {11, true},
        {13441, true},
        {61, true},
        {4, false},
        {1, false},
    }

    for _, testCase := range testCases {
        result := is_prime(testCase.number)
        if result != testCase.expected {
            t.Errorf(""is_prime(%d) = %v; want %v"", testCase.number, result, testCase.expected)
        } else {
            fmt.Printf(""Test Passed: is_prime(%d) = %v\n"", testCase.number, result)
        }
    }
}","func TestIs_Prime(t *testing.T) {
  candidate := is_prime
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(6), expected: false },
     { actual: candidate(101), expected: true },
     { actual: candidate(11), expected: true },
     { actual: candidate(13441), expected: true },
     { actual: candidate(61), expected: true },
     { actual: candidate(4), expected: false },
     { actual: candidate(1), expected: false },
     { actual: candidate(5), expected: true },
     { actual: candidate(11), expected: true },
     { actual: candidate(17), expected: true },
     { actual: candidate(85), expected: false },
     { actual: candidate(77), expected: false },
     { actual: candidate(255379), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_33,bos_Latn,go_test.go,"package sort_third_test

import (
    ""testing""
    ""fmt""
)

//za vrijednosti odgovarajućih indeksa l, ali sortiran.//l' je identičan l u indeksu koji nije podijeljen sa tri, dok su njegove vrijednosti u indeksu koji je podijeljen sa tri jednake.//Ova funkcija uzima listu l i vraća listu l' takvu da // >>> sort_third([]int{1, 2, 3})
// []int{1, 2, 3}
// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})
// []int{2, 6, 3, 4, 8, 9, 5}
func sort_third(l []int) []int {
","package sort_third_test

import (
    ""sort""
)

func sort_third(l []int) []int {
    type pair struct {
        index int
        value int
    }

    // Collect the pairs where indices are divisible by 3
    sortSection := []pair{}

    for i := 0; i < len(l); i++ {
        if i%3 == 0 {
            sortSection = append(sortSection, pair{index: i, value: l[i]})
        }
    }

    // Sort this section based on the values
    sort.Slice(sortSection, func(i, j int) bool {
        return sortSection[i].value < sortSection[j].value
    })

    // Generate result slice
    result := make([]int, len(l))
    copy(result, l)

    // Fill the sorted values back to the result
    for _, p := range sortSection {
        result[p.index] = p.value
    }

    return result
}","func TestSort_Third(t *testing.T) {
  candidate := sort_third
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },
     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },
     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },
     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_34,bos_Latn,go_test.go,"package unique_test

import (
    ""testing""
    ""fmt""
)

//Vraća sortirane jedinstvene elemente u listi// >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{0, 2, 3, 5, 9, 123}
func unique(l []int) []int {
","package unique_test

import (
    ""sort""
)

func unique(l []int) []int {
    uniqueMap := make(map[int]bool)
    for _, value := range l {
        uniqueMap[value] = true
    }

    uniqueSlice := make([]int, 0, len(uniqueMap))
    for key := range uniqueMap {
        uniqueSlice = append(uniqueSlice, key)
    }

    sort.Ints(uniqueSlice)
    return uniqueSlice
}","func TestUnique(t *testing.T) {
  candidate := unique
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_35,bos_Latn,go_test.go,"package max_element_test

import (
    ""testing""
    ""fmt""
)

//Vraća najveći element na listi.// >>> max_element([]int{1, 2, 3})
// 3
// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// 123
func max_element(l []int) int {
","package max_element_test

import (
    ""testing""
    ""fmt""
)

// Return maximum element in the list.
// >>> max_element([]int{1, 2, 3})
// 3
// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// 123
func max_element(l []int) int {
    if len(l) == 0 {
        panic(""Empty list has no maximum value"")
    }
    max := l[0]
    for _, value := range l {
        if value > max {
            max = value
        }
    }
    return max
}

func TestMaxElement(t *testing.T) {
    testCases := []struct {
        input    []int
        expected int
    }{
        {[]int{1, 2, 3}, 3},
        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},
        {[]int{-1, -2, -3, -4}, -1},
        {[]int{9, 9, 9, 9}, 9},
    }

    for _, testCase := range testCases {
        result := max_element(testCase.input)
        if result != testCase.expected {
            t.Errorf(""For input %v, expected %d, got %d"", testCase.input, testCase.expected, result)
        }
    }
}","func TestMax_Element(t *testing.T) {
  candidate := max_element
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: 3 },
     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_36,bos_Latn,go_test.go,"package fizz_buzz_test

import (
    ""testing""
    ""fmt""
)

//Vrati broj puta kada se brojka 7 pojavljuje u brojevima manjim od n koji su deljivi sa 11 ili 13. // >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
func fizz_buzz(n int) int {
","package fizz_buzz_test

import (
    ""testing""
    ""fmt""
    ""strconv""
)

func fizz_buzz(n int) int {
    count := 0
    for i := 0; i < n; i++ {
        if i % 11 == 0 || i % 13 == 0 {
            count += countSevens(i)
        }
    }
    return count
}

func countSevens(num int) int {
    strNum := strconv.Itoa(num)
    count := 0
    for _, c := range strNum {
        if c == '7' {
            count++
        }
    }
    return count
}

func TestFizzBuzz(t *testing.T) {
    tests := []struct {
        input int
        expected int
    }{
        {50, 0},
        {78, 2},
        {79, 3},
    }

    for _, test := range tests {
        result := fizz_buzz(test.input)
        if result != test.expected {
            t.Errorf(""fizz_buzz(%d) = %d; expected %d"", test.input, result, test.expected)
        }
    }
}

func main() {
    fmt.Println(fizz_buzz(50)) // 0
    fmt.Println(fizz_buzz(78)) // 2
    fmt.Println(fizz_buzz(79)) // 3
}","func TestFizz_Buzz(t *testing.T) {
  candidate := fizz_buzz
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(50), expected: 0 },
     { actual: candidate(78), expected: 2 },
     { actual: candidate(79), expected: 3 },
     { actual: candidate(100), expected: 3 },
     { actual: candidate(200), expected: 6 },
     { actual: candidate(4000), expected: 192 },
     { actual: candidate(10000), expected: 639 },
     { actual: candidate(100000), expected: 8026 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_37,bos_Latn,go_test.go,"package sort_even_test

import (
    ""testing""
    ""fmt""
)

//Na vrednosti parnih indeksa l, ali sortiran.//l' je identičan l u neparnim indeksima, dok su njegove vrijednosti u parnim indeksima jednake.//Ova funkcija uzima listu l i vraća listu l' takvu da // >>> sort_even([]int{1, 2, 3})
// []int{1, 2, 3}
// >>> sort_even([]int{5, 6, 3, 4})
// []int{3, 6, 5, 4}
func sort_even(l []int) []int {
","package sort_even_test

import (
    ""sort""
)

func sort_even(l []int) []int {
    if len(l) < 2 {
        return l
    }
    
    // Extract even indices
    evens := []int{}
    for i := 0; i < len(l); i += 2 {
        evens = append(evens, l[i])
    }
    
    // Sort even-indexed elements
    sort.Ints(evens)
    
    // Merge sorted evens back into the original list
    j := 0
    for i := 0; i < len(l); i += 2 {
        l[i] = evens[j]
        j++
    }

    return l
}","func TestSort_Even(t *testing.T) {
  candidate := sort_even
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },
     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },
     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_39,bos_Latn,go_test.go,"package prime_fib_test

import (
    ""testing""
    ""fmt""
)

//prime_fib vraća n-ti broj koji je Fibonačijev broj i koji je također prvi. // >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
func prime_fib(n int) int {
","package prime_fib_test

import (
    ""testing""
    ""fmt""
)

// isPrime checks if a number is prime
func isPrime(num int) bool {
    if num <= 1 {
        return false
    }
    if num <= 3 {
        return true
    }
    if num%2 == 0 || num%3 == 0 {
        return false
    }
    for i := 5; i*i <= num; i += 6 {
        if num%i == 0 || num%(i+2) == 0 {
            return false
        }
    }
    return true
}

// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
func prime_fib(n int) int {
    if n <= 0 {
        return 0
    }
    a, b := 1, 1
    count := 0
    for count < n {
        a, b = b, a+b
        if isPrime(a) {
            count++
        }
    }
    return a
}

func TestPrimeFib(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {1, 2},
        {2, 3},
        {3, 5},
        {4, 13},
        {5, 89},
    }

    for _, test := range tests {
        result := prime_fib(test.input)
        if result != test.expected {
            t.Errorf(""prime_fib(%d) = %d; expected %d"", test.input, result, test.expected)
        } else {
            fmt.Printf(""prime_fib(%d) = %d\n"", test.input, result)
        }
    }
}","func TestPrime_Fib(t *testing.T) {
  candidate := prime_fib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 2 },
     { actual: candidate(2), expected: 3 },
     { actual: candidate(3), expected: 5 },
     { actual: candidate(4), expected: 13 },
     { actual: candidate(5), expected: 89 },
     { actual: candidate(6), expected: 233 },
     { actual: candidate(7), expected: 1597 },
     { actual: candidate(8), expected: 28657 },
     { actual: candidate(9), expected: 514229 },
     { actual: candidate(10), expected: 433494437 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_40,bos_Latn,go_test.go,"package triples_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

//Sum do nule, i pogrešno inače.//vraća vrijednost true ako postoje tri različita elementa na listi koja //triples_sum_to_zero uzima listu cijelih brojeva kao ulaz.// >>> triples_sum_to_zero([]int{1, 3, 5, 0})
// false
// >>> triples_sum_to_zero([]int{1, 3, -2, 1})
// true
// >>> triples_sum_to_zero([]int{1, 2, 3, 7})
// false
// >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})
// true
// >>> triples_sum_to_zero([]int{1})
// false
func triples_sum_to_zero(l []int) bool {
","func triples_sum_to_zero(l []int) bool {
    n := len(l)
    if n < 3 {
        return false
    }
    
    for i := 0; i < n-2; i++ {
        for j := i + 1; j < n-1; j++ {
            for k := j + 1; k < n; k++ {
                if l[i]+l[j]+l[k] == 0 {
                    return true
                }
            }
        }
    }
    
    return false
}

func TestTriplesSumToZero(t *testing.T) {
    tests := []struct {
        input  []int
        output bool
    }{
        {[]int{1, 3, 5, 0}, false},
        {[]int{1, 3, -2, 1}, true},
        {[]int{1, 2, 3, 7}, false},
        {[]int{2, 4, -5, 3, 9, 7}, true},
        {[]int{1}, false},
    }

    for _, test := range tests {
        result := triples_sum_to_zero(test.input)
        if result != test.output {
            t.Errorf(""For input %v, expected %v, got %v"", test.input, test.output, result)
        }
    }
}

func main() {
    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    // false
    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   // true
    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    // false
    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) // true
    fmt.Println(triples_sum_to_zero([]int{1}))              // false
}","func TestTriples_Sum_To_Zero(t *testing.T) {
  candidate := triples_sum_to_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 3, 5, 0}), expected: false },
     { actual: candidate([]int{1, 3, 5, -1}), expected: false },
     { actual: candidate([]int{1, 3, -2, 1}), expected: true },
     { actual: candidate([]int{1, 2, 3, 7}), expected: false },
     { actual: candidate([]int{1, 2, 5, 7}), expected: false },
     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },
     { actual: candidate([]int{1}), expected: false },
     { actual: candidate([]int{1, 3, 5, -100}), expected: false },
     { actual: candidate([]int{100, 3, 5, -100}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_41,bos_Latn,go_test.go,"package car_race_collision_test

import (
    ""testing""
    ""fmt""
)

//Ova funkcija daje broj takvih sudara. //U svojoj putanji kao da se nisu sudarili.//Međutim, kola su beskrajno čvrsta i jaka; kao rezultat toga, oni se nastavljaju kretati.//Kada auto koji se kreće sa leve na desnu udari auto koji se kreće sa desne na lijevu.//Svi automobili se kreću istom brzinom.//Dva para automobila su počela da se kreću veoma daleko od...//n automobila vozi s lijeva na desno; istovremeno, drugačiji skup od n automobila //Zamisli put koji je savršeno ravna beskonačno duga linija.func car_race_collision(n int) int {
","package car_race_collision_test

import (
    ""testing""
)

func car_race_collision(n int) int {
    return n
}

func TestCarRaceCollision(t *testing.T) {
    cases := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 2},
        {3, 3},
        {10, 10},
        {0, 0},
    }

    for _, c := range cases {
        result := car_race_collision(c.n)
        if result != c.expected {
            t.Errorf(""car_race_collision(%d) == %d, expected %d"", c.n, result, c.expected)
        }
    }
}","func TestCar_Race_Collision(t *testing.T) {
  candidate := car_race_collision
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: 4 },
     { actual: candidate(3), expected: 9 },
     { actual: candidate(4), expected: 16 },
     { actual: candidate(8), expected: 64 },
     { actual: candidate(10), expected: 100 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_42,bos_Latn,go_test.go,"package incr_list_test

import (
    ""testing""
    ""fmt""
)

//Lista povratka sa elementima povećanim za 1.// >>> incr_list([]int{1, 2, 3})
// []int{2, 3, 4}
// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}
func incr_list(l []int) []int {
","package incr_list_test

import (
    ""testing""
    ""fmt""
)

// Return list with elements incremented by 1.
// >>> incr_list([]int{1, 2, 3})
// []int{2, 3, 4}
// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}
func incr_list(l []int) []int {
    result := make([]int, len(l))
    for i, val := range l {
        result[i] = val + 1
    }
    return result
}

func TestIncrList(t *testing.T) {
    cases := []struct {
        input    []int
        expected []int
    }{
        {[]int{1, 2, 3}, []int{2, 3, 4}},
        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},
    }

    for _, c := range cases {
        result := incr_list(c.input)
        for i := range result {
            if result[i] != c.expected[i] {
                t.Errorf(""incr_list(%v) == %v, expected %v"", c.input, result, c.expected)
            }
        }
    }
}

func main() {
    fmt.Println(incr_list([]int{1, 2, 3}))          // should print [2, 3, 4]
    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) // should print [6, 4, 6, 3, 4, 4, 10, 1, 124]
}","func TestIncr_List(t *testing.T) {
  candidate := incr_list
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },
     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_43,bos_Latn,go_test.go,"package pairs_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

//Sum do nule, i pogrešno inače.//vraća vrijednost true ako postoje dva različita elementa u listi koja //pairs_sum_to_zero uzima listu cijelih brojeva kao ulaz.// >>> pairs_sum_to_zero([]int{1, 3, 5, 0})
// false
// >>> pairs_sum_to_zero([]int{1, 3, -2, 1})
// false
// >>> pairs_sum_to_zero([]int{1, 2, 3, 7})
// false
// >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})
// true
// >>> pairs_sum_to_zero([]int{1})
// false
func pairs_sum_to_zero(l []int) bool {
","package pairs_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

func pairs_sum_to_zero(l []int) bool {
    numSet := make(map[int]struct{})
    for _, num := range l {
        if _, found := numSet[-num]; found {
            return true
        }
        numSet[num] = struct{}{}
    }
    return false
}

func TestPairsSumToZero(t *testing.T) {
    testCases := []struct {
        input    []int
        expected bool
    }{
        {[]int{1, 3, 5, 0}, false},
        {[]int{1, 3, -2, 1}, false},
        {[]int{1, 2, 3, 7}, false},
        {[]int{2, 4, -5, 3, 5, 7}, true},
        {[]int{1}, false},
    }

    for _, tc := range testCases {
        result := pairs_sum_to_zero(tc.input)
        if result != tc.expected {
            t.Errorf(""pairs_sum_to_zero(%v) = %v; expected %v"", tc.input, result, tc.expected)
        } else {
            fmt.Printf(""Test passed for input: %v, result: %v\n"", tc.input, result)
        }
    }
}","func TestPairs_Sum_To_Zero(t *testing.T) {
  candidate := pairs_sum_to_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 3, 5, 0}), expected: false },
     { actual: candidate([]int{1, 3, -2, 1}), expected: false },
     { actual: candidate([]int{1, 2, 3, 7}), expected: false },
     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },
     { actual: candidate([]int{1}), expected: false },
     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },
     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },
     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },
     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_44,bos_Latn,go_test.go,"package change_base_test

import (
    ""testing""
    ""fmt""
)

//Broj baznih brojeva je manji od 10.//povratni string prikaz nakon konverzije.//Promeni numeričku bazu ulaznog broja x u bazu.// >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
func change_base(x int, base int) string {
","package change_base_test

import (
    ""strconv""
    ""testing""
    ""fmt""
)

func change_base(x int, base int) string {
    if base < 2 || base > 9 {
        return """"
    }

    result := """"
    for x > 0 {
        remainder := x % base
        result = strconv.Itoa(remainder) + result
        x = x / base
    }
    
    if result == """" {
        return ""0""
    }
    return result
}

func TestChangeBase(t *testing.T) {
    tests := []struct {
        x      int
        base   int
        result string
    }{
        {8, 3, ""22""},
        {8, 2, ""1000""},
        {7, 2, ""111""},
        {0, 2, ""0""},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d to base %d"", test.x, test.base), func(t *testing.T) {
            res := change_base(test.x, test.base)
            if res != test.result {
                t.Errorf(""expected %s, got %s"", test.result, res)
            }
        })
    }
}","func TestChange_Base(t *testing.T) {
  candidate := change_base
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(8, 3), expected: ""22"" },
     { actual: candidate(9, 3), expected: ""100"" },
     { actual: candidate(234, 2), expected: ""11101010"" },
     { actual: candidate(16, 2), expected: ""10000"" },
     { actual: candidate(8, 2), expected: ""1000"" },
     { actual: candidate(7, 2), expected: ""111"" },
     { actual: candidate(2, 3), expected: ""2"" },
     { actual: candidate(3, 4), expected: ""3"" },
     { actual: candidate(4, 5), expected: ""4"" },
     { actual: candidate(5, 6), expected: ""5"" },
     { actual: candidate(6, 7), expected: ""6"" },
     { actual: candidate(7, 8), expected: ""7"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_45,bos_Latn,go_test.go,"package triangle_area_test

import (
    ""testing""
    ""fmt""
)

//Dajte mi dužinu strane i visoku površinu povratka za trougao.// >>> triangle_area(5, 3)
// 7.5
func triangle_area(a int, h int) float64 {
","package triangle_area_test

import (
    ""testing""
    ""fmt""
)

// Given length of a side and height return area for a triangle.
// >>> triangle_area(5, 3)
// 7.5
func triangle_area(a int, h int) float64 {
    return 0.5 * float64(a) * float64(h)
}

func TestTriangleArea(t *testing.T) {
    cases := []struct {
        a, h int
        expected float64
    }{
        {5, 3, 7.5},
        {6, 4, 12.0},
        {10, 2, 10.0},
        {8, 5, 20.0},
    }
    
    for _, c := range cases {
        result := triangle_area(c.a, c.h)
        if result != c.expected {
            t.Errorf(""triangle_area(%d, %d) == %f, expected %f"", c.a, c.h, result, c.expected)
        } else {
            fmt.Printf(""triangle_area(%d, %d) == %f\n"", c.a, c.h, result)
        }
    }
}","func TestTriangle_Area(t *testing.T) {
  candidate := triangle_area
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5, 3), expected: 7.5 },
     { actual: candidate(2, 2), expected: 2.0 },
     { actual: candidate(10, 8), expected: 40.0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_46,bos_Latn,go_test.go,"package fib4_test

import (
    ""testing""
    ""fmt""
)

//Molim vas da napišete funkciju koja će efikasno izračunati n-ti element fib4 niza brojeva.//fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).//fib4(3) -> 0 //- Da, da, da, da, da, da, da, da.//fib4(1) -> 0 //fib4 ((0) -> 0 //Fib4 brojni niz je niz sličan Fibbonaccijevom nizu koji je definisan na sledeći način: // >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
func fib4(n int) int {
","func fib4(n int) int {
    if n < 0 {
        return 0
    }
    
    seq := []int{0, 0, 2, 0}
    
    if n < 4 {
        return seq[n]
    }
    
    for i := 4; i <= n; i++ {
        next := seq[0] + seq[1] + seq[2] + seq[3]
        seq[0] = seq[1]
        seq[1] = seq[2]
        seq[2] = seq[3]
        seq[3] = next
    }
    
    return seq[3]
}","func TestFib4(t *testing.T) {
  candidate := fib4
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 4 },
     { actual: candidate(8), expected: 28 },
     { actual: candidate(10), expected: 104 },
     { actual: candidate(12), expected: 386 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_47,bos_Latn,go_test.go,"package median_test

import (
    ""testing""
    ""fmt""
)

//Povratna medijana elemenata na listi l. // >>> median([]int{3, 1, 2, 4, 5})
// 3
// >>> median([]int{-10, 4, 6, 1000, 10, 20})
// 15.0
func median(l []int) float64 {
","package median_test

import (
    ""sort""
)

func median(l []int) float64 {
    sort.Ints(l)
    n := len(l)
    if n%2 == 1 {
        return float64(l[n/2])
    }
    mid1, mid2 := l[(n/2)-1], l[n/2]
    return float64(mid1+mid2) / 2.0
}","func TestMedian(t *testing.T) {
  candidate := median
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },
     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },
     { actual: candidate([]int{5}), expected: 5 },
     { actual: candidate([]int{6, 5}), expected: 5.5 },
     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_48,bos_Latn,go_test.go,"package is_palindrome_test

import (
    ""testing""
    ""fmt""
)

//Provjerava da li je dat niz palindrom.// >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
func is_palindrome(text string) bool {
","package is_palindrome_test

import (
    ""testing""
)

// Checks if given string is a palindrome
func is_palindrome(text string) bool {
    n := len(text)
    for i := 0; i < n/2; i++ {
        if text[i] != text[n-i-1] {
            return false
        }
    }
    return true
}

func TestIsPalindrome(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {"""", true},
        {""aba"", true},
        {""aaaaa"", true},
        {""zbcd"", false},
    }

    for _, test := range tests {
        result := is_palindrome(test.input)
        if result != test.expected {
            t.Errorf(""For input '%s', expected %v, but got %v"", test.input, test.expected, result)
        }
    }
}","func TestIs_Palindrome(t *testing.T) {
  candidate := is_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: true },
     { actual: candidate(""aba""), expected: true },
     { actual: candidate(""aaaaa""), expected: true },
     { actual: candidate(""zbcd""), expected: false },
     { actual: candidate(""xywyx""), expected: true },
     { actual: candidate(""xywyz""), expected: false },
     { actual: candidate(""xywzx""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_49,bos_Latn,go_test.go,"package modp_test

import (
    ""testing""
    ""fmt""
)

//Vrati 2^n modulo p (pametite brojeve).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
func modp(n int, p int) int {
","package modp_test

import (
    ""testing""
    ""fmt""
)

// Return 2^n modulo p (be aware of numerics).
func modp(n int, p int) int {
    if n == 0 {
        return 1
    }
    result := 1
    base := 2
    for n > 0 {
        if n%2 == 1 {
            result = (result * base) % p
        }
        base = (base * base) % p
        n /= 2
    }
    return result
}

func TestModp(t *testing.T) {
    tests := []struct {
        n, p int
        expected int
    }{
        {3, 5, 3},
        {1101, 101, 2},
        {0, 101, 1},
        {3, 11, 8},
        {100, 101, 1},
    }

    for _, test := range tests {
        result := modp(test.n, test.p)
        if result != test.expected {
            t.Errorf(""modp(%d, %d) = %d; expected %d"", test.n, test.p, result, test.expected)
        } else {
            fmt.Printf(""modp(%d, %d) = %d; passed\n"", test.n, test.p, result)
        }
    }
}","func TestModp(t *testing.T) {
  candidate := modp
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 5), expected: 3 },
     { actual: candidate(1101, 101), expected: 2 },
     { actual: candidate(0, 101), expected: 1 },
     { actual: candidate(3, 11), expected: 8 },
     { actual: candidate(100, 101), expected: 1 },
     { actual: candidate(30, 5), expected: 4 },
     { actual: candidate(31, 5), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_51,bos_Latn,go_test.go,"package remove_vowels_test

import (
    ""testing""
    ""fmt""
)

//remove_vowels je funkcija koja uzima niz i vraća niz bez samoglasnika. // >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
func remove_vowels(text string) string {
","package remove_vowels_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func remove_vowels(text string) string {
    vowels := ""aeiouAEIOU""
    var result strings.Builder
    for _, char := range text {
        if !strings.ContainsRune(vowels, char) {
            result.WriteRune(char)
        }
    }
    return result.String()
}

func TestRemoveVowels(t *testing.T) {
    var tests = []struct {
        input    string
        expected string
    }{
        {"""", """"},
        {""abcdef"", ""bcdf""},
        {""aaaaa"", """"},
        {""aaBAA"", ""B""},
        {""zbcd"", ""zbcd""},
    }

    for _, test := range tests {
        if output := remove_vowels(test.input); output != test.expected {
            t.Errorf(""remove_vowels(%q) = %q; expected %q"", test.input, output, test.expected)
        }
    }
}

func main() {
    test := &testing.T{}
    TestRemoveVowels(test)
    if test.Failed() {
        fmt.Println(""Tests failed!"")
    } else {
        fmt.Println(""All tests passed!"")
    }
}","func TestRemove_Vowels(t *testing.T) {
  candidate := remove_vowels
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""abcdef\nghijklm""), expected: ""bcdf\nghjklm"" },
     { actual: candidate(""fedcba""), expected: ""fdcb"" },
     { actual: candidate(""eeeee""), expected: """" },
     { actual: candidate(""acBAA""), expected: ""cB"" },
     { actual: candidate(""EcBOO""), expected: ""cB"" },
     { actual: candidate(""ybcd""), expected: ""ybcd"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_52,bos_Latn,go_test.go,"package below_threshold_test

import (
    ""testing""
    ""fmt""
)

//Vraća vrijednost true ako su svi brojevi na listi l ispod praga t. // >>> below_threshold([]int{1, 2, 4, 10}, 100)
// true
// >>> below_threshold([]int{1, 20, 4, 10}, 5)
// false
func below_threshold(l []int, t int) bool {
","package below_threshold_test

import (
    ""testing""
    ""fmt""
)

// Return true if all numbers in the list l are below threshold t.
func below_threshold(l []int, t int) bool {
    for _, num := range l {
        if num >= t {
            return false
        }
    }
    return true
}

// Example test cases
func TestBelowThreshold(t *testing.T) {
    if !below_threshold([]int{1, 2, 4, 10}, 100) {
        t.Error(""Expected true, got false"")
    }
    if below_threshold([]int{1, 20, 4, 10}, 5) {
        t.Error(""Expected false, got true"")
    }
}

func main() {
    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) // true
    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  // false
}","func TestBelow_Threshold(t *testing.T) {
  candidate := below_threshold
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },
     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },
     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },
     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_53,bos_Latn,go_test.go,"package add_test

import (
    ""testing""
    ""fmt""
)

//Dodaj dva broja x i y.// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
func add(x int, y int) int {
","package add_test

import (
    ""testing""
    ""fmt""
)

// Add two numbers x and y
// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
func add(x int, y int) int {
    return x + y
}

func TestAdd(t *testing.T) {
    testCases := []struct {
        x, y, expected int
    }{
        {2, 3, 5},
        {5, 7, 12},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf(""add(%d,%d)"", tc.x, tc.y), func(t *testing.T) {
            result := add(tc.x, tc.y)
            if result != tc.expected {
                t.Errorf(""Expected %d, got %d"", tc.expected, result)
            }
        })
    }
}","func TestAdd(t *testing.T) {
  candidate := add
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0, 1), expected: 1 },
     { actual: candidate(1, 0), expected: 1 },
     { actual: candidate(2, 3), expected: 5 },
     { actual: candidate(5, 7), expected: 12 },
     { actual: candidate(7, 5), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_54,bos_Latn,go_test.go,"package same_chars_test

import (
    ""testing""
    ""fmt""
)

//Provjeri da li dve reči imaju iste znakove.// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
func same_chars(s0 string, s1 string) bool {
","package same_chars_test

import (
	""testing""
	""fmt""
)

func same_chars(s0 string, s1 string) bool {
	countChars := func(s string) map[rune]int {
		count := make(map[rune]int)
		for _, char := range s {
			count[char]++
		}
		return count
	}

	count0 := countChars(s0)
	count1 := countChars(s1)

	for char := range count0 {
		if count1[char] < count0[char] {
			return false
		}
	}

	for char := range count1 {
		if count0[char] < count1[char] {
			return false
		}
	}

	return true
}

func TestSameChars(t *testing.T) {
	tests := []struct {
		s0     string
		s1     string
		result bool
	}{
		{""eabcdzzzz"", ""dddzzzzzzzddeddabc"", true},
		{""abcd"", ""dddddddabc"", true},
		{""dddddddabc"", ""abcd"", true},
		{""eabcd"", ""dddddddabc"", false},
		{""abcd"", ""dddddddabce"", false},
		{""eabcdzzzz"", ""dddzzzzzzzddddabc"", false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%s vs %s"", test.s0, test.s1), func(t *testing.T) {
			if got := same_chars(test.s0, test.s1); got != test.result {
				t.Errorf(""same_chars(%q, %q) = %v; want %v"", test.s0, test.s1, got, test.result)
			}
		})
	}
}","func TestSame_Chars(t *testing.T) {
  candidate := same_chars
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""), expected: true },
     { actual: candidate(""abcd"", ""dddddddabc""), expected: true },
     { actual: candidate(""dddddddabc"", ""abcd""), expected: true },
     { actual: candidate(""eabcd"", ""dddddddabc""), expected: false },
     { actual: candidate(""abcd"", ""dddddddabcf""), expected: false },
     { actual: candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""), expected: false },
     { actual: candidate(""aabb"", ""aaccc""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_55,bos_Latn,go_test.go,"package fib_test

import (
    ""testing""
    ""fmt""
)

//Vrati n-ti Fibonačijev broj. // >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
func fib(n int) int {
","if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}","func TestFib(t *testing.T) {
  candidate := fib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(10), expected: 55 },
     { actual: candidate(1), expected: 1 },
     { actual: candidate(8), expected: 21 },
     { actual: candidate(11), expected: 89 },
     { actual: candidate(12), expected: 144 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_56,bos_Latn,go_test.go,"package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

//return true ako svaka otvorena zagrada ima odgovarajuću zatvaranju zagrada. //brackets je niz ""<"" i "">"". // >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
func correct_bracketing(brackets string) bool {
","package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

func correct_bracketing(brackets string) bool {
    balance := 0
    for _, char := range brackets {
        if char == '<' {
            balance++
        } else if char == '>' {
            balance--
            if balance < 0 {
                return false
            }
        }
    }
    return balance == 0
}

func TestCorrectBracketing(t *testing.T) {
    testCases := []struct {
        input    string
        expected bool
    }{
        {input: ""<"", expected: false},
        {input: ""<>"", expected: true},
        {input: ""<<><>>"", expected: true},
        {input: ""><<>"", expected: false},
        {input: ""<<>>"", expected: true},
        {input: ""><"", expected: false},
    }

    for _, tc := range testCases {
        result := correct_bracketing(tc.input)
        if result != tc.expected {
            t.Errorf(""correct_bracketing(%q) = %v; expected %v"", tc.input, result, tc.expected)
        } else {
            fmt.Printf(""Test passed for input: %q\n"", tc.input)
        }
    }
}","func TestCorrect_Bracketing(t *testing.T) {
  candidate := correct_bracketing
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""<>""), expected: true },
     { actual: candidate(""<<><>>""), expected: true },
     { actual: candidate(""<><><<><>><>""), expected: true },
     { actual: candidate(""<><><<<><><>><>><<><><<>>>""), expected: true },
     { actual: candidate(""<<<><>>>>""), expected: false },
     { actual: candidate(""><<>""), expected: false },
     { actual: candidate(""<""), expected: false },
     { actual: candidate(""<<<<""), expected: false },
     { actual: candidate("">""), expected: false },
     { actual: candidate(""<<>""), expected: false },
     { actual: candidate(""<><><<><>><>><<>""), expected: false },
     { actual: candidate(""<><><<><>><>>><>""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_57,bos_Latn,go_test.go,"package monotonic_test

import (
    ""testing""
    ""fmt""
)

//Vraća vrijednost true ako su elementi liste monotonski povećavani ili smanjivani.// >>> monotonic([]int{1, 2, 4, 20})
// true
// >>> monotonic([]int{1, 20, 4, 10})
// false
// >>> monotonic([]int{4, 1, 0, -10})
// true
func monotonic(l []int) bool {
","package monotonic_test

import (
    ""testing""
    ""fmt""
)

// Return true if list elements are monotonically increasing or decreasing.
func monotonic(l []int) bool {
    if len(l) < 2 {
        return true
    }
    increasing := true
    decreasing := true

    for i := 1; i < len(l); i++ {
        if l[i] > l[i-1] {
            decreasing = false
        }
        if l[i] < l[i-1] {
            increasing = false
        }
    }

    return increasing || decreasing
}

func TestMonotonic(t *testing.T) {
    fmt.Println(monotonic([]int{1, 2, 4, 20})) // true
    fmt.Println(monotonic([]int{1, 20, 4, 10})) // false
    fmt.Println(monotonic([]int{4, 1, 0, -10})) // true
}","func TestMonotonic(t *testing.T) {
  candidate := monotonic
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 10}), expected: true },
     { actual: candidate([]int{1, 2, 4, 20}), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}), expected: false },
     { actual: candidate([]int{4, 1, 0, -10}), expected: true },
     { actual: candidate([]int{4, 1, 1, 0}), expected: true },
     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },
     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },
     { actual: candidate([]int{9, 9, 9, 9}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_58,bos_Latn,go_test.go,"package common_test

import (
    ""testing""
    ""fmt""
)

//Vraća sortirane jedinstvene zajedničke elemente za dvije liste.// >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})
// []int{1, 5, 653}
// >>> common([]int{5, 3, 2, 8}, []int{3, 2})
// []int{2, 3}
func common(l1 []int, l2 []int) []int {
","package common_test

import (
    ""testing""
    ""fmt""
    ""sort""
)

func common(l1 []int, l2 []int) []int {
    set1 := make(map[int]struct{})
    set2 := make(map[int]struct{})
    commonSet := make(map[int]struct{})
    
    // Fill set1 with elements of l1
    for _, num := range l1 {
        set1[num] = struct{}{}
    }
    
    // Fill set2 with elements of l2
    for _, num := range l2 {
        if _, found := set1[num]; found {
            commonSet[num] = struct{}{}
        }
        set2[num] = struct{}{}
    }
    
    result := make([]int, 0, len(commonSet))
    
    // Collect common elements
    for num := range commonSet {
        result = append(result, num)
    }
    
    // Sort the result
    sort.Ints(result)
    
    return result
}

func TestCommon(t *testing.T) {
    cases := []struct {
        l1, l2 []int
        expected []int
    }{
        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},
        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},
    }
    
    for _, c := range cases {
        result := common(c.l1, c.l2)
        if !equal(result, c.expected) {
            t.Errorf(""common(%v, %v) == %v, expected %v"", c.l1, c.l2, result, c.expected)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestCommon(t *testing.T) {
  candidate := common
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },
     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },
     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },
     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_59,bos_Latn,go_test.go,"package largest_prime_factor_test

import (
    ""testing""
    ""fmt""
)

//Vrati najveći primarni faktor od n. Pretpostavimo da je n > 1 i nije primarno. // >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
func largest_prime_factor(n int) int {
","package largest_prime_factor_test

import (
	""testing""
	""fmt""
)

func largest_prime_factor(n int) int {
	largestFactor := 1
	div := 2

	for n > 1 {
		if n%div == 0 {
			largestFactor = div
			n /= div
		} else {
			div++
		}
	}

	return largestFactor
}

func TestLargestPrimeFactor(t *testing.T) {
	tests := []struct{
		n int
		expected int
	} {
		{13195, 29},
		{2048, 2},
		{123456, 643},
		{100, 5},
		{999, 37},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""n=%d"", test.n), func(t *testing.T) {
			if result := largest_prime_factor(test.n); result != test.expected {
				t.Errorf(""largest_prime_factor(%d) = %d; expected %d"", test.n, result, test.expected)
			}
		})
	}
}","func TestLargest_Prime_Factor(t *testing.T) {
  candidate := largest_prime_factor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(15), expected: 5 },
     { actual: candidate(27), expected: 3 },
     { actual: candidate(63), expected: 7 },
     { actual: candidate(330), expected: 11 },
     { actual: candidate(13195), expected: 29 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_60,bos_Latn,go_test.go,"package sum_to_n_test

import (
    ""testing""
    ""fmt""
)

//sum_to_n je funkcija koja zbira brojeve od 1 do n. // >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
func sum_to_n(n int) int {
","func sum_to_n(n int) int {
    return n * (n + 1) / 2
}

func TestSumToN(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {30, 465},
        {100, 5050},
        {5, 15},
        {10, 55},
        {1, 1},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""sum_to_n(%d)"", test.input), func(t *testing.T) {
            result := sum_to_n(test.input)
            if result != test.expected {
                t.Errorf(""Expected %d, got %d"", test.expected, result)
            }
        })
    }
}","func TestSum_To_N(t *testing.T) {
  candidate := sum_to_n
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 1 },
     { actual: candidate(6), expected: 21 },
     { actual: candidate(11), expected: 66 },
     { actual: candidate(30), expected: 465 },
     { actual: candidate(100), expected: 5050 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_61,bos_Latn,go_test.go,"package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

//return true ako svaka otvorena zagrada ima odgovarajuću zatvaranju zagrada. //brackets je niz ""("" i "")"". // >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
func correct_bracketing(brackets string) bool {
","package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

func correct_bracketing(brackets string) bool {
    balance := 0
    for _, char := range brackets {
        if char == '(' {
            balance++
        } else if char == ')' {
            balance--
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}

func TestCorrectBracketing(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {""("", false},
        {""()"", true},
        {""(()())"", true},
        {"")(()"", false},
        {"""", true},
        {""((()))"", true},
        {""(()"", false},
        {""())"", false},
    }

    for _, tt := range tests {
        result := correct_bracketing(tt.input)
        if result != tt.expected {
            t.Errorf(""correct_bracketing(%q) = %v; want %v"", tt.input, result, tt.expected)
        } else {
            fmt.Printf(""correct_bracketing(%q) = %v\n"", tt.input, result)
        }
    }
}","func TestCorrect_Bracketing(t *testing.T) {
  candidate := correct_bracketing
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""()""), expected: true },
     { actual: candidate(""(()())""), expected: true },
     { actual: candidate(""()()(()())()""), expected: true },
     { actual: candidate(""()()((()()())())(()()(()))""), expected: true },
     { actual: candidate(""((()())))""), expected: false },
     { actual: candidate("")(()""), expected: false },
     { actual: candidate(""(""), expected: false },
     { actual: candidate(""((((""), expected: false },
     { actual: candidate("")""), expected: false },
     { actual: candidate(""(()""), expected: false },
     { actual: candidate(""()()(()())())(()""), expected: false },
     { actual: candidate(""()()(()())()))()""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_62,bos_Latn,go_test.go,"package derivative_test

import (
    ""testing""
    ""fmt""
)

//Vrati derivatu ovog polinoma u istom obliku.//xs[0] + xs[1] * x + xs[2] * x^2 + .... //xs predstavlja koeficijent polinoma.// >>> derivative([]int{3, 1, 2, 4, 5})
// []int{1, 4, 12, 20}
// >>> derivative([]int{1, 2, 3})
// []int{2, 6}
func derivative(xs []int) []int {
","package derivative_test

import (
    ""testing""
    ""fmt""
)

// xs represent coefficients of a polynomial.
// xs[0] + xs[1] * x + xs[2] * x^2 + ....
// Return derivative of this polynomial in the same form.
func derivative(xs []int) []int {
    if len(xs) <= 1 {
        return []int{}
    }
    
    derived := make([]int, len(xs)-1)
    for i := 1; i < len(xs); i++ {
        derived[i-1] = xs[i] * i
    }
    return derived
}

func TestDerivative(t *testing.T) {
    testCases := []struct{
        input []int
        expected []int
    }{
        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},
        {[]int{1, 2, 3}, []int{2, 6}},
        {[]int{1}, []int{}},
        {[]int{}, []int{}},
    }

    for _, testCase := range testCases {
        result := derivative(testCase.input)
        if !equal(result, testCase.expected) {
            t.Errorf(""For input %v, expected %v, but got %v"", 
                     testCase.input, testCase.expected, result)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestDerivative(t *testing.T) {
  candidate := derivative
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },
     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },
     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },
     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },
     { actual: candidate([]int{1}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_63,bos_Latn,go_test.go,"package fibfib_test

import (
    ""testing""
    ""fmt""
)

//Molim vas da napišete funkciju koja će efikasno izračunati n-ti element niza brojeva fibfib. //fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3). //- Da, da, da.//Fibfib ((1)) == 0 //Fibfib ((0) == 0 //FibFib brojni niz je niz sličan Fibbonaccijevom nizu koji je definisan na sledeći način: // >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
func fibfib(n int) int {
","func fibfib(n int) int {
    if n == 0 || n == 1 {
        return 0
    } else if n == 2 {
        return 1
    }

    a, b, c := 0, 0, 1
    for i := 3; i <= n; i++ {
        next := a + b + c
        a = b
        b = c
        c = next
    }
    return c
}","func TestFibfib(t *testing.T) {
  candidate := fibfib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: 1 },
     { actual: candidate(1), expected: 0 },
     { actual: candidate(5), expected: 4 },
     { actual: candidate(8), expected: 24 },
     { actual: candidate(10), expected: 81 },
     { actual: candidate(12), expected: 274 },
     { actual: candidate(14), expected: 927 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_64,bos_Latn,go_test.go,"package vowels_count_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //samoglasnik, ali samo kada je na kraju date riječi.//Samoglasnici u ovom slučaju su ""a"", ""e"", ""i"", ""o"", ""u"".//riječ kao ulaz i vraća broj samoglasnika u nizu. //Napišite funkciju vowels_count koja uzima niz koji predstavlja // >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
func vowels_count(s string) int {
","package vowels_count_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func vowels_count(s string) int {
    count := 0
    s = strings.ToLower(s)
    vowels := ""aeiou""
    for i, char := range s {
        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {
            count++
        }
    }
    return count
}

func TestVowelsCount(t *testing.T) {
    tests := []struct {
        input  string
        output int
    }{
        {""abcde"", 2},
        {""ACEDY"", 3},
        {""xyz"", 1},
        {""plenty"", 1},
        {""queue"", 3},
    }

    for _, test := range tests {
        result := vowels_count(test.input)
        if result != test.output {
            t.Errorf(""Expected %d, but got %d for input %s"", test.output, result, test.input)
        } else {
            fmt.Printf(""Success: got %d for input %s\n"", result, test.input)
        }
    }
}","func TestVowels_Count(t *testing.T) {
  candidate := vowels_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""abcde""), expected: 2 },
     { actual: candidate(""Alone""), expected: 3 },
     { actual: candidate(""key""), expected: 2 },
     { actual: candidate(""bye""), expected: 1 },
     { actual: candidate(""keY""), expected: 2 },
     { actual: candidate(""bYe""), expected: 1 },
     { actual: candidate(""ACEDY""), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_65,bos_Latn,go_test.go,"package circular_shift_test

import (
    ""testing""
    ""fmt""
)

//Ako je shift > broj cifara, vratite cifre obrnute. //i vrati rezultat kao niz. //Okruglo pomerite cifre celog broja x, pomerite cifre desno pomeranjem.// >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
func circular_shift(x int, shift int) string {
","package circular_shift_test

import (
    ""strconv""
)

func circular_shift(x int, shift int) string {
    strX := strconv.Itoa(x)
    numDigits := len(strX)

    if shift > numDigits {
        // Reverse the digits if shift is greater than the number of digits
        reversed := make([]byte, numDigits)
        for i := 0; i < numDigits; i++ {
            reversed[i] = strX[numDigits-i-1]
        }
        return string(reversed)
    } else {
        // Perform a circular shift
        shift = shift % numDigits
        return strX[numDigits-shift:] + strX[:numDigits-shift]
    }
}","func TestCircular_Shift(t *testing.T) {
  candidate := circular_shift
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(100, 2), expected: ""001"" },
     { actual: candidate(12, 2), expected: ""12"" },
     { actual: candidate(97, 8), expected: ""79"" },
     { actual: candidate(12, 1), expected: ""21"" },
     { actual: candidate(11, 101), expected: ""11"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_66,bos_Latn,go_test.go,"package digitSum_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //ASCII kodovi.//Napišite funkciju koja uzima niz kao ulaz i vraća samo sumu gornjih znakova.//Zadatak // >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
func digitSum(s string) int {
","func digitSum(s string) int {
    sum := 0
    for _, char := range s {
        if char >= 'A' && char <= 'Z' {
            sum += int(char)
        }
    }
    return sum
}","func TestDigitsum(t *testing.T) {
  candidate := digitSum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""abAB""), expected: 131 },
     { actual: candidate(""abcCd""), expected: 67 },
     { actual: candidate(""helloE""), expected: 69 },
     { actual: candidate(""woArBld""), expected: 131 },
     { actual: candidate(""aAaaaXa""), expected: 153 },
     { actual: candidate("" How are yOu?""), expected: 151 },
     { actual: candidate(""You arE Very Smart""), expected: 327 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_67,bos_Latn,go_test.go,"package fruit_distribution_test

import (
    ""testing""
    ""fmt""
)

//Za eksabl: //u korpu vrati broj plodova mango u korpu. //Pomorandže i jabuke i cijeli broj koji predstavlja ukupan broj voća //Jabuka, pomorandže i mango, uz niz koji predstavlja ukupan broj //koji su raspoređeni u košari s voćem koju sadrži ova košara.//U ovom zadatku, dobićete niz koji predstavlja broj jabuka i naranča.// >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
func fruit_distribution(s string, n int) int {
","package fruit_distribution_test

import (
    ""fmt""
    ""regexp""
    ""strconv""
    ""testing""
)

func fruit_distribution(s string, n int) int {
    re := regexp.MustCompile(`(\d+) apples and (\d+) oranges`)
    matches := re.FindStringSubmatch(s)
    
    if len(matches) != 3 {
        return -1 // Could return an error or a sentinel value if input format is incorrect
    }

    apples, _ := strconv.Atoi(matches[1])
    oranges, _ := strconv.Atoi(matches[2])

    mangoes := n - (apples + oranges)
    return mangoes
}

func TestFruitDistribution(t *testing.T) {
    var tests = []struct {
        description string
        inputString string
        totalFruits int
        expected    int
    }{
        {""Test case 1"", ""5 apples and 6 oranges"", 19, 8},
        {""Test case 2"", ""0 apples and 1 oranges"", 3, 2},
        {""Test case 3"", ""2 apples and 3 oranges"", 100, 95},
        {""Test case 4"", ""100 apples and 1 oranges"", 120, 19},
    }

    for _, tt := range tests {
        t.Run(tt.description, func(t *testing.T) {
            result := fruit_distribution(tt.inputString, tt.totalFruits)
            if result != tt.expected {
                t.Errorf(""got %d, want %d"", result, tt.expected)
            }
        })
    }
}

func main() {
    fmt.Println(fruit_distribution(""5 apples and 6 oranges"", 19)) // 8
    fmt.Println(fruit_distribution(""0 apples and 1 oranges"", 3))  // 2
    fmt.Println(fruit_distribution(""2 apples and 3 oranges"", 100)) // 95
    fmt.Println(fruit_distribution(""100 apples and 1 oranges"", 120)) // 19
}","func TestFruit_Distribution(t *testing.T) {
  candidate := fruit_distribution
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""5 apples and 6 oranges"", 19), expected: 8 },
     { actual: candidate(""5 apples and 6 oranges"", 21), expected: 10 },
     { actual: candidate(""0 apples and 1 oranges"", 3), expected: 2 },
     { actual: candidate(""1 apples and 0 oranges"", 3), expected: 2 },
     { actual: candidate(""2 apples and 3 oranges"", 100), expected: 95 },
     { actual: candidate(""2 apples and 3 oranges"", 5), expected: 0 },
     { actual: candidate(""1 apples and 100 oranges"", 120), expected: 19 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_68,bos_Latn,go_test.go,"package pluck_test

import (
    ""testing""
    ""fmt""
)

//Primjer 1: //Ako nema parnih vrednosti ili je navedena lista prazna, vratite [].//Oduzeći čvor treba vratiti u listi, [ smalest_value, njegov indeks ], //Ako se nađe više čvorova sa istom najmanjom parnom vrijednošću, vrati čvor koji ima najmanji indeks. //Određeni čvor treba da bude čvor sa najmanjom parnom vrijednošću.//Vaš zadatak je da odvojite jedan od čvorova i vratite ga.//""Dano je popis koji predstavlja grana stabla koja ima ne-negativne čitav broj čvorova // >>> pluck([]int{4, 2, 3})
// []int{2, 1}
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([]int{1, 2, 3})
// []int{2, 1}
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([]int{})
// []int{}
// Example 4:
// >>> pluck([]int{5, 0, 3, 0, 4, 2})
// []int{0, 1}
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
func pluck(arr []int) []int {
","package pluck_test

import (
	""testing""
)

// pluck function that implements the solution as described in the problem
func pluck(arr []int) []int {
	if len(arr) == 0 {
		return []int{}
	}

	smallestEvenValue := -1
	index := -1

	for i, val := range arr {
		if val%2 == 0 {
			if smallestEvenValue == -1 || val < smallestEvenValue {
				smallestEvenValue = val
				index = i
			}
		}
	}

	if index == -1 {
		return []int{}
	}

	return []int{smallestEvenValue, index}
}

// Example unit tests can be implemented by using the testing package
func TestPluck(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{[]int{4, 2, 3}, []int{2, 1}},
		{[]int{1, 2, 3}, []int{2, 1}},
		{[]int{}, []int{}},
		{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},
	}

	for _, test := range tests {
		result := pluck(test.input)
		if len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {
			t.Errorf(""pluck(%v) = %v; expected %v"", test.input, result, test.expected)
		}
	}
}","func TestPluck(t *testing.T) {
  candidate := pluck
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },
     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },
     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },
     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },
     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },
     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_69,bos_Latn,go_test.go,"package search_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Ako takva vrijednost ne postoji, vrati se -1.//Frekvencija celog broja je broj puta kada se pojavljuje na listi.//nula, i ima učestalost veću ili jednaku vrijednosti samog broja. //Dobiješ neprazan popis pozitivnih cijelih brojeva.// >>> search([]int{4, 1, 2, 2, 3, 1})
// 2
// >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})
// 3
// >>> search([]int{5, 5, 4, 4, 4})
// -1
func search(lst []int) int {
","package search_test

import ""sort""

func search(lst []int) int {
	frequency := make(map[int]int)

	for _, num := range lst {
		frequency[num]++
	}

	candidates := []int{}
	for num, count := range frequency {
		if count >= num {
			candidates = append(candidates, num)
		}
	}

	if len(candidates) == 0 {
		return -1
	}

	sort.Ints(candidates)
	return candidates[len(candidates)-1]
}","func TestSearch(t *testing.T) {
  candidate := search
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },
     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },
     { actual: candidate([]int{3, 3}), expected: -1 },
     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },
     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },
     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },
     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },
     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },
     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },
     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },
     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },
     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },
     { actual: candidate([]int{1}), expected: 1 },
     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },
     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },
     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },
     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },
     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },
     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },
     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },
     { actual: candidate([]int{10}), expected: -1 },
     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },
     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },
     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },
     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_70,bos_Latn,go_test.go,"package strange_sort_list_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //onda maksimalni od preostalih cijelih brojeva, onda minimalni i tako dalje.//Čudno je sortiranje, kada počinjete sa minimalnom vrijednošću, //Ako dobijem listu cijelih brojeva, vraćam listu u neobičnom redoslijedu.// >>> strange_sort_list([]int{1, 2, 3, 4})
// []int{1, 4, 2, 3}
// >>> strange_sort_list([]int{5, 5, 5, 5})
// []int{5, 5, 5, 5}
// >>> strange_sort_list([]int{})
// []int{}
func strange_sort_list(lst []int) []int {
","package strange_sort_list_test

import (
	""testing""
	""fmt""
	""sort""
)

func strange_sort_list(lst []int) []int {
	if len(lst) == 0 {
		return lst
	}
	
	sort.Ints(lst)
	res := make([]int, len(lst))
	left, right := 0, len(lst)-1
	i := 0

	for left <= right {
		if i%2 == 0 {
			res[i] = lst[left]
			left++
		} else {
			res[i] = lst[right]
			right--
		}
		i++
	}

	return res
}

func TestStrangeSortList(t *testing.T) {
	tests := []struct {
		input  []int
		output []int
	}{
		{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},
		{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},
		{[]int{}, []int{}},
		{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},
	}
	for _, test := range tests {
		if res := strange_sort_list(test.input); !equal(res, test.output) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.output, res)
		}
	}
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func main() {
	fmt.Println(strange_sort_list([]int{1, 2, 3, 4})) // Should print [1 4 2 3]
}","func TestStrange_Sort_List(t *testing.T) {
  candidate := strange_sort_list
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },
     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },
     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },
     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },
     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },
     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },
     { actual: candidate([]int{111111}), expected: []int{111111} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_71,bos_Latn,go_test.go,"package triangle_area_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //nego treća strana.//Tri strane čine trijuga ako je zbir bilo koje dvije strane veći.//U suprotnom, vrati -1 //Trokut zaokružen na 2 decimalna broja ako tri strane čine valjan trokut. //S obzirom na dužine tri strane trougla, vratimo površinu // >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
func triangle_area(a int, b int, c int) float64 {
","package triangle_area_test

import (
    ""math""
)

func triangle_area(a int, b int, c int) float64 {
    // Check for the validity of the triangle
    if a+b <= c || a+c <= b || b+c <= a {
        return -1
    }
    // Calculate the semi-perimeter
    s := float64(a+b+c) / 2
    // Calculate the area using Heron's formula
    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))
    // Round the result to 2 decimal places
    return math.Round(area*100) / 100.0
}","func TestTriangle_Area(t *testing.T) {
  candidate := triangle_area
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 4, 5), expected: 6.0 },
     { actual: candidate(1, 2, 10), expected: -1 },
     { actual: candidate(4, 8, 5), expected: 8.18 },
     { actual: candidate(2, 2, 2), expected: 1.73 },
     { actual: candidate(1, 2, 3), expected: -1 },
     { actual: candidate(10, 5, 7), expected: 16.25 },
     { actual: candidate(2, 6, 3), expected: -1 },
     { actual: candidate(1, 1, 1), expected: 0.43 },
     { actual: candidate(2, 2, 10), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_72,bos_Latn,go_test.go,"package will_it_fly_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Objekt q će letjeti ako je uravnotežen (to je palindromska lista) i suma njegovih elemenata je manja od ili jednaka najvećoj mogućoj težini w.//Napišite funkciju koja vraća istinitu ako će objekt q letjeti, a pogrešnu u suprotnom. // >>> will_it_fly([]int{1, 2}, 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([]int{3, 2, 3}, 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([]int{3, 2, 3}, 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([]int{3}, 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q []int, w int) bool {
","func will_it_fly(q []int, w int) bool {
    sum := 0
    n := len(q)

    // Calculate the sum of the elements in q
    for _, value := range q {
        sum += value
    }

    // Check if sum is greater than the maximum possible weight
    if sum > w {
        return false
    }

    // Check if the list is a palindrome
    for i := 0; i < n/2; i++ {
        if q[i] != q[n-i-1] {
            return false
        }
    }

    // If the list is balanced and sum is less than or equal to w
    return true
}","func TestWill_It_Fly(t *testing.T) {
  candidate := will_it_fly
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 2, 3}, 9), expected: true },
     { actual: candidate([]int{1, 2}, 5), expected: false },
     { actual: candidate([]int{3}, 5), expected: true },
     { actual: candidate([]int{3, 2, 3}, 1), expected: false },
     { actual: candidate([]int{1, 2, 3}, 6), expected: false },
     { actual: candidate([]int{5}, 5), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_73,bos_Latn,go_test.go,"package smallest_change_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //U jednoj promjeni, možete da promenite jedan element u bilo koji drugi element.//palidromna lista je lista koja //Ako imamo listu cijelih brojeva, nađimo minimalni broj elemenata koji // >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})
// 4
// >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})
// 1
// >>> smallest_change([]int{1, 2, 3, 2, 1})
// 0
func smallest_change(arr []int) int {
","package smallest_change_test

import (
    ""testing""
    ""fmt""
)

func smallest_change(arr []int) int {
    n := len(arr)
    changes := 0
    for i := 0; i < n/2; i++ {
        if arr[i] != arr[n-i-1] {
            changes++
        }
    }
    return changes
}

func TestSmallestChange(t *testing.T) {
    tests := []struct{
        input []int
        expected int
    }{
        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},
        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},
        {[]int{1, 2, 3, 2, 1}, 0},
    }

    for _, test := range tests {
        result := smallest_change(test.input)
        if result != test.expected {
            t.Errorf(""For input %v, expected %d but got %d"", test.input, test.expected, result)
        } else {
            fmt.Printf(""Test passed for input %v\n"", test.input)
        }
    }
}","func TestSmallest_Change(t *testing.T) {
  candidate := smallest_change
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },
     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },
     { actual: candidate([]int{1, 4, 2}), expected: 1 },
     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },
     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },
     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },
     { actual: candidate([]int{1}), expected: 0 },
     { actual: candidate([]int{0, 1}), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_74,bos_Latn,go_test.go,"package total_match_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //ako su dvije liste iste po broju znakova, vrati prvu listu. //Ukupan broj znakova u svim nizovima liste manje od druge liste.//Napišite funkciju koja prihvata dvije liste niza i vraća listu koja ima // >>> total_match([]string{}, []string{})
// []string{}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hI"", ""Hi""})
// []string{""hI"", ""Hi""}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""})
// []string{""hi"", ""admin""}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""})
// []string{""hI"", ""hi"", ""hi""}
// >>> total_match([]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""})
// []string{""4""}
func total_match(lst1 []string, lst2 []string) []string {
","package total_match_test

import (
    ""testing""
    ""fmt""
)

// total_match function returns the list with the smaller total character count.
// If both lists have the same character count, it returns the first list.
func total_match(lst1 []string, lst2 []string) []string {
    sumChars := func(lst []string) int {
        total := 0
        for _, str := range lst {
            total += len(str)
        }
        return total
    }
    
    sum1 := sumChars(lst1)
    sum2 := sumChars(lst2)

    if sum1 <= sum2 {
        return lst1
    } else {
        return lst2
    }
}

// Test functions can go below to verify the behavior of total_match.
func TestTotalMatch(t *testing.T) {
    cases := []struct {
        lst1      []string
        lst2      []string
        expected  []string
    }{
        {[]string{}, []string{}, []string{}},
        {[]string{""hi"", ""admin""}, []string{""hI"", ""Hi""}, []string{""hI"", ""Hi""}},
        {[]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""}, []string{""hi"", ""admin""}},
        {[]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""}, []string{""hI"", ""hi"", ""hi""}},
        {[]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""}, []string{""4""}},
    }

    for _, c := range cases {
        result := total_match(c.lst1, c.lst2)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", c.expected) {
            t.Errorf(""total_match(%v, %v) == %v, expected %v"", c.lst1, c.lst2, result, c.expected)
        }
    }
}","func TestTotal_Match(t *testing.T) {
  candidate := total_match
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, []string{}), expected: []string{} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hi"", ""hi""}), expected: []string{""hi"", ""hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""}), expected: []string{""hi"", ""admin""} },
     { actual: candidate([]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""}), expected: []string{""4""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""Hi""}), expected: []string{""hI"", ""Hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""}), expected: []string{""hI"", ""hi"", ""hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hii""}), expected: []string{""hi"", ""admin""} },
     { actual: candidate([]string{}, []string{""this""}), expected: []string{} },
     { actual: candidate([]string{""this""}, []string{}), expected: []string{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_75,bos_Latn,go_test.go,"package is_multiply_prime_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Znajući da je (a) manje od 100.//i pogrešno u suprotnom.//Napišite funkciju koja vraća vrijednost istinita ako je dat broj množenje 3 prostih broja // >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
func is_multiply_prime(a int) bool {
","func is_multiply_prime(a int) bool {
	if a < 2 {
		return false
	}

	primeNumbers := generatePrimesUpTo(100)
	
	for i := 0; i < len(primeNumbers); i++ {
		for j := i; j < len(primeNumbers); j++ {
			for k := j; k < len(primeNumbers); k++ {
				if primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {
					return true
				}
			}
		}
	}
	return false
}

func generatePrimesUpTo(max int) []int {
	isPrime := make([]bool, max+1)
	for i := 2; i <= max; i++ {
		isPrime[i] = true
	}
	for i := 2; i*i <= max; i++ {
		if isPrime[i] {
			for j := i * i; j <= max; j += i {
				isPrime[j] = false
			}
		}
	}
	var primes []int
	for i := 2; i <= max; i++ {
		if isPrime[i] {
			primes = append(primes, i)
		}
	}
	return primes
}","func TestIs_Multiply_Prime(t *testing.T) {
  candidate := is_multiply_prime
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: false },
     { actual: candidate(30), expected: true },
     { actual: candidate(8), expected: true },
     { actual: candidate(10), expected: false },
     { actual: candidate(125), expected: true },
     { actual: candidate(105), expected: true },
     { actual: candidate(126), expected: false },
     { actual: candidate(729), expected: false },
     { actual: candidate(891), expected: false },
     { actual: candidate(1001), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_76,bos_Latn,go_test.go,"package is_simple_power_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //x je jednostavan moć od n ako je n**int=x //moć n i false u ostalim slučajevima. //Vaš zadatak je da napišete funkciju koja vraća vrijednost true ako je broj x jednostavan // >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
func is_simple_power(x int, n int) bool {
","package is_simple_power_test

import (
    ""testing""
    ""fmt""
)

func is_simple_power(x int, n int) bool {
    if n <= 1 {
        return x == 1
    }
    
    current := n
    for current <= x {
        if current == x {
            return true
        }
        current *= n
    }
    return false
}

func TestIsSimplePower(t *testing.T) {
    tests := []struct {
        x, n     int
        expected bool
    }{
        {1, 4, true},
        {2, 2, true},
        {8, 2, true},
        {3, 2, false},
        {3, 1, false},
        {5, 3, false},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d,%d"", test.x, test.n), func(t *testing.T) {
            result := is_simple_power(test.x, test.n)
            if result != test.expected {
                t.Errorf(""Expected %v, but got %v"", test.expected, result)
            }
        })
    }
}","func TestIs_Simple_Power(t *testing.T) {
  candidate := is_simple_power
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(16, 2), expected: true },
     { actual: candidate(143214, 16), expected: false },
     { actual: candidate(4, 2), expected: true },
     { actual: candidate(9, 3), expected: true },
     { actual: candidate(16, 4), expected: true },
     { actual: candidate(24, 2), expected: false },
     { actual: candidate(128, 4), expected: false },
     { actual: candidate(12, 6), expected: false },
     { actual: candidate(1, 1), expected: true },
     { actual: candidate(1, 12), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_77,bos_Latn,go_test.go,"package iscube_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Napomena: možete pretpostaviti da je ulaz uvijek važeći.//Ako je ovaj ingeger kub nekog celog broja.//Napiši funkciju koja uzima cijeli broj a i vraća vrednost true // >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
func iscube(a int) bool {
","package iscube_test

import (
	""testing""
	""math""
)

func iscube(a int) bool {
	if a < 0 {
		a = -a
	}
	cubeRoot := math.Cbrt(float64(a))
	return cubeRoot == float64(int(cubeRoot))
}

func TestIsCube(t *testing.T) {
	tests := []struct {
		input    int
		expected bool
	}{
		{1, true},
		{2, false},
		{-1, true},
		{64, true},
		{0, true},
		{180, false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""iscube(%d)"", test.input), func(t *testing.T) {
			result := iscube(test.input)
			if result != test.expected {
				t.Errorf(""expected %v, got %v"", test.expected, result)
			}
		})
	}
}","func TestIscube(t *testing.T) {
  candidate := iscube
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: true },
     { actual: candidate(2), expected: false },
     { actual: candidate(-1), expected: true },
     { actual: candidate(64), expected: true },
     { actual: candidate(180), expected: false },
     { actual: candidate(1000), expected: true },
     { actual: candidate(0), expected: true },
     { actual: candidate(1729), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_78,bos_Latn,go_test.go,"package hex_key_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //i simboli A,B,C,D,E,F su uvijek veliki.//Napomena: možete pretpostaviti da je ulaz uvijek tačan ili prazan niz, //B (= decimalna 11), D (= decimalna 13). //Dakle, morate odrediti broj sledećih cifara: 2, 3, 5, 7, //Primarni brojevi su 2, 3, 5, 7, 11, 13, 17,...//Hexadecimalne cifre su 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.//veći od 1 koji nije proizvod dva manja prirodnih broja).//Brojke koje su primne (primi broj, ili prvenstveni broj, je prirodni broj)//Šesnaestomjesečni broj kao niz i broji broj šesnaestomjesečnih //Dobio si zadatak da napišeš funkciju koja prima // >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
func hex_key(num string) int {
","func hex_key(num string) int {
    primeDigits := map[rune]struct{}{
        '2': {},
        '3': {},
        '5': {},
        '7': {},
        'B': {},
        'D': {},
    }

    count := 0
    for _, digit := range num {
        if _, found := primeDigits[digit]; found {
            count++
        }
    }
    return count
}

func TestHexKey(t *testing.T) {
    tests := []struct {
        input    string
        expected int
    }{
        {""AB"", 1},
        {""1077E"", 2},
        {""ABED1A33"", 4},
        {""123456789ABCDEF0"", 6},
        {""2020"", 2},
        {"""", 0},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""hex_key(%s)"", test.input), func(t *testing.T) {
            result := hex_key(test.input)
            if result != test.expected {
                t.Errorf(""expected %d, got %d"", test.expected, result)
            }
        })
    }
}","func TestHex_Key(t *testing.T) {
  candidate := hex_key
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""AB""), expected: 1 },
     { actual: candidate(""1077E""), expected: 2 },
     { actual: candidate(""ABED1A33""), expected: 4 },
     { actual: candidate(""2020""), expected: 2 },
     { actual: candidate(""123456789ABCDEF0""), expected: 6 },
     { actual: candidate(""112233445566778899AABBCCDDEEFF00""), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_79,bos_Latn,go_test.go,"package decimal_to_binary_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Dodatni znakovi su tu da pomognu u formatu.//Biće dodatnih nekoliko znakova 'db' na početku i na kraju niza.//Svaki znak u nizu će biti ""0"" ili ""1"".//Funkcija treba da vrati niz, sa svakim znakom koji predstavlja binarni //Dobićete broj u decimalnom obliku i vaš zadatak je da ga pretvorite u // >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
func decimal_to_binary(decimal int) string {
","package decimal_to_binary_test

import (
    ""testing""
    ""fmt""
    ""strconv""
)

// You will be given a number in decimal form and your task is to convert it to
// binary format. The function should return a string, with each character representing a binary
// number. Each character in the string will be '0' or '1'.
// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
// The extra characters are there to help with the format.
// Examples:
// >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
func decimal_to_binary(decimal int) string {
    binary := strconv.FormatInt(int64(decimal), 2)
    return ""db"" + binary + ""db""
}

func TestDecimalToBinary(t *testing.T) {
    tests := []struct {
        input  int
        output string
    }{
        {15, ""db1111db""},
        {32, ""db100000db""},
        {0, ""db0db""},
        {1, ""db1db""},
        {255, ""db11111111db""},
    }

    for _, test := range tests {
        result := decimal_to_binary(test.input)
        if result != test.output {
            t.Errorf(""For input %d, expected %s, but got %s"", test.input, test.output, result)
        }
    }
}

func main() {
    fmt.Println(decimal_to_binary(15))  // Output: db1111db
    fmt.Println(decimal_to_binary(32))  // Output: db100000db
    fmt.Println(decimal_to_binary(255)) // Output: db11111111db
}","func TestDecimal_To_Binary(t *testing.T) {
  candidate := decimal_to_binary
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0), expected: ""db0db"" },
     { actual: candidate(32), expected: ""db100000db"" },
     { actual: candidate(103), expected: ""db1100111db"" },
     { actual: candidate(15), expected: ""db1111db"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_80,bos_Latn,go_test.go,"package is_happy_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //String je hapgo ako je njegova dužina najmanje 3 i svaki od 3 uzastopna slova su različita //Vaš zadatak je da provjerite da li je string hapgo ili ne.//Dobiješ niz s.// >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
func is_happy(s string) bool {
","func is_happy(s string) bool {
    if len(s) < 3 {
        return false
    }
    for i := 0; i <= len(s)-3; i++ {
        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {
            return false
        }
    }
    return true
}","func TestIs_Happy(t *testing.T) {
  candidate := is_happy
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""a""), expected: false },
     { actual: candidate(""aa""), expected: false },
     { actual: candidate(""abcd""), expected: true },
     { actual: candidate(""aabb""), expected: false },
     { actual: candidate(""adb""), expected: true },
     { actual: candidate(""xyy""), expected: false },
     { actual: candidate(""iopaxpoi""), expected: true },
     { actual: candidate(""iopaxioi""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_81,bos_Latn,go_test.go,"package numerical_letter_grade_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //0.0 E //> 0.0 D- //> 0,7 D //> 1,0 D+ //> 1.3 C- //> 1,7 C //> 2.0 C+ //> 2.3 B- //> 2,7 B //> 3.0 B+ //> 3.3 A- //> 3.7 A //4.0 A+ //Prosek. Oznaka po pismu.//Funkcija koja može da izbaci listu razredova slova koristeći sledeću tabelu: //Dala ti je listu prosjeka nekih učenika i moraš da pišeš.//Jedini problem je što je izgubila kod koji je koristila za ocenjivanje.//Učitelj je napravio svoj algoritam za ocenjivanje.//Ovo je poslednja sedmica semestra i učiteljica mora da daje ocene.// >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})
// []string{""A+"", ""B"", ""C-"", ""C"", ""A-""}
func numerical_letter_grade(grades []float64) []string {
","func numerical_letter_grade(grades []float64) []string {
    letterGrades := []string{}
    for _, grade := range grades {
        if grade == 4.0 {
            letterGrades = append(letterGrades, ""A+"")
        } else if grade > 3.7 {
            letterGrades = append(letterGrades, ""A"")
        } else if grade > 3.3 {
            letterGrades = append(letterGrades, ""A-"")
        } else if grade > 3.0 {
            letterGrades = append(letterGrades, ""B+"")
        } else if grade > 2.7 {
            letterGrades = append(letterGrades, ""B"")
        } else if grade > 2.3 {
            letterGrades = append(letterGrades, ""B-"")
        } else if grade > 2.0 {
            letterGrades = append(letterGrades, ""C+"")
        } else if grade > 1.7 {
            letterGrades = append(letterGrades, ""C"")
        } else if grade > 1.3 {
            letterGrades = append(letterGrades, ""C-"")
        } else if grade > 1.0 {
            letterGrades = append(letterGrades, ""D+"")
        } else if grade > 0.7 {
            letterGrades = append(letterGrades, ""D"")
        } else if grade > 0.0 {
            letterGrades = append(letterGrades, ""D-"")
        } else {
            letterGrades = append(letterGrades, ""E"")
        }
    }
    return letterGrades
}","func TestNumerical_Letter_Grade(t *testing.T) {
  candidate := numerical_letter_grade
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{""A+"", ""B"", ""C-"", ""C"", ""A-""} },
     { actual: candidate([]float64{1.2}), expected: []string{""D+""} },
     { actual: candidate([]float64{0.5}), expected: []string{""D-""} },
     { actual: candidate([]float64{0.0}), expected: []string{""E""} },
     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{""D"", ""D-"", ""C-"", ""B"", ""B+""} },
     { actual: candidate([]float64{0.0, 0.7}), expected: []string{""E"", ""D-""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_82,bos_Latn,go_test.go,"package prime_length_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //dužina je prvi broj ili je pogrešan inače //Napišite funkciju koja uzima niz i vraća vrijednost true ako niz // >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
func prime_length(myString string) bool {
","package prime_length_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func prime_length(myString string) bool {
    length := len(myString)
    return isPrime(length)
}

func TestPrimeLength(t *testing.T) {
    testCases := []struct{
        input string
        expected bool
    }{
        {""Hello"", true},
        {""abcdcba"", true},
        {""kittens"", true},
        {""orange"", false},
    }

    for _, testCase := range testCases {
        result := prime_length(testCase.input)
        if result != testCase.expected {
            t.Errorf(""prime_length(%v) returned %v, expected %v"", testCase.input, result, testCase.expected)
        }
    }
}

func main() {
    fmt.Println(prime_length(""Hello""))  // true
    fmt.Println(prime_length(""abcdcba""))  // true
    fmt.Println(prime_length(""kittens""))  // true
    fmt.Println(prime_length(""orange""))  // false
}","func TestPrime_Length(t *testing.T) {
  candidate := prime_length
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hello""), expected: true },
     { actual: candidate(""abcdcba""), expected: true },
     { actual: candidate(""kittens""), expected: true },
     { actual: candidate(""orange""), expected: false },
     { actual: candidate(""wow""), expected: true },
     { actual: candidate(""world""), expected: true },
     { actual: candidate(""MadaM""), expected: true },
     { actual: candidate(""Wow""), expected: true },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""HI""), expected: true },
     { actual: candidate(""go""), expected: true },
     { actual: candidate(""gogo""), expected: false },
     { actual: candidate(""aaaaaaaaaaaaaaa""), expected: false },
     { actual: candidate(""Madam""), expected: true },
     { actual: candidate(""M""), expected: false },
     { actual: candidate(""0""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_83,bos_Latn,go_test.go,"package starts_one_ends_test

import (
    ""testing""
    ""fmt""
)

//Pozitivni celi brojevi koji počinju ili završavaju sa 1.//Ako je n pozitivan cijeli broj, vratite broj n-cifrenih brojeva func starts_one_ends(n int) int {
","package starts_one_ends_test

import (
    ""testing""
    ""fmt""
)

// Given a positive integer n, return the count of the numbers of n-digit
// positive integers that start or end with 1.
func starts_one_ends(n int) int {
    if n == 1 {
        return 1
    }

    countStart1 := 1 * pow(10, n-1)
    countEnd1 := 9 * pow(10, n-2)
    
    return countStart1 + countEnd1
}

func pow(base, exp int) int {
    if exp == 0 {
        return 1
    }
    result := 1
    for i := 0; i < exp; i++ {
        result *= base
    }
    return result
}

func TestStartsOneEnds(t *testing.T) {
    tests := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 19},
        {3, 189},
        {4, 1899},
        {5, 18999},
    }

    for _, tt := range tests {
        testname := fmt.Sprintf(""n=%d"", tt.n)
        t.Run(testname, func(t *testing.T) {
            result := starts_one_ends(tt.n)
            if result != tt.expected {
                t.Errorf(""got %d, want %d"", result, tt.expected)
            }
        })
    }
}","func TestStarts_One_Ends(t *testing.T) {
  candidate := starts_one_ends
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 1 },
     { actual: candidate(2), expected: 18 },
     { actual: candidate(3), expected: 180 },
     { actual: candidate(4), expected: 1800 },
     { actual: candidate(5), expected: 18000 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_84,bos_Latn,go_test.go,"package solve_test

import (
    ""testing""
    ""fmt""
)

//Primjer //Dajući pozitivan cijeli broj N, vratite ukupnu sumu njegovih cifara u binarnom obliku. // >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
func solve(N int) string {
","func solve(N int) string {
    sum := 0
    for N > 0 {
        sum += N % 10
        N /= 10
    }
    return fmt.Sprintf(""%b"", sum)
}","func TestSolve(t *testing.T) {
  candidate := solve
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1000), expected: ""1"" },
     { actual: candidate(150), expected: ""110"" },
     { actual: candidate(147), expected: ""1100"" },
     { actual: candidate(333), expected: ""1001"" },
     { actual: candidate(963), expected: ""10010"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_85,bos_Latn,go_test.go,"package add_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Ako imamo neprazan popis cijelih brojeva, prvo dodaj parni elementi koji su u neparnim indeksima.// >>> add([]int{4, 2, 6, 7})
// 2
func add(lst []int) int {
","sum := 0
    for i := 1; i < len(lst); i += 2 {
        if lst[i]%2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","func TestAdd(t *testing.T) {
  candidate := add
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{4, 88}), expected: 88 },
     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },
     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },
     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_86,bos_Latn,go_test.go,"package anti_shuffle_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Napomena: Treba da se zadrži redosled reči i praznih prostora u rečenici.//Poredak po porastu na osnovu ASCII vrijednosti.//zamjenjuje se novom riječju u kojoj su svi znakovi raspoređeni u //Poredana verzija niza, je niza u kojoj su sve riječi (odvojene razmakom) //Napišite funkciju koja uzima niz i vraća poresku verziju.// >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
func anti_shuffle(s string) string {
","package anti_shuffle_test

import (
    ""strings""
    ""sort""
)

func anti_shuffle(s string) string {
    // Split the input string into words based on spaces
    words := strings.Fields(s)

    // Iterate over each word
    for i, word := range words {
        // Convert the word to a slice of runes for sorting
        runes := []rune(word)
        // Sort the runes using custom comparison
        sort.Slice(runes, func(i, j int) bool {
            return runes[i] < runes[j]
        })
        // Reassign the sorted runes back to the word
        words[i] = string(runes)
    }

    // Rejoin the words into a single string, keeping original spaces
    result := """"
    inputIndex := 0

    for _, word := range words {
        // Add the spaces prior to the current word
        for inputIndex < len(s) && s[inputIndex] == ' ' {
            result += "" ""
            inputIndex++
        }
        // Add the current sorted word
        result += word
        inputIndex += len(word)
    }

    // Add trailing spaces, if any.
    for inputIndex < len(s) && s[inputIndex] == ' ' {
        result += "" ""
        inputIndex++
    }

    return result
}","func TestAnti_Shuffle(t *testing.T) {
  candidate := anti_shuffle
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hi""), expected: ""Hi"" },
     { actual: candidate(""hello""), expected: ""ehllo"" },
     { actual: candidate(""number""), expected: ""bemnru"" },
     { actual: candidate(""abcd""), expected: ""abcd"" },
     { actual: candidate(""Hello World!!!""), expected: ""Hello !!!Wdlor"" },
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""Hi. My name is Mister Robot. How are you?""), expected: "".Hi My aemn is Meirst .Rboot How aer ?ouy"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_87,bos_Latn,go_test.go,"package get_row_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Takođe, sortiraj koordinate reda po kolumnama u padajućem redoslijedu.//Sortiraj koordinate po redovima u porastu.//Svaki popis je koordinata - (red, kolona), počevši od 0. //i vrati popis lista, [(x1, y1), (x2, y2) ...] tako da //Ako imamo lst i cijeli broj x, pronađimo cijeli broj x na listi, //Svaki red može sadržavati različit broj kolona.//koja je slična matricama, međutim, za razliku od matrica,//Dobiješ dvodimenzionalne podatke, kao ugnežđene liste, // >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)
// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}
// >>> get_row([][]int{}, 1)
// [][]interface{}{}
// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)
// [][]int{[]interface{}{2, 2}}
func get_row(lst [][]int, x int) [][]interface{} {
","package get_row_test

import (
	""sort""
)

func get_row(lst [][]int, x int) [][]interface{} {
	var result [][]interface{}

	for i, row := range lst {
		var temp []interface{}
		for j, value := range row {
			if value == x {
				temp = append(temp, []interface{}{i, j})
			}
		}
		// Sort columns in descending order for the current row
		sort.Slice(temp, func(a, b int) bool {
			return temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)
		})
		result = append(result, temp...)
	}

	// result is already sorted by rows since we've traversed `lst` row by row
	return result
}","func TestGet_Row(t *testing.T) {
  candidate := get_row
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },
     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },
     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },
     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_88,bos_Latn,go_test.go,"package sort_array_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //* ne mijenjajte date liste. //Napomena: //ili ga rasporediti u padajućem redoslijedu ako je suma ((prva indeksna vrijednost, posljednja indeksna vrijednost) parna. //sortirat ćete datog popisa u rastućem redoslijedu ako je suma ((prva indeksna vrijednost, posljednja indeksna vrijednost) neparna, //Ako je data lista ne-negativnih cijelih brojeva, vrati se cogo date liste nakon sortiranja, // >>> sort_array([]int{})
// []int{}
// >>> sort_array([]int{5})
// []int{5}
// >>> sort_array([]int{2, 4, 3, 0, 1, 5})
// []int{0, 1, 2, 3, 4, 5}
// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})
// []int{6, 5, 4, 3, 2, 1, 0}
func sort_array(array []int) []int {
","package sort_array_test

import (
    ""sort""
)

func sort_array(array []int) []int {
    if len(array) <= 1 {
        return append([]int{}, array...)
    }

    result := append([]int{}, array...) // Copy the array to avoid mutating the input
    if (result[0]+result[len(result)-1])%2 == 0 {
        sort.Sort(sort.Reverse(sort.IntSlice(result))) // Sort in descending order
    } else {
        sort.Ints(result) // Sort in ascending order
    }

    return result
}","func TestSort_Array(t *testing.T) {
  candidate := sort_array
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{5}), expected: []int{5} },
     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },
     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },
     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },
     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },
     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_89,bos_Latn,go_test.go,"package encrypt_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //pomak dole sa dva puta na dva mjesta.//Alfabet treba da se rotira na takav način da slova//vraća niz šifrovan sa rotacijom abecede. //Stvori funkciju koja uzima niz kao argument i // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
func encrypt(s string) string {
","func encrypt(s string) string {
    result := []rune(s)
    for i, char := range result {
        if char >= 'a' && char <= 'z' {
            result[i] = 'a' + (char-'a'+4)%26
        } else if char >= 'A' && char <= 'Z' {
            result[i] = 'A' + (char-'A'+4)%26
        }
    }
    return string(result)
}","func TestEncrypt(t *testing.T) {
  candidate := encrypt
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""hi""), expected: ""lm"" },
     { actual: candidate(""asdfghjkl""), expected: ""ewhjklnop"" },
     { actual: candidate(""gf""), expected: ""kj"" },
     { actual: candidate(""et""), expected: ""ix"" },
     { actual: candidate(""faewfawefaewg""), expected: ""jeiajeaijeiak"" },
     { actual: candidate(""hellomyfriend""), expected: ""lippsqcjvmirh"" },
     { actual: candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""), expected: ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" },
     { actual: candidate(""a""), expected: ""e"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_91,bos_Latn,go_test.go,"package is_bored_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Rečenice se razgraničavaju sa '.', '?' ili '!'. //Dosada je rečenica koja počinje sa ""ja"".//Dobićete niz reči, a vaš zadatak je da prebrojite broj.// >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
func is_bored(S string) int {
","package is_bored_test

import (
    ""strings""
    ""testing""
    ""fmt""
)

func is_bored(S string) int {
    sentences := strings.FieldsFunc(S, func(r rune) bool {
        return r == '.' || r == '?' || r == '!'
    })
    count := 0
    for _, sentence := range sentences {
        trimmed := strings.TrimSpace(sentence)
        if strings.HasPrefix(trimmed, ""I "") {
            count++
        }
    }
    return count
}

func TestIsBored(t *testing.T) {
    tests := []struct {
        input string
        want  int
    }{
        {""Hello world"", 0},
        {""The sky is blue. The sun is shining. I love this weather"", 1},
        {""I am here. I am there. I am everywhere"", 3},
        {""What's up? Are you ok? Yes, I am!"", 1},
        {"""", 0},
        {""I."", 1},
        {""I! am excited. I? am curious"", 2},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf(""is_bored(%q)"", tt.input), func(t *testing.T) {
            got := is_bored(tt.input)
            if got != tt.want {
                t.Errorf(""got %d, want %d"", got, tt.want)
            }
        })
    }
}","func TestIs_Bored(t *testing.T) {
  candidate := is_bored
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hello world""), expected: 0 },
     { actual: candidate(""Is the sky blue?""), expected: 0 },
     { actual: candidate(""I love It !""), expected: 1 },
     { actual: candidate(""bIt""), expected: 0 },
     { actual: candidate(""I feel good today. I will be productive. will kill It""), expected: 2 },
     { actual: candidate(""You and I are going for a walk""), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_92,bos_Latn,go_test.go,"package any_int_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //Vraća false u svim ostalim slučajevima.//Vraća vrijednost istinita ako je jedan od brojeva jednak zbiru ostalih dva, a svi brojevi su celi brojevi.//Stvori funkciju koja uzima 3 broja.// >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
func any_int(x float64, y float64, z float64) bool {
","package any_int_test

import (
    ""testing""
)

func any_int(x float64, y float64, z float64) bool {
    // Check if x, y, and z are integers
    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {
        return false
    }

    // Check if one of the numbers is the sum of the other two
    if x == y+z || y == x+z || z == x+y {
        return true
    }

    return false
}

func TestAnyInt(t *testing.T) {
    if !any_int(5, 2, 7) {
        t.Errorf(""Expected true for any_int(5, 2, 7)"")
    }
    if any_int(3, 2, 2) {
        t.Errorf(""Expected false for any_int(3, 2, 2)"")
    }
    if !any_int(3, -2, 1) {
        t.Errorf(""Expected true for any_int(3, -2, 1)"")
    }
    if any_int(3.6, -2.2, 2) {
        t.Errorf(""Expected false for any_int(3.6, -2.2, 2)"")
    }
}","func TestAny_Int(t *testing.T) {
  candidate := any_int
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2, 3, 1), expected: true },
     { actual: candidate(2.5, 2, 3), expected: false },
     { actual: candidate(1.5, 5, 3.5), expected: false },
     { actual: candidate(2, 6, 2), expected: false },
     { actual: candidate(4, 2, 2), expected: true },
     { actual: candidate(2.2, 2.2, 2.2), expected: false },
     { actual: candidate(-4, 6, 2), expected: true },
     { actual: candidate(2, 1, 1), expected: true },
     { actual: candidate(3, 4, 7), expected: true },
     { actual: candidate(3.0, 4, 7), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_93,bos_Latn,go_test.go,"package encode_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Pretpostavimo samo slova.//Samoglasnik u engleskom abecedi.//Poruka sa slovom koje se pojavljuje 2 mjesta ispred toga.//Na taj način zamjenjuje case svih slova, zamjenjuje sve samoglasnike u //Napišite funkciju koja uzima poruku i kodira je u takvom // >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
func encode(message string) string {
","package encode_test

import (
	""strings""
	""unicode""
)

func encode(message string) string {
	var encodedMessage strings.Builder

	// Mapping of vowels to the letter appearing 2 places ahead
	vowelReplacement := map[rune]rune{
		'a': 'c',
		'A': 'C',
		'e': 'g',
		'E': 'G',
		'i': 'k',
		'I': 'K',
		'o': 'q',
		'O': 'Q',
		'u': 'w',
		'U': 'W',
	}

	for _, char := range message {
		if unicode.IsLetter(char) {
			// Swap case of the character
			if unicode.IsUpper(char) {
				char = unicode.ToLower(char)
			} else {
				char = unicode.ToUpper(char)
			}

			// Replace vowel if the character is a vowel
			if replacement, isVowel := vowelReplacement[char]; isVowel {
				char = replacement
			}
		}

		encodedMessage.WriteRune(char)
	}

	return encodedMessage.String()
}","func TestEncode(t *testing.T) {
  candidate := encode
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""TEST""), expected: ""tgst"" },
     { actual: candidate(""Mudasir""), expected: ""mWDCSKR"" },
     { actual: candidate(""YES""), expected: ""ygs"" },
     { actual: candidate(""This is a message""), expected: ""tHKS KS C MGSSCGG"" },
     { actual: candidate(""I DoNt KnOw WhAt tO WrItE""), expected: ""k dQnT kNqW wHcT Tq wRkTg"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_94,bos_Latn,go_test.go,"package skjkasdkd_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Morate naći najveću primarnu vrijednost i vratiti zbir njenih cifara.//Dobiješ listu cijelih brojeva.// >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})
// 10
// >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})
// 25
// >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})
// 13
// >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})
// 11
// >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})
// 3
// >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})
// 7
func skjkasdkd(lst []int) int {
","package skjkasdkd_test

import (
	""testing""
)

// Helper function to check if a number is prime
func isPrime(n int) bool {
	if n < 2 {
		return false
	}
	for i := 2; i*i <= n; i++ {
		if n%i == 0 {
			return false
		}
	}
	return true
}

// Function to calculate the sum of digits of a number
func sumOfDigits(n int) int {
	sum := 0
	for n > 0 {
		sum += n % 10
		n /= 10
	}
	return sum
}

// Function to find the largest prime and return the sum of its digits
func skjkasdkd(lst []int) int {
	maxPrime := -1
	for _, num := range lst {
		if isPrime(num) && num > maxPrime {
			maxPrime = num
		}
	}
	if maxPrime == -1 {
		return 0
	}
	return sumOfDigits(maxPrime)
}

func TestSkjkasdkd(t *testing.T) {
	tests := []struct {
		input    []int
		expected int
	}{
		{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},
		{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},
		{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},
		{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},
		{[]int{0, 81, 12, 3, 1, 21}, 3},
		{[]int{0, 8, 1, 2, 1, 7}, 7},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
			result := skjkasdkd(test.input)
			if result != test.expected {
				t.Errorf(""got %v, want %v"", result, test.expected)
			}
		})
	}
}","func TestSkjkasdkd(t *testing.T) {
  candidate := skjkasdkd
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },
     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },
     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },
     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },
     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },
     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },
     { actual: candidate([]int{8191}), expected: 19 },
     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },
     { actual: candidate([]int{127, 97, 8192}), expected: 10 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_95,bos_Latn,go_test.go,"package check_dict_case_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Funkcija treba da vrati false ako je data mapa prazna. //case ili svi ključevi su nizovi u velikim slovima, inače vraća false. //Ako je data mapa, vrati se istina ako su svi tasteri nizovi u nižoj // >>> check_dict_case(map[string]string{""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case(map[string]string{""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case(map[interface{}]string{""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case(map[string]string{""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case(map[string]string{""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
func check_dict_case(dict map[string]string) bool {
","func check_dict_case(dict map[string]string) bool {
    if len(dict) == 0 {
        return false
    }

    var allLowercase, allUppercase bool
    for k := range dict {
        if k != strings.ToLower(k) && k != strings.ToUpper(k) {
            return false
        }
        if k == strings.ToLower(k) {
            if allUppercase {
                return false
            }
            allLowercase = true
        }
        if k == strings.ToUpper(k) {
            if allLowercase {
                return false
            }
            allUppercase = true
        }
    }

    return allLowercase || allUppercase
}","func TestCheck_Dict_Case(t *testing.T) {
  candidate := check_dict_case
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""b"": ""banana""}), expected: true },
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}), expected: false },
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}), expected: false },
     { actual: candidate(map[string]string{""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}), expected: false },
     { actual: candidate(map[string]string{""STATE"": ""NC"", ""ZIP"": ""12345""}), expected: true },
     { actual: candidate(map[string]string{""fruit"": ""Orange"", ""taste"": ""Sweet""}), expected: true },
     { actual: candidate(map[string]string{}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_96,bos_Latn,go_test.go,"package count_up_to_test

import (
    ""testing""
    ""fmt""
)

//na primer: //Cijeli brojevi koji su prvi brojevi i manji od n.//Implementira funkciju koja uzima ne-negativni cijeli broj i vraća listu prvih n // >>> count_up_to(5)
// []int{2, 3}
// >>> count_up_to(11)
// []int{2, 3, 5, 7}
// >>> count_up_to(0)
// []int{}
// >>> count_up_to(20)
// []int{2, 3, 5, 7, 11, 13, 17, 19}
// >>> count_up_to(1)
// []int{}
// >>> count_up_to(18)
// []int{2, 3, 5, 7, 11, 13, 17}
func count_up_to(n int) []int {
","func count_up_to(n int) []int {
	primes := []int{}
	for num := 2; num < n; num++ {
		if isPrime(num) {
			primes = append(primes, num)
		}
	}
	return primes
}

func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	for i := 2; i*i <= num; i++ {
		if num%i == 0 {
			return false
		}
	}
	return true
}","func TestCount_Up_To(t *testing.T) {
  candidate := count_up_to
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: []int{2, 3} },
     { actual: candidate(6), expected: []int{2, 3, 5} },
     { actual: candidate(7), expected: []int{2, 3, 5} },
     { actual: candidate(10), expected: []int{2, 3, 5, 7} },
     { actual: candidate(0), expected: []int{} },
     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },
     { actual: candidate(1), expected: []int{} },
     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },
     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },
     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_97,bos_Latn,go_test.go,"package multiply_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Pretpostavimo da je ulaz uvijek važeći.//proizvod njihovih jediničnih cifara. //Završite funkciju koja uzima dva cijela broja i vraća // >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
func multiply(a int, b int) int {
","package multiply_test

import (
    ""testing""
    ""fmt""
)

// Complete the function that takes two integers and returns 
// the product of their unit digits.
// Assume the input is always valid.
func multiply(a int, b int) int {
    unitA := abs(a) % 10
    unitB := abs(b) % 10
    return unitA * unitB
}

func abs(n int) int {
    if n < 0 {
        return -n
    }
    return n
}

func TestMultiply(t *testing.T) {
    fmt.Println(multiply(148, 412)) // 16
    fmt.Println(multiply(19, 28))   // 72
    fmt.Println(multiply(2020, 1851)) // 0
    fmt.Println(multiply(14, -15))  // 20
}","func TestMultiply(t *testing.T) {
  candidate := multiply
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(148, 412), expected: 16 },
     { actual: candidate(19, 28), expected: 72 },
     { actual: candidate(2020, 1851), expected: 0 },
     { actual: candidate(14, -15), expected: 20 },
     { actual: candidate(76, 67), expected: 42 },
     { actual: candidate(17, 27), expected: 49 },
     { actual: candidate(0, 1), expected: 0 },
     { actual: candidate(0, 0), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_98,bos_Latn,go_test.go,"package count_upper_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //S obzirom na niz s, prebroji broj velikih samoglasnika u parnim indeksima. // >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
func count_upper(s string) int {
","package count_upper_test

import (
    ""testing""
)

func count_upper(s string) int {
    uppercaseVowels := ""AEIOU""
    count := 0
    
    for i := 0; i < len(s); i += 2 {
        if contains(uppercaseVowels, s[i]) {
            count++
        }
    }
    
    return count
}

func contains(vowels string, ch byte) bool {
    for i := 0; i < len(vowels); i++ {
        if vowels[i] == ch {
            return true
        }
    }
    return false
}

func TestCountUpper(t *testing.T) {
    tests := []struct {
        input    string
        expected int
    }{
        {""aBCdEf"", 1},
        {""abcdefg"", 0},
        {""dBBE"", 0},
    }

    for _, test := range tests {
        result := count_upper(test.input)
        if result != test.expected {
            t.Errorf(""For input '%s', expected %d but got %d"", test.input, test.expected, result)
        }
    }
}","func TestCount_Upper(t *testing.T) {
  candidate := count_upper
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""aBCdEf""), expected: 1 },
     { actual: candidate(""abcdefg""), expected: 0 },
     { actual: candidate(""dBBE""), expected: 0 },
     { actual: candidate(""B""), expected: 0 },
     { actual: candidate(""U""), expected: 1 },
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""EEEE""), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_99,bos_Latn,go_test.go,"package closest_integer_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //od dva cijela broja, zaokružite ga od nule.//i vraća najbliži cjelokupni broj. Ako je broj jednako udaljen //Stvori funkciju koja uzima vrijednost (string) koja predstavlja broj // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value string) int {
","package closest_integer_test

import (
	""strconv""
	""math""
)

func closest_integer(value string) int {
	num, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return 0 // handle error appropriately in real scenarios
	}
	if num > 0 {
		return int(math.Ceil(num - 0.5))
	}
	return int(math.Floor(num + 0.5))
}","func TestClosest_Integer(t *testing.T) {
  candidate := closest_integer
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""10""), expected: 10 },
     { actual: candidate(""14.5""), expected: 15 },
     { actual: candidate(""-15.5""), expected: -16 },
     { actual: candidate(""15.3""), expected: 15 },
     { actual: candidate(""0""), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_100,bos_Latn,go_test.go,"package make_a_pile_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //i predstavlja broj kamenja na nivou (i+1).//Vraća broj kamenja u svakom nivou u listi, gdje je element u indeksu //- sljedeći parni broj ako je n par. //- sljedeći neparni broj ako je n neparno. //Broj kamenja u sledećem nivou je://Prvi nivo ima n kamenja.//Ako imamo pozitivan cijeli broj n, moramo napraviti hrpu od n nivoa kamenja.// >>> make_a_pile(3)
// []int{3, 5, 7}
func make_a_pile(n int) []int {
","package make_a_pile_test

import (
    ""testing""
    ""fmt""
)

func make_a_pile(n int) []int {
    pile := make([]int, n)
    currentStones := n

    for i := 0; i < n; i++ {
        pile[i] = currentStones
        if n%2 == 0 {
            currentStones += 2
        } else {
            currentStones += 2
        }
    }

    return pile
}

func TestMakeAPile(t *testing.T) {
    cases := []struct {
        input    int
        expected []int
    }{
        {3, []int{3, 5, 7}},
        {4, []int{4, 6, 8, 10}},
        {1, []int{1}},
        {5, []int{5, 7, 9, 11, 13}},
    }

    for _, c := range cases {
        res := make_a_pile(c.input)
        if fmt.Sprintf(""%v"", res) != fmt.Sprintf(""%v"", c.expected) {
            t.Errorf(""make_a_pile(%d) == %v, expected %v"", c.input, res, c.expected)
        }
    }
}","func TestMake_A_Pile(t *testing.T) {
  candidate := make_a_pile
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: []int{3, 5, 7} },
     { actual: candidate(4), expected: []int{4, 6, 8, 10} },
     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },
     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },
     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_101,bos_Latn,go_test.go,"package words_string_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //da podeli niz na reči i vrati listu riječi.//Dobićete niz reči odvojenih zarezima ili razmakom.// >>> words_string(""Hi, my name is John"")
// []string{""Hi"", ""my"", ""name"", ""is"", ""John""}
// >>> words_string(""One, two, three, four, five, six"")
// []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""}
func words_string(s string) []string {
","package words_string_test

import (
    ""testing""
    ""strings""
    ""fmt""
    ""regexp""
)

func words_string(s string) []string {
    re := regexp.MustCompile(`[,\s]+`)
    return re.Split(s, -1)
}

func TestWordsString(t *testing.T) {
    tests := []struct{
        input string
        expected []string
    }{
        {""Hi, my name is John"", []string{""Hi"", ""my"", ""name"", ""is"", ""John""}},
        {""One, two, three, four, five, six"", []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""}},
        {""a,b,c"", []string{""a"", ""b"", ""c""}},
        {""hello world"", []string{""hello"", ""world""}},
    }

    for _, test := range tests {
        result := words_string(test.input)
        if !equal(result, test.expected) {
            t.Errorf(""Expected %v, but got %v"", test.expected, result)
        }
    }
}

func equal(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestWords_String(t *testing.T) {
  candidate := words_string
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hi, my name is John""), expected: []string{""Hi"", ""my"", ""name"", ""is"", ""John""} },
     { actual: candidate(""One, two, three, four, five, six""), expected: []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""} },
     { actual: candidate(""Hi, my name""), expected: []string{""Hi"", ""my"", ""name""} },
     { actual: candidate(""One,, two, three, four, five, six,""), expected: []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""} },
     { actual: candidate(""""), expected: []string{} },
     { actual: candidate(""ahmed     , gamal""), expected: []string{""ahmed"", ""gamal""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_102,bos_Latn,go_test.go,"package choose_num_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Ako nema takvog broja, onda funkcija treba da vrati -1.//Najveći parni cijeli broj koji je u rasponu [x, y] uključivo.//Ova funkcija uzima dva pozitivna broja x i y i vraća // >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
func choose_num(x int, y int) int {
","func choose_num(x int, y int) int {
	if x > y {
		return -1
	}
	// Start from y and move backwards looking for the largest even number
	for i := y; i >= x; i-- {
		if i%2 == 0 {
			return i
		}
	}
	return -1
}

func TestChooseNum(t *testing.T) {
	tests := []struct {
		x, y, expected int
	}{
		{12, 15, 14},
		{13, 12, -1},
		{4, 10, 10},
		{5, 5, -1},
		{6, 6, 6},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""x=%d_y=%d"", test.x, test.y), func(t *testing.T) {
			result := choose_num(test.x, test.y)
			if result != test.expected {
				t.Errorf(""For choose_num(%d, %d), expected %d, but got %d"", test.x, test.y, test.expected, result)
			}
		})
	}
}","func TestChoose_Num(t *testing.T) {
  candidate := choose_num
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(12, 15), expected: 14 },
     { actual: candidate(13, 12), expected: -1 },
     { actual: candidate(33, 12354), expected: 12354 },
     { actual: candidate(5234, 5233), expected: -1 },
     { actual: candidate(6, 29), expected: 28 },
     { actual: candidate(27, 10), expected: -1 },
     { actual: candidate(7, 7), expected: -1 },
     { actual: candidate(546, 546), expected: 546 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_104,bos_Latn,go_test.go,"package unique_digits_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Napomena: Povratna lista treba da bude sortirana u porastu.//elemenata koji nemaju nijednu parnu cifru.//Ako je data lista pozitivnih cijelih brojeva x, vrati sortiranu listu svih // >>> unique_digits([]int{15, 33, 1422, 1})
// []int{1, 15, 33}
// >>> unique_digits([]int{152, 323, 1422, 10})
// []int{}
func unique_digits(x []int) []int {
","package unique_digits_test

import (
    ""sort""
)

// unique_digits returns a sorted list of all elements that don't have any even digit.
func unique_digits(x []int) []int {
    result := []int{}
    for _, num := range x {
        if hasEvenDigit(num) == false {
            result = append(result, num)
        }
    }
    sort.Ints(result)
    return result
}

// hasEvenDigit checks if a given number contains any even digit.
func hasEvenDigit(num int) bool {
    for num > 0 {
        digit := num % 10
        if digit%2 == 0 {
            return true
        }
        num /= 10
    }
    return false
}","func TestUnique_Digits(t *testing.T) {
  candidate := unique_digits
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },
     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },
     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },
     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_105,bos_Latn,go_test.go,"package by_length_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Jedan, dva, tri, četiri, pet, šest, sedam, osam, devet.//preokrenite rezultiranu listu, a zatim zamijenite svaku cifru odgovarajućim imenom iz //Ako imamo listu cijelih brojeva, sortirajmo ih između 1 i 9 uključujući, // >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})
// []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""}
// If the list is empty, return an empty list:
// >>> by_length([]int{})
// []string{}
// If the list has any strange number ignore it:
// >>> by_length([]int{1, -1, 55})
// []string{""One""}
func by_length(arr []int) []string {
","package by_length_test

import (
    ""testing""
    ""sort""
)

func by_length(arr []int) []string {
    // Filter numbers between 1 and 9
    filtered := []int{}
    for _, num := range arr {
        if num >= 1 && num <= 9 {
            filtered = append(filtered, num)
        }
    }

    // Sort in ascending order
    sort.Ints(filtered)

    // Reverse the sorted slice
    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {
        filtered[i], filtered[j] = filtered[j], filtered[i]
    }

    // Map numbers to their corresponding names
    numToString := map[int]string{
        1: ""One"", 2: ""Two"", 3: ""Three"",
        4: ""Four"", 5: ""Five"", 6: ""Six"",
        7: ""Seven"", 8: ""Eight"", 9: ""Nine"",
    }

    // Create the result slice with names
    result := []string{}
    for _, num := range filtered {
        result = append(result, numToString[num])
    }

    return result
}

func TestByLength(t *testing.T) {
    tests := []struct {
        input []int
        want  []string
    }{
        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""}},
        {[]int{}, []string{}},
        {[]int{1, -1, 55}, []string{""One""}},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
            got := by_length(test.input)
            if !equals(got, test.want) {
                t.Errorf(""got = %v; want %v"", got, test.want)
            }
        })
    }
}

func equals(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestBy_Length(t *testing.T) {
  candidate := by_length
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""} },
     { actual: candidate([]int{}), expected: []string{} },
     { actual: candidate([]int{1, -1, 55}), expected: []string{""One""} },
     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{""Three"", ""Two"", ""One""} },
     { actual: candidate([]int{9, 4, 8}), expected: []string{""Nine"", ""Eight"", ""Four""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_106,bos_Latn,go_test.go,"package f_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Faktorijal od i je množenje brojeva od 1 do i (1 * 2 * ... * i).//Pocinjem od 1.//ili suma brojeva od 1 do i. //i vraća listu veličine n, tako da je vrijednost elementa na indeksu i faktorijal od i ako je i parna //Implementirajte funkciju f koja uzima n kao parametar, // >>> f(5)
// []int{1, 2, 6, 24, 15}
func f(n int) []int {
","package f_test

import (
    ""testing""
    ""fmt""
)

func f(n int) []int {
    result := make([]int, n)
    for i := 1; i <= n; i++ {
        if i%2 == 0 {
            result[i-1] = factorial(i)
        } else {
            result[i-1] = sum(i)
        }
    }
    return result
}

func factorial(num int) int {
    if num <= 1 {
        return 1
    }
    return num * factorial(num-1)
}

func sum(num int) int {
    s := 0
    for i := 1; i <= num; i++ {
        s += i
    }
    return s
}

func TestF(t *testing.T) {
    expected := []int{1, 2, 6, 24, 15}
    result := f(5)
    if !equals(expected, result) {
        t.Errorf(""Expected %v, got %v"", expected, result)
    }
}

func equals(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}

func main() {
    fmt.Println(f(5)) // Output: []int{1, 2, 6, 24, 15}
}","func TestF(t *testing.T) {
  candidate := f
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },
     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },
     { actual: candidate(1), expected: []int{1} },
     { actual: candidate(3), expected: []int{1, 2, 6} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_107,bos_Latn,go_test.go,"package even_odd_palindrome_test

import (
    ""testing""
    ""fmt""
)

//Primjer 1: //cijeli brojevi palindroma koji su u rasponu od ({1, n}), uključujući. //Ako je dat pozitivan cijeli broj n, vratimo listu koja ima broj parnih i neparnih // >>> even_odd_palindrome(3)
// []interface{}{1, 2}
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// []interface{}{4, 6}
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned list has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n int) []interface{} {
","func isPalindrome(num int) bool {
    original := num
    reversed := 0
    for num > 0 {
        reversed = reversed*10 + num%10
        num /= 10
    }
    return original == reversed
}

func even_odd_palindrome(n int) []interface{} {
    evenCount, oddCount := 0, 0
    for i := 1; i <= n; i++ {
        if isPalindrome(i) {
            if i%2 == 0 {
                evenCount++
            } else {
                oddCount++
            }
        }
    }
    return []interface{}{evenCount, oddCount}
}","func TestEven_Odd_Palindrome(t *testing.T) {
  candidate := even_odd_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(123), expected: []interface{}{8, 13} },
     { actual: candidate(12), expected: []interface{}{4, 6} },
     { actual: candidate(3), expected: []interface{}{1, 2} },
     { actual: candidate(63), expected: []interface{}{6, 8} },
     { actual: candidate(25), expected: []interface{}{5, 6} },
     { actual: candidate(19), expected: []interface{}{4, 6} },
     { actual: candidate(9), expected: []interface{}{4, 5} },
     { actual: candidate(1), expected: []interface{}{0, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_108,bos_Latn,go_test.go,"package count_nums_test

import (
    ""testing""
    ""fmt""
)

//Na primjer, -123 ima potpisane cifre -1, 2 i 3.//Ako je broj negativan, onda će njegova prva potpisana cifra biti negativna: //broj elemenata čija je suma cifara > 0. //Napišite funkciju count_nums koja uzima listu cijelih brojeva i vraća // >>> count_nums([]int{})
// 0
// >>> count_nums([]int{-1, 11, -11})
// 1
// >>> count_nums([]int{1, 1, 2})
// 3
func count_nums(arr []int) int {
","package count_nums_test

import (
    ""testing""
    ""fmt""
)

func count_nums(arr []int) int {
    count := 0
    for _, num := range arr {
        digits := num
        sum := 0

        if digits < 0 {
            sum = digits % 10
            digits = -digits / 10
        }

        for digits > 0 {
            sum += digits % 10
            digits /= 10
        }

        if sum > 0 {
            count++
        }
    }
    return count
}

func TestCountNums(t *testing.T) {
    testCases := []struct {
        input    []int
        expected int
    }{
        {[]int{}, 0},
        {[]int{-1, 11, -11}, 1},
        {[]int{1, 1, 2}, 3},
    }

    for _, tc := range testCases {
        result := count_nums(tc.input)
        if result != tc.expected {
            t.Errorf(""Expected %v, got %v"", tc.expected, result)
        }
    }
}

func main() {
    fmt.Println(count_nums([]int{-1, 11, -11})) // Output: 1
    fmt.Println(count_nums([]int{1, 1, 2}))    // Output: 3
}","func TestCount_Nums(t *testing.T) {
  candidate := count_nums
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: 0 },
     { actual: candidate([]int{-1, -2, 0}), expected: 0 },
     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },
     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },
     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },
     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },
     { actual: candidate([]int{0, 1}), expected: 1 },
     { actual: candidate([]int{1}), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_109,bos_Latn,go_test.go,"package move_one_ball_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Napomena: Navedena lista garantuje jedinstvene elemente.//Ako je data lista prazna onda vraćamo true. //onda vraćaj tačno ili vraćaj lažno.//Ako je moguće dobiti sortiranu listu vršenjem gore navedene operacije //početna pozicija na listi, tj. 0th indeks. //Posljednji element liste će biti premješten na //Jedna desna pomeranja znači pomeranje svih elemenata liste za jedan.//Možete da izvodite desnu pomeranje operaciju bilo koji broj puta.//sljedeća operacija na datoj listi: //je moguće dobiti listu sortiran u redoslijedu bez pada, tako što se izvrši //Brojevi na listi će biti nasumično raspoređeni.//Imamo listu 'arr' od N cifara arr[1], arr[2], ..., arr[N].// >>> move_one_ball([]int{3, 4, 5, 1, 2})
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given list.
// >>> move_one_ball([]int{3, 5, 4, 1, 2})
// false
// Explanation:It is not possible to get non-decreasing order for the given
// list by performing any number of right shift operations.
func move_one_ball(arr []int) bool {
","func move_one_ball(arr []int) bool {
    n := len(arr)
    if n == 0 {
        return true
    }

    // Detect the point where the order breaks
    countBreaks := 0
    index := -1

    for i := 0; i < n; i++ {
        if arr[i] > arr[(i+1)%n] {
            countBreaks++
            index = i
        }
    }

    // If there is at most one point where the order breaks
    if countBreaks <= 1 {
        return true
    }

    return false
}","func TestMove_One_Ball(t *testing.T) {
  candidate := move_one_ball
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },
     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },
     { actual: candidate([]int{4, 3, 1, 2}), expected: false },
     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },
     { actual: candidate([]int{}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_110,bos_Latn,go_test.go,"package exchange_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //U suprotnom, vrati ""NE"".//Da bi svi elementi lst1 bili parni, vrati ""DA"".//Ako je moguće da se elementi zamene između lst1 i lst2 da bi se//Nema ograničenja na broj elemenata koji se razmjenjuju između lst1 i lst2. //Da bi napravio listu parnih brojeva.//i utvrđuje da li je moguće izvršiti razmjenu elemenata //U ovom problemu, implementirat ćete funkciju koja uzima dvije liste brojeva, // >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})
// ""YES""
// >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})
// ""NO""
// It is assumed that the input lists will be non-empty.
func exchange(lst1 []int, lst2 []int) string {
","func exchange(lst1 []int, lst2 []int) string {
    hasEvenInLst2 := false
    
    for _, num := range lst2 {
        if num%2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasEvenInLst2 {
        return ""NO""
    }
    
    for _, num := range lst1 {
        if num%2 != 0 {
            return ""YES""
        }
    }

    return ""YES""
}","func TestExchange(t *testing.T) {
  candidate := exchange
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: ""YES"" },
     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: ""NO"" },
     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: ""YES"" },
     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: ""YES"" },
     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: ""NO"" },
     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: ""NO"" },
     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: ""YES"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_111,bos_Latn,go_test.go,"package histogram_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Ako se nekoliko slova pojavljuje na istom mestu, vratite ih sve.//Odnosno, u ovom slučaju, u pitanju je slovo koje se najčešće ponavlja i koje sadrži odgovarajući broj.//Ako je dat niz koji predstavlja mala slova odvojena od prostora, vrati mapu // >>> histogram(""a b c"")
// map[string]int{""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// map[string]int{""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// map[string]int{""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// map[string]int{""b"": 4}
// >>> histogram("""")
// map[string]int{}
func histogram(test string) map[string]int {
","package histogram_test

import (
    ""strings""
)

func histogram(test string) map[string]int {
    if test == """" {
        return map[string]int{}
    }

    counts := make(map[string]int)
    words := strings.Fields(test)
    
    var maxCount int
    for _, word := range words {
        counts[word]++
        if counts[word] > maxCount {
            maxCount = counts[word]
        }
    }

    result := make(map[string]int)
    for key, count := range counts {
        if count == maxCount {
            result[key] = count
        }
    }

    return result
}","func TestHistogram(t *testing.T) {
  candidate := histogram
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""a b b a""), expected: map[string]int{""a"": 2, ""b"": 2} },
     { actual: candidate(""a b c a b""), expected: map[string]int{""a"": 2, ""b"": 2} },
     { actual: candidate(""a b c d g""), expected: map[string]int{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1} },
     { actual: candidate(""r t g""), expected: map[string]int{""r"": 1, ""t"": 1, ""g"": 1} },
     { actual: candidate(""b b b b a""), expected: map[string]int{""b"": 4} },
     { actual: candidate(""r t g""), expected: map[string]int{""r"": 1, ""t"": 1, ""g"": 1} },
     { actual: candidate(""""), expected: map[string]int{} },
     { actual: candidate(""a""), expected: map[string]int{""a"": 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_112,bos_Latn,go_test.go,"package reverse_delete_test

import (
    ""testing""
    ""fmt""
)

//Primjer //Treba da vratite listu koja sadrži niz rezultata i tačno/nepravedno za proveru.//Niska se zove palindrom ako se čita isto unazad kao i naprijed.//onda provjerite da li je rezultata palindrom. //Imamo dva niza s i c, morate izbrisati sve znakove u s koji su jednaki bilo kojem znaku u c //Zadatak // >>> reverse_delete(""abcde"", ""ae"")
// []interface{}{""bcd"", false}
// >>> reverse_delete(""abcdef"", ""b"")
// []interface{}{""acdef"", false}
// >>> reverse_delete(""abcdedcba"", ""ab"")
// []interface{}{""cdedc"", true}
func reverse_delete(s string, c string) []interface{} {
","func reverse_delete(s string, c string) []interface{} {
    // Create a map to store the characters to be deleted
    deleteMap := make(map[rune]bool)
    for _, ch := range c {
        deleteMap[ch] = true
    }
    
    // Filter the string s by removing characters present in deleteMap
    var filteredString []rune
    for _, ch := range s {
        if !deleteMap[ch] {
            filteredString = append(filteredString, ch)
        }
    }
    
    // Check if the filtered string is a palindrome
    n := len(filteredString)
    isPalindrome := true
    for i := 0; i < n/2; i++ {
        if filteredString[i] != filteredString[n-1-i] {
            isPalindrome = false
            break
        }
    }
    
    // Convert filteredString to a string and prepare result
    resultString := string(filteredString)
    return []interface{}{resultString, isPalindrome}
}","func TestReverse_Delete(t *testing.T) {
  candidate := reverse_delete
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""abcde"", ""ae""), expected: []interface{}{""bcd"", false} },
     { actual: candidate(""abcdef"", ""b""), expected: []interface{}{""acdef"", false} },
     { actual: candidate(""abcdedcba"", ""ab""), expected: []interface{}{""cdedc"", true} },
     { actual: candidate(""dwik"", ""w""), expected: []interface{}{""dik"", false} },
     { actual: candidate(""a"", ""a""), expected: []interface{}{"""", true} },
     { actual: candidate(""abcdedcba"", """"), expected: []interface{}{""abcdedcba"", true} },
     { actual: candidate(""abcdedcba"", ""v""), expected: []interface{}{""abcdedcba"", true} },
     { actual: candidate(""vabba"", ""v""), expected: []interface{}{""abba"", true} },
     { actual: candidate(""mamma"", ""mia""), expected: []interface{}{"""", true} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_113,bos_Latn,go_test.go,"package odd_count_test

import (
    ""testing""
    ""fmt""
)

//od neparnih cifara u i'th niz ulaza. //"" gdje bi svi i-i trebali biti zamijenjeni brojem //Svaki element i izlaznih podataka treba da bude ""broj neparnih elemenata u //Ako je data lista niza, gde se svaki niz sastoji samo od cifara, vrati popis.// >>> odd_count([]string{""1234567""})
// []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""}
// >>> odd_count([]string{""3"", ""11111111""})
// []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""}
func odd_count(lst []string) []string {
","package odd_count_test

import (
	""fmt""
	""testing""
)

func odd_count(lst []string) []string {
	result := []string{}
	for _, str := range lst {
		oddCount := 0
		for _, char := range str {
			if char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {
				oddCount++
			}
		}
		output := fmt.Sprintf(""the number of odd elements %dn the str%1ng %d of the %dnput."", oddCount, oddCount, oddCount)
		result = append(result, output)
	}
	return result
}

func TestOddCount(t *testing.T) {
	tests := []struct {
		input    []string
		expected []string
	}{
		{[]string{""1234567""}, []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""}},
		{[]string{""3"", ""11111111""}, []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""}},
	}

	for _, test := range tests {
		if result := odd_count(test.input); !equals(result, test.expected) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
		}
	}
}

func equals(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestOdd_Count(t *testing.T) {
  candidate := odd_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""1234567""}), expected: []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""} },
     { actual: candidate([]string{""3"", ""11111111""}), expected: []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""} },
     { actual: candidate([]string{""271"", ""137"", ""314""}), expected: []string{""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_114,bos_Latn,go_test.go,"package minSubArraySum_test

import (
    ""testing""
    ""fmt""
)

//Primjer //od brojeva.//S obzirom na listu cijelih brojeva, nađite minimalnu sumu bilo koje neprazne podliste // >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})
// 1
// >>> minSubArraySum([]int{-1, -2, -3})
// -6
func minSubArraySum(nums []int) int {
","if len(nums) == 0 {
        return 0
    }
    
    minEndingHere := nums[0]
    minSoFar := nums[0]

    for _, num := range nums[1:] {
        if minEndingHere > 0 {
            minEndingHere = num
        } else {
            minEndingHere += num
        }
        
        if minEndingHere < minSoFar {
            minSoFar = minEndingHere
        }
    }
    
    return minSoFar
}","func TestMinsubarraysum(t *testing.T) {
  candidate := minSubArraySum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },
     { actual: candidate([]int{-1, -2, -3}), expected: -6 },
     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },
     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },
     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },
     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },
     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },
     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },
     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },
     { actual: candidate([]int{-10}), expected: -10 },
     { actual: candidate([]int{7}), expected: 7 },
     { actual: candidate([]int{1, -1}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_115,bos_Latn,go_test.go,"package max_fill_test

import (
    ""testing""
    ""fmt""
)

//Primjer 1: //Izdaj broj puta koliko treba da spustiš kante.//Vaš zadatak je da koristite kante da ispraznite bunare.//i sve kante imaju isti kapacitet.//Svaki bunar ima odgovarajuću kantu koja se može koristiti za izvlačenje vode iz njega,//i svaka 1 u redu predstavlja jednu jedinicu vode.//Dobiješ pravougaonu mrežu bunara.// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)
// 6
// Example 2:
// >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)
// 5
// Example 3:
// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
func max_fill(grid [][]int, capacity int) int {
","package max_fill_test

import (
    ""testing""
    ""fmt""
)

func max_fill(grid [][]int, capacity int) int {
    totalLowerings := 0

    for _, row := range grid {
        waterInRow := 0
        
        for _, cell := range row {
            if cell == 1 {
                waterInRow++
            }
        }

        totalLowerings += (waterInRow + capacity - 1) / capacity
    }

    return totalLowerings
}

func TestMaxFill(t *testing.T) {
    tests := []struct {
        grid     [][]int
        capacity int
        expected int
    }{
        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},
        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},
        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},
    }

    for _, test := range tests {
        result := max_fill(test.grid, test.capacity)
        if result != test.expected {
            t.Errorf(""For grid %v with capacity %d, expected %d but got %d"", test.grid, test.capacity, test.expected, result)
        }
    }
}

func main() {
    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) // Output: 6
    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) // Output: 5
    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) // Output: 0
}","func TestMax_Fill(t *testing.T) {
  candidate := max_fill
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },
     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },
     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },
     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },
     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_116,bos_Latn,go_test.go,"package sort_array_test

import (
    ""testing""
    ""fmt""
)

//Mora se sprovesti ovako://Za sličan broj jedinica, sortirajte na osnovu decimalne vrijednosti.//Broj jedinica u binarnom prikazu u rastućem redoslijedu.//U ovom kata, morate sortirati listu ne-negativnih cijelih brojeva prema // >>> sort_array([]int{1, 5, 2, 3, 4})
// []int{1, 2, 3, 4, 5}
// >>> sort_array([]int{-2, -3, -4, -5, -6})
// []int{-6, -5, -4, -3, -2}
// >>> sort_array([]int{1, 0, 2, 3, 4})
// []int{0, 1, 2, 3, 4}
func sort_array(arr []int) []int {
","package sort_array_test

import (
    ""sort""
)

func sort_array(arr []int) []int {
    sort.Slice(arr, func(i, j int) bool {
        countOnes := func(x int) int {
            count := 0
            for x != 0 {
                count += x & 1
                x >>= 1
            }
            return count
        }

        countI := countOnes(arr[i])
        countJ := countOnes(arr[j])

        if countI == countJ {
            return arr[i] < arr[j]
        }
        return countI < countJ
    })
    return arr
}","func TestSort_Array(t *testing.T) {
  candidate := sort_array
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },
     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },
     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },
     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },
     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },
     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_117,bos_Latn,go_test.go,"package select_words_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Napomena: možete pretpostaviti da unosni niz sadrži samo slova i razmakove.//Ako je niz s prazan onda funkcija treba da vrati praznu listu.//n suglasnika, po redosledu koji se pojavljuje u nizu s. //Funkcija koja vraća spisak svih riječi iz niza s koje sadrže tačno //Ako imamo niz s i prirodni broj n, dobili smo zadatak da implementiramo // >>> select_words(""Mary had a little lamb"", 4)
// []string{""little""}
// >>> select_words(""Mary had a little lamb"", 3)
// []string{""Mary"", ""lamb""}
// >>> select_words(""simple white space"", 2)
// []string{}
// >>> select_words(""Hello world"", 4)
// []string{""world""}
// >>> select_words(""Uncle sam"", 3)
// []string{""Uncle""}
func select_words(s string, n int) []string {
","package select_words_test

import (
	""strings""
	""testing""
)

func select_words(s string, n int) []string {
	// Define a helper function to check if a character is a consonant.
	isConsonant := func(c rune) bool {
		c = rune(strings.ToLower(string(c))[0])
		return c >= 'a' && c <= 'z' && !strings.ContainsRune(""aeiou"", c)
	}

	// Split the string into words.
	words := strings.Fields(s)
	var result []string

	// Iterate over each word.
	for _, word := range words {
		consonantCount := 0
		// Count the consonants in the word.
		for _, char := range word {
			if isConsonant(char) {
				consonantCount++
			}
		}
		// If the number of consonants matches n, add the word to the result.
		if consonantCount == n {
			result = append(result, word)
		}
	}

	return result
}

func TestSelectWords(t *testing.T) {
	testCases := []struct {
		s        string
		n        int
		expected []string
	}{
		{""Mary had a little lamb"", 4, []string{""little""}},
		{""Mary had a little lamb"", 3, []string{""Mary"", ""lamb""}},
		{""simple white space"", 2, []string{}},
		{""Hello world"", 4, []string{""world""}},
		{""Uncle sam"", 3, []string{""Uncle""}},
	}

	for _, testCase := range testCases {
		result := select_words(testCase.s, testCase.n)
		if !equal(result, testCase.expected) {
			t.Errorf(""For input '%s' with n=%d, expected %v, but got %v"", testCase.s, testCase.n, testCase.expected, result)
		}
	}
}

func equal(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestSelect_Words(t *testing.T) {
  candidate := select_words
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Mary had a little lamb"", 4), expected: []string{""little""} },
     { actual: candidate(""Mary had a little lamb"", 3), expected: []string{""Mary"", ""lamb""} },
     { actual: candidate(""simple white space"", 2), expected: []string{} },
     { actual: candidate(""Hello world"", 4), expected: []string{""world""} },
     { actual: candidate(""Uncle sam"", 3), expected: []string{""Uncle""} },
     { actual: candidate("""", 4), expected: []string{} },
     { actual: candidate(""a b c d e f"", 1), expected: []string{""b"", ""c"", ""d"", ""f""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_118,bos_Latn,go_test.go,"package get_closest_vowel_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Možete pretpostaviti da dat niz sadrži samo engleski slovo.//Nađi samoglasnik koji ispunjava gore navedeni uslov.//Samoglasnici na početku i kraju se ne računaju.//dva suglasnika sa desne strane riječi (s obzirom na veličinu).//Vaša zadaća je da pronađete najbliži samoglasnik koji stoji između.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
func get_closest_vowel(word string) string {
","package get_closest_vowel_test

import (
    ""testing""
    ""fmt""
)

func get_closest_vowel(word string) string {
    vowels := ""aeiouAEIOU""
    isVowel := make(map[rune]bool)
    for _, v := range vowels {
        isVowel[v] = true
    }
    
    n := len(word)
    for i := n-2; i > 0; i-- {
        if isVowel[rune(word[i])] && 
           !isVowel[rune(word[i-1])] && 
           !isVowel[rune(word[i+1])] {
            return string(word[i])
        }
    }
    return """"
}

// Test functions
func TestGetClosestVowel(t *testing.T) {
    var tests = []struct {
        input    string
        expected string
    }{
        {""yogurt"", ""u""},
        {""FULL"", ""U""},
        {""quick"", """"},
        {""ab"", """"},
    }
    
    for _, test := range tests {
        result := get_closest_vowel(test.input)
        if result != test.expected {
            t.Errorf(""get_closest_vowel(%q) = %q; want %q"", test.input, result, test.expected)
        }
    }
}

func main() {
    fmt.Println(get_closest_vowel(""yogurt"")) // Output: ""u""
    fmt.Println(get_closest_vowel(""FULL""))   // Output: ""U""
    fmt.Println(get_closest_vowel(""quick""))  // Output: """"
    fmt.Println(get_closest_vowel(""ab""))     // Output: """"
}","func TestGet_Closest_Vowel(t *testing.T) {
  candidate := get_closest_vowel
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""yogurt""), expected: ""u"" },
     { actual: candidate(""full""), expected: ""u"" },
     { actual: candidate(""easy""), expected: """" },
     { actual: candidate(""eAsy""), expected: """" },
     { actual: candidate(""ali""), expected: """" },
     { actual: candidate(""bad""), expected: ""a"" },
     { actual: candidate(""most""), expected: ""o"" },
     { actual: candidate(""ab""), expected: """" },
     { actual: candidate(""ba""), expected: """" },
     { actual: candidate(""quick""), expected: """" },
     { actual: candidate(""anime""), expected: ""i"" },
     { actual: candidate(""Asia""), expected: """" },
     { actual: candidate(""Above""), expected: ""o"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_119,bos_Latn,go_test.go,"package match_parens_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Vrati 'Da' ako postoji način da se napravi dobar niz, i vrati 'Ne' u suprotnom.//"" (()) "" nije.//Na primjer: niz '(()))) je dobar, dok je niz //Niz S se smatra dobrim ako i samo ako su sve zagrade u S //neki red, da će rezultirajući niz biti dobar.//Tvoj posao je da provjeriš da li je moguće povezati dva niza u //samo u zagradama "" (("") ili u zatvorenim zagradama "") "". //Dobićete listu od dva niza, oba niza se sastoje od open // >>> match_parens([]string{""()("", "")""})
// ""Yes""
// >>> match_parens([]string{"")"", "")""})
// ""No""
func match_parens(lst []string) string {
","func match_parens(lst []string) string {
	left1, right1 := countParens(lst[0])
	left2, right2 := countParens(lst[1])

	if left1+left2 == right1+right2 {
		return ""Yes""
	}

	if left1-right1+left2-right2 == 0 {
		return ""Yes""
	}

	return ""No""
}

func countParens(s string) (left int, right int) {
	for _, c := range s {
		if c == '(' {
			left++
		} else if c == ')' {
			right++
		}
	}
	return
}

func TestMatchParens(t *testing.T) {
	tests := []struct {
		input    []string
		expected string
	}{
		{[]string{""()("", "")""}, ""Yes""},
		{[]string{"")"", "")""}, ""No""},
		{[]string{""((("", "")))""}, ""Yes""},
		{[]string{""("", "")""}, ""Yes""},
		{[]string{""))("", ""(""}, ""No""},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
			if got := match_parens(test.input); got != test.expected {
				t.Errorf(""match_parens(%v) = %v; want %v"", test.input, got, test.expected)
			}
		})
	}
}","func TestMatch_Parens(t *testing.T) {
  candidate := match_parens
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""()("", "")""}), expected: ""Yes"" },
     { actual: candidate([]string{"")"", "")""}), expected: ""No"" },
     { actual: candidate([]string{""(()(())"", ""())())""}), expected: ""No"" },
     { actual: candidate([]string{"")())"", ""(()()(""}), expected: ""Yes"" },
     { actual: candidate([]string{""(())))"", ""(()())((""}), expected: ""Yes"" },
     { actual: candidate([]string{""()"", ""())""}), expected: ""No"" },
     { actual: candidate([]string{""(()("", ""()))()""}), expected: ""Yes"" },
     { actual: candidate([]string{""(((("", ""((())""}), expected: ""No"" },
     { actual: candidate([]string{"")(()"", ""(()(""}), expected: ""No"" },
     { actual: candidate([]string{"")("", "")(""}), expected: ""No"" },
     { actual: candidate([]string{""("", "")""}), expected: ""Yes"" },
     { actual: candidate([]string{"")"", ""(""}), expected: ""Yes"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_120,bos_Latn,go_test.go,"package maximum_test

import (
    ""testing""
    ""fmt""
)

//Primjer 1: //dužine k sa maksimalnim k brojevima u arr. //Ako je data lista cijelih brojeva arr i pozitivan cjelina k, vrati sortiranu listu // >>> maximum([]int{-3, -4, 5}, 3)
// []int{-4, -3, 5}
// Example 2:
// >>> maximum([]int{4, -4, 4}, 2)
// []int{4, 4}
// Example 3:
// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)
// []int{2}
// Note:
// 1. The length of the list will be in the range of [1, 1000].
// 2. The elements in the list will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
func maximum(arr []int, k int) []int {
","package maximum_test

import (
    ""sort""
)

func maximum(arr []int, k int) []int {
    if k == 0 {
        return []int{}
    }
    
    // Sort the array
    sort.Ints(arr)
    
    // Get the last k elements, which are the largest
    return arr[len(arr)-k:]
}","func TestMaximum(t *testing.T) {
  candidate := maximum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },
     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },
     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },
     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },
     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },
     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },
     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },
     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },
     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },
     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },
     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_121,bos_Latn,go_test.go,"package solution_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //Ako imamo neprazan popis cijelih brojeva, vratimo sumu svih neparnih elemenata koji su u parnim pozicijama.// >>> solution([]int{5, 8, 7, 1})
// 12
// >>> solution([]int{3, 3, 3, 3, 3})
// 9
// >>> solution([]int{30, 13, 24, 321})
// 0
func solution(lst []int) int {
","sum := 0
    for i := 0; i < len(lst); i++ {
        if i%2 == 0 && lst[i]%2 != 0 {
            sum += lst[i]
        }
    }
    return sum
}","func TestSolution(t *testing.T) {
  candidate := solution
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },
     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },
     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },
     { actual: candidate([]int{5, 9}), expected: 5 },
     { actual: candidate([]int{2, 4, 8}), expected: 0 },
     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },
     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_122,bos_Latn,go_test.go,"package add_elements_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //suma elemenata sa najviše dvije cifre od prvih k elemenata arr. //S obzirom na nepraznu listu cijelih brojeva arr i cijelog broja k, vrati // >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
func add_elements(arr []int, k int) int {
","func add_elements(arr []int, k int) int {
    sum := 0
    for i := 0; i < k; i++ {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","func TestAdd_Elements(t *testing.T) {
  candidate := add_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },
     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },
     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },
     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },
     { actual: candidate([]int{1}, 1), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_123,bos_Latn,go_test.go,"package get_odd_collatz_test

import (
    ""testing""
    ""fmt""
)

//get_odd_collatz(5) vraća [1, 5] # Kollatz niz za 5 je [5, 16, 8, 4, 2, 1], tako da su neparni brojevi samo 1, i 5. //Na primer: //2. vraćena lista sortirana u porastu.//1. Collatz(1) je [1]. //Napomena: //Pretpostavka je da bez obzira na to koja je vrijednost n, slijed će uvijek dostići 1.//Ako je prethodni izraz neparan, sljedeći izraz je 3 puta prethodni.//Prethodni izraz je pola od //kao slijedeće: pocinjemo sa bilo kojim pozitivnim cijelim brojem n. Onda se svaki izraz dobija iz //Collatzova pretpostavka je pretpostavka u matematici koja se odnosi na definirani niz.//S obzirom na pozitivan cijeli broj n, vratite sortiranu listu koja ima neparne brojeve u Collatz nizu. // >>> get_odd_collatz(5)
// []int{1, 5}
func get_odd_collatz(n int) []int {
","package get_odd_collatz_test

import (
    ""sort""
)

func get_odd_collatz(n int) []int {
    oddNumbers := make(map[int]bool)

    for n != 1 {
        if n%2 != 0 {
            oddNumbers[n] = true
        }
        if n%2 == 0 {
            n /= 2
        } else {
            n = 3*n + 1
        }
    }

    // Add 1 to the set of odd numbers because the sequence always ends at 1
    oddNumbers[1] = true

    // Extract the keys, which represent the odd numbers
    result := make([]int, 0, len(oddNumbers))
    for num := range oddNumbers {
        result = append(result, num)
    }

    // Sort the result
    sort.Ints(result)

    return result
}","func TestGet_Odd_Collatz(t *testing.T) {
  candidate := get_odd_collatz
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },
     { actual: candidate(5), expected: []int{1, 5} },
     { actual: candidate(12), expected: []int{1, 3, 5} },
     { actual: candidate(1), expected: []int{1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_124,bos_Latn,go_test.go,"package valid_date_test

import (
    ""testing""
    ""fmt""
)

//4. Datum treba da bude u formatu: mm-dd-aaaa //3. Meseci ne bi trebali biti manji od 1 ili veći od 12.//Broj dana nije manji od 1 ili veći od 31 dana za mjesece 1,3,5,7,8,10,12. i broj dana nije manji od 1 ili veći od 30 dana za mjesece 4,6,9,11. i broj dana nije manji od 1 ili veći od 29 za mjesec 2.//1. niz datuma nije prazan.//Datum je važeći ako su ispunjena sva sledeća pravila: //vraća tačno ako je datum važeći inače lažan. //Morate napisati funkciju koja potvrđuje datirani niz i // >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
func valid_date(date string) bool {
","func valid_date(date string) bool {
    if len(date) == 0 {
        return false
    }

    var month, day, year int
    n, err := fmt.Sscanf(date, ""%02d-%02d-%04d"", &month, &day, &year)

    if err != nil || n != 3 {
        return false
    }

    if month < 1 || month > 12 {
        return false
    }

    if month == 2 {
        if day < 1 || day > 29 {
            return false
        }
    } else if month == 4 || month == 6 || month == 9 || month == 11 {
        if day < 1 || day > 30 {
            return false
        }
    } else {
        if day < 1 || day > 31 {
            return false
        }
    }

    return true
}","func TestValid_Date(t *testing.T) {
  candidate := valid_date
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""03-11-2000""), expected: true },
     { actual: candidate(""15-01-2012""), expected: false },
     { actual: candidate(""04-0-2040""), expected: false },
     { actual: candidate(""06-04-2020""), expected: true },
     { actual: candidate(""01-01-2007""), expected: true },
     { actual: candidate(""03-32-2011""), expected: false },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""04-31-3000""), expected: false },
     { actual: candidate(""06-06-2005""), expected: true },
     { actual: candidate(""21-31-2000""), expected: false },
     { actual: candidate(""04-12-2003""), expected: true },
     { actual: candidate(""04122003""), expected: false },
     { actual: candidate(""20030412""), expected: false },
     { actual: candidate(""2003-04""), expected: false },
     { actual: candidate(""2003-04-12""), expected: false },
     { actual: candidate(""04-2003""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_126,bos_Latn,go_test.go,"package is_sorted_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //Pretpostavimo da nema negativnih brojeva i samo cjelokupnih brojeva.//Ako je popis u više od jednog duplikata, //Ako je data lista brojeva, vrati ih, raspoređene ili ne.// >>> is_sorted([]int{5})
// true
// >>> is_sorted([]int{1, 2, 3, 4, 5})
// true
// >>> is_sorted([]int{1, 3, 2, 4, 5})
// false
// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})
// true
// >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})
// true
// >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})
// false
// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})
// true
// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})
// false
func is_sorted(lst []int) bool {
","func is_sorted(lst []int) bool {
    if len(lst) <= 1 {
        return true
    }
    
    duplicateCount := make(map[int]int)

    for i := 0; i < len(lst)-1; i++ {
        if lst[i] > lst[i+1] {
            return false
        }
        duplicateCount[lst[i]]++
        if duplicateCount[lst[i]] > 1 {
            return false
        }
    }
    
    // Check the last element for duplicate
    duplicateCount[lst[len(lst)-1]]++
    if duplicateCount[lst[len(lst)-1]] > 1 {
        return false
    }

    return true
}","func TestIs_Sorted(t *testing.T) {
  candidate := is_sorted
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },
     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },
     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },
     { actual: candidate([]int{}), expected: true },
     { actual: candidate([]int{1}), expected: true },
     { actual: candidate([]int{3, 2, 1}), expected: false },
     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },
     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },
     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_127,bos_Latn,go_test.go,"package intersection_test

import (
    ""testing""
    ""fmt""
)

//[input/output] uzorci: //Ako se dva intervala ne prekidaju, vrati ""NO"".//U suprotnom, vrati ""NE"". //Ako je dužina presjeka prvi broj, vrati ""DA"", //koji je dužina 1, koji nije prost broj.//Primjer, presjek intervala (1, 3), (2, 4) je (2, 3) //Interval je prvi broj.//Vaš zadatak je da odredite da li je dužina presjeka ove dvije //Za svaki dat interval, pretpostavlja se da je njegov početak manji ili jednak njegovom kraju.//uključuje i početak i kraj. //Dat interval je zatvoren, što znači da je interval (početak, kraj) //gdje je svaki interval par cijelih brojeva. Na primer, interval = (početak, kraj) = (1, 2).//Dobićete dva intervala.// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})
// ""NO""
// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})
// ""NO""
// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})
// ""YES""
func intersection(interval1 []interface{}, interval2 []interface{}) string {
","package intersection_test

import (
	""testing""
)

// Helper function to determine if a number is prime
func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	if num == 2 {
		return true
	}
	if num%2 == 0 {
		return false
	}
	for i := 3; i*i <= num; i += 2 {
		if num%i == 0 {
			return false
		}
	}
	return true
}

func intersection(interval1 []interface{}, interval2 []interface{}) string {
	start1, end1 := interval1[0].(int), interval1[1].(int)
	start2, end2 := interval2[0].(int), interval2[1].(int)

	// Determine the intersection of two intervals
	intersectStart := max(start1, start2)
	intersectEnd := min(end1, end2)

	if intersectStart > intersectEnd {
		return ""NO""
	}

	// The length of intersection is end - start
	lengthOfIntersection := intersectEnd - intersectStart
	if isPrime(lengthOfIntersection) {
		return ""YES""
	}
	return ""NO""
}

// Helper function to find the maximum of two integers
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Helper function to find the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func TestIntersection(t *testing.T) {
	if intersection([]interface{}{1, 2}, []interface{}{2, 3}) != ""NO"" {
		t.Error(""Expected NO"")
	}
	if intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != ""NO"" {
		t.Error(""Expected NO"")
	}
	if intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != ""YES"" {
		t.Error(""Expected YES"")
	}
}","func TestIntersection(t *testing.T) {
  candidate := intersection
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: ""NO"" },
     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: ""NO"" },
     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: ""YES"" },
     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: ""YES"" },
     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: ""NO"" },
     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: ""NO"" },
     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: ""NO"" },
     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: ""NO"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_129,bos_Latn,go_test.go,"package minPath_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Vraća poresku listu vrijednosti u ćelijama kroz koje prolazi minimalna putanja. //Garantujem da je odgovor jedinstven.//lst_A[j] = lst_B[j].//tako da lst_A[i] < lst_B[i] i za bilo koji j (1 <= j < i) imamo //nego lst_B, drugim riječima, postoji cjeloviti indeks i (1 <= i <= k) //kroz (nazovimo ih lst_A i lst_B), lst_A je leksikografski manje //Nakon što napravimo poreske liste vrijednosti u ćelijama koje A i B idu //Put A (dužine k) se smatra manjim od puta B (dužine k) ako //Ne možeš da se skloniš od mreže.//nužno različiti).//Napominjemo da put dužine k znači da se posećuje tačno k ćelija (ne //ćelija. //Drugim riječima, možete ići u ćelije koje dijele rub sa vama sadašnjim //iz bilo koje ćelije, i u svakom koraku možete se preseliti na bilo koju od susjednih ćelija, //Morate naći minimalni put dužine k u mreži.//uključivo se pojavljuje tačno jednom u ćelijama mreže. //Svaka cijela broj u rasponu [1, N * N] //S obzirom na mrežu sa N redova i N kolona (N >= 2) i pozitivan cjelokupni broj k, // >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)
// []int{1, 2, 1}
// >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)
// []int{1}
func minPath(grid [][]int, k int) []int {
","package minPath_test

import (
    ""sort""
)

func minPath(grid [][]int, k int) []int {
    n := len(grid)
    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}
    
    var dfs func(x, y, length int, path []int)
    var minPath []int
    minPath = make([]int, k)
    for i := 0; i < k; i++ {
        minPath[i] = n*n + 1
    }

    dfs = func(x, y, length int, path []int) {
        if length == k {
            if isLess(path, minPath) {
                copy(minPath, path)
            }
            return
        }
        
        for _, dir := range directions {
            nx, ny := x+dir[0], y+dir[1]
            if nx >= 0 && ny >= 0 && nx < n && ny < n {
                path[length] = grid[nx][ny]
                dfs(nx, ny, length+1, path)
            }
        }
    }
    
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            path := make([]int, k)
            path[0] = grid[i][j]
            dfs(i, j, 1, path)
        }
    }
    
    return minPath
}

func isLess(a, b []int) bool {
    for i := 0; i < len(a); i++ {
        if a[i] < b[i] {
            return true
        }
        if a[i] > b[i] {
            return false
        }
    }
    return false
}","func TestMinpath(t *testing.T) {
  candidate := minPath
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },
     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },
     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },
     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },
     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },
     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },
     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },
     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },
     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },
     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_130,bos_Latn,go_test.go,"package tri_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Prvi n + 1 brojevi Tribonaccijevog niza.//Ako vam je dat ne-negativan cijeli broj n, morate vratiti listu //= 2 + 3 + 3 = 8 //tri(3) = tri(2) + tri(1) + tri(4) //tri(4) = 3 //tri(2) = 1 + (2 / 2) = 2 //Na primer: //tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), ako je n neparno. //tri (n) = 1 + n / 2, ako je n parna. //tri(1) = 3 //Tribonaćina sekvenca je definisana ponavljanjem: //Međutim, ono što ljudi ne znaju je Tribonačkijev niz.//Svi znaju za Fibonačijev niz, matematičari su ga proučavali u dubini u // >>> tri(3)
// []int{1, 3, 2, 8}
func tri(n int) []int {
","func tri(n int) []int {
    if n < 0 {
        return []int{}
    }
    sequence := make([]int, n+1)
    sequence[0] = 1 // tri(0) is not defined in problem, let's start with tri(1)
    if n >= 1 {
        sequence[1] = 3
    }
    for i := 2; i <= n; i++ {
        if i%2 == 0 {
            sequence[i] = 1 + i/2
        } else {
            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)
        }
    }
    return sequence
}

func getNextTribonacci(n int) int {
    if n%2 == 0 {
        return 1 + n/2
    }
    return getNextTribonacciRec(n+1)
}

func getNextTribonacciRec(n int) int {
    triNext := make([]int, n+1)
    triNext[0] = 1 // again assuming some base start
    if n >= 1 {
        triNext[1] = 3
    }
    for i := 2; i <= n; i++ {
        if i%2 == 0 {
            triNext[i] = 1 + i/2
        } else {
            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)
        }
    }
    return triNext[n]
}","func TestTri(t *testing.T) {
  candidate := tri
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: []int{1, 3, 2, 8} },
     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },
     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },
     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },
     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },
     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },
     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },
     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },
     { actual: candidate(0), expected: []int{1} },
     { actual: candidate(1), expected: []int{1, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_131,bos_Latn,go_test.go,"package digits_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Vrati 0 ako su sve cifre parne. //Ako je dat pozitivan cijeli broj n, vratite proizvod neparnih cifara. // >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
func digits(n int) int {
","product := 1
    hasOdd := false

    for n > 0 {
        digit := n % 10
        if digit%2 != 0 {
            product *= digit
            hasOdd = true
        }
        n /= 10
    }

    if hasOdd {
        return product
    }
    return 0
}","func TestDigits(t *testing.T) {
  candidate := digits
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 5 },
     { actual: candidate(54), expected: 5 },
     { actual: candidate(120), expected: 1 },
     { actual: candidate(5014), expected: 5 },
     { actual: candidate(98765), expected: 315 },
     { actual: candidate(5576543), expected: 2625 },
     { actual: candidate(2468), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_132,bos_Latn,go_test.go,"package is_nested_test

import (
    ""testing""
    ""fmt""
)

//gdje je najmanje jedna zagrada u potporednosti ugnezdena. //Funkcija treba da vrati vrijednost true ako i samo ako postoji valjana potprateća zagrada //Stvori funkciju koja uzima niz kao ulaz koji sadrži samo kvadratne zagrade.// >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
func is_nested(myString string) bool {
","func is_nested(myString string) bool {
	stack := []rune{}
	nestingFound := false

	for _, char := range myString {
		if char == '[' {
			stack = append(stack, char)
		} else if char == ']' {
			if len(stack) > 0 {
				stack = stack[:len(stack)-1]
				if len(stack) > 0 {
					nestingFound = true
				}
			}
		}
	}

	return nestingFound
}","func TestIs_Nested(t *testing.T) {
  candidate := is_nested
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""[[]]""), expected: true },
     { actual: candidate(""[]]]]]]][[[[[]""), expected: false },
     { actual: candidate(""[][]""), expected: false },
     { actual: candidate(""[]""), expected: false },
     { actual: candidate(""[[[[]]]]""), expected: true },
     { actual: candidate(""[]]]]]]]]]]""), expected: false },
     { actual: candidate(""[][][[]]""), expected: true },
     { actual: candidate(""[[]""), expected: false },
     { actual: candidate(""[]]""), expected: false },
     { actual: candidate(""[[]][[""), expected: true },
     { actual: candidate(""[[][]]""), expected: true },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""[[[[[[[[""), expected: false },
     { actual: candidate(""]]]]]]]]""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_133,bos_Latn,go_test.go,"package sum_squares_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Okruži svaki element na listi na gornji int{}{}}}{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}//Morate vratiti zbir kvadrata brojeva na datoj listi, //Dobiješ listu brojeva.// >>> lst([]float64{1.0, 2.0, 3.0})
// 14
// >>> lst([]float64{1.0, 4.0, 9.0})
// 98
// >>> lst([]float64{1.0, 3.0, 5.0, 7.0})
// 84
// >>> lst([]float64{1.4, 4.2, 0.0})
// 29
// >>> lst([]float64{-2.4, 1.0, 1.0})
// 6
func sum_squares(lst []float64) int {
","package sum_squares_test

import (
	""math""
)

func sum_squares(lst []float64) int {
	sum := 0
	for _, num := range lst {
		ceiledNum := math.Ceil(num)
		sum += int(ceiledNum * ceiledNum)
	}
	return sum
}","func TestSum_Squares(t *testing.T) {
  candidate := sum_squares
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },
     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },
     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },
     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },
     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },
     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },
     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },
     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },
     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },
     { actual: candidate([]float64{0.0}), expected: 0 },
     { actual: candidate([]float64{-1.0}), expected: 1 },
     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_134,bos_Latn,go_test.go,"package check_if_last_char_is_a_letter_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Napomena: ""reč"" je grupa znakova odvojenih prostorom.//dio riječi, i pogrešno inače.//je alfabetski znak i nije //Stvori funkciju koja vraća vrijednost true ako je poslednji znak // >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
func check_if_last_char_is_a_letter(txt string) bool {
","package check_if_last_char_is_a_letter_test

import (
    ""testing""
    ""unicode""
)

func check_if_last_char_is_a_letter(txt string) bool {
    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {
        return false
    }
    
    lastCharIndex := len(txt) - 1
    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {
        lastCharIndex--
    }
    
    if lastCharIndex < 0 {
        return false
    }

    if !unicode.IsLetter(rune(txt[lastCharIndex])) {
        return false
    }
    
    // Check if it's part of a word by looking at the previous character
    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {
        return false
    }

    return true
}

func TestCheckIfLastCharIsALetter(t *testing.T) {
    cases := []struct {
        input    string
        expected bool
    }{
        {""apple pie"", false},
        {""apple pi e"", true},
        {""apple pi e "", false},
        {"""", false},
        {""hello world"", true},
        {""a "", true},
        {"" a"", true},
        {""abc"", false},
        {""abc "", false},
    }

    for _, c := range cases {
        t.Run(c.input, func(t *testing.T) {
            result := check_if_last_char_is_a_letter(c.input)
            if result != c.expected {
                t.Errorf(""Expected %v, got %v for input \""%s\"""", c.expected, result, c.input)
            }
        })
    }
}","func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {
  candidate := check_if_last_char_is_a_letter
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""apple""), expected: false },
     { actual: candidate(""apple pi e""), expected: true },
     { actual: candidate(""eeeee""), expected: false },
     { actual: candidate(""A""), expected: true },
     { actual: candidate(""Pumpkin pie ""), expected: false },
     { actual: candidate(""Pumpkin pie 1""), expected: false },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""eeeee e ""), expected: false },
     { actual: candidate(""apple pie""), expected: false },
     { actual: candidate(""apple pi e ""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_135,bos_Latn,go_test.go,"package can_arrange_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Duplicirane vrednosti.//Ako ne postoji takav element onda vrati -1.//nije veći od ili jednak elementu koji je neposredno ispred njega.//Stvori funkciju koja vraća najveći indeks elementa koji // >>> can_arrange([]int{1, 2, 4, 3, 5})
// 3
// >>> can_arrange([]int{1, 2, 3})
// -1
func can_arrange(arr []int) int {
","package can_arrange_test

func can_arrange(arr []int) int {
    for i := len(arr) - 1; i > 0; i-- {
        if arr[i] < arr[i-1] {
            return i
        }
    }
    return -1
}","func TestCan_Arrange(t *testing.T) {
  candidate := can_arrange
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },
     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },
     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },
     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },
     { actual: candidate([]int{}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_136,bos_Latn,go_test.go,"package largest_smallest_integers_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Ako nema negativnih ili pozitivnih cijelih brojeva, vrati ih kao nil.//Pozitivnih cijela brojeva u listi.//Najveći od negativnih cijelih brojeva, a ""b"" je najmanji //Stvori funkciju koja vraća listu (a, b), gdje je 'a' // >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})
// []interface{}{nil, 1}
// >>> largest_smallest_integers([]int{})
// []interface{}{nil, nil}
// >>> largest_smallest_integers([]int{0})
// []interface{}{nil, nil}
func largest_smallest_integers(lst []int) []interface{} {
","func largest_smallest_integers(lst []int) []interface{} {
    var largestNegative *int
    var smallestPositive *int

    for _, num := range lst {
        if num < 0 {
            if largestNegative == nil || num > *largestNegative {
                largestNegative = new(int)
                *largestNegative = num
            }
        } else if num > 0 {
            if smallestPositive == nil || num < *smallestPositive {
                smallestPositive = new(int)
                *smallestPositive = num
            }
        }
    }

    var result = []interface{}{nil, nil}
    if largestNegative != nil {
        result[0] = *largestNegative
    }
    if smallestPositive != nil {
        result[1] = *smallestPositive
    }

    return result
}","func TestLargest_Smallest_Integers(t *testing.T) {
  candidate := largest_smallest_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },
     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },
     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },
     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },
     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },
     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },
     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },
     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },
     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },
     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },
     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_138,bos_Latn,go_test.go,"package is_equal_to_sum_even_test

import (
    ""testing""
    ""fmt""
)

//Primjer //Procijenite da li se dat broj n može zapisati kao zbroj tačno 4 pozitivna parna broja.// >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
func is_equal_to_sum_even(n int) bool {
","package is_equal_to_sum_even_test

import (
    ""testing""
    ""fmt""
)

// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
// Example
// >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
func is_equal_to_sum_even(n int) bool {
    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8
    // Therefore, n must be at least 8 and n must be even
    return n >= 8 && n%2 == 0
}

// Testing the function
func TestIsEqualToSumEven(t *testing.T) {
    cases := []struct {
        n      int
        expect bool
    }{
        {4, false},
        {6, false},
        {8, true},
        {10, true},
        {12, true},
        {14, true},
        {16, true},
    }

    for _, c := range cases {
        result := is_equal_to_sum_even(c.n)
        if result != c.expect {
            t.Errorf(""is_equal_to_sum_even(%d) == %v, expect %v"", c.n, result, c.expect)
        } else {
            fmt.Printf(""Success: is_equal_to_sum_even(%d) == %v\n"", c.n, result)
        }
    }
}","func TestIs_Equal_To_Sum_Even(t *testing.T) {
  candidate := is_equal_to_sum_even
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(4), expected: false },
     { actual: candidate(6), expected: false },
     { actual: candidate(8), expected: true },
     { actual: candidate(10), expected: true },
     { actual: candidate(11), expected: false },
     { actual: candidate(12), expected: true },
     { actual: candidate(13), expected: false },
     { actual: candidate(16), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_139,bos_Latn,go_test.go,"package special_factorial_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //gdje je n > 0 //brazilski_faktorik (n) = n! * (n-1)! * (n-2)! * ... * 1! //Brazilski faktorijal je definisan kao: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
func special_factorial(n int) int {
","package special_factorial_test

import (
    ""testing""
    ""fmt""
)

func special_factorial(n int) int {
    if n <= 0 {
        return 1
    }
    
    result := 1
    for i := 1; i <= n; i++ {
        result *= factorial(i)
    }
    
    return result
}

func factorial(x int) int {
    if x == 0 {
        return 1
    }
    prod := 1
    for i := 1; i <= x; i++ {
        prod *= i
    }
    return prod
}

func TestSpecialFactorial(t *testing.T) {
    cases := []struct {
        input    int
        expected int
    }{
        {4, 288},      // 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288
        {3, 12},       // 3! * 2! * 1! = 6 * 2 * 1 = 12
        {2, 2},        // 2! * 1! = 2 * 1 = 2
        {1, 1},        // 1! = 1
        {0, 1},        // Edge case for n=0, considered as 1 for special factorial
    }

    for _, c := range cases {
        result := special_factorial(c.input)
        if result != c.expected {
            t.Errorf(""special_factorial(%d) == %d, want %d"", c.input, result, c.expected)
        }
    }
}

func main() {
    fmt.Println(special_factorial(4)) // Output: 288
    fmt.Println(special_factorial(3)) // Output: 12
}","func TestSpecial_Factorial(t *testing.T) {
  candidate := special_factorial
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(4), expected: 288 },
     { actual: candidate(5), expected: 34560 },
     { actual: candidate(7), expected: 125411328000 },
     { actual: candidate(1), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_140,bos_Latn,go_test.go,"package fix_spaces_test

import (
    ""testing""
    ""fmt""
)

//Onda zameni sve uzastopne prostore sa - //i ako niz ima više od 2 uzastopna prostora, //Ako je dat niz teksta, zameni sve prostore sa podvlačenim znakovima, // >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
func fix_spaces(text string) string {
","package fix_spaces_test

import (
    ""strings""
    ""testing""
)

func fix_spaces(text string) string {
    var result string
    spaceCount := 0

    for _, char := range text {
        if char == ' ' {
            spaceCount++
        } else {
            if spaceCount == 1 {
                result += ""_""
            } else if spaceCount > 1 {
                result += ""-""
            }
            result += string(char)
            spaceCount = 0
        }
    }

    // Handle trailing spaces
    if spaceCount == 1 {
        result += ""_""
    } else if spaceCount > 1 {
        result += ""-""
    }

    return result
}

func TestFixSpaces(t *testing.T) {
    cases := []struct {
        input    string
        expected string
    }{
        {"" Example"", ""Example""},
        {"" Example 1"", ""Example_1""},
        {"" Example 2"", ""_Example_2""},
        {"" Example 3"", ""_Example-3""},
        {"" Hello    world"", ""_Hello-world""},
        {""   Leading spaces"", ""-Leading_spaces""},
    }

    for _, c := range cases {
        result := fix_spaces(c.input)
        if result != c.expected {
            t.Errorf(""fix_spaces(%q) == %q, expected %q"", c.input, result, c.expected)
        }
    }
}","func TestFix_Spaces(t *testing.T) {
  candidate := fix_spaces
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Example""), expected: ""Example"" },
     { actual: candidate(""Mudasir Hanif ""), expected: ""Mudasir_Hanif_"" },
     { actual: candidate(""Yellow Yellow  Dirty  Fellow""), expected: ""Yellow_Yellow__Dirty__Fellow"" },
     { actual: candidate(""Exa   mple""), expected: ""Exa-mple"" },
     { actual: candidate(""   Exa 1 2 2 mple""), expected: ""-Exa_1_2_2_mple"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_141,bos_Latn,go_test.go,"package file_name_check_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //- Podstring nakon tačke treba da bude jedan od ovih: ['txt', 'exe', 'dll'] //latinski alfabet ('a'-'z' i 'A'-'Z'). //- Podstrin pre tačke ne bi trebao biti prazan, i počinje sa slovom od //- Ime datoteke sadrži tačno jednu tačku.//- Naziv datoteke ne smije imati više od tri cifre ('0'-'9'). //su ispunjeni: //Ime datoteke se smatra validnim ako i samo ako su ispunjeni svi sledeći uslovi://""Da"" ako je ime datoteke ispravno, a u suprotnom daje ""Ne"". //Stvori funkciju koja uzima niz koji predstavlja ime datoteke i vraća // >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
func file_name_check(file_name string) string {
","package file_name_check_test

import (
    ""strings""
    ""unicode""
)

func file_name_check(file_name string) string {
    if len(file_name) == 0 {
        return ""No""
    }

    // Condition 2: Check for exactly one dot
    dotIndex := strings.LastIndex(file_name, ""."")
    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {
        return ""No""
    }

    // Split the file name into two parts
    namePart := file_name[:dotIndex]
    extension := file_name[dotIndex+1:]

    // Condition 4: Check the extension
    validExtensions := map[string]bool{
        ""txt"": true,
        ""exe"": true,
        ""dll"": true,
    }
    if !validExtensions[extension] {
        return ""No""
    }

    // Condition 3: Check the first character before the dot
    if !unicode.IsLetter(rune(namePart[0])) {
        return ""No""
    }

    // Condition 1: Count the digits in the file name
    digitCount := 0
    for _, char := range namePart {
        if unicode.IsDigit(char) {
            digitCount++
        }
    }
    if digitCount > 3 {
        return ""No""
    }

    // If all conditions are met, return ""Yes""
    return ""Yes""
}","func TestFile_Name_Check(t *testing.T) {
  candidate := file_name_check
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""example.txt""), expected: ""Yes"" },
     { actual: candidate(""1example.dll""), expected: ""No"" },
     { actual: candidate(""s1sdf3.asd""), expected: ""No"" },
     { actual: candidate(""K.dll""), expected: ""Yes"" },
     { actual: candidate(""MY16FILE3.exe""), expected: ""Yes"" },
     { actual: candidate(""His12FILE94.exe""), expected: ""No"" },
     { actual: candidate(""_Y.txt""), expected: ""No"" },
     { actual: candidate(""?aREYA.exe""), expected: ""No"" },
     { actual: candidate(""/this_is_valid.dll""), expected: ""No"" },
     { actual: candidate(""this_is_valid.wow""), expected: ""No"" },
     { actual: candidate(""this_is_valid.txt""), expected: ""Yes"" },
     { actual: candidate(""this_is_valid.txtexe""), expected: ""No"" },
     { actual: candidate(""#this2_i4s_5valid.ten""), expected: ""No"" },
     { actual: candidate(""@this1_is6_valid.exe""), expected: ""No"" },
     { actual: candidate(""this_is_12valid.6exe4.txt""), expected: ""No"" },
     { actual: candidate(""all.exe.txt""), expected: ""No"" },
     { actual: candidate(""I563_No.exe""), expected: ""Yes"" },
     { actual: candidate(""Is3youfault.txt""), expected: ""Yes"" },
     { actual: candidate(""no_one#knows.dll""), expected: ""Yes"" },
     { actual: candidate(""1I563_Yes3.exe""), expected: ""No"" },
     { actual: candidate(""I563_Yes3.txtt""), expected: ""No"" },
     { actual: candidate(""final..txt""), expected: ""No"" },
     { actual: candidate(""final132""), expected: ""No"" },
     { actual: candidate(""_f4indsartal132.""), expected: ""No"" },
     { actual: candidate("".txt""), expected: ""No"" },
     { actual: candidate(""s.""), expected: ""No"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_142,bos_Latn,go_test.go,"package sum_squares_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Ako je indeks u popisu, funkcija će vratiti zbir svih unosa.//multiplikator 3 i će kubirati cijeli broj ako je njegov indeks multiplikator 4 a ne multiplikator 3. Funkcija neće //Ova funkcija će uzeti listu cijelih brojeva. Za sve unose u listi, funkcija će kvadrirati cijelim brojem ako je njen indeks a //""      // >>> lst
// []int{1, 2, 3}
// >>> lst
// int{}
// >>> lst
// []int{-1, -5, 2, -1, -5}
func sum_squares(lst []int) int {
","package sum_squares_test

import (
    ""testing""
)

func sum_squares(lst []int) int {
    sum := 0
    for i, val := range lst {
        if i%3 == 0 {
            sum += val * val
        } else if i%4 == 0 {
            sum += val * val * val
        } else {
            sum += val
        }
    }
    return sum
}

func TestSumSquares(t *testing.T) {
    tests := []struct {
        lst      []int
        expected int
    }{
        {[]int{1, 2, 3}, 10},   // 1^2 + 2 + 3 = 10
        {[]int{}, 0},           // empty list
        {[]int{-1, -5, 2, -1, -5}, 0}, // (-1)^2 + (-5)^3 + 2 + (-1) = -118
    }

    for _, test := range tests {
        result := sum_squares(test.lst)
        if result != test.expected {
            t.Errorf(""sum_squares(%v) = %d; expected %d"", test.lst, result, test.expected)
        }
    }
}","func TestSum_Squares(t *testing.T) {
  candidate := sum_squares
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: 6 },
     { actual: candidate([]int{1, 4, 9}), expected: 14 },
     { actual: candidate([]int{}), expected: 0 },
     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },
     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },
     { actual: candidate([]int{0}), expected: 0 },
     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },
     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },
     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },
     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },
     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_143,bos_Latn,go_test.go,"package words_in_sentence_test

import (
    ""testing""
    ""fmt""
)

//Primjer 1: //Redosled reči u novom nizu treba da bude isti kao i u originalnom.//čije su dužine prosti brojevi, //i morate vratiti niz koji sadrži riječi iz originalne rečenice, //rečenica sadrži neke reči odvojene razmakom, //Dobiješ niz koji predstavlja rečenicu, // >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
func words_in_sentence(sentence string) string {
","package words_in_sentence_test

import (
    ""strings""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n == 2 {
        return true
    }
    if n%2 == 0 {
        return false
    }
    for i := 3; i*i <= n; i += 2 {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func words_in_sentence(sentence string) string {
    words := strings.Split(sentence, "" "")
    var result []string

    for _, word := range words {
        if isPrime(len(word)) {
            result = append(result, word)
        }
    }

    return strings.Join(result, "" "")
}","func TestWords_In_Sentence(t *testing.T) {
  candidate := words_in_sentence
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""This is a test""), expected: ""is"" },
     { actual: candidate(""lets go for swimming""), expected: ""go for"" },
     { actual: candidate(""there is no place available here""), expected: ""there is no place"" },
     { actual: candidate(""Hi I am Hussein""), expected: ""Hi am Hussein"" },
     { actual: candidate(""go for it""), expected: ""go for it"" },
     { actual: candidate(""here""), expected: """" },
     { actual: candidate(""here is""), expected: ""is"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_144,bos_Latn,go_test.go,"package simplify_test

import (
    ""testing""
    ""fmt""
)

//Možete pretpostaviti da su x i n valjani frakcije, i nemaju nule kao imenovača.//<brojnik>/<nazivnik> gdje su i brojnik i nazivnik pozitivni celi brojevi. //i x i n su nizovi frakcija i imaju sljedeći format, //x * n. Funkcija vraća vrijednost true ako je x * n cijela broj i false //Vaš zadatak je da implementirate funkciju koja će pojednostaviti izraz.// >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
func simplify(x string, n string) bool {
","package simplify_test

import (
    ""strconv""
    ""strings""
    ""testing""
)

func simplify(x string, n string) bool {
    // Split the input strings into numerators and denominators
    xParts := strings.Split(x, ""/"")
    nParts := strings.Split(n, ""/"")

    // Convert the string parts to integers
    xNumerator, _ := strconv.Atoi(xParts[0])
    xDenominator, _ := strconv.Atoi(xParts[1])
    nNumerator, _ := strconv.Atoi(nParts[0])
    nDenominator, _ := strconv.Atoi(nParts[1])

    // Perform the multiplication (x * n) = (xNumerator/nDenominator) * (nNumerator/nDenominator)
    resultNumerator := xNumerator * nNumerator
    resultDenominator := xDenominator * nDenominator

    // Check if the result is a whole number
    return resultNumerator%resultDenominator == 0
}

func TestSimplify(t *testing.T) {
    if !simplify(""1/5"", ""5/1"") {
        t.Fatalf(""Expected true, got false"")
    }
    if simplify(""1/6"", ""2/1"") {
        t.Fatalf(""Expected false, got true"")
    }
    if simplify(""7/10"", ""10/2"") {
        t.Fatalf(""Expected false, got true"")
    }
}","func TestSimplify(t *testing.T) {
  candidate := simplify
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""1/5"", ""5/1""), expected: true },
     { actual: candidate(""1/6"", ""2/1""), expected: false },
     { actual: candidate(""5/1"", ""3/1""), expected: true },
     { actual: candidate(""7/10"", ""10/2""), expected: false },
     { actual: candidate(""2/10"", ""50/10""), expected: true },
     { actual: candidate(""7/2"", ""4/2""), expected: true },
     { actual: candidate(""11/6"", ""6/1""), expected: true },
     { actual: candidate(""2/3"", ""5/2""), expected: false },
     { actual: candidate(""5/2"", ""3/5""), expected: false },
     { actual: candidate(""2/4"", ""8/4""), expected: true },
     { actual: candidate(""2/4"", ""4/2""), expected: true },
     { actual: candidate(""1/5"", ""5/1""), expected: true },
     { actual: candidate(""1/5"", ""1/5""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_145,bos_Latn,go_test.go,"package order_by_points_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Pored toga, oni su redovani na osnovu njihovog indeksa u originalnoj listi.//Napomena: ako postoji nekoliko stavki sa sličnom zbirom njihovih cifara, //U poretku prema zbrojima njihovih cifara.//Napiši funkciju koja sorte datog popisa cijelih brojeva.// >>> order_by_points([]int{1, 11, -1, -11, -12})
// []int{-1, -11, 1, -12, 11}
// >>> order_by_points([]int{})
// []int{}
func order_by_points(nums []int) []int {
","package order_by_points_test

import (
	""testing""
	""fmt""
	""sort""
	""strconv""
)

func digitSum(n int) int {
	n = abs(n) // Consider the absolute value for digit sum
	sum := 0
	for n > 0 {
		sum += n % 10
		n /= 10
	}
	return sum
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func order_by_points(nums []int) []int {
	type numWithIndex struct {
		num   int
		index int
	}

	numsWithIndex := make([]numWithIndex, len(nums))
	for i, num := range nums {
		numsWithIndex[i] = numWithIndex{num, i}
	}

	sort.Slice(numsWithIndex, func(i, j int) bool {
		sumI := digitSum(numsWithIndex[i].num)
		sumJ := digitSum(numsWithIndex[j].num)
		if sumI == sumJ {
			return numsWithIndex[i].index < numsWithIndex[j].index
		}
		return sumI < sumJ
	})

	sortedNums := make([]int, len(nums))
	for i, nwi := range numsWithIndex {
		sortedNums[i] = nwi.num
	}

	return sortedNums
}

func TestOrderByPoints(t *testing.T) {
	testCases := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},
		{[]int{}, []int{}},
	}

	for _, tc := range testCases {
		result := order_by_points(tc.input)
		if !equal(result, tc.expected) {
			t.Errorf(""Expected %v, but got %v"", tc.expected, result)
		}
	}
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestOrder_By_Points(t *testing.T) {
  candidate := order_by_points
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },
     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },
     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_146,bos_Latn,go_test.go,"package specialFilter_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Prva i posljednja cifra broja su neparne (1, 3, 5, 7, 9).//broj elemenata na listi koji su veći od 10 i oba //Napišite funkciju koja uzima listu brojeva kao ulaz i vraća // >>> specialFilter([]int{15, -73, 14, -15})
// 1
// >>> specialFilter([]int{33, -2, -3, 45, 21, 109})
// 2
func specialFilter(nums []int) int {
","package specialFilter_test

import (
	""testing""
)

func specialFilter(nums []int) int {
	count := 0
	for _, num := range nums {
		// Consider the absolute value of the number
		absNum := abs(num)
		if absNum > 10 {
			strNum := fmt.Sprintf(""%d"", absNum)
			firstDigit := strNum[0]
			lastDigit := strNum[len(strNum)-1]
			if isOdd(firstDigit) && isOdd(lastDigit) {
				count++
			}
		}
	}
	return count
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func isOdd(digit byte) bool {
	return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'
}

func TestSpecialFilter(t *testing.T) {
	tests := []struct {
		input    []int
		expected int
	}{
		{[]int{15, -73, 14, -15}, 1},
		{[]int{33, -2, -3, 45, 21, 109}, 2},
		{[]int{8, 4, 12, 55, 99, 111}, 1},
		{[]int{-11, -22, -33, -44, -55}, 1},
	}

	for _, test := range tests {
		result := specialFilter(test.input)
		if result != test.expected {
			t.Errorf(""specialFilter(%v) = %d; want %d"", test.input, result, test.expected)
		}
	}
}","func TestSpecialfilter(t *testing.T) {
  candidate := specialFilter
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },
     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },
     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },
     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },
     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },
     { actual: candidate([]int{1}), expected: 0 },
     { actual: candidate([]int{}), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_147,bos_Latn,go_test.go,"package get_max_triples_test

import (
    ""testing""
    ""fmt""
)

//Primjer://a a[i] + a[j] + a[k] je višekratnik od 3. //Vrati broj trojnika (a[i], a[j], a[k]) od a gdje je i < j < k, //Za svako i (1 ≤ i ≤ n), vrijednost a[i] = i * i - i + 1. //Dobićete pozitivan cijeli broj n. Morate stvoriti cijeli broj lista a dužine n.// >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
func get_max_triples(n int) int {
","package get_max_triples_test

import (
    ""testing""
)

func get_max_triples(n int) int {
    a := make([]int, n)
    for i := 1; i <= n; i++ {
        a[i-1] = i*i - i + 1
    }
    
    count := 0
    
    for i := 0; i < n-2; i++ {
        for j := i + 1; j < n-1; j++ {
            for k := j + 1; k < n; k++ {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count++
                }
            }
        }
    }
    
    return count
}

func TestGetMaxTriples(t *testing.T) {
    if get_max_triples(5) != 1 {
        t.Errorf(""Expected 1 but got %d"", get_max_triples(5))
    }
}","func TestGet_Max_Triples(t *testing.T) {
  candidate := get_max_triples
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 1 },
     { actual: candidate(6), expected: 4 },
     { actual: candidate(10), expected: 36 },
     { actual: candidate(100), expected: 53361 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_148,bos_Latn,go_test.go,"package bf_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //nisu tačna imena planeta.//Funkcija treba da vrati praznu listu ako je planet1 ili planet2 //blizina suncu.//Nalazi se između orbite planete 1 i orbite planete 2, sortiran po //Funkcija treba da vrati listu sa svim planetama čije su orbite //Napišite funkciju koja uzima dva imena planeta kao nizove planet1 i planet2. //Uran, Neptun.//je Merkur, sljedeći je Venera, onda Zemlja, Mars, Jupiter, Saturn, //U našem solarnom sistemu ima osam planeta: najbliža Suncu.// >>> bf(""Jupiter"", ""Neptune"")
// []interface{}{""Saturn"", ""Uranus""}
// >>> bf(""Earth"", ""Mercury"")
// ""Venus""
// >>> bf(""Mercury"", ""Uranus"")
// []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}
func bf(planet1 string, planet2 string) []interface{} {
","package bf_test

import (
    ""testing""
    ""fmt""
)

// Define the solar system slice with planets ordered by their proximity to the Sun
var solarSystem = []string{""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""}

func bf(planet1 string, planet2 string) []interface{} {
    index1 := -1
    index2 := -1

    // Find the indices of the given planet names in the solarSystem slice
    for i, planet := range solarSystem {
        if planet == planet1 {
            index1 = i
        }
        if planet == planet2 {
            index2 = i
        }
    }

    // If either planet name is incorrect, return an empty list
    if index1 == -1 || index2 == -1 {
        return []interface{}{}
    }

    // Ensure index1 is less than index2 to find planets between them
    if index1 > index2 {
        index1, index2 = index2, index1
    }

    // Collect and return planets that are located between the two indices
    var planetsBetween []interface{}
    for i := index1 + 1; i < index2; i++ {
        planetsBetween = append(planetsBetween, solarSystem[i])
    }
    
    return planetsBetween
}

func TestBf(t *testing.T) {
    fmt.Println(bf(""Jupiter"", ""Neptune"")) // Should print: []interface{}{""Saturn"", ""Uranus""}
    fmt.Println(bf(""Earth"", ""Mercury""))  // Should print: []interface{}{""Venus""}
    fmt.Println(bf(""Mercury"", ""Uranus"")) // Should print: []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}
}","func TestBf(t *testing.T) {
  candidate := bf
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Jupiter"", ""Neptune""), expected: []interface{}{""Saturn"", ""Uranus""} },
     { actual: candidate(""Earth"", ""Mercury""), expected: []interface{}{""Venus""} },
     { actual: candidate(""Mercury"", ""Uranus""), expected: []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""} },
     { actual: candidate(""Neptune"", ""Venus""), expected: []interface{}{""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""} },
     { actual: candidate(""Earth"", ""Earth""), expected: []interface{}{} },
     { actual: candidate(""Mars"", ""Earth""), expected: []interface{}{} },
     { actual: candidate(""Jupiter"", ""Makemake""), expected: []interface{}{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_149,bos_Latn,go_test.go,"package sorted_list_sum_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //Možete pretpostaviti da će sve reči imati istu dužinu.//Funkcija treba da vrati listu niza u sortiranom redosledu.//Ako su dvije riječi iste dužine, sortiraj listu po abecedi.//Treba da vrati listu sortiranu po tom pravilu.//Redosled liste treba da bude uzlazni prema dužini svake reči, a vi...//i može sadržavati duplikate.//Lista je uvijek lista niza i nikada lista brojeva, //i vraća rezultatnu listu u sortiranom redoslijedu, //briše nizove koji imaju neparne dužine od njega, //Napišite funkciju koja prihvata listu niza kao parametar, // >>> list_sort([]string{""aa"", ""a"", ""aaa""})
// []string{""aa""}
// >>> list_sort([]string{""ab"", ""a"", ""aaa"", ""cd""})
// []string{""ab"", ""cd""}
func sorted_list_sum(lst []string) []string {
","package sorted_list_sum_test

import (
    ""sort""
)

func sorted_list_sum(lst []string) []string {
    // Filter out strings with odd lengths
    filtered := []string{}
    for _, str := range lst {
        if len(str)%2 == 0 {
            filtered = append(filtered, str)
        }
    }

    // Sort the filtered list by length, then alphabetically
    sort.Slice(filtered, func(i, j int) bool {
        if len(filtered[i]) == len(filtered[j]) {
            return filtered[i] < filtered[j]
        }
        return len(filtered[i]) < len(filtered[j])
    })

    return filtered
}","func TestSorted_List_Sum(t *testing.T) {
  candidate := sorted_list_sum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""aa"", ""a"", ""aaa""}), expected: []string{""aa""} },
     { actual: candidate([]string{""school"", ""AI"", ""asdf"", ""b""}), expected: []string{""AI"", ""asdf"", ""school""} },
     { actual: candidate([]string{""d"", ""b"", ""c"", ""a""}), expected: []string{} },
     { actual: candidate([]string{""d"", ""dcba"", ""abcd"", ""a""}), expected: []string{""abcd"", ""dcba""} },
     { actual: candidate([]string{""AI"", ""ai"", ""au""}), expected: []string{""AI"", ""ai"", ""au""} },
     { actual: candidate([]string{""a"", ""b"", ""b"", ""c"", ""c"", ""a""}), expected: []string{} },
     { actual: candidate([]string{""aaaa"", ""bbbb"", ""dd"", ""cc""}), expected: []string{""cc"", ""dd"", ""aaaa"", ""bbbb""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_150,bos_Latn,go_test.go,"package x_or_y_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //a prvo broj i treba da vrati vrednost y u suprotnom. //Jednostavan program koji bi trebao vratiti vrijednost x ako je n // >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
func x_or_y(n int, x int, y int) int {
","package x_or_y_test

import (
    ""testing""
    ""math""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func x_or_y(n int, x int, y int) int {
    if isPrime(n) {
        return x
    }
    return y
}

func TestXOrY(t *testing.T) {
    cases := []struct{
        n, x, y, want int
    }{
        {7, 34, 12, 34},
        {15, 8, 5, 5},
        {2, 10, 20, 10},
        {1, 5, 15, 15},
    }

    for _, c := range cases {
        got := x_or_y(c.n, c.x, c.y)
        if got != c.want {
            t.Errorf(""x_or_y(%d, %d, %d) == %d, want %d"", c.n, c.x, c.y, got, c.want)
        }
    }
}","func TestX_Or_Y(t *testing.T) {
  candidate := x_or_y
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(7, 34, 12), expected: 34 },
     { actual: candidate(15, 8, 5), expected: 5 },
     { actual: candidate(3, 33, 5212), expected: 33 },
     { actual: candidate(1259, 3, 52), expected: 3 },
     { actual: candidate(7919, -1, 12), expected: -1 },
     { actual: candidate(3609, 1245, 583), expected: 583 },
     { actual: candidate(91, 56, 129), expected: 129 },
     { actual: candidate(6, 34, 1234), expected: 1234 },
     { actual: candidate(1, 2, 0), expected: 0 },
     { actual: candidate(2, 2, 0), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_151,bos_Latn,go_test.go,"package double_the_difference_test

import (
    ""testing""
    ""fmt""
)

//Ignorirajte brojeve koji su negativni ili nisu cijevi.//Ako imamo listu brojeva, vratimo zbir kvadrata brojeva.// >>> double_the_difference([]int{1, 3, 2, 0})
// 10
// >>> double_the_difference([]int{-1, -2, 0})
// 0
// >>> double_the_difference([]int{9, -2})
// 81
// >>> double_the_difference([]int{0})
// 0
// If the input list is empty, return 0.
func double_the_difference(lst []float64) int {
","package double_the_difference_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func double_the_difference(lst []float64) int {
    sum := 0
    for _, num := range lst {
        if num >= 0 && math.Mod(num, 1) == 0 {
            intNum := int(num)
            if intNum%2 != 0 {
                sum += intNum * intNum
            }
        }
    }
    return sum
}

func TestDoubleTheDifference(t *testing.T) {
    cases := []struct {
        input []float64
        expected int
    }{
        {input: []float64{1, 3, 2, 0}, expected: 10},
        {input: []float64{-1, -2, 0}, expected: 0},
        {input: []float64{9, -2}, expected: 81},
        {input: []float64{0}, expected: 0},
        {input: []float64{}, expected: 0},
    }

    for _, c := range cases {
        result := double_the_difference(c.input)
        if result != c.expected {
            t.Errorf(""double_the_difference(%v) == %d, want %d"", c.input, result, c.expected)
        } else {
            fmt.Printf(""Test passed for input %v. Result: %d\n"", c.input, result)
        }
    }
}","func TestDouble_The_Difference(t *testing.T) {
  candidate := double_the_difference
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{}), expected: 0 },
     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },
     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },
     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },
     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },
     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },
     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_152,bos_Latn,go_test.go,"package compare_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //vrijednost je 0, a ako nije, vrijednost je apsolutna razlika između pretpostavke i rezultata. //Vrati listu iste dužine koja označava koliko je udaljena svaka od pretpostavki.//Dobićete dvije liste rezultata i nagađanja jednake dužine, gde svaki indeks pokazuje podudaranje.//Vaš zadatak je da utvrdite da li je osoba ispravno pogodila rezultate nekoliko utakmica.//Definitivno vredi zapisati i uporediti.//Osjećanja i misli koje imate u tom trenutku su...//Mislim da svi pamtimo taj osećaj kada je rezultat nekog dugo očekivanog// >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})
// []int{0, 0, 0, 0, 3, 3}
// >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})
// []int{4, 4, 1, 0, 0, 6}
func compare(game []int, guess []int) []int {
","package compare_test

import (
    ""math""
    ""testing""
    ""fmt""
)

func compare(game []int, guess []int) []int {
    result := make([]int, len(game))
    for i := 0; i < len(game); i++ {
        if game[i] == guess[i] {
            result[i] = 0
        } else {
            result[i] = int(math.Abs(float64(game[i] - guess[i])))
        }
    }
    return result
}

func TestCompare(t *testing.T) {
    tests := []struct {
        game  []int
        guess []int
        want  []int
    }{
        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},
        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf(""%v vs %v"", tt.game, tt.guess), func(t *testing.T) {
            got := compare(tt.game, tt.guess)
            for i := range got {
                if got[i] != tt.want[i] {
                    t.Errorf(""compare(%v, %v) = %v; want %v"", tt.game, tt.guess, got, tt.want)
                }
            }
        })
    }
}","func TestCompare(t *testing.T) {
  candidate := compare
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },
     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },
     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },
     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_153,bos_Latn,go_test.go,"package Strongest_Extension_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //(njegova jačina je -1).//return ""Slices.SErviNGSliCes"" jer je ""SErviNGSliCes"" najjača ekstenzija //['SErviNGSliCes', 'Cheese', 'StuFfed'] onda bi trebalo //Na primjer, ako vam je data ""Slice"" kao klasa i lista //Izaberite onaj koji je prvi na listi.//Ako postoje dva ili više produženja iste jačine, treba da se//format: ClassName.StrongestExtensionName. //Treba da nađete najjači nastavak i vratite niz u ovom //u nazivu dodatka, snaga se daje frakcijom CAP - SM. //slova u imenu ekstenzije, a SM neka bude broj malih slova //Snaga proširenja je sljedeća: Neka CAP bude broj velikog slova //Ekstenzije se koriste za učitavanje dodatnih klasa u klasi.//Dobićete ime klase (string) i listu ekstenzija.// >>> Strongest_Extension(""my_class"", []string{""AA"", ""Be"", ""CC""})
// ""my_class.AA""
func Strongest_Extension(class_name string, extensions []string) string {
","func Strongest_Extension(class_name string, extensions []string) string {
    strongestExtension := """"
    maxStrength := -1 << 31

    for _, extension := range extensions {
        capCount, smCount := 0, 0
        for _, char := range extension {
            if char >= 'A' && char <= 'Z' {
                capCount++
            } else if char >= 'a' && char <= 'z' {
                smCount++
            }
        }
        strength := capCount - smCount
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = extension
        }
    }

    return fmt.Sprintf(""%s.%s"", class_name, strongestExtension)
}","func TestStrongest_Extension(t *testing.T) {
  candidate := Strongest_Extension
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Watashi"", []string{""tEN"", ""niNE"", ""eIGHt8OKe""}), expected: ""Watashi.eIGHt8OKe"" },
     { actual: candidate(""Boku123"", []string{""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""}), expected: ""Boku123.YEs.WeCaNe"" },
     { actual: candidate(""__YESIMHERE"", []string{""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""}), expected: ""__YESIMHERE.NuLl__"" },
     { actual: candidate(""K"", []string{""Ta"", ""TAR"", ""t234An"", ""cosSo""}), expected: ""K.TAR"" },
     { actual: candidate(""__HAHA"", []string{""Tab"", ""123"", ""781345"", ""-_-""}), expected: ""__HAHA.123"" },
     { actual: candidate(""YameRore"", []string{""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""}), expected: ""YameRore.okIWILL123"" },
     { actual: candidate(""finNNalLLly"", []string{""Die"", ""NowW"", ""Wow"", ""WoW""}), expected: ""finNNalLLly.WoW"" },
     { actual: candidate(""_"", []string{""Bb"", ""91245""}), expected: ""_.Bb"" },
     { actual: candidate(""Sp"", []string{""671235"", ""Bb""}), expected: ""Sp.671235"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_154,bos_Latn,go_test.go,"package cycpattern_check_test

import (
    ""testing""
    ""fmt""
)

//Dobijate 2 riječi. Morate vratiti true ako je druga riječ ili bilo koja od njenih rotacija podstring u prvoj riječi.// >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
func cycpattern_check(a string, b string) bool {
","package cycpattern_check_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func cycpattern_check(a string, b string) bool {
    n := len(b)
    
    // Generate all rotations of b
    for i := 0; i < n; i++ {
        rotated := b[i:] + b[:i]
        if strings.Contains(a, rotated) {
            return true
        }
    }
    
    return false
}","func TestCycpattern_Check(t *testing.T) {
  candidate := cycpattern_check
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""xyzw"", ""xyw""), expected: false },
     { actual: candidate(""yello"", ""ell""), expected: true },
     { actual: candidate(""whattup"", ""ptut""), expected: false },
     { actual: candidate(""efef"", ""fee""), expected: true },
     { actual: candidate(""abab"", ""aabb""), expected: false },
     { actual: candidate(""winemtt"", ""tinem""), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_155,bos_Latn,go_test.go,"package even_odd_count_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Ako je dat cjelokupni broj, vrati listu koja ima broj parnih i neparnih cifara.// >>> even_odd_count(-12)
// []interface{}{1, 1}
// >>> even_odd_count(123)
// []interface{}{1, 2}
func even_odd_count(num int) []interface{} {
","func even_odd_count(num int) []interface{} {
    // Handle negative numbers by taking the absolute value
    if num < 0 {
        num = -num
    }
    
    evenCount, oddCount := 0, 0

    // Iterate over each digit in the number
    for num > 0 {
        digit := num % 10
        if digit%2 == 0 {
            evenCount++
        } else {
            oddCount++
        }
        num /= 10
    }

    return []interface{}{evenCount, oddCount}
}

func TestEvenOddCount(t *testing.T) {
    testCases := []struct {
        input    int
        expected []interface{}
    }{
        {-12, []interface{}{1, 1}},
        {123, []interface{}{1, 2}},
        {2468, []interface{}{4, 0}},
        {1357, []interface{}{0, 4}},
        {0, []interface{}{1, 0}},
    }

    for _, testCase := range testCases {
        result := even_odd_count(testCase.input)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", testCase.expected) {
            t.Errorf(""even_odd_count(%d) = %v; expected %v"", testCase.input, result, testCase.expected)
        }
    }
}","func TestEven_Odd_Count(t *testing.T) {
  candidate := even_odd_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(7), expected: []interface{}{0, 1} },
     { actual: candidate(-78), expected: []interface{}{1, 1} },
     { actual: candidate(3452), expected: []interface{}{2, 2} },
     { actual: candidate(346211), expected: []interface{}{3, 3} },
     { actual: candidate(-345821), expected: []interface{}{3, 3} },
     { actual: candidate(-2), expected: []interface{}{1, 0} },
     { actual: candidate(-45347), expected: []interface{}{2, 3} },
     { actual: candidate(0), expected: []interface{}{1, 0} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_156,bos_Latn,go_test.go,"package int_to_mini_roman_test

import (
    ""testing""
    ""fmt""
)

//Primjeri: //Ograničenja: 1 <= num <= 1000 //i vrati ga malim slovima.//Ako je dato pozitivan cijeli broj, dobijte njegov rimski broj kao niz, // >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
func int_to_mini_roman(number int) string {
","package int_to_mini_roman_test

import (
	""strings""
	""testing""
)

func int_to_mini_roman(number int) string {
	vals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
	symbols := []string{""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""}

	var roman strings.Builder

	for i := 0; i < len(vals); i++ {
		for number >= vals[i] {
			number -= vals[i]
			roman.WriteString(symbols[i])
		}
	}
	return roman.String()
}

func TestIntToMiniRoman(t *testing.T) {
	tests := []struct {
		input    int
		expected string
	}{
		{19, ""xix""},
		{152, ""clii""},
		{426, ""cdxxvi""},
		{1000, ""m""},
		{1, ""i""},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf(""%d"", tt.input), func(t *testing.T) {
			result := int_to_mini_roman(tt.input)
			if result != tt.expected {
				t.Fatalf(""expected %v, but got %v"", tt.expected, result)
			}
		})
	}
}","func TestInt_To_Mini_Roman(t *testing.T) {
  candidate := int_to_mini_roman
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(19), expected: ""xix"" },
     { actual: candidate(152), expected: ""clii"" },
     { actual: candidate(251), expected: ""ccli"" },
     { actual: candidate(426), expected: ""cdxxvi"" },
     { actual: candidate(500), expected: ""d"" },
     { actual: candidate(1), expected: ""i"" },
     { actual: candidate(4), expected: ""iv"" },
     { actual: candidate(43), expected: ""xliii"" },
     { actual: candidate(90), expected: ""xc"" },
     { actual: candidate(94), expected: ""xciv"" },
     { actual: candidate(532), expected: ""dxxxii"" },
     { actual: candidate(900), expected: ""cm"" },
     { actual: candidate(994), expected: ""cmxciv"" },
     { actual: candidate(1000), expected: ""m"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_157,bos_Latn,go_test.go,"package right_angle_triangle_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //90 stepeni.//Pravougaoni trougao je trougao u kojem je jedan ugao pravougaoni ili//strane formiraju pravougaoni trougao, inače je to pogrešno.//Dajte dužine tri strane trougla.// >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
func right_angle_triangle(a int, b int, c int) bool {
","package right_angle_triangle_test

import (
    ""testing""
    ""fmt""
)

func right_angle_triangle(a int, b int, c int) bool {
    // Squaring the sides
    a2, b2, c2 := a*a, b*b, c*c
    // Check the Pythagorean theorem for the combination of sides
    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2
}","func TestRight_Angle_Triangle(t *testing.T) {
  candidate := right_angle_triangle
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 4, 5), expected: true },
     { actual: candidate(1, 2, 3), expected: false },
     { actual: candidate(10, 6, 8), expected: true },
     { actual: candidate(2, 2, 2), expected: false },
     { actual: candidate(7, 24, 25), expected: true },
     { actual: candidate(10, 5, 7), expected: false },
     { actual: candidate(5, 12, 13), expected: true },
     { actual: candidate(15, 8, 17), expected: true },
     { actual: candidate(48, 55, 73), expected: true },
     { actual: candidate(1, 1, 1), expected: false },
     { actual: candidate(2, 2, 10), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_158,bos_Latn,go_test.go,"package find_max_test

import (
    ""testing""
    ""fmt""
)

//znakova, vrati onaj koji je prvi po leksikografskoj redoslijedu. //Ako više niza ima maksimalan broj jedinstvenih karaktera //Lista sadrži različite riječi.//Napišite funkciju koja prihvata listu niza.// >>> find_max([]string{""name"", ""of"", ""string""})
// ""string""
// >>> find_max([]string{""name"", ""enam"", ""game""})
// ""enam""
// >>> find_max([]string{""aaaaaaa"", ""bb"", ""cc""})
// ""aaaaaaa""
func find_max(words []string) string {
","package find_max_test

import (
    ""testing""
    ""fmt""
    ""sort""
)

func find_max(words []string) string {
    maxWord := """"
    maxUnique := 0
    
    for _, word := range words {
        uniqueChars := countUniqueChars(word)
        if uniqueChars > maxUnique {
            maxUnique = uniqueChars
            maxWord = word
        } else if uniqueChars == maxUnique {
            if maxWord == """" || word < maxWord {
                maxWord = word
            }
        }
    }
    
    return maxWord
}

func countUniqueChars(word string) int {
    charSet := make(map[rune]struct{})
    for _, c := range word {
        charSet[c] = struct{}{}
    }
    return len(charSet)
}

// Test case runs to verify the solution
func TestFindMax(t *testing.T) {
    testCases := []struct {
        input []string
        expected string
    }{
        {[]string{""name"", ""of"", ""string""}, ""string""},
        {[]string{""name"", ""enam"", ""game""}, ""enam""},
        {[]string{""aaaaaaa"", ""bb"", ""cc""}, ""aaaaaaa""},
    }

    for _, tc := range testCases {
        result := find_max(tc.input)
        if result != tc.expected {
            t.Errorf(""For input %v, expected %s, but got %s"", tc.input, tc.expected, result)
        } else {
            fmt.Printf(""Test passed for input %v\n"", tc.input)
        }
    }
}","func TestFind_Max(t *testing.T) {
  candidate := find_max
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""name"", ""of"", ""string""}), expected: ""string"" },
     { actual: candidate([]string{""name"", ""enam"", ""game""}), expected: ""enam"" },
     { actual: candidate([]string{""aaaaaaa"", ""bb"", ""cc""}), expected: ""aaaaaaa"" },
     { actual: candidate([]string{""abc"", ""cba""}), expected: ""abc"" },
     { actual: candidate([]string{""play"", ""this"", ""game"", ""of"", ""footbott""}), expected: ""footbott"" },
     { actual: candidate([]string{""we"", ""are"", ""gonna"", ""rock""}), expected: ""gonna"" },
     { actual: candidate([]string{""we"", ""are"", ""a"", ""mad"", ""nation""}), expected: ""nation"" },
     { actual: candidate([]string{""this"", ""is"", ""a"", ""prrk""}), expected: ""this"" },
     { actual: candidate([]string{""b""}), expected: ""b"" },
     { actual: candidate([]string{""play"", ""play"", ""play""}), expected: ""play"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_159,bos_Latn,go_test.go,"package eat_test

import (
    ""testing""
    ""fmt""
)

//Primjer: //Ako nema dovoljno šargarepe, pojesti ćeš sve šargarepe, ali ćeš i dalje biti gladan.//broj mrkve koja vam je ostala nakon obroka] //treba da vratite spisak [ ukupnog broja konzumiranih mrkve nakon obroka, //Ali sada treba da jedeš više mrkve da bi završio dnevni obrok.//Ti si gladan zec, i vec si pojeo određen broj mrkve, // >>> eat(5, 6, 10)
// []int{11, 4}
// >>> eat(4, 8, 9)
// []int{12, 1}
// >>> eat(1, 10, 10)
// []int{11, 0}
// >>> eat(2, 11, 5)
// []int{7, 0}
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
func eat(number int, need int, remaining int) []int {
","package eat_test

import (
    ""testing""
    ""fmt""
)

// eat calculates the total number of eaten carrots after meals and the number of carrots left.
func eat(number int, need int, remaining int) []int {
    if need <= remaining {
        return []int{number + need, remaining - need}
    }
    return []int{number + remaining, 0}
}

func TestEat(t *testing.T) {
    tests := []struct {
        number, need, remaining int
        expected                []int
    }{
        {5, 6, 10, []int{11, 4}},
        {4, 8, 9, []int{12, 1}},
        {1, 10, 10, []int{11, 0}},
        {2, 11, 5, []int{7, 0}},
    }

    for _, test := range tests {
        result := eat(test.number, test.need, test.remaining)
        if result[0] != test.expected[0] || result[1] != test.expected[1] {
            t.Errorf(""eat(%d, %d, %d) = %v; expected %v"", test.number, test.need, test.remaining, result, test.expected)
        }
    }
}","func TestEat(t *testing.T) {
  candidate := eat
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5, 6, 10), expected: []int{11, 4} },
     { actual: candidate(4, 8, 9), expected: []int{12, 1} },
     { actual: candidate(1, 10, 10), expected: []int{11, 0} },
     { actual: candidate(2, 11, 5), expected: []int{7, 0} },
     { actual: candidate(4, 5, 7), expected: []int{9, 2} },
     { actual: candidate(4, 5, 1), expected: []int{5, 0} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_160,bos_Latn,go_test.go,"package do_algebra_test

import (
    ""testing""
    ""fmt""
)

//Lista operatera ima najmanje jednog operatera, a lista operanda ima najmanje dva operanda.//Operand je lista ne-negativnih cijelih brojeva.//Dužina liste operatora je jednaka dužini liste operanda minus jedan.//Napomena: //=> rezultat = 9 //Rezultat je 2 + 3 * 4 - 5 //lista = [2, 3, 4, 5] //Operator ['+', '*', '-'] //Primjer: //Eksponencijalno (**) //Podovi podjela ( //) //Množenje (*) //Oduzimanje ( - ) //Dodavanje (+) //Osnovne algebarske operacije://Izraz i vrati ocjenu ovog izraza.//Druga lista je lista cijelih brojeva.//Prva lista ima osnovne algebarske operacije, a func do_algebra(operator []string, operand []int) int {
","package do_algebra_test

import (
    ""fmt""
    ""testing""
)

func do_algebra(operator []string, operand []int) int {
    if len(operator) != len(operand)-1 {
        return 0
    }

    result := operand[0]
    for i := 0; i < len(operator); i++ {
        switch operator[i] {
        case ""+"":
            result += operand[i+1]
        case ""-"":
            result -= operand[i+1]
        case ""*"":
            result *= operand[i+1]
        case ""//"":
            result /= operand[i+1]
        case ""**"":
            result = intPow(result, operand[i+1])
        }
    }

    return result
}

func intPow(base, exp int) int {
    result := 1
    for exp != 0 {
        if exp%2 == 1 {
            result *= base
        }
        exp /= 2
        base *= base
    }
    return result
}

func TestDoAlgebra(t *testing.T) {
    operators := []string{""+"", ""*"", ""-""}
    operands := []int{2, 3, 4, 5}
    expectedResult := 9
    result := do_algebra(operators, operands)
    if result != expectedResult {
        t.Errorf(""expected %d but got %d"", expectedResult, result)
    }

    fmt.Println(""All tests passed."")
}","func TestDo_Algebra(t *testing.T) {
  candidate := do_algebra
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""**"", ""*"", ""+""}, []int{2, 3, 4, 5}), expected: 37 },
     { actual: candidate([]string{""+"", ""*"", ""-""}, []int{2, 3, 4, 5}), expected: 9 },
     { actual: candidate([]string{""//"", ""*""}, []int{7, 3, 4}), expected: 8 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_161,bos_Latn,go_test.go,"package solve_test

import (
    ""testing""
    ""fmt""
)

//Primjeri //Funkcija treba da vrati rezultiranu niz.//Ako string ne sadrži slova, obrnite string.//Inače, ostavi ga kako jeste.//ako je s[i] slovo, preokrenite njegov slučaj od donjeg prema gornjem ili obrnuto, //Dobiješ niz s.// >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
func solve(s string) string {
","package solve_test

import (
    ""unicode""
)

func solve(s string) string {
    hasLetter := false
    result := []rune(s)

    for i, char := range result {
        if unicode.IsLetter(char) {
            hasLetter = true
            if unicode.IsUpper(char) {
                result[i] = unicode.ToLower(char)
            } else {
                result[i] = unicode.ToUpper(char)
            }
        }
    }

    if !hasLetter {
        // reverse the string
        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
            result[i], result[j] = result[j], result[i]
        }
    }

    return string(result)
}","func TestSolve(t *testing.T) {
  candidate := solve
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""AsDf""), expected: ""aSdF"" },
     { actual: candidate(""1234""), expected: ""4321"" },
     { actual: candidate(""ab""), expected: ""AB"" },
     { actual: candidate(""#a@C""), expected: ""#A@c"" },
     { actual: candidate(""#AsdfW^45""), expected: ""#aSDFw^45"" },
     { actual: candidate(""#6@2""), expected: ""2@6#"" },
     { actual: candidate(""#$a^D""), expected: ""#$A^d"" },
     { actual: candidate(""#ccc""), expected: ""#CCC"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_163,bos_Latn,go_test.go,"package generate_integers_test

import (
    ""testing""
    ""fmt""
)

//Na primer: //i b, u porastu. //S obzirom na dva pozitivna cijela broja a i b, vratite parne cifre između a // >>> generate_integers(2, 8)
// []int{2, 4, 6, 8}
// >>> generate_integers(8, 2)
// []int{2, 4, 6, 8}
// >>> generate_integers(10, 14)
// []int{}
func generate_integers(a int, b int) []int {
","package generate_integers_test

import (
    ""testing""
    ""fmt""
)

func generate_integers(a int, b int) []int {
    start, end := a, b
    if a > b {
        start, end = b, a
    }
    
    result := []int{}
    for i := start; i <= end; i++ {
        if i%2 == 0 {
            result = append(result, i)
        }
    }
    return result
}

func TestGenerateIntegers(t *testing.T) {
    tests := []struct {
        a, b int
        want []int
    }{
        {2, 8, []int{2, 4, 6, 8}},
        {8, 2, []int{2, 4, 6, 8}},
        {10, 14, []int{}},
    }
    
    for _, tt := range tests {
        t.Run(fmt.Sprintf(""generate_integers(%d, %d)"", tt.a, tt.b), func(t *testing.T) {
            got := generate_integers(tt.a, tt.b)
            if len(got) != len(tt.want) {
                t.Errorf(""expected %v, got %v"", tt.want, got)
                return
            }
            for i := range got {
                if got[i] != tt.want[i] {
                    t.Errorf(""expected %v, got %v"", tt.want, got)
                    return
                }
            }
        })
    }
}","func TestGenerate_Integers(t *testing.T) {
  candidate := generate_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },
     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },
     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },
     { actual: candidate(17, 89), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
