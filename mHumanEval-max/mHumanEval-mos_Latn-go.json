[{"task_id":"HumanEval_0","nl":"mos_Latn","pl":"go_test.go","prompt":"package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sẽn dat n maan bũmb ningã\/\/Ges-y sã n yaa sõor a yiib n pẽ taab n yɩɩd \/\/ >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n\/\/ true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n","canonical_solution":"package has_close_elements_test\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\n\/\/ Check if in given list of numbers, are any two numbers closer to each other than\n\/\/ given threshold.\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n\tsort.Float64s(numbers)\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif math.Abs(numbers[i+1]-numbers[i]) < threshold {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n\ttestCases := []struct {\n\t\tnumbers   []float64\n\t\tthreshold float64\n\t\texpected  bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},\n\t\t{[]float64{1.5, 1.8, 2.2}, 0.3, true},\n\t\t{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase%d\", i+1), func(t *testing.T) {\n\t\t\tresult := has_close_elements(tc.numbers, tc.threshold)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_1","nl":"mos_Latn","pl":"go_test.go","prompt":"package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ra ges-y zĩ-zãrs nins sẽn be sõsgã pʋgẽ wã ye.\/\/B sẽn yãkd b sullã to-to wã zemsame (yẽk fãa sẽn pakã sɛgdame tɩ zemsã) la b pa kẽed taab ye.\/\/welg-y sull-kãng n welg-a n lebg sõor-yend n lebg n wa ne b sõorã. \/\/Fõn-kãng sẽn kẽed ne bũmb ningã yaa sõn-vãoog sẽn tar sull wʋsg sẽn be ne gãn-bi-nens sẽn be b sʋkã.\/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n","canonical_solution":"package separate_paren_groups\n\nfunc separate_paren_groups(paren_string string) []string {\n\tvar result []string\n\tvar currentGroup []rune\n\topenCount := 0\n\n\tfor _, char := range paren_string {\n\t\tif char == '(' {\n\t\t\topenCount++\n\t\t\tcurrentGroup = append(currentGroup, char)\n\t\t} else if char == ')' {\n\t\t\topenCount--\n\t\t\tcurrentGroup = append(currentGroup, char)\n\n\t\t\tif openCount == 0 {\n\t\t\t\tresult = append(result, string(currentGroup))\n\t\t\t\tcurrentGroup = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}","tests":"func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_2","nl":"mos_Latn","pl":"go_test.go","prompt":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Rɩk sõorã n lebg n wa. \/\/(Bãng-y tɩ bũmb ning sẽn ketã yaa bilf n yɩɩd a ye bala.)\/\/la pʋɩ-sʋk (sẽn yaa a soab sẽn yaa-a kãseng n yɩɩd yaa a sẽn yaa-a bilf n yɩɩd sõor ning b sẽn kõ wã) la pʋɩ-sʋk \/\/Sã n kõ-d sõor sẽn yaa sõma, d tõe n welga-a lame n lebg \/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n","canonical_solution":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive floating point number, it can be decomposed into\n\/\/ an integer part (largest integer smaller than given number) and decimals\n\/\/ (leftover part always smaller than 1).\n\/\/ Return the decimal part of the number.\n\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n    integerPart := int(number)\n    return number - float64(integerPart)\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n    testCases := []struct {\n        input float64\n        expected float64\n    }{\n        {3.5, 0.5},\n        {0.0, 0.0},\n        {7.25, 0.25},\n        {4.99, 0.99},\n        {2.0, 0.0},\n    }\n\n    for _, tc := range testCases {\n        result := truncate_number(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %.2f, got %.2f\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(truncate_number(3.5)) \/\/ Should print 0.5\n    fmt.Println(truncate_number(7.25)) \/\/ Should print 0.25\n}","tests":"func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_3","nl":"mos_Latn","pl":"go_test.go","prompt":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Rẽ poore, a segd n lebg n togsa sɩda. Sã n pa woto, a segd n lebg n togsa zĩrĩ.\/\/y tʋʋmda yaa yãag sã n mikame tɩ wakat ning fãa, y ligdã sãnda paoogame n ta zéro, la \/\/B kõ-y-la b sẽn ning la b yiis ligdã ligdã ligdã pʋgẽ wã sõor sẽn sɩng ne \/\/ >>> below_zero([]int{1, 2, 3})\n\/\/ false\n\/\/ >>> below_zero([]int{1, 2, -4, 5})\n\/\/ true\nfunc below_zero(operations []int) bool {\n","canonical_solution":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestBelowZero(t *testing.T) {\n    testCases := []struct {\n        operations []int\n        expected   bool\n    }{\n        {[]int{1, 2, 3}, false},\n        {[]int{1, 2, -4, 5}, true},\n        {[]int{0, -1, 1}, true},\n        {[]int{}, false},\n        {[]int{-1, 1, -1, 1}, true},\n    }\n    for _, tc := range testCases {\n        result := below_zero(tc.operations)\n        if result != tc.expected {\n            t.Errorf(\"below_zero(%v) = %v; want %v\", tc.operations, result, tc.expected)\n        }\n    }\n}","tests":"func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_4","nl":"mos_Latn","pl":"go_test.go","prompt":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/MAD = average. x - x_mean. \/\/B sẽn boond tɩ \" Elements \" wã la b sẽn boond tɩ \" Centre \" wã (dẽnd sẽn dat n yeel tɩ \" moyenne \" wã): \/\/Sẽn yaa bũmb ning fãa la b sẽn maan tɩ b pa tõe n bãngã yaa tɩ b sẽn pa tõe n bãngã yaa bũmb ning fãa la b sẽn pa tõe n bãngã.\/\/Sẽn yɩɩd fãa, b sẽn na n maan to-to n tõog n paam n maan woto wã yaa bũmb sẽn yaa toor ne b sẽn da tagsdã.\/\/Sẽn na yɩl n bãng sõor ning sẽn be sõor ning pʋgẽ wã, d na n bao n bãnga sẽn yaa to-to.\/\/ >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n\/\/ 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n","canonical_solution":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    var sum float64\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum \/ float64(len(numbers))\n\n    var madSum float64\n    for _, num := range numbers {\n        madSum += math.Abs(num - mean)\n    }\n    return madSum \/ float64(len(numbers))\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    tests := []struct {\n        input []float64\n        want  float64\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},\n        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},\n        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"mean_absolute_deviation(%v)\", test.input), func(t *testing.T) {\n            got := mean_absolute_deviation(test.input)\n            if got != test.want {\n                t.Errorf(\"mean_absolute_deviation(%v) = %v; want %v\", test.input, got, test.want)\n            }\n        })\n    }\n}","tests":"func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_5","nl":"mos_Latn","pl":"go_test.go","prompt":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B kẽesa sõor sẽn yaa \"delimiter\" n be b sẽn boond tɩ \"input list\" wã zĩis a yiib fãa sʋka.\/\/ >>> intersperse([]int{}, 4)\n\/\/ []int{}\n\/\/ >>> intersperse([]int{1, 2, 3}, 4)\n\/\/ []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n","canonical_solution":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc intersperse(numbers []int, delimiter int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, num := range numbers {\n        if i > 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n\nfunc TestIntersperse(t *testing.T) {\n    testCases := []struct{\n        input []int\n        delimiter int\n        expected []int\n    }{\n        {[]int{}, 4, []int{}},\n        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},\n        {[]int{1}, 4, []int{1}},\n        {[]int{1, 2}, 4, []int{1, 4, 2}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v, %d\", tc.input, tc.delimiter), func(t *testing.T) {\n            result := intersperse(tc.input, tc.delimiter)\n            if !equal(result, tc.expected) {\n                t.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    \n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_6","nl":"mos_Latn","pl":"go_test.go","prompt":"package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre, (() (()) tara sẽn yɩɩd bĩis a yiib n beẽ, t'a ((())) tar a tãabo. \/\/Sẽn kẽed ne sull fãa, wilg-y sẽn kẽed ne sull fãa n yɩɩd fãa.\/\/Yaa sẽn na n yɩlẽ n tõog n bãng sẽn yaa bũmb ning n kɩt tɩ b yãkd b sẽn dat n maan bũmb ningã.\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n","canonical_solution":"func parse_nested_parens(paren_string string) []int {\n    groups := strings.Fields(paren_string)\n    depths := make([]int, len(groups))\n\n    for i, group := range groups {\n        maxDepth, currentDepth := 0, 0\n        for _, char := range group {\n            if char == '(' {\n                currentDepth++\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == ')' {\n                currentDepth--\n            }\n        }\n        depths[i] = maxDepth\n    }\n\n    return depths\n}","tests":"func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_7","nl":"mos_Latn","pl":"go_test.go","prompt":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Yɩl n gilg n kõ sõor-koɛɛg sẽn be sõor-koɛɛg sẽn kõ \/\/ >>> filter_by_substring([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n","canonical_solution":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc filter_by_substring(strings []string, substring string) []string {\n    var result []string\n    for _, str := range strings {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterBySubstring(t *testing.T) {\n    tests := []struct {\n        input    []string\n        substring string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"bacd\", \"array\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_substring(test.input, test.substring)\n        if fmt.Sprintf(\"%q\", result) != fmt.Sprintf(\"%q\", test.expected) {\n            t.Errorf(\"filter_by_substring(%q, %q) = %q; expected %q\", test.input, test.substring, result, test.expected)\n        }\n    }\n}","tests":"func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_8","nl":"mos_Latn","pl":"go_test.go","prompt":"package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sẽn pa be wã segd n yɩɩ 0 tɩ sẽn pa be wã segd n yɩɩ 1.\/\/Sẽn kẽed ne sõor sẽn kõ, lebg n wa ne sõor sẽn naag ne sõor la sẽn lebg n wa ne sõor sẽn naag ne sõor fãa sẽn be sõor pʋgẽ wã.\/\/ >>> sum_product([]int{})\n\/\/ []interface{}{0, 1}\n\/\/ >>> sum_product([]int{1, 2, 3, 4})\n\/\/ []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n","canonical_solution":"func sum_product(numbers []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n}","tests":"func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_9","nl":"mos_Latn","pl":"go_test.go","prompt":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sẽn na n maan to-to wã.\/\/Ne sõor sẽn yaa sõma wã, d na n paama sõor sẽn yaa sõma n yɩɩd sẽn ta wakat ning b sẽn kõ wã.\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n","canonical_solution":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a given list of integers, generate a list of rolling maximum element found until given moment\n\/\/ in the sequence.\n\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n    maxSoFar := numbers[0]\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n\nfunc TestRollingMax(t *testing.T) {\n    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) \/\/ should output []int{1, 2, 3, 3, 3, 4, 4}\n}","tests":"func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_10","nl":"mos_Latn","pl":"go_test.go","prompt":"package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/- Add to the end of the string reverse of a string prefix that comes before the palindromic suffix.  tall n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas\/\/- Bao-y n bãng-y sẽn yaa to-to tɩ y sã n wa kõ-y sõor a woto, y sã n wa paam-a, a yɩ-la wa palindrõme.\/\/A sẽn dat n maan bũmb ningã yaa nana:\/\/Bao-y palindrom ning sẽn yaa kɩt n yɩɩd sẽn sɩng ne sõor b sẽn kõ wã. \/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunc make_palindrome(myString string) string {\n","canonical_solution":"package make_palindrome_test\n\nimport (\n    \"testing\"\n)\n\nfunc make_palindrome(myString string) string {\n    if len(myString) <= 1 {\n        return myString\n    }\n    \n    \/\/ Helper function to check if a string is a palindrome\n    isPalindrome := func(s string) bool {\n        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n            if s[i] != s[j] {\n                return false\n            }\n        }\n        return true\n    }\n\n    \/\/ Start from the whole string and reduce until we find a palindrome\n    for i := len(myString); i > 0; i-- {\n        if isPalindrome(myString[len(myString)-i:]) {\n            prefix := myString[:len(myString)-i]\n            \/\/ Reverse the prefix and append to original string\n            reversedPrefix := reverse(prefix)\n            return myString + reversedPrefix\n        }\n    }\n\n    \/\/ If no palindromic suffix is found, return original string with reverse appended\n    return myString + reverse(myString)\n}\n\n\/\/ Helper function to reverse a string\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc TestMakePalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"cat\", \"catac\"},\n        {\"cata\", \"catac\"},\n    }\n\n    for _, test := range tests {\n        result := make_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"make_palindrome(%q) = %q; expected %q\", test.input, result, test.expected)\n        }\n    }\n}","tests":"func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_11","nl":"mos_Latn","pl":"go_test.go","prompt":"package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Bõn-kãens fãa zug bɩ y maan XOR sẽn yaa yiib-n-soab n lebg n wa ne bi-beoog sẽn yaa sõor sẽn yaa toore.\/\/Yaa b sẽn gʋlsd 1 la 0 bal n gʋlsd b sẽn gʋlsd b toorã.\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunc string_xor(a string, b string) string {\n","canonical_solution":"result := make([]byte, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tresult[i] = '0'\n\t\t} else {\n\t\t\tresult[i] = '1'\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_13","nl":"mos_Latn","pl":"go_test.go","prompt":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/lebg n wa ne nin-sabls a la b sẽn pʋɩt n yɩɩdã \/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n","canonical_solution":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a greatest common divisor of two integers a and b\n\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n    for b != 0 {\n        a, b = b, a%b\n    }\n    return a\n}\n\nfunc TestGreatestCommonDivisor(t *testing.T) {\n    tests := []struct {\n        a, b   int\n        expect int\n    }{\n        {3, 5, 1},\n        {25, 15, 5},\n        {54, 24, 6},\n        {48, 18, 6},\n        {101, 103, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.a, test.b), func(t *testing.T) {\n            result := greatest_common_divisor(test.a, test.b)\n            if result != test.expect {\n                t.Errorf(\"expected %d, got %d\", test.expect, result)\n            }\n        })\n    }\n}","tests":"func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_14","nl":"mos_Latn","pl":"go_test.go","prompt":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne sõor sẽn sɩng ne sõor sẽn yaa kɩdma n tɩ ta sõor sẽn yaa woglem sẽn yaa kɩdma.\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n","canonical_solution":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of all prefixes from shortest to longest of the input string\n\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n    var prefixes []string\n    for i := 1; i <= len(myString); i++ {\n        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n}\n\nfunc TestAllPrefixes(t *testing.T) {\n    result := all_prefixes(\"abc\")\n    expected := []string{\"a\", \"ab\", \"abc\"}\n    for i, v := range result {\n        if v != expected[i] {\n            t.Errorf(\"Test failed, expected %v, got %v\", expected[i], v)\n        }\n    }\n    fmt.Println(\"Test passed\")\n}","tests":"func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_15","nl":"mos_Latn","pl":"go_test.go","prompt":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/lebg n wa ne sõor sẽn be zĩ-zĩig pʋgẽ n sɩng ne 0 n ta n fãa. \/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n","canonical_solution":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n\/\/ Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nfunc string_sequence(n int) string {\n    var parts []string\n    for i := 0; i <= n; i++ {\n        parts = append(parts, fmt.Sprintf(\"%d\", i))\n    }\n    return strings.Join(parts, \" \")\n}\n\nfunc TestStringSequence(t *testing.T) {\n    result := string_sequence(0)\n    expected := \"0\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n    \n    result = string_sequence(5)\n    expected = \"0 1 2 3 4 5\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n}","tests":"func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_16","nl":"mos_Latn","pl":"go_test.go","prompt":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D sã n kõ-y sõor sẽn yaa sõor sẽn yaa toore, bɩ y bao n bãng sõor ning sẽn yaa toore (n pa ges b sẽn gʋlsd-a to-to wã) \/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunc count_distinct_characters(myString string) int {\n","canonical_solution":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc count_distinct_characters(myString string) int {\n    characterMap := make(map[rune]bool)\n    for _, char := range strings.ToLower(myString) {\n        characterMap[char] = true\n    }\n    return len(characterMap)\n}\n\nfunc TestCountDistinctCharacters(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected int\n    }{\n        {\"xyzXYZ\", 3},\n        {\"Jerry\", 4},\n        {\"\", 0},\n        {\"Hello, World!\", 10},\n    }\n\n    for _, testCase := range testCases {\n        result := count_distinct_characters(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", testCase.input, testCase.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input '%s': got %d\\n\", testCase.input, result)\n        }\n    }\n}","tests":"func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_17","nl":"mos_Latn","pl":"go_test.go","prompt":"package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/'Hak' yaa yɩɩl sẽn tar koe-zug a naas sẽn kaoosd wakat a ye.\/\/\"O\" yaa \"o\" sẽn dat n yeel tɩ \"bũmb fãa\".\/\/'o' - yɩɩll fãa, sẽn kaoosd wakat a naas \/\/Ad kɩbar sẽn wilgd rẽ:\/\/pa yaoolem ye.\/\/Y tʋʋmda yaa y sẽn na n bãng n welg sõor kãnga n lebg n wa ne sõor sẽn zems ne sõor ning sẽn zems ne b sẽn na n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll tɩ yɩll n yɩll n yɩll n yɩll n yɩll tɩ yɩll n yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll\/\/Yaa sẽn na n yɩlẽ n wilg tɩ yɩɩlã yaa ASCII sẽn yaa takɩ.\/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n","canonical_solution":"package parse_music_test\n\nimport (\n    \"strings\"\n)\n\nfunc parse_music(music_string string) []int {\n    notes := strings.Fields(music_string)\n    beats := make([]int, len(notes))\n    for i, note := range notes {\n        switch note {\n        case \"o\":\n            beats[i] = 4\n        case \"o|\":\n            beats[i] = 2\n        case \".|\":\n            beats[i] = 1\n        }\n    }\n    return beats\n}","tests":"func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_18","nl":"mos_Latn","pl":"go_test.go","prompt":"package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Bao-y n bãng-y naoor a wãn la b tõe n yã sõor-koɛɛg sẽn yaa wa b sẽn da gʋls-a wã.\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunc how_many_times(myString string, substring string) int {\n","canonical_solution":"func how_many_times(myString string, substring string) int {\n    if len(substring) == 0 {\n        return 0\n    }\n\n    count := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHowManyTimes(t *testing.T) {\n    tests := []struct {\n        myString  string\n        substring string\n        expected  int\n    }{\n        {\"\", \"a\", 0},\n        {\"aaa\", \"a\", 3},\n        {\"aaaa\", \"aa\", 3},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%s in %s\", test.substring, test.myString), func(t *testing.T) {\n            result := how_many_times(test.myString, test.substring)\n            if result != test.expected {\n                t.Errorf(\"Expected %d but got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_19","nl":"mos_Latn","pl":"go_test.go","prompt":"package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/lebg n wa ne sõor sẽn tũ sor n sɩng ne yaoolem n tɩ ta yaoolem \/\/B sẽn tõe n yãk n yãkã yaa 'fɩt', 'yẽng', 'a yiib', 'a tãab', 'a naas', 'a nu', 'a yoob', 'a yopoe', 'a nii' la 'a wɛ.' \/\/Sẽn kẽed ne yaa sõor sẽn kẽed ne zĩiga sẽn yi \"fãa\" n tɩ ta \"sẽn pa ta a wɛ\" n kẽedẽ.\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunc sort_numbers(numbers string) string {\n","canonical_solution":"package sort_numbers_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc sort_numbers(numbers string) string {\n    wordsToNumbers := map[string]int{\n        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n        \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\":   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n    }\n    \n    numbersToWords := []string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    \n    words := strings.Fields(numbers)\n    numberInts := make([]int, len(words))\n    \n    for i, word := range words {\n        numberInts[i] = wordsToNumbers[word]\n    }\n    \n    sort.Ints(numberInts)\n    \n    sortedWords := make([]string, len(words))\n    for i, num := range numberInts {\n        sortedWords[i] = numbersToWords[num]\n    }\n    \n    return strings.Join(sortedWords, \" \")\n}","tests":"func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_20","nl":"mos_Latn","pl":"go_test.go","prompt":"package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sã n wa rat n bãng b sẽn na n maan to-to, b segd n lebg n wa ne b sẽn pʋɩt to-to wã (b sã n dat n bãng b sõor sẽn paood to-to, b segd n lebg n wa ne b sõor sẽn yɩɩd to-to).\/\/Y sã n yã sõor sõor sẽn be sõor sõor sõor sõor a yiib pʋgẽ (sẽn pa ta a yiib) bɩ y yãk sõor a yiib sẽn kolg n yɩɩd b fãa n lebg n wa \/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\/\/ []interface{}{2.0, 2.2}\n\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n\/\/ []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n","canonical_solution":"package find_closest_elements_test\n\nimport (\n    \"math\"\n    \"sort\"\n)\n\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n    \n    \/\/ Create a sorted copy of the numbers\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n    \n    \/\/ Initialize the minimum difference and result\n    minDiff := math.MaxFloat64\n    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}\n    \n    \/\/ Iterate over the sorted numbers to find the closest pair\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            result[0] = sortedNumbers[i-1]\n            result[1] = sortedNumbers[i]\n        }\n    }\n    \n    return result\n}","tests":"func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_21","nl":"mos_Latn","pl":"go_test.go","prompt":"package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sẽn na yɩl tɩ sõor ning sẽn yaa bilf n yɩɩdã lebg 0 la sẽn yaa kãseng n yɩɩdã lebg 1 \/\/B sã n kõ sõor sõor (sẽn zems a yiib), b rɩkda lineer tɩlɛg n tek sõor kãng zugu, \/\/ >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\/\/ []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n","canonical_solution":"package rescale_to_unit_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n\tif len(numbers) < 2 {\n\t\treturn numbers\n\t}\n\t\n\tminVal := numbers[0]\n\tmaxVal := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < minVal {\n\t\t\tminVal = num\n\t\t} else if num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\n\tscale := maxVal - minVal\n\tif scale == 0 {\n\t\treturn make([]float64, len(numbers))\n\t}\n\n\trescaled := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\trescaled[i] = (num - minVal) \/ scale\n\t}\n\n\treturn rescaled\n}\n\nfunc TestRescaleToUnit(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},\n\t\t{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},\n\t\t{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := rescale_to_unit(test.input)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","tests":"func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_22","nl":"mos_Latn","pl":"go_test.go","prompt":"package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Fɩtrã sẽn kõ sõor ning sẽn be gothon-rãmbã fãa wã yaa sẽn zems ne nimero-rãmb sẽn yaa sõma bal yĩnga \/\/ >>> filter_integers([]float64{\"a\", 3.14, 5})\n\/\/ []int{5}\n\/\/ >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n\/\/ []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n","canonical_solution":"func filter_integers(values []interface{}) []int {\n    var result []int\n    for _, v := range values {\n        if intValue, ok := v.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n\nfunc TestFilterIntegers(t *testing.T) {\n    cases := []struct {\n        input    []interface{}\n        expected []int\n    }{\n        {\n            input:    []interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n            expected: []int{1, 2, 3},\n        },\n        {\n            input:    []interface{}{\"a\", 3.14, 5},\n            expected: []int{5},\n        },\n    }\n\n    for _, c := range cases {\n        result := filter_integers(c.input)\n        if !equal(result, c.expected) {\n            t.Errorf(\"filter_integers(%v) == %v, expected %v\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_23","nl":"mos_Latn","pl":"go_test.go","prompt":"package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne sõor-kẽengã sẽn kõ wã woglem \/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunc strlen(myString string) int {\n","canonical_solution":"return len(myString)\n}","tests":"func TestStrlen(t *testing.T) {\n  candidate := strlen\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"x\"), expected: 1 },\n     { actual: candidate(\"asdasnakj\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_24","nl":"mos_Latn","pl":"go_test.go","prompt":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sẽn na n yɩlẽ n paam sõor sẽn kõ, bao sõor ning sẽn yaa kãseng n yɩɩd n n pʋɩt n wã, n ya bilf n yɩɩd n \/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n","canonical_solution":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n    for i := n\/2; i > 0; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}\n\nfunc TestLargestDivisor(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {15, 5},\n        {100, 50},\n        {49, 7},\n        {81, 27},\n        {1, 1},\n    }\n\n    for _, c := range cases {\n        result := largest_divisor(c.input)\n        if result != c.expected {\n            t.Errorf(\"largest_divisor(%d) == %d, expected %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(largest_divisor(15))\n}","tests":"func TestLargest_Divisor(t *testing.T) {\n  candidate := largest_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: 1 },\n     { actual: candidate(7), expected: 1 },\n     { actual: candidate(10), expected: 5 },\n     { actual: candidate(100), expected: 50 },\n     { actual: candidate(49), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_25","nl":"mos_Latn","pl":"go_test.go","prompt":"package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sõngd n bãngame tɩ f sã n na n gʋls sõor-kãng n paase, f segd n karma rẽ ne bũmb nins fãa sẽn naag n gʋlsã.\/\/B segd n sõdga yel-bũndã naoor sẽn zems ne naoor ning a sẽn pukd yel-bũndã pʋgẽ wã.\/\/D lebg n wa ne sõor sẽn yaa pipi koees rãmb sẽn yaa sõor sẽn yaa zãng n sɩng ne sõor sẽn yaa bilf n tɩ ta sõor sẽn yaa kãsenga.\/\/ >>> factorize(8)\n\/\/ []int{2, 2, 2}\n\/\/ >>> factorize(25)\n\/\/ []int{5, 5}\n\/\/ >>> factorize(70)\n\/\/ []int{2, 5, 7}\nfunc factorize(n int) []int {\n","canonical_solution":"package factorize\n\nfunc factorize(n int) []int {\n\tvar factors []int\n\tfor i := 2; i*i <= n; i++ {\n\t\tfor n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn \/= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}","tests":"func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_26","nl":"mos_Latn","pl":"go_test.go","prompt":"package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B bas tɩ b sẽn gʋls bũmb ningã ket n yaa woto.\/\/Y sã n na n sõd sõor sẽn yaa zãng n yaool n wa n gʋls-a, y segd n yiisa sõor nins sẽn be wã fãa.\/\/ >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n\/\/ []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n","canonical_solution":"package remove_duplicates_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc remove_duplicates(numbers []int) []int {\n\tcounts := make(map[int]int)\n\tfor _, num := range numbers {\n\t\tcounts[num]++\n\t}\n\n\tresult := []int{}\n\tfor _, num := range numbers {\n\t\tif counts[num] == 1 {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestRemoveDuplicates(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},\n\t\t{[]int{1, 1, 1, 1}, []int{}},\n\t\t{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},\n\t\t{[]int{5, 5, 5, 6}, []int{6}},\n\t\t{[]int{9, 8, 9, 8, 7}, []int{7}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"remove_duplicates(%v)\", test.input), func(t *testing.T) {\n\t\t\tresult := remove_duplicates(test.input)\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Expected length %d, got %d\", len(test.expected), len(result))\n\t\t\t}\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_27","nl":"mos_Latn","pl":"go_test.go","prompt":"package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sẽn kẽed ne sõsg sẽn kõ, lebg-y lɛtrã sẽn yaa bilfr n lebg bilfr kãsenga, la bilfr kãsenga n lebg bilfr bilf-bilfã. \/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunc flip_case(myString string) string {\n","canonical_solution":"func flip_case(myString string) string {\n\tvar result []rune\n\tfor _, char := range myString {\n\t\tif char >= 'a' && char <= 'z' {\n\t\t\tresult = append(result, char-('a'-'A'))\n\t\t} else if char >= 'A' && char <= 'Z' {\n\t\t\tresult = append(result, char+('a'-'A'))\n\t\t} else {\n\t\t\tresult = append(result, char)\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_28","nl":"mos_Latn","pl":"go_test.go","prompt":"package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Yɩta sõsg sẽn na n yɩ sõsg a ye bala \/\/ >>> concatenate([]string{})\n\/\/ \"\"\n\/\/ >>> concatenate([]string{\"a\", \"b\", \"c\"})\n\/\/ \"abc\"\nfunc concatenate(strings []string) string {\n","canonical_solution":"result := \"\"\n    for _, str := range strings {\n        result += str\n    }\n    return result\n}","tests":"func TestConcatenate(t *testing.T) {\n  candidate := concatenate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}), expected: \"\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\"}), expected: \"xyz\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\", \"w\", \"k\"}), expected: \"xyzwk\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_29","nl":"mos_Latn","pl":"go_test.go","prompt":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Y sã n dat n wa ne sõor sẽn yaa toore, bɩ y ges sõor nins sẽn sɩng ne pipi sõor bala.\/\/ >>> filter_by_prefix([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n","canonical_solution":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Filter an input list of strings only for ones that start with a given prefix.\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterByPrefix(t *testing.T) {\n    tests := []struct {\n        input    []string\n        prefix   string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"array\"}},\n        {[]string{\"hello\", \"helium\", \"world\"}, \"he\", []string{\"hello\", \"helium\"}},\n        {[]string{\"banana\", \"band\", \"bandana\"}, \"ban\", []string{\"banana\", \"band\", \"bandana\"}},\n        {[]string{\"apple\", \"ape\", \"apricot\"}, \"ap\", []string{\"apple\", \"ape\", \"apricot\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_prefix(test.input, test.prefix)\n        if !equal(result, test.expected) {\n            t.Errorf(\"filter_by_prefix(%v, %s) = %v; expected %v\", test.input, test.prefix, result, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_By_Prefix(t *testing.T) {\n  candidate := filter_by_prefix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_30","nl":"mos_Latn","pl":"go_test.go","prompt":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Lebg n kõ sõor sẽn yaa sõma bala.\/\/ >>> get_positive([]int{-1, 2, -4, 5, 6})\n\/\/ []int{2, 5, 6}\n\/\/ >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n","canonical_solution":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return only positive numbers in the list.\nfunc get_positive(l []int) []int {\n    var positiveNumbers []int\n    for _, num := range l {\n        if num > 0 {\n            positiveNumbers = append(positiveNumbers, num)\n        }\n    }\n    return positiveNumbers\n}\n\nfunc TestGetPositive(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},\n    }\n    \n    for _, test := range tests {\n        result := get_positive(test.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.output) {\n            t.Errorf(\"Expected %v, got %v\", test.output, result)\n        }\n    }\n}","tests":"func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1, -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_31","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D sã n kõ sõor sẽn yaa pipi, d lebg n togsa sɩda, sã n pa woto, yaa ziri. \/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunc is_prime(n int) bool {\n","canonical_solution":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_prime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPrime(t *testing.T) {\n    testCases := []struct {\n        number   int\n        expected bool\n    }{\n        {6, false},\n        {101, true},\n        {11, true},\n        {13441, true},\n        {61, true},\n        {4, false},\n        {1, false},\n    }\n\n    for _, testCase := range testCases {\n        result := is_prime(testCase.number)\n        if result != testCase.expected {\n            t.Errorf(\"is_prime(%d) = %v; want %v\", testCase.number, result, testCase.expected)\n        } else {\n            fmt.Printf(\"Test Passed: is_prime(%d) = %v\\n\", testCase.number, result)\n        }\n    }\n}","tests":"func TestIs_Prime(t *testing.T) {\n  candidate := is_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(6), expected: false },\n     { actual: candidate(101), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(13441), expected: true },\n     { actual: candidate(61), expected: true },\n     { actual: candidate(4), expected: false },\n     { actual: candidate(1), expected: false },\n     { actual: candidate(5), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(17), expected: true },\n     { actual: candidate(85), expected: false },\n     { actual: candidate(77), expected: false },\n     { actual: candidate(255379), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_33","nl":"mos_Latn","pl":"go_test.go","prompt":"package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sẽn maan to-to n na n bãng n yãk b sẽn na n maan to-to n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam\/\/l' yaa a yembr ne l sẽn kẽed ne vɛrse nins sẽn pa tõe n pʋɩ ne tãabã wɛɛngẽ, tɩ b vɛrse nins sẽn tõe n pʋɩ ne tãabã wɛɛngẽ wã yaa a yembr \/\/Tʋʋm kãnga rɩkda list l la a lebg n wa ne list l' sẽn yaa woto tɩ \/\/ >>> sort_third([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n\/\/ []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n","canonical_solution":"package sort_third_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_third(l []int) []int {\n    type pair struct {\n        index int\n        value int\n    }\n\n    \/\/ Collect the pairs where indices are divisible by 3\n    sortSection := []pair{}\n\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            sortSection = append(sortSection, pair{index: i, value: l[i]})\n        }\n    }\n\n    \/\/ Sort this section based on the values\n    sort.Slice(sortSection, func(i, j int) bool {\n        return sortSection[i].value < sortSection[j].value\n    })\n\n    \/\/ Generate result slice\n    result := make([]int, len(l))\n    copy(result, l)\n\n    \/\/ Fill the sorted values back to the result\n    for _, p := range sortSection {\n        result[p.index] = p.value\n    }\n\n    return result\n}","tests":"func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_34","nl":"mos_Latn","pl":"go_test.go","prompt":"package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Leb n wa ne bũmb sẽn yaa toor-toor sẽn be list pʋgẽ \/\/ >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n","canonical_solution":"package unique_test\n\nimport (\n    \"sort\"\n)\n\nfunc unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, value := range l {\n        uniqueMap[value] = true\n    }\n\n    uniqueSlice := make([]int, 0, len(uniqueMap))\n    for key := range uniqueMap {\n        uniqueSlice = append(uniqueSlice, key)\n    }\n\n    sort.Ints(uniqueSlice)\n    return uniqueSlice\n}","tests":"func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_35","nl":"mos_Latn","pl":"go_test.go","prompt":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne sõor sẽn ta zĩig ning fãa.\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n","canonical_solution":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return maximum element in the list.\n\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n    if len(l) == 0 {\n        panic(\"Empty list has no maximum value\")\n    }\n    max := l[0]\n    for _, value := range l {\n        if value > max {\n            max = value\n        }\n    }\n    return max\n}\n\nfunc TestMaxElement(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 3},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},\n        {[]int{-1, -2, -3, -4}, -1},\n        {[]int{9, 9, 9, 9}, 9},\n    }\n\n    for _, testCase := range testCases {\n        result := max_element(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %v, expected %d, got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}","tests":"func TestMax_Element(t *testing.T) {\n  candidate := max_element\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 3 },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_36","nl":"mos_Latn","pl":"go_test.go","prompt":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Rɩkd sõor ning sẽn zems naoor ning sõor 7 sẽn pukd n yɩɩd n sẽn tõe n pʋɩ ne 11 bɩ 13 wã. \/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunc fizz_buzz(n int) int {\n","canonical_solution":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 0; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += countSevens(i)\n        }\n    }\n    return count\n}\n\nfunc countSevens(num int) int {\n    strNum := strconv.Itoa(num)\n    count := 0\n    for _, c := range strNum {\n        if c == '7' {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestFizzBuzz(t *testing.T) {\n    tests := []struct {\n        input int\n        expected int\n    }{\n        {50, 0},\n        {78, 2},\n        {79, 3},\n    }\n\n    for _, test := range tests {\n        result := fizz_buzz(test.input)\n        if result != test.expected {\n            t.Errorf(\"fizz_buzz(%d) = %d; expected %d\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(fizz_buzz(50)) \/\/ 0\n    fmt.Println(fizz_buzz(78)) \/\/ 2\n    fmt.Println(fizz_buzz(79)) \/\/ 3\n}","tests":"func TestFizz_Buzz(t *testing.T) {\n  candidate := fizz_buzz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(50), expected: 0 },\n     { actual: candidate(78), expected: 2 },\n     { actual: candidate(79), expected: 3 },\n     { actual: candidate(100), expected: 3 },\n     { actual: candidate(200), expected: 6 },\n     { actual: candidate(4000), expected: 192 },\n     { actual: candidate(10000), expected: 639 },\n     { actual: candidate(100000), expected: 8026 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_37","nl":"mos_Latn","pl":"go_test.go","prompt":"package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Yaa sẽn na yɩl n bãng n bãng n paas n paasã.\/\/l' yaa a yembr ne l sẽn be ne sẽn pa yɩ-b toor-toorã, tɩ b sẽn be ne sẽn yaa-b toor-toorã yaa a yembr \/\/Tʋʋm kãnga rɩkda list l la a lebg n wa ne list l' sẽn yaa woto tɩ \/\/ >>> sort_even([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_even([]int{5, 6, 3, 4})\n\/\/ []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n","canonical_solution":"package sort_even_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_even(l []int) []int {\n    if len(l) < 2 {\n        return l\n    }\n    \n    \/\/ Extract even indices\n    evens := []int{}\n    for i := 0; i < len(l); i += 2 {\n        evens = append(evens, l[i])\n    }\n    \n    \/\/ Sort even-indexed elements\n    sort.Ints(evens)\n    \n    \/\/ Merge sorted evens back into the original list\n    j := 0\n    for i := 0; i < len(l); i += 2 {\n        l[i] = evens[j]\n        j++\n    }\n\n    return l\n}","tests":"func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_39","nl":"mos_Latn","pl":"go_test.go","prompt":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/prime_fib lebgda n-ẽegrã sõor sẽn yaa Fibonacci sõor la a leb n yaa pipi sõore. \/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunc prime_fib(n int) int {\n","canonical_solution":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ isPrime checks if a number is prime\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    if num <= 3 {\n        return true\n    }\n    if num%2 == 0 || num%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= num; i += 6 {\n        if num%i == 0 || num%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfunc prime_fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    a, b := 1, 1\n    count := 0\n    for count < n {\n        a, b = b, a+b\n        if isPrime(a) {\n            count++\n        }\n    }\n    return a\n}\n\nfunc TestPrimeFib(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {1, 2},\n        {2, 3},\n        {3, 5},\n        {4, 13},\n        {5, 89},\n    }\n\n    for _, test := range tests {\n        result := prime_fib(test.input)\n        if result != test.expected {\n            t.Errorf(\"prime_fib(%d) = %d; expected %d\", test.input, result, test.expected)\n        } else {\n            fmt.Printf(\"prime_fib(%d) = %d\\n\", test.input, result)\n        }\n    }\n}","tests":"func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2), expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4), expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual: candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected: 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_40","nl":"mos_Latn","pl":"go_test.go","prompt":"package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sã n pa rẽ, yaa ziri.\/\/a sã n be bũmb a tãab sẽn yaa toor ne taab n be sõor-kãng pʋgẽ tɩ \/\/triples_sum_to_zero rɩkda nimero rãmb sõor sẽn yaa sõma n lebg a vẽnegr. \/\/ >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1})\n\/\/ false\nfunc triples_sum_to_zero(l []int) bool {\n","canonical_solution":"func triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    if n < 3 {\n        return false\n    }\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}\n\nfunc TestTriplesSumToZero(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, true},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 9, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, test := range tests {\n        result := triples_sum_to_zero(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %v, expected %v, got %v\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1}))              \/\/ false\n}","tests":"func TestTriples_Sum_To_Zero(t *testing.T) {\n  candidate := triples_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -1}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{1, 2, 5, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -100}), expected: false },\n     { actual: candidate([]int{100, 3, 5, -100}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_41","nl":"mos_Latn","pl":"go_test.go","prompt":"package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Tʋʋm kãnga wilgda b sẽn maan b sẽn dat n maan bũmb ningã.\/\/B sẽn da wa n kẽnd to-to wã, wa b pa tol n wa wẽ taab ye.\/\/La b sẽn da tõe n maan bũmb ninsã ra pa tõe n sãam b sũur ye.\/\/Soab sẽn kẽnd n ya goabg n kẽng rɩtg sã n wa wẽed soab sẽn kẽnd n ya rɩtg n kẽng goabga.\/\/B yetame tɩ mobill a yiib n wa n lʋɩ taaba.\/\/Soabd a yiib n sɩng n be yɩɩg ne \/\/n mobillã kẽndame n ya goabg n kẽng rɩtgo; wakat yɛng pʋgẽ, mobill n to n be be.\/\/Tags-y n ges-y sor sẽn yaa tɩrga, n tar woglem sẽn pa tõe n bãng n bilg ye.func car_race_collision(n int) int {\n","canonical_solution":"package car_race_collision_test\n\nimport (\n    \"testing\"\n)\n\nfunc car_race_collision(n int) int {\n    return n\n}\n\nfunc TestCarRaceCollision(t *testing.T) {\n    cases := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 2},\n        {3, 3},\n        {10, 10},\n        {0, 0},\n    }\n\n    for _, c := range cases {\n        result := car_race_collision(c.n)\n        if result != c.expected {\n            t.Errorf(\"car_race_collision(%d) == %d, expected %d\", c.n, result, c.expected)\n        }\n    }\n}","tests":"func TestCar_Race_Collision(t *testing.T) {\n  candidate := car_race_collision\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 4 },\n     { actual: candidate(3), expected: 9 },\n     { actual: candidate(4), expected: 16 },\n     { actual: candidate(8), expected: 64 },\n     { actual: candidate(10), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_42","nl":"mos_Latn","pl":"go_test.go","prompt":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne sõor sẽn paas 1 \/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n","canonical_solution":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list with elements incremented by 1.\n\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n    result := make([]int, len(l))\n    for i, val := range l {\n        result[i] = val + 1\n    }\n    return result\n}\n\nfunc TestIncrList(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3}, []int{2, 3, 4}},\n        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},\n    }\n\n    for _, c := range cases {\n        result := incr_list(c.input)\n        for i := range result {\n            if result[i] != c.expected[i] {\n                t.Errorf(\"incr_list(%v) == %v, expected %v\", c.input, result, c.expected)\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(incr_list([]int{1, 2, 3}))          \/\/ should print [2, 3, 4]\n    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) \/\/ should print [6, 4, 6, 3, 4, 4, 10, 1, 124]\n}","tests":"func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_43","nl":"mos_Latn","pl":"go_test.go","prompt":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sã n pa rẽ, yaa ziri.\/\/a sã n be yel-bũndã pʋgẽ tɩ yel-bũndã yaa toor ne a taabã, a lebgda sɩda.\/\/pairs_sum_to_zero rɩkda nimero rãmb sõor sẽn yaa sõma wa sẽn kẽed ne rẽ. \/\/ >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([]int{1})\n\/\/ false\nfunc pairs_sum_to_zero(l []int) bool {\n","canonical_solution":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pairs_sum_to_zero(l []int) bool {\n    numSet := make(map[int]struct{})\n    for _, num := range l {\n        if _, found := numSet[-num]; found {\n            return true\n        }\n        numSet[num] = struct{}{}\n    }\n    return false\n}\n\nfunc TestPairsSumToZero(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, false},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 5, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, tc := range testCases {\n        result := pairs_sum_to_zero(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"pairs_sum_to_zero(%v) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %v, result: %v\\n\", tc.input, result)\n        }\n    }\n}","tests":"func TestPairs_Sum_To_Zero(t *testing.T) {\n  candidate := pairs_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_44","nl":"mos_Latn","pl":"go_test.go","prompt":"package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Bãngr-gomdã sõor pa ta 10 ye.\/\/lebg n wa ne sõor sẽn yaa toore, n lebg n wa ne sõor sẽn yaa toore. \/\/Toeem sõor ning sẽn tik n lebg sõor ning sẽn lebg x wã tɩ lebg sõor ning sẽn tik n lebg \/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunc change_base(x int, base int) string {\n","canonical_solution":"package change_base_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc change_base(x int, base int) string {\n    if base < 2 || base > 9 {\n        return \"\"\n    }\n\n    result := \"\"\n    for x > 0 {\n        remainder := x % base\n        result = strconv.Itoa(remainder) + result\n        x = x \/ base\n    }\n    \n    if result == \"\" {\n        return \"0\"\n    }\n    return result\n}\n\nfunc TestChangeBase(t *testing.T) {\n    tests := []struct {\n        x      int\n        base   int\n        result string\n    }{\n        {8, 3, \"22\"},\n        {8, 2, \"1000\"},\n        {7, 2, \"111\"},\n        {0, 2, \"0\"},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d to base %d\", test.x, test.base), func(t *testing.T) {\n            res := change_base(test.x, test.base)\n            if res != test.result {\n                t.Errorf(\"expected %s, got %s\", test.result, res)\n            }\n        })\n    }\n}","tests":"func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9, 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\" },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8, 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3, 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n     { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6, 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_45","nl":"mos_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D sã n ges a nug-rɩtgã woglem la a sẽn lebg n lebgd zĩig ningã, yaa wa trikõntã.\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given length of a side and height return area for a triangle.\n\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n    return 0.5 * float64(a) * float64(h)\n}\n\nfunc TestTriangleArea(t *testing.T) {\n    cases := []struct {\n        a, h int\n        expected float64\n    }{\n        {5, 3, 7.5},\n        {6, 4, 12.0},\n        {10, 2, 10.0},\n        {8, 5, 20.0},\n    }\n    \n    for _, c := range cases {\n        result := triangle_area(c.a, c.h)\n        if result != c.expected {\n            t.Errorf(\"triangle_area(%d, %d) == %f, expected %f\", c.a, c.h, result, c.expected)\n        } else {\n            fmt.Printf(\"triangle_area(%d, %d) == %f\\n\", c.a, c.h, result)\n        }\n    }\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 3), expected: 7.5 },\n     { actual: candidate(2, 2), expected: 2.0 },\n     { actual: candidate(10, 8), expected: 40.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_46","nl":"mos_Latn","pl":"go_test.go","prompt":"package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Gʋls-y n gʋls-y tʋʋm-noor sẽn na n sõng tɩ b bãng fib4 sõor pʋɩ-sʋkã n-n-soab sẽn yaa a soaba.\/\/Fib 4 (n) -> Fib 4 (n-1) + Fib 4 (n-2) + Fib 4 (n-3) + Fib 4 (n-4).\/\/fib4(3) -> 0 \/\/fib4(2) -> 2 \/\/fib4(1) -> 0 \/\/fib4(0) -> 0 \/\/Fib4 sõor pʋga yaa pʋga sẽn wõnd Fibbonacci pʋga sẽn yaa wa sẽn pʋgdã: \/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunc fib4(n int) int {\n","canonical_solution":"func fib4(n int) int {\n    if n < 0 {\n        return 0\n    }\n    \n    seq := []int{0, 0, 2, 0}\n    \n    if n < 4 {\n        return seq[n]\n    }\n    \n    for i := 4; i <= n; i++ {\n        next := seq[0] + seq[1] + seq[2] + seq[3]\n        seq[0] = seq[1]\n        seq[1] = seq[2]\n        seq[2] = seq[3]\n        seq[3] = next\n    }\n    \n    return seq[3]\n}","tests":"func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_47","nl":"mos_Latn","pl":"go_test.go","prompt":"package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D sã n na n lebg n ges sõor a ye sẽn be sõor a ye wã pʋgẽ wã, d na n yãa a sẽn yaa to-to.\/\/ >>> median([]int{3, 1, 2, 4, 5})\n\/\/ 3\n\/\/ >>> median([]int{-10, 4, 6, 1000, 10, 20})\n\/\/ 15.0\nfunc median(l []int) float64 {\n","canonical_solution":"package median_test\n\nimport (\n    \"sort\"\n)\n\nfunc median(l []int) float64 {\n    sort.Ints(l)\n    n := len(l)\n    if n%2 == 1 {\n        return float64(l[n\/2])\n    }\n    mid1, mid2 := l[(n\/2)-1], l[n\/2]\n    return float64(mid1+mid2) \/ 2.0\n}","tests":"func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}), expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_48","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/A gesda sã n yaa tɩ b kõ-a-la sõor sẽn yaa wa palindrome \/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunc is_palindrome(text string) bool {\n","canonical_solution":"package is_palindrome_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    n := len(text)\n    for i := 0; i < n\/2; i++ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"\", true},\n        {\"aba\", true},\n        {\"aaaaa\", true},\n        {\"zbcd\", false},\n    }\n\n    for _, test := range tests {\n        result := is_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_49","nl":"mos_Latn","pl":"go_test.go","prompt":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne 2^n modulo p (y segd n bãngame tɩ yaa sõor la d segd n bãngã).\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunc modp(n int, p int) int {\n","canonical_solution":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return 2^n modulo p (be aware of numerics).\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n    }\n    result := 1\n    base := 2\n    for n > 0 {\n        if n%2 == 1 {\n            result = (result * base) % p\n        }\n        base = (base * base) % p\n        n \/= 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n    tests := []struct {\n        n, p int\n        expected int\n    }{\n        {3, 5, 3},\n        {1101, 101, 2},\n        {0, 101, 1},\n        {3, 11, 8},\n        {100, 101, 1},\n    }\n\n    for _, test := range tests {\n        result := modp(test.n, test.p)\n        if result != test.expected {\n            t.Errorf(\"modp(%d, %d) = %d; expected %d\", test.n, test.p, result, test.expected)\n        } else {\n            fmt.Printf(\"modp(%d, %d) = %d; passed\\n\", test.n, test.p, result)\n        }\n    }\n}","tests":"func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_51","nl":"mos_Latn","pl":"go_test.go","prompt":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/remove_vowels yaa tʋʋm-noor sẽn dɩkd sõn-vɩɩs n lebgd n lebd ne sõn-vɩɩs sẽn ka be ye. \/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunc remove_vowels(text string) string {\n","canonical_solution":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc remove_vowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    var result strings.Builder\n    for _, char := range text {\n        if !strings.ContainsRune(vowels, char) {\n            result.WriteRune(char)\n        }\n    }\n    return result.String()\n}\n\nfunc TestRemoveVowels(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"abcdef\", \"bcdf\"},\n        {\"aaaaa\", \"\"},\n        {\"aaBAA\", \"B\"},\n        {\"zbcd\", \"zbcd\"},\n    }\n\n    for _, test := range tests {\n        if output := remove_vowels(test.input); output != test.expected {\n            t.Errorf(\"remove_vowels(%q) = %q; expected %q\", test.input, output, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    test := &testing.T{}\n    TestRemoveVowels(test)\n    if test.Failed() {\n        fmt.Println(\"Tests failed!\")\n    } else {\n        fmt.Println(\"All tests passed!\")\n    }\n}","tests":"func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual: candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_52","nl":"mos_Latn","pl":"go_test.go","prompt":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Return true if all numbers in the list l are below threshold t.  sã n yaa tɩ sõor fãa sẽn be sõor-kẽengã pʋgẽ wã yaa tɩlɛ.\/\/ >>> below_threshold([]int{1, 2, 4, 10}, 100)\n\/\/ true\n\/\/ >>> below_threshold([]int{1, 20, 4, 10}, 5)\n\/\/ false\nfunc below_threshold(l []int, t int) bool {\n","canonical_solution":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if all numbers in the list l are below threshold t.\nfunc below_threshold(l []int, t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ Example test cases\nfunc TestBelowThreshold(t *testing.T) {\n    if !below_threshold([]int{1, 2, 4, 10}, 100) {\n        t.Error(\"Expected true, got false\")\n    }\n    if below_threshold([]int{1, 20, 4, 10}, 5) {\n        t.Error(\"Expected false, got true\")\n    }\n}\n\nfunc main() {\n    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) \/\/ true\n    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  \/\/ false\n}","tests":"func TestBelow_Threshold(t *testing.T) {\n  candidate := below_threshold\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },\n     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_53","nl":"mos_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Rɩk sõor a yiib n paas x la y \/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n","canonical_solution":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Add two numbers x and y\n\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc TestAdd(t *testing.T) {\n    testCases := []struct {\n        x, y, expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"add(%d,%d)\", tc.x, tc.y), func(t *testing.T) {\n            result := add(tc.x, tc.y)\n            if result != tc.expected {\n                t.Errorf(\"Expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0, 1), expected: 1 },\n     { actual: candidate(1, 0), expected: 1 },\n     { actual: candidate(2, 3), expected: 5 },\n     { actual: candidate(5, 7), expected: 12 },\n     { actual: candidate(7, 5), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_54","nl":"mos_Latn","pl":"go_test.go","prompt":"package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ges-y gom-biis a yiib sã n tara yʋy sẽn yaa a yembre. \/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunc same_chars(s0 string, s1 string) bool {\n","canonical_solution":"package same_chars_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc same_chars(s0 string, s1 string) bool {\n\tcountChars := func(s string) map[rune]int {\n\t\tcount := make(map[rune]int)\n\t\tfor _, char := range s {\n\t\t\tcount[char]++\n\t\t}\n\t\treturn count\n\t}\n\n\tcount0 := countChars(s0)\n\tcount1 := countChars(s1)\n\n\tfor char := range count0 {\n\t\tif count1[char] < count0[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor char := range count1 {\n\t\tif count0[char] < count1[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc TestSameChars(t *testing.T) {\n\ttests := []struct {\n\t\ts0     string\n\t\ts1     string\n\t\tresult bool\n\t}{\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddeddabc\", true},\n\t\t{\"abcd\", \"dddddddabc\", true},\n\t\t{\"dddddddabc\", \"abcd\", true},\n\t\t{\"eabcd\", \"dddddddabc\", false},\n\t\t{\"abcd\", \"dddddddabce\", false},\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddddabc\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s vs %s\", test.s0, test.s1), func(t *testing.T) {\n\t\t\tif got := same_chars(test.s0, test.s1); got != test.result {\n\t\t\t\tt.Errorf(\"same_chars(%q, %q) = %v; want %v\", test.s0, test.s1, got, test.result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSame_Chars(t *testing.T) {\n  candidate := same_chars\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), expected: true },\n     { actual: candidate(\"abcd\", \"dddddddabc\"), expected: true },\n     { actual: candidate(\"dddddddabc\", \"abcd\"), expected: true },\n     { actual: candidate(\"eabcd\", \"dddddddabc\"), expected: false },\n     { actual: candidate(\"abcd\", \"dddddddabcf\"), expected: false },\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), expected: false },\n     { actual: candidate(\"aabb\", \"aaccc\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_55","nl":"mos_Latn","pl":"go_test.go","prompt":"package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Rɩk n-yemb Fibonacci sõor n lebg n wa. \/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunc fib(n int) int {\n","canonical_solution":"if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}","tests":"func TestFib(t *testing.T) {\n  candidate := fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10), expected: 55 },\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(8), expected: 21 },\n     { actual: candidate(11), expected: 89 },\n     { actual: candidate(12), expected: 144 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_56","nl":"mos_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Return true sã n yaa tɩ yalgr fãa tara yalgr sẽn zems ne a sẽn na n baasã. \/\/brackets yaa \"<\" la \">\" sõor sẽn yaa sõor wʋsgo.\/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '<' {\n            balance++\n        } else if char == '>' {\n            balance--\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected bool\n    }{\n        {input: \"<\", expected: false},\n        {input: \"<>\", expected: true},\n        {input: \"<<><>>\", expected: true},\n        {input: \"><<>\", expected: false},\n        {input: \"<<>>\", expected: true},\n        {input: \"><\", expected: false},\n    }\n\n    for _, tc := range testCases {\n        result := correct_bracketing(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %q\\n\", tc.input)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_57","nl":"mos_Latn","pl":"go_test.go","prompt":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Return true is list elements are monotonically increasing or decreasing.  B sẽn na n lebg n wa ne sɩd yaa tɩ sõorã paasdame bɩ a boogdame.\/\/ >>> monotonic([]int{1, 2, 4, 20})\n\/\/ true\n\/\/ >>> monotonic([]int{1, 20, 4, 10})\n\/\/ false\n\/\/ >>> monotonic([]int{4, 1, 0, -10})\n\/\/ true\nfunc monotonic(l []int) bool {\n","canonical_solution":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if list elements are monotonically increasing or decreasing.\nfunc monotonic(l []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    increasing := true\n    decreasing := true\n\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n\nfunc TestMonotonic(t *testing.T) {\n    fmt.Println(monotonic([]int{1, 2, 4, 20})) \/\/ true\n    fmt.Println(monotonic([]int{1, 20, 4, 10})) \/\/ false\n    fmt.Println(monotonic([]int{4, 1, 0, -10})) \/\/ true\n}","tests":"func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_58","nl":"mos_Latn","pl":"go_test.go","prompt":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/A lebsa bũmb a yiib sẽn yaa toor sẽn yaa a yembr n be sõor a yiib pʋgẽ.\/\/ >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n\/\/ []int{1, 5, 653}\n\/\/ >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n\/\/ []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n","canonical_solution":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]struct{})\n    set2 := make(map[int]struct{})\n    commonSet := make(map[int]struct{})\n    \n    \/\/ Fill set1 with elements of l1\n    for _, num := range l1 {\n        set1[num] = struct{}{}\n    }\n    \n    \/\/ Fill set2 with elements of l2\n    for _, num := range l2 {\n        if _, found := set1[num]; found {\n            commonSet[num] = struct{}{}\n        }\n        set2[num] = struct{}{}\n    }\n    \n    result := make([]int, 0, len(commonSet))\n    \n    \/\/ Collect common elements\n    for num := range commonSet {\n        result = append(result, num)\n    }\n    \n    \/\/ Sort the result\n    sort.Ints(result)\n    \n    return result\n}\n\nfunc TestCommon(t *testing.T) {\n    cases := []struct {\n        l1, l2 []int\n        expected []int\n    }{\n        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},\n        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},\n    }\n    \n    for _, c := range cases {\n        result := common(c.l1, c.l2)\n        if !equal(result, c.expected) {\n            t.Errorf(\"common(%v, %v) == %v, expected %v\", c.l1, c.l2, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_59","nl":"mos_Latn","pl":"go_test.go","prompt":"package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne n-yẽgd ning sẽn yaa kãseng n yɩɩdã. D ges n > 1 t'a pa prime. \/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunc largest_prime_factor(n int) int {\n","canonical_solution":"package largest_prime_factor_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc largest_prime_factor(n int) int {\n\tlargestFactor := 1\n\tdiv := 2\n\n\tfor n > 1 {\n\t\tif n%div == 0 {\n\t\t\tlargestFactor = div\n\t\t\tn \/= div\n\t\t} else {\n\t\t\tdiv++\n\t\t}\n\t}\n\n\treturn largestFactor\n}\n\nfunc TestLargestPrimeFactor(t *testing.T) {\n\ttests := []struct{\n\t\tn int\n\t\texpected int\n\t} {\n\t\t{13195, 29},\n\t\t{2048, 2},\n\t\t{123456, 643},\n\t\t{100, 5},\n\t\t{999, 37},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d\", test.n), func(t *testing.T) {\n\t\t\tif result := largest_prime_factor(test.n); result != test.expected {\n\t\t\t\tt.Errorf(\"largest_prime_factor(%d) = %d; expected %d\", test.n, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual: candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195), expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_60","nl":"mos_Latn","pl":"go_test.go","prompt":"package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/sum_to_n yaa tʋʋm-noor sẽn na n sõd sõor sẽn sɩng ne 1 n ta n. \/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunc sum_to_n(n int) int {\n","canonical_solution":"func sum_to_n(n int) int {\n    return n * (n + 1) \/ 2\n}\n\nfunc TestSumToN(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {30, 465},\n        {100, 5050},\n        {5, 15},\n        {10, 55},\n        {1, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"sum_to_n(%d)\", test.input), func(t *testing.T) {\n            result := sum_to_n(test.input)\n            if result != test.expected {\n                t.Errorf(\"Expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestSum_To_N(t *testing.T) {\n  candidate := sum_to_n\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(6), expected: 21 },\n     { actual: candidate(11), expected: 66 },\n     { actual: candidate(30), expected: 465 },\n     { actual: candidate(100), expected: 5050 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_61","nl":"mos_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Return true sã n yaa tɩ yalgr fãa tara yalgr sẽn zems ne a sẽn na n baasã. \/\/brackets yaa \"(\" la \"\") sõor sẽn yaa sõor wʋsgo.\/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '(' {\n            balance++\n        } else if char == ')' {\n            balance--\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"(\", false},\n        {\"()\", true},\n        {\"(()())\", true},\n        {\")(()\", false},\n        {\"\", true},\n        {\"((()))\", true},\n        {\"(()\", false},\n        {\"())\", false},\n    }\n\n    for _, tt := range tests {\n        result := correct_bracketing(tt.input)\n        if result != tt.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; want %v\", tt.input, result, tt.expected)\n        } else {\n            fmt.Printf(\"correct_bracketing(%q) = %v\\n\", tt.input, result)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_62","nl":"mos_Latn","pl":"go_test.go","prompt":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/D lebg n wa ne polynôme kãnga sẽn yit zĩig a ye wã.\/\/xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/xs makda polynom koeefɩtense. \/\/ >>> derivative([]int{3, 1, 2, 4, 5})\n\/\/ []int{1, 4, 12, 20}\n\/\/ >>> derivative([]int{1, 2, 3})\n\/\/ []int{2, 6}\nfunc derivative(xs []int) []int {\n","canonical_solution":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ xs represent coefficients of a polynomial.\n\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\/\/ Return derivative of this polynomial in the same form.\nfunc derivative(xs []int) []int {\n    if len(xs) <= 1 {\n        return []int{}\n    }\n    \n    derived := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        derived[i-1] = xs[i] * i\n    }\n    return derived\n}\n\nfunc TestDerivative(t *testing.T) {\n    testCases := []struct{\n        input []int\n        expected []int\n    }{\n        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},\n        {[]int{1, 2, 3}, []int{2, 6}},\n        {[]int{1}, []int{}},\n        {[]int{}, []int{}},\n    }\n\n    for _, testCase := range testCases {\n        result := derivative(testCase.input)\n        if !equal(result, testCase.expected) {\n            t.Errorf(\"For input %v, expected %v, but got %v\", \n                     testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestDerivative(t *testing.T) {\n  candidate := derivative\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },\n     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },\n     { actual: candidate([]int{1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_63","nl":"mos_Latn","pl":"go_test.go","prompt":"package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Yãk-y n tool-y-yã sẽn na yɩl n bãng n-rɩtg ning sẽn be nimero rãmb nins sẽn yaa to-to wã pʋgẽ wã.\/\/fibrÃ£n (n) == fibrÃ£n (n-1) + fibrÃ£n (n-2) + fibrÃ£n (n-3). \/\/fib fib ((2) == 1 \/\/fibfib ((1) == 0 \/\/fib fib ((0) == 0 \/\/FibFib sõor pʋga yaa pʋga sẽn wõnd Fibbonacci pʋga sẽn yaa wa sẽn pʋgdã: \/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunc fibfib(n int) int {\n","canonical_solution":"func fibfib(n int) int {\n    if n == 0 || n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    }\n\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        next := a + b + c\n        a = b\n        b = c\n        c = next\n    }\n    return c\n}","tests":"func TestFibfib(t *testing.T) {\n  candidate := fibfib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 1 },\n     { actual: candidate(1), expected: 0 },\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 24 },\n     { actual: candidate(10), expected: 81 },\n     { actual: candidate(12), expected: 274 },\n     { actual: candidate(14), expected: 927 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_64","nl":"mos_Latn","pl":"go_test.go","prompt":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/B sã n gʋlsd gom-bilã n na n wilg tɩ gom-bilã tara vɛrse, b tõe n gʋls-a lame n lebg tɩ vɛrse.\/\/B sẽn boond tɩ vokaalã yaa a, e, i, o, u.\/\/A sã n wa lebg n wa, a na n lebg n wa ne vokaal-rãmb sõor sẽn be sõor-gãndã pʋgẽ.\/\/Gʋls-y tʋʋm-noor ning sẽn boond tɩ vowels_count sẽn dɩkd sõn-vãoog sẽn makd \/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunc vowels_count(s string) int {\n","canonical_solution":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc vowels_count(s string) int {\n    count := 0\n    s = strings.ToLower(s)\n    vowels := \"aeiou\"\n    for i, char := range s {\n        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestVowelsCount(t *testing.T) {\n    tests := []struct {\n        input  string\n        output int\n    }{\n        {\"abcde\", 2},\n        {\"ACEDY\", 3},\n        {\"xyz\", 1},\n        {\"plenty\", 1},\n        {\"queue\", 3},\n    }\n\n    for _, test := range tests {\n        result := vowels_count(test.input)\n        if result != test.output {\n            t.Errorf(\"Expected %d, but got %d for input %s\", test.output, result, test.input)\n        } else {\n            fmt.Printf(\"Success: got %d for input %s\\n\", result, test.input)\n        }\n    }\n}","tests":"func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual: candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected: 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n     { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_65","nl":"mos_Latn","pl":"go_test.go","prompt":"package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sã n yaa shift > sõor sẽn yaa sõor bala, lebg n wa ne sõor sẽn yaa sõor bala.\/\/la a lebg n wa ne a sẽn wat ne wã wa sõor sẽn yaa sõor-yoodre. \/\/D sã n na n wẽnemd n ges sõor a x sẽn yaa tɩlɛ wã, d na n wẽnemda a x wã n teesdẽ.\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunc circular_shift(x int, shift int) string {\n","canonical_solution":"package circular_shift_test\n\nimport (\n    \"strconv\"\n)\n\nfunc circular_shift(x int, shift int) string {\n    strX := strconv.Itoa(x)\n    numDigits := len(strX)\n\n    if shift > numDigits {\n        \/\/ Reverse the digits if shift is greater than the number of digits\n        reversed := make([]byte, numDigits)\n        for i := 0; i < numDigits; i++ {\n            reversed[i] = strX[numDigits-i-1]\n        }\n        return string(reversed)\n    } else {\n        \/\/ Perform a circular shift\n        shift = shift % numDigits\n        return strX[numDigits-shift:] + strX[:numDigits-shift]\n    }\n}","tests":"func TestCircular_Shift(t *testing.T) {\n  candidate := circular_shift\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(100, 2), expected: \"001\" },\n     { actual: candidate(12, 2), expected: \"12\" },\n     { actual: candidate(97, 8), expected: \"79\" },\n     { actual: candidate(12, 1), expected: \"21\" },\n     { actual: candidate(11, 101), expected: \"11\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_66","nl":"mos_Latn","pl":"go_test.go","prompt":"package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/ASCII kood dãmba. \/\/Gʋls-y tʋʋm-noor sẽn na n dɩk sõor sẽn yaa wa kõom n lebg ne sõor sẽn yaa pipi sõorã balã.'\/\/Tʋʋmd \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunc digitSum(s string) int {\n","canonical_solution":"func digitSum(s string) int {\n    sum := 0\n    for _, char := range s {\n        if char >= 'A' && char <= 'Z' {\n            sum += int(char)\n        }\n    }\n    return sum\n}","tests":"func TestDigitsum(t *testing.T) {\n  candidate := digitSum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abAB\"), expected: 131 },\n     { actual: candidate(\"abcCd\"), expected: 67 },\n     { actual: candidate(\"helloE\"), expected: 69 },\n     { actual: candidate(\"woArBld\"), expected: 131 },\n     { actual: candidate(\"aAaaaXa\"), expected: 153 },\n     { actual: candidate(\" How are yOu?\"), expected: 151 },\n     { actual: candidate(\"You arE Very Smart\"), expected: 327 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_67","nl":"mos_Latn","pl":"go_test.go","prompt":"package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/n na n yɩ a soabã: \/\/Sebrã pʋgẽ, wilg-y mangã biis sõor sẽn be sebrã pʋgẽ. \/\/yaa pom-pemb la a ka-bõoneg la sõor sẽn yaa zãng sẽn makd biisã fãa sõore \/\/D sã n ges sõor ning sẽn makd  wã fãa sẽn yaa a wãnã, d na n yeelame tɩ  yaa a wãnã.\/\/B sẽn pʋɩt-b tɩɩsã biis koglg pʋgẽ wã yaa woto:\/\/Tʋʋm kãnga pʋgẽ, b na n kõ-y-la sõor sẽn makd kʋɩl-zẽed la pom-pãm sõore.\/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunc fruit_distribution(s string, n int) int {\n","canonical_solution":"package fruit_distribution_test\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"testing\"\n)\n\nfunc fruit_distribution(s string, n int) int {\n    re := regexp.MustCompile(`(\\d+) apples and (\\d+) oranges`)\n    matches := re.FindStringSubmatch(s)\n    \n    if len(matches) != 3 {\n        return -1 \/\/ Could return an error or a sentinel value if input format is incorrect\n    }\n\n    apples, _ := strconv.Atoi(matches[1])\n    oranges, _ := strconv.Atoi(matches[2])\n\n    mangoes := n - (apples + oranges)\n    return mangoes\n}\n\nfunc TestFruitDistribution(t *testing.T) {\n    var tests = []struct {\n        description string\n        inputString string\n        totalFruits int\n        expected    int\n    }{\n        {\"Test case 1\", \"5 apples and 6 oranges\", 19, 8},\n        {\"Test case 2\", \"0 apples and 1 oranges\", 3, 2},\n        {\"Test case 3\", \"2 apples and 3 oranges\", 100, 95},\n        {\"Test case 4\", \"100 apples and 1 oranges\", 120, 19},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.description, func(t *testing.T) {\n            result := fruit_distribution(tt.inputString, tt.totalFruits)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}\n\nfunc main() {\n    fmt.Println(fruit_distribution(\"5 apples and 6 oranges\", 19)) \/\/ 8\n    fmt.Println(fruit_distribution(\"0 apples and 1 oranges\", 3))  \/\/ 2\n    fmt.Println(fruit_distribution(\"2 apples and 3 oranges\", 100)) \/\/ 95\n    fmt.Println(fruit_distribution(\"100 apples and 1 oranges\", 120)) \/\/ 19\n}","tests":"func TestFruit_Distribution(t *testing.T) {\n  candidate := fruit_distribution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"5 apples and 6 oranges\", 19), expected: 8 },\n     { actual: candidate(\"5 apples and 6 oranges\", 21), expected: 10 },\n     { actual: candidate(\"0 apples and 1 oranges\", 3), expected: 2 },\n     { actual: candidate(\"1 apples and 0 oranges\", 3), expected: 2 },\n     { actual: candidate(\"2 apples and 3 oranges\", 100), expected: 95 },\n     { actual: candidate(\"2 apples and 3 oranges\", 5), expected: 0 },\n     { actual: candidate(\"1 apples and 100 oranges\", 120), expected: 19 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_68","nl":"mos_Latn","pl":"go_test.go","prompt":"package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makr a 1: \/\/Sã n pa be vɛrse-rãmb sẽn yaa pa-kẽema, bɩ sõor ning b sẽn kõ wã sã n yaa zaalem, lebg n wa [].\/\/B segd n lebg n waa ne nod ning b sẽn yãkã ne sõor sẽn yaa [ smalest_value, a indeksã ], \/\/Sã n mikame tɩ nod-dãmb wʋsg sẽn tar yaoolem n-yẽgd sẽn yaa bilf n yɩɩd fãa wã, lebg n wa ne nod-dãmb nins sẽn tar yaoolem n-yẽgdã. \/\/B sẽn yãk-a wã segd n yɩɩ sẽn pa tar-a n yɩɩd fãa.\/\/Yãmb tʋʋmda yaa y sẽn na n yãk bãnd a yembr n lebs-a.\/\/\"B kõ-d-la sõor sẽn makd tɩɩg wil sẽn tar nimero sẽn pa wẽns n be a pʋgẽ \/\/ >>> pluck([]int{4, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([]int{1, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([]int{})\n\/\/ []int{}\n\/\/ Example 4:\n\/\/ >>> pluck([]int{5, 0, 3, 0, 4, 2})\n\/\/ []int{0, 1}\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunc pluck(arr []int) []int {\n","canonical_solution":"package pluck_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ pluck function that implements the solution as described in the problem\nfunc pluck(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn []int{}\n\t}\n\n\tsmallestEvenValue := -1\n\tindex := -1\n\n\tfor i, val := range arr {\n\t\tif val%2 == 0 {\n\t\t\tif smallestEvenValue == -1 || val < smallestEvenValue {\n\t\t\t\tsmallestEvenValue = val\n\t\t\t\tindex = i\n\t\t\t}\n\t\t}\n\t}\n\n\tif index == -1 {\n\t\treturn []int{}\n\t}\n\n\treturn []int{smallestEvenValue, index}\n}\n\n\/\/ Example unit tests can be implemented by using the testing package\nfunc TestPluck(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{4, 2, 3}, []int{2, 1}},\n\t\t{[]int{1, 2, 3}, []int{2, 1}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := pluck(test.input)\n\t\tif len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {\n\t\t\tt.Errorf(\"pluck(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_69","nl":"mos_Latn","pl":"go_test.go","prompt":"package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sã n pa be tɩla woto, lebg n wa ne -1.\/\/Sõor sẽn yaa zãng naoor a wãn la b yãt-a sõorã pʋgẽ.\/\/yaa zaalem, la a naoor yaa n yɩɩd bɩ n zemsa ne nimero-rãmbã meng sẽn yaa sõma wã.\/\/B kõ-y-la sõor sẽn pa zaalem sẽn naag ne nimero-rãmb sẽn yaa sõma.\/\/ >>> search([]int{4, 1, 2, 2, 3, 1})\n\/\/ 2\n\/\/ >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})\n\/\/ 3\n\/\/ >>> search([]int{5, 5, 4, 4, 4})\n\/\/ -1\nfunc search(lst []int) int {\n","canonical_solution":"package search_test\n\nimport \"sort\"\n\nfunc search(lst []int) int {\n\tfrequency := make(map[int]int)\n\n\tfor _, num := range lst {\n\t\tfrequency[num]++\n\t}\n\n\tcandidates := []int{}\n\tfor num, count := range frequency {\n\t\tif count >= num {\n\t\t\tcandidates = append(candidates, num)\n\t\t}\n\t}\n\n\tif len(candidates) == 0 {\n\t\treturn -1\n\t}\n\n\tsort.Ints(candidates)\n\treturn candidates[len(candidates)-1]\n}","tests":"func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3, 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n     { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}), expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_70","nl":"mos_Latn","pl":"go_test.go","prompt":"package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Rẽ poore, yaa sẽn ketã fãa n na n yɩ wʋsgo, tɩ rẽ poor bɩ yɩ bilfu, la woto.\/\/Yaa y sã n sɩng ne minimã, \/\/D sã n kõ sõor sẽn yaa zãng sõor sõor sõor a ye, d na n lebg n wa ne sõor sẽn pa tũ sor-wilgr ye.\/\/ >>> strange_sort_list([]int{1, 2, 3, 4})\n\/\/ []int{1, 4, 2, 3}\n\/\/ >>> strange_sort_list([]int{5, 5, 5, 5})\n\/\/ []int{5, 5, 5, 5}\n\/\/ >>> strange_sort_list([]int{})\n\/\/ []int{}\nfunc strange_sort_list(lst []int) []int {\n","canonical_solution":"package strange_sort_list_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc strange_sort_list(lst []int) []int {\n\tif len(lst) == 0 {\n\t\treturn lst\n\t}\n\t\n\tsort.Ints(lst)\n\tres := make([]int, len(lst))\n\tleft, right := 0, len(lst)-1\n\ti := 0\n\n\tfor left <= right {\n\t\tif i%2 == 0 {\n\t\t\tres[i] = lst[left]\n\t\t\tleft++\n\t\t} else {\n\t\t\tres[i] = lst[right]\n\t\t\tright--\n\t\t}\n\t\ti++\n\t}\n\n\treturn res\n}\n\nfunc TestStrangeSortList(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []int\n\t\toutput []int\n\t}{\n\t\t{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},\n\t\t{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},\n\t}\n\tfor _, test := range tests {\n\t\tif res := strange_sort_list(test.input); !equal(res, test.output) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.output, res)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(strange_sort_list([]int{1, 2, 3, 4})) \/\/ Should print [1 4 2 3]\n}","tests":"func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_71","nl":"mos_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Yaa a tãab-n-soabã n yɩɩd a to wã.\/\/B sẽn boond tɩ triyangl tɩ \" triyangl sẽn tar nens a tãabã \" yaa b sẽn sã n get tɩ b sẽn sõd a yiibã fãa yaa wʋsgo .\/\/Sã n pa rẽ bɩ y lebs n gʋls tɩ -1 \/\/B sã n na n maan tɩ nug-rɩtg a tãabã lebg wa nug-rɩtg sẽn zemsã, b na n kɩtame tɩ nug-rɩtgã lebg nug-rɩtg a yiib sẽn zems zĩ-n-vẽenemã.\/\/D sã n ges sẽn yaa a tãabã sẽn yaa to-to wã, d na n lebg n togsa \/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunc triangle_area(a int, b int, c int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"math\"\n)\n\nfunc triangle_area(a int, b int, c int) float64 {\n    \/\/ Check for the validity of the triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    \/\/ Calculate the semi-perimeter\n    s := float64(a+b+c) \/ 2\n    \/\/ Calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    \/\/ Round the result to 2 decimal places\n    return math.Round(area*100) \/ 100.0\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: 6.0 },\n     { actual: candidate(1, 2, 10), expected: -1 },\n     { actual: candidate(4, 8, 5), expected: 8.18 },\n     { actual: candidate(2, 2, 2), expected: 1.73 },\n     { actual: candidate(1, 2, 3), expected: -1 },\n     { actual: candidate(10, 5, 7), expected: 16.25 },\n     { actual: candidate(2, 6, 3), expected: -1 },\n     { actual: candidate(1, 1, 1), expected: 0.43 },\n     { actual: candidate(2, 2, 10), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_72","nl":"mos_Latn","pl":"go_test.go","prompt":"package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Yĩngr q na n yɩga sã n yaa tɩlɛ (a yaa palindrom lisi) la a wilã sõor sã n pa ta bɩ n zemsa ne zɩɩm sẽn tõe n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll\/\/Gʋls-y tʋʋm-noor sẽn na n lebg n wa ne sɩd sã n yaa tɩ bõn-vɩɩgã q na n yɩkame, la a lebg n wa ne ziri sã n pa woto. \/\/ >>> will_it_fly([]int{1, 2}, 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([]int{3}, 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n","canonical_solution":"func will_it_fly(q []int, w int) bool {\n    sum := 0\n    n := len(q)\n\n    \/\/ Calculate the sum of the elements in q\n    for _, value := range q {\n        sum += value\n    }\n\n    \/\/ Check if sum is greater than the maximum possible weight\n    if sum > w {\n        return false\n    }\n\n    \/\/ Check if the list is a palindrome\n    for i := 0; i < n\/2; i++ {\n        if q[i] != q[n-i-1] {\n            return false\n        }\n    }\n\n    \/\/ If the list is balanced and sum is less than or equal to w\n    return true\n}","tests":"func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_73","nl":"mos_Latn","pl":"go_test.go","prompt":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/yaa wa b sẽn gʋlsd n lebgd n lebgd n lebgdẽ. Y tõe n toeema bũmb a ye n lebg bũmb a to.\/\/yaa tɩlɛ tɩ b toeeme n na n kɩt tɩ sõsgã yɩ wa palindrom.\/\/D sã n kõ sõor sẽn yaa zãng n yaa ar, d bao bũmb nins sõor sẽn yaa bilf n tõe n \/\/ >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})\n\/\/ 4\n\/\/ >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})\n\/\/ 1\n\/\/ >>> smallest_change([]int{1, 2, 3, 2, 1})\n\/\/ 0\nfunc smallest_change(arr []int) int {\n","canonical_solution":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_change(arr []int) int {\n    n := len(arr)\n    changes := 0\n    for i := 0; i < n\/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changes++\n        }\n    }\n    return changes\n}\n\nfunc TestSmallestChange(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},\n        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},\n        {[]int{1, 2, 3, 2, 1}, 0},\n    }\n\n    for _, test := range tests {\n        result := smallest_change(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %v, expected %d but got %d\", test.input, test.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", test.input)\n        }\n    }\n}","tests":"func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_74","nl":"mos_Latn","pl":"go_test.go","prompt":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Sã n yaa sõor a ye la b gʋlsd b yiibã fãa pʋgẽ, lebg n gʋls pipi sõorã.\/\/Bãngr-gomdã sõor sẽn yaa bilfã bee sõor a taabã fãa pʋgẽ.\/\/Gʋls tʋʋm-noor sẽn deegd sõor a yiib n lebg n wat ne sõor ning sẽn tar \/\/ >>> total_match([]string{}, []string{})\n\/\/ []string{}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n\/\/ []string{\"hI\", \"Hi\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"})\n\/\/ []string{\"hi\", \"admin\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\/\/ []string{\"hI\", \"hi\", \"hi\"}\n\/\/ >>> total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"})\n\/\/ []string{\"4\"}\nfunc total_match(lst1 []string, lst2 []string) []string {\n","canonical_solution":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ total_match function returns the list with the smaller total character count.\n\/\/ If both lists have the same character count, it returns the first list.\nfunc total_match(lst1 []string, lst2 []string) []string {\n    sumChars := func(lst []string) int {\n        total := 0\n        for _, str := range lst {\n            total += len(str)\n        }\n        return total\n    }\n    \n    sum1 := sumChars(lst1)\n    sum2 := sumChars(lst2)\n\n    if sum1 <= sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\n\/\/ Test functions can go below to verify the behavior of total_match.\nfunc TestTotalMatch(t *testing.T) {\n    cases := []struct {\n        lst1      []string\n        lst2      []string\n        expected  []string\n    }{\n        {[]string{}, []string{}, []string{}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}, []string{\"hI\", \"Hi\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}, []string{\"hi\", \"admin\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}, []string{\"hI\", \"hi\", \"hi\"}},\n        {[]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}, []string{\"4\"}},\n    }\n\n    for _, c := range cases {\n        result := total_match(c.lst1, c.lst2)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"total_match(%v, %v) == %v, expected %v\", c.lst1, c.lst2, result, c.expected)\n        }\n    }\n}","tests":"func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_75","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/D bãng tɩ a yaa bilf n yɩɩd 100.\/\/La b pa sɩd ye.\/\/Gʋls-y tʋʋm-noor sẽn na n lebg n wa ne sɩd sã n yaa tɩ sõor ning b sẽn kõ wã yaa sõor a 3 sẽn yaa pipi sõor b sẽn wilgi .\/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a int) bool {\n","canonical_solution":"func is_multiply_prime(a int) bool {\n\tif a < 2 {\n\t\treturn false\n\t}\n\n\tprimeNumbers := generatePrimesUpTo(100)\n\t\n\tfor i := 0; i < len(primeNumbers); i++ {\n\t\tfor j := i; j < len(primeNumbers); j++ {\n\t\t\tfor k := j; k < len(primeNumbers); k++ {\n\t\t\t\tif primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc generatePrimesUpTo(max int) []int {\n\tisPrime := make([]bool, max+1)\n\tfor i := 2; i <= max; i++ {\n\t\tisPrime[i] = true\n\t}\n\tfor i := 2; i*i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tfor j := i * i; j <= max; j += i {\n\t\t\t\tisPrime[j] = false\n\t\t\t}\n\t\t}\n\t}\n\tvar primes []int\n\tfor i := 2; i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn primes\n}","tests":"func TestIs_Multiply_Prime(t *testing.T) {\n  candidate := is_multiply_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: false },\n     { actual: candidate(30), expected: true },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: false },\n     { actual: candidate(125), expected: true },\n     { actual: candidate(105), expected: true },\n     { actual: candidate(126), expected: false },\n     { actual: candidate(729), expected: false },\n     { actual: candidate(891), expected: false },\n     { actual: candidate(1001), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_76","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/x yaa n sẽn tar pãng bala, n**int=x \/\/n yaa ziri, la a pa sɩd ye.\/\/Y tʋʋmda yaa y gʋls tʋʋm-noor sẽn lebg n lebg sɩd sã n yaa sõor x yaa \/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunc is_simple_power(x int, n int) bool {\n","canonical_solution":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_simple_power(x int, n int) bool {\n    if n <= 1 {\n        return x == 1\n    }\n    \n    current := n\n    for current <= x {\n        if current == x {\n            return true\n        }\n        current *= n\n    }\n    return false\n}\n\nfunc TestIsSimplePower(t *testing.T) {\n    tests := []struct {\n        x, n     int\n        expected bool\n    }{\n        {1, 4, true},\n        {2, 2, true},\n        {8, 2, true},\n        {3, 2, false},\n        {3, 1, false},\n        {5, 3, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.x, test.n), func(t *testing.T) {\n            result := is_simple_power(test.x, test.n)\n            if result != test.expected {\n                t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_77","nl":"mos_Latn","pl":"go_test.go","prompt":"package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sebre: y tõe n tagsame tɩ sẽn kẽed ne wã yaa wakat fãa. \/\/sã n yaa tɩ Ingegrã yaa koe-zĩig sẽn yaa zãngã.\/\/Gʋls-y tʋʋm-noor sẽn na n dɩk n tall n lebg n wa n kõ sɩd \/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunc iscube(a int) bool {\n","canonical_solution":"package iscube_test\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc iscube(a int) bool {\n\tif a < 0 {\n\t\ta = -a\n\t}\n\tcubeRoot := math.Cbrt(float64(a))\n\treturn cubeRoot == float64(int(cubeRoot))\n}\n\nfunc TestIsCube(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{1, true},\n\t\t{2, false},\n\t\t{-1, true},\n\t\t{64, true},\n\t\t{0, true},\n\t\t{180, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"iscube(%d)\", test.input), func(t *testing.T) {\n\t\t\tresult := iscube(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestIscube(t *testing.T) {\n  candidate := iscube\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: true },\n     { actual: candidate(2), expected: false },\n     { actual: candidate(-1), expected: true },\n     { actual: candidate(64), expected: true },\n     { actual: candidate(180), expected: false },\n     { actual: candidate(1000), expected: true },\n     { actual: candidate(0), expected: true },\n     { actual: candidate(1729), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_78","nl":"mos_Latn","pl":"go_test.go","prompt":"package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/la b sẽn gʋlsd-b tɩ A, B, C, D, E, F wã fãa yaa kãsenga. \/\/Sebr: y tõe n tagsame tɩ sẽn kẽed ne wã yaa sõma wakat fãa bɩ yaa vɛɛre.\/\/B (= piig pʋɩɩr 11), D (= piig pʋɩɩr 13). \/\/Woto wã, y segd n baoo sõor sẽn yaa 2, 3, 5, 7, \/\/Sõor a yiib n tãag a nu, a nu, a yopoe, a piig la a yembr, a piig la a tãab, a piig la a yopoe, a piig la a yopoe, a piig la a yopoe, a piig la a yopoe, ...\/\/B sẽn boond tɩ hexadecimalã yaa 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\/\/yaa 1 n yɩɩd tɩ pa wil-bõoneg a yiib sẽn yaa bõones n yɩɩd rẽ ye).\/\/Bõn-dãmb sẽn yaa pipi sõor (bɩ pipi sõor yaa pipi sõor \/\/a hexadecimal sõor wa sõor sẽn yaa sõor sẽn yaa hexadecimal sõor \/\/B yeel-y lame tɩ y gʋls tʋʋm-noor sẽn deegd \/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunc hex_key(num string) int {\n","canonical_solution":"func hex_key(num string) int {\n    primeDigits := map[rune]struct{}{\n        '2': {},\n        '3': {},\n        '5': {},\n        '7': {},\n        'B': {},\n        'D': {},\n    }\n\n    count := 0\n    for _, digit := range num {\n        if _, found := primeDigits[digit]; found {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHexKey(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"AB\", 1},\n        {\"1077E\", 2},\n        {\"ABED1A33\", 4},\n        {\"123456789ABCDEF0\", 6},\n        {\"2020\", 2},\n        {\"\", 0},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"hex_key(%s)\", test.input), func(t *testing.T) {\n            result := hex_key(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_79","nl":"mos_Latn","pl":"go_test.go","prompt":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/B sẽn yãkd lɛtrã n paasã yaa sẽn na yɩl n sõng-a t'a yɩ sõma. \/\/B na n paama 'db' n paas sõor a yiib sõorã sɩngr la a baasgẽ.\/\/Bõn-naandg fãa sẽn be sõor-gãndã pʋgẽ na n yɩɩ '0' bɩ '1'.\/\/yaa binɛɛr sõor sẽn yaa toore. Tʋʋmdã segd n lebg n waa ne sõor sẽn yaa toore, tɩ makrã fãa makd binɛɛr sõor \/\/B na n kõ-y-la sõor sẽn yaa tɩlɛ tɩ y tek n lebg \/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n","canonical_solution":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n\/\/ You will be given a number in decimal form and your task is to convert it to\n\/\/ binary format. The function should return a string, with each character representing a binary\n\/\/ number. Each character in the string will be '0' or '1'.\n\/\/ There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n\/\/ The extra characters are there to help with the format.\n\/\/ Examples:\n\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    binary := strconv.FormatInt(int64(decimal), 2)\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimalToBinary(t *testing.T) {\n    tests := []struct {\n        input  int\n        output string\n    }{\n        {15, \"db1111db\"},\n        {32, \"db100000db\"},\n        {0, \"db0db\"},\n        {1, \"db1db\"},\n        {255, \"db11111111db\"},\n    }\n\n    for _, test := range tests {\n        result := decimal_to_binary(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %d, expected %s, but got %s\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(decimal_to_binary(15))  \/\/ Output: db1111db\n    fmt.Println(decimal_to_binary(32))  \/\/ Output: db100000db\n    fmt.Println(decimal_to_binary(255)) \/\/ Output: db11111111db\n}","tests":"func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_80","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/B sã n yeel tɩ sõn-vãoog yaa hapgo, yaa a sã n ta sõor a 3 la a sã n yaa sõor a 3 fãa sẽn pʋgl taab n yaa toor-toore.\/\/Yãmb tʋʋmda yaa ges y sã n tara hapgo bɩ pa woto.\/\/B kõ-y-la sõor sẽn yaa sõor wʋsgo.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunc is_happy(s string) bool {\n","canonical_solution":"func is_happy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i <= len(s)-3; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestIs_Happy(t *testing.T) {\n  candidate := is_happy\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a\"), expected: false },\n     { actual: candidate(\"aa\"), expected: false },\n     { actual: candidate(\"abcd\"), expected: true },\n     { actual: candidate(\"aabb\"), expected: false },\n     { actual: candidate(\"adb\"), expected: true },\n     { actual: candidate(\"xyy\"), expected: false },\n     { actual: candidate(\"iopaxpoi\"), expected: true },\n     { actual: candidate(\"iopaxioi\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_81","nl":"mos_Latn","pl":"go_test.go","prompt":"package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/0.0 E \/\/> 0.0 D- \/\/> 0.7 D \/\/> 1.0 D+ \/\/> 1.3 C- \/\/> 1.7 C \/\/> 2.0 C+ \/\/> 2.3 B- \/\/> 2.7 B \/\/> 3.0 B+ \/\/> 3.3 A- \/\/> 3.7 A \/\/4.0 A + \/\/GPA. r-y sõor \/\/yaa tʋʋm-noor sẽn tõe n yiis lɛt-rãmb sõor n tũnug ne taabl ning sẽn pʋgdã: \/\/A kõ-y-la karen-biis kẽer sẽn paam minim minim minim sõor n gʋls n kõ-yã.\/\/Yaa a sẽn da tũnugd ne n makd nebã n pa le miẽ wã bal n kɩt t'a pa le tõe n bãng b sẽn maand bũmb ningã ye.\/\/Karen-saambã maana a meng sẽn na yɩl n mak b karen-biisã.\/\/Yaa semestrã yaoolem semenã la karen-saambã segd n kõo karen-biisã makrã.\/\/ >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})\n\/\/ []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\nfunc numerical_letter_grade(grades []float64) []string {\n","canonical_solution":"func numerical_letter_grade(grades []float64) []string {\n    letterGrades := []string{}\n    for _, grade := range grades {\n        if grade == 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if grade > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if grade > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if grade > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if grade > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if grade > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if grade > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if grade > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if grade > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if grade > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if grade > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if grade > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}","tests":"func TestNumerical_Letter_Grade(t *testing.T) {\n  candidate := numerical_letter_grade\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"} },\n     { actual: candidate([]float64{1.2}), expected: []string{\"D+\"} },\n     { actual: candidate([]float64{0.5}), expected: []string{\"D-\"} },\n     { actual: candidate([]float64{0.0}), expected: []string{\"E\"} },\n     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"} },\n     { actual: candidate([]float64{0.0, 0.7}), expected: []string{\"E\", \"D-\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_82","nl":"mos_Latn","pl":"go_test.go","prompt":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/length yaa pipi sõor bɩ pa sɩda \/\/Gʋls-y tʋʋm-noor sẽn na n dɩk n lebg n wa ne sɩd sã n yaa tɩ sõsgã yaa \/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunc prime_length(myString string) bool {\n","canonical_solution":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc prime_length(myString string) bool {\n    length := len(myString)\n    return isPrime(length)\n}\n\nfunc TestPrimeLength(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected bool\n    }{\n        {\"Hello\", true},\n        {\"abcdcba\", true},\n        {\"kittens\", true},\n        {\"orange\", false},\n    }\n\n    for _, testCase := range testCases {\n        result := prime_length(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"prime_length(%v) returned %v, expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(prime_length(\"Hello\"))  \/\/ true\n    fmt.Println(prime_length(\"abcdcba\"))  \/\/ true\n    fmt.Println(prime_length(\"kittens\"))  \/\/ true\n    fmt.Println(prime_length(\"orange\"))  \/\/ false\n}","tests":"func TestPrime_Length(t *testing.T) {\n  candidate := prime_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello\"), expected: true },\n     { actual: candidate(\"abcdcba\"), expected: true },\n     { actual: candidate(\"kittens\"), expected: true },\n     { actual: candidate(\"orange\"), expected: false },\n     { actual: candidate(\"wow\"), expected: true },\n     { actual: candidate(\"world\"), expected: true },\n     { actual: candidate(\"MadaM\"), expected: true },\n     { actual: candidate(\"Wow\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"HI\"), expected: true },\n     { actual: candidate(\"go\"), expected: true },\n     { actual: candidate(\"gogo\"), expected: false },\n     { actual: candidate(\"aaaaaaaaaaaaaaa\"), expected: false },\n     { actual: candidate(\"Madam\"), expected: true },\n     { actual: candidate(\"M\"), expected: false },\n     { actual: candidate(\"0\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_83","nl":"mos_Latn","pl":"go_test.go","prompt":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/yaa sõor sẽn yaa sõma sẽn sɩng ne 1 bɩ sẽn baas ne 1 \/\/D sã n kõ sõor sẽn yaa sõma n, d na n leoka sõor ning sẽn yaa n-digitã func starts_one_ends(n int) int {\n","canonical_solution":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the count of the numbers of n-digit\n\/\/ positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n    if n == 1 {\n        return 1\n    }\n\n    countStart1 := 1 * pow(10, n-1)\n    countEnd1 := 9 * pow(10, n-2)\n    \n    return countStart1 + countEnd1\n}\n\nfunc pow(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    result := 1\n    for i := 0; i < exp; i++ {\n        result *= base\n    }\n    return result\n}\n\nfunc TestStartsOneEnds(t *testing.T) {\n    tests := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 19},\n        {3, 189},\n        {4, 1899},\n        {5, 18999},\n    }\n\n    for _, tt := range tests {\n        testname := fmt.Sprintf(\"n=%d\", tt.n)\n        t.Run(testname, func(t *testing.T) {\n            result := starts_one_ends(tt.n)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}","tests":"func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected: 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_84","nl":"mos_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/D sã n kõ sõor sẽn yaa sõma n yaa sõma n yaa N, lebg n wa ne a sifrã sõor sẽn yaa a yiib-n-soabã. \/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunc solve(N int) string {\n","canonical_solution":"func solve(N int) string {\n    sum := 0\n    for N > 0 {\n        sum += N % 10\n        N \/= 10\n    }\n    return fmt.Sprintf(\"%b\", sum)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1000), expected: \"1\" },\n     { actual: candidate(150), expected: \"110\" },\n     { actual: candidate(147), expected: \"1100\" },\n     { actual: candidate(333), expected: \"1001\" },\n     { actual: candidate(963), expected: \"10010\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_85","nl":"mos_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/D sã n kõ sõor sẽn pa zaalem, d na n deng n sõd-a-la ne yel-bũndi.\/\/ >>> add([]int{4, 2, 6, 7})\n\/\/ 2\nfunc add(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 88}), expected: 88 },\n     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },\n     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },\n     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_86","nl":"mos_Latn","pl":"go_test.go","prompt":"package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/Sebrã pʋgẽ, y segd n tũuda gom-biisã sẽn be zĩig ningã, la y pa segd n bas zĩ-zulungã ye.\/\/Yaa sẽn na n yɩlẽ n paam n paas b sẽn da get b yellã.\/\/B ledga gom-paall sẽn na n yɩll tɩ b gʋlsd b fãa ne \/\/B sẽn kõ sor tɩ b gʋls sõssã to-to wã yaa sõss nins fãa sẽn be be wã (b sẽn welg ne zĩiga) \/\/Gʋls-y tʋʋm-noor sẽn dɩkd sõn-vãoog n lebg n wat ne a sẽn be sor zug to-to.\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s string) string {\n","canonical_solution":"package anti_shuffle_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc anti_shuffle(s string) string {\n    \/\/ Split the input string into words based on spaces\n    words := strings.Fields(s)\n\n    \/\/ Iterate over each word\n    for i, word := range words {\n        \/\/ Convert the word to a slice of runes for sorting\n        runes := []rune(word)\n        \/\/ Sort the runes using custom comparison\n        sort.Slice(runes, func(i, j int) bool {\n            return runes[i] < runes[j]\n        })\n        \/\/ Reassign the sorted runes back to the word\n        words[i] = string(runes)\n    }\n\n    \/\/ Rejoin the words into a single string, keeping original spaces\n    result := \"\"\n    inputIndex := 0\n\n    for _, word := range words {\n        \/\/ Add the spaces prior to the current word\n        for inputIndex < len(s) && s[inputIndex] == ' ' {\n            result += \" \"\n            inputIndex++\n        }\n        \/\/ Add the current sorted word\n        result += word\n        inputIndex += len(word)\n    }\n\n    \/\/ Add trailing spaces, if any.\n    for inputIndex < len(s) && s[inputIndex] == ' ' {\n        result += \" \"\n        inputIndex++\n    }\n\n    return result\n}","tests":"func TestAnti_Shuffle(t *testing.T) {\n  candidate := anti_shuffle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi\"), expected: \"Hi\" },\n     { actual: candidate(\"hello\"), expected: \"ehllo\" },\n     { actual: candidate(\"number\"), expected: \"bemnru\" },\n     { actual: candidate(\"abcd\"), expected: \"abcd\" },\n     { actual: candidate(\"Hello World!!!\"), expected: \"Hello !!!Wdlor\" },\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hi. My name is Mister Robot. How are you?\"), expected: \".Hi My aemn is Meirst .Rboot How aer ?ouy\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_87","nl":"mos_Latn","pl":"go_test.go","prompt":"package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sẽn paase, bɩ y welg sõsdã zĩis n welge.\/\/Rɩk-y n ges-y zĩ-kãens sẽn be zĩig ningã n sɩng ne sõor sẽn zẽkdẽ wã.\/\/Sebr fãa yaa sẽn na n yɩll n wilg sẽn yaa to-to.\/\/la lebg n wa ne listã sẽn be wã, [(x1, y1), (x2, y2) ...] tɩ \/\/D sã n kõ tɩ lst yaa sõor sẽn pa rẽnd n yaa x, bɩ d bao sõor sẽn pa rẽnd n yaa x sõor ning sẽn be sõor-kãng pʋgẽ wã, \/\/Sõsg fãa tõe n tara sull sõor sẽn yaa toor-toore.\/\/yaa wa matriksi, la pa wa matriksi wã ye.\/\/B kõ-y-la dʋrwa-rãmb sẽn yaa wa b sẽn ningd b sẽn datã b pʋsẽ.\/\/ >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n\/\/ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n\/\/ >>> get_row([][]int{}, 1)\n\/\/ [][]interface{}{}\n\/\/ >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n\/\/ [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n","canonical_solution":"package get_row_test\n\nimport (\n\t\"sort\"\n)\n\nfunc get_row(lst [][]int, x int) [][]interface{} {\n\tvar result [][]interface{}\n\n\tfor i, row := range lst {\n\t\tvar temp []interface{}\n\t\tfor j, value := range row {\n\t\t\tif value == x {\n\t\t\t\ttemp = append(temp, []interface{}{i, j})\n\t\t\t}\n\t\t}\n\t\t\/\/ Sort columns in descending order for the current row\n\t\tsort.Slice(temp, func(a, b int) bool {\n\t\t\treturn temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)\n\t\t})\n\t\tresult = append(result, temp...)\n\t}\n\n\t\/\/ result is already sorted by rows since we've traversed `lst` row by row\n\treturn result\n}","tests":"func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_88","nl":"mos_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/* ra toeem sõsg ning b sẽn kõ wã ye. \/\/Sebr a ye: \/\/Wala makre, y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore.\/\/y na n welga sõor ning sẽn be wã ne sẽn yikd-a wã, sã n yaa tɩ sõor ning sẽn yaa (( pipi indeksã yõodo, yaoolem indeksã yõodo) yaa pa-yende, \/\/D sã n kõ sõor sẽn pa zuloes n lebg n wa, d na n lebg n wa ne sõor sẽn kõ wã sẽn yaa cogo, sorã pʋga, \/\/ >>> sort_array([]int{})\n\/\/ []int{}\n\/\/ >>> sort_array([]int{5})\n\/\/ []int{5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n\/\/ []int{0, 1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n\/\/ []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return append([]int{}, array...)\n    }\n\n    result := append([]int{}, array...) \/\/ Copy the array to avoid mutating the input\n    if (result[0]+result[len(result)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(result))) \/\/ Sort in descending order\n    } else {\n        sort.Ints(result) \/\/ Sort in ascending order\n    }\n\n    return result\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_89","nl":"mos_Latn","pl":"go_test.go","prompt":"package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/B sẽn na n maan to-to tɩ b sẽn na n maan to-to wã yɩ sõma n yɩɩda, yaa b sẽn na n maan to-to wã.\/\/B segd n wẽnemda lɛtbã sẽn na yɩl tɩ lɛtbã \/\/lebgda sõor sẽn kẽed ne alfabɛtã sẽn lebg n lebg n wa. \/\/Na n maana fõntr sẽn na n dɩk n kõ sõor sẽn yaa wa arzegs la \/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunc encrypt(s string) string {\n","canonical_solution":"func encrypt(s string) string {\n    result := []rune(s)\n    for i, char := range result {\n        if char >= 'a' && char <= 'z' {\n            result[i] = 'a' + (char-'a'+4)%26\n        } else if char >= 'A' && char <= 'Z' {\n            result[i] = 'A' + (char-'A'+4)%26\n        }\n    }\n    return string(result)\n}","tests":"func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected: \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual: candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual: candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_91","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/B boonda gom-biis ne '.', '?' bɩ '!'. \/\/A sẽn yaa sũ-sãang soab yaa gom-bi-kãngã sẽn sɩng ne \"m\" wã.\/\/B na n kõ-y-la gom-biis sõor wʋsgo, la y tʋʋmd na n yɩɩ n sõd sõorã.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunc is_bored(S string) int {\n","canonical_solution":"package is_bored_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_bored(S string) int {\n    sentences := strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?' || r == '!'\n    })\n    count := 0\n    for _, sentence := range sentences {\n        trimmed := strings.TrimSpace(sentence)\n        if strings.HasPrefix(trimmed, \"I \") {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestIsBored(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"Hello world\", 0},\n        {\"The sky is blue. The sun is shining. I love this weather\", 1},\n        {\"I am here. I am there. I am everywhere\", 3},\n        {\"What's up? Are you ok? Yes, I am!\", 1},\n        {\"\", 0},\n        {\"I.\", 1},\n        {\"I! am excited. I? am curious\", 2},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"is_bored(%q)\", tt.input), func(t *testing.T) {\n            got := is_bored(tt.input)\n            if got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}","tests":"func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"), expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual: candidate(\"I feel good today. I will be productive. will kill It\"), expected: 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_92","nl":"mos_Latn","pl":"go_test.go","prompt":"package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/A sã n pa woto, a lebgda ziri.\/\/A sã n lebg n lebg n wa n na n wilg tɩ sõor a ye yaa a yiib a taabã sõor sẽn na n yɩ to-to wã, la tɩ sõor fãa yaa sõor sẽn pa zãngã.\/\/Na n wa ne tʋʋm-noor sẽn na n dɩkd sõor a 3.\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunc any_int(x float64, y float64, z float64) bool {\n","canonical_solution":"package any_int_test\n\nimport (\n    \"testing\"\n)\n\nfunc any_int(x float64, y float64, z float64) bool {\n    \/\/ Check if x, y, and z are integers\n    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {\n        return false\n    }\n\n    \/\/ Check if one of the numbers is the sum of the other two\n    if x == y+z || y == x+z || z == x+y {\n        return true\n    }\n\n    return false\n}\n\nfunc TestAnyInt(t *testing.T) {\n    if !any_int(5, 2, 7) {\n        t.Errorf(\"Expected true for any_int(5, 2, 7)\")\n    }\n    if any_int(3, 2, 2) {\n        t.Errorf(\"Expected false for any_int(3, 2, 2)\")\n    }\n    if !any_int(3, -2, 1) {\n        t.Errorf(\"Expected true for any_int(3, -2, 1)\")\n    }\n    if any_int(3.6, -2.2, 2) {\n        t.Errorf(\"Expected false for any_int(3.6, -2.2, 2)\")\n    }\n}","tests":"func TestAny_Int(t *testing.T) {\n  candidate := any_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 3, 1), expected: true },\n     { actual: candidate(2.5, 2, 3), expected: false },\n     { actual: candidate(1.5, 5, 3.5), expected: false },\n     { actual: candidate(2, 6, 2), expected: false },\n     { actual: candidate(4, 2, 2), expected: true },\n     { actual: candidate(2.2, 2.2, 2.2), expected: false },\n     { actual: candidate(-4, 6, 2), expected: true },\n     { actual: candidate(2, 1, 1), expected: true },\n     { actual: candidate(3, 4, 7), expected: true },\n     { actual: candidate(3.0, 4, 7), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_93","nl":"mos_Latn","pl":"go_test.go","prompt":"package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Yaa lɛtrã bal la y segd n ges n bãnge.\/\/Yaa vokaal sẽn be ãngilindã babg ning b sẽn gʋls ne ãngilindã pʋgẽ.\/\/Koe-no-kãng ne lɛtr ning sẽn be zĩ-bõoneg a yiib taoorã \/\/A sẽn maand woto wã, a toeema lɛtbã fãa sẽn yaa kãs-kãs-kãsã, n ledg vokaall fãa sẽn be  pʋgẽ wã.\/\/Gʋls tʋʋm-noor sẽn dɩkd koɛɛg n ningd-a \/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message string) string {\n","canonical_solution":"package encode_test\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc encode(message string) string {\n\tvar encodedMessage strings.Builder\n\n\t\/\/ Mapping of vowels to the letter appearing 2 places ahead\n\tvowelReplacement := map[rune]rune{\n\t\t'a': 'c',\n\t\t'A': 'C',\n\t\t'e': 'g',\n\t\t'E': 'G',\n\t\t'i': 'k',\n\t\t'I': 'K',\n\t\t'o': 'q',\n\t\t'O': 'Q',\n\t\t'u': 'w',\n\t\t'U': 'W',\n\t}\n\n\tfor _, char := range message {\n\t\tif unicode.IsLetter(char) {\n\t\t\t\/\/ Swap case of the character\n\t\t\tif unicode.IsUpper(char) {\n\t\t\t\tchar = unicode.ToLower(char)\n\t\t\t} else {\n\t\t\t\tchar = unicode.ToUpper(char)\n\t\t\t}\n\n\t\t\t\/\/ Replace vowel if the character is a vowel\n\t\t\tif replacement, isVowel := vowelReplacement[char]; isVowel {\n\t\t\t\tchar = replacement\n\t\t\t}\n\t\t}\n\n\t\tencodedMessage.WriteRune(char)\n\t}\n\n\treturn encodedMessage.String()\n}","tests":"func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_94","nl":"mos_Latn","pl":"go_test.go","prompt":"package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Y segd n baoo pipi sõor ning sẽn yaa kãseng n yɩɩdã n lebs a sõorã sõor sẽn yaa a sõorã.\/\/B kõ-y-la sõor sẽn yaa zãng sõor sõor wʋsgo.\/\/ >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\/\/ 10\n\/\/ >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\/\/ 25\n\/\/ >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\/\/ 13\n\/\/ >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\/\/ 11\n\/\/ >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\/\/ 3\n\/\/ >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\/\/ 7\nfunc skjkasdkd(lst []int) int {\n","canonical_solution":"package skjkasdkd_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\/\/ Function to calculate the sum of digits of a number\nfunc sumOfDigits(n int) int {\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\n\/\/ Function to find the largest prime and return the sum of its digits\nfunc skjkasdkd(lst []int) int {\n\tmaxPrime := -1\n\tfor _, num := range lst {\n\t\tif isPrime(num) && num > maxPrime {\n\t\t\tmaxPrime = num\n\t\t}\n\t}\n\tif maxPrime == -1 {\n\t\treturn 0\n\t}\n\treturn sumOfDigits(maxPrime)\n}\n\nfunc TestSkjkasdkd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n\t\t{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n\t\t{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n\t\t{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n\t\t{[]int{0, 81, 12, 3, 1, 21}, 3},\n\t\t{[]int{0, 8, 1, 2, 1, 7}, 7},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tresult := skjkasdkd(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"got %v, want %v\", result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     { actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_95","nl":"mos_Latn","pl":"go_test.go","prompt":"package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Fãagrã segd n lebg n waa ne ziri, sã n yaa tɩ kartã sẽn kõ wã yaa zaalem. \/\/B sã n pa gʋlsd-a ne lɛtr bɩ ne lɛtr fãa, a lebgda ziri.\/\/D sã n ges kartã, lebg n wa ne sɩd sã n yaa tɩ b fãa yaa sõor-biis sẽn yaa bils sẽn yaa nenga.\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunc check_dict_case(dict map[string]string) bool {\n","canonical_solution":"func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n\n    var allLowercase, allUppercase bool\n    for k := range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k) {\n            return false\n        }\n        if k == strings.ToLower(k) {\n            if allUppercase {\n                return false\n            }\n            allLowercase = true\n        }\n        if k == strings.ToUpper(k) {\n            if allLowercase {\n                return false\n            }\n            allUppercase = true\n        }\n    }\n\n    return allLowercase || allUppercase\n}","tests":"func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_96","nl":"mos_Latn","pl":"go_test.go","prompt":"package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/yaa sõor sẽn yaa sõor sẽn yaa pipi n yɩɩd n.\/\/D maan tʋʋmde n dɩkd nimero sẽn pa wẽnemd n lebg n lebg n lebg n nẽr pipi n wã \/\/ >>> count_up_to(5)\n\/\/ []int{2, 3}\n\/\/ >>> count_up_to(11)\n\/\/ []int{2, 3, 5, 7}\n\/\/ >>> count_up_to(0)\n\/\/ []int{}\n\/\/ >>> count_up_to(20)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17, 19}\n\/\/ >>> count_up_to(1)\n\/\/ []int{}\n\/\/ >>> count_up_to(18)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int {\n","canonical_solution":"func count_up_to(n int) []int {\n\tprimes := []int{}\n\tfor num := 2; num < n; num++ {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_97","nl":"mos_Latn","pl":"go_test.go","prompt":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/D gesame tɩ b sẽn gʋls bũmb ningã yaa sõma wakat fãa.\/\/b sullã wilã sẽn yaa to-to wã. \/\/Tʋʋmdã sẽn dɩkd nimero rãmb a yiib n lebg n watẽ wã \/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunc multiply(a int, b int) int {\n","canonical_solution":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Complete the function that takes two integers and returns \n\/\/ the product of their unit digits.\n\/\/ Assume the input is always valid.\nfunc multiply(a int, b int) int {\n    unitA := abs(a) % 10\n    unitB := abs(b) % 10\n    return unitA * unitB\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}\n\nfunc TestMultiply(t *testing.T) {\n    fmt.Println(multiply(148, 412)) \/\/ 16\n    fmt.Println(multiply(19, 28))   \/\/ 72\n    fmt.Println(multiply(2020, 1851)) \/\/ 0\n    fmt.Println(multiply(14, -15))  \/\/ 20\n}","tests":"func TestMultiply(t *testing.T) {\n  candidate := multiply\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(148, 412), expected: 16 },\n     { actual: candidate(19, 28), expected: 72 },\n     { actual: candidate(2020, 1851), expected: 0 },\n     { actual: candidate(14, -15), expected: 20 },\n     { actual: candidate(76, 67), expected: 42 },\n     { actual: candidate(17, 27), expected: 49 },\n     { actual: candidate(0, 1), expected: 0 },\n     { actual: candidate(0, 0), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_98","nl":"mos_Latn","pl":"go_test.go","prompt":"package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/D sã n kõ-y sõor sẽn yaa s, bɩ y sõd koe-biis nins sẽn yaa kãn-kãe n be vɛrse wã pʋgẽ wã sõore. \/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunc count_upper(s string) int {\n","canonical_solution":"package count_upper_test\n\nimport (\n    \"testing\"\n)\n\nfunc count_upper(s string) int {\n    uppercaseVowels := \"AEIOU\"\n    count := 0\n    \n    for i := 0; i < len(s); i += 2 {\n        if contains(uppercaseVowels, s[i]) {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc contains(vowels string, ch byte) bool {\n    for i := 0; i < len(vowels); i++ {\n        if vowels[i] == ch {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCountUpper(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestCount_Upper(t *testing.T) {\n  candidate := count_upper\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"aBCdEf\"), expected: 1 },\n     { actual: candidate(\"abcdefg\"), expected: 0 },\n     { actual: candidate(\"dBBE\"), expected: 0 },\n     { actual: candidate(\"B\"), expected: 0 },\n     { actual: candidate(\"U\"), expected: 1 },\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"EEEE\"), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_99","nl":"mos_Latn","pl":"go_test.go","prompt":"package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Ne f sẽn na n yãkd koe-zĩis a yiib n na n dɩk n togl n zãag ne zéro wã.\/\/sã n yaa tɩ sõorã yaa toore, \/\/Na n maana fɩkɛɛr sẽn na n dɩkd sõor sẽn makd sõor n kõ \/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n","canonical_solution":"package closest_integer_test\n\nimport (\n\t\"strconv\"\n\t\"math\"\n)\n\nfunc closest_integer(value string) int {\n\tnum, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn 0 \/\/ handle error appropriately in real scenarios\n\t}\n\tif num > 0 {\n\t\treturn int(math.Ceil(num - 0.5))\n\t}\n\treturn int(math.Floor(num + 0.5))\n}","tests":"func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_100","nl":"mos_Latn","pl":"go_test.go","prompt":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/i yaa kugã sõor sẽn be zĩigã (i+1). \/\/D lebg n wa ne kug sõor sẽn be sull fãa pʋgẽ, tɩ elemẽ wã be \/\/- sã n yaa tɩ n yaa tɩle. \/\/- sã n yaa n yaa pa-yɛlga, yaa sõor sẽn pʋgd n pa-yɛlga. \/\/B sẽn na n tall kug-bõonesã to-to wã yaa: \/\/Pipi sullã tara kug n.\/\/Sã n kõ-y sõor sẽn yaa sõma n, y segd n maana kug-rãmb sẽn tar n-yẽes n tigim taab n yɩ tʋʋlgo.\/\/ >>> make_a_pile(3)\n\/\/ []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n","canonical_solution":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc make_a_pile(n int) []int {\n    pile := make([]int, n)\n    currentStones := n\n\n    for i := 0; i < n; i++ {\n        pile[i] = currentStones\n        if n%2 == 0 {\n            currentStones += 2\n        } else {\n            currentStones += 2\n        }\n    }\n\n    return pile\n}\n\nfunc TestMakeAPile(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected []int\n    }{\n        {3, []int{3, 5, 7}},\n        {4, []int{4, 6, 8, 10}},\n        {1, []int{1}},\n        {5, []int{5, 7, 9, 11, 13}},\n    }\n\n    for _, c := range cases {\n        res := make_a_pile(c.input)\n        if fmt.Sprintf(\"%v\", res) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"make_a_pile(%d) == %v, expected %v\", c.input, res, c.expected)\n        }\n    }\n}","tests":"func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual: candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_101","nl":"mos_Latn","pl":"go_test.go","prompt":"package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/n welg sõsgã n lebg gom-biis sõor sõor sõor n lebg n wa. \/\/Y na n paama gom-biis sẽn welg ne vɛrse-rãmb la zĩ-zãrs n na n wilg y sẽn segd n maan to-to.\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n","canonical_solution":"package words_string_test\n\nimport (\n    \"testing\"\n    \"strings\"\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc words_string(s string) []string {\n    re := regexp.MustCompile(`[,\\s]+`)\n    return re.Split(s, -1)\n}\n\nfunc TestWordsString(t *testing.T) {\n    tests := []struct{\n        input string\n        expected []string\n    }{\n        {\"Hi, my name is John\", []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}},\n        {\"One, two, three, four, five, six\", []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}},\n        {\"a,b,c\", []string{\"a\", \"b\", \"c\"}},\n        {\"hello world\", []string{\"hello\", \"world\"}},\n    }\n\n    for _, test := range tests {\n        result := words_string(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestWords_String(t *testing.T) {\n  candidate := words_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi, my name is John\"), expected: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"} },\n     { actual: candidate(\"One, two, three, four, five, six\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"Hi, my name\"), expected: []string{\"Hi\", \"my\", \"name\"} },\n     { actual: candidate(\"One,, two, three, four, five, six,\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"ahmed     , gamal\"), expected: []string{\"ahmed\", \"gamal\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_102","nl":"mos_Latn","pl":"go_test.go","prompt":"package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/sã n pa be sõor a woto, a segd n lebg n waa ne -1.\/\/Sã n yaa tɩ  yaa sõor sẽn yaa zall n yɩɩd sẽn be zallã pʋgẽ [x, y] sẽn naag ne a taabã fãa.\/\/Tʋʋm kãnga rɩkda sõor a yiib sẽn yaa sõma x la y n lebg n wa ne \/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunc choose_num(x int, y int) int {\n","canonical_solution":"func choose_num(x int, y int) int {\n\tif x > y {\n\t\treturn -1\n\t}\n\t\/\/ Start from y and move backwards looking for the largest even number\n\tfor i := y; i >= x; i-- {\n\t\tif i%2 == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc TestChooseNum(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, expected int\n\t}{\n\t\t{12, 15, 14},\n\t\t{13, 12, -1},\n\t\t{4, 10, 10},\n\t\t{5, 5, -1},\n\t\t{6, 6, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"x=%d_y=%d\", test.x, test.y), func(t *testing.T) {\n\t\t\tresult := choose_num(test.x, test.y)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For choose_num(%d, %d), expected %d, but got %d\", test.x, test.y, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestChoose_Num(t *testing.T) {\n  candidate := choose_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(12, 15), expected: 14 },\n     { actual: candidate(13, 12), expected: -1 },\n     { actual: candidate(33, 12354), expected: 12354 },\n     { actual: candidate(5234, 5233), expected: -1 },\n     { actual: candidate(6, 29), expected: 28 },\n     { actual: candidate(27, 10), expected: -1 },\n     { actual: candidate(7, 7), expected: -1 },\n     { actual: candidate(546, 546), expected: 546 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_104","nl":"mos_Latn","pl":"go_test.go","prompt":"package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/Sebr ning b sẽn lebg n kõ wã segd n yɩɩ ne sor sẽn na n paasdẽ.\/\/B sẽn boond tɩ \"rɩtbã\" wã pa be ye.\/\/D sã n kõ sõor sẽn yaa sõma n yɩɩd fãa, d na n lebg n wa ne sõor sẽn yaa sõma n yɩɩd fãa.\/\/ >>> unique_digits([]int{15, 33, 1422, 1})\n\/\/ []int{1, 15, 33}\n\/\/ >>> unique_digits([]int{152, 323, 1422, 10})\n\/\/ []int{}\nfunc unique_digits(x []int) []int {\n","canonical_solution":"package unique_digits_test\n\nimport (\n    \"sort\"\n)\n\n\/\/ unique_digits returns a sorted list of all elements that don't have any even digit.\nfunc unique_digits(x []int) []int {\n    result := []int{}\n    for _, num := range x {\n        if hasEvenDigit(num) == false {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\n\/\/ hasEvenDigit checks if a given number contains any even digit.\nfunc hasEvenDigit(num int) bool {\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            return true\n        }\n        num \/= 10\n    }\n    return false\n}","tests":"func TestUnique_Digits(t *testing.T) {\n  candidate := unique_digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },\n     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },\n     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },\n     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_105","nl":"mos_Latn","pl":"go_test.go","prompt":"package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/\"Yɛl a yembr\", \"a yiib\", \"a tãab\", \"a naas\", \"a nu\", \"a yoob\", \"a yopoe\", \"a nii\", \"a wɛ\". \/\/n lebg n wa n gʋls sõor ning sẽn wa ne wã, la d ledg sõor fãa ne a yʋʋr sẽn zems ne \/\/D sã n kõ-y sõor sẽn yaa zãng sõor sõor sõor a ye, bɩ y welg sõor nins sẽn be 1 n tɩ ta 9 wã, \/\/ >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n\/\/ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\/\/ If the list is empty, return an empty list:\n\/\/ >>> by_length([]int{})\n\/\/ []string{}\n\/\/ If the list has any strange number ignore it:\n\/\/ >>> by_length([]int{1, -1, 55})\n\/\/ []string{\"One\"}\nfunc by_length(arr []int) []string {\n","canonical_solution":"package by_length_test\n\nimport (\n    \"testing\"\n    \"sort\"\n)\n\nfunc by_length(arr []int) []string {\n    \/\/ Filter numbers between 1 and 9\n    filtered := []int{}\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            filtered = append(filtered, num)\n        }\n    }\n\n    \/\/ Sort in ascending order\n    sort.Ints(filtered)\n\n    \/\/ Reverse the sorted slice\n    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n        filtered[i], filtered[j] = filtered[j], filtered[i]\n    }\n\n    \/\/ Map numbers to their corresponding names\n    numToString := map[int]string{\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\",\n    }\n\n    \/\/ Create the result slice with names\n    result := []string{}\n    for _, num := range filtered {\n        result = append(result, numToString[num])\n    }\n\n    return result\n}\n\nfunc TestByLength(t *testing.T) {\n    tests := []struct {\n        input []int\n        want  []string\n    }{\n        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}},\n        {[]int{}, []string{}},\n        {[]int{1, -1, 55}, []string{\"One\"}},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n            got := by_length(test.input)\n            if !equals(got, test.want) {\n                t.Errorf(\"got = %v; want %v\", got, test.want)\n            }\n        })\n    }\n}\n\nfunc equals(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_106","nl":"mos_Latn","pl":"go_test.go","prompt":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/i koees-rãmbã yaa sõor nins sẽn yit 1 n tɩ ta i wã koees-rãmb (1 * 2 * ... * i).\/\/i sɩngda ne 1. \/\/Wala makre, sõor a 1 n tɩ ta i wã sõor fãa.\/\/la a lebg n wa ne sõor sẽn yaa n, tɩ elemẽ wã sẽn be indeks i wã makrã yaa i wã faktoriyelã, sã n yaa tɩ i yaa paalle \/\/D rɩk f sẽn dɩkd n n yɩt tɩ b sõd-a, \/\/ >>> f(5)\n\/\/ []int{1, 2, 6, 24, 15}\nfunc f(n int) []int {\n","canonical_solution":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(num int) int {\n    if num <= 1 {\n        return 1\n    }\n    return num * factorial(num-1)\n}\n\nfunc sum(num int) int {\n    s := 0\n    for i := 1; i <= num; i++ {\n        s += i\n    }\n    return s\n}\n\nfunc TestF(t *testing.T) {\n    expected := []int{1, 2, 6, 24, 15}\n    result := f(5)\n    if !equals(expected, result) {\n        t.Errorf(\"Expected %v, got %v\", expected, result)\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(f(5)) \/\/ Output: []int{1, 2, 6, 24, 15}\n}","tests":"func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },\n     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },\n     { actual: candidate(1), expected: []int{1} },\n     { actual: candidate(3), expected: []int{1, 2, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_107","nl":"mos_Latn","pl":"go_test.go","prompt":"package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makr a 1: \/\/Sõor a yiib-n-soab sẽn yaa wa palindrom sẽn be ãnduni wã pʋgẽ.\/\/D sã n kõ sõor sẽn yaa sõma n lebg n wa ne sõor sẽn yaa toor la sẽn yaa toor \/\/ >>> even_odd_palindrome(3)\n\/\/ []interface{}{1, 2}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ []interface{}{4, 6}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned list has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n int) []interface{} {\n","canonical_solution":"func isPalindrome(num int) bool {\n    original := num\n    reversed := 0\n    for num > 0 {\n        reversed = reversed*10 + num%10\n        num \/= 10\n    }\n    return original == reversed\n}\n\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount, oddCount := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n}","tests":"func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8, 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     { actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63), expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5, 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     { actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1), expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_108","nl":"mos_Latn","pl":"go_test.go","prompt":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre, -123 tara nimero -1, 2 la 3.\/\/Sã n yaa sõor sẽn pa sõma, a pipi sifrã sẽn tar bãndã na n yɩɩ wẽnga: \/\/yaa sõor ning sẽn be elemẽ wã tɩ b sõor sõor sẽn yaa > 0. \/\/Gʋls tʋʋm-noor count_nums sẽn dɩkd nimero rãmb sõor n lebg n wat ne \/\/ >>> count_nums([]int{})\n\/\/ 0\n\/\/ >>> count_nums([]int{-1, 11, -11})\n\/\/ 1\n\/\/ >>> count_nums([]int{1, 1, 2})\n\/\/ 3\nfunc count_nums(arr []int) int {\n","canonical_solution":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        digits := num\n        sum := 0\n\n        if digits < 0 {\n            sum = digits % 10\n            digits = -digits \/ 10\n        }\n\n        for digits > 0 {\n            sum += digits % 10\n            digits \/= 10\n        }\n\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCountNums(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{}, 0},\n        {[]int{-1, 11, -11}, 1},\n        {[]int{1, 1, 2}, 3},\n    }\n\n    for _, tc := range testCases {\n        result := count_nums(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %v, got %v\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(count_nums([]int{-1, 11, -11})) \/\/ Output: 1\n    fmt.Println(count_nums([]int{1, 1, 2}))    \/\/ Output: 3\n}","tests":"func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_109","nl":"mos_Latn","pl":"go_test.go","prompt":"package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/Sebrã pʋgẽ, b wilgame tɩ b na n paama bũmb sẽn yaa toor fasɩ ne a taabã.\/\/Sã n yaa tɩ sõor ning b sẽn kõ wã yaa zaalem bɩ lebg n wa true. \/\/sã n pa rẽ bɩ lebg n wa ne ziri.\/\/Sã n tõe n paama sõdg sẽn welg sõma wã ne tʋʋm ning sẽn be yĩngrã \/\/Yaa sõor ning b sẽn sɩng n gʋlsd sõor-kãngã pʋgẽ wã, sẽn dat n yeel tɩ 0 soabã.\/\/B na n kɩtame tɩ sõor ning sẽn pʋglã lebg \/\/Zĩ-yerdg a ye rɩtgo rat n yeelame tɩ y na n toeema bũmb nins fãa sẽn be sõsgã pʋgẽ wã ne a ye.\/\/Y tõe n maana rɩtg n tees n kẽng rɩtg naoor wʋsgo.\/\/tʋʋm kãnga sẽn be sõsg ning sẽn pʋɩtã pʋgẽ: \/\/yaa ne  sẽn na n maan tɩ b tõog n welg sõor sẽn pa na n boog n paase.\/\/Y na n bao n bãnga y sã n tõe n paama y sẽn datã.\/\/D tara sõor sẽn yaa 'arr' sẽn tar nimero rãmb sẽn yaa N arr[1], arr[2], ..., arr[N].\/\/ >>> move_one_ball([]int{3, 4, 5, 1, 2})\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given list.\n\/\/ >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n","canonical_solution":"func move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n\n    \/\/ Detect the point where the order breaks\n    countBreaks := 0\n    index := -1\n\n    for i := 0; i < n; i++ {\n        if arr[i] > arr[(i+1)%n] {\n            countBreaks++\n            index = i\n        }\n    }\n\n    \/\/ If there is at most one point where the order breaks\n    if countBreaks <= 1 {\n        return true\n    }\n\n    return false\n}","tests":"func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_110","nl":"mos_Latn","pl":"go_test.go","prompt":"package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/Sã n pa woto bɩ y lebs n gʋls tɩ \"AO\".\/\/Y sã n dat tɩ lst1 wã fãa yɩ pa-yemsã, lebg n wa ne \"YƐƐ\".\/\/Sã n tõe n tek n tek bũmb nins sẽn be lst1 la lst2 wã n maan \/\/B pa mi bũmb ning sẽn kɩt tɩ b tõe n tek n dɩk n dɩk n maan yel-gɛtb nins sẽn be lst1 la lst2 wã ye.\/\/B sẽn maan to-to n na n kɩt tɩ sõor ning b sẽn gʋls tɩ \"lst1\" wã yɩ sõor sẽn yaa pa-kẽengã balã.\/\/la a bãngd sã n tõe n maana bũmb a taab n tek ne taaba \/\/Yel-kãngã pʋgẽ, y na n maana tʋʋm-noor sẽn na n dɩk sõor sõor a yiib n gʋls n kõ-yã, \/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})\n\/\/ \"YES\"\n\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})\n\/\/ \"NO\"\n\/\/ It is assumed that the input lists will be non-empty.\nfunc exchange(lst1 []int, lst2 []int) string {\n","canonical_solution":"func exchange(lst1 []int, lst2 []int) string {\n    hasEvenInLst2 := false\n    \n    for _, num := range lst2 {\n        if num%2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasEvenInLst2 {\n        return \"NO\"\n    }\n    \n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"YES\"\n        }\n    }\n\n    return \"YES\"\n}","tests":"func TestExchange(t *testing.T) {\n  candidate := exchange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: \"YES\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: \"NO\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: \"NO\" },\n     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: \"NO\" },\n     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: \"YES\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_111","nl":"mos_Latn","pl":"go_test.go","prompt":"package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Y sã n yãt seb-biis wʋsg sẽn gomd bũmb a ye, bɩ y lebs-b fãa. \/\/Yaa lɛtr ning b sẽn lebg n gʋls n yɩɩd la b sõd-a n yɩɩda.\/\/D sã n kõ-a sõor sẽn yaa wa karẽn-bi-bɩɩg sẽn welg ne zĩiga, a lebg n wata ne kartã.\/\/ >>> histogram(\"a b c\")\n\/\/ map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ map[string]int{\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ map[string]int{}\nfunc histogram(test string) map[string]int {\n","canonical_solution":"package histogram_test\n\nimport (\n    \"strings\"\n)\n\nfunc histogram(test string) map[string]int {\n    if test == \"\" {\n        return map[string]int{}\n    }\n\n    counts := make(map[string]int)\n    words := strings.Fields(test)\n    \n    var maxCount int\n    for _, word := range words {\n        counts[word]++\n        if counts[word] > maxCount {\n            maxCount = counts[word]\n        }\n    }\n\n    result := make(map[string]int)\n    for key, count := range counts {\n        if count == maxCount {\n            result[key] = count\n        }\n    }\n\n    return result\n}","tests":"func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_112","nl":"mos_Latn","pl":"go_test.go","prompt":"package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Y segd n lebg n waa ne sõor sẽn tar baasg la sɩd\/zãmb n na n ges-a.\/\/B boondame tɩ palindrôme sã n yaa wa sẽn be taoor la poorẽ wã bala.\/\/Rẽ poor bɩ y ges sã n yaa tɩ b sẽn gʋls n lebg n wa wã yaa palindrome. \/\/B kõ-d-la sõn-vãoog a yiib sẽn boond tɩ s la c, tɩ d segd n yiis a fãa sẽn yaa wa a sẽn be a pʋgẽ wã.\/\/Tʋʋmd \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ []interface{}{\"bcd\", false}\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ []interface{}{\"acdef\", false}\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ []interface{}{\"cdedc\", true}\nfunc reverse_delete(s string, c string) []interface{} {\n","canonical_solution":"func reverse_delete(s string, c string) []interface{} {\n    \/\/ Create a map to store the characters to be deleted\n    deleteMap := make(map[rune]bool)\n    for _, ch := range c {\n        deleteMap[ch] = true\n    }\n    \n    \/\/ Filter the string s by removing characters present in deleteMap\n    var filteredString []rune\n    for _, ch := range s {\n        if !deleteMap[ch] {\n            filteredString = append(filteredString, ch)\n        }\n    }\n    \n    \/\/ Check if the filtered string is a palindrome\n    n := len(filteredString)\n    isPalindrome := true\n    for i := 0; i < n\/2; i++ {\n        if filteredString[i] != filteredString[n-1-i] {\n            isPalindrome = false\n            break\n        }\n    }\n    \n    \/\/ Convert filteredString to a string and prepare result\n    resultString := string(filteredString)\n    return []interface{}{resultString, isPalindrome}\n}","tests":"func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\", \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_113","nl":"mos_Latn","pl":"go_test.go","prompt":"package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Yaa sẽn na n yɩlẽ tɩ b bãng b sẽn tõe n maan to-to n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam\/\/\" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\/\/Yɩl n bãng tɩ b sã n wa yãk bũmb fãa, a segd n yɩɩ \"tʋʋm-te-paalsã sõor sẽn yaa a yembr ne b sẽn yãkd bũmb ning fãa wã\".\/\/D sã n kõ sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor\/\/ >>> odd_count([]string{\"1234567\"})\n\/\/ []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n\/\/ >>> odd_count([]string{\"3\", \"11111111\"})\n\/\/ []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}\nfunc odd_count(lst []string) []string {\n","canonical_solution":"package odd_count_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc odd_count(lst []string) []string {\n\tresult := []string{}\n\tfor _, str := range lst {\n\t\toddCount := 0\n\t\tfor _, char := range str {\n\t\t\tif char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {\n\t\t\t\toddCount++\n\t\t\t}\n\t\t}\n\t\toutput := fmt.Sprintf(\"the number of odd elements %dn the str%1ng %d of the %dnput.\", oddCount, oddCount, oddCount)\n\t\tresult = append(result, output)\n\t}\n\treturn result\n}\n\nfunc TestOddCount(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{[]string{\"1234567\"}, []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}},\n\t\t{[]string{\"3\", \"11111111\"}, []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif result := odd_count(test.input); !equals(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equals(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOdd_Count(t *testing.T) {\n  candidate := odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"1234567\"}), expected: []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"} },\n     { actual: candidate([]string{\"3\", \"11111111\"}), expected: []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"} },\n     { actual: candidate([]string{\"271\", \"137\", \"314\"}), expected: []string{\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_114","nl":"mos_Latn","pl":"go_test.go","prompt":"package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Yaa sõor wʋsgo.\/\/D sã n kõ sõor sẽn yaa zɛlg n sõd sõor fãa, bao sõor sẽn yaa bilf n yɩɩd sõor fãa sẽn pa zɛlg \/\/ >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n\/\/ 1\n\/\/ >>> minSubArraySum([]int{-1, -2, -3})\n\/\/ -6\nfunc minSubArraySum(nums []int) int {\n","canonical_solution":"if len(nums) == 0 {\n        return 0\n    }\n    \n    minEndingHere := nums[0]\n    minSoFar := nums[0]\n\n    for _, num := range nums[1:] {\n        if minEndingHere > 0 {\n            minEndingHere = num\n        } else {\n            minEndingHere += num\n        }\n        \n        if minEndingHere < minSoFar {\n            minSoFar = minEndingHere\n        }\n    }\n    \n    return minSoFar\n}","tests":"func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     { actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}), expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_115","nl":"mos_Latn","pl":"go_test.go","prompt":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makr a 1: \/\/Wilg-y y sẽn segd n sik ko-bĩn-dãmbã naoor a wãn to.\/\/Yãmb tʋʋmda yaa y rɩk ko-bĩnd n kʋɩl bulsa.\/\/la ko-bĩn fãa tara pãng a yembr bala.\/\/B sẽn boond tɩ \"ko-bĩng\" wã yaa ko-bĩng sẽn tõe n dɩk koom n yiis ko-bĩng fãa pʋgẽ.\/\/la 1 fãa sẽn be be wã makda koom ye. \/\/B kõ-y-la b sẽn tõe n maan ne koomã sẽn be zĩig ningã.\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid [][]int, capacity int) int {\n","canonical_solution":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_fill(grid [][]int, capacity int) int {\n    totalLowerings := 0\n\n    for _, row := range grid {\n        waterInRow := 0\n        \n        for _, cell := range row {\n            if cell == 1 {\n                waterInRow++\n            }\n        }\n\n        totalLowerings += (waterInRow + capacity - 1) \/ capacity\n    }\n\n    return totalLowerings\n}\n\nfunc TestMaxFill(t *testing.T) {\n    tests := []struct {\n        grid     [][]int\n        capacity int\n        expected int\n    }{\n        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},\n        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},\n        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},\n    }\n\n    for _, test := range tests {\n        result := max_fill(test.grid, test.capacity)\n        if result != test.expected {\n            t.Errorf(\"For grid %v with capacity %d, expected %d but got %d\", test.grid, test.capacity, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) \/\/ Output: 6\n    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) \/\/ Output: 5\n    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) \/\/ Output: 0\n}","tests":"func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_116","nl":"mos_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Yaa woto la b segd n maan-a: \/\/Sã n yaa 1 wã sõor sẽn zem taaba, bɩ y welg n tik desimallã zugu.\/\/B sẽn gʋlsd b toorã pʋgẽ, b sõorã yaa sõor sẽn yikd n dabda.\/\/Kata wã pʋgẽ, y segd n welga nimero rãmb nins sẽn pa wẽnsã sõor sẽn zems ne \/\/ >>> sort_array([]int{1, 5, 2, 3, 4})\n\/\/ []int{1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{-2, -3, -4, -5, -6})\n\/\/ []int{-6, -5, -4, -3, -2}\n\/\/ >>> sort_array([]int{1, 0, 2, 3, 4})\n\/\/ []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(arr []int) []int {\n    sort.Slice(arr, func(i, j int) bool {\n        countOnes := func(x int) int {\n            count := 0\n            for x != 0 {\n                count += x & 1\n                x >>= 1\n            }\n            return count\n        }\n\n        countI := countOnes(arr[i])\n        countJ := countOnes(arr[j])\n\n        if countI == countJ {\n            return arr[i] < arr[j]\n        }\n        return countI < countJ\n    })\n    return arr\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_117","nl":"mos_Latn","pl":"go_test.go","prompt":"package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sebre: y tõe n tagsame tɩ b sẽn gʋlsd-a wã yaa lɛtɛɛr dãmb la zĩ-zãrs bala.\/\/Sã n yaa tɩ s yaa zaalem, tʋʋm-kãng segd n lebg n waa ne sõor sẽn pa zaalem. \/\/n gom-biis sẽn yaa wa taab n be sõss nins sẽn be sõssã pʋgẽ wã.\/\/a tʋʋm-noor sẽn lebg n wa ne gom-biis nins fãa sẽn yit s-yẽgẽ wã sẽn tar  sẽn zems zãng n be be wã.\/\/D sã n kõ-y sõor sẽn yaa s la sẽn yaa nimero, b yeel-y lame tɩ y maan \/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ []string{\"little\"}\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ []string{\"Mary\", \"lamb\"}\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []string{}\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ []string{\"world\"}\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n","canonical_solution":"package select_words_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc select_words(s string, n int) []string {\n\t\/\/ Define a helper function to check if a character is a consonant.\n\tisConsonant := func(c rune) bool {\n\t\tc = rune(strings.ToLower(string(c))[0])\n\t\treturn c >= 'a' && c <= 'z' && !strings.ContainsRune(\"aeiou\", c)\n\t}\n\n\t\/\/ Split the string into words.\n\twords := strings.Fields(s)\n\tvar result []string\n\n\t\/\/ Iterate over each word.\n\tfor _, word := range words {\n\t\tconsonantCount := 0\n\t\t\/\/ Count the consonants in the word.\n\t\tfor _, char := range word {\n\t\t\tif isConsonant(char) {\n\t\t\t\tconsonantCount++\n\t\t\t}\n\t\t}\n\t\t\/\/ If the number of consonants matches n, add the word to the result.\n\t\tif consonantCount == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestSelectWords(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tn        int\n\t\texpected []string\n\t}{\n\t\t{\"Mary had a little lamb\", 4, []string{\"little\"}},\n\t\t{\"Mary had a little lamb\", 3, []string{\"Mary\", \"lamb\"}},\n\t\t{\"simple white space\", 2, []string{}},\n\t\t{\"Hello world\", 4, []string{\"world\"}},\n\t\t{\"Uncle sam\", 3, []string{\"Uncle\"}},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tresult := select_words(testCase.s, testCase.n)\n\t\tif !equal(result, testCase.expected) {\n\t\t\tt.Errorf(\"For input '%s' with n=%d, expected %v, but got %v\", testCase.s, testCase.n, testCase.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_118","nl":"mos_Latn","pl":"go_test.go","prompt":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Y tõe n tagsame tɩ sõor ning b sẽn kõ wã tara ãngilind lɛtɛɛr bal bala.\/\/Bao-y tɩ gom-biis nins sẽn be yĩngrã pids-yã.\/\/B pa na n geelg gom-biis nins sẽn sɩng la b sẽn baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng ye.\/\/B sã n gʋlsd gomdã n sɩng ne a rɩtgo, b gʋlsda gomdã ne gom-biis a yiib sẽn be rɩtgã (sẽn zems ne b sẽn gʋlsd-a to-to wã).\/\/B kõ-y-la gomde. Y tʋʋmda yaa n yã gom-bi-yend sẽn pẽ-a n yɩɩd sẽn be a yiib sʋka.\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunc get_closest_vowel(word string) string {\n","canonical_solution":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_closest_vowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    isVowel := make(map[rune]bool)\n    for _, v := range vowels {\n        isVowel[v] = true\n    }\n    \n    n := len(word)\n    for i := n-2; i > 0; i-- {\n        if isVowel[rune(word[i])] && \n           !isVowel[rune(word[i-1])] && \n           !isVowel[rune(word[i+1])] {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\/\/ Test functions\nfunc TestGetClosestVowel(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"yogurt\", \"u\"},\n        {\"FULL\", \"U\"},\n        {\"quick\", \"\"},\n        {\"ab\", \"\"},\n    }\n    \n    for _, test := range tests {\n        result := get_closest_vowel(test.input)\n        if result != test.expected {\n            t.Errorf(\"get_closest_vowel(%q) = %q; want %q\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(get_closest_vowel(\"yogurt\")) \/\/ Output: \"u\"\n    fmt.Println(get_closest_vowel(\"FULL\"))   \/\/ Output: \"U\"\n    fmt.Println(get_closest_vowel(\"quick\"))  \/\/ Output: \"\"\n    fmt.Println(get_closest_vowel(\"ab\"))     \/\/ Output: \"\"\n}","tests":"func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_119","nl":"mos_Latn","pl":"go_test.go","prompt":"package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/D sã n tõe n maan sõn-vãoog sẽn yaa sõma, d segd n lebg n togsa 'N-yẽe' bala.\/\/\" (()) \" pa woto ye. \/\/Wala makre: \" ' (_) ' yaa sõma, tɩ \" ' (_) ' yaa sõma, tɩ \" ' (_) ' yaa sõma, tɩ \" ' (_) ' yaa sõma, tɩ \" ' (_) ' yaa sõma, tɩ \" ' (_) yaa sõma.\/\/B getame tɩ sõor sẽn yaa sõma yaa sã n yaa tɩ sõor ning sẽn be S pʋgẽ wã fãa yaa sõma \/\/B sã n wa na n yãk yam n maan bũmb a to, b na n wa paama sõor sẽn zemsã.\/\/Yãmb tʋʋmd yaa y ges sã n tõe n kɩtame tɩ b rɩk b yiibã n kẽ ne taaba.\/\/yaa \" ((\" bɩ \" \") bal la b be.\/\/B kõ-y-la sõor sẽn tar bãn a yiibu, b fãa tara vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb sẽn yaa vɛrse rãmb\/\/ >>> match_parens([]string{\"()(\", \")\"})\n\/\/ \"Yes\"\n\/\/ >>> match_parens([]string{\")\", \")\"})\n\/\/ \"No\"\nfunc match_parens(lst []string) string {\n","canonical_solution":"func match_parens(lst []string) string {\n\tleft1, right1 := countParens(lst[0])\n\tleft2, right2 := countParens(lst[1])\n\n\tif left1+left2 == right1+right2 {\n\t\treturn \"Yes\"\n\t}\n\n\tif left1-right1+left2-right2 == 0 {\n\t\treturn \"Yes\"\n\t}\n\n\treturn \"No\"\n}\n\nfunc countParens(s string) (left int, right int) {\n\tfor _, c := range s {\n\t\tif c == '(' {\n\t\t\tleft++\n\t\t} else if c == ')' {\n\t\t\tright++\n\t\t}\n\t}\n\treturn\n}\n\nfunc TestMatchParens(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected string\n\t}{\n\t\t{[]string{\"()(\", \")\"}, \"Yes\"},\n\t\t{[]string{\")\", \")\"}, \"No\"},\n\t\t{[]string{\"(((\", \")))\"}, \"Yes\"},\n\t\t{[]string{\"(\", \")\"}, \"Yes\"},\n\t\t{[]string{\"))(\", \"(\"}, \"No\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tif got := match_parens(test.input); got != test.expected {\n\t\t\t\tt.Errorf(\"match_parens(%v) = %v; want %v\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_120","nl":"mos_Latn","pl":"go_test.go","prompt":"package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makr a 1: \/\/yaa k la sẽn yɩɩd k sõor sẽn yaa arr. \/\/D sã n kõ sõor sẽn yaa sõma n yaa ar, la sõor sẽn yaa sõma n yaa k, d na n lebg n wa ne sõor sẽn yaa sõma \/\/ >>> maximum([]int{-3, -4, 5}, 3)\n\/\/ []int{-4, -3, 5}\n\/\/ Example 2:\n\/\/ >>> maximum([]int{4, -4, 4}, 2)\n\/\/ []int{4, 4}\n\/\/ Example 3:\n\/\/ >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n\/\/ []int{2}\n\/\/ Note:\n\/\/ 1. The length of the list will be in the range of [1, 1000].\n\/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n","canonical_solution":"package maximum_test\n\nimport (\n    \"sort\"\n)\n\nfunc maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    \n    \/\/ Sort the array\n    sort.Ints(arr)\n    \n    \/\/ Get the last k elements, which are the largest\n    return arr[len(arr)-k:]\n}","tests":"func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_121","nl":"mos_Latn","pl":"go_test.go","prompt":"package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/D sã n kõ sõor sẽn pa zaalem, d na n leoka bũmb nins fãa sẽn yaa zall n be zall zĩ-yendã.\/\/ >>> solution([]int{5, 8, 7, 1})\n\/\/ 12\n\/\/ >>> solution([]int{3, 3, 3, 3, 3})\n\/\/ 9\n\/\/ >>> solution([]int{30, 13, 24, 321})\n\/\/ 0\nfunc solution(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 0; i < len(lst); i++ {\n        if i%2 == 0 && lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestSolution(t *testing.T) {\n  candidate := solution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },\n     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },\n     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },\n     { actual: candidate([]int{5, 9}), expected: 5 },\n     { actual: candidate([]int{2, 4, 8}), expected: 0 },\n     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },\n     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_122","nl":"mos_Latn","pl":"go_test.go","prompt":"package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/yaa sẽn zems ne a yiib n yɩɩd sẽn sɩng ne a yiib n soabã fãa sẽn yaa a yiib n soabã fãa sẽn sɩng ne a yiib n soabã fãa sẽn sɩng ne a yiib n soabã fãa.\/\/D sã n kõ sõor sẽn pa zaalem sẽn yaa nimero rãmb sẽn yaa sõma arr la nimero rãmb sẽn yaa sõma k, lebg n wa \/\/ >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n","canonical_solution":"func add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd_Elements(t *testing.T) {\n  candidate := add_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },\n     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },\n     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },\n     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },\n     { actual: candidate([]int{1}, 1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_123","nl":"mos_Latn","pl":"go_test.go","prompt":"package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/get_odd_collatz(5) lebgda [1, 5] # Collatz rũmsa sẽn na n yɩll n paam 5 yaa [5, 16, 8, 4, 2, 1], woto wã, sõor nins sẽn pa yɩllã yaa 1 la 5 bal bala. \/\/Wala makre: \/\/2. b sẽn lebg n wa ne sõor sẽn welge, n paasdẽ. \/\/1. Collatz ((1) yaa [1]. \/\/Sebr a ye: \/\/B sẽn yetã yaa tɩ baa n sã n yaa n to-to, a ket n yaa 1 wakat fãa.\/\/Sã n yaa tɩ sẽn deng-a wã yaa pa yembr, sẽn pʋgd-a wã yaa sẽn deng-a wã naoor a 3.\/\/Sẽn deng-a wã yaa woto: sã n yaa tɩ sẽn deng-a wã yaa pa-yembr bɩ pa-yembr, sẽn pʋgdã yaa pʋɩ-sʋk \/\/yaa woto: sɩng ne nimero fãa sẽn yaa sõma n. Rẽ poore, b na n paama sull fãa ne \/\/Collatz sẽn yetã yaa bãng-bãngr sẽn kẽed ne matematiksã sẽn tɩ loe ne yel-bũndã sẽn yaa to-to wã.\/\/D sã n kõ sõor sẽn yaa sõma n lebg n wa ne sõor sẽn be sor zugu, sẽn tar sõor sẽn pa yembr ne a Collatz sẽn pʋgd taab to-to wã.\/\/ >>> get_odd_collatz(5)\n\/\/ []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n","canonical_solution":"package get_odd_collatz_test\n\nimport (\n    \"sort\"\n)\n\nfunc get_odd_collatz(n int) []int {\n    oddNumbers := make(map[int]bool)\n\n    for n != 1 {\n        if n%2 != 0 {\n            oddNumbers[n] = true\n        }\n        if n%2 == 0 {\n            n \/= 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n\n    \/\/ Add 1 to the set of odd numbers because the sequence always ends at 1\n    oddNumbers[1] = true\n\n    \/\/ Extract the keys, which represent the odd numbers\n    result := make([]int, 0, len(oddNumbers))\n    for num := range oddNumbers {\n        result = append(result, num)\n    }\n\n    \/\/ Sort the result\n    sort.Ints(result)\n\n    return result\n}","tests":"func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_124","nl":"mos_Latn","pl":"go_test.go","prompt":"package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/4. Sebrã segd n yɩɩ woto: mm-dd-yyyy \/\/3. Kiisã pa segd n ta 1 bɩ n yɩɩd 12 ye.\/\/Yaa tɩ b sã n na n maan b sẽn datã, b na n paama kibs sẽn na n yɩll tɩ b bãng b sẽn segd n maan bũmb ning yʋʋmd fãa.\/\/1. Dati wã sõor pa zaalem ye.\/\/Sebrã yaa sõma, sã n yaa tɩ noy nins sẽn pʋgdã fãa la b tũuda: \/\/sã n yaa tɩlɛ, a lebgda sɩda, sã n pa woto a lebgda ziri. \/\/Y segd n gʋlsa tʋʋm-noor sẽn na n wilg tɩ daarã yaa sɩda, la \/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunc valid_date(date string) bool {\n","canonical_solution":"func valid_date(date string) bool {\n    if len(date) == 0 {\n        return false\n    }\n\n    var month, day, year int\n    n, err := fmt.Sscanf(date, \"%02d-%02d-%04d\", &month, &day, &year)\n\n    if err != nil || n != 3 {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n\n    return true\n}","tests":"func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_126","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Sõor a ye, lebg n wa ne ziri.\/\/Sã n yaa tɩ sõorã yaa toor n yɩɩd a yembr bala, \/\/Y sã n paam sõor sõor sõor sẽn be wã, y na n lebg n waame tɩ b sõdga yaa toor-toore bɩ pa rẽ.\/\/ >>> is_sorted([]int{5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n\/\/ false\nfunc is_sorted(lst []int) bool {\n","canonical_solution":"func is_sorted(lst []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    \n    duplicateCount := make(map[int]int)\n\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        duplicateCount[lst[i]]++\n        if duplicateCount[lst[i]] > 1 {\n            return false\n        }\n    }\n    \n    \/\/ Check the last element for duplicate\n    duplicateCount[lst[len(lst)-1]]++\n    if duplicateCount[lst[len(lst)-1]] > 1 {\n        return false\n    }\n\n    return true\n}","tests":"func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_127","nl":"mos_Latn","pl":"go_test.go","prompt":"package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/[Kõosg bɩ b sẽn yiisd-a] makrã: \/\/Sã n pa be tɩ b yiibã kẽed taaba, lebg n wa ne \"AO\".\/\/Sã n pa rẽ bɩ y lebs n gʋls \"AO\". \/\/Sã n yaa sõor sẽn yaa pipi, lebg n wa ne \"YƐƐ\", \/\/a woglem yaa 1. A pa pipi sõor ye.\/\/Makre, sẽn kẽed ne seg-taabã (1, 3), (2, 4) yaa (2, 3) \/\/A yaa pipi sõor sẽn yaa tɩlɛ.\/\/Yãmb tʋʋmd yaa n bãng tɩ bãmb b yiibã sẽn kẽed taab to-to wã zulumsi yaa a wãn bala.\/\/Sẽn na yɩl n bãng sẽn sɩng to-to, d segd n tẽega tɩ sẽn sɩng to-to wã yaa bilf n yɩɩd sẽn na n baas to-to wã bɩ n zemse.\/\/A na n sɩnga ne a baasgo.\/\/B sẽn kõ wã yaa b sẽn na n wa baas n yeel tɩ b sẽn na n sɩng la b baasã yaa:\/\/sẽn be tɩ wakat fãa yaa sõor sẽn pa zʋʋg a ye. Wala makre, wakat = (sẽn sɩngda, sẽn baasda) = (1, 2).\/\/B kõ-y-la wakat a yiib tɩ y na n zĩnd n gese.\/\/ >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\/\/ \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n","canonical_solution":"package intersection_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to determine if a number is prime\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tif num == 2 {\n\t\treturn true\n\t}\n\tif num%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= num; i += 2 {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n\tstart1, end1 := interval1[0].(int), interval1[1].(int)\n\tstart2, end2 := interval2[0].(int), interval2[1].(int)\n\n\t\/\/ Determine the intersection of two intervals\n\tintersectStart := max(start1, start2)\n\tintersectEnd := min(end1, end2)\n\n\tif intersectStart > intersectEnd {\n\t\treturn \"NO\"\n\t}\n\n\t\/\/ The length of intersection is end - start\n\tlengthOfIntersection := intersectEnd - intersectStart\n\tif isPrime(lengthOfIntersection) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\n\/\/ Helper function to find the maximum of two integers\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\/\/ Helper function to find the minimum of two integers\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc TestIntersection(t *testing.T) {\n\tif intersection([]interface{}{1, 2}, []interface{}{2, 3}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != \"YES\" {\n\t\tt.Error(\"Expected YES\")\n\t}\n}","tests":"func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_129","nl":"mos_Latn","pl":"go_test.go","prompt":"package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/D lebg n wa ne cell-dãmb nins sẽn be sor ning sẽn yaa bilf n yɩɩd n na n tũ wã.\/\/B tõe n kɩsa sɩd tɩ b leokrã yaa toor fasɩ ne a taabã. \/\/A = A b.\/\/tɩ lst_A[i] < lst_B[i] la ne j fãa (1 <= j < i) d tara \/\/yaa sẽn na n yɩlẽ n bãng tɩ b sã n dɩk n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n mak n na n mak n mak n mak n na n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n\/\/(D bool-b lame tɩ lst_A la lst_B), lst_A yaa sõsg-yend sẽn yaa bil \/\/B sã n wa gʋlsd b sẽn gʋlsd bũmb ning b zĩ-gũbrẽ wã, b na n yeelame tɩ A la B sẽn gʋlsã yaa \/\/B getame tɩ sor A (a woglem k) yaa bilf n yɩɩd sor B (a woglem k) sã n yaa \/\/Y YÃMB pa tõe n pa yã-b ye.\/\/b pa segd n welg taab ye).\/\/D bãng tɩ k k k k k k k k-yẽng n be sorã pʋgẽ wã rat n yeelame tɩ d kẽe k sel-rãmb bala (ka \/\/cellã \/\/yaa woto, y tõe n kẽnga sɛb nins sẽn tar noor ne yãmbã pʋsẽ.\/\/Y tõe n yii sel buud fãa, la y tõe n kẽnga sel a to sẽn pẽ-a wã pʋgẽ, \/\/Y segd n baoo sor ning sẽn yaa bilf n yɩɩd n tõe n yã n sɩng ne \/\/yaa vugr bal la b yãend sẽn kẽed ne b sẽn na n maan bũmb ning fãa.\/\/Sõng-y tɩ y bãng tɩ f sã n na n sõdga f sẽn dat n maan bũmb ningã, f na n sõdga a soabã.\/\/D sã n kõ ẽtɛgnet sẽn tar sor-n-sood n yaa N la kolõns n yaa N (N >= 2) la sõor sẽn yaa sõma n yaa k, \/\/ >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)\n\/\/ []int{1, 2, 1}\n\/\/ >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)\n\/\/ []int{1}\nfunc minPath(grid [][]int, k int) []int {\n","canonical_solution":"package minPath_test\n\nimport (\n    \"sort\"\n)\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    \n    var dfs func(x, y, length int, path []int)\n    var minPath []int\n    minPath = make([]int, k)\n    for i := 0; i < k; i++ {\n        minPath[i] = n*n + 1\n    }\n\n    dfs = func(x, y, length int, path []int) {\n        if length == k {\n            if isLess(path, minPath) {\n                copy(minPath, path)\n            }\n            return\n        }\n        \n        for _, dir := range directions {\n            nx, ny := x+dir[0], y+dir[1]\n            if nx >= 0 && ny >= 0 && nx < n && ny < n {\n                path[length] = grid[nx][ny]\n                dfs(nx, ny, length+1, path)\n            }\n        }\n    }\n    \n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            path := make([]int, k)\n            path[0] = grid[i][j]\n            dfs(i, j, 1, path)\n        }\n    }\n    \n    return minPath\n}\n\nfunc isLess(a, b []int) bool {\n    for i := 0; i < len(a); i++ {\n        if a[i] < b[i] {\n            return true\n        }\n        if a[i] > b[i] {\n            return false\n        }\n    }\n    return false\n}","tests":"func TestMinpath(t *testing.T) {\n  candidate := minPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },\n     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },\n     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },\n     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },\n     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },\n     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },\n     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_130","nl":"mos_Latn","pl":"go_test.go","prompt":"package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/n + 1 pipi Tribonacci sõor pʋga. \/\/B kõ-y-la nimero sẽn pa wẽnemd n n-yẽng n na n lebg n wa ne \/\/= 2 + 3 + 3 = 8 \/\/tri(3) = tri(2) + tri(1) + tri(4) \/\/tri(4) = 3 \/\/tri(2) = 1 + (2 \/ 2) = 2 \/\/Wala makre: \/\/tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), sã n yaa tɩ n yaa pa-yende. \/\/tri (n) = 1 + n \/ 2, sã n yaa tɩ n yaa pa-yende. \/\/tri(1) = 3 \/\/A Tribonacci siglg yaa woto: \/\/La bũmb ning nebã sẽn pa mi yaa Tribonacci siglgã.\/\/Ned fãa mii Fibonacci rẽnna, a paama vaeesg wʋsg ne matematiks rãmba \/\/ >>> tri(3)\n\/\/ []int{1, 3, 2, 8}\nfunc tri(n int) []int {\n","canonical_solution":"func tri(n int) []int {\n    if n < 0 {\n        return []int{}\n    }\n    sequence := make([]int, n+1)\n    sequence[0] = 1 \/\/ tri(0) is not defined in problem, let's start with tri(1)\n    if n >= 1 {\n        sequence[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            sequence[i] = 1 + i\/2\n        } else {\n            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)\n        }\n    }\n    return sequence\n}\n\nfunc getNextTribonacci(n int) int {\n    if n%2 == 0 {\n        return 1 + n\/2\n    }\n    return getNextTribonacciRec(n+1)\n}\n\nfunc getNextTribonacciRec(n int) int {\n    triNext := make([]int, n+1)\n    triNext[0] = 1 \/\/ again assuming some base start\n    if n >= 1 {\n        triNext[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            triNext[i] = 1 + i\/2\n        } else {\n            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)\n        }\n    }\n    return triNext[n]\n}","tests":"func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0), expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_131","nl":"mos_Latn","pl":"go_test.go","prompt":"package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/D lebg n wa ne 0 sã n yaa tɩ sõor fãa yaa pa-yembr bala. \/\/D sã n kõ sõor sẽn yaa sõma n lebg n wa ne sõor sẽn yaa toor-toorã sẽn paasã. \/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunc digits(n int) int {\n","canonical_solution":"product := 1\n    hasOdd := false\n\n    for n > 0 {\n        digit := n % 10\n        if digit%2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n \/= 10\n    }\n\n    if hasOdd {\n        return product\n    }\n    return 0\n}","tests":"func TestDigits(t *testing.T) {\n  candidate := digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 5 },\n     { actual: candidate(54), expected: 5 },\n     { actual: candidate(120), expected: 1 },\n     { actual: candidate(5014), expected: 5 },\n     { actual: candidate(98765), expected: 315 },\n     { actual: candidate(5576543), expected: 2625 },\n     { actual: candidate(2468), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_132","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/sẽn na n yɩlẽ n paam tɩ b bãng b sẽn tõe n maan to-to n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam\/\/Fõn-kãng segd n lebg n waame tɩ yaa sɩd sã n yaa tɩlɛ tɩ b tũ ne gãntigã.\/\/Na n wa ne tʋʋm-noor sẽn na n dɩk n kõ sõor sẽn tar karẽn-bi-bɛd balã.\/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunc is_nested(myString string) bool {\n","canonical_solution":"func is_nested(myString string) bool {\n\tstack := []rune{}\n\tnestingFound := false\n\n\tfor _, char := range myString {\n\t\tif char == '[' {\n\t\t\tstack = append(stack, char)\n\t\t} else if char == ']' {\n\t\t\tif len(stack) > 0 {\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t\tif len(stack) > 0 {\n\t\t\t\t\tnestingFound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nestingFound\n}","tests":"func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_133","nl":"mos_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sẽn deng fãa, y na n deng n kẽnga ne bũmb ning sẽn be sõsgã pʋgẽ wã n tɩ ta a sẽn be yĩngrã.\/\/Y segd n lebg n togsa sõor nins b sẽn kõ sõor sõor sõor sõorã pʋgẽ wã sẽn lebg koabg zugã sõore, \/\/B kõ-y-la sõor sõor sõor n gʋls n tool-yã.\/\/ >>> lst([]float64{1.0, 2.0, 3.0})\n\/\/ 14\n\/\/ >>> lst([]float64{1.0, 4.0, 9.0})\n\/\/ 98\n\/\/ >>> lst([]float64{1.0, 3.0, 5.0, 7.0})\n\/\/ 84\n\/\/ >>> lst([]float64{1.4, 4.2, 0.0})\n\/\/ 29\n\/\/ >>> lst([]float64{-2.4, 1.0, 1.0})\n\/\/ 6\nfunc sum_squares(lst []float64) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n\t\"math\"\n)\n\nfunc sum_squares(lst []float64) int {\n\tsum := 0\n\tfor _, num := range lst {\n\t\tceiledNum := math.Ceil(num)\n\t\tsum += int(ceiledNum * ceiledNum)\n\t}\n\treturn sum\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },\n     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },\n     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },\n     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },\n     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },\n     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },\n     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },\n     { actual: candidate([]float64{0.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0}), expected: 1 },\n     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_134","nl":"mos_Latn","pl":"go_test.go","prompt":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sebr ning sẽn yaa \"word\" wã yaa seb-biis sull b sẽn welg ne zĩiga.\/\/Yaa gom-bilã babg la a pa sɩd ye.\/\/yaa alphabẽ wã sebre la pa \/\/Na n wa ne tʋʋm-noor sẽn na n lebg n wa true sã n yaa tɩ yaoolem nenga \/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n","canonical_solution":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"unicode\"\n)\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {\n        return false\n    }\n    \n    lastCharIndex := len(txt) - 1\n    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {\n        lastCharIndex--\n    }\n    \n    if lastCharIndex < 0 {\n        return false\n    }\n\n    if !unicode.IsLetter(rune(txt[lastCharIndex])) {\n        return false\n    }\n    \n    \/\/ Check if it's part of a word by looking at the previous character\n    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {\n        return false\n    }\n\n    return true\n}\n\nfunc TestCheckIfLastCharIsALetter(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n        {\"hello world\", true},\n        {\"a \", true},\n        {\" a\", true},\n        {\"abc\", false},\n        {\"abc \", false},\n    }\n\n    for _, c := range cases {\n        t.Run(c.input, func(t *testing.T) {\n            result := check_if_last_char_is_a_letter(c.input)\n            if result != c.expected {\n                t.Errorf(\"Expected %v, got %v for input \\\"%s\\\"\", c.expected, result, c.input)\n            }\n        })\n    }\n}","tests":"func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_135","nl":"mos_Latn","pl":"go_test.go","prompt":"package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/B sẽn tõe n maan to-to n paam n maan woto wã\/\/sã n pa be yel-bũndã, lebg n wa ne -1. Sõdg ning sẽn kõ wã pa na n tall \/\/pa yɩɩd bɩ pa zem bũmb ning sẽn deng-a wã ye.\/\/Na n wa ne tʋʋm-noor sẽn na n lebg n wa ne elemẽ wã sẽn yaa kãseng n yɩɩdã \/\/ >>> can_arrange([]int{1, 2, 4, 3, 5})\n\/\/ 3\n\/\/ >>> can_arrange([]int{1, 2, 3})\n\/\/ -1\nfunc can_arrange(arr []int) int {\n","canonical_solution":"package can_arrange_test\n\nfunc can_arrange(arr []int) int {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_136","nl":"mos_Latn","pl":"go_test.go","prompt":"package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sã n pa be nimero sẽn pa sõma bɩ nimero sẽn yaa sõma, lebg-y n kõ-y nil. \/\/Yaa sõor sẽn yaa sõma n yɩɩd sõor sẽn yaa sõma fãa.\/\/Yaa sẽn yaa-a kãseng n yɩɩd ne nimero-rãmb nins sẽn yaa wẽnsã sʋka, la b yaa sẽn yaa-a bilf n yɩɩda \/\/Na n wa ne tʋʋm-noor sẽn na n lebg n wa ne sõor (a, b), tɩ 'a' yaa \/\/ >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\/\/ []interface{}{nil, 1}\n\/\/ >>> largest_smallest_integers([]int{})\n\/\/ []interface{}{nil, nil}\n\/\/ >>> largest_smallest_integers([]int{0})\n\/\/ []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n","canonical_solution":"func largest_smallest_integers(lst []int) []interface{} {\n    var largestNegative *int\n    var smallestPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            if largestNegative == nil || num > *largestNegative {\n                largestNegative = new(int)\n                *largestNegative = num\n            }\n        } else if num > 0 {\n            if smallestPositive == nil || num < *smallestPositive {\n                smallestPositive = new(int)\n                *smallestPositive = num\n            }\n        }\n    }\n\n    var result = []interface{}{nil, nil}\n    if largestNegative != nil {\n        result[0] = *largestNegative\n    }\n    if smallestPositive != nil {\n        result[1] = *smallestPositive\n    }\n\n    return result\n}","tests":"func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_138","nl":"mos_Latn","pl":"go_test.go","prompt":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Bao-y n bãng-y n sã n tõe n gʋlsame tɩ yaa sõor sẽn zems sõor a 4 sẽn yaa tɩrs la sẽn yaa tɩrsã sõore.\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n","canonical_solution":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n\/\/ Example\n\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n    \/\/ The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    \/\/ Therefore, n must be at least 8 and n must be even\n    return n >= 8 && n%2 == 0\n}\n\n\/\/ Testing the function\nfunc TestIsEqualToSumEven(t *testing.T) {\n    cases := []struct {\n        n      int\n        expect bool\n    }{\n        {4, false},\n        {6, false},\n        {8, true},\n        {10, true},\n        {12, true},\n        {14, true},\n        {16, true},\n    }\n\n    for _, c := range cases {\n        result := is_equal_to_sum_even(c.n)\n        if result != c.expect {\n            t.Errorf(\"is_equal_to_sum_even(%d) == %v, expect %v\", c.n, result, c.expect)\n        } else {\n            fmt.Printf(\"Success: is_equal_to_sum_even(%d) == %v\\n\", c.n, result)\n        }\n    }\n}","tests":"func TestIs_Equal_To_Sum_Even(t *testing.T) {\n  candidate := is_equal_to_sum_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: false },\n     { actual: candidate(6), expected: false },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: true },\n     { actual: candidate(11), expected: false },\n     { actual: candidate(12), expected: true },\n     { actual: candidate(13), expected: false },\n     { actual: candidate(16), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_139","nl":"mos_Latn","pl":"go_test.go","prompt":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/n > 0 \/\/brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/B sẽn boond tɩ Brazil factoriallã yaa woto: \/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunc special_factorial(n int) int {\n","canonical_solution":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc special_factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    \n    result := 1\n    for i := 1; i <= n; i++ {\n        result *= factorial(i)\n    }\n    \n    return result\n}\n\nfunc factorial(x int) int {\n    if x == 0 {\n        return 1\n    }\n    prod := 1\n    for i := 1; i <= x; i++ {\n        prod *= i\n    }\n    return prod\n}\n\nfunc TestSpecialFactorial(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {4, 288},      \/\/ 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n        {3, 12},       \/\/ 3! * 2! * 1! = 6 * 2 * 1 = 12\n        {2, 2},        \/\/ 2! * 1! = 2 * 1 = 2\n        {1, 1},        \/\/ 1! = 1\n        {0, 1},        \/\/ Edge case for n=0, considered as 1 for special factorial\n    }\n\n    for _, c := range cases {\n        result := special_factorial(c.input)\n        if result != c.expected {\n            t.Errorf(\"special_factorial(%d) == %d, want %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(special_factorial(4)) \/\/ Output: 288\n    fmt.Println(special_factorial(3)) \/\/ Output: 12\n}","tests":"func TestSpecial_Factorial(t *testing.T) {\n  candidate := special_factorial\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: 288 },\n     { actual: candidate(5), expected: 34560 },\n     { actual: candidate(7), expected: 125411328000 },\n     { actual: candidate(1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_140","nl":"mos_Latn","pl":"go_test.go","prompt":"package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Rẽ poor bɩ y lebs n ning zĩ-zãrs nins fãa sẽn pʋgl taabã ne - \/\/la sã n yaa tɩ sõor sẽn yɩɩd zĩ-yend a yiib n pʋgd taaba, \/\/Y sã n paam vɛrse sẽn yaa sõor-koɛɛga, ledg-y zĩ-zãrsã fãa ne vɛrse-rãmb sẽn be tẽngre, \/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunc fix_spaces(text string) string {\n","canonical_solution":"package fix_spaces_test\n\nimport (\n    \"strings\"\n    \"testing\"\n)\n\nfunc fix_spaces(text string) string {\n    var result string\n    spaceCount := 0\n\n    for _, char := range text {\n        if char == ' ' {\n            spaceCount++\n        } else {\n            if spaceCount == 1 {\n                result += \"_\"\n            } else if spaceCount > 1 {\n                result += \"-\"\n            }\n            result += string(char)\n            spaceCount = 0\n        }\n    }\n\n    \/\/ Handle trailing spaces\n    if spaceCount == 1 {\n        result += \"_\"\n    } else if spaceCount > 1 {\n        result += \"-\"\n    }\n\n    return result\n}\n\nfunc TestFixSpaces(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected string\n    }{\n        {\" Example\", \"Example\"},\n        {\" Example 1\", \"Example_1\"},\n        {\" Example 2\", \"_Example_2\"},\n        {\" Example 3\", \"_Example-3\"},\n        {\" Hello    world\", \"_Hello-world\"},\n        {\"   Leading spaces\", \"-Leading_spaces\"},\n    }\n\n    for _, c := range cases {\n        result := fix_spaces(c.input)\n        if result != c.expected {\n            t.Errorf(\"fix_spaces(%q) == %q, expected %q\", c.input, result, c.expected)\n        }\n    }\n}","tests":"func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n     { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n     { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\" },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n     { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_141","nl":"mos_Latn","pl":"go_test.go","prompt":"package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/- B sẽn na n gʋls-a to-to wã segd n yɩɩ woto: ['txt', 'exe', 'dll'] \/\/b sẽn gʋls ne latinã ('a'-'z' la 'A'-'Z'). \/\/- Bãng-y tɩ b sã n gʋls tɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ \/\/- Fãllã yʋʋr tara zĩ-yend bala.\/\/- A ka segd n tall sõor sẽn yɩɩd nimero a tãab ye ('0' - '9') file wã yʋʋr pʋgẽ ye. \/\/b sẽn pidsd: \/\/B geta file yʋʋr t'a yaa sõma, sã n yaa tɩ bũmb nins fãa sẽn pʋgdã zemsa ne-a \/\/'Yes' sã n yaa tɩlɛ tɩ fÃ£a wã yʋʋr yɩ sõma, la sã n pa woto, a lebgda 'Nii' ye. \/\/Na n maana tʋʋm-noor sẽn dɩkd sõn-vãoog sẽn makd fail yʋʋr n lebg n wa \/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunc file_name_check(file_name string) string {\n","canonical_solution":"package file_name_check_test\n\nimport (\n    \"strings\"\n    \"unicode\"\n)\n\nfunc file_name_check(file_name string) string {\n    if len(file_name) == 0 {\n        return \"No\"\n    }\n\n    \/\/ Condition 2: Check for exactly one dot\n    dotIndex := strings.LastIndex(file_name, \".\")\n    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {\n        return \"No\"\n    }\n\n    \/\/ Split the file name into two parts\n    namePart := file_name[:dotIndex]\n    extension := file_name[dotIndex+1:]\n\n    \/\/ Condition 4: Check the extension\n    validExtensions := map[string]bool{\n        \"txt\": true,\n        \"exe\": true,\n        \"dll\": true,\n    }\n    if !validExtensions[extension] {\n        return \"No\"\n    }\n\n    \/\/ Condition 3: Check the first character before the dot\n    if !unicode.IsLetter(rune(namePart[0])) {\n        return \"No\"\n    }\n\n    \/\/ Condition 1: Count the digits in the file name\n    digitCount := 0\n    for _, char := range namePart {\n        if unicode.IsDigit(char) {\n            digitCount++\n        }\n    }\n    if digitCount > 3 {\n        return \"No\"\n    }\n\n    \/\/ If all conditions are met, return \"Yes\"\n    return \"Yes\"\n}","tests":"func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual: candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"\/this_is_valid.dll\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n     { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual: candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual: candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     { actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected: \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_142","nl":"mos_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/n toeemd sõor nins sẽn be sõor ning pʋgẽ tɩ b nimero wã pa 3 bɩ 4 naoor ye. Tʋʋmdã na n lebg n waa ne sõor nins fãa sẽn be sõorã pʋgẽ wã.\/\/A sã n yaa 4 naoor wʋsgo, la a sã n pa 3 naoor wʋsgo, a na n wẽe nimero-rãmb nins sẽn be wã tɩ b lebg a yiib n paase.\/\/Tʋʋm kãnga na n dɩka sõor sẽn yaa zãng sõor sõor sõor fãa pʋgẽ, tʋʋma na n tõoga sõor sẽn yaa zãng sõorã sã n yaa a \/\/\" \/\/ >>> lst\n\/\/ []int{1, 2, 3}\n\/\/ >>> lst\n\/\/ int{}\n\/\/ >>> lst\n\/\/ []int{-1, -5, 2, -1, -5}\nfunc sum_squares(lst []int) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n    \"testing\"\n)\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for i, val := range lst {\n        if i%3 == 0 {\n            sum += val * val\n        } else if i%4 == 0 {\n            sum += val * val * val\n        } else {\n            sum += val\n        }\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct {\n        lst      []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 10},   \/\/ 1^2 + 2 + 3 = 10\n        {[]int{}, 0},           \/\/ empty list\n        {[]int{-1, -5, 2, -1, -5}, 0}, \/\/ (-1)^2 + (-5)^3 + 2 + (-1) = -118\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.lst)\n        if result != test.expected {\n            t.Errorf(\"sum_squares(%v) = %d; expected %d\", test.lst, result, test.expected)\n        }\n    }\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 6 },\n     { actual: candidate([]int{1, 4, 9}), expected: 14 },\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },\n     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },\n     { actual: candidate([]int{0}), expected: 0 },\n     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },\n     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },\n     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },\n     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },\n     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_143","nl":"mos_Latn","pl":"go_test.go","prompt":"package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makr a 1: \/\/Gom-biis nins sẽn be sõssã sẽn yaa to-to wã segd n yɩɩ wa pipi sõsgã.\/\/sẽn tar sõor sẽn yaa sõor pipi wã, \/\/la y segd n lebg n waa ne sõsg sẽn naag ne gom-bil ning b sẽn da gʋls pipi wã, \/\/vɛrse wã tara gom-biis kẽer sẽn welg ne zĩ-zãrgre, \/\/B kõ-y-la sõsg sẽn makd sõsg a ye, \/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n","canonical_solution":"package words_in_sentence_test\n\nimport (\n    \"strings\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc words_in_sentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var result []string\n\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n\n    return strings.Join(result, \" \")\n}","tests":"func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_144","nl":"mos_Latn","pl":"go_test.go","prompt":"package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Y tõe n yeelame tɩ x, la n yaa wil-bɛɛg sẽn zems la b pa tar zéro wa b sẽn boond-a wã ye.\/\/B sẽn boond tɩ \"numerator\" bɩ \"denominator\" wã, b sẽn boond tɩ \"numerator\" la \"denominator\" wã fãa yaa sõor sẽn yaa sõma.\/\/Sã n pa rẽ, b yiibã fãa, x la n, yaa wilgr sẽn yaa wa b sẽn gʋls n wilg wilgr toɛy-toɛy n yaa to-to wã, la b tara seb-kãngã: \/\/x * n. Tʋʋmdã lebgda sɩd sã n yaa tɩ x * n yaa sõor sẽn yaa zãng la a yaa zĩrĩ \/\/Y tʋʋmda yaa y sẽn na n maan tʋʋm-noor sẽn na n kɩt tɩ koe-kãngã yɩ nana \/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunc simplify(x string, n string) bool {\n","canonical_solution":"package simplify_test\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc simplify(x string, n string) bool {\n    \/\/ Split the input strings into numerators and denominators\n    xParts := strings.Split(x, \"\/\")\n    nParts := strings.Split(n, \"\/\")\n\n    \/\/ Convert the string parts to integers\n    xNumerator, _ := strconv.Atoi(xParts[0])\n    xDenominator, _ := strconv.Atoi(xParts[1])\n    nNumerator, _ := strconv.Atoi(nParts[0])\n    nDenominator, _ := strconv.Atoi(nParts[1])\n\n    \/\/ Perform the multiplication (x * n) = (xNumerator\/nDenominator) * (nNumerator\/nDenominator)\n    resultNumerator := xNumerator * nNumerator\n    resultDenominator := xDenominator * nDenominator\n\n    \/\/ Check if the result is a whole number\n    return resultNumerator%resultDenominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n    if !simplify(\"1\/5\", \"5\/1\") {\n        t.Fatalf(\"Expected true, got false\")\n    }\n    if simplify(\"1\/6\", \"2\/1\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n    if simplify(\"7\/10\", \"10\/2\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n}","tests":"func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/6\", \"2\/1\"), expected: false },\n     { actual: candidate(\"5\/1\", \"3\/1\"), expected: true },\n     { actual: candidate(\"7\/10\", \"10\/2\"), expected: false },\n     { actual: candidate(\"2\/10\", \"50\/10\"), expected: true },\n     { actual: candidate(\"7\/2\", \"4\/2\"), expected: true },\n     { actual: candidate(\"11\/6\", \"6\/1\"), expected: true },\n     { actual: candidate(\"2\/3\", \"5\/2\"), expected: false },\n     { actual: candidate(\"5\/2\", \"3\/5\"), expected: false },\n     { actual: candidate(\"2\/4\", \"8\/4\"), expected: true },\n     { actual: candidate(\"2\/4\", \"4\/2\"), expected: true },\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/5\", \"1\/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_145","nl":"mos_Latn","pl":"go_test.go","prompt":"package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/B na n tũnuga ne b sẽn gʋls b rãmb to-to wã n sõd-ba.\/\/Sebr ning sẽn be seb-kãngã pʋgẽ wã yaa:\/\/b sẽn sõd-b ne sõor sẽn yikd n paasdẽ wã. \/\/Gʋls-y tʋʋm-noor sẽn na n welg sõor-kẽengã sẽn be wã \/\/ >>> order_by_points([]int{1, 11, -1, -11, -12})\n\/\/ []int{-1, -11, 1, -12, 11}\n\/\/ >>> order_by_points([]int{})\n\/\/ []int{}\nfunc order_by_points(nums []int) []int {\n","canonical_solution":"package order_by_points_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc digitSum(n int) int {\n\tn = abs(n) \/\/ Consider the absolute value for digit sum\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc order_by_points(nums []int) []int {\n\ttype numWithIndex struct {\n\t\tnum   int\n\t\tindex int\n\t}\n\n\tnumsWithIndex := make([]numWithIndex, len(nums))\n\tfor i, num := range nums {\n\t\tnumsWithIndex[i] = numWithIndex{num, i}\n\t}\n\n\tsort.Slice(numsWithIndex, func(i, j int) bool {\n\t\tsumI := digitSum(numsWithIndex[i].num)\n\t\tsumJ := digitSum(numsWithIndex[j].num)\n\t\tif sumI == sumJ {\n\t\t\treturn numsWithIndex[i].index < numsWithIndex[j].index\n\t\t}\n\t\treturn sumI < sumJ\n\t})\n\n\tsortedNums := make([]int, len(nums))\n\tfor i, nwi := range numsWithIndex {\n\t\tsortedNums[i] = nwi.num\n\t}\n\n\treturn sortedNums\n}\n\nfunc TestOrderByPoints(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := order_by_points(tc.input)\n\t\tif !equal(result, tc.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_146","nl":"mos_Latn","pl":"go_test.go","prompt":"package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/Sõor pipi la yaoolem sifr yaa toor-toore (1, 3, 5, 7, 9).\/\/Elemẽ rãmb sõor sẽn yɩɩd 10 la b yiibã fãa \/\/Gʋls-y tʋʋm-noor sẽn na n dɩk sõor sõor n kõ tɩ lebg n wa \/\/ >>> specialFilter([]int{15, -73, 14, -15})\n\/\/ 1\n\/\/ >>> specialFilter([]int{33, -2, -3, 45, 21, 109})\n\/\/ 2\nfunc specialFilter(nums []int) int {\n","canonical_solution":"package specialFilter_test\n\nimport (\n\t\"testing\"\n)\n\nfunc specialFilter(nums []int) int {\n\tcount := 0\n\tfor _, num := range nums {\n\t\t\/\/ Consider the absolute value of the number\n\t\tabsNum := abs(num)\n\t\tif absNum > 10 {\n\t\t\tstrNum := fmt.Sprintf(\"%d\", absNum)\n\t\t\tfirstDigit := strNum[0]\n\t\t\tlastDigit := strNum[len(strNum)-1]\n\t\t\tif isOdd(firstDigit) && isOdd(lastDigit) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc isOdd(digit byte) bool {\n\treturn digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'\n}\n\nfunc TestSpecialFilter(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{15, -73, 14, -15}, 1},\n\t\t{[]int{33, -2, -3, 45, 21, 109}, 2},\n\t\t{[]int{8, 4, 12, 55, 99, 111}, 1},\n\t\t{[]int{-11, -22, -33, -44, -55}, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := specialFilter(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"specialFilter(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestSpecialfilter(t *testing.T) {\n  candidate := specialFilter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },\n     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },\n     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },\n     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },\n     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{}), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_147","nl":"mos_Latn","pl":"go_test.go","prompt":"package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/la a[i] + a[j] + a[k] yaa 3 naoor wʋsgo. \/\/lebg n wa ne a tãag a (a[i], a[j], a[k]) zĩig ning i < j < k, \/\/Sẽn na yɩl n bãng i fãa (1 ≤ i ≤ n), a[i] = i * i - i + 1 yõodo. \/\/B kõ-y-la sõor sẽn yaa sõma n. Y segd n maana sõor sẽn yaa sõma n zãr n. \/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n","canonical_solution":"package get_max_triples_test\n\nimport (\n    \"testing\"\n)\n\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    \n    count := 0\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\nfunc TestGetMaxTriples(t *testing.T) {\n    if get_max_triples(5) != 1 {\n        t.Errorf(\"Expected 1 but got %d\", get_max_triples(5))\n    }\n}","tests":"func TestGet_Max_Triples(t *testing.T) {\n  candidate := get_max_triples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 1 },\n     { actual: candidate(6), expected: 4 },\n     { actual: candidate(10), expected: 36 },\n     { actual: candidate(100), expected: 53361 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_148","nl":"mos_Latn","pl":"go_test.go","prompt":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/pa ãds yʋy sẽn zems ye.\/\/Fõn-kãng segd n lebg n waa ne list sẽn ka be ye, sã n yaa planet1 bɩ planet2 \/\/A sẽn pẽ wĩntoogã to-to wã yĩnga.\/\/B sẽn yã tɩ b sẽn da be ãdsã 1 la ãdsã 2 sʋkã, b sõdga ne \/\/Tʋʋmdã segd n lebg n waa ne list sẽn tar ãdsã fãa sẽn tar b gilg-taab sẽn yaa \/\/Gʋls-y tʋʋm-noor sẽn na n dɩk ãds a yiib yʋy n lebg tɩ ãdsã1 la ãdsã2 sõor-koɛɛga.\/\/A Urã, a Neptun.\/\/Yaa Merkur, sẽn pʋgd-a wã yaa Vẽenus, tɩ rẽ poor yaa tẽngã, a Mars, a Zoviit, a Satɛrn, \/\/D sẽn be wĩndgã ne wĩndgã sʋka , yaa ãds a nii n be.\/\/ >>> bf(\"Jupiter\", \"Neptune\")\n\/\/ []interface{}{\"Saturn\", \"Uranus\"}\n\/\/ >>> bf(\"Earth\", \"Mercury\")\n\/\/ \"Venus\"\n\/\/ >>> bf(\"Mercury\", \"Uranus\")\n\/\/ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n","canonical_solution":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Define the solar system slice with planets ordered by their proximity to the Sun\nvar solarSystem = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n    index1 := -1\n    index2 := -1\n\n    \/\/ Find the indices of the given planet names in the solarSystem slice\n    for i, planet := range solarSystem {\n        if planet == planet1 {\n            index1 = i\n        }\n        if planet == planet2 {\n            index2 = i\n        }\n    }\n\n    \/\/ If either planet name is incorrect, return an empty list\n    if index1 == -1 || index2 == -1 {\n        return []interface{}{}\n    }\n\n    \/\/ Ensure index1 is less than index2 to find planets between them\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\n    \/\/ Collect and return planets that are located between the two indices\n    var planetsBetween []interface{}\n    for i := index1 + 1; i < index2; i++ {\n        planetsBetween = append(planetsBetween, solarSystem[i])\n    }\n    \n    return planetsBetween\n}\n\nfunc TestBf(t *testing.T) {\n    fmt.Println(bf(\"Jupiter\", \"Neptune\")) \/\/ Should print: []interface{}{\"Saturn\", \"Uranus\"}\n    fmt.Println(bf(\"Earth\", \"Mercury\"))  \/\/ Should print: []interface{}{\"Venus\"}\n    fmt.Println(bf(\"Mercury\", \"Uranus\")) \/\/ Should print: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n}","tests":"func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_149","nl":"mos_Latn","pl":"go_test.go","prompt":"package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/Y tõe n tagsame tɩ gom-biis fãa woglem na n yɩɩ a yembre.\/\/Tʋʋmdã segd n lebg n waa ne sõor sẽn be sõor pʋga.\/\/Gom-biis a yiib sã n tar woglem sẽn zem taaba, bɩ y sõd-bã ne lɛbɛɛre. \/\/B segd n lebs-a-la sõor ning b sẽn sõdgã ne noor kãng n welge.\/\/Sõssã sõor segd n yɩɩ sẽn zẽkd n dabda, la y segd n \/\/la a tõe n tara sẽn yaa a yiib-n-soaba.\/\/Sõngrã yaa sõngr sẽn tar sõor-n-bay wakat fãa, la a pa tol n yaa sõor-n-bay ye.\/\/la a lebg n wa ne sõor sẽn pʋɩ-sʋk sẽn na n yɩlẽ, \/\/a yiisda sõn-vãoog nins sẽn tar woglem sẽn pa yembr ne yẽ wã, \/\/Gʋls-y tʋʋm-noor sẽn sak n deeg sõor sẽn yaa sõor-n-bay wa a paramɛtre, \/\/ >>> list_sort([]string{\"aa\", \"a\", \"aaa\"})\n\/\/ []string{\"aa\"}\n\/\/ >>> list_sort([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n\/\/ []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n","canonical_solution":"package sorted_list_sum_test\n\nimport (\n    \"sort\"\n)\n\nfunc sorted_list_sum(lst []string) []string {\n    \/\/ Filter out strings with odd lengths\n    filtered := []string{}\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            filtered = append(filtered, str)\n        }\n    }\n\n    \/\/ Sort the filtered list by length, then alphabetically\n    sort.Slice(filtered, func(i, j int) bool {\n        if len(filtered[i]) == len(filtered[j]) {\n            return filtered[i] < filtered[j]\n        }\n        return len(filtered[i]) < len(filtered[j])\n    })\n\n    return filtered\n}","tests":"func TestSorted_List_Sum(t *testing.T) {\n  candidate := sorted_list_sum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"aa\", \"a\", \"aaa\"}), expected: []string{\"aa\"} },\n     { actual: candidate([]string{\"school\", \"AI\", \"asdf\", \"b\"}), expected: []string{\"AI\", \"asdf\", \"school\"} },\n     { actual: candidate([]string{\"d\", \"b\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"d\", \"dcba\", \"abcd\", \"a\"}), expected: []string{\"abcd\", \"dcba\"} },\n     { actual: candidate([]string{\"AI\", \"ai\", \"au\"}), expected: []string{\"AI\", \"ai\", \"au\"} },\n     { actual: candidate([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}), expected: []string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_150","nl":"mos_Latn","pl":"go_test.go","prompt":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/a yaa pipi sõor la a segd n lebg n wa ne y sẽn yaa to-to wã.\/\/Yaa porgram sẽn yaa nana sẽn segd n lebg n wa ne x makrã sã n yaa \/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunc x_or_y(n int, x int, y int) int {\n","canonical_solution":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    }\n    return y\n}\n\nfunc TestXOrY(t *testing.T) {\n    cases := []struct{\n        n, x, y, want int\n    }{\n        {7, 34, 12, 34},\n        {15, 8, 5, 5},\n        {2, 10, 20, 10},\n        {1, 5, 15, 15},\n    }\n\n    for _, c := range cases {\n        got := x_or_y(c.n, c.x, c.y)\n        if got != c.want {\n            t.Errorf(\"x_or_y(%d, %d, %d) == %d, want %d\", c.n, c.x, c.y, got, c.want)\n        }\n    }\n}","tests":"func TestX_Or_Y(t *testing.T) {\n  candidate := x_or_y\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7, 34, 12), expected: 34 },\n     { actual: candidate(15, 8, 5), expected: 5 },\n     { actual: candidate(3, 33, 5212), expected: 33 },\n     { actual: candidate(1259, 3, 52), expected: 3 },\n     { actual: candidate(7919, -1, 12), expected: -1 },\n     { actual: candidate(3609, 1245, 583), expected: 583 },\n     { actual: candidate(91, 56, 129), expected: 129 },\n     { actual: candidate(6, 34, 1234), expected: 1234 },\n     { actual: candidate(1, 2, 0), expected: 0 },\n     { actual: candidate(2, 2, 0), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_151","nl":"mos_Latn","pl":"go_test.go","prompt":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B sã n pa sõor sẽn zems bɩ sã n pa sõor sẽn yaa sõma, bɩ y bas n pa ges-b ye.\/\/D sã n kõ sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor\/\/ >>> double_the_difference([]int{1, 3, 2, 0})\n\/\/ 10\n\/\/ >>> double_the_difference([]int{-1, -2, 0})\n\/\/ 0\n\/\/ >>> double_the_difference([]int{9, -2})\n\/\/ 81\n\/\/ >>> double_the_difference([]int{0})\n\/\/ 0\n\/\/ If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n","canonical_solution":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc double_the_difference(lst []float64) int {\n    sum := 0\n    for _, num := range lst {\n        if num >= 0 && math.Mod(num, 1) == 0 {\n            intNum := int(num)\n            if intNum%2 != 0 {\n                sum += intNum * intNum\n            }\n        }\n    }\n    return sum\n}\n\nfunc TestDoubleTheDifference(t *testing.T) {\n    cases := []struct {\n        input []float64\n        expected int\n    }{\n        {input: []float64{1, 3, 2, 0}, expected: 10},\n        {input: []float64{-1, -2, 0}, expected: 0},\n        {input: []float64{9, -2}, expected: 81},\n        {input: []float64{0}, expected: 0},\n        {input: []float64{}, expected: 0},\n    }\n\n    for _, c := range cases {\n        result := double_the_difference(c.input)\n        if result != c.expected {\n            t.Errorf(\"double_the_difference(%v) == %d, want %d\", c.input, result, c.expected)\n        } else {\n            fmt.Printf(\"Test passed for input %v. Result: %d\\n\", c.input, result)\n        }\n    }\n}","tests":"func TestDouble_The_Difference(t *testing.T) {\n  candidate := double_the_difference\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{}), expected: 0 },\n     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },\n     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },\n     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },\n     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },\n     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_152","nl":"mos_Latn","pl":"go_test.go","prompt":"package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/yaa 0, la sã n pa woto, yaa sẽn pa tũ ne makrã la sẽn pa tũ ne makrã.\/\/D na n leoka sõor sẽn yaa zãngã n wilg b sẽn pa bãng bũmb ning fãa to-to wã.\/\/B kõ-y-la sõor a yiib sẽn tar makrã la b sẽn tõe n bãngã sẽn yaa zãngã, tɩ b fãa makd taab sõma.\/\/Yãmb tʋʋmd yaa y bãng ned sã n da togsa b sẽn na n wa ne bũmb ninsã tɩ zemse.\/\/Yaa sɩd tɩ d segd n ges-a lame n mak-a ne taaba.\/\/Y sẽn mi bũmb ning sẽn maan-y wã, y sẽn tagsd bũmb ning la y sẽn tagsd bũmb ning sasa wã, yaa y sẽn na n bãng-a to-to wã.\/\/M tagsdame tɩ d fãa tẽra sũ-sãang ning d sẽn da tar n gũud bũmb sẽn kaoosã sẽn wa n baas to-to wã.\/\/ >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n\/\/ []int{0, 0, 0, 0, 3, 3}\n\/\/ >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n\/\/ []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n","canonical_solution":"package compare_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := 0; i < len(game); i++ {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc TestCompare(t *testing.T) {\n    tests := []struct {\n        game  []int\n        guess []int\n        want  []int\n    }{\n        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},\n        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%v vs %v\", tt.game, tt.guess), func(t *testing.T) {\n            got := compare(tt.game, tt.guess)\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"compare(%v, %v) = %v; want %v\", tt.game, tt.guess, got, tt.want)\n                }\n            }\n        })\n    }\n}","tests":"func TestCompare(t *testing.T) {\n  candidate := compare\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },\n     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },\n     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },\n     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_153","nl":"mos_Latn","pl":"go_test.go","prompt":"package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/(a pãng yaa -1).\/\/lebg n wa ne \"Slices.SErviNGSliCes\" bala \"SErviNGSliCes\" yaa paasg sẽn yaa kãsenga \/\/y segd n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n n ẽe n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n\/\/Wala makre, b sã n kõ-y \"Slices\" sẽn yaa sullã la \/\/Y sã n dat n bãng y sẽn tõe n maan to-to, bɩ y yãk pipi soabã.\/\/Y sã n wa tar y sẽkã n paasdẽ, y segd n ẽnega y sẽkã n paasdẽ.\/\/format: ClassName.StrongestExtensionName. \/\/Y segd n baoo sẽn yaa pãng n yɩɩdã n lebg n wa ne sõor sẽn be \/\/Sẽn paasd-a pãnga, a yʋʋr pʋgẽ, yaa CAP - SM sẽn yaa wilgrã n wilgd pãng ning a sẽn tarã.\/\/gʋls-biis sẽn be paasgã yʋʋr pʋgẽ, la bɩ SM yɩ lɛt-bõoneg sõor \/\/Sẽn paasd-a pãng yaa woto: Bɩ CAP yɩ sõor sẽn be gãneg-kãsengã pʋgẽ \/\/B na n dɩka yel-gɛtbã n ning karen-biis a taab karen-bi-kãng pʋgẽ.\/\/Y na n paama sull yʋʋr (sull sẽn yaa sõor sẽn yaa toore) la sõor sẽn yaa toore.\/\/ >>> Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"})\n\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name string, extensions []string) string {\n","canonical_solution":"func Strongest_Extension(class_name string, extensions []string) string {\n    strongestExtension := \"\"\n    maxStrength := -1 << 31\n\n    for _, extension := range extensions {\n        capCount, smCount := 0, 0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                capCount++\n            } else if char >= 'a' && char <= 'z' {\n                smCount++\n            }\n        }\n        strength := capCount - smCount\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    return fmt.Sprintf(\"%s.%s\", class_name, strongestExtension)\n}","tests":"func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected: \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected: \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\" },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n     { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_154","nl":"mos_Latn","pl":"go_test.go","prompt":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/B kõ-y-la gom-biis a yiibu. Y segd n lebg n togsa sɩd sã n yaa gom-biig a yiib-n-soabã bɩ a rotations a to wã yaa substring pipi gom-biigã pʋgẽ.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunc cycpattern_check(a string, b string) bool {\n","canonical_solution":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc cycpattern_check(a string, b string) bool {\n    n := len(b)\n    \n    \/\/ Generate all rotations of b\n    for i := 0; i < n; i++ {\n        rotated := b[i:] + b[:i]\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    \n    return false\n}","tests":"func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual: candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_155","nl":"mos_Latn","pl":"go_test.go","prompt":"package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/D sã n kõ sõor sẽn yaa zãng, d na n lebg n wa ne sõor sẽn tar sõor sẽn yaa zuloees la zuloees sõor n zems taaba. \/\/ >>> even_odd_count(-12)\n\/\/ []interface{}{1, 1}\n\/\/ >>> even_odd_count(123)\n\/\/ []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n","canonical_solution":"func even_odd_count(num int) []interface{} {\n    \/\/ Handle negative numbers by taking the absolute value\n    if num < 0 {\n        num = -num\n    }\n    \n    evenCount, oddCount := 0, 0\n\n    \/\/ Iterate over each digit in the number\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n        num \/= 10\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\nfunc TestEvenOddCount(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected []interface{}\n    }{\n        {-12, []interface{}{1, 1}},\n        {123, []interface{}{1, 2}},\n        {2468, []interface{}{4, 0}},\n        {1357, []interface{}{0, 4}},\n        {0, []interface{}{1, 0}},\n    }\n\n    for _, testCase := range testCases {\n        result := even_odd_count(testCase.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", testCase.expected) {\n            t.Errorf(\"even_odd_count(%d) = %v; expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}","tests":"func TestEven_Odd_Count(t *testing.T) {\n  candidate := even_odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7), expected: []interface{}{0, 1} },\n     { actual: candidate(-78), expected: []interface{}{1, 1} },\n     { actual: candidate(3452), expected: []interface{}{2, 2} },\n     { actual: candidate(346211), expected: []interface{}{3, 3} },\n     { actual: candidate(-345821), expected: []interface{}{3, 3} },\n     { actual: candidate(-2), expected: []interface{}{1, 0} },\n     { actual: candidate(-45347), expected: []interface{}{2, 3} },\n     { actual: candidate(0), expected: []interface{}{1, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_156","nl":"mos_Latn","pl":"go_test.go","prompt":"package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/B sẽn tõe n maan to-to n paam n kẽe bãaga\/\/la y lebs-a ne gʋls-biis sẽn yaa bilfr. \/\/D sã n kõ sõor sẽn yaa sõma, d na n paama a sẽn zem ne Rom sõor sẽn yaa wa sõor sẽn yaa toore, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n","canonical_solution":"package int_to_mini_roman_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc int_to_mini_roman(number int) string {\n\tvals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\tsymbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n\tvar roman strings.Builder\n\n\tfor i := 0; i < len(vals); i++ {\n\t\tfor number >= vals[i] {\n\t\t\tnumber -= vals[i]\n\t\t\troman.WriteString(symbols[i])\n\t\t}\n\t}\n\treturn roman.String()\n}\n\nfunc TestIntToMiniRoman(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected string\n\t}{\n\t\t{19, \"xix\"},\n\t\t{152, \"clii\"},\n\t\t{426, \"cdxxvi\"},\n\t\t{1000, \"m\"},\n\t\t{1, \"i\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d\", tt.input), func(t *testing.T) {\n\t\t\tresult := int_to_mini_roman(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Fatalf(\"expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_157","nl":"mos_Latn","pl":"go_test.go","prompt":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Yaa digri 90.\/\/A rectangle triangle yaa triangle a ye sẽn tar rectangle bɩ \/\/A na n yɩɩ wa a sẽn da yeelã.\/\/D sã n ges a tãabã sẽn yaa to-to wã, lebg n wa ne true sã n yaa tɩ tãabã yaa \/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunc right_angle_triangle(a int, b int, c int) bool {\n","canonical_solution":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n    \/\/ Squaring the sides\n    a2, b2, c2 := a*a, b*b, c*c\n    \/\/ Check the Pythagorean theorem for the combination of sides\n    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2\n}","tests":"func TestRight_Angle_Triangle(t *testing.T) {\n  candidate := right_angle_triangle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: true },\n     { actual: candidate(1, 2, 3), expected: false },\n     { actual: candidate(10, 6, 8), expected: true },\n     { actual: candidate(2, 2, 2), expected: false },\n     { actual: candidate(7, 24, 25), expected: true },\n     { actual: candidate(10, 5, 7), expected: false },\n     { actual: candidate(5, 12, 13), expected: true },\n     { actual: candidate(15, 8, 17), expected: true },\n     { actual: candidate(48, 55, 73), expected: true },\n     { actual: candidate(1, 1, 1), expected: false },\n     { actual: candidate(2, 2, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_158","nl":"mos_Latn","pl":"go_test.go","prompt":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/n lebg n wa ne a soab sẽn yɩ pipi n zĩnd gom-biis nins sẽn be seb-vãoogã pʋgẽ wã. \/\/Sã n yaa sõor sẽn yaa toor n yɩɩd la b tõe n tall n gʋls sõor wʋsgo, \/\/Sõngrã tara gom-biis toor-toor. lebg n wa ne gom-biis sõor sẽn yaa wʋsgo \/\/Gʋls-y tʋʋm-noor sẽn tõe n sak n deeg sõor sẽn yaa sõor-n-bãngr n kõ.\/\/ >>> find_max([]string{\"name\", \"of\", \"string\"})\n\/\/ \"string\"\n\/\/ >>> find_max([]string{\"name\", \"enam\", \"game\"})\n\/\/ \"enam\"\n\/\/ >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\/\/ \"aaaaaaa\"\nfunc find_max(words []string) string {\n","canonical_solution":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc find_max(words []string) string {\n    maxWord := \"\"\n    maxUnique := 0\n    \n    for _, word := range words {\n        uniqueChars := countUniqueChars(word)\n        if uniqueChars > maxUnique {\n            maxUnique = uniqueChars\n            maxWord = word\n        } else if uniqueChars == maxUnique {\n            if maxWord == \"\" || word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    \n    return maxWord\n}\n\nfunc countUniqueChars(word string) int {\n    charSet := make(map[rune]struct{})\n    for _, c := range word {\n        charSet[c] = struct{}{}\n    }\n    return len(charSet)\n}\n\n\/\/ Test case runs to verify the solution\nfunc TestFindMax(t *testing.T) {\n    testCases := []struct {\n        input []string\n        expected string\n    }{\n        {[]string{\"name\", \"of\", \"string\"}, \"string\"},\n        {[]string{\"name\", \"enam\", \"game\"}, \"enam\"},\n        {[]string{\"aaaaaaa\", \"bb\", \"cc\"}, \"aaaaaaa\"},\n    }\n\n    for _, tc := range testCases {\n        result := find_max(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"For input %v, expected %s, but got %s\", tc.input, tc.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", tc.input)\n        }\n    }\n}","tests":"func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_159","nl":"mos_Latn","pl":"go_test.go","prompt":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre: \/\/Sã n pa be tɩ karotã kell n sekã, y na n wãba karotã fãa sẽn kellã, la y na n ket n tara kom.\/\/[Yãk-y n tool-y neda]\/\/y segd n lebg n wa ne [ sõor ning y sẽn dɩt tɩ b sa wã poore, \/\/La masã, y segd n dɩta karot n paase, n na n dɩ n sa.\/\/Yãmb yaa bõang kom sẽn tar wʋsgo, la y zoe n dɩka zũnzũy sõor sẽn zems wʋsgo.\/\/ >>> eat(5, 6, 10)\n\/\/ []int{11, 4}\n\/\/ >>> eat(4, 8, 9)\n\/\/ []int{12, 1}\n\/\/ >>> eat(1, 10, 10)\n\/\/ []int{11, 0}\n\/\/ >>> eat(2, 11, 5)\n\/\/ []int{7, 0}\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n","canonical_solution":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ eat calculates the total number of eaten carrots after meals and the number of carrots left.\nfunc eat(number int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{number + need, remaining - need}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n    tests := []struct {\n        number, need, remaining int\n        expected                []int\n    }{\n        {5, 6, 10, []int{11, 4}},\n        {4, 8, 9, []int{12, 1}},\n        {1, 10, 10, []int{11, 0}},\n        {2, 11, 5, []int{7, 0}},\n    }\n\n    for _, test := range tests {\n        result := eat(test.number, test.need, test.remaining)\n        if result[0] != test.expected[0] || result[1] != test.expected[1] {\n            t.Errorf(\"eat(%d, %d, %d) = %v; expected %v\", test.number, test.need, test.remaining, result, test.expected)\n        }\n    }\n}","tests":"func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_160","nl":"mos_Latn","pl":"go_test.go","prompt":"package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Tʋʋmd-mitbã sõor tara tʋʋm-mit a yembr n tãag tʋʋma sõor tara tʋʋma a yiib n tãag tʋʋma.\/\/Operand yaa sõor sẽn pa-wʋmd sẽn yaa zãng sõor sõor sõore.\/\/Operatɛɛrã sõor yaa wa operandã sõor sẽn kong a ye.\/\/Sebr a ye: \/\/=> B sẽn wa n yãkd a soabã yaa 9 \/\/Rẽ kɩtame tɩ b lebg 2 + 3 * 4 - 5 \/\/Sõdg-y sõsgã sẽn na n yɩ to-to.\/\/so-toakã['+', '*', '-'] \/\/Makre: \/\/B sẽn tõe n maan to-to n wilg tɩ b yaa to-to wã (**) \/\/Roog pʋɩ-sʋka ( \/\/ ) \/\/Yaa f sẽn na n dɩk n paasã la f na n dɩk n paasã.\/\/B sẽn yãkd bũmb ningã ( - ) \/\/Sẽn paasd (+) \/\/Alzebrã tʋʋm-noodã yaa: \/\/D sã n wa rat n bãng bũmb ning sẽn kɩt tɩ d gom woto wã, d segd n bao n bãnga d sẽn na n gom to-to.\/\/Sebr a yiib-n-soabã yaa sõor sẽn yaa zãng sõor sõore.\/\/B kõ-d-la sõor a yiib sẽn wilgd tɩ b tõe n maana bũmb a to.func do_algebra(operator []string, operand []int) int {\n","canonical_solution":"package do_algebra_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc do_algebra(operator []string, operand []int) int {\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n\n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"\/\/\":\n            result \/= operand[i+1]\n        case \"**\":\n            result = intPow(result, operand[i+1])\n        }\n    }\n\n    return result\n}\n\nfunc intPow(base, exp int) int {\n    result := 1\n    for exp != 0 {\n        if exp%2 == 1 {\n            result *= base\n        }\n        exp \/= 2\n        base *= base\n    }\n    return result\n}\n\nfunc TestDoAlgebra(t *testing.T) {\n    operators := []string{\"+\", \"*\", \"-\"}\n    operands := []int{2, 3, 4, 5}\n    expectedResult := 9\n    result := do_algebra(operators, operands)\n    if result != expectedResult {\n        t.Errorf(\"expected %d but got %d\", expectedResult, result)\n    }\n\n    fmt.Println(\"All tests passed.\")\n}","tests":"func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"\/\/\", \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_161","nl":"mos_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Makre \/\/Fõn-kãng segd n lebg n waa ne sõor sẽn wa ne wã.\/\/Sã n pa be lɛta a ye, bɩ y wẽnemd-a.\/\/Sã n pa rẽ bɩ y bas-a a sẽn yaa to-to wã.\/\/sã n yaa lɛtgre, bɩ f lebg n tek a sẽn be wã n sɩng ne a sẽn be tẽngrã n kẽng a sẽn be a zugẽ wã, bɩ a sẽn be a poorẽ wã n baas ne a sẽn be a poorẽ wã, \/\/B kõ-y-la sõor sẽn yaa sõor wʋsgo.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunc solve(s string) string {\n","canonical_solution":"package solve_test\n\nimport (\n    \"unicode\"\n)\n\nfunc solve(s string) string {\n    hasLetter := false\n    result := []rune(s)\n\n    for i, char := range result {\n        if unicode.IsLetter(char) {\n            hasLetter = true\n            if unicode.IsUpper(char) {\n                result[i] = unicode.ToLower(char)\n            } else {\n                result[i] = unicode.ToUpper(char)\n            }\n        }\n    }\n\n    if !hasLetter {\n        \/\/ reverse the string\n        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {\n            result[i], result[j] = result[j], result[i]\n        }\n    }\n\n    return string(result)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_163","nl":"mos_Latn","pl":"go_test.go","prompt":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Wala makre: \/\/la b, sẽn na yɩl tɩ b sõorã paasdẽ. \/\/D sã n kõ sõor sẽn yaa sõma a la b, d na n leoka sõor sẽn yaa a la b sʋka.\/\/ >>> generate_integers(2, 8)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(8, 2)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(10, 14)\n\/\/ []int{}\nfunc generate_integers(a int, b int) []int {\n","canonical_solution":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc generate_integers(a int, b int) []int {\n    start, end := a, b\n    if a > b {\n        start, end = b, a\n    }\n    \n    result := []int{}\n    for i := start; i <= end; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestGenerateIntegers(t *testing.T) {\n    tests := []struct {\n        a, b int\n        want []int\n    }{\n        {2, 8, []int{2, 4, 6, 8}},\n        {8, 2, []int{2, 4, 6, 8}},\n        {10, 14, []int{}},\n    }\n    \n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"generate_integers(%d, %d)\", tt.a, tt.b), func(t *testing.T) {\n            got := generate_integers(tt.a, tt.b)\n            if len(got) != len(tt.want) {\n                t.Errorf(\"expected %v, got %v\", tt.want, got)\n                return\n            }\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"expected %v, got %v\", tt.want, got)\n                    return\n                }\n            }\n        })\n    }\n}","tests":"func TestGenerate_Integers(t *testing.T) {\n  candidate := generate_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(17, 89), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]