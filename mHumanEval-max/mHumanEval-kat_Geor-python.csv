task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,kat_Geor,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""შეამოწმეთ, არის თუ არა მოცემული რიცხვების სიაში რომელიმე ორი რიცხვი ერთმანეთთან უფრო ახლოს, ვიდრე მოცემული ზღვარია. მაგალითი: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) ცრუ >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) მართალი """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,kat_Geor,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""ამ ფუნქციის შესავალი არის სტრიქონი, რომელიც შეიცავს მრავალ ჯგუფს ჩანართული კვეთაში. თქვენი მიზანია, რომ დაყოს ეს ჯგუფი ცალკე სტრიქონებად და დააბრუნოს მათი სია. ცალკე ჯგუფები დაბალანსებულია (თითოეული ღია კვეთა სწორად არის დახურული) და არ არის ჩანართული ერთმანეთის შიგნით. იგნორირება ნებისმიერი სივრცეები შეყვანის სტრიქონში. მაგალითი: >>> ცალკე_პარენ_ჯგუფები ' ((( ) (() (()))))) ' [' (()) ', ' ((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,kat_Geor,python,"

def truncate_number(number: float) -> float:
    """"""დადებითი ცვალებადი წერტილის რიცხვის მიხედვით, იგი შეიძლება დაიშალოს მთელ რიცხვებად (დიდი მთლიანი რიცხვი მოცემულ რიცხვზე უფრო პატარაა) და ათეულებად (დანარჩენი ნაწილი ყოველთვის უფრო პატარაა, ვიდრე 1). დააბრუნეთ რიცხვის ათეულთა ნაწილი. მაგალითი: >>> truncate_number ((3.5) 0.5 """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,kat_Geor,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""თქვენ გაქვთ ბანკის ანგარიშზე დეპოზიტისა და თანხის გამოტანის ოპერაციების სია, რომელიც იწყება ნულოვანი ბალანსით. თქვენი ამოცანაა აღმოაჩინოთ, თუ ანგარიშის ბალანსი ნებისმიერ მომენტში ნულზე დაბლა ვარდება და ამ დროს ფუნქცია უნდა დააბრუნოს True. წინააღმდეგ შემთხვევაში ის უნდა დააბრუნოს False. მაგალითი: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,kat_Geor,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""მონაცემთა სიის მოცემული ნომრებისათვის, გამოითვალეთ საშუალო აბსოლუტური გადახრა ამ მონაცემთა ნაკრების საშუალო მნიშვნელობის გარშემო. საშუალო აბსოლუტური გადახრა არის საშუალო აბსოლუტური განსხვავება თითოეულ ელემენტსა და ცენტრალურ წერტილს შორის (ამ შემთხვევაში საშუალო): MAD = საშუალო ⋅ x - x_mean ⋅ მაგალითი: >>> საშუალო_აბსოლუტური_გადახრა ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,kat_Geor,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""შეიყვანეთ ციფრი ""დელიმეტრი"" შეყვანის სიის ყოველ ორ თანმიმდევრულ ელემენტს შორის `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,kat_Geor,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""ამ ფუნქციის შესავალია სტრიქონი, რომელიც წარმოდგენილია მრავალჯერადი ჯგუფებით, რომლებიც განლაგებულია კვანძებში, რომლებიც განცალკევებულია სივრცეებით. თითოეული ჯგუფისთვის, გამოტანა კვანძების ყველაზე ღრმა დონე. მაგალითად (() (()) აქვს კვანძების მაქსიმუმ ორი დონე, ხოლო ((())) აქვს სამი. >>> parse_nested_parens (('((()) ((())) () (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,kat_Geor,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""ფილტრაცია სტრიქონების შესვლის სიის მხოლოდ იმ სტრიქონებისათვის, რომლებიც შეიცავს მოცემულ ქვესტრიგს >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,kat_Geor,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""მთელი რიცხვების მოცემული სიისთვის დააბრუნეთ ტუპლი, რომელიც შედგება სიაში არსებული ყველა მთელი რიცხვის ჯამისა და ნაყოფისგან. ცარიელი ჯამი უნდა იყოს 0-ის ტოლი და ცარიელი ნაყოფი უნდა იყოს 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,kat_Geor,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""მთელი რიცხვების მოცემული სიიდან წარმოიქმნება სიის როლირების მაქსიმალური ელემენტი, რომელიც ნაპოვნია თანმიმდევრობაში მოცემულ მომენტამდე. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,kat_Geor,python,"

def is_palindrome(string: str) -> bool:
    """"""იპოვეთ ყველაზე მოკლე პალინდრომი, რომელიც იწყება მოცემული სტრიქონით. ალგორითმის იდეა მარტივია: - იპოვეთ მიწოდებული სტრიქონის ყველაზე გრძელი პოსტფიქსი, რომელიც არის პალინდრომი. - მიუერთეთ სტრიქონის ბოლოს სტრიქონის პრეფიქსის საპირისპირო, რომელიც მოდის პალინდრომული სუფიქსის წინ. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('catac') ' >>> make_palindrome ((('catac') ' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""შეამოწმეთ, არის თუ არა მოცემული სტრიქონი პალინდრომი.""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,kat_Geor,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""შეყვანა არის ორი სტრიქონი a და b, რომლებიც შედგება მხოლოდ 1 და 0-ისგან. შეასრულეთ ბინარული XOR ამ შეყვანისას და დააბრუნეთ შედეგი ასევე როგორც სტრიქონი. >>> string_xor (('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,kat_Geor,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""სტრიქონების სიიდან, დააბრუნეთ ყველაზე გრძელი. დააბრუნეთ პირველი ერთი ერთი სიგრძის მრავალჯერადი სტრიქონების შემთხვევაში. დააბრუნეთ None იმ შემთხვევაში, თუ შეყვანილი სია ცარიელია. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,kat_Geor,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""დააბრუნეთ ორი მთელი რიცხვის a და b უდიდესი საერთო გამყოფი >>> უდიდესი_საერთო_გამყოფი ((3, 5) 1 >>> უდიდესი_საერთო_გამყოფი ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,kat_Geor,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""დაბრუნების სია ყველა პრეფიქსის მოკლედან ყველაზე გრძელამდე შეყვანის სტრიქონის >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,kat_Geor,python,"

def string_sequence(n: int) -> str:
    """"""დაბრუნება სტრიქონს, რომელიც შეიცავს სივრცით განსაზღვრულ რიცხვებს 0-დან n-მდე. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,kat_Geor,python,"

def count_distinct_characters(string: str) -> int:
    """"""მოცემული სტრიქონი, გაარკვიეთ რამდენი განსხვავებული სიმბოლო (არ აქვს მნიშვნელობა კეისის) შედგება >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,kat_Geor,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""ამ ფუნქციის შესვლა არის სიმები, რომლებიც წარმოადგენენ მუსიკალურ ნოტებს სპეციალურ ASCII ფორმატში. თქვენი ამოცანაა, რომ გაანალიზოთ მთელი სიმების სია, რომლებიც შეესაბამება ბევრ ბიტს. აქ არის ლეგენდა: 'o' ნოტა, ბოლო ოთხი ბითები 'o' - ნახევარი ნოტა, ბოლო ორი ბითები 'o' - ოთხი ნოტა, ბოლო ერთი ბითი >>> parse_music. 'o' o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,kat_Geor,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""იპოვეთ რამდენჯერ შეიძლება ნაპოვნი იყოს მოცემული ქვესტრინგი ორიგინალურ სტრიქონში. დათვალეთ ერთმანეთთან გადახურებული შემთხვევები. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,kat_Geor,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""შეყვანაა სივრცით განსაზღვრული ციფრების სტრიქონი 'ნულიდან' 'ცხრამდე'. ვალიდური არჩევანი არის 'ნული', 'ერთი', 'ორი', 'სამი', 'ოთხი', 'ხუთი', 'ექვსი', 'შვიდი', 'რვა' და 'ცხრა'. დააბრუნეთ სტრიქონი ციფრებით, რომლებიც დახარისხებულია ყველაზე პატარადან ყველაზე დიდამდე >>> sort_numbers (('სამი ერთი ხუთი') 'ერთი სამი ხუთი' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,kat_Geor,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""რიცხვების ჩამონათვალიდან (სიგრძე მინიმუმ ორი) აირჩიეთ და დააბრუნეთ ორი, რომლებიც ერთმანეთთან ყველაზე ახლოს არიან და დააბრუნეთ ისინი თანმიმდევრობით (უფრო მცირე რიცხვი, უფრო დიდი რიცხვი). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,kat_Geor,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""რიცხვების მოცემული სია (მინიმუმ ორი ელემენტისგან), გამოიყენეთ ლინერიული ტრანსფორმაცია ამ სიაში, ისე, რომ ყველაზე პატარა რიცხვი გახდეს 0 და ყველაზე დიდი გახდეს 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,kat_Geor,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""ფილტრის მოცემული ჩამონათვალი ნებისმიერი პითონის მნიშვნელობებისა მხოლოდ მთელი რიცხვებისათვის >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,kat_Geor,python,"

def strlen(string: str) -> int:
    """"""მოცემული სტრიქონის დაბრუნების სიგრძე >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,kat_Geor,python,"

def largest_divisor(n: int) -> int:
    """"""მოცემული რიცხვისთვის n, იპოვეთ ყველაზე დიდი რიცხვი, რომელიც n-ს ირიბად იყოფს, n-ზე პატარა >>> ყველაზე დიდი_გამყოფი ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,kat_Geor,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""დაბრუნება მოცემული მთელი რიცხვის პირველადი ფაქტორების ჩამონათვალი, ყველაზე მცირედან ყველაზე დიდამდე. თითოეული ფაქტორი უნდა იყოს ჩამოთვლილი იმ რაოდენობის მიხედვით, რამდენჯერაც ის გამოჩნდება ფაქტორების გაყოფაში. შეყვანის რიცხვი უნდა იყოს ყველა ფაქტორის ნაყოფის ტოლი >>> ფაქტორების გაყოფა ((8) [2, 2, 2] >>> ფაქტორების გაყოფა ((25) [5, 5] >>> ფაქტორების გაყოფა ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,kat_Geor,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""მთელი რიცხვების სიიდან ამოიღეთ ყველა ელემენტი, რომელიც ერთზე მეტჯერ გვხვდება. ელემენტების რიგითობა შეინახეთ იგივე, როგორც შეყვანილი. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,kat_Geor,python,"

def flip_case(string: str) -> str:
    """"""მოცემული სტრიქონისთვის, მცირე ასოების გადატანა დიდი ასოებით და დიდი ასოების გადატანა მცირე ასოებით. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,kat_Geor,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""სტრიქონების კონკეტენირების სია ერთ სტრიქონში >>> კონკეტენირება (([]) ' ' >>> კონკეტენირება ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,kat_Geor,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""ფილტრაცია სტრიქონების შესვლის სიის მხოლოდ იმ სტრიქონებისათვის, რომლებიც იწყება მოცემული პრეფიქსით. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,kat_Geor,python,"

def get_positive(l: list):
    """"""დაბრუნება მხოლოდ დადებითი რიცხვები სიაში. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,kat_Geor,python,"

def is_prime(n):
    """"""დაბრუნება true თუ მოცემული რიცხვი არის პირველადი და false სხვა შემთხვევაში. >>> არის_პირველი ((6) False >>> არის_პირველი ((101) True >>> არის_პირველი ((11) True >>> არის_პირველი ((13441) True >>> არის_პირველი ((61) True >>> არის_პირველი ((4) False >>> არის_პირველი ((1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,kat_Geor,python,"import math


def poly(xs: list, x: float):
    """"""find_zero იპოვის x-ს, რომლის კოეფიციენტიც არის მრავალმნიშვნელოვანი. find_zero იპოვის x-ს ისე, რომ poly(x) = 0. find_zero იბრუნებს მხოლოდ მხოლოდ ნულოვან წერტილს, მაშინაც კი, თუ ბევრი არსებობს. გარდა ამისა, find_zero იღებს მხოლოდ x-ს, რომელსაც აქვს კოეფიციენტების თანაბარი რაოდენობა და ყველაზე დიდი არა-ნულოვანი კოეფიციენტი, რადგან ეს გარანტირებულია გამოსავალი. >>> round ((find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0 """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""შეაფასებს პოლინომს კოეფიციენტებით xs x წერტილში. დაბრუნება xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,kat_Geor,python,"

def sort_third(l: list):
    """"""ეს ფუნქცია იღებს l-ს და იბრუნებს l'-ს, ისე რომ l'-ი იდენტურია l-ს იმ ინდექსებში, რომლებიც არ იყოფა სამით, ხოლო მისი მნიშვნელობები იმ ინდექსებში, რომლებიც იყოფა სამით, ტოლია l-ის შესაბამისი ინდექსების მნიშვნელობების, მაგრამ დახარისხებულია. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,kat_Geor,python,"

def unique(l: list):
    """"""დაბრუნება დახარისხებული უნიკალური ელემენტები სიაში >>> უნიკალური (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,kat_Geor,python,"

def max_element(l: list):
    """"""დაბრუნება მაქსიმალური ელემენტი სიაში. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,kat_Geor,python,"

def fizz_buzz(n: int):
    """"""დააბრუნეთ ციფრი 7-ის იმ რაოდენობის რაოდენობა, რომელიც აღინიშნება n-ზე ნაკლები მთელი რიცხვის დროს, რომელიც იყოფა 11-ით ან 13-ით. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,kat_Geor,python,"

def sort_even(l: list):
    """"""ეს ფუნქცია იღებს l-ს და იბრუნებს l'-ს, ისე რომ l'-ი იდენტურია l-სთან უცნაურ ინდექსებში, ხოლო მისი მნიშვნელობები თანაბარ ინდექსებში თანაბარია l-ის თანაბარი ინდექსების მნიშვნელობებთან, მაგრამ დახარისხებულია. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,kat_Geor,python,"

def encode_cyclic(s: str):
    """"""იღებს როგორც შემოსავალ სტრიქონს, რომელიც დაშიფრულია ფუნქციით encode_cyclic. აბრუნებს დეკოდირებულ სტრიქონს. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""ბრუნდება კოდირებული სტრიქონი ციკლირებული ჯგუფების მიერ სამი სიმბოლო.""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,kat_Geor,python,"

def prime_fib(n: int):
    """"""prime_fib აბრუნებს ნ-ე რიცხვს, რომელიც არის ფიბონაჩის რიცხვი და ის ასევე არის პირველი. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,kat_Geor,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero იღებს მთელი რიცხვების სიას. ის აბრუნებს True-ს, თუ სიაში არის სამი განსხვავებული ელემენტი, რომელთა ჯამი ნულამდეა, და False სხვა შემთხვევაში. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,kat_Geor,python,"

def car_race_collision(n: int):
    """"""წარმოიდგინეთ გზა, რომელიც არის სრულად სწორი უსასრულოდ გრძელი ხაზი. n მანქანა მოძრაობს მარცხნიდან მარჯვნივ; ამავე დროს, n მანქანის სხვა ნაკრები მოძრაობს მარჯვნიდან მარცხნივ. მანქანების ორი ნაკრები იწყება ძალიან შორს ერთმანეთისგან. ყველა მანქანა მოძრაობს ერთი და იგივე სიჩქარით. ორი მანქანა ერთმანეთს ეჯახება, როდესაც მარცხნიდან მარჯვნივ მოძრავი მანქანა ეჯახება მარჯვნიდან მარცხნივ მოძრავ მანქანას. თუმცა, მანქანები უსასრულოდ მყარია და ძლიერი; შედეგად, ისინი განაგრძობენ მოძრაობას თავიანთ ტრაექტორიაში, თითქოს ისინი არ შეჯახებულან. ეს ფუნქცია ამგვარი შეჯახებების რაოდენობას აჩვენებს.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,kat_Geor,python,"

def incr_list(l: list):
    """"""დაბრუნების სია ელემენტებით, რომლებიც იზრდება 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,kat_Geor,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero იღებს მთელი რიცხვების სიას. ის აბრუნებს True-ს, თუ სიაში ორი განსხვავებული ელემენტია, რომელთა ჯამი ნულამდეა, და False-ს სხვა შემთხვევაში. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,kat_Geor,python,"

def change_base(x: int, base: int):
    """"""შეცვალეთ შესული რიცხვის x რიცხვითი ბაზა ბაზაზე. კონვერტაციის შემდეგ დააბრუნეთ სტრიქონის წარმოდგენა. ბაზის რიცხვები ნაკლებია 10-ზე. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,kat_Geor,python,"

def triangle_area(a, h):
    """"""სამკუთხედის გვერდის სიგრძე და მაღალი დაბრუნების ფართობი. >>> სამკუთხედი_ფართობი ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,kat_Geor,python,"

def fib4(n: int):
    """"""Fib4-ის რიცხვთა თანმიმდევრობა არის ფიბონაჩის თანმიმდევრობის მსგავსი თანმიმდევრობა, რომელიც განისაზღვრება შემდეგნაირად: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). გთხოვთ, დაწეროთ ფუნქცია, რომ ეფექტურად გამოითვალოთ fib4-ის რიცხვთა თანმიმდევრობის n-ე ელემენტი. არ გამოიყენოთ რეკურსი. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,kat_Geor,python,"

def median(l: list):
    """"""ჩამონათვალში არსებული ელემენტების დაბრუნების მედიანა l. >>> მედიანა (([3, 1, 2, 4, 5]) 3 >>> მედიანა (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,kat_Geor,python,"

def is_palindrome(text: str):
    """"""ამოწმებს, არის თუ არა მოცემული სტრიქონი პალინდრომი >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,kat_Geor,python,"

def modp(n: int, p: int):
    """"""დაბრუნება 2^n მოდულო p (გაითვალისწინეთ რიცხვითი მნიშვნელობა). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,kat_Geor,python,"

def encode_shift(s: str):
    """"""იღებს როგორც შემოსავალ სტრიქონს, რომელიც დაშიფრულია ფუნქციით encode_shift. ბრუნავს დეკოდირებულ სტრიქონს. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""ბრუნდება კოდირებული სტრიქონი, ყველა სიმბოლოს გადატანით 5 ნიშნით ანბანში.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,kat_Geor,python,"

def remove_vowels(text):
    """"""remove_vowels არის ფუნქცია, რომელიც იღებს სტრიქონს და უბრუნებს სტრიქონს ხმოვანების გარეშე. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') ' ' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,kat_Geor,python,"

def below_threshold(l: list, t: int):
    """"""დაბრუნება True თუ ყველა რიცხვი სიაში l არის ქვემოთ threshold t. >>> ქვემოთ_threshold (([1, 2, 4, 10], 100) True >>> ქვემოთ_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,kat_Geor,python,"

def add(x: int, y: int):
    """"""დავაკრიბოთ ორი რიცხვი x და y, დავამატოთ ((2, 3) 5), დავამატოთ ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,kat_Geor,python,"

def same_chars(s0: str, s1: str):
    """"""შეამოწმეთ, აქვს თუ არა ორი სიტყვისთვის იგივე სიმბოლოები. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') True >>> same_chars (('abcd', 'dddddddddabc') True >>> same_chars (('dddddddabc', 'abcd') True >>> same_chars (('eabcd', 'dddddddddabc') False >>> same_chars (('abcd', 'dddddddabce') False >>> same_chars (('eabcdzzzz', 'dddzzzzzzdddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,kat_Geor,python,"

def fib(n: int):
    """"""დააბრუნეთ n-ე ფიბონაჩის რიცხვი. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,kat_Geor,python,"

def correct_bracketing(brackets: str):
    """"""brackets არის სტრიქონი ""<"" და "">"". დაბრუნება True თუ თითოეულ გახსნილ კრეფას აქვს შესაბამისი დახურვის კრეფა. >>> correct_bracketing ((""<"") False >>> correct_bracketing ((""<>"") True >>> correct_bracketing ((""<><>>"") True >>> correct_bracketing ((""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,kat_Geor,python,"

def monotonic(l: list):
    """"""დაბრუნება True არის სია ელემენტები მონოტონურად იზრდება ან მცირდება. >>> მონოტონური (([1, 2, 4, 20]) True >>> მონოტონური (([1, 20, 4, 10]) False >>> მონოტონური (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,kat_Geor,python,"

def common(l1: list, l2: list):
    """"""დაბრუნება ორ სიაში დახარისხებული უნიკალური საერთო ელემენტებისათვის. >>> საერთო (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> საერთო (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,kat_Geor,python,"

def largest_prime_factor(n: int):
    """"""დააბრუნეთ n-ის უდიდესი პირველადი ფაქტორი. ვარაუდობთ, რომ n > 1 და არ არის პირველადი. >>> უდიდესი_პირველი_ფაქტორი ((13195) 29 >>> უდიდესი_პირველი_ფაქტორი ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,kat_Geor,python,"

def sum_to_n(n: int):
    """"""sum_to_n არის ფუნქცია, რომელიც აყრის რიცხვებს 1-დან n-მდე. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,kat_Geor,python,"

def correct_bracketing(brackets: str):
    """"""brackets არის სტრიქონი ""("" და "")"". დაბრუნება მართალია, თუ ყველა გახსნის კრეფა აქვს შესაბამისი დახურვის კრეფა. >>> correct_bracketing (((""("") False >>> correct_bracketing ((("")) მართალია >>> correct_bracketing (((()) მართალია >>> correct_bracketing ((((()) False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,kat_Geor,python,"

def derivative(xs: list):
    """"""xs წარმოადგენს პოლინომის კოეფიციენტებს. xs[0] + xs[1] * x + xs[2] * x^2 + .... დაბრუნება ამ პოლინომის წარმოებულის იმავე ფორმით. >>> derivative (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivative[(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,kat_Geor,python,"

def fibfib(n: int):
    """"""FibFib რიცხვის თანმიმდევრობა არის თანმიმდევრობა, რომელიც მსგავსია Fibbonacci თანმიმდევრობისა, რომელიც განსაზღვრულია შემდეგნაირად: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). გთხოვთ, დაწეროთ ფუნქცია, რომ ეფექტურად გამოითვალოს fibfib რიცხვის თანმიმდევრობის n-ე ელემენტი. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,kat_Geor,python,"
FIX = """"""დაწერეთ ფუნქცია vowels_count რომელიც იღებს სტრიქონს, რომელიც წარმოადგენს სიტყვას და აბრუნებს სტრიქონში არსებული ხმოვანების რაოდენობას. ამ შემთხვევაში ხმოვანები არის 'a', 'e', 'i', 'o', 'u'. აქ 'y' ასევე ხმოვანია, მაგრამ მხოლოდ მაშინ, როდესაც იგი მოცემული სიტყვის ბოლოს არის. მაგალითი: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""დაამატეთ მეტი საცდელი შემთხვევა.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,kat_Geor,python,"
def circular_shift(x, shift):
    """"""წრიული გადაადგილება მთელი რიცხვის ციფრები x, გადაადგილება ციფრები მარჯვნივ გადაადგილება და დააბრუნოს შედეგი, როგორც სტრიქონს. თუ გადაადგილება > ციფრების რაოდენობა, დაბრუნება ციფრები inverted. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,kat_Geor,python,"
def digitSum(s):
    """"""დავალება დაწერეთ ფუნქცია, რომელიც იღებს სტრიქონს შეყვანის სახით და აბრუნებს მხოლოდ ზედა სიმბოლოების ჯამს ASCII კოდები. მაგალითები: digitSum ((("""") => 0 digitSum (((""abAB"") => 131 digitSum (((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum (((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,kat_Geor,python,"
def fruit_distribution(s,n):
    """"""ამ ამოცანაში, თქვენ მიიღებთ სტრიქონს, რომელიც წარმოადგენს ვაშლისა და ფორთოხლის რაოდენობას, რომლებიც განაწილებულია ხილის კალათაში. ეს კალათი შეიცავს ვაშლს, ფორთოხალსა და მანგოს ხილს. სტრიქონის მიხედვით, რომელიც წარმოადგენს ფორთოხალისა და ვაშლის საერთო რაოდენობას და მთელი რიცხვის მიხედვით, რომელიც წარმოადგენს კალათაში ხილის საერთო რაოდენობას, დააბრუნეთ მანგოს ხილის რაოდენობა კალათაში. მაგალითად: fruit_distribution""5(ვაშლი და 6 ფორთოხალი"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 ვაშლი და 1 ფორთოხალი"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 ვაშლი და 3 ფორთოხალი"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 ვაშლი და 120) "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,kat_Geor,python,"
def pluck(arr):
    """"""""მიმდინარე მასივი, რომელიც წარმოადგენს ხის ფილიალს, რომელსაც აქვს არა უარყოფითი მთლიანი კვანძები, თქვენი ამოცანაა ამოიღოთ ერთ-ერთი კვანძები და დააბრუნოთ იგი. ამოღებული კვანძი უნდა იყოს ყველაზე პატარა წყვილი მნიშვნელობის კვანძი. თუ ნაპოვნია რამდენიმე კვანძი იგივე ყველაზე პატარა წყვილი მნიშვნელობით, დააბრუნეთ კვანძს, რომელსაც აქვს ყველაზე პატარა ინდექსი. ამოღებული კვანძის დაბრუნება უნდა მოხდეს სიაში, [smallest_value, მისი ინდექსი ], თუ არ არსებობს წყვილი მნიშვნელობები ან მოცემული მასივი ცარიელია, დააბრუნეთ []. მაგალითი 1: შეყვანა: [4,2,3] გამოშვება: [2, 1] ახსნა: 2 აქვს ყველაზე პატარა წყვილი მნიშვნელობა, ხოლო 2 აქვს ყველაზე პატარა ინდექსი. მაგალითი 2: შეყვანა: [1,2,3] გამოშვება: [2, 1] ახსნა: 2 აქვს ყველაზე პატარა წყვილი მნიშვნელობა და 2 აქვს ყველაზე პატარა ინდექსი. მაგალითი 3: შეყვანა: [] [] [] [] [] [4: [5, [3, [0, 4] [0,] 2 გამოშვება: 1 ყველაზე პატარა კვანძით კვანძს უნდა დააბრუნდეს კვან, რომელსაც აქვს ყველაზე პატარა ინდექსი.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,kat_Geor,python,"
def search(lst):
    '''თქვენ გაქვთ არა ცარიელი სია დადებითი მთელი რიცხვების. დააბრუნეთ ყველაზე დიდი მთელი რიცხვი, რომელიც მეტია ნულზე და აქვს სიხშირე, რომელიც მეტია ან თანაბარია მთელი რიცხვის მნიშვნელობას. მთელი რიცხვის სიხშირე არის ის რაოდენობა, რამდენჯერაც ის ჩნდება სიაში. თუ ასეთი მნიშვნელობა არ არსებობს, დააბრუნეთ -1. მაგალითები: ძებნა (([4, 1, 2, 2, 3, 1]) == 2 ძებნა (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 ძებნა (([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,kat_Geor,python,"
def strange_sort_list(lst):
    '''მთელი რიცხვების მოცემული სია, დაბრუნების სია უცნაური თანმიმდევრობით. უცნაური დახარისხება, როდესაც იწყებთ მინიმალური ღირებულებით, შემდეგ დარჩენილი მთელი რიცხვების მაქსიმუმით, შემდეგ მინიმალური და ა.შ. მაგალითები: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,kat_Geor,python,"
def triangle_area(a, b, c):
    '''სამკუთხედის სამი მხარის სიგრძე. დააბრუნეთ სამკუთხედის ფართობი დაჭრილი 2 ათეულობით წერტილამდე, თუ სამი მხარე შეადგენს ვალიდურ სამკუთხედს. წინააღმდეგ შემთხვევაში დააბრუნეთ -1 სამი მხარე შეადგენს ვალიდურ სამკუთხედს, როდესაც ნებისმიერი ორი მხარის ჯამი უფრო დიდია, ვიდრე მესამე მხარე. მაგალითი: სამკუთხედი_ფართობი ((3, 4, 5) == 6.00 სამკუთხედი_ფართობი ((1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,kat_Geor,python,"
def will_it_fly(q,w):
    '''დაწერეთ ფუნქცია, რომელიც დააბრუნებს True-ს, თუ ობიექტი q გაფრინდება, და False-ს სხვა შემთხვევაში. ობიექტი q გაფრინდება, თუ ის დაბალანსებულია (ეს პალინდრომული სიაა) და მისი ელემენტების ჯამი ნაკლებია ან ტოლია მაქსიმალური შესაძლო წონის w-ს. მაგალითი: will_it_fly (([1, 2], 5) â -> False # 1+2 ნაკლებია მაქსიმალური შესაძლო წონისგან, მაგრამ ის დაბალანსებულია. will_it_fly (([3, 2, 3], 1) â -> False # ის დაბალანსებულია, მაგრამ 3+2+3 მეტია მაქსიმალურ შესაძლო წონაზე. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 ნაკლებია მაქსიმალური შესაძლო წონისგან და ის დაბალანსებულია. will_it_fly ((([3], â 5) -> True # 3 ნაკლებია მაქსიმალურ შესაძლო წონისგან და ის დაბალანსებულია.'''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,kat_Geor,python,"
def smallest_change(arr):
    """"""მთელი რიცხვების არეალის მიხედვით, იპოვეთ ელემენტების მინიმალური რაოდენობა, რომლებიც უნდა შეიცვალოს, რათა არეალი პალინდრომული გახდეს. პალინდრომული არეალი არის არეალი, რომელიც იკითხება იგივე წინ და უკან. ერთ ცვლილებაში შეგიძლიათ შეცვალოთ ერთი ელემენტი ნებისმიერი სხვა ელემენტად. მაგალითად: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,kat_Geor,python,"
def total_match(lst1, lst2):
    '''დაწერეთ ფუნქცია, რომელიც იღებს ორ სტრიქონს და დააბრუნებს იმ სიაში, რომელშიც ყველა სტრიქონში სიმბოლოების საერთო რაოდენობა ნაკლებია, ვიდრე მეორე სიაში. თუ ორი სიაში სიმბოლოების რაოდენობა თანაბარია, დააბრუნეთ პირველი სია. მაგალითები total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi'], 'hi'_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,kat_Geor,python,"
def is_multiply_prime(a):
    """"""დაწერეთ ფუნქცია, რომელიც დააბრუნებს მართლაც, თუ მოცემული რიცხვი არის 3 პირველადი რიცხვის გამრავლება და სხვა შემთხვევაში ცრუ. იცოდეთ, რომ (a) ნაკლებია, ვიდრე 100. მაგალითი: is_multiply_prime(30) == მართლაც 30 = 2 * 3 * 5 """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,kat_Geor,python,"
def is_simple_power(x, n):
    """"""თქვენი ამოცანაა დაწეროთ ფუნქცია, რომელიც დააბრუნებს მართლაც, თუ რიცხვი x არის n-ის მარტივი სიმძლავრე და სხვა შემთხვევებში ცრუ. x არის n-ის მარტივი სიმძლავრე, თუ n**int=x მაგალითად: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,kat_Geor,python,"
def iscube(a):
    '''დაწერეთ ფუნქცია, რომელიც იღებს მთელ რიცხვს a და დააბრუნებს True-ს, თუ ეს ინგერი არის მთელი რიცხვის კუბი. შენიშვნა: თქვენ შეიძლება ჩათვალოთ, რომ შეყვანა ყოველთვის ძალაშია. მაგალითები: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,kat_Geor,python,"
def hex_key(num):
    """"""თქვენ დავალებული ხართ დაწეროთ ფუნქცია, რომელიც მიიღებს ექვსეულობით რიცხვს სტრიქონად და დაითვლის ექვსეულობით ციფრების რაოდენობას, რომლებიც პირველები არიან (პირველი რიცხვი, ანუ პირველი რიცხვი, არის ნატურალური რიცხვი, რომელიც მეტია, ვიდრე 1, რომელიც არ არის ორი მცირე ნატურალური რიცხვის ნაყოფი). ექვსეულობით ციფრებია 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. პირველადი რიცხვები არიან 2, 3, 5, 7, 11, 13, 17,... ასე რომ თქვენ უნდა განსაზღვროთ შემდეგი ციფრების რაოდენობა: 2, 3, 5, 7, B (= ათეულობითი 11), D (= ათეულობითი 13). შენიშვნა: თქვენ შეიძლება ჩავთვალოთ, რომ შეყვანა ყოველთვის სწორია ან ცარიელი სტრიქონია, ხოლო სიმბოლოები A,B,C,D,E,F ყოველთვის დიდი ასოებითაა. მაგალითები: Num = AB გამოსავალი უნდა იყოს num = 1. Num = 1077E გამოსავალი უნდა იყოს 2. Num = AB331ED Num უნდა იყოს 4.BC = 6.01289D. Num = 6.045DEF = 6.02020""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,kat_Geor,python,"
def decimal_to_binary(decimal):
    """"""ფუნქცია უნდა დააბრუნოს სტრიქონი, სადაც თითოეული სიმბოლო წარმოადგენს ბინარულ რიცხვს. სტრიქონის თითოეული სიმბოლო იქნება '0' ან '1'. სტრიქონის დასაწყისში და ბოლოს იქნება დამატებითი ორი სიმბოლო 'db'. დამატებითი სიმბოლოები იქ არის ფორმატის დამხმარე. მაგალითები: decimal_to_binary ((15) # იბრუნებს ""db1111db"" decimal_to_binary32) # იბრუნებს ""db100000db""""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,kat_Geor,python,"
def is_happy(s):
    """"""თქვენ გაქვთ სტრიქონი s. თქვენი ამოცანაა შეამოწმოთ არის თუ არა სტრიქონი ბედნიერი. სტრიქონი ბედნიერი, თუ მისი სიგრძე არის მინიმუმ 3 და ყოველ 3 თანმიმდევრული ასოები განსხვავებულია. მაგალითად: არის_ბედნიერი (a) => ცრუ არის_ბედნიერი (aa) => ცრუ არის_ბედნიერი (abcd) => მართალი არის_ბედნიერი (aabb) => ცრუ არის_ბედნიერი (adb) => მართალი არის_ბედნიერი (xyy) => ცრუ """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,kat_Geor,python,"
def numerical_letter_grade(grades):
    """"""ეს არის სემესტრის ბოლო კვირა და მასწავლებელს უნდა მისცეს მოსწავლეებს ქულები. მასწავლებელი ქმნის თავის ალგორითმს ქულების დასადგენად. ერთადერთი პრობლემა ისაა, რომ მან დაკარგა კოდი, რომელსაც იყენებდა ქულების დასადგენად. მან მოგცა ზოგიერთი მოსწავლის GPA- ს სია და თქვენ უნდა დაწეროთ ფუნქცია, რომელიც შეიძლება გამოტანილი იყოს ასოების ქულების სია შემდეგი ცხრილის გამოყენებით: GPA. ასოების ქულა 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E მაგალითი: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,kat_Geor,python,"
def prime_length(string):
    """"""დაწერეთ ფუნქცია, რომელიც იღებს სტრიქონს და დააბრუნებს True-ს, თუ სტრიქონის სიგრძე არის უპირველესი რიცხვი ან False-ს სხვა შემთხვევაში. მაგალითები prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,kat_Geor,python,"
def starts_one_ends(n):
    """"""დადებითი მთელი რიცხვი n-ის მიხედვით, დააბრუნეთ იმ n-ნიშნის პოზიტიური მთელი რიცხვების რაოდენობა, რომლებიც იწყება ან მთავრდება 1-ით. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,kat_Geor,python,"
def solve(N):
    """"""მოცემული პოზიტიური მთელი რიცხვი N, დააბრუნეთ მისი ციფრების ჯამი ბინარულში. მაგალითი N = 1000- ისთვის ციფრების ჯამი იქნება 1 გამოსავალი უნდა იყოს ""1"". N = 150- ისთვის ციფრების ჯამი იქნება 6 გამოსავალი უნდა იყოს ""110"". N = 147- ისთვის ციფრების ჯამი იქნება 12 გამოსავალი უნდა იყოს ""1100"". ცვლადი: @N მთელი რიცხვი შეზღუდვები: 0 â‰¤ N â‰¤ 10000. გამოსავალი: ბინარული რიცხვის სტრიქონი """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,kat_Geor,python,"
def add(lst):
    """"""მთელი რიცხვების არაცარიელი სიის მიხედვით, ჯერ დავაკრიბოთ პარტიული ელემენტები, რომლებიც უცნაურ ინდექსებშია. მაგალითები: add (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,kat_Geor,python,"
def anti_shuffle(s):
    """"""დაწერეთ ფუნქცია, რომელიც იღებს სტრიქონს და აბრუნებს მისი დალაგებულ ვერსიას. სტრიქონის დალაგებული ვერსია არის სტრიქონი, სადაც ყველა სიტყვა (შორებულია სივრცით) შეიცვლება ახალი სიტყვით, სადაც ყველა სიმბოლო დალაგებულია ასკეის მნიშვნელობის საფუძველზე. შენიშვნა: თქვენ უნდა შეინახოთ სიტყვებისა და ცარიელი სივრცეების თანმიმდევრობა წინადადებაში. მაგალითად: anti_shuffle ((('Hi') აბრუნებს 'Hi' anti_shuffle ((('hello') აბრუნებს 'ehllo' anti_shuffle (('Hello World!!!') აბრუნებს 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,kat_Geor,python,"
def get_row(lst, x):
    """"""თქვენ გაქვთ 2 განზომილების მონაცემები, როგორც ჩასახული სიები, რომელიც მსგავსია მატრიცის, თუმცა, განსხვავებით მატრიცები, თითოეული რიგში შეიძლება შეიცავდეს სხვადასხვა რაოდენობის სვეტები. მოცემული lst, და მთლიანი რიცხვი x, იპოვოს მთლიანი რიცხვები x სიაში, და დაბრუნების სია tuples, [(x1, y1), (x2, y2) ...] ისე, რომ თითოეული tuple არის კოორდინატები - (რიგი, სვეტები), დაწყებული 0. დახარისხება კოორდინატები თავდაპირველად რიგები აღმავალი წესით. ასევე, დახარისხება კოორდინატები რიგები სვეტები ქვეითი წესით. მაგალითები: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1] ], 1) == [0, 0, 0, 0, 1, 4], 0 (2, 5), (2, 0, 0] get_(1), 1) [] == [[სვეტი [1], 2 , 3]], 2) [2, 3]]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,kat_Geor,python,"
def sort_array(array):
    """"""არანეგატიური მთლიანი რიცხვების მატრიდან, დახარისხების შემდეგ დააბრუნეთ მოცემული მატრის ასლი. დახარისხებთ მოცემულ მატრიდან მზარდი თანმიმდევრობით, თუ ჯამი ((პირველი ინდექსის ღირებულება, ბოლო ინდექსის ღირებულება) უცნაურია, ან დახარისხებთ მას მწირად, თუ ჯამი ((პირველი ინდექსის ღირებულება, ბოლო ინდექსის ღირებულება) პარტია. შენიშვნა: * არ შეცვალოთ მოცემული მატრი. მაგალითები: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,kat_Geor,python,"
def encrypt(s):
    """"""ფუნქციის შექმნა encrypt რომელიც იღებს სტრიქონს, როგორც არგუმენტს და აბრუნებს სტრიქონს, რომელიც არის დაშიფრული ანბანის ბრუნვით. ანბანი უნდა იყოს ბრუნული ისე, რომ ასოები გადავიდეს ქვემოთ ორჯერ ორ ადგილას. მაგალითად: encrypt (('hi') აბრუნებს 'lm' encrypt (('asdfghjkl') აბრუნებს 'ewhjklnop' encrypt (('gf') აბრუნებს 'kj' encrypt (('et') აბრუნებს 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,kat_Geor,python,"
def next_smallest(lst):
    """"""თქვენ გაქვთ მთელი რიცხვების სია. დაწერეთ ფუნქცია next_smallest ((), რომელიც დააბრუნებს სიაში მე-2 ყველაზე პატარა ელემენტს. დააბრუნებს None, თუ ასეთი ელემენტი არ არსებობს. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,kat_Geor,python,"
def is_bored(S):
    """"""თქვენ მოგცემთ სიტყვების სტრიქონს და თქვენი ამოცანაა დაითვალოთ მოწყენილობის რაოდენობა. მოწყენილობა არის წინადადება, რომელიც იწყება სიტყვით ""I"". წინადადებები გამოყოფილია '.', '?' ან '! ' მაგალითად: >>> არის_მოწყენილობა ((""მოგესალმებით სამყარო"") 0 >>> არის_მოწყენილობა ((""ცისფერი ცაა. მზე ანათებს. მიყვარს ეს ამინდი"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,kat_Geor,python,"
def any_int(x, y, z):
    '''შექმენით ფუნქცია, რომელიც იღებს 3 რიცხვს. დააბრუნებს მართლაც, თუ ერთ-ერთი რიცხვი უდრის დანარჩენი ორი რიცხვის ჯამს და ყველა რიცხვი არის მთელი რიცხვი. დააბრუნებს ცრუ ნებისმიერ სხვა შემთხვევაში. მაგალითები any_int ((5, 2, 7) â -> True any_int ((3, 2, 2) â -> False any_int ((3, -2, 1) â -> True any_int ((3.6, -2.2, 2) â -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,kat_Geor,python,"
def encode(message):
    """"""დაწერეთ ფუნქცია, რომელიც იღებს შეტყობინებას და კოდირებს ისე, რომ შეცვალოს ყველა ასოს კეისი, შეცვალოს ყველა ხმოვანი შეტყობინება ასოთი, რომელიც ჩნდება 2 ადგილით წინ ამ ხმოვანის ინგლისურ ანბანში. მიიღეთ მხოლოდ ასოები. მაგალითები: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,kat_Geor,python,"

def skjkasdkd(lst):
    """"""თქვენ გაქვთ მთელი რიცხვების სია. თქვენ უნდა იპოვოთ ყველაზე დიდი უპირველესი მნიშვნელობა და დააბრუნოთ ციფრების ჯამი. მაგალითები: For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] გამოსავალი უნდა იყოს 10 For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] გამოსავალი უნდა იყოს 25 For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] გამოსავალი უნდა იყოს 13 For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] გამოსავალი უნდა იყოს 11 For lst = [0,81,12,3,21,1] გამოსავალი უნდა იყოს 3 For lst = [0,1,8,2,1,7] გამოსავალი უნდა იყოს 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,kat_Geor,python,"
def check_dict_case(dict):
    """"""მოცემული ლექსიკონი, დაბრუნება True თუ ყველა გასაღები არის სტრიქონები მცირე ან ყველა გასაღები არის სტრიქონები დიდი ასოებით, სხვა შემთხვევაში დაბრუნება False. ფუნქცია უნდა დააბრუნოს False მოცემული ლექსიკონი ცარიელია. მაგალითები: check_dict_case{""a"":""apple"", ""b"":""banana""}) უნდა დააბრუნოს True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) უნდა დააბრუნოს False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) უნდა დააბრუნოს False. check_dict_case{""NC"":""STATE"", ""Z"":""IP""}) უნდა დააბრუნოს False.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,kat_Geor,python,"
def count_up_to(n):
    """"""განახორციელეთ ფუნქცია, რომელიც იღებს არაუარყოფით მთელ რიცხვს და აბრუნებს მასივს პირველი n მთლიანი რიცხვისგან, რომლებიც არის ნაცვლად რიცხვები და ნაკლებია n-ზე. მაგალითად: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,kat_Geor,python,"
def multiply(a, b):
    """"""შეავსეთ ფუნქცია, რომელიც იღებს ორ მთლიან რიცხვს და იბრუნებს მათი ერთეულის ციფრების ნაყოფს. ვარაუდობთ, რომ შეყვანა ყოველთვის ძალაშია. მაგალითები: გამრავლება ((148, 412) უნდა დააბრუნოს 16. გამრავლება ((19, 28) უნდა დააბრუნოს 72. გამრავლება ((2020, 1851) უნდა დააბრუნოს 0. გამრავლება ((14,-15) უნდა დააბრუნოს 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,kat_Geor,python,"
def count_upper(s):
    """"""string s-ის მიხედვით, დათვალეთ დიდი ხმოვანების რაოდენობა პარტიულ ინდექსებში. მაგალითად: count_upper (('aBCdEf') აბრუნებს 1 count_upper (('abcdefg') აბრუნებს 0 count_upper (('dBBE') აბრუნებს 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,kat_Geor,python,"
def closest_integer(value):
    '''შექმენით ფუნქცია, რომელიც იღებს მნიშვნელობას (სტრინგს), რომელიც წარმოადგენს რიცხვს და უბრუნებს მასთან უახლოეს მთელ რიცხვს. თუ რიცხვი თანაბრად არის დაშორებული ორი მთლიანი რიცხვისგან, დაატრიალეთ ის ნულიდან. მაგალითები >>> უახლოესი_მთლიანი რიცხვი ((""10"") 10 >>> უახლოესი_მთლიანი რიცხვი ((""15.3"") 15 შენიშვნა: ნულიდან დაატრიალება ნიშნავს, რომ თუ მოცემული რიცხვი თანაბრად არის დაშორებული ორი მთლიანი რიცხვისგან, ის, რაც უნდა დააბრუნოთ, არის ის, რაც ყველაზე შორს არის ნულიდან. მაგალითისთვის უახლოესი_მთლიანი რიცხვი "" ((14.5"") უნდა დააბრუნოს 15 და უახლოესი_მთლიანი რიცხვი "" ((-14.5"") უნდა დააბრუნოს -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,kat_Geor,python,"
def make_a_pile(n):
    """"""დადებითი მთელი რიცხვი n-ის მიხედვით, თქვენ უნდა გააკეთოთ ქვების n დონე. პირველ დონეზე არის n ქვა. ქვების რაოდენობა შემდეგ დონეზე არის: - შემდეგი უცნაური რიცხვი, თუ n უცნაურია. - შემდეგი წყვილი რიცხვი, თუ n წყვილია. დააბრუნეთ ქვების რაოდენობა თითოეულ დონეზე სიაში, სადაც ელემენტი ინდექსში i წარმოადგენს ქვების რაოდენობას დონეზე (i+1). მაგალითები: >>> make_a_pile (i+1) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,kat_Geor,python,"
def words_string(s):
    """"""თქვენ მოგცემთ სიტყვების სტრიქონს, რომლებიც გამოყოფილია კომებით ან ცარიელი ადგილების საშუალებით. თქვენი ამოცანაა, რომ სტრიქონს გაყოთ სიტყვებად და დაუბრუნოთ სიტყვების მასივი. მაგალითად: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,kat_Geor,python,"
def choose_num(x, y):
    """"""ეს ფუნქცია იღებს ორ პოზიტიურ რიცხვს x და y და აბრუნებს ყველაზე დიდ პარტნიორ მთელ რიცხვს, რომელიც არის [x, y] ჩათვლით. თუ ასეთი რიცხვი არ არსებობს, მაშინ ფუნქცია უნდა დააბრუნოს -1. მაგალითად: choose_num(12, 15) = 14 choose_num(13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,kat_Geor,python,"
def rounded_avg(n, m):
    """"""თქვენ გაქვთ ორი დადებითი მთელი რიცხვი n და m, თქვენი ამოცანაა გამოითვალოთ n-დან m-მდე მთელი რიცხვების საშუალო. დაატრიალეთ პასუხი უახლოეს მთელ რიცხვამდე და გადააკეთეთ ის ბინარულში. თუ n-ი m-ზე დიდია, დააბრუნეთ -1. მაგალითი: დაატრიალეთ_avg ((1, 5) => ""0b11"" დაატრიალეთ_avg ((7, 5) => -1 დაატრიალეთ_avg ((10, 20) => ""0b1111"" დაატრიალეთ_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,kat_Geor,python,"
def unique_digits(x):
    """"""დადებითი მთლიანი რიცხვების ჩამონათვალი x. დააბრუნეთ ყველა ელემენტის დახარისხებული ჩამონათვალი, რომელსაც არ აქვს არცერთი წყვილი ციფრი. შენიშვნა: დაბრუნებული სია უნდა დახარისხდეს მზარდი წესით. მაგალითად: >>> უნიკალური_ციფრები (([15, 33, 1422, 1]) [1, 15, 33] >>> უნიკალური_ციფრები (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,kat_Geor,python,"
def by_length(arr):
    """"""მთელი რიცხვების მასივიდან, დაალაგეთ მთელი რიცხვები, რომლებიც 1-დან 9-მდეა, შეარჩიეთ მიღებული მასივი და შემდეგ შეცვალეთ თითოეული ციფრი მისი შესაბამისი სახელით ""ერთი"", ""ორი"", ""სამი"", ""ოთხი"", ""ხუთი"", ""ექვსი"", ""შვიდი"", ""რვა"", ""ცხრა"". მაგალითად: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> დაალაგეთ arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> შეარჩიეთ arr -> [8, 5, 4, 3, 2, 2, 1, 1] დაბრუნება [""რვა"", ""ოთხი"", ""სამი"", ""ორი"", ""ორი"", ""ერთი"", ""ერთი""] თუ მასივი ცარიელია, დააბრუნეთ მასივი: arr = [] დაბრუნება [] თუ მასივში არის რაიმე უცნაური რიცხვი, უგულებელყოთ მას: arr = [1, -1 , 55 -> arr -> [1, 1], 55 -> arr -> [55, 1] - დაბრუნება ['one'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,kat_Geor,python,"
def f(n):
    """"""განვახორციელოთ ფუნქცია f, რომელიც იღებს n-ს პარამეტრად და აბრუნებს n ზომის სიას, ისე, რომ i ინდექსის ელემენტის ღირებულება იყოს i-ის ფაქტორიალი, თუ i არის წყვილი ან სხვა შემთხვევაში 1-დან i-მდე რიცხვების ჯამი. i იწყება 1-დან. i-ის ფაქტორიალი არის რიცხვების გამრავლება 1-დან i-მდე (1 * 2 * ... * i). მაგალითი: f ((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,kat_Geor,python,"
def even_odd_palindrome(n):
    """"""დადებითი მთელი რიცხვი n, დააბრუნეთ ტუპლი, რომელსაც აქვს თანაბარი და უცნაური მთელი რიცხვების პალინდრომების რაოდენობა, რომლებიც შედის დიაპაზონში ((1, n), მათ შორის. მაგალითი 1: შეყვანა: 3 გამომავალი: (1, 2) ახსნა: მთელი რიცხვების პალინდრომები არიან 1, 2, 3. ერთი მათგანი არის თანაბარი, და ორი მათგანი არის უცნაური. მაგალითი 2: შეყვანა: 12 გამომავალი: (4, 6) ახსნა: მთელი რიცხვების პალინდრომები არიან 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ოთხი მათგანი არის თანაბარი, და 6 მათგანი არის უცნაური. შენიშვნა: 1. 1 <= n <= 10 ^ 3 2. ტუპლი დააბრუნებს თანაბარი და უცნაური მთელი რიცხვების პალინდრომების რაოდენობას, შესაბამისად. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,kat_Geor,python,"
def count_nums(arr):
    """"""დაწერეთ ფუნქცია count_nums რომელიც იღებს მთლიანი რიცხვების მასივს და აბრუნებს ელემენტების რაოდენობას, რომლის ციფრების ჯამი არის > 0. თუ რიცხვი უარყოფითია, მაშინ მისი პირველი ხელმოწერილი ციფრი იქნება უარყოფითი: მაგ. -123 აქვს ხელმოწერილი ციფრები -1, 2, და 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,kat_Geor,python,"
def move_one_ball(arr):
    """"""ჩვენ გვაქვს 'arr' array N მთელი რიცხვების arr[1], arr[2], ..., arr[N].რიგში რიცხვები შემთხვევითი წესით იქნება დალაგებული. თქვენი ამოცანაა განსაზღვროთ, შესაძლებელია თუ არა არე დალაგებული არამცირებელი წესით მოცემულ მასალაზე შემდეგი ოპერაციის შესრულებით: თქვენ უფლება გაქვთ შეასრულოთ მარჯვენა გადაადგილების ოპერაცია რამდენჯერმე. მარჯვენა გადაადგილების ოპერაცია ნიშნავს მასალის ყველა ელემენტის გადაადგილებას ერთი პოზიციით მარჯვენა მიმართულებით. მასალის ბოლო ელემენტი გადაიტანება მასალის საწყის პოზიციაზე, ანუ 0-ე ინდექსზე. თუ შესაძლებელია დალაგებული მასალის მიღება ზემოთ მოცემული ოპერაციის შესრულებით, მაშინ დაბრუნება True, სხვა შემთხვევაში დაბრუნება False. თუ მოცემული მასალა ცარიელია, მაშინ დაბრუნება True. შენიშვნა: მოცემული სია გარანტირებულია უნიკალური ელემენტების მქონე. მაგალითად: move_one_(ball[3, 4, 5, 2] True ახსნა: Performin 2 მარჯვენა ოპერაციების შესრულებით, არამცირებადი წესით შეიძლება მივაგვე მივაგოთ მასალას.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,kat_Geor,python,"
def exchange(lst1, lst2):
    """"""ამ ამოცანაში თქვენ განახორციელებთ ფუნქციას, რომელიც იღებს რიცხვების ორ სიას და განსაზღვრავს, შესაძლებელია თუ არა მათ შორის ელემენტების გაცვლა, რათა lst1 გახდეს მხოლოდ პარტიული რიცხვების სია. არ არსებობს ლიმიტი lst1-სა და lst2-ს შორის გაცვლილი ელემენტების რაოდენობაზე. თუ შესაძლებელია lst1-სა და lst2-ს შორის ელემენტების გაცვლა, რათა lst1-ის ყველა ელემენტი იყოს პარტიული, დააბრუნეთ ""დიახ"". წინააღმდეგ შემთხვევაში, დააბრუნეთ ""არა"". მაგალითად: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""დიახ"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""არა"" ვარაუდობს, რომ შეყვანილი სიები არ იქნება ცარიელი. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,kat_Geor,python,"
def histogram(test):
    """"""მოცემული სტრიქონი, რომელიც წარმოადგენს კარიშხლით დაშორებულ მცირე ასოებს, დააბრუნეთ ყველაზე ხშირად გამეორებული ასოს ლექსიკონი, რომელიც შეიცავს შესაბამის რიცხვს. თუ რამდენიმე ასოს აქვს ერთი და იგივე შემთხვევა, დააბრუნეთ ყველა მათგანი. მაგალითი: ჰისტოგრამა ((('a b c') == {'a': 1, 'b': 1, 'c': 1} ჰისტოგრამა ((('a b b a') == {'a': 2, 'b': 2} ჰისტოგრამა ((('a b c a b') == {'a': 2, 'b': 2} ჰისტოგრამა ((('b b a') == {'b 4}': ჰისტოგრამა (((')) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,kat_Geor,python,"
def reverse_delete(s,c):
    """"""დავალება ჩვენ გვაქვს ორი სტრიქონი s და c, თქვენ უნდა წაშალოთ ყველა სიმბოლო s- ში, რომლებიც თანაბარია c- ში ნებისმიერი სიმბოლოზე, შემდეგ შეამოწმეთ, არის თუ არა შედეგის სტრიქონი პალინდრომი. სტრიქონს ეწოდება პალინდრომი, თუ იგი იკითხება იგივე უკან და წინ. თქვენ უნდა დააბრუნოთ ტუპლი, რომელიც შეიცავს შედეგის სტრიქონს და True/False შემოწმებისთვის. მაგალითი s = ""abcde"", c = ""ae"", შედეგი უნდა იყოს ('bcd', False) s = ""abcdef"", c = ""b"" შედეგი უნდა იყოს ('acdef', False) s = ""abcdedcba"", c = ""ab"", შედეგი უნდა იყოს ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,kat_Geor,python,"
def odd_count(lst):
    """"""სტრიქონების ჩამონათვალი, სადაც თითოეული სტრიქონი მხოლოდ ციფრებისგან შედგება, დაბრუნება სია. თითოეული ელემენტი i გამოსავალი უნდა იყოს ""უნაწილო ელემენტების რაოდენობა სტრიქონში i შეყვანის. "" სადაც ყველა i უნდა შეიცვალოს უნაწილო ციფრების რაოდენობით i'th სტრიქონში შეყვანის. >>> odd_count ['1234567']) [""უნაწილო ელემენტების რაოდენობა 4n the str4ng 4 of the 4nput.""] >>> odd_count ['3', ""11111111""]) [""უნაწილო ელემენტების რაოდენობა 1n the str1ng 1 of the 1nput. "", ""უნაწილო ელემენტების რაოდენობა 8n the str8ng 8 of the 8nput. ""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,kat_Geor,python,"
def minSubArraySum(nums):
    """"""მთელი რიცხვების არეალის მიხედვით, იპოვეთ რიცხვების არამცარიელი ქვე-არეალის მინიმალური ჯამი. მაგალითი minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,kat_Geor,python,"
def max_fill(grid, capacity):
    import math
    """"""თქვენ გაქვთ ჭების მართკუთხა ქსელი. თითოეული რიგის წარმომადგენელი არის ერთი ჭა, ხოლო თითოეული რიგის 1 წარმოადგენს წყლის ერთეულს. თითოეულ ჭა-ს აქვს შესაბამისი კალამი, რომელიც შეიძლება გამოყენებულ იქნას წყლის მოსაპოვებლად და ყველა კალამს აქვს იგივე მოცულობა. თქვენი ამოცანაა გამოიყენოთ კალამები ჭების გასაწმენდად. გამოტანა იმ რაოდენობის, რამდენჯერაც გჭირდებათ ჭების დაშვება. მაგალითი 1: შესავალი: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 გამოსავალი: მაგალითი 6: შესავალი: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 გამოსავალი: მაგალითი 5: შესავალი: [[:0,0,0], [0,0]] bucket_capacity: well 5 გამოსავალი: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,kat_Geor,python,"
def sort_array(arr):
    """"""ამ კატაში თქვენ უნდა დაალაგოთ არა უარყოფითი მთლიანი რიცხვების მასივი მათი ბინარული წარმოდგენის რაოდენობის მიხედვით მზარდი თანმიმდევრობით. მსგავსი რაოდენობის ერთეულებისათვის, დაალაგეთ ათეულობითი მნიშვნელობის საფუძველზე. ეს უნდა განხორციელდეს შემდეგნაირად: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,kat_Geor,python,"
def select_words(s, n):
    """"""მოცემული სტრიქონის s და ნატურალური რიცხვის n, თქვენ დავალებული ხართ განახორციელოთ ფუნქცია, რომელიც აბრუნებს ყველა სიტყვის სია სტრიქონის s- დან, რომლებიც შეიცავს ზუსტად n თანხმოვანებს, რათა ეს სიტყვები გამოჩნდეს სტრიქონში s. თუ სტრიქონის s ცარიელია, მაშინ ფუნქცია უნდა დააბრუნოს ცარიელი სია. შენიშვნა: თქვენ შეიძლება ვივარაუდოთ, რომ შეყვანილი სტრიქონი შეიცავს მხოლოდ ასოებს და სივრცეებს. მაგალითები: select_words ""მარიამ პატარა ცხვარი ჰყავდა"", 4) ==> [""მცირე""] select_words ""მარიამ პატარა ცხვარი ჰყავდა"", 3) ==> [""მცირე""] select_words ""მარტივი თეთრი სივრცე"", 2) ==> [] select_words ""მოგესალმებით, სამყარო"", 4) ==> [""მსოფლიო""] select_words ""დედა სამ"", 3) ==> [""დედა""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,kat_Geor,python,"
def get_closest_vowel(word):
    """"""თქვენ გექნებათ სიტყვა. თქვენი ამოცანაა იპოვოთ უახლოესი ხმოვანი, რომელიც დგას ორი თანხმოვანი შორის სიტყვის მარჯვენა მხრიდან (მნიშვნელოვანი). ხმოვანი დასაწყისში და დასასრულს არ ითვლება. დაბრუნება ცარიელი სტრიქონი, თუ არ იპოვეთ ხმოვანი შეხვდა ზემოთ მოცემული პირობა. თქვენ შეიძლება ვარაუდობ, რომ მოცემული სტრიქონი შეიცავს მხოლოდ ინგლისური ასო. მაგალითი: get_closest_vowel ((""yogurt"") ==> ""u"" get_closest_vowel ((""F"") ==> ""U"" get_closest_vowel ((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,kat_Geor,python,"
def match_parens(lst):
    '''თქვენ გაქვთ ორი სტრიქონის სია, ორივე სტრიქონში მხოლოდ ღია კვეთა '(' ან დახურული კვეთა ') 'ა. თქვენი საქმეა შეამოწმოთ, შესაძლებელია თუ არა ორი სტრიქონის გარკვეული თანმიმდევრობით შეკრება, რომ შედეგად მიღებული სტრიქონი კარგი იყოს. სტრიქონს S ითვლება კარგად, თუ და მხოლოდ თუ ყველა კვეთა S- ში დაბალანსებულია. მაგალითად: სტრიქონს '((()) ' კარგია, ხოლო სტრიქონს '()) ' არა. დაბრუნება 'დიახ', თუ არსებობს კარგი სტრიქონის შექმნის გზა, და დაბრუნება 'არა' სხვა შემთხვევაში. მაგალითები: match_parens [('() ', ') ']) == 'დიახ' match_parens [(') ', ') ']) == 'არა' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,kat_Geor,python,"
def maximum(arr, k):
    """"""მთელი რიცხვების დადებითი მთელი რიცხვის k-ს მატერიალური მასივის მიხედვით, დააბრუნეთ k სიგრძის დახარისხებული სია, რომლის მაქსიმალური რაოდენობა k რიცხვია. მაგალითი1: შეყვანა: arr = [-3, -4, 5], k = 3 გამოსავალი: [-4, -3, 5] მაგალითი2: შეყვანა: arr = [4, -4, 4], k = 2 გამოსავალი: [4, 4] მაგალითი3: შეყვანა: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 გამოსავალი: [2] შენიშვნა: 1. მასივის სიგრძე იქნება [1, 1000] ფარგლებში. 2. მასივის ელემენტები იქნება [-1000, 1000] ფარგლებში. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,kat_Geor,python,"
def solution(lst):
    """"""მთელი რიცხვების არაცარიელი სიის მიხედვით, დააბრუნეთ ყველა უცნაური ელემენტის ჯამი, რომლებიც თანაბარ პოზიციებშია. მაგალითები გამოსავალი (([5, 8, 7, 1]) ==> 12 გამოსავალი (([3, 3, 3, 3, 3]) ==> 9 გამოსავალი (([30, 13, 24, 321]) ==> 0 """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,kat_Geor,python,"
def add_elements(arr, k):
    """"""მთელი რიცხვების არამცარიელი მასივისა და მთელი რიცხვის k-ის მიხედვით, დააბრუნეთ ელემენტების ჯამი, რომლებიც არარის პირველი k ელემენტის მაქსიმუმ ორი ციფრით შედგება. მაგალითი: შემავალი: arr = [111,21,3,4000,5,6,7,8,9], k = 4 გამოსავალი: 24 # 21 + 3 შეზღუდვები: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,kat_Geor,python,"
def get_odd_collatz(n):
    """"""დადებითი მთელი რიცხვი n-ის მიხედვით, დააბრუნეთ დახარისხებული სია, რომელშიც არის უცნაური რიცხვები კოლატცის თანმიმდევრობით. კოლატცის ვარაუდი არის მათემატიკის ვარაუდი, რომელიც ეხება თანმიმდევრობას, რომელიც განსაზღვრულია შემდეგნაირად: დაიწყეთ ნებისმიერი დადებითი მთელი რიცხვი n-ით. შემდეგ თითოეული ტერმინი მიიღება წინა ტერმინისგან შემდეგნაირად: თუ წინა ტერმინი არის წყვილი, შემდეგი ტერმინი არის წინა ტერმინის ნახევარი. თუ წინა ტერმინი არის უცნაური, შემდეგი ტერმინი არის წინა ტერმინის 3 ჯერ პლუს 1. ვარაუდი არის ის, რომ არ აქვს მნიშვნელობა, რა მნიშვნელობა აქვს n-ს, თანმიმდევრობას ყოველთვის მიაღწევს 1. შენიშვნა: 1. კოლატცს (((1) არის [1]. 2. დააბრუნებული სია დახარისხებულია მზარდი წესით. მაგალითად: get_odd_collatz ((5) ბრუნდება [1, 5] # კოლატცის თანმიმდევრობა 5 არის [5, 8, 16, 4, 2, 1], ასე რომ უცნაური რიცხვები მხოლოდ 1, და 5 """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,kat_Geor,python,"
def valid_date(date):
    """"""თქვენ უნდა დაწეროთ ფუნქცია, რომელიც დაადგენს თარიღის სტრიქონს და დააბრუნებს True-ს, თუ თარიღი არის სწორი, წინააღმდეგ შემთხვევაში False. თარიღი არის სწორი, თუ ყველა შემდეგი წესი დაკმაყოფილებულია: 1. თარიღის სტრიქონი არ არის ცარიელი. 2. დღეების რაოდენობა არ არის 1 ან მეტი 31 დღეზე ნაკლები თვეების 1,3,5,7,8,10,12-ში. და დღეების რაოდენობა არ არის 1 ან მეტი 30 დღეზე ნაკლები თვეების 4,6,9,11-ში. და დღეების რაოდენობა არ არის 1 ან მეტი 29 თვეში. 2. თვეები არ უნდა იყოს 1 ან მეტი 12. 4. თარიღი უნდა იყოს ფორმატში: mm-dd-yyyy მაგალითად: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-02040') => False_valid_date (('06-04-2020') => True_valid_date (('06/04/2020') => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,kat_Geor,python,"
def split_words(txt):
    '''მოცემული სიტყვების სტრიქონი, დააბრუნეთ სიტყვების სია, რომლებიც გაყოფილია თეთრი ფართებით, თუ ტექსტში არ არსებობს თეთრი ფართები, თქვენ უნდა გაყოთ კომატები ',' თუ კომატები არ არსებობს, თქვენ უნდა დააბრუნოთ მცირე ასოების რაოდენობა ანბანში უცნაური თანმიმდევრობით, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 მაგალითები split_words ((""მოგესალმებით სამყარო!"") â -> [""მოგესალმებით"", ""მსოფლიო!""] split_words ((""მოგესალმებით, სამყარო!"") â -> [""მოგესალმებით"", ""მსოფლიო!""] split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,kat_Geor,python,"
def is_sorted(lst):
    '''მოცემული რიცხვების სია, დაბრუნება, თუ ისინი დახარისხებულია აღმავალი წესით. თუ სიაში არის ერთზე მეტი დუბლიკატის იგივე რიცხვი, დაბრუნება False. ვარაუდობენ, რომ უარყოფითი რიცხვები და მხოლოდ მთელი რიცხვები. მაგალითები is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,kat_Geor,python,"
def intersection(interval1, interval2):
    """"""თქვენ გაქვთ ორი ინტერვალი, სადაც თითოეული ინტერვალი არის მთელი რიცხვების წყვილი. მაგალითად, ინტერვალი = (დაწყება, დასასრული) = (1, 2). მოცემული ინტერვალები დახურულია, რაც ნიშნავს, რომ ინტერვალი (დაწყება, დასასრული) მოიცავს როგორც დასაწყისს, ასევე დასასრულს. თითოეული მოცემული ინტერვალისათვის, ვარაუდობენ, რომ მისი დასაწყისი ნაკლებია ან ტოლია მისი დასასრულის. თქვენი ამოცანაა, დაადგინოთ, არის თუ არა ამ ორი ინტერვალის კვეთის სიგრძე მარტივი რიცხვი. მაგალითად, ინტერვალების კვეთის სიგრძე (1, 3), (2, 4) არის (2, 3), რომლის სიგრძე არის 1, რომელიც არ არის მარტივი რიცხვი. თუ კვეთის სიგრძე მარტივი რიცხვია, დააბრუნეთ ""დიახ"", წინააღმდეგ შემთხვევაში დააბრუნეთ ""არა"". თუ ორი ინტერვალი არ კვეთს, დააბრუნეთ ""არა"". [input/output] ნიმუშები: intersection (((1, 2), (2, 3) ==> ""intersection ((1, 1) ""NO"") =="", intersection (<0, 4) ==""NO (<0, 5), - (((1, 5), "" ((((((((((((((((((((((((((((((((((())))))))))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,kat_Geor,python,"
def prod_signs(arr):
    """"""თქვენ გაქვთ მთელი რიცხვების მასივი და თქვენ უნდა დააბრუნოთ მთელი რიცხვების სიდიდეების ჯამი, გამრავლებული მასივის თითოეული რიცხვის ყველა ნიშნის პროდუქტით, რომელიც წარმოდგენილია 1, -1 ან 0. შენიშვნა: დაბრუნება არ არის ცარიელი arr- ისთვის. მაგალითი: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,kat_Geor,python,"
def minPath(grid, k):
    """"""მოცემული ქსელი N რიგებით და N სვეტებით (N > = 2) და დადებითი მთლიანი k, ქსელის თითოეული უჯრედი შეიცავს მნიშვნელობას. [1, N * N] ჩათვლით, ყველა მთლიანი რიცხვი ზუსტად ერთხელ ჩნდება ქსელის უჯრედებზე. თქვენ უნდა იპოვოთ სიგრძის k მინიმალური გზა ქსელში. თქვენ შეგიძლიათ დაიწყოთ ნებისმიერი უჯრიდან და თითოეულ ნაბიჯში შეგიძლიათ გადახვიდეთ ნებისმიერ მეზობელ უჯრედზე, სხვა სიტყვებით, შეგიძლიათ გადახვიდეთ უჯრედებზე, რომლებიც იზიარებენ კიდეს თქვენს მიმდინარე უჯრედთან. გთხოვთ გაითვალისწინოთ, რომ k სიგრძის გზა ნიშნავს ზუსტად k უჯრედის მონახულებას (არ არის აუცილებლად განსხვავებული). თქვენ არ შეგიძლიათ წასვლა ქსელიდან. A გზა (k სიგრძის) ითვლება ნაკლებად ვიდრე B გზა (k სიგრძის) თუ მას შემდეგ, რაც დალაგებული სიები ღირებულებების უჯრედებზე, რომლებმაც გაიარეს A და B (მოვიწვიოთ მათ l_st და l_stA_st l_stB), l_stA_ს ლექსიკოგრაფიკურად ნაკლებია, ვიდრე l_stB_st), l_st_ს არის ნაკლები, ვიდრე l_st_st_st_st_ს, l_st_st_ს, j_j, j_j, j_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_[[[[[1,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_j,_[[[[,_j,_j,_j,_j,_j,_j,_j,_j,_j,_[,_[,_j,_[,_j,_,_,_,_""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,kat_Geor,python,"
def tri(n):
    """"""ყველა იცის ფიბონაჩის თანმიმდევრობა, მას მკაცრად სწავლობდნენ მათემატიკოსები ბოლო რამდენიმე საუკუნის განმავლობაში. თუმცა, ის, რაც ხალხს არ იცის, არის ტრიბონაჩის თანმიმდევრობა. ტრიბონაჩის თანმიმდევრობა განისაზღვრება განმეორებით: tri(1) = 3 tri(n) = 1 + n / 2, თუ n არის პარტიული. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), თუ n არის უცნაური. მაგალითად: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 თქვენ გაქვთ ნეგატიური მთელი რიცხვი n, თქვენ უნდა დააბრუნოთ ტრიბონაჩის თანმიმდევრობის პირველი n + 1 რიცხვის სია. მაგალითები: tri(3) = [1, 3, 2, 8] """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,kat_Geor,python,"
def digits(n):
    """"""დადებითი მთელი რიცხვის n-ის მიხედვით, დააბრუნეთ უცნაური ციფრების ნაყოფი. დააბრუნეთ 0 თუ ყველა ციფრი თანაბარია. მაგალითად: ციფრები ((1) == 1 ციფრი ((4) == 0 ციფრი ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,kat_Geor,python,"
def is_nested(string):
    '''შექმენით ფუნქცია, რომელიც იღებს სტრიქონს, როგორც შეყვანას, რომელიც შეიცავს მხოლოდ კვადრატულ ბრჭყალებს. ფუნქცია უნდა დააბრუნოს True, თუ და მხოლოდ თუ არსებობს ბრჭყალების ვალიდური ქვეშემადგენლობა, სადაც მინიმუმ ერთი ბრჭყალები არის ჩასახული. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[[]]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]]') â -> True is_nested '[[]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,kat_Geor,python,"

def sum_squares(lst):
    """"""თქვენ გექნებათ რიცხვების სია. თქვენ უნდა დააბრუნოთ მოცემული სიის კვადრატის რიცხვების ჯამი, თავიდან დაატრიალოთ თითოეული ელემენტი სიაში ზედა int ((ceiling) -ზე. მაგალითები: For lst = [1,2,3] გამოსავალი უნდა იყოს 14 For lst = [1,4,9] გამოსავალი უნდა იყოს 98 For lst = [1,3,5,7] გამოსავალი უნდა იყოს 84 For lst = [1.4,4.2,0] გამოსავალი უნდა იყოს 29 For lst = [-2.4,1,1] გამოსავალი უნდა იყოს 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,kat_Geor,python,"
def check_if_last_char_is_a_letter(txt):
    '''შექმენით ფუნქცია, რომელიც დააბრუნებს True, თუ მოცემული სტრიქონის ბოლო სიმბოლო არის ანბანური სიმბოლო და არ არის სიტყვის ნაწილი, და False სხვა შემთხვევაში. შენიშვნა: ""სიტყვა"" არის სიმბოლოების ჯგუფი, რომლებიც გამოყოფილია სივრცით. მაგალითები: check_if_last_char_is_a_letter ((""apple pie"") â -> False check_if_last_char_is_a_letter ((""apple pi e"") â -> True check_if_last_char_is_a_letter ((""apple pi e "") â -> False check_if_last_char_is_a_letter"" ((("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,kat_Geor,python,"
def can_arrange(arr):
    """"""შექმენით ფუნქცია, რომელიც დააბრუნებს ყველაზე დიდ ინდექსს ელემენტისა, რომელიც არ არის უფრო დიდი ან თანაბარი მასთან უშუალოდ წინა ელემენტთან. თუ ასეთი ელემენტი არ არსებობს, მაშინ დააბრუნეთ -1. მოცემული მასივი არ შეიცავს დუბლირებულ მნიშვნელობებს. მაგალითები: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,kat_Geor,python,"
def largest_smallest_integers(lst):
    '''შექმენით ფუნქცია, რომელიც დააბრუნებს ტუპლს (a, b), სადაც 'a' არის უარყოფითი მთლიანი რიცხვების ყველაზე დიდი და 'b' არის ყველაზე პატარა დადებითი მთლიანი რიცხვები სიაში. თუ არ არსებობს უარყოფითი ან დადებითი მთლიანი რიცხვები, დააბრუნეთ ისინი None. მაგალითები: ყველაზე დიდი_მცირესი_მთლიანი რიცხვები[2, 4, 1, 3, 5, 7]) == (არ არსებობს, 1) ყველაზე დიდი_მცირესი_მთლიანი რიცხვები (([]) == (არ არსებობს, არც ერთი) ყველაზე დიდი_მცირესი_მთლიანი რიცხვები (([0]) == (არ არსებობს, არც ერთი) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,kat_Geor,python,"
def compare_one(a, b):
    """"""შექმენით ფუნქცია, რომელიც იღებს მთლიან რიცხვებს, ცურავს ან სტრიქონებს, რომლებიც წარმოადგენენ რეალურ რიცხვებს და უბრუნებს უფრო დიდ ცვლადებს მისთვის მოცემული ცვლადის ტიპში. უბრუნებს None, თუ მნიშვნელობები თანაბარია. შენიშვნა: თუ რეალური რიცხვი წარმოდგენილია სტრიქონად, ცურავი წერტილი შეიძლება იყოს . ან , შეადარეთ_ერთი, 2.5) â -> 2.5 შეადარეთ_ერთი, ""2,3"") â -> ""2,3"" შეადარეთ_ერთი, ""5,1"", ""6"") â -> ""6"" შეადარეთ_ერთი, ""1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,kat_Geor,python,"
def is_equal_to_sum_even(n):
    """"""შეაფასეთ, შეიძლება თუ არა მოცემული რიცხვი n დაიწეროს ზუსტად 4 პოზიტიური პარალური რიცხვის ჯამად. მაგალითი არის_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_თანაბარი_სამ_სამ_სამ_სამ_სამ_სამ_სამ_სამ_სამ_სამ_სამ_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს_ს____________________________________________________________________________________________________________""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,kat_Geor,python,"
def special_factorial(n):
    """"""ბრაზილიური ფაქტორიული განისაზღვრება შემდეგნაირად: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! სადაც n > 0 მაგალითად: >>> special_factorial ((4) 288 ფუნქცია მიიღებს მთელ რიცხვს და უნდა დააბრუნოს ამ მთელ რიცხვის სპეციალური ფაქტორიული. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,kat_Geor,python,"
def fix_spaces(text):
    """"""_მსგავსი-3ნის მიხედვით, ყველა სივრცე ჩაანაცვლეთ ქვედა ხაზებით, ხოლო თუ სტრიქონს აქვს 2 ზე მეტი თანმიმდევრული სივრცე, მაშინ ყველა თანმიმდევრული სივრცე ჩაანაცვლეთ - fix_spaces ((""მსგავსი"") == ""მსგავსი"" fix_spaces ((""მსგავსი1"") == ""მსგავსი_1"" fix_spaces (((""მსგავსი2"") == ""_მსგავსი_2"" fix_spaces (((""მსგავსი 3"") == ""_მსგავსი-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,kat_Geor,python,"
def file_name_check(file_name):
    """"""შექმენით ფუნქცია, რომელიც იღებს სტრიქონს, რომელიც წარმოადგენს ფაილის სახელს და აბრუნებს ""დიახ"", თუ ფაილის სახელი ძალაშია, და აბრუნებს ""არა"", სხვა შემთხვევაში. ფაილის სახელი ითვლება ძალაში თუ და მხოლოდ თუ ყველა შემდეგი პირობა შესრულებულია: - ფაილის სახელში არ უნდა იყოს სამ ციფრზე მეტი ('0'-'9') - ფაილის სახელი შეიცავს ზუსტად ერთ წერტილს '.' - ქვესტრიქონს წერტილის წინ არ უნდა იყოს ცარიელი და ის იწყება ლათინური ასოების ასოთი ('a'-'z' და 'A'Z'). - ქვესტრიქონს წერტილის შემდეგ უნდა იყოს ერთ-ერთი ასეთი: ['txt', 'exe', 'll'd'] მაგალითები: file_name_check""{(example.txt"") # => 'დიახ' file_name_check""{{example.txt1}) => 'არა' (# სახელი უნდა იწყებოდეს ლათინური ასოთი)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,kat_Geor,python,"


def sum_squares(lst):
    """""""" ეს ფუნქცია მიიღებს მთლიანი რიცხვების სიას. ყველა ჩანაწერისთვის, ფუნქცია აყენებს კვადრატში მთლიანი რიცხვის ჩანაწერს, თუ მისი ინდექსი არის 3-ის მრავლობითი და კუბურდება მთლიანი რიცხვის ჩანაწერს, თუ მისი ინდექსი არის 4-ის მრავლობითი და არა 3-ის მრავლობითი. ფუნქცია არ შეცვლის ჩანაწერებს სიაში, რომელთა ინდექსები არ არის 3-ის ან 4-ის მრავლობითი. ფუნქცია შემდეგ დააბრუნებს ყველა ჩანაწერის ჯამს. მაგალითები: lst = [1,2,3] გამოსავალი უნდა იყოს 6 lst = [] გამოსავალი უნდა იყოს 0 lst = [-1,-5,2,-1,-5] გამოსავალი უნდა იყოს -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,kat_Geor,python,"
def words_in_sentence(sentence):
    """"""თქვენ გაქვთ სტრიქონი, რომელიც წარმოადგენს წინადადებას, წინადადება შეიცავს რამდენიმე სიტყვას, რომლებიც განცალკევებულია სივრცით და თქვენ უნდა დააბრუნოთ სტრიქონი, რომელიც შეიცავს ორიგინალური წინადადების სიტყვებს, რომელთა სიგრძე არის პირველადი რიცხვები, ახალი სტრიქონის სიტყვების თანმიმდევრულობა უნდა იყოს იგივე, რაც ორიგინალური. მაგალითი1: შესავალი: წინადადება = ""ეს არის ტესტი"" გამოსავალი: ""ეს არის"" მაგალითი2: შესავალი: წინადადება = ""გავუშვებთ ცურვაზე"" გამოსავალი: ""წადი"" შეზღუდვები: * 1 <= len(sentence) <= 100 * წინადადება შეიცავს მხოლოდ ასოებს """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,kat_Geor,python,"
def simplify(x, n):
    """"""თქვენი ამოცანაა განახორციელოთ ფუნქცია, რომელიც გამარტივებს გამოხატვას x * n. ფუნქცია დააბრუნებს True თუ x * n აფასებს მთელ რიცხვს და False სხვა შემთხვევაში. ორივე x და n, არის წილების სიმებიანი წარმოდგენა და აქვს შემდეგი ფორმატი, <numerator>/<denominator> სადაც ორივე მრიცხველი და მნიშვნელი არის დადებითი მთლიანი რიცხვები. თქვენ შეგიძლიათ ვივარაუდოთ, რომ x და n არის ვალიდური წილები და არ აქვთ ნული მნიშვნელად. გამარტივება:""""""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,kat_Geor,python,"
def order_by_points(nums):
    """"""დაწერეთ ფუნქცია, რომელიც მთელი რიცხვების მოცემულ სიას ასაწესრიგებს მათი ციფრების ჯამის მიხედვით. შენიშვნა: თუ არსებობს რამდენიმე ელემენტი, რომელთა ციფრების თანაბარი ჯამი, დაალაგეთ ისინი ორიგინალურ სიაში მათი ინდექსის მიხედვით. მაგალითად: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,kat_Geor,python,"
def specialFilter(nums):
    """"""დაწერეთ ფუნქცია, რომელიც იღებს ციფრების მასივს და აბრუნებს მასივის იმ ელემენტების რაოდენობას, რომლებიც მეტია 10-ზე და რიცხვის პირველი და ბოლო ციფრები უცნაურია (1, 3, 5, 7, 9). მაგალითად: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,kat_Geor,python,"
def get_max_triples(n):
    """"""თქვენ გაქვთ დადებითი მთელი რიცხვი n. თქვენ უნდა შექმნათ მთელი რიცხვების მასივი სიგრძე n-ის. თითოეული i-სთვის (1 ‰¤ i ‰¤ n), a[i] = i * i - i + 1. დააბრუნეთ a-ს სამმაგი (a[i], a[j], a[k]) რაოდენობა, სადაც i < j < k, და a[i] + a[j] + a[k] არის 3-ის მრავლობითი. მაგალითი: შესავალი: n = 5 გამოსავალი: 1 ახსნა: a = [1, 3, 7, 13, 21] ერთადერთი დასაშვები სამმაგი არის (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,kat_Geor,python,"
def bf(planet1, planet2):
    '''ჩვენს მზის სისტემაში არის რვა პლანეტა: მზესთან ყველაზე ახლოს მდებარეობს მერკური, შემდეგ ვენერა, შემდეგ დედამიწა, მარსი, იუპიტერი, სატურნი, ურანი, ნეპტუნი. დაწერეთ ფუნქცია, რომელიც ორი პლანეტის სახელებს იღებს როგორც სტრიქონებს პლანეტა1 და პლანეტა2. ფუნქციამ უნდა დააბრუნოს ტუპლი, რომელიც შეიცავს ყველა პლანეტას, რომელთა ორბიტები მდებარეობს პლანეტა1 ორბიტასა და პლანეტა2 ორბიტას შორის, მზესთან სიახლოვის მიხედვით. ფუნქციამ უნდა დააბრუნოს ცარიელი ტუპლი, თუ პლანეტა1 ან პლანეტა2 არ არის სწორად დასახელებული პლანეტები. მაგალითები bf""(იუპიტერი"", ""ნეპტუნი"") ==> (""სატურნი"", ""ურანუსი"") bf((""დედამიწა"", ""მერკური"") ==> (""ვენერა"", ""დედამიწა"", ""მარსი"", ""იუპიტერი"", ""სატურნი"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,kat_Geor,python,"
def sorted_list_sum(lst):
    """"""დაწერეთ ფუნქცია, რომელიც იღებს სტრიქონების სიას პარამეტრად, წაშლის სტრიქონებს, რომლებსაც აქვთ უცნაური სიგრძე და აბრუნებს შედეგად მიღებულ სიას დახარისხებული თანმიმდევრობით. სია ყოველთვის არის სტრიქონების სია და არასოდეს რიცხვების მასივი და შეიძლება შეიცავდეს დუბლირებულებს. სიის თანმიმდევრობით უნდა იყოს აღმავალი თითოეული სიტყვის სიგრძე და თქვენ უნდა დააბრუნოთ სია დახარისხებული ამ წესით. თუ ორი სიტყვა აქვს იგივე სიგრძე, დახარისხეთ სია ანბანური წესით. ფუნქცია უნდა დააბრუნოს სტრიქონების სია დახარისხებული თანმიმდევრობით. თქვენ შეიძლება ვივარაუდოთ, რომ ყველა სიტყვა იქნება იგივე სიგრძე. მაგალითად: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""aaaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,kat_Geor,python,"
def x_or_y(n, x, y):
    """"""მარტივი პროგრამა, რომელიც უნდა დააბრუნოს x-ის მნიშვნელობა, თუ n არის მარტივი რიცხვი და უნდა დააბრუნოს y-ის მნიშვნელობა სხვა შემთხვევაში. მაგალითები: x_or_y(7, 34, 12) == 34 x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,kat_Geor,python,"
def double_the_difference(lst):
    '''რიცხვების ჩამონათვალი, დააბრუნეთ რიცხვების კვადრატების ჯამი, რომლებიც უცნაურია. უგულებელყოთ ნეგატიური ან არამთლიანი რიცხვები. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 თუ შეყვანილი სია ცარიელია, დააბრუნეთ 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,kat_Geor,python,"
def compare(game,guess):
    """"""ვფიქრობ, ყველას გვახსოვს ეს განცდა, როდესაც დიდი ხნის განმავლობაში მოლოდინში მყოფი მოვლენის შედეგი საბოლოოდ ცნობილია. იმ მომენტში თქვენ განცდები და აზრები ნამდვილად ღირს აღწერა და შედარება. თქვენი ამოცანაა განსაზღვროთ, სწორად გამოიცნო თუ არა ადამიანმა რამდენიმე მატჩის შედეგები. თქვენ გაქვთ ორი მატჩი ქულებისა და ვარაუდების თანაბარი სიგრძის, სადაც თითოეული ინდექსი აჩვენებს მატჩს. დააბრუნეთ იგივე სიგრძის მატჩი, რომელიც აღნიშნავს, თუ რამდენად შორს იყო თითოეული ვარაუდი. თუ ისინი სწორად ივარაუდებდნენ, მნიშვნელობა არის 0, ხოლო თუ არა, მნიშვნელობა არის აბსოლუტური განსხვავება ვარაუდსა და ქულას შორის. მაგალითი: (([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3] compare (([0,5,0,0,4],[4,1,0,-2]) -> [4,0,1,0,6] """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,kat_Geor,python,"
def Strongest_Extension(class_name, extensions):
    """"""თქვენ მიიღებთ კლასის სახელს (სტრინგს) და გაფართოებების სიას. გაფართოებები უნდა გამოიყენოთ კლასში დამატებითი კლასების ჩატვირთვისთვის. გაფართოების სიძლიერე შემდეგია: CAP იყოს გაფართოების სახელის დიდი ასოების რაოდენობა, ხოლო SM იყოს გაფართოების სახელის მცირე ასოების რაოდენობა, სიძლიერე მოცემულია CAP - SM ფრაქციით. თქვენ უნდა იპოვოთ ყველაზე ძლიერი გაფართოება და დააბრუნოთ სტრიngi ამ ფორმატში: ClassName.StrongestExtensionName. თუ არსებობს ორი ან მეტი გაფართოება ერთი სიძლიერით, თქვენ უნდა აირჩიოთ ის, რომელიც პირველ ადგილზეა სიაში. მაგალითად, თუ თქვენ გაქვთ ""Slices"" კლასის სახით და გაფართოებების სია: ['SEviRNGLISCes', 'Cheese', 'StuFfed'], მაშინ თქვენ უნდა დააბრუნოთ 'Slices.SEviRNGLISCes' და 'SviRNGLISCes' ჩემი გაფართოების სახელია, სიძლიერე მოცემულია ფრაქცია CAP - SM. თქვენ უნდა იპოვოთ ყველაზე ძლიერი გაფართოება და და დააბრუნდეთ სტრიგს ამ ფორმატში: ClassName.StrongestExtensionName.StrongestExtensionName.If there are two or more extensions with the same strength of the same class (a) and a list of extensions, you will be given the name of the class (a list of the extension. For example, you will be given the name of the class and the extension: ['Slice'Slice'Slice'Slice'Slice'Slice'Slice'Slice'Slice'Slice'Slice'Slice'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'S'""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,kat_Geor,python,"
def cycpattern_check(a , b):
    """"""თქვენ გაქვთ 2 სიტყვა. თქვენ უნდა დააბრუნოთ True, თუ მეორე სიტყვა ან მისი რომელიმე როტაცია არის ქვესტრინგი პირველ სიტყვაში cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,kat_Geor,python,"
def even_odd_count(num):
    """"""მოცემულია მთელი რიცხვი. დააბრუნებს ტუპლს, რომელსაც აქვს თანაბარი და უცნაური ციფრების რაოდენობა. მაგალითი: თანაბარი_ უცნაური_ რიცხვი ((-12) ==> (1, 1) თანაბარი_ უცნაური_ რიცხვი ((123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,kat_Geor,python,"
def int_to_mini_roman(number):
    """"""დადებითი მთელი რიცხვის მიხედვით, მიიღეთ მისი რომაული რიცხვითი ექვივალენტი სტრიქნგის სახით და დააბრუნეთ ის მცირე ასოებით. შეზღუდვები: 1 <= num <= 1000 მაგალითები: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,kat_Geor,python,"
def right_angle_triangle(a, b, c):
    '''სამკუთხედის სამი მხარის სიგრძე. დააბრუნეთ True, თუ სამი მხარე წარმოადგენს სწორკუთხა სამკუთხედს, False სხვა შემთხვევაში. სწორკუთხა სამკუთხედი არის სამკუთხედი, რომელშიც ერთი კუთხე სწორკუთხეა ან 90 გრადუსი. მაგალითი: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,kat_Geor,python,"
def find_max(words):
    """"""დაწერეთ ფუნქცია, რომელიც იღებს სტრიქონების სიას. სია შეიცავს სხვადასხვა სიტყვებს. დააბრუნეთ სიტყვა უნიკალური სიმბოლოების მაქსიმალური რაოდენობით. თუ მრავალ სტრიქონს აქვს უნიკალური სიმბოლოების მაქსიმალური რაოდენობა, დააბრუნეთ ის, რომელიც პირველია ლექსიკოგრაფიული თანმიმდევრობით. find_max (([""სახელი"", ""of"", ""string""]) == ""string"" find_max (([""სახელი"", ""enam"", ""თამაში""]) == ""enam"" find_max (([""aaaaaaa"", ""bb"" , ""cc""]) == """"aaaaaaaaaa"" """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,kat_Geor,python,"
def eat(number, need, remaining):
    """"""თქვენ ხართ მშიერი კურდღელი და უკვე შეჭამეთ გარკვეული რაოდენობის კენკრა, მაგრამ ახლა თქვენ უნდა ჭამოთ მეტი კენკრა, რათა დაასრულოთ დღის კვება. თქვენ უნდა დააბრუნოთ მასივი [მთლიანი რაოდენობა ჭამეს კენკრა თქვენი კვება, რაოდენობა კენკრა დარჩა თქვენი კვება ] თუ არ არის საკმარისი დარჩენილი კენკრა, თქვენ შეჭამოს ყველა დარჩენილი კენკრა, მაგრამ მაინც იქნება მშიერი. მაგალითი: * ჭამა ((5, 6, 10) -> [11, 4] * ჭამა ((4, 8, 9) -> [12, 1] * ჭამა ((1, 10, 10) -> [11, 0] * ჭამა ((2, 11, 5) -> [7, 0] ცვლადი: @number: მთელი რაოდენობის კენკრა, რომ თქვენ ჭამა. @need: მთელი რაოდენობის კენკრა, რომ თქვენ უნდა ჭამა. @remaining: მთელი რაოდენობის კენკრა დარჩენილი რაოდენობა, რომ არსებობს საფონდო კონტრას: * 0 = <= 1000 * 0 = <= 1000 * 0 = <= 1000 დარჩენილი რაოდენობა""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,kat_Geor,python,"
def do_algebra(operator, operand):
    """"""მოცემულია ორი ოპერატორის სია და ოპერანდი. პირველ სიაში არის ელეგანტური ალგებრული ოპერაციები, ხოლო მეორე სიაში არის მთელი რიცხვების სია. გამოიყენეთ ორი მოცემული სია ალგებრული გამოთქმის შესაქმნელად და ამ გამოთქმის შეფასების დასაბრუნებლად. ელეგანტური ალგებრული ოპერაციები: დამატება ( +) გამოკლება ( -) გამრავლება ( *) იატაკის გაყოფა ( //) ექსპონენტაცია ( ** მაგალითი) ოპერატორი['+', '*', '-'] მასივი = [2, 3, 4, 5] შედეგი = 2 + 3 * 4 - 5 => შედეგი = 9 შენიშვნა: ოპერატორების სიის სიგრძე ტოლია ოპერანდის სიის სიგრძეს მინუს ერთი. ოპერანდი არის ნეგატიური მთლიანი რიცხვების სია. ოპერატორს აქვს მინიმუმ ერთი ოპერატორი, ხოლო ოპერანდს აქვს მინიმუმ ორი ოპერანდი. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,kat_Geor,python,"
def solve(s):
    """"""თქვენ გაქვთ სტრიქონის s. თუ s[i] არის ასო, გადააბრუნეთ მისი კეისი ქვემოდან ზედა ან პირიქით, სხვა შემთხვევაში შეინახეთ იგი. თუ სტრიქონში არ არის ასოები, გადააბრუნეთ სტრიქონი. ფუნქცია უნდა დააბრუნოს შედეგად მიღებული სტრიქონი. მაგალითები solve(""1234"") = ""4321"" solve(""ab"") = ""AB"" solve(""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,kat_Geor,python,"
def string_to_md5(text):
    """"""მოცემული სტრიქონის 'text', დაბრუნება მისი md5 ჰეშის ექვივალენტური სტრიქონის. თუ 'text' არის ცარიელი სტრიქონის, დაბრუნება None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,kat_Geor,python,"
def generate_integers(a, b):
    """"""მოცემულია ორი დადებითი მთელი რიცხვი a და b, დააბრუნეთ თანაბარი ციფრები a და b შორის, მზარდი თანმიმდევრობით. მაგალითად: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
