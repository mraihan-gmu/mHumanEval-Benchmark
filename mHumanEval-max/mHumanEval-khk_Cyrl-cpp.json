[
    {
        "task_id": "HumanEval/0",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Даанчсан векторт өгөгдсөн цэгээс илүү ойр хоёр тоо байгаа эсэхийг шалгаарай. >>> has_close_elements (((std::vector<float> ((({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f)) (хуультай) >>> has_close_elements (((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f)) (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ функцын нэвтрүүлэг нь олон бүлэгтэй нягт дугаараар тохирсон нягт юм. Та эдгээр бүлэгүүдийг тусдаа нягт дугаараар хувааж, тэдгээрийн вектор буцаах зорилготой. Тус тусдаа бүлэгүүд тэнцвэртэй (хүн бүрийн нээлттэй нягт дугаараар зөвөөр хаагдсан) бөгөөд бие биендээ нягтлан байгуулсангүй.\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Эерэг давхаргатай цэгт тоо өгвөл, энэ нь бүтэн тооны хэсэг (үлсэлтийн тооноос жижиг) болон арванхоёрдугаар хэсэгт (ашигласан хэсэг нь үргэлж 1-ээс жижиг) хуваагдана. >>> truncate_number((3.5f)) (0.5f)\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та банкны дансанд 0-ээс эхлэх хадгаламж, хураамжийн үйл ажиллагааны вектор авна. Таны ажил нь ямар нэг цэгт дансны тэнцвэр 0-ээс доош унасан эсэхийг илрүүлэх бөгөөд энэ үед функц нь үнэн гэж буцаана. Үгүй бол энэ нь худал гэж буцана. >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero(std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Мэдээллийн нэрийн өгөгдлийн векторын хувьд энэ өгөгдлийн багцын дундаж дүнгээс дундаж дундаж дундаж дундаж дундаж дундаж дундаж дундаж дундаж дундаж нь нь элемент бүрийн төв цэг (Энэ тохиолдолд дундаж): MAD = ≈ x - x_mean ≈ >>> mean_absolute_deviation (((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Гүйцэтгэх вектор `numbers' >>> intersperse (((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse (((std::vector<long>({(long) 1, (long) 2, (long) 3})), (4)) (std::vector<long>({(long) 1, (long) 4, (long) 2, (long) 4, (long) 3}) хооронд дараалан гарч буй хоёр элементийн хооронд \"delimeter\" тоог оруулна.\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ функц нь хооронд нь хуваагдсан нягт дугуйлуудын олон бүлгийг илэрхийлсэн суваг юм. Багийн бүрээс нягт дугуйлуудын хамгийн гүнзгий түвшинг гаргана. Жишээ нь (() (()) нь хамгийн ихдээ хоёр түвшинтэй бол ((())) нь гурван байна. >>> parse_nested_parens (((\"((()) ((())) () ((()))))) (std:: vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Зөвхөн өгөгдсөн дэд шугамтай string-ийн нэвтрэх вектор нь filter_by_substring (((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_substring ((((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) abc\", (std::string) \"bacd\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой бүтэн тооны векторд бүх бүтэн тооны нийлбэр болон үржүүлбэрээс бүрдэх цуврал буцаана. Хугацаа 0 байх ёстой, хоосон үржүүлбэр нь 1 байх ёстой. >>> sum_product((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой бүтэн тооны векторээс дараалалд тодорхой цаг хүртэл олсон хамгийн их элементийн вектор үүсгэнэ. >>> rolling_max((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Аливаа өгөгдсөн үсгийн хамгийн богино палиндромыг олох. Алгоритмын санаа нь энгийн: - Өргөдсөн үсгийн хамгийн урт палиндром болох дараах үсгийн дараах үсгийн дараах үсгийн дараах үсгийн дараах үсгийн дараах үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үсгийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн үрийн\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Ашиглалтын үр дүн нь зөвхөн 1 болон 0-ээс бүрддэг a, b хоёр үсгийн үр дүн юм. Эдгээр үсгийн дээр хос XOR гүйцэтгэж үр дүнг нь үсгийн үр дүнгээр буцаана. >>> string_xor((\"010\"), (\"110\")) (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Шүлгийн векторээс хамгийн урт нь эргүүлнэ. Нэг урттай хэд хэдэн үсгийн тохиолдолд эхнийх нь эргүүлнэ. Нэвтрэх вектор хоосон тохиолдолд үгүйг эргүүлнэ. >>> longest(((std:: vector<std::string>())) std::nullopt >>> longest(((std:: vector<std::string>{(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) \"a\" >>> longest(((std:: vector<std::string>({(std::string) \"a\", (std::string) \"bb\", (stdstring) \"ccc\"}))) \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хоёр бүтэн тоо a, b-ийн хамгийн том нийт хуваагчдыг буцаах >>> хамгийн том_ нийт_ хуваагч (((3), (5)) (1) >>> хамгийн том_ нийт_ хуваагч (((25), (15)) (5)\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Эргэн орох string-ийн хамгийн богинононоос хамгийн урт хүртэлх бүх prefix-ийн буцаах вектор >>> all_prefixes (((\"abc\")) (std:: vector<std::string>({(std::string) \"a\", (std::string) \"ab\", (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 0-аас n хүртэлх орон зайгаар хязгаарлагдсан тоонуудыг агуулсан string-г буцаана. >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэг үсгийн тоог авч үзвэл, хэдэн өөр өөр тэмдэгт (хууль нь ямар ч байсан) >>> count_distinct_characters (((\"xyzXYZ\")) (3) >>> count_distinct_characters (((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ функц нь ASCII форматтай хөгжмийн тэмдэгтүүдийг илэрхийлэх суваг юм. Таны хийх ажил бол олон цохилттой нийцсэн бүтэн тооны суваг векторг шинжилгээ хийх юм. Энд тайлбар бичигдсэн байна: 'o' note, lasts four beats 'o,r' - lasts half note, lasts two beats 'r' - lasts quater note, lasts one beat >>> parse_music. (o) o,r' - lasts four beats 'o,r' - lasts half note, lasts two beats 'r' - lasts quater note, lasts one beat >>> parse_music. (o) o,r' - lasts four beats 'o,r' - lasts half note, lasts two beats 'r' - lasts one beat >>> parse_music. (o) o,r' - lasts four beats 'o,r' - lasts two beats 'r' - lasts four beats 'r' - lasts half note, lasts two beats 'r' - lasts four beats 'r' - lasts one beat >>> parse_music. (o,r' - lasts four beats) - last one beat >>> parse_music.\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Эхний дугаарт өгөгдсөн дэд дугаарыг хэдэн удаа олж болох талаар хайж олох. Хаацалсан тохиолдлуудыг тоол. >>> how_many_times((\"\"), (\"a\")) (0) >>> how_many_times(\"aaa\"), (\"a\")) (3) >>> how_many_times(\"aaaa\"), (\"aa\") (3)\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Оролцох нь \"нуль\" -ээс \"хоёр\" хүртэлх тооны орон зайтай бүлэг юм. \"нуль\", \"нэг\", \"хоёр\", \"үч\", \"хоёр\", \"биш\", \"шүүн\", \"хоёр\", \"хоёр\", \"эмэг\" болон \"хоёр\" нь хүчин төгөлдөр сонголт юм. Хамгийн багаас хамгийн том хүртэл дараалсан тоотой бүлэг буцаах >>> sort_numbers((\"three one five\")) (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхойлосон тооны вектор (илүү нь хамгийн багадаа хоёр) -аас хамгийн ойрхон хоёр элементийг сонгож, дарааллаар (хөөрхөн тоо, том тоо) буцааж өгнө. >>> find_closest_elements (хөөрхөн тоо, том тоо)\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэдэн тооны вектор (өөрөөр хэлбэл, хамгийн бага нь 0 болж, хамгийн том нь 1 болохын тулд энэ векторт хязгаарлагдмал өөрчлөлт хий. >>> rescale_to_unit (хэдэн тооны вектор нь 0 болж, хамгийн том нь 1 болохын тулд энэ векторт хязгаарлагдмал өөрчлөлт хий.)\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers >>> filter_integers((std::vector<std::any>({(std::string) \"a\", (std::string)3.14f, (std::string)5}))) (std::vector<long>({(long)5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// өгөгдсөн string-ийн урт >>> string_length((\"\")) (0) >>> string_length((\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэгийг тэгш хуваадаг хамгийн том тоог n-ээс бага тоог олох >>> largest_divisor (((15)) (5)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Даанч өгөгдсөн бүтэн тооны анхны хүчин зүйлсийн вектор нь хамгийн багаас хамгийн том хүртэлх дарааллаар буцаах. Оролцогч бүр нь оруулахдаа хэдэн удаа гарч ирснийг нь төлөөлөн хэд хэдэн удаа векторлах ёстой. Оролцох тоо нь бүх хүчин зүйлсийн үр дүнтэй тэнцүү байх ёстой >>> оруулах ((8)) (std:: vector<long>({(long) 2, (long) 2, (long) 2})) >>> оруулах ((25)) (std:: vector<long>({(long) 5, (long) 5})) >>> оруулах ((((70)) (std:: vector<long>({(long) 2, (long) 5, (long) 7}))\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой тооны вектор дээр нэгээс илүү удаа гарч байгаа бүх элементийг устга. Элементүүдийн дарааллыг оруулсан хэвээр үлдээ. >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Жич дээр жижиг үсгийг том, том үсгийг жижиг үсгээр эргүүлнэ. >>> flip_case (((\"Hello\")) (\"hELLO\")\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Шүлгийн вектор нэг шугамд нэгтгэх >>> нэгтгэх ((((std:: vector<std::string>())) (\"\") >>> нэгтгэх (((std:: vector<std::string>({(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Зөвхөн өгөгдсөн өмнөх тэмдэгтээр эхлэх string-ийн нэвтрэх vector-ийг филтрлэнэ. >>> filter_by_prefix((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string) \"cde\", (stdstring) \"array\"})), (\"a\") (std::vector<std::string>({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Зөвхөн вектор дахь эерэг тоонуудыг буцаана. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive(((std::vector<long>({(long) -5, (long) -3, (long) -5, (long) -2, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Даанч тоо нь нэгдүгээр тоо бол true, бусад тохиолдолд false өгнө. >>> нэгдүгээр тоо бол true (тэг) (тэггүй) >>> нэгдүгээр тоо бол prime (тэггүй) (тэггүй) (тэггүй) (тэггүй) (тэггүй) (тэггүй)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ функц нь l вектор авч, l' векторг эргүүлнэ. Энэ нь l' нь 3 дээр хуваагдахгүй гэсэн индексүүд дээр l-тэй ижил байх бөгөөд 3 дээр хуваагдашгүй гэсэн индексүүд дээр түүний үнэ цэнэ нь l-ийн тухайн индексийн үнэ цэнэтэй тэнцүү боловч ангилагдсан байна. >>> sort_third((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Төгсөгчд эерэг дараалсан элементүүдийг буцаана >>> unique((std:: vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) (std:: vector<long>{(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Векторын хамгийн их элементийг буцаана. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) - 10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 7 гэсэн тоог 11 эсвэл 13-д хуваагдах n-ээс бага бүхэл тооны дугаарыг буцаана. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ функц нь l вектор авч, l' векторг тэгш индексүүд дээр нь ижил байх үед л нь тэгш индексүүд дээр нь тэгш индексүүд дээр нь ижил байх үед нь эргүүлнэ. >>> sort_even: vector<long>{(long) 1, (long) 2, (long) 3}))) (std: vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even: vector<(std: vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std: vector<((long>{(long) 3, (long) 6, (long) 5, (long) 4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib нь Fibonacci тоо бөгөөд энэ нь мөн анхны тоо юм. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib(3)) (5) >>> prime_fib(4)) (13) >>> prime_fib(5)) (89)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero нь бүтэн тооны векторг оруулсан болно. Хэрэв векторт 0-д нийлсэн гурван өөр элемент байгаа бол үнэн, өөр тохиолдолд худал өгөгддөг. >>> triples_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triples_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long)-2, (long) 1} >>> (true) triples_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) >>> triples_sum_to_zero_((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Зам нь төгс тэгш, хязгааргүй урт шугам гэж бодъё. n машин зүүнээс баруун руу явж байна. Нөгөөтэйгүүр, n машин баруун зүүн рүү явж байна. Хоёр баг нь бие биенээсээ маш хол яваад эхэлж байна. Бүх машин ижил хурдтай явж байна. Зүүнээс баруун руу явж байгаа машин баруун зүүн рүү явж байгаа машиныг цохих үед хоёр машин мөргөлдөж байна гэж үздэг. Гэсэн хэдий ч машин нь хязгааргүй бат бөх бөгөөд хүчтэй байдаг. Үүний үр дүнд тэд мөргөлдөж байгаагүй мэт замдаа үргэлжлэн хөдөлгөөнд ордог. Энэ функц нь ийм мөргөлдөөн тохиолдсон тоог гаргадаг.\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Элементүүд нь 1 -ээр нэмэгдсэн эргэлтийн вектор >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero нь бүтэн тооны векторг оруулсан болно. Энэ нь векторт хоёр өөр өөр элемент 0-д нийлэх бол үнэн, эсвэл буруу гэж өгөгддөг. >>> pairs_sum_to_zero(std:: vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std:: vector<long>({long) 1, (long) 3, (long)-2, (long) 1} >>> (false) pairs_sum_to_zero(std:: vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero_{(long>{(long>{(long>{(long>{long>{long>{long>} (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэвлэх тооны x-ийн тооны суурийг суурийг өөрчлөх. хөрвүүлсний дараа үсгийн төлөөллийг буцаах. суурины тоо 10-аас бага. >>> change_base((8), (3)) (\"22\") >>> change_base(8), (2)) (\"1000\") >>> change_base((7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Гурван талын талбайн урт, өндөр эргэлтийн талбайг өгвөл. >>> triangle_area((5), (3)) (7.5f)\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Fib4 тооны дарааллын дараалал нь Fibbonacci дарааллын нэгэн адил дараалал юм. Энэ дарааллыг дараах байдлаар тодорхойлдог: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4 тооны дарааллын n-р элементийг үр ашигтай тооцох функцийг бичих. Рекурсийг ашиглахгүй. >>> fib4((5)) (4) >>> fib4((6)) (8) >>> fib4((7)) (14)\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Вектор l-ийн элементийн эргэн ирцэд орсон медиан. >>> медиан((std:: vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (float(3) >>> медиан((std:: vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Даанхүү string нь palindrome >>> is_palindrome (((\"\")) (true) >>> is_palindrome (((\"aba\")) (true) >>> is_palindrome (((\"aaaaa\")) (true) >>> is_palindrome (((\"zbcd\")) (false) эсэхийг шалгана.\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 2^n модуль p (нумбарын талаар мэдлэгтэй байх) -г буцаана. >>> modp((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp(0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels нь үсэггүй үсэгний үсэг авах функц юм. >>> remove_vowels(\"\")) (\"\") >>> remove_vowels(\"abcdef\")) (\"bcdf\") >>> remove_vowels(\"aaaaa\")) (\"\") >>> remove_vowels(\"aaBAA\")) (\"B\") >>> remove_vowels(\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэрэв l вектор дахь бүх тоо нь t хэмжээнээс доош байвал true-г буцаана. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// x, y гэсэн хоёр тоог нэмэх >>> нэмэх (((2), (3)) (5) >>> нэмэх (((5), (7)) (12)\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хоёр үг ижил тэмдэгттэй эсэхийг шалгаарай. >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) (true) >>> same_chars((\"abcd\"), (\"dddddddabc\")) (true) >>> same_chars(\"dddddddabc\"), (\"abcd\") (true) >>> same_chars((\"eabcd\"), (\"dddddddabc\")) (false) same_chars >>>\"(abcd\"), (\"dddddddabce\") (false) >>> same_chars((\"eabcd\"), (\"ddddzzzzzdzzdddabc\") (false)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Фибоначчийн n-р тоог буцаана. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets нь \"<\" ба \">\" гэсэн үсгийн дарааллыг илэрхийлдэг. Хэрэв нээлтээ хийх bracket бүр нь хаалтын bracketтэй байвал true-г буцаана. >>> correct_bracketing((\"<\")) (false) >>> correct_bracketing(\"<>\")) (true) >>> correct_bracketing(\"<><>>\")) (true) >>> correct_bracketing(\">(<>\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// true буцаах нь вектор элементүүд нэгтгэн өсч, буурч байна. >>> нэгтгэн((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> нэгтгэн((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> нэгтгэн((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) - 10}))) (true)\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хоёр векторт зориулсан ангилагдсан хос элементүүдийг буцаана. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653}) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// n-ийн хамгийн том анхны хүчин зүйлсийг буцаана. n > 1 гэж үзвэл тэр нь анхны тоо биш. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n нь 1 - н хүртэлх тоонуудыг нийлүүлэх функц юм. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets нь \"(\" ба \"\") гэсэн дугаар цуврал юм. Хэрэв нээлтээ хийх bracket бүр нь хаалтын bracketтэй байвал true-г буцаана. >>> correct_bracketing((\"(\")) (false) >>> correct_bracketing(\"() \")) (true) >>> correct_bracketing(\"(()))) (true) >>> correct_bracketing((\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs нь олон үсгийн тооцлоор илэрхийлэгддэг. xs[0] + xs[1] * x + xs[2] * x^2 + .... Энэ олон үсгийн тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцлоор тооцло тооцлоор тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцло тооцо тооцо тооцо тооцо тооцо тооцон тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро тооцро\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// FibFib тооны дарааллын дараалал нь Fibbonacci дарааллын дараалалтай төстэй бөгөөд дараах байдлаар тодорхойлогддог: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Үг үгсийг илэрхийлэх үсгийн тоог оруулж, үгийн үсгийн тоог буцаан өгөгддөг функц vowels_count гэж бичих. Энэ тохиолдолд үгийн үсэг нь 'a', 'e', 'i', 'o', 'u' юм. Энд 'y' нь мөн үгийн үсэг боловч энэ нь өгөгдсөн үгийн төгсгөлд байх үед л байдаг. Жишээ нь: >>> vowels_count ((\"abcde\")) (2) >>> vowels_count ((\"ACEDY\") (3)\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Цирклийн хэлбэрээр x бүтэн тооны тоонуудыг шилжүүлж, тоонуудыг шилжүүлэн баруун талд шилжүүлж, үр дүнг нь мөр болгон буцаана. Shift > тоонуудын тоо бол эргээд буцаана. >>> circular_shift (((12), (1)) (\"21\") >>> circular_shift (((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Ажлын хэсэг Гүйцэтгэлийн тооны үсэгг оруулж, зөвхөн дээд тэмдэгтийн ASCII кодыг өгөгддөг функцийг бичих. Жишээ нь: >>> digitSum((\"\")) (0) >>> digitSum((\"abAB\")) (131) >>> digitSum((\"abcCd\")) (67) >>> digitSum((\"helloE\")) (69) >>> digitSum((\"woArBld\")) (131) >>> digitSum((\"aAXaaaa\") (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ даалгаврын хувьд танд жимс жимсгэнэ, ягаан будаа, манго жимсгэнэ бүхий жимсний сав дахь жимс жимсгэнэ, ягаан будаа, манго жимсгэнэ бүхий сав дахь жимс жимсгэнэүүдийн тоог илэрхийлэх дарааллыг өгнө. Жимс жимсгэнэ, ягаан будаа, манго жимсгэнэүүдийн тоог илэрхийлэх дарааллыг өгвөл, сав дахь манго жимсгэнэүүдийн тоог буцаана. жишээ нь: >>> жимс_буулалтын тоо (((((\"ягаан будаа 5\", (19)) (8) >>> жимс_буулалтын тоо (((\"ягаан будаа 10\", (3)) (2) >>> жимс_буулалтын тоо ((((\"ягаан будаа 2\", (100)) (95) >>> жимс_буулалтын тоо (((\"ягаан будаа 100\", (120)) (19)\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Хэрэв нэг цэг нь нэг цэцэрлэг цэгээс бусад бүтэн тооны цэгүүдтэй бол танай ажил нь нэг цэгүүдийг хурааж, буцаах явдал юм. Хураагдсан цэг нь хамгийн бага тэгш үнэтэй цэг байх ёстой. Хэрэв хамгийн бага тэгш үнэтэй олон цэг илэрвэл хамгийн бага индекстэй цэг буцаах ёстой. Хураагдсан цэг нь векторт буцаах ёстой, [ хамгийн бага_ үнэ, түүний индекс ], Хэрэв тэгш үнэ байхгүй бол эсвэл өгөгдсөн вектор хоосон бол буцаах [ ] . Жишээ 1: >>> хураах((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таныг бодитой бүтэн тооны хоосон бус вектор өгөөд байна. Нутаас илүү их, бүтэн тооны үнэ цэнийг давтамжтай хамгийн том бүтэн тоог буцаана. бүтэн тооны давтамж нь бүтэн тооны үнэ цэнийг давтамжтай тэнцүү. Хэрэв ийм үнэ цэнийг байхгүй бол -1-ийг буцаана. Жишээ нь: >>> search: std:: vector<long>{(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search: std:: vector<(long>1, (long) 2, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4} (3)))) >>> std:: vector<(long>{(long) 5, (long) 5, (long) 4, (long) 4, (long) 1} (long) 1)))\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ нь хамгийн бага үнэ цэнэ, дараа нь үлдсэн бүхэл тооны хамгийн их үнэ цэнэ, дараа нь хамгийн бага зэрэг зэрэг нь өгөгдсөн байна. Жишээ нь: >>> strange_sort_list, (long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector, (long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list, (long) 5, (long) 5, (long) 5}))) (std::vector, (long) 5, (long) 5} (std::vector, (long) 5}) >>> strange_sort_list, (long) 5, (long) 5, (long) 5} (std::vector, (long) 5})\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Гурван талын гурван талын урт нь өгүүлнэ. Гурван талын 3 талын үр дүн нь гурав дахь талын үр дүнгээс их бол гурван талын тал нь 2 арванхоёрдугаар байранд хүрээлэгдсэн талбайг буцаана. Үгүй бол -1 буцаана. Гурван талын үр дүн нь гурав дахь талын үр дүнгээс их бол гурван талын үр дүнг бий болгоно. Жишээ нь: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэрэв q объект нисэх бол үнэн, өөр тохиолдолд худал өгөгдсөн функцийг бичих. q объект тэнцвэртэй (ул бол палиндром вектор) бөгөөд түүний элементүүдийн нийлбэр нь хамгийн их жинтэй тэнцэх эсвэл бага байвал нисэх болно. Жишээ нь: >>> will_it_fly((std:: vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2 нь хамгийн их жинтэй тэнцэхээс бага боловч тэнцвэргүй. >>> will_it_fly((stdvector<long>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой тооны ар арьст өгүүлбэрт, вектор нь палиндром болохын тулд өөрчлөх шаардлагатай элементийн хамгийн бага тоог олох. Палиндром вектор бол эргээд болон урагш нь ижил уншдаг вектор юм. Нэг өөрчлөлтийн үеэр та аль ч элементээр өөрчлөх боломжтой. Жишээ нь: >>> smallest_change(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1} (1) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 1, (long) (0))))\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой тооны вектор хүлээн авч, бусад вектортой харьцуулахад бага тооны вектор эргүүлнэ. Хэрэв хоёр вектор ижил тооны вектортой бол эхний вектор эргүүлнэ. Жишээ нь >>> total_match (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)), (тэдэв: vector (тэдэв: vector)) (тэдэв: vector (тэдэв: vector)) (тэдэв: vector (тэдэв: vector)) (тэдэв: vector (тэдэв: vector)) (тэдэв: vector (тэв: vector)) (тэв: vector (тэв: vector)) (тэвтэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (тэх) (\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэрэв өгөгдсөн тоо нь 3 үндсэн тооны үржүүлэлт бол үнэн, өөр тохиолдолд худал гэсэн функцийг бичих. (а) нь 100-аас бага гэдгийг мэдэж байна. Жишээ нь: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таны хийх ажил нь x тоо нь n-ийн энгийн хүчтэй, бусад тохиолдолд худал бол үнэн гэсэн функцийг бичих юм. x нь n-ийн энгийн хүчтэй бол n**int=x Жишээ нь: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ нь бүтэн тооны a тоог авч, энэ тоо нь ямар нэг бүтэн тооны куб бол true гэсэн функцийг бичнэ. Та өгөгдсөн тоо нь үргэлж хүчин төгөлдөр гэж үзэж болно. Жишээ нь: >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180)) (false)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та нар хэсэг тоон тоог цуврал хэлбэрээр хүлээн авч, хэсэг тоон тооны тоог тооцдог функцийг бичих үүрэг хүлээсэн байна. (Тэгвэл, нэг тоон тоо нь 1ээс илүү их, хоёр жижиг тоон тооны үр дүн биш байгалийн тоо юм). Хэсэг тоон тоо нь 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Тоон тоо нь 2, 3, 5, 7, 11, 13, 17,... Тиймээс та дараах тоон тоонуудын тоог тодорхойлох хэрэгтэй: 2, 3, 5, 7, B (= арван тоон тоон 11), D (= арван тоон тоон 13). Эскертүү: та нар нэвтрүүлэг нь үргэлж зөв эсвэл хоосон байх бөгөөд A,B,C,D,E,F, тэмдэгтүүд нь үргэлж том үсэгтэй байдаг. Жишээ нь: >>> hex_(AB\"key\") >>> hex_(AB\"key\") (1) >>> hex_(((10\"E77\") (2) hex_\" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таныг арванхоёрдугаар хэлбэрээр тоо өгч, түүнийг хоёрдугаар хэлбэрт хөрвүүлэх үүрэг өгнө. Функц нь нэг үсэг цуврал буцааж өгөх ёстой бөгөөд үсэг бүр хоёрдугаар тоог илэрхийлнэ. Үсэг цуврал нь '0' эсвэл '1' байх болно. Үсэг цуврал эхэнд болон төгсгөлд нэмэлт хос 'db' байх болно. Үүнээс гадна үсэгүүд нь хэлбэрт туслах болно. Жишээ нь: >>> decimal_to_binary((15)) (\"db1111db\") >>> decimal_to_binary(32) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таныг s гэж нэрлэсэн string-ийг өгнө. Таны хийх ажил нь string-ийг hapcpp эсэхийг шалгах явдал юм. string нь хамгийн багадаа 3 болон дараалан 3 үсэгтэй бол hapcpp гэж нэрлэгддэг. Жишээ нь: >>> is_happy(\"a\")) (false) >>> is_happy(\"aa\")) (false) >>> is_happy(\"abcd\")) (true) >>> is_happy(\"aabb\")) (false) >>> is_happy(\"adb\")) (true) >>> is_happy(\"xyy\") (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ бол улирлын сүүлийн долоо хоног бөгөөд багш нь сурагчдад үнэлгээ өгөх ёстой. Багш нь үнэлгээ өгөх өөрийн алгоритмыг хийж байна. Зөвхөн нэг асуудал нь, тэр үнэлгээ өгөх код нь алга болсон байна. Тэр танд зарим сурагчдын GPA-ийн вектор өгөөд байна, та дараах хүснэгтийг ашиглан захидал үнэлгээний вектор гаргах боломжтой функцийг бичих хэрэгтэй: GPA. Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E Жишээ нь: >>>_grade equation: (((std:: vector<float>{(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f))) (std vector::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::string: \"std\"d (Astring) (string) (Astring) (C) (C) (string) \"\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Шүлэгний урт нь нэг энгийн тоо бол үнэн, эсвэл худал эргүүлэн өгөгдсөн функцийг бичих жишээ >>> prime_length((\"Hello\")) (true) >>> prime_length((\"abcdcba\")) (true) >>> prime_length((\"kittens\")) (true) >>> prime_length((\"orange\")) (false)\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Эерэг бүтэн тоо n-г өгсөн бол 1-ээс эхлэх эсвэл 1-ээр дуусах n-хэлгийн эерэг бүтэн тооны тоог буцаана.\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэгийн бүтэн тоог авч үзвэл, түүний тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо тоо тоо тоо тоо тоо тоо тоо тоо тооны тооны тоо\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Цэнгэг тооны хоосон бус вектор lst. хос элементүүдийг хос индексээр нэмнэ. Жишээ нь: >>> add((std:: vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Захидалтай хувилбар нь бүх үг (загваргаар тус тус) нь ASCII-ийн үнэлгээний дагуу өсөх дарааллаар байрлуулсан шинэ үгтэй байхаар зохицуулагдсан хувилбар юм. Та өгүүлбэр дэх үг болон хоосон орон зайны дарааллыг хадгалах хэрэгтэй. Жишээ нь: >>> anti_shuffle((\"Hi\")) (\"Hi\") >>> anti_shuffle((\"hello\")) (\"ehllo\") >>> anti_shuffle\"((Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та 2 хэмжээст өгөгдөл, нэгдмэл вектор, матриц төстэй байдаг, гэхдээ матрицээс ялгаатай нь, нэг суудалд өөр тооны суудлууд байж болно. lst, бүтэн тоо x-ийг авч, векторт бүтэн тоо x-ийг олж, буцалт вектор нь нь [(x1, y1), (x2, y2) ...] иймээс тус бүр нь тупл нь координат юм - (суудлын суудлууд), 0-ээс эхлэн. Анхдаа суудлуудыг өсөх дарааллаар дараарай. Мөн суудлын координатуудыг буцалт дарааллаар дараарай. Жишээ нь: >>> get_row(std:: vector<std:: vector<<>> (long) {long) {long) {long) {long) {long) {long) {long) {long) {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нүүр хуудас: * өгөгдсөн векторг өөрчлөхгүй. Жишээ нь: >>> sort_array(std::vector<long>())) (std::vector<long>) >>> sort_array((std::vector<long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энрифт функцийг үүсгэхийн тулд нэг үсгийн аргумент болон үсгийн эргэлтээр шифрлэсэн үсгийн өгөгдөл гарна. Үргэлт нь үсэг хоёр дахин нэмэгдэх байдлаар эргүүлэх ёстой. Жишээ нь: >>> encrypt((\"hi\")) (\"lm\") >>> encrypt((\"asdfghjkl\")) (\"ewhjklnop\") >>> encrypt((\"gf\")) (\"kj\") >>> encrypt((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэл тооны вектор авдаг. next_smallest () функцийг бичих. Энэ нь вектор дахь 2-р жижиг элементийг буцааж өгдөг. Хэрэв тийм элемент байхгүй бол None () функцийг буцаана. >>> next_smallest () std:: vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest () std:: vector<long>{(long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest () std:: vector<long>(long))) std::nullopt >>> next_smallest () std:: vector<long>{(long) 1, (long) 1))) std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэнд хэд хэдэн үг өгнө, таны үүрэг бол ядарсан дугаарыг тоолх юм. Ядарсан гэдэг нь \"I\" үгээр эхэлдэг өгүүлбэр юм. Хуулийг \"\", \"?\" эсвэл \"! \" -ээр хуваадаг. Жишээ нь: >>> is_bored (((\"Hello world\")) (0) >>> is_bored (((\"Тэнгэр цэнхэр. Нар гэрэлтэж байна. Би энэ цаг агаард дуртай\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 3 тоог хүлээн авдаг функцийг бий болгоно. Нэг тоо нь бусад хоёр тооны нийлбэртэй тэнцүү бол үнэн, бүх тоо нь бүтэн тоо юм. Бусад тохиолдолд буруу гэж өгнө. Жишээ нь >>> any_int((float(5)), (float(2)), (float(7))) (true) >>> any_int(((float3)), (float(2)), (float(2))) (false) >>> any_int((float(3)), (float(-2)), (float(1) (true) >>> any_int(((3.6f), (-2.2f), (float(2))) (false)\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Мэдээлэл авах, бүх үсгийн case-ийг солилцох, бүх үсэгт үсгийн 2 байрлал өмнө байгаа үсэгт нь орлох байдлаар кодлох функцийг бичих. Зөвхөн үсэгүүдийг аваарай. Жишээ нь: >>> encode((\"test\")) (\"TGST\") >>> encode((\"This is a message\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэл тооны вектор өгөгдсөн байна. Та хамгийн том анхны үнэ цэнийг олж, түүний тоон тооны нийлбэрийг буцаах хэрэгтэй. Жишээ нь: >>> skjkasdkd((std:: vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 5, (long) 7, (long) 4, (long) 5, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) (long) (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Жишээ нь: >>> check_dict_case(((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}}))) (true) >>> check_dict_case(((std::<std::string,std::string>{{\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", {\"a\", \"apple\"}, {\"a\", {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", \"apple\"}, {\"a\", {\"a\", \"apple\"}, {\"a\", {\"a\", \"apple\"}, {\"a\", {\"a\", \"std\": \"std\": \"std\": \"std\": \"std\": \"std\": \"std\": \"std\": \"std\": \"st: \"st\": \"), \" ({{\"a\", \"}\", \"}\", \"}\", \"}\", \"}\", \" \" \" \" \"\", \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Сөрөг бус бүтэн тоог авч, n-ээс бага, анхны n бүтэн тооны вектор буцаах функцийг хэрэгжүүлнэ. Жишээ нь: >>> count_up_to((5)) (std:: vector<long>({long) 2, (long) 3})) >>> count_up_to(11)) (std:: vector<long>({long) 2, (long) 3, (long) 5, (long) 7}) >>> count_up_to(0)) (std:: vector<long>)) >>> count_up_to(20)) (std:: vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 13, (long) 17, (long) 19} >>> count_up_1) (std:: vector<long> >>> count_up_to(18) (std: vector<long>11, (long) 3, (long) 5, (long) 17)) (std: vector<long> (long) 3, (long) 11, (long) 1, (long) (long) 2, (long)) (long) 17 (long)\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хоёр бүтэн тоог авч, нэгжийн тооны үр дүнг гарган өгөгдсөн функцийг дуусгах.\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// S үсгийн тоог авч үзвэл, том үсэгт том үсэгт хэдэн тоог тооцно. Жишээ нь: >>> count_upper (((\"aBCdEf\")) (1) >>> count_upper (((\"abcdefg\")) (0) >>> count_upper (((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой тоог илэрхийлэх үнэ цэнийг (хүсэл) авч, түүнд хамгийн ойр цэцэг тоог буцаан өгөгдсөн функцийг бий болгоно. Хэрэв тоо нь хоёр бүтэн тооноос тэнцүү алслагдсан бол түүнийг нулаас холдуулж хураангуй болгоно. Жишээ нь >>> хамгийн ойр_төгцөгцөгцөгцөгцөгцөгцөг (((\"10\")) (10) >>> хамгийн ойр_төгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгцөгц\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэгийн тооны хувьд n хэмжээнд чулуунуудыг нэгтгэх хэрэгтэй. Эхний түвшинд нь n хэмжээнд чулуу бий. Дараагийн түвшинд чулуунуудын тоо нь: - n нь хос тоо бол дараагийн хос тоо. - n нь хос тоо бол дараагийн хос тоо. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэнд холимог болон хооронд хуваагдсан үгсийн цуврал өгнө. Таны ажил бол уг цуврал үгсийг хувааж, үгийн вектор буцаах явдал юм. Жишээ нь: >>> words_string (((\"Сайн байна уу, миний нэр Жон\")) (std::vector<std::string>({(std::string) \"Сайн байна уу\", (std::string) \"Миний\", (std::string) \"Нэр\", (std::string) \"Энэ\", (std::string) \"Жон\"}) >>> words_string (((\"Нэг, хоёр, гурван, дөрвөн, таван, зургаан\")) (std::vector<std::string>{(stdstring) \"Нэг\", (std::string) \"Нэг\", (std::string) \"Нэг, хоёр, (std::string) \"Нэг, (std::string) \"Нэг, (std::string) \"Нэг, (st::string) \"Нэг, (st::string) \"Нэг, (five, six))\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ функц нь x болон y гэсэн хоёр эерэг тоог авч, [x, y] хүрээний хамгийн том хос бүтэн тоог эргүүлнэ. Хэрэв ийм тоо байхгүй бол функц нь -1-ийг эргүүлнэ. Жишээ нь: >>> choose_num (((12), (15)) (14) >>> choose_num (((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Та хоёр эерэг бүтэн тоо n болон m-ийг авч, n-ээс m хүртэлх бүтэн тоонуудын дундаж тоог тооцох ёстой. Хариугаа хамгийн ойрын бүтэн тоонд хүргэж, үүнийг хослуулалтад хувиргана. Хэрэв n нь m-ээс их бол -1-ийг буцаана. Жишээ нь: >>> rounded_avg((1), (5)) \"0b11\" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) \"0b1111\" >>> rounded_avg(20), (33) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хөгжлийн хэдэн тооны вектор өгвөл x гэсэн тооны бүх элементийн хэдэн тооны вектор нь хэдэн тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой бүтэн тооны вектор өгвөл 1 болон 9 хоорондох бүтэн тоонуудыг ангилж, үр дүнг нь буцааж, дараа нь \"Нэг\", \"Хоёр\", \"Гурван\", \"Дөрвөн\", \"Гурван\", \"Гургаа\", \"Гурван\", \"Сям\", \"Сайн\", \"Есөн\" гэсэн дугаар болгон орлох. Жишээ нь: >>> by_lengthth, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3))) (std::vector, (std::string, (eight), (stdstring, (five), (stdstring, (four), (stdstring, (three), (stdstring, (two), (stdstring, (three)) (stdstring, (stdstring)) (stdstring, (stdstring)) (stdstring, (stdstring)) (stdstring, (stdstring)) (stdstring, (stdstring)) (stdstring, (stdstring)) (ststring, (stdstring)) (st) (ststring, (stdstring, (string)) (st) (string) (string) (string) (string (string) (string) (string (string) (string) (string (string) (string (string)) (string (string (string) (string) (string (string) (string (string)) (string (string (string) (string (string) (string (string)) (string (string (string) (string (string (string)) (string (string) (string (string) (string (string (string) (string (string (string)) (string (string) (string (string (string) (string (string (string)) (string (string) (string (string (string) (string (string (string)) (str\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// n-г параметр болгон авч, i индекс дэх элементийн үнэ цэнэ нь i-ийн i-ийн факториал юм бол i нь тэгш эсвэл 1 -ээс i хүртэлх тоонуудын нийлбэр юм бол i нь 1-ээс эхэлдэг. i-ийн факториал нь 1 -ээс i хүртэлх тоонуудын үржүүлэлт юм (1 * 2 * ... * i). Жишээ нь: >>> f (((5)) (std:: vector<long> (((long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Эерэг бүтэн тоо n-ийг авч үзвэл, дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундах дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дундад дунда\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// count_nums функцийг бичих. Энэ функц нь бүтэн тооны вектор авч, тооны тооны тооны тоог өгнө. Энэ функц нь тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Бидэнд N бүтэн тооны ар[1] ар[2] ар[N] гэсэн вектор байна. Векторын тоонуудыг тохиолдлын дагуу дараалж болно. Таны ажил нь тухайн вектор дээр дараах үйлдлийг хийснээр вектор нь буурч болохгүй дарааллаар дараалж болох эсэхийг тодорхойлох явдал юм. Та баруун шилжих үйлдлийг аль ч тооны удаа хийх боломжтой. Нэг баруун шилжих үйлдэл нь вектор дахь бүх элементүүдийг нэг байрлалаар баруун чиглэлд шилжүүлэх гэсэн үг юм. Векторын сүүлийн элемент нь вектор дахь эхлэх байрлалд буюу 0-р индексд шилжинэ. Хэрэв дээр дурдсан үйлдлийг хийснээр дараалсан вектор олж авах боломжтой бол true return false. Хэрэв тухайн вектор хоосон бол true return false. Зураг: Тухай вектор нь өвөрмөц элементтэй байх нь баталгаатай. Жишээ нь: >>> move_one_ball_((st vector::{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ асуудлын хувьд lst1 ба lst2 хооронд элемент солилцох боломжтой бол \"ТЭЙ\" гэж буцааж өг. Үгүй бол \"ҮҮҮ\" гэж буцааж өг. Жишээ нь: >>> exchange((std::vector<>(long) {1, (long) {2, (long) {3, (long) {4})), (std::vector<>({1, (long) {2, (long) {3, (long) {4})) (\"ТЭЙ\") >>> exchange:{d::vector<>{1, (long) {2, (long) {3, (long) {4}) \"ТЭЭЙ\" гэж буцааж өг.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Жишээ нь: >>> histogram (((\"a b c\")) (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}})) >>> histogram (((\"a b b a\")) (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})) >>> histogram (((\"a b c a\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> histogram (((\"a b c a b\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> histogram (http://www.histogram.com/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.php/index.ph\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Зам: Бидэнд s болон c гэсэн хоёр үсгийн бүх тэмдэгтүүдийг устгаж, дараа нь үр дүнгийн үсэг нь палиндром эсэхийг шалгах хэрэгтэй. Үргэлжлүүлэн уншдаг бол үр дүнгийн үсэг нь палиндром гэж нэрлэгддэг. Үр дүнгийн үсэгтэй, үнэн / худал гэсэн дугаарыг буцаан өгөх хэрэгтэй. Жишээ нь >>> reverse_delete (((\"abcde\"), (\"ae\")) (std::make_tuple (((bcd\", false)) >>> reverse_delete (((\"abcdef\"), (\"b\") (std::make_tuple (((acdef\",)) >>> reverse_delete (((abcded\", false)) >>> reverse_delete (((abcded\"), (\"abcba\") (std::make_tuple (((cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ нь i-г i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн тоог i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-ийн i-\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэрийн бүтэн тооны вектор өгвөл, хоосон биш бүхэл тооны субвекторын хамгийн бага нийлбэрийг олох. Жишээ нь >>> minSubArraySum(((std:: vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std:: vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэнд усан сангийн дөрвөлжин сүлжээ өгөгдсөн байна. Нэг мөр нь нэг усыг илэрхийлж, нэг мөр нь нэг нэгжийг илэрхийлдэг. Тухайн усан сангаас ус авахын тулд нэг савтай бөгөөд бүх сав нь ижил хэмжээтэй байдаг. Таны ажил бол савнуудыг ашиглаж, савнуудыг хооронд нь буулгах явдал юм. Цуврыг буулгах шаардлагатай хэдэн удаагаа оруулна. Жишээ 1: >>> max_fill((std:: vector<std:: vector<long>0, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ ката дээр та хоёр тооны бүтэн тооны нэгдлийн тооны дагуу тооны тооны тооны тооны дагуу тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэрэв string s нь хоосон бол функц нь хоосон вектор буцаах ёстой. Та оруулсан string нь зөвхөн үсэг, орон зайтай гэж үзэж болно. Жишээ нь: >>> select_words (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (>) (<string>) (>) (>) (>)\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таныг үг өгнө. Таны ажил бол үгийн баруун талд байгаа хоёр сурталчилгааны хооронд орших хамгийн ойрын үсэг олох (хурцтай). Эхлэл болон төгсгөлд байгаа үсэгүүд тооцогдохгүй. Хэрэв та дээрх нөхцөлд нийцсэн үсэг олдохгүй бол хоосон үсгийн дарааллыг буцаана.\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та хоёр үсгийн вектор өгөгдсөн бөгөөд хоёр үсэг нь зөвхөн нээлттэй дугуй '(' эсвэл хаалттай дугуй ') '-аас бүрддэг. Таны ажил нь хоёр үсэгт ямар нэг дарааллаар холбох боломжтой эсэхийг шалгах, үр дүнд гарсан үсэг сайн байх болно. S-ийн бүх дугуй тэнцвэртэй бол зөвхөн S-ийн бүх дугуй сайн гэж тооцогддог. Жишээ нь: '(()))) ' үсэг нь сайн бол '()) ' үсэг нь тийм биш. Хэрэв сайн үсэг хийх арга байгаа бол 'Тийм' гэж буцааж, өөр тохиолдолд 'Үгүй' гэж буцааж өгнө. Жишээ нь: >>> match_parens((std:: vector<std::string>{((stdstring) \") \", (((std::string) \"))) \" (\"Тийм\") >>> match_parens<std:: vector<std>{(stdstring>\" (\"Үгүй\")\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Жишээ 1: >>> maximum((std::vector<long>({(long) -3, (long) -4, (long) -4, (long) -3, (long) -5)) Жишээ 2: >>> maximum(std::vector<long>({(long) -4, (long) -4, (long) -4)), (2)) (std::vector<long>({(long) -4, (long) -4)) Жишээ 3: >>> maximum((std::vector<<long>({(long) -3, (long) -4)) Жишээ 3: >>> maximum(std::vector<<long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -2, (long) -2, (long) -1, (long) -2, (long) -2, (long) -1, (long) -1, (long) -1, (long) -1, (long) -1, (long) -1, (long) -2, (long) -1, (long) -1, (long) (1)) (1) (std::vector<<<<arr>) -2)) 1. Жишээ нь 1000 элементийн дундах болно.\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Цэнгэг тооны хоосон бус вектор өгвөл, тэгш байрлалд байгаа бүх хос элементийн нийлбэрийг буцаана. Жишээ нь >>> шийдэл((std:: vector<long>({(long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> шийдэл(((std:: vector<long>({(long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> шийдэл(((std:: vector<>({(long) 30, (long) 13, (long) 24, (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Цэнгэг тоо arr болон k гэсэн бүтэн тооны нөөцтэй тул arr-ийн эхний k элементийн хамгийн ихдээ хоёр оронтой элементүүдийн нийлбэрийг буцаана. Жишээ нь: >>> add_elements((std::vector<long>({(long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) Хязгаарлалтууд: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr()\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Collatz conjecture нь математикийн нэг таамаглал бөгөөд дараах байдлаар тодорхойлогддог: ямар ч n тоотой эхлэх. Дараа нь өмнөх тоо нь тэгш бол дараагийн тоо нь өмнөх тооны хагас болно. Хэрэв өмнөх тоо нь хос бол дараагийн тоо нь өмнөх тооны 3 дахин их болно.\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та өгөгдсөн хугацааны дугаарыг баталгаажуулж, хугацаа нь хүчин төгөлдөр бол үнэн, эсвэл худал гэж өгүүлэх функцийг бичих хэрэгтэй. Даатгалын дугаарыг дараах бүх дүрэмд нийцүүлэн баталгаажуулах хэрэгтэй: 1. Даатгалын дугаарыг хоосон гэж үзэхгүй. 2. Өдөрний тоо 1,3,5,7,8,10,12 саруудад 1ээс багагүй эсвэл 31ээс ихгүй, 4,6,9,11 саруудад 30 өдрөөс багагүй эсвэл 1ээс ихгүй. Мөн сарын тоо 1ээс багагүй эсвэл 29-аас ихгүй. 3. Саруудын тоо 1ээс багагүй эсвэл 12ээс ихгүй. 4. Даатгалын хэлбэр нь: mm-dd-yyyy >>> valid_(date(103-11-2000\")) (true >>> valid_date((15-01-2012\")) (false) >>> valid_date((04-040-20\") (false) >>> valid_((date_2020-06-04\") (true >>> valid_date\"06/04/2020) (false)\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Үгүүдийн цуврал өгвөл, үгийн хуваагдмал вектор буцааж өгнө, хэрэв үгийн хуваагдмал байхгүй бол та ',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',','\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тоон тооны вектор өгвөл тэдгээрийг өсөх дарааллаар ангилан эсэх нь эргүүлнэ. Хэрэв вектор нь ижил тооны нэгээс илүү давтагдалтай бол буруу гэж эргүүлнэ. Үр дүнг нь тоогүй тоо гэж үзээд зөвхөн бүтэн тоог тооцно. Жишээ нь >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та хоёр интервал өгөгдсөн байна, хаана нь интервал нь бүтэн тооны хос байна. Жишээ нь, интервал = (сарын эх, төгсгөл) = (1, 2). өгөгдсөн интервал нь хаагдсан байна, энэ нь интервал (сарын эх, төгсгөл) нь эхлэл, төгсгөл хоёрыг багтааж байна гэсэн үг юм. өгөгдсөн интервалын хувьд, түүний эх нь бага эсвэл төгсгөлтэй тэнцүү гэж үздэг. Таны ажил нь эдгээр хоёр интервалын хажуугийн урт нь нэг энгийн тоо эсэхийг тодорхойлох явдал юм. Жишээ нь, интервалын хажуугийн урт нь 1, энэ нь нэг энгийн тоо биш юм. Хэрэв хажуугийн урт нь нэг энгийн тоо бол \"ТЭР\", өөр тохиолдолд \"ҮҮҮҮ\" гэж буцааж өгнө. Хэрэв хоёр интервал хоорондоо зөрчигдөхгүй бол \"ҮҮҮ\" гэж буцааж өгнө. [input/output] samples: >>> intersection::(((d_make_tuple1,(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэл тооны арк вектор өгөгдсөн бөгөөд 1, -1 эсвэл 0-ээр илэрхийлэгдсэн вектор дахь бүх тооны бүх тэмдэгтийн үржүүлэлтээр бүтэн тооны хэмжээний нийлбэрийг буцаан өгөх хэрэгтэй. Зураг: хоосон арк дээр буцаан ирэхгүй. Жишээ нь: >>> prod_signs(((std:: vector<long>{(long) 1, (long) 2, (long) 2, (long) - 4}))) 9 >>> prod_signs(std:: vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs((std:: vector<long>())) std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та ямар ч эсийн эхэнд, болон та орших эсийн аль ч эгнээ рүү явж болно. Та k урттай зам нь яг k эсийн (зөвхөн ялгаж байх албагүй) зочлох гэсэн үг гэдгийг анхаарна уу. Та grid-ээс гарч чадахгүй. A (k урттай) зам нь B (k урттай) замнаас бага гэж тооцогддог. Хэрэв A болон B-ийн эсийн үнэт зүйлсийн дараалсан векторүүдийг хийсний дараа (асуудлыг lA_st_j болон lA_st_j гэж нэрлэе), lA_st_j нь лексикээр lA_st_j-ээс бага юм. Өөрөөр хэлбэл, ямар ч энгийн цэгт j[i] = lA_j < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j) < 1 (i_j)\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хүн бүр Фибоначчийн дарааллыг мэддэг бөгөөд сүүлийн хэдэн зууны хугацаанд математикчид үүнийг гүнзгий судалж байсан. Гэхдээ хүмүүс мэдэхгүй зүйл бол Трибоначчийн дараалл юм. Трибоначчийн дарааллыг давтагдалтайгаар тодорхойлдог: tri(1) = 3 tri(n) = 1 + n / 2, хэрэв n нь хос бол. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), хэрэв n нь хос бол. Жишээ нь: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Таныг n-гүй бүтэн тоо өгвөл, Трибоначчийн дарааллын эхний n + 1 -ийн вектор буцаах хэрэгтэй. Жишээ нь: >>> tri(3) (dst vector><<(((((( (long) (1, (long) (3, (long) (long))\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэгийн бүтэн тоог авч үзвэл, хос тооны үр дүнг өгнө. Хэрэв бүх тоо нь хос тооны тоо бол 0-г өгнө. Жишээ нь: >>> тооны тоо (((1)) (1) >>> тооны тоо (((4)) (0) >>> тооны тоо (((235)) (15)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Зөвхөн квадрат хаалгаар багтагдсан үсгийн дарааллыг оруулж буй функцийг бий болгоно. Хэрэв дараалал дахь хамгийн багадаа нэг хаалгаар нь байрлуулсан хаалганы дараалал байвал зөвхөн тэгш эргүүлнэ. >>> is_nested\" ([[]]\")) (true) >>> is_nested\" ([[]]) (true)\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэнд тооны вектор өгөгдсөн байна. Та өгөгдсөн вектор дахь тооны квадратын нийлбэрийг буцааж, вектор дахь элемент болгондоо хамгийн түрүүнд үрээс нь дугуйлах хэрэгтэй. Жишээ нь: >>> lst: vector<float>{(float) 1.0f, (float) 2.0f, (float) 3.0f))) (14) >>> lst: vector<float>{(float) 1.0f, (float) 4.0f, (float) 9.0f))) >>> (98) lst: vector<float>{(float>{(float) 1.0f, (float) 3.0f, (float) 5.0f, (float) 7.0f} (84) >>> lst: vector<float>{(((float>{(f1.4f, (float) 2.0f, (float) 2.0f, (float) 3.0f)) (14) >>> lst: vector<float>{(((((((f1.0f, (float) 2.0f, (float) (6) >>> (float: vector<((f.\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Жич: \"word\" нь орон зайгаар тусгаарлагдсан тэмдэгтүүдийн бүлэг юм. Жишээ нь: >>> check_if_last_char_is_a_letter (((\"apple pie\")) (false) >>> check_if_last_char_is_a_letter (((\"apple pi e\")) (true) >>> check_if_last_char_is_a_letter (((\"apple pi e \")) (false) >>> check_if_last_char_is_a_letter (((\"apple pi e \")) (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Элементээс хамгийн их буюу тэрнээс шууд өмнөх элементээс илүүгүй хамгийн том индексийг буцаан өгөх функцийг бий болгоно. Хэрэв ийм элемент байхгүй бол -1-ийг буцаана.\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тупл (a, b) -г буцаан өгөгдсөн функцийг бий болгоно. Энд 'a' нь сөрөг бүтэн тоонуудын хамгийн том, 'b' нь вектор дахь эерэг бүтэн тоонуудын хамгийн жижиг юм. Хэрэв сөрөг эсвэл эерэг бүтэн тоо байхгүй бол тэдгээрийг None гэж буцаана. Жишээ нь: >>> largest_smallest_integers((std::vector<long>{long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7))) std::make_tuplestd::optional<long>{long>), std::optional<long>{long>) >>> largest_smallest_integers{((std::std vector<long>{long>)) std::std vector<long>{long>)) std vector<long> (long>)\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Бодит тоог илэрхийлсэн бүтэн тоо, float эсвэл string-г авч, өгөгдсөн хэлбэрээр нь том хувьсагчийг буцааж өгдөг функцийг бий болгох. Хэрэв үнэ цэнэ нь ижил бол None-г буцаана.\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нэрлэсэн n тоог яг 4 эерэг тэгш тооны нийлбэр болгон бичиж болох эсэхийг үнэлнэ. Жишээ нь >>> is_equal_to_sum_even ((4)) (хууль) >>> is_equal_to_sum_even ((6)) (хууль) >>> is_equal_to_sum_even ((8) (true)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Бразилийн факториал нь: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! хаана n > 0 Жишээ нь: >>> special_factorial((4)) (288) Функц нь нэвтрүүлэг болгон бүтэн тоо хүлээн авч, энэ бүтэн тооны онцгой факториалыг буцаах ёстой.\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Шүлэгт өгөгдсөн үсгийн бүх орон зайг дорхноор орчуул, хэрэв үсгийн дараалан 2 гаруй орон зайтай бол дараалан бүх орон зайг - >>> fix_spaces (((\" Жишээ\")) (\" Жишээ\") >>> fix_spaces (((\" Жишээ 1\")) (\" Жишээ_1\") >>> fix_spaces (((\" Жишээ 2\")) (\"_ Жишээ_2\") >>> fix_spaces (((\" Жишээ 3\")) (\"_ Жишээ-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Файл нэр нь хүчин төгөлдөр бол \"Yes\" гэж, эсвэл \"No\" гэж өгөгддөг функцийг бий болгоно. Файл нэр нь дараах нөхцөлийг хангасан тохиолдолд хүчин төгөлдөр гэж тооцогдоно: - Файл нэр нь гурван тоодон ('0'-'9') илүү байх ёсгүй. - Файл нэр нь яг нэг цэг '.' - Цэгээс өмнөх дэд сүүлч хоосон байх ёсгүй, латин алфавитээс ('a'-'z' болон 'A'-Z') эхлэх ёстой. - Цэгээс дараах дэд сүүлч нь дараах үгийн нэг байх ёстой: ['txt', 'exe', 'll'] Жишээ: >>> file_name_check\"((example.txt\") (\"Yes\") >>> file_name_check\"((example.d1\") (\"No\")\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Энэ функц нь бүтэн тооны вектор авна. Энэ функц нь вектор дахь бүх нэрийн хувьд, функц нь 3 -ийн үржүүлэгт байгаа бол бүтэн тооны нэрийн квадрат, харин индекс нь 3 -ийн үржүүлэгт биш, харин 4 -ийн үржүүлэгт байгаа бол бүтэн тооны нэрийн куб болно. Энэ функц нь вектор дахь 3 эсвэл 4 -ийн үржүүлэгт бус нэрийн нэрийн нэрийн тоог өөрчлөхгүй. Дараа нь функц нь бүх нэрийн нийлбэрийг буцааж өгнө. Жишээ нь: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst (long ((long)) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та бүхэнд өгүүлбэрийг илэрхийлэх үсгийн дугаар өгөгдсөн бөгөөд үгээр нь хоорондоо зайгаар тусгаарлагдсан зарим үгсийг агуулсан үсгийн дугаар өгүүлэх ёстой. Үргэлж нь анхны үгийн үгсийг агуулсан үсгийн дугаар нь анхны үгийнхтэй ижил байх ёстой. Жишээ 1: >>> words_in_sentence (((\"This is a test\")) (\"is\") Жишээ 2: >>> words_in_sentence (((\"let's go for swimming\")) (\"go for\") Хязгаарлалтууд: * 1 <= len ((sentence) <= 100 * Үглэлд зөвхөн үсэг байдаг\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таны ажил нь x * n илэрхийлэлийг хялбаршуулдаг функцийг хэрэгжүүлэх явдал юм. Хялбаршуулбал x * n нь бүтэн тоо, эсхүл буруу гэж хариулна. x ба n нь хоцрогчийн үсгийн илэрхийлэл бөгөөд дараах хэлбэртэй байдаг, <асуудал>/<асуудал> хаана тооцол, нэрлэгч нь хоёулаа эерэг бүтэн тоо байдаг. x, n нь хүчин төгөлдөр хоцрог бөгөөд нэрлэгчийн хувьд 0 байхгүй гэж та үзэж болно. >>> хялбаршуул (((\"1/5\"), (\"5/1\")) (true) >>> хялбаршуул (((\"1/6\"), (\"2/1\")) (false) >>> хялбаршуул (((\"7/10\"), (\"10/2\")) (false)\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой бүтэн тооны вектор нь тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тооны тоо\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тоон тооны векторг оруулсан бөгөөд 10-аас их, тооны эхний болон сүүлийн хоёр орон нь хос (1, 3, 5, 7, 9) элементийн тоог буцаан өгөгдсөн функцийг бичих. Жишээ нь: >>> specialFilter(((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) (1) >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Таныг n тоотой бүтэн тоотой болгоно. Та n урттай бүтэн тооны вектор a бий болгох хэрэгтэй. i (1 ≤ i ≤ n) болгонд a[i] = i * i - i + 1 гэсэн утгатай. a-ийн i < j < k, a[i] + a[j] + a[k] нь 3-ийн үржүүлэг болох a-ийн 3 удаагийн тоог буцааж өгнө. Жишээ нь: >>> get_max_triples((5)) (1) Тодорхойлолт: a = [1, 3, 7, 13, 21] Зөвхөн 1, 7, 13 гэсэн гурван удаагийн тоо л хүчин төгөлдөр болно.\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Нарны системд найман гараг байдаг: Нарны хамгийн ойр орших нь Меркурий, дараа нь Венера, дараа нь Дэлхий, Марс, Юпитер, Сатурн, Уран, Нептун. Энэ функц нь хоёр гарагийн нэрийг planet1 болон planet2 гэж нэрлэх функцийг бичих хэрэгтэй. Энэ функц нь орчин тойрог нь planet1 болон planet2 орчин тойрог хооронд орших бүх гарагийг агуулсан, нарны ойролцооноос ангилан туплайг буцаах ёстой. Хэрэв planet1 эсвэл planet2 нь гарагийн нэр зөв биш бол функц нь хоосон туплайг буцаах ёстой. Жишээ нь >>> bf((\"Юпитер\"), (\"Нептун\")) (std:: vector<std::string>{(std::string) \"Сатурн\", (stdstring) \"Уран\"} (stdstring) >>> bf(\"Дэлхий\"), (\"Меркурий\") (stdstring) (Jupiter) (\",Saturn\", (\"Меркурий\") (stdstring) (Sup (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str)\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Гүйцэтгэг нь үргэлж үсгийн вектор бөгөөд хэзээ ч тооны вектор биш бөгөөд давтагдалтай зүйлсийг агуулж болно. Векторын дараалл нь үгийн урттайгаар өсч байх ёстой бөгөөд та энэ дүрмийн дагуу дараалсан вектор буцаах ёстой. Хэрэв хоёр үг ижил урттай бол векторг үсэг бусаар дараална. Функц нь үсгийн векторг дараалсан дарааллаар буцаах ёстой. Та бүх үг ижил урттай байх болно гэж үзэж болно. Жишээ нь: >>> list_sort{\"}std:: vector<stdstring>{\"}{\"}{\"} (string) \" (string) \" (string) \" (string) \" (string) \" (string) \" (string) \" (string) \" (string) \" (string) \" (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string) (string (string) (string) (string (string) (string (string) (string) (string (string) (string (string) (string (string) (string) (string (string) (string (string) (string (string) (string (string) (string (string) (string (string) (string (string) (string (string) (string (string) (string) (string (string (str) (string (str) (str) (str) (string (string (str) (str) (string (str) (str) (str) (string (str) (str) (string (str) (str) (str) (string (str) (str) (str) (string (str) (str) (str) (str) (str) (string (str) (str) (str) (str) (str) (str) (string (str) (string (str) (str) (str) (str) (str) (str) (str) (\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энгийн програм нь n нь анхны тоо бол x-ийн үнэ цэнийг буцааж, өөр тохиолдолд y-ийн үнэ цэнийг буцааж өгөх ёстой. Жишээ нь: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тоон тооны вектор өгвөл, вектор дахь хос тоонуудын квадратын нийлбэрийг буцаана. Үүнээс гадна, сөрөг тоо эсвэл бүтэн тоо биш тоонуудыг үл тооцно. >>> double_the_difference ((((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference ((((std::vector<float>{(long)-1, (long)-2, (long) 0}))) (0) >>> double_the_difference ((((std::vector<float>{(long) 9, (long) - 2}))) (81) >>> double_the_difference (((((std::vector<float>{(long) 0)) (0) Хэрэв оруулсан вектор нь хоосон бол 0 буцаана.\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Энэ нь ямар нэгэн удаан хүлээсэн үйл явдлын үр дүнг мэдэрсэн үед мэдрэгдэх мэдрэмж юм. Энэ үед таны мэдэрсэн мэдрэмж, бодол нь тодорхой тэмдэглэж, харьцуулахад үнэ цэнэтэй. Таны ажил бол хүн хэд хэдэн тоглолтын үр дүнг зөв таамагласан эсэхийг тодорхойлох явдал юм. Та бүхэнд ижил урттай оноо, таамаглал бүхий хоёр вектор өгөгдсөн бөгөөд тус бүр нь нийцсэн үзүүлэлтийг харуулдаг. Нэгэн адил урттай вектор буцааж, тухайн таамаглал хэр хол байгааг илэрхийлэх. Хэрэв тэд зөв таамагласан бол үнэ цэнэ нь 0, үгүй бол үнэ цэнэ нь таамаглал болон онооны хоорондын төгс ялгаа юм. Жишээ нь: >>> (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та анги (хүсэл) болон өргөтгөлийн вектор нэр авах болно. Өргөтгөлийн хүч нь дараах байдлаар байна: CAP нь өргөтгөлийн нэр дэх том үсгийн тоо, SM нь өргөтгөлийн нэр дэх бага үсгийн тоо байх бол хүч нь CAP - SM хэсэгээр өгөгддөг. Та хамгийн хүчтэй өргөтгөлийг олж, дараах хэлбэрээр үсэг буцаах хэрэгтэй: ClassName.StrongestExtensionName. Хэрэв ижил хүчтэй хоёр эсвэл түүнээс дээш өргөтгөлийн нэр байгаа бол векторд хамгийн түрүүнд гарч ирэх нэг нь сонгох хэрэгтэй. Жишээ нь, хэрэв танд \"Slices\" анги болон өргөтгөлийн вектор: ['SErviSliCes',' Cheese', 'StuF' гэж өгөгдсөн бол 'Slices.SErviSliCes' 'myst:::::::: myst: myst: SErviCes:: myst:::: myst: SErviCes:::: myst: myst:::::: myst: STRviCes:: strongest: strongest: strongest' гэж өгүүлнэ. (ааааааааааааааааааааааааааа) (аааааааааааааа) (ааааааааа) (ааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааа\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та 2 үг өгөгдсөн байна. Хэрэв хоёр дахь үг эсвэл түүний ямар нэг эргэлт нь эхний үгний дэд үсэг бол true-г буцаах хэрэгтэй >>> cycpattern_check((\"abcd\"), (\"abd\")) (false) >>> cycpattern_check((\"hello\"), (\"ell\")) (true) >>> cycpattern_check((\"whassup\"), (\"psus\")) (false) >>> cycpattern_check((\"abab\"), (\"baa\")) (true) >>> cycpattern_(check\"efef\"), (\"eeff\") cycpattern_check_((\"himens\"), (\"simen\") (true)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Тодорхой тоог өгсөн бол, тэгш болон хос тооны тоотой туплейг буцаана. Жишээ нь: >>> тэгш_орон_хурц_хуйц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_хурц_урц_хурц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урц_урур.\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Эерэг бүтэн тоо өгвөл, түүний ромын тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон тоон\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Гурван талын гурван талын урт өгүүлнэ. Гурван талын талууд нь тэгш өнцөгт гурвалжинг үүсгэдэг бол үнэн, өөр тохиолдолд буруу гэж буцаана. Төгс өнцөгт гурвалжин нь нэг өнцөг нь тэгш өнцөг эсвэл 90 градус байдаг гурвалжин юм. Жишээ нь: >>> right_angle_triangle (((3), (4), (5)) (true) >>> right_angle_triangle (((1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Гүйцэтгэгч нь өөр өөр үгсийг агуулсан үгийн хамгийн их тоог хүлээн зөвшөөрдөг функцийг бичих. Хэрэв олон тооны үгийн хамгийн их тоог хүлээн зөвшөөрдөг бол хамгийн түрүүнд гарч ирдэг үгийг эргүүлнэ. >>> find_max(std::vector<std::string>({(std::string) \"name\", (std::string) \"of\", (std::string) \"string\"}))) (\"string\") >>> find_max{(std::vector<std::string>({(std::string) \"name\", (std::string) \"enam\", (std::string) \"game\"} (\"enam\")))) >>> find_max{(std::vector<std::string>{((aaaaaaa\"}, (std::string) \"bbbb\" (\"aaa\"))\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Та өлсгөлөнтэй харваас бөгөөд тодорхой тооны гурилыг идсэн боловч одоо өдрийн хоолны хуваарийг дуусгахын тулд илүү их гурилыг идэх хэрэгтэй. Хэрэв хангалттай гурилыг идэж чадахгүй бол үлдсэн гурилыг бүгдийг идэх болно. Жишээ нь: >>> идэж((5), (6), (10)) (std:: vector<long>{(()11, (long)4}) >>> идэж((4), (8), (9) (std:: vector<long>{()12, ( (1})) >>> идэж(1), (10), (10) (std:: vector<long>{()11, (long) 0)) >>> идэж (), (11), (11), (5) (std:: vector<long>{() 7, (long) 0) V: бүтэн тооны тоо: 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000 * 0 = 1000\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Жич: Operator['+', '*', '-'] vector = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 тэмдэглэл: Operator vector-ийн урт нь operand vector-ийн урттай тэнцүү. Operand нь нөлөөгүй бүтэн тооны вектор юм. Operator vector-д хамгийн багадаа нэг оператор, operand vector-д хамгийн багадаа хоёр операнд байдаг.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Хэрэв s[i] нь үсэг бол үсгийн зургийг нь доод талаас дээш талаас эсвэл эсрэгээр нь буцааж, эсхүл үсэг нь байхгүй бол хэвээр үлдээдэг. Хэрэв үсэг нь үсэггүй бол үсэгний зургийг буцааж өгнө. Функц нь үр дүнгийн үсэг буцааж өгнө. Жишээ нь >>> solve((\"1234\")) (\"4321\") >>> solve(\"ab\")) (\"AB\") >>> solve(\"#a@C\")) (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 'text' string-г өгсөн бол md5 hash-тэй тэнцэх string-г буцаана. Хэрэв 'text' нь хоосон string-г байгаа бол None-г буцаана. >>> string_to_md5 (((\"Hello world\")) \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "khk_Cyrl",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// a, b гэсэн хоёр эерэг бүтэн тоог авч үзвэл a, b хоорондын хос тоог өсөх дарааллаар буцаана. Жишээ нь: >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]