[{"task_id":"HumanEval_0","nl":"kan_Knda","pl":"go_test.go","prompt":"package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್\/\/ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯಲ್ಲಿ, ಕ್ಕಿಂತ ಯಾವುದೇ ಎರಡು ಸಂಖ್ಯೆಗಳು ಪರಸ್ಪರ ಹತ್ತಿರವಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.\/\/ >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n\/\/ true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n","canonical_solution":"package has_close_elements_test\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\n\/\/ Check if in given list of numbers, are any two numbers closer to each other than\n\/\/ given threshold.\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n\tsort.Float64s(numbers)\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif math.Abs(numbers[i+1]-numbers[i]) < threshold {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n\ttestCases := []struct {\n\t\tnumbers   []float64\n\t\tthreshold float64\n\t\texpected  bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},\n\t\t{[]float64{1.5, 1.8, 2.2}, 0.3, true},\n\t\t{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase%d\", i+1), func(t *testing.T) {\n\t\t\tresult := has_close_elements(tc.numbers, tc.threshold)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_1","nl":"kan_Knda","pl":"go_test.go","prompt":"package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇನ್ಪುಟ್ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿರುವ ಯಾವುದೇ ಸ್ಥಳಗಳನ್ನು ನಿರ್ಲಕ್ಷಿಸಿ.\/\/ಪ್ರತ್ಯೇಕ ಗುಂಪುಗಳು ಸಮತೋಲಿತವಾಗಿರುತ್ತವೆ (ಪ್ರತಿ ತೆರೆದ ಬ್ರೇಸ್ ಸರಿಯಾಗಿ ಮುಚ್ಚಲ್ಪಡುತ್ತದೆ) ಮತ್ತು ಪರಸ್ಪರರೊಳಗೆ ಗೂಡುಕಟ್ಟಲಾಗುವುದಿಲ್ಲ .\/\/ಆ ಗುಂಪನ್ನು ಪ್ರತ್ಯೇಕ ಸ್ಟ್ರಿಂಗ್ಗಳಾಗಿ ಬೇರ್ಪಡಿಸಿ ಮತ್ತು ಆ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.\/\/ಈ ಕಾರ್ಯಕ್ಕೆ ಇನ್ಪುಟ್ ಎನ್ನುವುದು ನೆಸ್ಟೆಡ್ ಆವರಣಗಳ ಬಹು ಗುಂಪುಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ. ನಿಮ್ಮ ಗುರಿ \/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n","canonical_solution":"package separate_paren_groups\n\nfunc separate_paren_groups(paren_string string) []string {\n\tvar result []string\n\tvar currentGroup []rune\n\topenCount := 0\n\n\tfor _, char := range paren_string {\n\t\tif char == '(' {\n\t\t\topenCount++\n\t\t\tcurrentGroup = append(currentGroup, char)\n\t\t} else if char == ')' {\n\t\t\topenCount--\n\t\t\tcurrentGroup = append(currentGroup, char)\n\n\t\t\tif openCount == 0 {\n\t\t\t\tresult = append(result, string(currentGroup))\n\t\t\t\tcurrentGroup = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}","tests":"func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_2","nl":"kan_Knda","pl":"go_test.go","prompt":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಸಂಖ್ಯೆಯ ದಶಮಾಂಶ ಭಾಗವನ್ನು ಹಿಂತಿರುಗಿ.\/\/(ಉಳಿದ ಭಾಗವು ಯಾವಾಗಲೂ 1 ಕ್ಕಿಂತ ಚಿಕ್ಕದಾಗಿದೆ).\/\/ಮತ್ತು ಪೂರ್ಣಾಂಕ ಭಾಗ (ದೊಡ್ಡದಾದ ಪೂರ್ಣಾಂಕವು ನಿರ್ದಿಷ್ಟ ಸಂಖ್ಯೆಯ ಚಿಕ್ಕದಾಗಿದೆ) ಮತ್ತು ದಶಮಾಂಶ \/\/ಸಕಾರಾತ್ಮಕ ಫ್ಲೋಟಿಂಗ್ ಪಾಯಿಂಟ್ ಸಂಖ್ಯೆಯನ್ನು ನೀಡಿದರೆ, ಅದನ್ನು  ಎಂದು ವಿಭಜಿಸಬಹುದು.\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n","canonical_solution":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive floating point number, it can be decomposed into\n\/\/ an integer part (largest integer smaller than given number) and decimals\n\/\/ (leftover part always smaller than 1).\n\/\/ Return the decimal part of the number.\n\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n    integerPart := int(number)\n    return number - float64(integerPart)\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n    testCases := []struct {\n        input float64\n        expected float64\n    }{\n        {3.5, 0.5},\n        {0.0, 0.0},\n        {7.25, 0.25},\n        {4.99, 0.99},\n        {2.0, 0.0},\n    }\n\n    for _, tc := range testCases {\n        result := truncate_number(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %.2f, got %.2f\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(truncate_number(3.5)) \/\/ Should print 0.5\n    fmt.Println(truncate_number(7.25)) \/\/ Should print 0.25\n}","tests":"func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_3","nl":"kan_Knda","pl":"go_test.go","prompt":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಆ ಹಂತದಲ್ಲಿ ಕಾರ್ಯವು true ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು. ಇಲ್ಲದಿದ್ದರೆ ಅದು false ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.\/\/ಶೂನ್ಯ ಸಮತೋಲನ. ನಿಮ್ಮ ಕಾರ್ಯವು ಯಾವುದೇ ಹಂತದಲ್ಲಿ ಖಾತೆಯ ಸಮತೋಲನ ಶೂನ್ಯಕ್ಕಿಂತ ಕಡಿಮೆಯಾಗಿದ್ದರೆ ಪತ್ತೆಹಚ್ಚುವುದು, ಮತ್ತು \/\/ನಿಮಗೆ  ಎಂಬ ಅಕ್ಷರದಿಂದ ಪ್ರಾರಂಭವಾಗುವ ಬ್ಯಾಂಕ್ ಖಾತೆಯಲ್ಲಿನ ಠೇವಣಿ ಮತ್ತು ಹಿಂಪಡೆಯುವ ಕಾರ್ಯಾಚರಣೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ.\/\/ >>> below_zero([]int{1, 2, 3})\n\/\/ false\n\/\/ >>> below_zero([]int{1, 2, -4, 5})\n\/\/ true\nfunc below_zero(operations []int) bool {\n","canonical_solution":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestBelowZero(t *testing.T) {\n    testCases := []struct {\n        operations []int\n        expected   bool\n    }{\n        {[]int{1, 2, 3}, false},\n        {[]int{1, 2, -4, 5}, true},\n        {[]int{0, -1, 1}, true},\n        {[]int{}, false},\n        {[]int{-1, 1, -1, 1}, true},\n    }\n    for _, tc := range testCases {\n        result := below_zero(tc.operations)\n        if result != tc.expected {\n            t.Errorf(\"below_zero(%v) = %v; want %v\", tc.operations, result, tc.expected)\n        }\n    }\n}","tests":"func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_4","nl":"kan_Knda","pl":"go_test.go","prompt":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/MAD = ಸರಾಸರಿ. x - x_mean. \/\/ಅಂಶ ಮತ್ತು ಕೇಂದ್ರಬಿಂದು (ಈ ಸಂದರ್ಭದಲ್ಲಿ ಸರಾಸರಿ): \/\/ಸರಾಸರಿ ಸಂಪೂರ್ಣ ವಿಚಲನವು ಪ್ರತಿ \/\/ಈ ಡೇಟಾ ಸೆಟ್ನ ಸರಾಸರಿ.\/\/ಇನ್ಪುಟ್ ಸಂಖ್ಯೆಗಳ ನಿರ್ದಿಷ್ಟ ಪಟ್ಟಿಗಾಗಿ, ಸರಾಸರಿ ಸಂಪೂರ್ಣ ವಿಚಲನವನ್ನು ಲೆಕ್ಕ ಹಾಕಿ.\/\/ >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n\/\/ 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n","canonical_solution":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    var sum float64\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum \/ float64(len(numbers))\n\n    var madSum float64\n    for _, num := range numbers {\n        madSum += math.Abs(num - mean)\n    }\n    return madSum \/ float64(len(numbers))\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    tests := []struct {\n        input []float64\n        want  float64\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},\n        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},\n        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"mean_absolute_deviation(%v)\", test.input), func(t *testing.T) {\n            got := mean_absolute_deviation(test.input)\n            if got != test.want {\n                t.Errorf(\"mean_absolute_deviation(%v) = %v; want %v\", test.input, got, test.want)\n            }\n        })\n    }\n}","tests":"func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_5","nl":"kan_Knda","pl":"go_test.go","prompt":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇನ್ಪುಟ್ ಪಟ್ಟಿಯ ಪ್ರತಿ ಎರಡು ಸತತ ಅಂಶಗಳ ನಡುವೆ 'ಡಿಲಿಮೀಟರ್' ಸಂಖ್ಯೆಯನ್ನು ಸೇರಿಸಿ `numbers' \/\/ >>> intersperse([]int{}, 4)\n\/\/ []int{}\n\/\/ >>> intersperse([]int{1, 2, 3}, 4)\n\/\/ []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n","canonical_solution":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc intersperse(numbers []int, delimiter int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, num := range numbers {\n        if i > 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n\nfunc TestIntersperse(t *testing.T) {\n    testCases := []struct{\n        input []int\n        delimiter int\n        expected []int\n    }{\n        {[]int{}, 4, []int{}},\n        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},\n        {[]int{1}, 4, []int{1}},\n        {[]int{1, 2}, 4, []int{1, 4, 2}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v, %d\", tc.input, tc.delimiter), func(t *testing.T) {\n            result := intersperse(tc.input, tc.delimiter)\n            if !equal(result, tc.expected) {\n                t.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    \n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_6","nl":"kan_Knda","pl":"go_test.go","prompt":"package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾ. (() (()) ಗೂಡುಕಟ್ಟುವಿಕೆಯ ಗರಿಷ್ಠ ಎರಡು ಹಂತಗಳನ್ನು ಹೊಂದಿದ್ದರೆ ((())) ಮೂರು ಹೊಂದಿದೆ. \/\/ಗುಂಪಿನ ಪ್ರತಿಯೊಂದು, ಆವರಣಗಳ ಗೂಡುಕಟ್ಟುವಿಕೆ ಆಳವಾದ ಮಟ್ಟದ ಔಟ್ಪುಟ್. \/\/ಈ ಕಾರ್ಯಕ್ಕೆ ಇನ್ಪುಟ್ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ, ಇದು ಅಂತರಗಳಿಂದ ಬೇರ್ಪಡಿಸಲಾದ ಗೂಡುಗಳ ಆವರಣಗಳಿಗೆ ಬಹು ಗುಂಪುಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n","canonical_solution":"func parse_nested_parens(paren_string string) []int {\n    groups := strings.Fields(paren_string)\n    depths := make([]int, len(groups))\n\n    for i, group := range groups {\n        maxDepth, currentDepth := 0, 0\n        for _, char := range group {\n            if char == '(' {\n                currentDepth++\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == ')' {\n                currentDepth--\n            }\n        }\n        depths[i] = maxDepth\n    }\n\n    return depths\n}","tests":"func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_7","nl":"kan_Knda","pl":"go_test.go","prompt":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ನಿರ್ದಿಷ್ಟ ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ಗಳ ಇನ್ಪುಟ್ ಪಟ್ಟಿಯನ್ನು ಮಾತ್ರ ಫಿಲ್ಟರ್ ಮಾಡಿ\/\/ >>> filter_by_substring([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n","canonical_solution":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc filter_by_substring(strings []string, substring string) []string {\n    var result []string\n    for _, str := range strings {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterBySubstring(t *testing.T) {\n    tests := []struct {\n        input    []string\n        substring string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"bacd\", \"array\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_substring(test.input, test.substring)\n        if fmt.Sprintf(\"%q\", result) != fmt.Sprintf(\"%q\", test.expected) {\n            t.Errorf(\"filter_by_substring(%q, %q) = %q; expected %q\", test.input, test.substring, result, test.expected)\n        }\n    }\n}","tests":"func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_8","nl":"kan_Knda","pl":"go_test.go","prompt":"package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಖಾಲಿ ಮೊತ್ತವು 0 ಮತ್ತು ಖಾಲಿ ಉತ್ಪನ್ನವು 1 ಕ್ಕೆ ಸಮಾನವಾಗಿರಬೇಕು.\/\/ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ನಿರ್ದಿಷ್ಟ ಪಟ್ಟಿಗಾಗಿ, ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿರುವ ಎಲ್ಲಾ ಪೂರ್ಣಾಂಕಗಳ ಮೊತ್ತ ಮತ್ತು ಉತ್ಪನ್ನವನ್ನು ಒಳಗೊಂಡಿರುವ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.\/\/ >>> sum_product([]int{})\n\/\/ []interface{}{0, 1}\n\/\/ >>> sum_product([]int{1, 2, 3, 4})\n\/\/ []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n","canonical_solution":"func sum_product(numbers []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n}","tests":"func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_9","nl":"kan_Knda","pl":"go_test.go","prompt":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಅನುಕ್ರಮದಲ್ಲಿ.\/\/ಒಂದು ನಿರ್ದಿಷ್ಟ ಪಟ್ಟಿಯಿಂದ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ರಚಿಸಿ, ನಿರ್ದಿಷ್ಟ ಕ್ಷಣದವರೆಗೆ ಕಂಡುಬರುವ ರೋಲಿಂಗ್ ಗರಿಷ್ಠ ಅಂಶಗಳ ಪಟ್ಟಿಯನ್ನು ರಚಿಸಿ.\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n","canonical_solution":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a given list of integers, generate a list of rolling maximum element found until given moment\n\/\/ in the sequence.\n\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n    maxSoFar := numbers[0]\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n\nfunc TestRollingMax(t *testing.T) {\n    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) \/\/ should output []int{1, 2, 3, 3, 3, 4, 4}\n}","tests":"func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_10","nl":"kan_Knda","pl":"go_test.go","prompt":"package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/- ಸ್ಟ್ರಿಂಗ್ ಪೂರ್ವಪ್ರತ್ಯಯದ ಸ್ಟ್ರಿಂಗ್ ರಿವರ್ಸ್ನ ಅಂತ್ಯಕ್ಕೆ ಸೇರಿಸಿ ಅದು ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಪ್ರತ್ಯಯದ ಮೊದಲು ಬರುತ್ತದೆ.\/\/- ಒದಗಿಸಿದ ಸ್ಟ್ರಿಂಗ್ನ ಅತಿ ಉದ್ದದ ಪೋಸ್ಟ್ಫಿಕ್ಸ್ ಅನ್ನು ಪೈಲಿಂಡ್ರೋಮ್ ಎಂದು ಹುಡುಕಿ.\/\/ಅಲ್ಗಾರಿದಮ್ ಕಲ್ಪನೆ ಸರಳವಾಗಿದೆ: \/\/ಒದಗಿಸಿದ ಸ್ಟ್ರಿಂಗ್ನೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುವ ಕಡಿಮೆ ಪಾಲಿಂಡ್ರೋಮ್ ಅನ್ನು ಹುಡುಕಿ.\/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunc make_palindrome(myString string) string {\n","canonical_solution":"package make_palindrome_test\n\nimport (\n    \"testing\"\n)\n\nfunc make_palindrome(myString string) string {\n    if len(myString) <= 1 {\n        return myString\n    }\n    \n    \/\/ Helper function to check if a string is a palindrome\n    isPalindrome := func(s string) bool {\n        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n            if s[i] != s[j] {\n                return false\n            }\n        }\n        return true\n    }\n\n    \/\/ Start from the whole string and reduce until we find a palindrome\n    for i := len(myString); i > 0; i-- {\n        if isPalindrome(myString[len(myString)-i:]) {\n            prefix := myString[:len(myString)-i]\n            \/\/ Reverse the prefix and append to original string\n            reversedPrefix := reverse(prefix)\n            return myString + reversedPrefix\n        }\n    }\n\n    \/\/ If no palindromic suffix is found, return original string with reverse appended\n    return myString + reverse(myString)\n}\n\n\/\/ Helper function to reverse a string\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc TestMakePalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"cat\", \"catac\"},\n        {\"cata\", \"catac\"},\n    }\n\n    for _, test := range tests {\n        result := make_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"make_palindrome(%q) = %q; expected %q\", test.input, result, test.expected)\n        }\n    }\n}","tests":"func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_11","nl":"kan_Knda","pl":"go_test.go","prompt":"package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಈ ಇನ್ಪುಟ್ ಗಳಲ್ಲಿ ಬೈನರಿ XOR ಅನ್ನು ನಿರ್ವಹಿಸಿ ಮತ್ತು ಫಲಿತಾಂಶವನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಹಿಂತಿರುಗಿ.\/\/ಇನ್ಪುಟ್ ಎರಡು ಸ್ಟ್ರಿಂಗ್ ಗಳು a ಮತ್ತು b ಇವು 1 ಮತ್ತು 0 ಗಳನ್ನು ಮಾತ್ರ ಹೊಂದಿರುತ್ತವೆ.\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunc string_xor(a string, b string) string {\n","canonical_solution":"result := make([]byte, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tresult[i] = '0'\n\t\t} else {\n\t\t\tresult[i] = '1'\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_13","nl":"kan_Knda","pl":"go_test.go","prompt":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಎರಡು ಪೂರ್ಣಾಂಕಗಳ a ಮತ್ತು b ಗಳ ಒಂದು ದೊಡ್ಡ ಸಾಮಾನ್ಯ ವಿಭಾಜಕವನ್ನು ಹಿಂತಿರುಗಿ.\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n","canonical_solution":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a greatest common divisor of two integers a and b\n\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n    for b != 0 {\n        a, b = b, a%b\n    }\n    return a\n}\n\nfunc TestGreatestCommonDivisor(t *testing.T) {\n    tests := []struct {\n        a, b   int\n        expect int\n    }{\n        {3, 5, 1},\n        {25, 15, 5},\n        {54, 24, 6},\n        {48, 18, 6},\n        {101, 103, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.a, test.b), func(t *testing.T) {\n            result := greatest_common_divisor(test.a, test.b)\n            if result != test.expect {\n                t.Errorf(\"expected %d, got %d\", test.expect, result)\n            }\n        })\n    }\n}","tests":"func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_14","nl":"kan_Knda","pl":"go_test.go","prompt":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇನ್ಪುಟ್ ಸ್ಟ್ರಿಂಗ್ನ ಚಿಕ್ಕದಾದಿಂದ ಉದ್ದದವರೆಗಿನ ಎಲ್ಲಾ ಪೂರ್ವಪ್ರತ್ಯಯಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ \/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n","canonical_solution":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of all prefixes from shortest to longest of the input string\n\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n    var prefixes []string\n    for i := 1; i <= len(myString); i++ {\n        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n}\n\nfunc TestAllPrefixes(t *testing.T) {\n    result := all_prefixes(\"abc\")\n    expected := []string{\"a\", \"ab\", \"abc\"}\n    for i, v := range result {\n        if v != expected[i] {\n            t.Errorf(\"Test failed, expected %v, got %v\", expected[i], v)\n        }\n    }\n    fmt.Println(\"Test passed\")\n}","tests":"func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_15","nl":"kan_Knda","pl":"go_test.go","prompt":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/0 ರಿಂದ n ವರೆಗೆ ಸೇರಿದಂತೆ ಸ್ಥಳ-ನಿರ್ಧರಿತ ಸಂಖ್ಯೆಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ. \/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n","canonical_solution":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n\/\/ Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nfunc string_sequence(n int) string {\n    var parts []string\n    for i := 0; i <= n; i++ {\n        parts = append(parts, fmt.Sprintf(\"%d\", i))\n    }\n    return strings.Join(parts, \" \")\n}\n\nfunc TestStringSequence(t *testing.T) {\n    result := string_sequence(0)\n    expected := \"0\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n    \n    result = string_sequence(5)\n    expected = \"0 1 2 3 4 5\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n}","tests":"func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_16","nl":"kan_Knda","pl":"go_test.go","prompt":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ನೀಡಿದರೆ, ಎಷ್ಟು ವಿಭಿನ್ನ ಅಕ್ಷರಗಳನ್ನು (ಪ್ರಕರಣವನ್ನು ಲೆಕ್ಕಿಸದೆ) ಇದು ಒಳಗೊಂಡಿದೆ ಎಂದು ಕಂಡುಹಿಡಿಯಿರಿ\/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunc count_distinct_characters(myString string) int {\n","canonical_solution":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc count_distinct_characters(myString string) int {\n    characterMap := make(map[rune]bool)\n    for _, char := range strings.ToLower(myString) {\n        characterMap[char] = true\n    }\n    return len(characterMap)\n}\n\nfunc TestCountDistinctCharacters(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected int\n    }{\n        {\"xyzXYZ\", 3},\n        {\"Jerry\", 4},\n        {\"\", 0},\n        {\"Hello, World!\", 10},\n    }\n\n    for _, testCase := range testCases {\n        result := count_distinct_characters(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", testCase.input, testCase.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input '%s': got %d\\n\", testCase.input, result)\n        }\n    }\n}","tests":"func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_17","nl":"kan_Knda","pl":"go_test.go","prompt":"package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/'ಹ್ಯಾಕ್' - ಕ್ವಾರ್ಟರ್ ನೋಟ್, ಒಂದು ಬೀಟ್ ಅನ್ನು ಹೊಂದಿದೆ.\/\/'ಓ ಛೇ' - ಅರ್ಧ ನೋಟ್, ಎರಡು ಬೀಟ್ಸ್ \/\/'ಒ' - ಸಂಪೂರ್ಣ ಟಿಪ್ಪಣಿ, ನಾಲ್ಕು ಬೀಟ್ಸ್ \/\/ಇಲ್ಲಿ ಒಂದು ದಂತಕಥೆ ಇದೆ: \/\/ಕೊನೆಯದಲ್ಲ.\/\/ನಿಮ್ಮ ಕಾರ್ಯವು ಈ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಪಾರ್ಸ್ ಮಾಡುವುದು ಮತ್ತು ಪ್ರತಿ ಎಷ್ಟು ಬೀಟ್ಗಳಿಗೆ ಅನುಗುಣವಾಗಿ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುವುದು \/\/ಈ ಕಾರ್ಯಕ್ಕೆ ಇನ್ಪುಟ್ ವಿಶೇಷ ASCII ಸ್ವರೂಪದಲ್ಲಿ ಸಂಗೀತದ ಟಿಪ್ಪಣಿಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.\/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n","canonical_solution":"package parse_music_test\n\nimport (\n    \"strings\"\n)\n\nfunc parse_music(music_string string) []int {\n    notes := strings.Fields(music_string)\n    beats := make([]int, len(notes))\n    for i, note := range notes {\n        switch note {\n        case \"o\":\n            beats[i] = 4\n        case \"o|\":\n            beats[i] = 2\n        case \".|\":\n            beats[i] = 1\n        }\n    }\n    return beats\n}","tests":"func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_18","nl":"kan_Knda","pl":"go_test.go","prompt":"package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಮೂಲ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿ ನಿರ್ದಿಷ್ಟ ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಎಷ್ಟು ಬಾರಿ ಕಂಡುಬರುತ್ತದೆ ಎಂಬುದನ್ನು ಕಂಡುಹಿಡಿಯಿರಿ. ಅತಿಕ್ರಮಿಸುವ ಪ್ರಕರಣಗಳನ್ನು ಎಣಿಸಿ.\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunc how_many_times(myString string, substring string) int {\n","canonical_solution":"func how_many_times(myString string, substring string) int {\n    if len(substring) == 0 {\n        return 0\n    }\n\n    count := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHowManyTimes(t *testing.T) {\n    tests := []struct {\n        myString  string\n        substring string\n        expected  int\n    }{\n        {\"\", \"a\", 0},\n        {\"aaa\", \"a\", 3},\n        {\"aaaa\", \"aa\", 3},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%s in %s\", test.substring, test.myString), func(t *testing.T) {\n            result := how_many_times(test.myString, test.substring)\n            if result != test.expected {\n                t.Errorf(\"Expected %d but got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_19","nl":"kan_Knda","pl":"go_test.go","prompt":"package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಚಿಕ್ಕದರಿಂದ ದೊಡ್ಡದಕ್ಕೆ ವಿಂಗಡಿಸಲಾದ ಸಂಖ್ಯೆಗಳೊಂದಿಗೆ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿ \/\/ಮಾನ್ಯ ಆಯ್ಕೆಗಳು 'ಶೂನ್ಯ', 'ಒಂದು', 'ಎರಡು', 'ಮೂರು', 'ನಾಲ್ಕು', 'ಐದು', 'ಆರು', 'ಏಳು', 'ಎಂಟು' ಮತ್ತು 'ಒಂಬತ್ತು'. \/\/ಇನ್ಪುಟ್ ಎಂಬುದು 'ಶೂನ್ಯ'ದಿಂದ 'ಒಂಬತ್ತು' ವರೆಗಿನ ಸಂಖ್ಯೆಗಳ ಸ್ಥಳ-ನಿರ್ಧರಿತ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunc sort_numbers(numbers string) string {\n","canonical_solution":"package sort_numbers_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc sort_numbers(numbers string) string {\n    wordsToNumbers := map[string]int{\n        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n        \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\":   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n    }\n    \n    numbersToWords := []string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    \n    words := strings.Fields(numbers)\n    numberInts := make([]int, len(words))\n    \n    for i, word := range words {\n        numberInts[i] = wordsToNumbers[word]\n    }\n    \n    sort.Ints(numberInts)\n    \n    sortedWords := make([]string, len(words))\n    for i, num := range numberInts {\n        sortedWords[i] = numbersToWords[num]\n    }\n    \n    return strings.Join(sortedWords, \" \")\n}","tests":"func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_20","nl":"kan_Knda","pl":"go_test.go","prompt":"package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇತರ ಮತ್ತು ಅವುಗಳನ್ನು ಕ್ರಮದಲ್ಲಿ ಹಿಂತಿರುಗಿ (ಸಣ್ಣ ಸಂಖ್ಯೆ, ದೊಡ್ಡ ಸಂಖ್ಯೆ).\/\/ಒದಗಿಸಲಾದ ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯಿಂದ (ಕನಿಷ್ಠ ಎರಡು ಉದ್ದದ) ಪ್ರತಿ ಒಂದಕ್ಕೆ ಹತ್ತಿರವಿರುವ ಎರಡು ಸಂಖ್ಯೆಗಳನ್ನು ಆಯ್ಕೆಮಾಡಿ ಮತ್ತು ಹಿಂತಿರುಗಿ \/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\/\/ []interface{}{2.0, 2.2}\n\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n\/\/ []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n","canonical_solution":"package find_closest_elements_test\n\nimport (\n    \"math\"\n    \"sort\"\n)\n\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n    \n    \/\/ Create a sorted copy of the numbers\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n    \n    \/\/ Initialize the minimum difference and result\n    minDiff := math.MaxFloat64\n    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}\n    \n    \/\/ Iterate over the sorted numbers to find the closest pair\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            result[0] = sortedNumbers[i-1]\n            result[1] = sortedNumbers[i]\n        }\n    }\n    \n    return result\n}","tests":"func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_21","nl":"kan_Knda","pl":"go_test.go","prompt":"package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಆದ್ದರಿಂದ ಚಿಕ್ಕದಾದ ಸಂಖ್ಯೆ 0 ಆಗುತ್ತದೆ ಮತ್ತು ದೊಡ್ಡದು 1 ಆಗುತ್ತದೆ \/\/ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ (ಕನಿಷ್ಠ ಎರಡು ಅಂಶಗಳ), ಆ ಪಟ್ಟಿಗೆ ರೇಖೀಯ ಪರಿವರ್ತನೆಯನ್ನು ಅನ್ವಯಿಸಿ,\/\/ >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\/\/ []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n","canonical_solution":"package rescale_to_unit_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n\tif len(numbers) < 2 {\n\t\treturn numbers\n\t}\n\t\n\tminVal := numbers[0]\n\tmaxVal := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < minVal {\n\t\t\tminVal = num\n\t\t} else if num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\n\tscale := maxVal - minVal\n\tif scale == 0 {\n\t\treturn make([]float64, len(numbers))\n\t}\n\n\trescaled := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\trescaled[i] = (num - minVal) \/ scale\n\t}\n\n\treturn rescaled\n}\n\nfunc TestRescaleToUnit(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},\n\t\t{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},\n\t\t{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := rescale_to_unit(test.input)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","tests":"func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_22","nl":"kan_Knda","pl":"go_test.go","prompt":"package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪೂರ್ಣಾಂಕಗಳಿಗೆ ಮಾತ್ರ ಯಾವುದೇ ಗೋಥಾನ್ ಮೌಲ್ಯಗಳ ಪಟ್ಟಿಯನ್ನು ಫಿಲ್ಟರ್ ಮಾಡಿ\/\/ >>> filter_integers([]float64{\"a\", 3.14, 5})\n\/\/ []int{5}\n\/\/ >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n\/\/ []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n","canonical_solution":"func filter_integers(values []interface{}) []int {\n    var result []int\n    for _, v := range values {\n        if intValue, ok := v.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n\nfunc TestFilterIntegers(t *testing.T) {\n    cases := []struct {\n        input    []interface{}\n        expected []int\n    }{\n        {\n            input:    []interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n            expected: []int{1, 2, 3},\n        },\n        {\n            input:    []interface{}{\"a\", 3.14, 5},\n            expected: []int{5},\n        },\n    }\n\n    for _, c := range cases {\n        result := filter_integers(c.input)\n        if !equal(result, c.expected) {\n            t.Errorf(\"filter_integers(%v) == %v, expected %v\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_23","nl":"kan_Knda","pl":"go_test.go","prompt":"package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಕೊಟ್ಟಿರುವ ಸ್ಟ್ರಿಂಗ್ನ ರಿಟರ್ನ್ ಉದ್ದ \/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunc strlen(myString string) int {\n","canonical_solution":"return len(myString)\n}","tests":"func TestStrlen(t *testing.T) {\n  candidate := strlen\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"x\"), expected: 1 },\n     { actual: candidate(\"asdasnakj\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_24","nl":"kan_Knda","pl":"go_test.go","prompt":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಒಂದು ನಿರ್ದಿಷ್ಟ ಸಂಖ್ಯೆಯ n ಗಾಗಿ, n ಗಿಂತ ಚಿಕ್ಕದಾದ, n ಅನ್ನು ಸಮವಾಗಿ ವಿಭಜಿಸುವ ದೊಡ್ಡ ಸಂಖ್ಯೆಯನ್ನು ಹುಡುಕಿ \/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n","canonical_solution":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n    for i := n\/2; i > 0; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}\n\nfunc TestLargestDivisor(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {15, 5},\n        {100, 50},\n        {49, 7},\n        {81, 27},\n        {1, 1},\n    }\n\n    for _, c := range cases {\n        result := largest_divisor(c.input)\n        if result != c.expected {\n            t.Errorf(\"largest_divisor(%d) == %d, expected %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(largest_divisor(15))\n}","tests":"func TestLargest_Divisor(t *testing.T) {\n  candidate := largest_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: 1 },\n     { actual: candidate(7), expected: 1 },\n     { actual: candidate(10), expected: 5 },\n     { actual: candidate(100), expected: 50 },\n     { actual: candidate(49), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_25","nl":"kan_Knda","pl":"go_test.go","prompt":"package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇನ್ಪುಟ್ ಸಂಖ್ಯೆ ಎಲ್ಲಾ ಅಂಶಗಳ ಉತ್ಪನ್ನಕ್ಕೆ ಸಮಾನವಾಗಿರಬೇಕು \/\/ಪ್ರತಿಯೊಂದು ಅಂಶವನ್ನು ಎಷ್ಟು ಬಾರಿ ಅಂಶೀಕರಣದಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತದೆ ಎಂಬುದಕ್ಕೆ ಅನುಗುಣವಾಗಿ ಪಟ್ಟಿ ಮಾಡಬೇಕು.\/\/ಕೊಟ್ಟಿರುವ ಪೂರ್ಣಾಂಕದ ಅವಿಭಾಜ್ಯ ಅಂಶಗಳ ಪಟ್ಟಿಯನ್ನು ಚಿಕ್ಕದರಿಂದ ದೊಡ್ಡದರವರೆಗೆ ಕ್ರಮದಲ್ಲಿ ಹಿಂತಿರುಗಿ.\/\/ >>> factorize(8)\n\/\/ []int{2, 2, 2}\n\/\/ >>> factorize(25)\n\/\/ []int{5, 5}\n\/\/ >>> factorize(70)\n\/\/ []int{2, 5, 7}\nfunc factorize(n int) []int {\n","canonical_solution":"package factorize\n\nfunc factorize(n int) []int {\n\tvar factors []int\n\tfor i := 2; i*i <= n; i++ {\n\t\tfor n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn \/= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}","tests":"func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_26","nl":"kan_Knda","pl":"go_test.go","prompt":"package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇನ್ಪುಟ್ನಲ್ಲಿರುವಂತೆ ಎಡಭಾಗದ ಅಂಶಗಳ ಕ್ರಮವನ್ನು ಇಟ್ಟುಕೊಳ್ಳಿ.\/\/ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯಿಂದ, ಒಂದಕ್ಕಿಂತ ಹೆಚ್ಚು ಬಾರಿ ಸಂಭವಿಸುವ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ತೆಗೆದುಹಾಕಿ.\/\/ >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n\/\/ []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n","canonical_solution":"package remove_duplicates_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc remove_duplicates(numbers []int) []int {\n\tcounts := make(map[int]int)\n\tfor _, num := range numbers {\n\t\tcounts[num]++\n\t}\n\n\tresult := []int{}\n\tfor _, num := range numbers {\n\t\tif counts[num] == 1 {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestRemoveDuplicates(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},\n\t\t{[]int{1, 1, 1, 1}, []int{}},\n\t\t{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},\n\t\t{[]int{5, 5, 5, 6}, []int{6}},\n\t\t{[]int{9, 8, 9, 8, 7}, []int{7}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"remove_duplicates(%v)\", test.input), func(t *testing.T) {\n\t\t\tresult := remove_duplicates(test.input)\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Expected length %d, got %d\", len(test.expected), len(result))\n\t\t\t}\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_27","nl":"kan_Knda","pl":"go_test.go","prompt":"package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ನಿರ್ದಿಷ್ಟ ಸ್ಟ್ರಿಂಗ್ಗಾಗಿ, ಸಣ್ಣ ಅಕ್ಷರಗಳನ್ನು ದೊಡ್ಡಕ್ಷರಕ್ಕೆ ಮತ್ತು ದೊಡ್ಡಕ್ಷರವನ್ನು ಸಣ್ಣಕ್ಷರಕ್ಕೆ ತಿರುಗಿಸಿ.\/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunc flip_case(myString string) string {\n","canonical_solution":"func flip_case(myString string) string {\n\tvar result []rune\n\tfor _, char := range myString {\n\t\tif char >= 'a' && char <= 'z' {\n\t\t\tresult = append(result, char-('a'-'A'))\n\t\t} else if char >= 'A' && char <= 'Z' {\n\t\t\tresult = append(result, char+('a'-'A'))\n\t\t} else {\n\t\t\tresult = append(result, char)\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_28","nl":"kan_Knda","pl":"go_test.go","prompt":"package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯನ್ನು ಒಂದೇ ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಜೋಡಿಸಿ\/\/ >>> concatenate([]string{})\n\/\/ \"\"\n\/\/ >>> concatenate([]string{\"a\", \"b\", \"c\"})\n\/\/ \"abc\"\nfunc concatenate(strings []string) string {\n","canonical_solution":"result := \"\"\n    for _, str := range strings {\n        result += str\n    }\n    return result\n}","tests":"func TestConcatenate(t *testing.T) {\n  candidate := concatenate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}), expected: \"\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\"}), expected: \"xyz\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\", \"w\", \"k\"}), expected: \"xyzwk\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_29","nl":"kan_Knda","pl":"go_test.go","prompt":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ನಿರ್ದಿಷ್ಟ ಪೂರ್ವಪ್ರತ್ಯಯದೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುವ ಸ್ಟ್ರಿಂಗ್ಗಳ ಇನ್ಪುಟ್ ಪಟ್ಟಿಯನ್ನು ಮಾತ್ರ ಫಿಲ್ಟರ್ ಮಾಡಿ.\/\/ >>> filter_by_prefix([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n","canonical_solution":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Filter an input list of strings only for ones that start with a given prefix.\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterByPrefix(t *testing.T) {\n    tests := []struct {\n        input    []string\n        prefix   string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"array\"}},\n        {[]string{\"hello\", \"helium\", \"world\"}, \"he\", []string{\"hello\", \"helium\"}},\n        {[]string{\"banana\", \"band\", \"bandana\"}, \"ban\", []string{\"banana\", \"band\", \"bandana\"}},\n        {[]string{\"apple\", \"ape\", \"apricot\"}, \"ap\", []string{\"apple\", \"ape\", \"apricot\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_prefix(test.input, test.prefix)\n        if !equal(result, test.expected) {\n            t.Errorf(\"filter_by_prefix(%v, %s) = %v; expected %v\", test.input, test.prefix, result, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_By_Prefix(t *testing.T) {\n  candidate := filter_by_prefix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_30","nl":"kan_Knda","pl":"go_test.go","prompt":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸಕಾರಾತ್ಮಕ ಸಂಖ್ಯೆಗಳನ್ನು ಮಾತ್ರ ಹಿಂತಿರುಗಿ.\/\/ >>> get_positive([]int{-1, 2, -4, 5, 6})\n\/\/ []int{2, 5, 6}\n\/\/ >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n","canonical_solution":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return only positive numbers in the list.\nfunc get_positive(l []int) []int {\n    var positiveNumbers []int\n    for _, num := range l {\n        if num > 0 {\n            positiveNumbers = append(positiveNumbers, num)\n        }\n    }\n    return positiveNumbers\n}\n\nfunc TestGetPositive(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},\n    }\n    \n    for _, test := range tests {\n        result := get_positive(test.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.output) {\n            t.Errorf(\"Expected %v, got %v\", test.output, result)\n        }\n    }\n}","tests":"func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1, -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_31","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಕೊಟ್ಟಿರುವ ಸಂಖ್ಯೆಯು ಅವಿಭಾಜ್ಯವಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿ, ಇಲ್ಲದಿದ್ದರೆ false ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunc is_prime(n int) bool {\n","canonical_solution":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_prime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPrime(t *testing.T) {\n    testCases := []struct {\n        number   int\n        expected bool\n    }{\n        {6, false},\n        {101, true},\n        {11, true},\n        {13441, true},\n        {61, true},\n        {4, false},\n        {1, false},\n    }\n\n    for _, testCase := range testCases {\n        result := is_prime(testCase.number)\n        if result != testCase.expected {\n            t.Errorf(\"is_prime(%d) = %v; want %v\", testCase.number, result, testCase.expected)\n        } else {\n            fmt.Printf(\"Test Passed: is_prime(%d) = %v\\n\", testCase.number, result)\n        }\n    }\n}","tests":"func TestIs_Prime(t *testing.T) {\n  candidate := is_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(6), expected: false },\n     { actual: candidate(101), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(13441), expected: true },\n     { actual: candidate(61), expected: true },\n     { actual: candidate(4), expected: false },\n     { actual: candidate(1), expected: false },\n     { actual: candidate(5), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(17), expected: true },\n     { actual: candidate(85), expected: false },\n     { actual: candidate(77), expected: false },\n     { actual: candidate(255379), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_33","nl":"kan_Knda","pl":"go_test.go","prompt":"package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/l ನ ಅನುಗುಣವಾದ ಸೂಚ್ಯಂಕಗಳ ಮೌಲ್ಯಗಳಿಗೆ, ಆದರೆ ವಿಂಗಡಿಸಲಾಗಿದೆ.\/\/l' ಮೂರು ಭಾಗಿಸಬಹುದಾದ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ l ಗೆ ಒಂದೇ ಆಗಿರುತ್ತದೆ, ಆದರೆ ಮೂರು ಭಾಗಿಸಬಹುದಾದ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ ಅದರ ಮೌಲ್ಯಗಳು ಸಮಾನವಾಗಿರುತ್ತದೆ \/\/ಈ ಕಾರ್ಯವು ಒಂದು ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು ಒಂದು ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ l ' ಅಂತಹ \/\/ >>> sort_third([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n\/\/ []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n","canonical_solution":"package sort_third_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_third(l []int) []int {\n    type pair struct {\n        index int\n        value int\n    }\n\n    \/\/ Collect the pairs where indices are divisible by 3\n    sortSection := []pair{}\n\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            sortSection = append(sortSection, pair{index: i, value: l[i]})\n        }\n    }\n\n    \/\/ Sort this section based on the values\n    sort.Slice(sortSection, func(i, j int) bool {\n        return sortSection[i].value < sortSection[j].value\n    })\n\n    \/\/ Generate result slice\n    result := make([]int, len(l))\n    copy(result, l)\n\n    \/\/ Fill the sorted values back to the result\n    for _, p := range sortSection {\n        result[p.index] = p.value\n    }\n\n    return result\n}","tests":"func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_34","nl":"kan_Knda","pl":"go_test.go","prompt":"package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿ ವಿಂಗಡಿಸಲಾದ ಅನನ್ಯ ಅಂಶಗಳನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ\/\/ >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n","canonical_solution":"package unique_test\n\nimport (\n    \"sort\"\n)\n\nfunc unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, value := range l {\n        uniqueMap[value] = true\n    }\n\n    uniqueSlice := make([]int, 0, len(uniqueMap))\n    for key := range uniqueMap {\n        uniqueSlice = append(uniqueSlice, key)\n    }\n\n    sort.Ints(uniqueSlice)\n    return uniqueSlice\n}","tests":"func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_35","nl":"kan_Knda","pl":"go_test.go","prompt":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪಟ್ಟಿಯಲ್ಲಿನ ಗರಿಷ್ಠ ಅಂಶವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n","canonical_solution":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return maximum element in the list.\n\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n    if len(l) == 0 {\n        panic(\"Empty list has no maximum value\")\n    }\n    max := l[0]\n    for _, value := range l {\n        if value > max {\n            max = value\n        }\n    }\n    return max\n}\n\nfunc TestMaxElement(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 3},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},\n        {[]int{-1, -2, -3, -4}, -1},\n        {[]int{9, 9, 9, 9}, 9},\n    }\n\n    for _, testCase := range testCases {\n        result := max_element(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %v, expected %d, got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}","tests":"func TestMax_Element(t *testing.T) {\n  candidate := max_element\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 3 },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_36","nl":"kan_Knda","pl":"go_test.go","prompt":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/11 ಅಥವಾ 13 ರ ಮೂಲಕ ಭಾಗಿಸಬಹುದಾದ n ಗಿಂತ ಕಡಿಮೆ ಪೂರ್ಣಾಂಕಗಳಲ್ಲಿ 7 ಅಂಕಿಯು ಕಾಣಿಸಿಕೊಳ್ಳುವ ಬಾರಿ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunc fizz_buzz(n int) int {\n","canonical_solution":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 0; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += countSevens(i)\n        }\n    }\n    return count\n}\n\nfunc countSevens(num int) int {\n    strNum := strconv.Itoa(num)\n    count := 0\n    for _, c := range strNum {\n        if c == '7' {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestFizzBuzz(t *testing.T) {\n    tests := []struct {\n        input int\n        expected int\n    }{\n        {50, 0},\n        {78, 2},\n        {79, 3},\n    }\n\n    for _, test := range tests {\n        result := fizz_buzz(test.input)\n        if result != test.expected {\n            t.Errorf(\"fizz_buzz(%d) = %d; expected %d\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(fizz_buzz(50)) \/\/ 0\n    fmt.Println(fizz_buzz(78)) \/\/ 2\n    fmt.Println(fizz_buzz(79)) \/\/ 3\n}","tests":"func TestFizz_Buzz(t *testing.T) {\n  candidate := fizz_buzz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(50), expected: 0 },\n     { actual: candidate(78), expected: 2 },\n     { actual: candidate(79), expected: 3 },\n     { actual: candidate(100), expected: 3 },\n     { actual: candidate(200), expected: 6 },\n     { actual: candidate(4000), expected: 192 },\n     { actual: candidate(10000), expected: 639 },\n     { actual: candidate(100000), expected: 8026 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_37","nl":"kan_Knda","pl":"go_test.go","prompt":"package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/l ನ ಸಮ ಸೂಚ್ಯಂಕಗಳ ಮೌಲ್ಯಗಳಿಗೆ, ಆದರೆ ವಿಂಗಡಿಸಲಾಗಿದೆ.\/\/l' ಅಪರೂಪದ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ l ಗೆ ಒಂದೇ ಆಗಿರುತ್ತದೆ, ಆದರೆ ಸಮ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ ಅದರ ಮೌಲ್ಯಗಳು ಸಮಾನವಾಗಿರುತ್ತದೆ \/\/ಈ ಕಾರ್ಯವು ಒಂದು ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು ಒಂದು ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ l ' ಅಂತಹ \/\/ >>> sort_even([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_even([]int{5, 6, 3, 4})\n\/\/ []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n","canonical_solution":"package sort_even_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_even(l []int) []int {\n    if len(l) < 2 {\n        return l\n    }\n    \n    \/\/ Extract even indices\n    evens := []int{}\n    for i := 0; i < len(l); i += 2 {\n        evens = append(evens, l[i])\n    }\n    \n    \/\/ Sort even-indexed elements\n    sort.Ints(evens)\n    \n    \/\/ Merge sorted evens back into the original list\n    j := 0\n    for i := 0; i < len(l); i += 2 {\n        l[i] = evens[j]\n        j++\n    }\n\n    return l\n}","tests":"func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_39","nl":"kan_Knda","pl":"go_test.go","prompt":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/prime_fib ಒಂದು ಫೈಬೊನಾಕಿ ಸಂಖ್ಯೆಯಾಗಿರುವ n-ನೇ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ ಮತ್ತು ಅದು ಸಹ ಅವಿಭಾಜ್ಯವಾಗಿರುತ್ತದೆ.\/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunc prime_fib(n int) int {\n","canonical_solution":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ isPrime checks if a number is prime\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    if num <= 3 {\n        return true\n    }\n    if num%2 == 0 || num%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= num; i += 6 {\n        if num%i == 0 || num%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfunc prime_fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    a, b := 1, 1\n    count := 0\n    for count < n {\n        a, b = b, a+b\n        if isPrime(a) {\n            count++\n        }\n    }\n    return a\n}\n\nfunc TestPrimeFib(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {1, 2},\n        {2, 3},\n        {3, 5},\n        {4, 13},\n        {5, 89},\n    }\n\n    for _, test := range tests {\n        result := prime_fib(test.input)\n        if result != test.expected {\n            t.Errorf(\"prime_fib(%d) = %d; expected %d\", test.input, result, test.expected)\n        } else {\n            fmt.Printf(\"prime_fib(%d) = %d\\n\", test.input, result)\n        }\n    }\n}","tests":"func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2), expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4), expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual: candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected: 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_40","nl":"kan_Knda","pl":"go_test.go","prompt":"package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಮೊತ್ತವು ಶೂನ್ಯಕ್ಕೆ, ಮತ್ತು ಸುಳ್ಳು ಇಲ್ಲದಿದ್ದರೆ.\/\/ಇದು  ಎಂದು ಪಟ್ಟಿಯಲ್ಲಿ ಮೂರು ವಿಭಿನ್ನ ಅಂಶಗಳು ಇದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ\/\/triples_sum_to_zero ಒಂದು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ.\/\/ >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1})\n\/\/ false\nfunc triples_sum_to_zero(l []int) bool {\n","canonical_solution":"func triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    if n < 3 {\n        return false\n    }\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}\n\nfunc TestTriplesSumToZero(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, true},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 9, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, test := range tests {\n        result := triples_sum_to_zero(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %v, expected %v, got %v\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1}))              \/\/ false\n}","tests":"func TestTriples_Sum_To_Zero(t *testing.T) {\n  candidate := triples_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -1}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{1, 2, 5, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -100}), expected: false },\n     { actual: candidate([]int{100, 3, 5, -100}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_41","nl":"kan_Knda","pl":"go_test.go","prompt":"package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಈ ಕಾರ್ಯವು ಇಂತಹ ಘರ್ಷಣೆಗಳ ಸಂಖ್ಯೆಯನ್ನು ಔಟ್ಪುಟ್ ಮಾಡುತ್ತದೆ.\/\/ಅವುಗಳ ಪಥದಲ್ಲಿ ಅವು ಘರ್ಷಣೆ ಮಾಡದಿದ್ದಂತೆ.\/\/ಆದರೆ, ಈ ಕಾರುಗಳು ಅಪಾರವಾದ ಬಲವನ್ನು ಹೊಂದಿವೆ; ಇದರ ಪರಿಣಾಮವಾಗಿ, ಅವು ಚಲಿಸುತ್ತಲೇ ಇರುತ್ತವೆ.\/\/ಎಡದಿಂದ ಬಲಕ್ಕೆ ಚಲಿಸುವ ಕಾರು ಬಲದಿಂದ ಎಡಕ್ಕೆ ಚಲಿಸುವ ಕಾರು ಹೊಡೆದಾಗ.\/\/ಎಲ್ಲಾ ಕಾರುಗಳು ಒಂದೇ ವೇಗದಲ್ಲಿ ಚಲಿಸುತ್ತವೆ. ಎರಡು ಕಾರುಗಳು ಘರ್ಷಣೆಗೊಳ್ಳುತ್ತವೆ ಎಂದು ಹೇಳಲಾಗುತ್ತದೆ.\/\/ಎಡದಿಂದ ಬಲಕ್ಕೆ ಚಲಿಸುತ್ತಿದೆ. ಎರಡು ಕಾರುಗಳ ಜೋಡಿಗಳು ಪ್ರಾರಂಭವಾಗುವುದು \/\/n ಕಾರುಗಳು ಎಡದಿಂದ ಬಲಕ್ಕೆ ಚಲಿಸುತ್ತಿವೆ; ಏಕಕಾಲದಲ್ಲಿ, n ಕಾರುಗಳ ವಿಭಿನ್ನ ಸೆಟ್ \/\/ಒಂದು ರಸ್ತೆಯನ್ನು ಕಲ್ಪಿಸಿಕೊಳ್ಳಿ ಅದು ಪರಿಪೂರ್ಣವಾದ ನೇರ ಅನಂತ ಉದ್ದದ ರೇಖೆಯಾಗಿದೆ.func car_race_collision(n int) int {\n","canonical_solution":"package car_race_collision_test\n\nimport (\n    \"testing\"\n)\n\nfunc car_race_collision(n int) int {\n    return n\n}\n\nfunc TestCarRaceCollision(t *testing.T) {\n    cases := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 2},\n        {3, 3},\n        {10, 10},\n        {0, 0},\n    }\n\n    for _, c := range cases {\n        result := car_race_collision(c.n)\n        if result != c.expected {\n            t.Errorf(\"car_race_collision(%d) == %d, expected %d\", c.n, result, c.expected)\n        }\n    }\n}","tests":"func TestCar_Race_Collision(t *testing.T) {\n  candidate := car_race_collision\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 4 },\n     { actual: candidate(3), expected: 9 },\n     { actual: candidate(4), expected: 16 },\n     { actual: candidate(8), expected: 64 },\n     { actual: candidate(10), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_42","nl":"kan_Knda","pl":"go_test.go","prompt":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/1 ರಷ್ಟು ಹೆಚ್ಚಿಸಿದ ಅಂಶಗಳೊಂದಿಗೆ ರಿಟರ್ನ್ ಪಟ್ಟಿ.\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n","canonical_solution":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list with elements incremented by 1.\n\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n    result := make([]int, len(l))\n    for i, val := range l {\n        result[i] = val + 1\n    }\n    return result\n}\n\nfunc TestIncrList(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3}, []int{2, 3, 4}},\n        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},\n    }\n\n    for _, c := range cases {\n        result := incr_list(c.input)\n        for i := range result {\n            if result[i] != c.expected[i] {\n                t.Errorf(\"incr_list(%v) == %v, expected %v\", c.input, result, c.expected)\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(incr_list([]int{1, 2, 3}))          \/\/ should print [2, 3, 4]\n    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) \/\/ should print [6, 4, 6, 3, 4, 4, 10, 1, 124]\n}","tests":"func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_43","nl":"kan_Knda","pl":"go_test.go","prompt":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಮೊತ್ತವು ಶೂನ್ಯಕ್ಕೆ, ಮತ್ತು ಸುಳ್ಳು ಇಲ್ಲದಿದ್ದರೆ.\/\/ಇದು  ಎಂದು ಪಟ್ಟಿಯಲ್ಲಿ ಎರಡು ವಿಭಿನ್ನ ಅಂಶಗಳು ಇದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ\/\/pairs_sum_to_zero ಒಂದು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ.\/\/ >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([]int{1})\n\/\/ false\nfunc pairs_sum_to_zero(l []int) bool {\n","canonical_solution":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pairs_sum_to_zero(l []int) bool {\n    numSet := make(map[int]struct{})\n    for _, num := range l {\n        if _, found := numSet[-num]; found {\n            return true\n        }\n        numSet[num] = struct{}{}\n    }\n    return false\n}\n\nfunc TestPairsSumToZero(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, false},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 5, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, tc := range testCases {\n        result := pairs_sum_to_zero(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"pairs_sum_to_zero(%v) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %v, result: %v\\n\", tc.input, result)\n        }\n    }\n}","tests":"func TestPairs_Sum_To_Zero(t *testing.T) {\n  candidate := pairs_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_44","nl":"kan_Knda","pl":"go_test.go","prompt":"package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಮೂಲ ಸಂಖ್ಯೆಗಳು 10 ಕ್ಕಿಂತ ಕಡಿಮೆ.\/\/ಪರಿವರ್ತನೆಯ ನಂತರ ಸ್ಟ್ರಿಂಗ್ ಪ್ರಾತಿನಿಧ್ಯವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಇನ್ಪುಟ್ ಸಂಖ್ಯೆಯ x ನ ಸಂಖ್ಯಾ ಆಧಾರವನ್ನು ಆಧಾರಕ್ಕೆ ಬದಲಾಯಿಸಿ.\/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunc change_base(x int, base int) string {\n","canonical_solution":"package change_base_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc change_base(x int, base int) string {\n    if base < 2 || base > 9 {\n        return \"\"\n    }\n\n    result := \"\"\n    for x > 0 {\n        remainder := x % base\n        result = strconv.Itoa(remainder) + result\n        x = x \/ base\n    }\n    \n    if result == \"\" {\n        return \"0\"\n    }\n    return result\n}\n\nfunc TestChangeBase(t *testing.T) {\n    tests := []struct {\n        x      int\n        base   int\n        result string\n    }{\n        {8, 3, \"22\"},\n        {8, 2, \"1000\"},\n        {7, 2, \"111\"},\n        {0, 2, \"0\"},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d to base %d\", test.x, test.base), func(t *testing.T) {\n            res := change_base(test.x, test.base)\n            if res != test.result {\n                t.Errorf(\"expected %s, got %s\", test.result, res)\n            }\n        })\n    }\n}","tests":"func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9, 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\" },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8, 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3, 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n     { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6, 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_45","nl":"kan_Knda","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಒಂದು ತ್ರಿಕೋನಕ್ಕೆ ಒಂದು ಬದಿಯ ಉದ್ದ ಮತ್ತು ಹೆಚ್ಚಿನ ರಿಟರ್ನ್ ಪ್ರದೇಶವನ್ನು ನೀಡಲಾಗಿದೆ.\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given length of a side and height return area for a triangle.\n\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n    return 0.5 * float64(a) * float64(h)\n}\n\nfunc TestTriangleArea(t *testing.T) {\n    cases := []struct {\n        a, h int\n        expected float64\n    }{\n        {5, 3, 7.5},\n        {6, 4, 12.0},\n        {10, 2, 10.0},\n        {8, 5, 20.0},\n    }\n    \n    for _, c := range cases {\n        result := triangle_area(c.a, c.h)\n        if result != c.expected {\n            t.Errorf(\"triangle_area(%d, %d) == %f, expected %f\", c.a, c.h, result, c.expected)\n        } else {\n            fmt.Printf(\"triangle_area(%d, %d) == %f\\n\", c.a, c.h, result)\n        }\n    }\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 3), expected: 7.5 },\n     { actual: candidate(2, 2), expected: 2.0 },\n     { actual: candidate(10, 8), expected: 40.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_46","nl":"kan_Knda","pl":"go_test.go","prompt":"package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/fib4 ಸಂಖ್ಯೆಗಳ ಅನುಕ್ರಮದ n-ನೇ ಅಂಶವನ್ನು ಸಮರ್ಥವಾಗಿ ಲೆಕ್ಕಾಚಾರ ಮಾಡಲು ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ. ಪುನರಾವರ್ತನೆಯನ್ನು ಬಳಸಬೇಡಿ.\/\/fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \/\/fib4(3) -> 0 \/\/fib4(2) -> 2 \/\/fib4(1) -> 0 \/\/fib4(0) -> 0 \/\/Fib4 ಸಂಖ್ಯೆಯ ಅನುಕ್ರಮವು ಫೈಬೊನಾಕಿ ಅನುಕ್ರಮಕ್ಕೆ ಹೋಲುತ್ತದೆ, ಇದನ್ನು ಈ ಕೆಳಗಿನಂತೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ:\/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunc fib4(n int) int {\n","canonical_solution":"func fib4(n int) int {\n    if n < 0 {\n        return 0\n    }\n    \n    seq := []int{0, 0, 2, 0}\n    \n    if n < 4 {\n        return seq[n]\n    }\n    \n    for i := 4; i <= n; i++ {\n        next := seq[0] + seq[1] + seq[2] + seq[3]\n        seq[0] = seq[1]\n        seq[1] = seq[2]\n        seq[2] = seq[3]\n        seq[3] = next\n    }\n    \n    return seq[3]\n}","tests":"func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_47","nl":"kan_Knda","pl":"go_test.go","prompt":"package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪಟ್ಟಿಯಲ್ಲಿನ ಅಂಶಗಳ ಮಧ್ಯಮವನ್ನು ಹಿಂತಿರುಗಿ l. \/\/ >>> median([]int{3, 1, 2, 4, 5})\n\/\/ 3\n\/\/ >>> median([]int{-10, 4, 6, 1000, 10, 20})\n\/\/ 15.0\nfunc median(l []int) float64 {\n","canonical_solution":"package median_test\n\nimport (\n    \"sort\"\n)\n\nfunc median(l []int) float64 {\n    sort.Ints(l)\n    n := len(l)\n    if n%2 == 1 {\n        return float64(l[n\/2])\n    }\n    mid1, mid2 := l[(n\/2)-1], l[n\/2]\n    return float64(mid1+mid2) \/ 2.0\n}","tests":"func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}), expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_48","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಕೊಟ್ಟಿರುವ ಸ್ಟ್ರಿಂಗ್ ಪಾಲಿಂಡ್ರೋಮ್ ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸುತ್ತದೆ \/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunc is_palindrome(text string) bool {\n","canonical_solution":"package is_palindrome_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    n := len(text)\n    for i := 0; i < n\/2; i++ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"\", true},\n        {\"aba\", true},\n        {\"aaaaa\", true},\n        {\"zbcd\", false},\n    }\n\n    for _, test := range tests {\n        result := is_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_49","nl":"kan_Knda","pl":"go_test.go","prompt":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/2^n modulo p ಅನ್ನು ಹಿಂತಿರುಗಿ (ಸಂಖ್ಯೆಗಳ ಬಗ್ಗೆ ತಿಳಿದಿರಲಿ).\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunc modp(n int, p int) int {\n","canonical_solution":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return 2^n modulo p (be aware of numerics).\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n    }\n    result := 1\n    base := 2\n    for n > 0 {\n        if n%2 == 1 {\n            result = (result * base) % p\n        }\n        base = (base * base) % p\n        n \/= 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n    tests := []struct {\n        n, p int\n        expected int\n    }{\n        {3, 5, 3},\n        {1101, 101, 2},\n        {0, 101, 1},\n        {3, 11, 8},\n        {100, 101, 1},\n    }\n\n    for _, test := range tests {\n        result := modp(test.n, test.p)\n        if result != test.expected {\n            t.Errorf(\"modp(%d, %d) = %d; expected %d\", test.n, test.p, result, test.expected)\n        } else {\n            fmt.Printf(\"modp(%d, %d) = %d; passed\\n\", test.n, test.p, result)\n        }\n    }\n}","tests":"func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_51","nl":"kan_Knda","pl":"go_test.go","prompt":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/remove_vowels ಎನ್ನುವುದು ಸ್ವರಗಳಿಲ್ಲದ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವಾಗಿದೆ.\/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunc remove_vowels(text string) string {\n","canonical_solution":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc remove_vowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    var result strings.Builder\n    for _, char := range text {\n        if !strings.ContainsRune(vowels, char) {\n            result.WriteRune(char)\n        }\n    }\n    return result.String()\n}\n\nfunc TestRemoveVowels(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"abcdef\", \"bcdf\"},\n        {\"aaaaa\", \"\"},\n        {\"aaBAA\", \"B\"},\n        {\"zbcd\", \"zbcd\"},\n    }\n\n    for _, test := range tests {\n        if output := remove_vowels(test.input); output != test.expected {\n            t.Errorf(\"remove_vowels(%q) = %q; expected %q\", test.input, output, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    test := &testing.T{}\n    TestRemoveVowels(test)\n    if test.Failed() {\n        fmt.Println(\"Tests failed!\")\n    } else {\n        fmt.Println(\"All tests passed!\")\n    }\n}","tests":"func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual: candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_52","nl":"kan_Knda","pl":"go_test.go","prompt":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪಟ್ಟಿಯಲ್ಲಿನ ಎಲ್ಲಾ ಸಂಖ್ಯೆಗಳು ಮಿತಿ t ಗಿಂತ ಕೆಳಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> below_threshold([]int{1, 2, 4, 10}, 100)\n\/\/ true\n\/\/ >>> below_threshold([]int{1, 20, 4, 10}, 5)\n\/\/ false\nfunc below_threshold(l []int, t int) bool {\n","canonical_solution":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if all numbers in the list l are below threshold t.\nfunc below_threshold(l []int, t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ Example test cases\nfunc TestBelowThreshold(t *testing.T) {\n    if !below_threshold([]int{1, 2, 4, 10}, 100) {\n        t.Error(\"Expected true, got false\")\n    }\n    if below_threshold([]int{1, 20, 4, 10}, 5) {\n        t.Error(\"Expected false, got true\")\n    }\n}\n\nfunc main() {\n    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) \/\/ true\n    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  \/\/ false\n}","tests":"func TestBelow_Threshold(t *testing.T) {\n  candidate := below_threshold\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },\n     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_53","nl":"kan_Knda","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/x ಮತ್ತು y ಎಂಬ ಎರಡು ಸಂಖ್ಯೆಗಳನ್ನು ಸೇರಿಸಿ.\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n","canonical_solution":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Add two numbers x and y\n\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc TestAdd(t *testing.T) {\n    testCases := []struct {\n        x, y, expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"add(%d,%d)\", tc.x, tc.y), func(t *testing.T) {\n            result := add(tc.x, tc.y)\n            if result != tc.expected {\n                t.Errorf(\"Expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0, 1), expected: 1 },\n     { actual: candidate(1, 0), expected: 1 },\n     { actual: candidate(2, 3), expected: 5 },\n     { actual: candidate(5, 7), expected: 12 },\n     { actual: candidate(7, 5), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_54","nl":"kan_Knda","pl":"go_test.go","prompt":"package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಎರಡು ಪದಗಳು ಒಂದೇ ಅಕ್ಷರಗಳನ್ನು ಹೊಂದಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunc same_chars(s0 string, s1 string) bool {\n","canonical_solution":"package same_chars_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc same_chars(s0 string, s1 string) bool {\n\tcountChars := func(s string) map[rune]int {\n\t\tcount := make(map[rune]int)\n\t\tfor _, char := range s {\n\t\t\tcount[char]++\n\t\t}\n\t\treturn count\n\t}\n\n\tcount0 := countChars(s0)\n\tcount1 := countChars(s1)\n\n\tfor char := range count0 {\n\t\tif count1[char] < count0[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor char := range count1 {\n\t\tif count0[char] < count1[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc TestSameChars(t *testing.T) {\n\ttests := []struct {\n\t\ts0     string\n\t\ts1     string\n\t\tresult bool\n\t}{\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddeddabc\", true},\n\t\t{\"abcd\", \"dddddddabc\", true},\n\t\t{\"dddddddabc\", \"abcd\", true},\n\t\t{\"eabcd\", \"dddddddabc\", false},\n\t\t{\"abcd\", \"dddddddabce\", false},\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddddabc\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s vs %s\", test.s0, test.s1), func(t *testing.T) {\n\t\t\tif got := same_chars(test.s0, test.s1); got != test.result {\n\t\t\t\tt.Errorf(\"same_chars(%q, %q) = %v; want %v\", test.s0, test.s1, got, test.result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSame_Chars(t *testing.T) {\n  candidate := same_chars\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), expected: true },\n     { actual: candidate(\"abcd\", \"dddddddabc\"), expected: true },\n     { actual: candidate(\"dddddddabc\", \"abcd\"), expected: true },\n     { actual: candidate(\"eabcd\", \"dddddddabc\"), expected: false },\n     { actual: candidate(\"abcd\", \"dddddddabcf\"), expected: false },\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), expected: false },\n     { actual: candidate(\"aabb\", \"aaccc\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_55","nl":"kan_Knda","pl":"go_test.go","prompt":"package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/n-ನೇ ಫಿಬೊನಾಕಿ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂತಿರುಗಿ. \/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunc fib(n int) int {\n","canonical_solution":"if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}","tests":"func TestFib(t *testing.T) {\n  candidate := fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10), expected: 55 },\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(8), expected: 21 },\n     { actual: candidate(11), expected: 89 },\n     { actual: candidate(12), expected: 144 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_56","nl":"kan_Knda","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪ್ರತಿ ಆರಂಭಿಕ ಬ್ರಾಕೆಟ್ಗೆ ಅನುಗುಣವಾದ ಮುಚ್ಚುವ ಬ್ರಾಕೆಟ್ ಇದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಬ್ರಾಕೆಟ್ಸ್ \"<\" ಮತ್ತು \">\" ನ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.\/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '<' {\n            balance++\n        } else if char == '>' {\n            balance--\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected bool\n    }{\n        {input: \"<\", expected: false},\n        {input: \"<>\", expected: true},\n        {input: \"<<><>>\", expected: true},\n        {input: \"><<>\", expected: false},\n        {input: \"<<>>\", expected: true},\n        {input: \"><\", expected: false},\n    }\n\n    for _, tc := range testCases {\n        result := correct_bracketing(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %q\\n\", tc.input)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_57","nl":"kan_Knda","pl":"go_test.go","prompt":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ ಪಟ್ಟಿ ಅಂಶಗಳು ಏಕತಾನತೆಯಿಂದ ಹೆಚ್ಚುತ್ತಿವೆ ಅಥವಾ ಕಡಿಮೆಯಾಗುತ್ತಿವೆ ಎಂದು ನಿಜವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> monotonic([]int{1, 2, 4, 20})\n\/\/ true\n\/\/ >>> monotonic([]int{1, 20, 4, 10})\n\/\/ false\n\/\/ >>> monotonic([]int{4, 1, 0, -10})\n\/\/ true\nfunc monotonic(l []int) bool {\n","canonical_solution":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if list elements are monotonically increasing or decreasing.\nfunc monotonic(l []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    increasing := true\n    decreasing := true\n\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n\nfunc TestMonotonic(t *testing.T) {\n    fmt.Println(monotonic([]int{1, 2, 4, 20})) \/\/ true\n    fmt.Println(monotonic([]int{1, 20, 4, 10})) \/\/ false\n    fmt.Println(monotonic([]int{4, 1, 0, -10})) \/\/ true\n}","tests":"func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_58","nl":"kan_Knda","pl":"go_test.go","prompt":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಎರಡು ಪಟ್ಟಿಗಳ ವಿಂಗಡಿಸಲಾದ ವಿಶಿಷ್ಟ ಸಾಮಾನ್ಯ ಅಂಶಗಳನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n\/\/ []int{1, 5, 653}\n\/\/ >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n\/\/ []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n","canonical_solution":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]struct{})\n    set2 := make(map[int]struct{})\n    commonSet := make(map[int]struct{})\n    \n    \/\/ Fill set1 with elements of l1\n    for _, num := range l1 {\n        set1[num] = struct{}{}\n    }\n    \n    \/\/ Fill set2 with elements of l2\n    for _, num := range l2 {\n        if _, found := set1[num]; found {\n            commonSet[num] = struct{}{}\n        }\n        set2[num] = struct{}{}\n    }\n    \n    result := make([]int, 0, len(commonSet))\n    \n    \/\/ Collect common elements\n    for num := range commonSet {\n        result = append(result, num)\n    }\n    \n    \/\/ Sort the result\n    sort.Ints(result)\n    \n    return result\n}\n\nfunc TestCommon(t *testing.T) {\n    cases := []struct {\n        l1, l2 []int\n        expected []int\n    }{\n        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},\n        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},\n    }\n    \n    for _, c := range cases {\n        result := common(c.l1, c.l2)\n        if !equal(result, c.expected) {\n            t.Errorf(\"common(%v, %v) == %v, expected %v\", c.l1, c.l2, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_59","nl":"kan_Knda","pl":"go_test.go","prompt":"package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/n ನ ಅತಿದೊಡ್ಡ ಅವಿಭಾಜ್ಯ ಅಂಶವನ್ನು ಹಿಂತಿರುಗಿ. n > 1 ಮತ್ತು ಅವಿಭಾಜ್ಯವಲ್ಲ ಎಂದು ಭಾವಿಸಿ. \/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunc largest_prime_factor(n int) int {\n","canonical_solution":"package largest_prime_factor_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc largest_prime_factor(n int) int {\n\tlargestFactor := 1\n\tdiv := 2\n\n\tfor n > 1 {\n\t\tif n%div == 0 {\n\t\t\tlargestFactor = div\n\t\t\tn \/= div\n\t\t} else {\n\t\t\tdiv++\n\t\t}\n\t}\n\n\treturn largestFactor\n}\n\nfunc TestLargestPrimeFactor(t *testing.T) {\n\ttests := []struct{\n\t\tn int\n\t\texpected int\n\t} {\n\t\t{13195, 29},\n\t\t{2048, 2},\n\t\t{123456, 643},\n\t\t{100, 5},\n\t\t{999, 37},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d\", test.n), func(t *testing.T) {\n\t\t\tif result := largest_prime_factor(test.n); result != test.expected {\n\t\t\t\tt.Errorf(\"largest_prime_factor(%d) = %d; expected %d\", test.n, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual: candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195), expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_60","nl":"kan_Knda","pl":"go_test.go","prompt":"package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/sum_to_n ಎನ್ನುವುದು 1 ರಿಂದ n ವರೆಗಿನ ಸಂಖ್ಯೆಗಳನ್ನು ಒಟ್ಟುಗೂಡಿಸುವ ಒಂದು ಕಾರ್ಯವಾಗಿದೆ.\/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunc sum_to_n(n int) int {\n","canonical_solution":"func sum_to_n(n int) int {\n    return n * (n + 1) \/ 2\n}\n\nfunc TestSumToN(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {30, 465},\n        {100, 5050},\n        {5, 15},\n        {10, 55},\n        {1, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"sum_to_n(%d)\", test.input), func(t *testing.T) {\n            result := sum_to_n(test.input)\n            if result != test.expected {\n                t.Errorf(\"Expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestSum_To_N(t *testing.T) {\n  candidate := sum_to_n\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(6), expected: 21 },\n     { actual: candidate(11), expected: 66 },\n     { actual: candidate(30), expected: 465 },\n     { actual: candidate(100), expected: 5050 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_61","nl":"kan_Knda","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪ್ರತಿ ಆರಂಭಿಕ ಬ್ರಾಕೆಟ್ಗೆ ಅನುಗುಣವಾದ ಮುಚ್ಚುವ ಬ್ರಾಕೆಟ್ ಇದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಬ್ರಾಕೆಟ್ಗಳು \"(\" ಮತ್ತು \"\") ಗಳ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.\/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '(' {\n            balance++\n        } else if char == ')' {\n            balance--\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"(\", false},\n        {\"()\", true},\n        {\"(()())\", true},\n        {\")(()\", false},\n        {\"\", true},\n        {\"((()))\", true},\n        {\"(()\", false},\n        {\"())\", false},\n    }\n\n    for _, tt := range tests {\n        result := correct_bracketing(tt.input)\n        if result != tt.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; want %v\", tt.input, result, tt.expected)\n        } else {\n            fmt.Printf(\"correct_bracketing(%q) = %v\\n\", tt.input, result)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_62","nl":"kan_Knda","pl":"go_test.go","prompt":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಈ ಬಹುಪದವಿಯ ವ್ಯುತ್ಪತ್ತಿಯನ್ನು ಅದೇ ರೂಪದಲ್ಲಿ ಹಿಂತಿರುಗಿ.\/\/xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/xs ಬಹುಪದವಿಯ ಗುಣಾಂಕಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.\/\/ >>> derivative([]int{3, 1, 2, 4, 5})\n\/\/ []int{1, 4, 12, 20}\n\/\/ >>> derivative([]int{1, 2, 3})\n\/\/ []int{2, 6}\nfunc derivative(xs []int) []int {\n","canonical_solution":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ xs represent coefficients of a polynomial.\n\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\/\/ Return derivative of this polynomial in the same form.\nfunc derivative(xs []int) []int {\n    if len(xs) <= 1 {\n        return []int{}\n    }\n    \n    derived := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        derived[i-1] = xs[i] * i\n    }\n    return derived\n}\n\nfunc TestDerivative(t *testing.T) {\n    testCases := []struct{\n        input []int\n        expected []int\n    }{\n        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},\n        {[]int{1, 2, 3}, []int{2, 6}},\n        {[]int{1}, []int{}},\n        {[]int{}, []int{}},\n    }\n\n    for _, testCase := range testCases {\n        result := derivative(testCase.input)\n        if !equal(result, testCase.expected) {\n            t.Errorf(\"For input %v, expected %v, but got %v\", \n                     testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestDerivative(t *testing.T) {\n  candidate := derivative\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },\n     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },\n     { actual: candidate([]int{1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_63","nl":"kan_Knda","pl":"go_test.go","prompt":"package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ದಯವಿಟ್ಟು fibfib ಸಂಖ್ಯೆಗಳ ಅನುಕ್ರಮದ n-ನೇ ಅಂಶವನ್ನು ಸಮರ್ಥವಾಗಿ ಲೆಕ್ಕಾಚಾರ ಮಾಡಲು ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ.\/\/fib fib (n) == fib fib (n-1) + fib fib (n-2) + fib (n-3) ಗಳು\/\/fib fib ((2) == 1 \/\/        \/\/fib fib ((0) == 0 \/\/ಫೈಬ್ಫೈಬ್ ಸಂಖ್ಯೆಯ ಅನುಕ್ರಮವು ಫೈಬೊನಾಕಿ ಅನುಕ್ರಮಕ್ಕೆ ಹೋಲುತ್ತದೆ, ಇದನ್ನು ಈ ಕೆಳಗಿನಂತೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ:\/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunc fibfib(n int) int {\n","canonical_solution":"func fibfib(n int) int {\n    if n == 0 || n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    }\n\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        next := a + b + c\n        a = b\n        b = c\n        c = next\n    }\n    return c\n}","tests":"func TestFibfib(t *testing.T) {\n  candidate := fibfib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 1 },\n     { actual: candidate(1), expected: 0 },\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 24 },\n     { actual: candidate(10), expected: 81 },\n     { actual: candidate(12), expected: 274 },\n     { actual: candidate(14), expected: 927 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_64","nl":"kan_Knda","pl":"go_test.go","prompt":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಸ್ವರ, ಆದರೆ ಅದು ಕೊಟ್ಟಿರುವ ಪದದ ಕೊನೆಯಲ್ಲಿ ಮಾತ್ರ.\/\/ಈ ಸಂದರ್ಭದಲ್ಲಿ ಸ್ವರಗಳು 'a', 'e', 'i', 'o', 'u'. ಇಲ್ಲಿ, 'y' ಕೂಡ ಒಂದು \/\/ಒಂದು ಪದವನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ಮತ್ತು ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಸ್ವರಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.\/\/ ಅನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ vowels_count\/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunc vowels_count(s string) int {\n","canonical_solution":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc vowels_count(s string) int {\n    count := 0\n    s = strings.ToLower(s)\n    vowels := \"aeiou\"\n    for i, char := range s {\n        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestVowelsCount(t *testing.T) {\n    tests := []struct {\n        input  string\n        output int\n    }{\n        {\"abcde\", 2},\n        {\"ACEDY\", 3},\n        {\"xyz\", 1},\n        {\"plenty\", 1},\n        {\"queue\", 3},\n    }\n\n    for _, test := range tests {\n        result := vowels_count(test.input)\n        if result != test.output {\n            t.Errorf(\"Expected %d, but got %d for input %s\", test.output, result, test.input)\n        } else {\n            fmt.Printf(\"Success: got %d for input %s\\n\", result, test.input)\n        }\n    }\n}","tests":"func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual: candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected: 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n     { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_65","nl":"kan_Knda","pl":"go_test.go","prompt":"package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/shift > ಅಂಕಿಗಳ ಸಂಖ್ಯೆ, ಹಿಂದಿರುಗಿದ ಅಂಕಿಗಳನ್ನು ಹಿಮ್ಮುಖಗೊಳಿಸಿ.\/\/ಮತ್ತು ಫಲಿತಾಂಶವನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಪೂರ್ಣಾಂಕ x ನ ಅಂಕಿಗಳನ್ನು ವೃತ್ತಾಕಾರವಾಗಿ ಸರಿಸಿ, ಅಂಕಿಗಳನ್ನು ಬಲಕ್ಕೆ ಸರಿಸಿ \/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunc circular_shift(x int, shift int) string {\n","canonical_solution":"package circular_shift_test\n\nimport (\n    \"strconv\"\n)\n\nfunc circular_shift(x int, shift int) string {\n    strX := strconv.Itoa(x)\n    numDigits := len(strX)\n\n    if shift > numDigits {\n        \/\/ Reverse the digits if shift is greater than the number of digits\n        reversed := make([]byte, numDigits)\n        for i := 0; i < numDigits; i++ {\n            reversed[i] = strX[numDigits-i-1]\n        }\n        return string(reversed)\n    } else {\n        \/\/ Perform a circular shift\n        shift = shift % numDigits\n        return strX[numDigits-shift:] + strX[:numDigits-shift]\n    }\n}","tests":"func TestCircular_Shift(t *testing.T) {\n  candidate := circular_shift\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(100, 2), expected: \"001\" },\n     { actual: candidate(12, 2), expected: \"12\" },\n     { actual: candidate(97, 8), expected: \"79\" },\n     { actual: candidate(12, 1), expected: \"21\" },\n     { actual: candidate(11, 101), expected: \"11\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_66","nl":"kan_Knda","pl":"go_test.go","prompt":"package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ASCII ಸಂಕೇತಗಳು \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಮೇಲಿನ ಅಕ್ಷರಗಳ ಮೊತ್ತವನ್ನು ಮಾತ್ರ ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ' \/\/ಕಾರ್ಯ \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunc digitSum(s string) int {\n","canonical_solution":"func digitSum(s string) int {\n    sum := 0\n    for _, char := range s {\n        if char >= 'A' && char <= 'Z' {\n            sum += int(char)\n        }\n    }\n    return sum\n}","tests":"func TestDigitsum(t *testing.T) {\n  candidate := digitSum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abAB\"), expected: 131 },\n     { actual: candidate(\"abcCd\"), expected: 67 },\n     { actual: candidate(\"helloE\"), expected: 69 },\n     { actual: candidate(\"woArBld\"), expected: 131 },\n     { actual: candidate(\"aAaaaXa\"), expected: 153 },\n     { actual: candidate(\" How are yOu?\"), expected: 151 },\n     { actual: candidate(\"You arE Very Smart\"), expected: 327 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_67","nl":"kan_Knda","pl":"go_test.go","prompt":"package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪಠ್ಯಕ್ಕಾಗಿ: \/\/ಬುಟ್ಟಿಯಲ್ಲಿರುವ ಹಣ್ಣುಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಕಿತ್ತಳೆ ಮತ್ತು ಸೇಬುಗಳು ಮತ್ತು ಹಣ್ಣುಗಳ ಒಟ್ಟು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಪೂರ್ಣಾಂಕ \/\/ಸೇಬುಗಳು, ಕಿತ್ತಳೆಗಳು, ಮತ್ತು ಮಾಂಗೊ ಹಣ್ಣುಗಳು. ಒಟ್ಟು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗಿದೆ \/\/ಈ ಹಣ್ಣಿನ ಬುಟ್ಟಿಯಲ್ಲಿರುವ ಹಣ್ಣಿನ ಬುಟ್ಟಿಯಲ್ಲಿ ವಿತರಿಸಲಾಗುತ್ತದೆ .\/\/ಈ ಕಾರ್ಯದಲ್ಲಿ, ನಿಮಗೆ ಒಂದು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗುವುದು ಸೇಬುಗಳು ಮತ್ತು ಕಿತ್ತಳೆಗಳು \/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunc fruit_distribution(s string, n int) int {\n","canonical_solution":"package fruit_distribution_test\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"testing\"\n)\n\nfunc fruit_distribution(s string, n int) int {\n    re := regexp.MustCompile(`(\\d+) apples and (\\d+) oranges`)\n    matches := re.FindStringSubmatch(s)\n    \n    if len(matches) != 3 {\n        return -1 \/\/ Could return an error or a sentinel value if input format is incorrect\n    }\n\n    apples, _ := strconv.Atoi(matches[1])\n    oranges, _ := strconv.Atoi(matches[2])\n\n    mangoes := n - (apples + oranges)\n    return mangoes\n}\n\nfunc TestFruitDistribution(t *testing.T) {\n    var tests = []struct {\n        description string\n        inputString string\n        totalFruits int\n        expected    int\n    }{\n        {\"Test case 1\", \"5 apples and 6 oranges\", 19, 8},\n        {\"Test case 2\", \"0 apples and 1 oranges\", 3, 2},\n        {\"Test case 3\", \"2 apples and 3 oranges\", 100, 95},\n        {\"Test case 4\", \"100 apples and 1 oranges\", 120, 19},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.description, func(t *testing.T) {\n            result := fruit_distribution(tt.inputString, tt.totalFruits)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}\n\nfunc main() {\n    fmt.Println(fruit_distribution(\"5 apples and 6 oranges\", 19)) \/\/ 8\n    fmt.Println(fruit_distribution(\"0 apples and 1 oranges\", 3))  \/\/ 2\n    fmt.Println(fruit_distribution(\"2 apples and 3 oranges\", 100)) \/\/ 95\n    fmt.Println(fruit_distribution(\"100 apples and 1 oranges\", 120)) \/\/ 19\n}","tests":"func TestFruit_Distribution(t *testing.T) {\n  candidate := fruit_distribution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"5 apples and 6 oranges\", 19), expected: 8 },\n     { actual: candidate(\"5 apples and 6 oranges\", 21), expected: 10 },\n     { actual: candidate(\"0 apples and 1 oranges\", 3), expected: 2 },\n     { actual: candidate(\"1 apples and 0 oranges\", 3), expected: 2 },\n     { actual: candidate(\"2 apples and 3 oranges\", 100), expected: 95 },\n     { actual: candidate(\"2 apples and 3 oranges\", 5), expected: 0 },\n     { actual: candidate(\"1 apples and 100 oranges\", 120), expected: 19 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_68","nl":"kan_Knda","pl":"go_test.go","prompt":"package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ 1: \/\/ಯಾವುದೇ ಸಮ ಮೌಲ್ಯಗಳು ಇಲ್ಲದಿದ್ದರೆ ಅಥವಾ ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿ ಖಾಲಿಯಾಗಿದ್ದರೆ, [] ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಕಿತ್ತುಹಾಕಿದ ನೋಡ್ ಅನ್ನು ಪಟ್ಟಿಯಲ್ಲಿ ಹಿಂತಿರುಗಿಸಬೇಕು, [ smalest_value, ಅದರ ಸೂಚ್ಯಂಕ ], \/\/ಒಂದೇ ಚಿಕ್ಕದಾದ ಸಹ ಮೌಲ್ಯವನ್ನು ಹೊಂದಿರುವ ಬಹು ನೋಡ್ಗಳನ್ನು ಕಂಡುಕೊಂಡರೆ, ಚಿಕ್ಕದಾದ ಸೂಚ್ಯಂಕವನ್ನು ಹೊಂದಿರುವ ನೋಡ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ. \/\/ಕಿತ್ತುಕೊಂಡ ನೋಡ್ ಚಿಕ್ಕದಾದ ಸಹ ಮೌಲ್ಯವನ್ನು ಹೊಂದಿರುವ ನೋಡ್ ಆಗಿರಬೇಕು.\/\/ನಿಮ್ಮ ಕಾರ್ಯವು ಒಂದು ನೋಡ್ ಅನ್ನು ಎಳೆಯುವುದು ಮತ್ತು ಅದನ್ನು ಹಿಂದಿರುಗಿಸುವುದು.\/\/\"ಒಂದು ಮರದ ಒಂದು ಶಾಖೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ ಅದು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕ ನೋಡ್ಗಳನ್ನು ಹೊಂದಿದೆ \/\/ >>> pluck([]int{4, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([]int{1, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([]int{})\n\/\/ []int{}\n\/\/ Example 4:\n\/\/ >>> pluck([]int{5, 0, 3, 0, 4, 2})\n\/\/ []int{0, 1}\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunc pluck(arr []int) []int {\n","canonical_solution":"package pluck_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ pluck function that implements the solution as described in the problem\nfunc pluck(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn []int{}\n\t}\n\n\tsmallestEvenValue := -1\n\tindex := -1\n\n\tfor i, val := range arr {\n\t\tif val%2 == 0 {\n\t\t\tif smallestEvenValue == -1 || val < smallestEvenValue {\n\t\t\t\tsmallestEvenValue = val\n\t\t\t\tindex = i\n\t\t\t}\n\t\t}\n\t}\n\n\tif index == -1 {\n\t\treturn []int{}\n\t}\n\n\treturn []int{smallestEvenValue, index}\n}\n\n\/\/ Example unit tests can be implemented by using the testing package\nfunc TestPluck(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{4, 2, 3}, []int{2, 1}},\n\t\t{[]int{1, 2, 3}, []int{2, 1}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := pluck(test.input)\n\t\tif len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {\n\t\t\tt.Errorf(\"pluck(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_69","nl":"kan_Knda","pl":"go_test.go","prompt":"package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಅಂತಹ ಮೌಲ್ಯವು ಅಸ್ತಿತ್ವದಲ್ಲಿಲ್ಲದಿದ್ದರೆ, -1 ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಒಂದು ಪೂರ್ಣಾಂಕದ ಆವರ್ತನವು ಪಟ್ಟಿಯಲ್ಲಿ ಅದು ಕಾಣಿಸಿಕೊಳ್ಳುವ ಸಂಖ್ಯೆಯಾಗಿದೆ.\/\/ಶೂನ್ಯ, ಮತ್ತು ಪೂರ್ಣಾಂಕದ ಮೌಲ್ಯಕ್ಕಿಂತ ಹೆಚ್ಚಿನ ಅಥವಾ ಸಮನಾದ ಆವರ್ತನವನ್ನು ಹೊಂದಿದೆ.\/\/ನಿಮಗೆ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿ ನೀಡಲಾಗಿದೆ.  ಗಿಂತ ದೊಡ್ಡದಾದ ದೊಡ್ಡ ಪೂರ್ಣಾಂಕವನ್ನು ಹಿಂತಿರುಗಿ.\/\/ >>> search([]int{4, 1, 2, 2, 3, 1})\n\/\/ 2\n\/\/ >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})\n\/\/ 3\n\/\/ >>> search([]int{5, 5, 4, 4, 4})\n\/\/ -1\nfunc search(lst []int) int {\n","canonical_solution":"package search_test\n\nimport \"sort\"\n\nfunc search(lst []int) int {\n\tfrequency := make(map[int]int)\n\n\tfor _, num := range lst {\n\t\tfrequency[num]++\n\t}\n\n\tcandidates := []int{}\n\tfor num, count := range frequency {\n\t\tif count >= num {\n\t\t\tcandidates = append(candidates, num)\n\t\t}\n\t}\n\n\tif len(candidates) == 0 {\n\t\treturn -1\n\t}\n\n\tsort.Ints(candidates)\n\treturn candidates[len(candidates)-1]\n}","tests":"func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3, 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n     { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}), expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_70","nl":"kan_Knda","pl":"go_test.go","prompt":"package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ನಂತರ ಉಳಿದ ಪೂರ್ಣಾಂಕಗಳ ಗರಿಷ್ಠ, ನಂತರ ಕನಿಷ್ಠ ಹೀಗೆ.\/\/ವಿಚಿತ್ರ ವಿಂಗಡಣೆ, ನೀವು ಕನಿಷ್ಟ ಮೌಲ್ಯದೊಂದಿಗೆ ಪ್ರಾರಂಭಿಸಿದಾಗ, \/\/ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ವಿಚಿತ್ರ ಕ್ರಮದಲ್ಲಿ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> strange_sort_list([]int{1, 2, 3, 4})\n\/\/ []int{1, 4, 2, 3}\n\/\/ >>> strange_sort_list([]int{5, 5, 5, 5})\n\/\/ []int{5, 5, 5, 5}\n\/\/ >>> strange_sort_list([]int{})\n\/\/ []int{}\nfunc strange_sort_list(lst []int) []int {\n","canonical_solution":"package strange_sort_list_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc strange_sort_list(lst []int) []int {\n\tif len(lst) == 0 {\n\t\treturn lst\n\t}\n\t\n\tsort.Ints(lst)\n\tres := make([]int, len(lst))\n\tleft, right := 0, len(lst)-1\n\ti := 0\n\n\tfor left <= right {\n\t\tif i%2 == 0 {\n\t\t\tres[i] = lst[left]\n\t\t\tleft++\n\t\t} else {\n\t\t\tres[i] = lst[right]\n\t\t\tright--\n\t\t}\n\t\ti++\n\t}\n\n\treturn res\n}\n\nfunc TestStrangeSortList(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []int\n\t\toutput []int\n\t}{\n\t\t{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},\n\t\t{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},\n\t}\n\tfor _, test := range tests {\n\t\tif res := strange_sort_list(test.input); !equal(res, test.output) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.output, res)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(strange_sort_list([]int{1, 2, 3, 4})) \/\/ Should print [1 4 2 3]\n}","tests":"func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_71","nl":"kan_Knda","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಮೂರನೇ ಭಾಗಕ್ಕಿಂತಲೂ ಹೆಚ್ಚು.\/\/ಯಾವುದೇ ಎರಡು ಬದಿಗಳ ಮೊತ್ತವು ದೊಡ್ಡದಾಗಿದ್ದರೆ ಮೂರು ಬದಿಗಳು ಮಾನ್ಯ ತ್ರಿಕೋನವನ್ನು ಮಾಡುತ್ತವೆ.\/\/ಇಲ್ಲದಿದ್ದರೆ -1  ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ\/\/ ಮೂರು ಬದಿಗಳು ಮಾನ್ಯ ತ್ರಿಕೋನವೊಂದನ್ನು ರೂಪಿಸಿದರೆ ತ್ರಿಕೋನವು 2 ದಶಮಾಂಶ ಬಿಂದುಗಳಿಗೆ ದುಂಡಾದ \/\/ ನ ಪ್ರದೇಶವನ್ನು ಹಿಂತಿರುಗಿ \/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunc triangle_area(a int, b int, c int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"math\"\n)\n\nfunc triangle_area(a int, b int, c int) float64 {\n    \/\/ Check for the validity of the triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    \/\/ Calculate the semi-perimeter\n    s := float64(a+b+c) \/ 2\n    \/\/ Calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    \/\/ Round the result to 2 decimal places\n    return math.Round(area*100) \/ 100.0\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: 6.0 },\n     { actual: candidate(1, 2, 10), expected: -1 },\n     { actual: candidate(4, 8, 5), expected: 8.18 },\n     { actual: candidate(2, 2, 2), expected: 1.73 },\n     { actual: candidate(1, 2, 3), expected: -1 },\n     { actual: candidate(10, 5, 7), expected: 16.25 },\n     { actual: candidate(2, 6, 3), expected: -1 },\n     { actual: candidate(1, 1, 1), expected: 0.43 },\n     { actual: candidate(2, 2, 10), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_72","nl":"kan_Knda","pl":"go_test.go","prompt":"package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ವಸ್ತುವಿನ q ಸಮತೋಲಿತ ವೇಳೆ ಹಾರುವ (ಇದು ಒಂದು ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಪಟ್ಟಿ) ಮತ್ತು ಅದರ ಅಂಶಗಳ ಮೊತ್ತವು ಕಡಿಮೆ ಅಥವಾ ಗರಿಷ್ಠ ಸಾಧ್ಯ ತೂಕ w ಸಮಾನವಾಗಿರುತ್ತದೆ.\/\/ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಅದು ವಸ್ತುವಿನ q ಹಾರಿದರೆ true ಮತ್ತು ಇಲ್ಲದಿದ್ದರೆ false ಎಂದು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.\/\/ >>> will_it_fly([]int{1, 2}, 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([]int{3}, 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n","canonical_solution":"func will_it_fly(q []int, w int) bool {\n    sum := 0\n    n := len(q)\n\n    \/\/ Calculate the sum of the elements in q\n    for _, value := range q {\n        sum += value\n    }\n\n    \/\/ Check if sum is greater than the maximum possible weight\n    if sum > w {\n        return false\n    }\n\n    \/\/ Check if the list is a palindrome\n    for i := 0; i < n\/2; i++ {\n        if q[i] != q[n-i-1] {\n            return false\n        }\n    }\n\n    \/\/ If the list is balanced and sum is less than or equal to w\n    return true\n}","tests":"func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_73","nl":"kan_Knda","pl":"go_test.go","prompt":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಒಂದು ಬದಲಾವಣೆಯಲ್ಲಿ, ನೀವು ಒಂದು ಅಂಶವನ್ನು ಯಾವುದೇ ಇತರ ಅಂಶಕ್ಕೆ ಬದಲಾಯಿಸಬಹುದು.\/\/ಪಟ್ಟಿಯನ್ನು ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಮಾಡಲು ಬದಲಾಯಿಸಬೇಕಾಗಿದೆ. ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಪಟ್ಟಿ ಎಂಬುದು ಒಂದು ಪಟ್ಟಿ \/\/ಪೂರ್ಣಾಂಕಗಳ arr ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ,  ಎಂದು ಕನಿಷ್ಠ ಅಂಶಗಳ ಸಂಖ್ಯೆಯನ್ನು ಕಂಡುಹಿಡಿಯಿರಿ\/\/ >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})\n\/\/ 4\n\/\/ >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})\n\/\/ 1\n\/\/ >>> smallest_change([]int{1, 2, 3, 2, 1})\n\/\/ 0\nfunc smallest_change(arr []int) int {\n","canonical_solution":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_change(arr []int) int {\n    n := len(arr)\n    changes := 0\n    for i := 0; i < n\/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changes++\n        }\n    }\n    return changes\n}\n\nfunc TestSmallestChange(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},\n        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},\n        {[]int{1, 2, 3, 2, 1}, 0},\n    }\n\n    for _, test := range tests {\n        result := smallest_change(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %v, expected %d but got %d\", test.input, test.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", test.input)\n        }\n    }\n}","tests":"func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_74","nl":"kan_Knda","pl":"go_test.go","prompt":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಎರಡು ಪಟ್ಟಿಗಳು ಒಂದೇ ಸಂಖ್ಯೆಯ ಅಕ್ಷರಗಳನ್ನು ಹೊಂದಿದ್ದರೆ, ಮೊದಲ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.\/\/ಪಟ್ಟಿಯ ಎಲ್ಲಾ ಸ್ಟ್ರಿಂಗ್ಗಳಲ್ಲಿನ ಒಟ್ಟು ಸಂಖ್ಯೆಯ ಅಕ್ಷರಗಳು ಇತರ ಪಟ್ಟಿಗಿಂತ ಕಡಿಮೆಯಿವೆ.\/\/ಎರಡು ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಗಳನ್ನು ಸ್ವೀಕರಿಸುವ ಮತ್ತು  ಹೊಂದಿರುವ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ\/\/ >>> total_match([]string{}, []string{})\n\/\/ []string{}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n\/\/ []string{\"hI\", \"Hi\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"})\n\/\/ []string{\"hi\", \"admin\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\/\/ []string{\"hI\", \"hi\", \"hi\"}\n\/\/ >>> total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"})\n\/\/ []string{\"4\"}\nfunc total_match(lst1 []string, lst2 []string) []string {\n","canonical_solution":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ total_match function returns the list with the smaller total character count.\n\/\/ If both lists have the same character count, it returns the first list.\nfunc total_match(lst1 []string, lst2 []string) []string {\n    sumChars := func(lst []string) int {\n        total := 0\n        for _, str := range lst {\n            total += len(str)\n        }\n        return total\n    }\n    \n    sum1 := sumChars(lst1)\n    sum2 := sumChars(lst2)\n\n    if sum1 <= sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\n\/\/ Test functions can go below to verify the behavior of total_match.\nfunc TestTotalMatch(t *testing.T) {\n    cases := []struct {\n        lst1      []string\n        lst2      []string\n        expected  []string\n    }{\n        {[]string{}, []string{}, []string{}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}, []string{\"hI\", \"Hi\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}, []string{\"hi\", \"admin\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}, []string{\"hI\", \"hi\", \"hi\"}},\n        {[]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}, []string{\"4\"}},\n    }\n\n    for _, c := range cases {\n        result := total_match(c.lst1, c.lst2)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"total_match(%v, %v) == %v, expected %v\", c.lst1, c.lst2, result, c.expected)\n        }\n    }\n}","tests":"func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_75","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/(a) 100 ಕ್ಕಿಂತ ಚಿಕ್ಕದಾಗಿದೆ ಎಂದು ತಿಳಿದಿರುವುದು.\/\/ಮತ್ತು ಸುಳ್ಳು ಬೇರೆ.\/\/ಕೊಟ್ಟಿರುವ ಸಂಖ್ಯೆಯು 3 ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳ ಗುಣಾಕಾರವಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ \/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a int) bool {\n","canonical_solution":"func is_multiply_prime(a int) bool {\n\tif a < 2 {\n\t\treturn false\n\t}\n\n\tprimeNumbers := generatePrimesUpTo(100)\n\t\n\tfor i := 0; i < len(primeNumbers); i++ {\n\t\tfor j := i; j < len(primeNumbers); j++ {\n\t\t\tfor k := j; k < len(primeNumbers); k++ {\n\t\t\t\tif primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc generatePrimesUpTo(max int) []int {\n\tisPrime := make([]bool, max+1)\n\tfor i := 2; i <= max; i++ {\n\t\tisPrime[i] = true\n\t}\n\tfor i := 2; i*i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tfor j := i * i; j <= max; j += i {\n\t\t\t\tisPrime[j] = false\n\t\t\t}\n\t\t}\n\t}\n\tvar primes []int\n\tfor i := 2; i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn primes\n}","tests":"func TestIs_Multiply_Prime(t *testing.T) {\n  candidate := is_multiply_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: false },\n     { actual: candidate(30), expected: true },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: false },\n     { actual: candidate(125), expected: true },\n     { actual: candidate(105), expected: true },\n     { actual: candidate(126), expected: false },\n     { actual: candidate(729), expected: false },\n     { actual: candidate(891), expected: false },\n     { actual: candidate(1001), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_76","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/x ಎಂಬುದು n ನ ಸರಳ ಪದರವಾಗಿದೆ n**int=x \/\/n ನ ಪವರ್ ಮತ್ತು ಇತರ ಸಂದರ್ಭಗಳಲ್ಲಿ ಸುಳ್ಳು.\/\/ನಿಮ್ಮ ಕಾರ್ಯವು ಒಂದು ಸಂಖ್ಯೆಯ x ಒಂದು ಸರಳ  ಆಗಿದ್ದರೆ ನಿಜವಾದದನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯುವುದು.\/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunc is_simple_power(x int, n int) bool {\n","canonical_solution":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_simple_power(x int, n int) bool {\n    if n <= 1 {\n        return x == 1\n    }\n    \n    current := n\n    for current <= x {\n        if current == x {\n            return true\n        }\n        current *= n\n    }\n    return false\n}\n\nfunc TestIsSimplePower(t *testing.T) {\n    tests := []struct {\n        x, n     int\n        expected bool\n    }{\n        {1, 4, true},\n        {2, 2, true},\n        {8, 2, true},\n        {3, 2, false},\n        {3, 1, false},\n        {5, 3, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.x, test.n), func(t *testing.T) {\n            result := is_simple_power(test.x, test.n)\n            if result != test.expected {\n                t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_77","nl":"kan_Knda","pl":"go_test.go","prompt":"package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಗಮನಿಸಿ: ನೀವು ಇನ್ಪುಟ್ ಯಾವಾಗಲೂ ಮಾನ್ಯ ಎಂದು ಭಾವಿಸಬಹುದು.\/\/ಈ ಇಂಗರ್ ಒಂದು ಪೂರ್ಣಾಂಕದ ಘನವಾಗಿದ್ದರೆ.\/\/ಒಂದು ಪೂರ್ಣಾಂಕವನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಮತ್ತು true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ \/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunc iscube(a int) bool {\n","canonical_solution":"package iscube_test\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc iscube(a int) bool {\n\tif a < 0 {\n\t\ta = -a\n\t}\n\tcubeRoot := math.Cbrt(float64(a))\n\treturn cubeRoot == float64(int(cubeRoot))\n}\n\nfunc TestIsCube(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{1, true},\n\t\t{2, false},\n\t\t{-1, true},\n\t\t{64, true},\n\t\t{0, true},\n\t\t{180, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"iscube(%d)\", test.input), func(t *testing.T) {\n\t\t\tresult := iscube(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestIscube(t *testing.T) {\n  candidate := iscube\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: true },\n     { actual: candidate(2), expected: false },\n     { actual: candidate(-1), expected: true },\n     { actual: candidate(64), expected: true },\n     { actual: candidate(180), expected: false },\n     { actual: candidate(1000), expected: true },\n     { actual: candidate(0), expected: true },\n     { actual: candidate(1729), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_78","nl":"kan_Knda","pl":"go_test.go","prompt":"package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಮತ್ತು ಚಿಹ್ನೆಗಳು A,B,C,D,E,F ಯಾವಾಗಲೂ ದೊಡ್ಡಕ್ಷರಗಳಾಗಿರುತ್ತವೆ.\/\/ಗಮನಿಸಿ: ನೀವು ಇನ್ಪುಟ್ ಯಾವಾಗಲೂ ಸರಿಯಾದ ಅಥವಾ ಖಾಲಿ ಸ್ಟ್ರಿಂಗ್ ಎಂದು ಭಾವಿಸಬಹುದು, \/\/ಬಿ (= ದಶಮಾಂಶ 11), ಡಿ (= ದಶಮಾಂಶ 13).\/\/ಆದ್ದರಿಂದ ನೀವು ಈ ಕೆಳಗಿನ ಅಂಕೆಗಳ ಸಂಖ್ಯೆಯನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು: 2, 3, 5, 7, \/\/ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳು 2, 3, 5, 7, 11, 13, 17,... \/\/ಹೆಕ್ಸಾಡೆಸಿಮಲ್ ಅಂಕಿಗಳು 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/1 ಕ್ಕಿಂತ ದೊಡ್ಡದಾಗಿದೆ ಅದು ಎರಡು ಸಣ್ಣ ನೈಸರ್ಗಿಕ ಸಂಖ್ಯೆಗಳ ಉತ್ಪನ್ನವಲ್ಲ).\/\/ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳು (ಪ್ರೈಮ್ ಸಂಖ್ಯೆ, ಅಥವಾ ಅವಿಭಾಜ್ಯ, ನೈಸರ್ಗಿಕ ಸಂಖ್ಯೆ \/\/ಹೆಕ್ಸಾಡೆಸಿಮಲ್ ಸಂಖ್ಯೆಯನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಮತ್ತು ಹೆಕ್ಸಾಡೆಸಿಮಲ್ ಸಂಖ್ಯೆಯನ್ನು ಎಣಿಕೆ ಮಾಡುತ್ತದೆ \/\/ನೀವು ಸ್ವೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಲು ನಿಯೋಜಿಸಲಾಗಿದೆ \/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunc hex_key(num string) int {\n","canonical_solution":"func hex_key(num string) int {\n    primeDigits := map[rune]struct{}{\n        '2': {},\n        '3': {},\n        '5': {},\n        '7': {},\n        'B': {},\n        'D': {},\n    }\n\n    count := 0\n    for _, digit := range num {\n        if _, found := primeDigits[digit]; found {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHexKey(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"AB\", 1},\n        {\"1077E\", 2},\n        {\"ABED1A33\", 4},\n        {\"123456789ABCDEF0\", 6},\n        {\"2020\", 2},\n        {\"\", 0},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"hex_key(%s)\", test.input), func(t *testing.T) {\n            result := hex_key(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_79","nl":"kan_Knda","pl":"go_test.go","prompt":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಹೆಚ್ಚುವರಿ ಅಕ್ಷರಗಳು ಸ್ವರೂಪಕ್ಕೆ ಸಹಾಯ ಮಾಡಲು ಇವೆ.\/\/ಸ್ಟ್ರಿಂಗ್ನ ಆರಂಭದಲ್ಲಿ ಮತ್ತು ಕೊನೆಯಲ್ಲಿ ಹೆಚ್ಚುವರಿ ಎರಡು ಅಕ್ಷರಗಳು 'db' ಇರುತ್ತದೆ.\/\/ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಪ್ರತಿಯೊಂದು ಅಕ್ಷರವು '0' ಅಥವಾ '1' ಆಗಿರುತ್ತದೆ.\/\/ಬೈನರಿ ಸ್ವರೂಪ. ಈ ಕಾರ್ಯವು ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು, ಇದರಲ್ಲಿ ಪ್ರತಿ ಅಕ್ಷರವು ಬೈನರಿ  ಅನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.\/\/ನಿಮಗೆ ದಶಮಾಂಶ ರೂಪದಲ್ಲಿ ಒಂದು ಸಂಖ್ಯೆಯನ್ನು ನೀಡಲಾಗುವುದು ಮತ್ತು ನಿಮ್ಮ ಕಾರ್ಯವು ಅದನ್ನು ಪರಿವರ್ತಿಸುವುದು\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n","canonical_solution":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n\/\/ You will be given a number in decimal form and your task is to convert it to\n\/\/ binary format. The function should return a string, with each character representing a binary\n\/\/ number. Each character in the string will be '0' or '1'.\n\/\/ There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n\/\/ The extra characters are there to help with the format.\n\/\/ Examples:\n\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    binary := strconv.FormatInt(int64(decimal), 2)\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimalToBinary(t *testing.T) {\n    tests := []struct {\n        input  int\n        output string\n    }{\n        {15, \"db1111db\"},\n        {32, \"db100000db\"},\n        {0, \"db0db\"},\n        {1, \"db1db\"},\n        {255, \"db11111111db\"},\n    }\n\n    for _, test := range tests {\n        result := decimal_to_binary(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %d, expected %s, but got %s\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(decimal_to_binary(15))  \/\/ Output: db1111db\n    fmt.Println(decimal_to_binary(32))  \/\/ Output: db100000db\n    fmt.Println(decimal_to_binary(255)) \/\/ Output: db11111111db\n}","tests":"func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_80","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಹ್ಯಾಪ್ಗೊ ಆಗಿದ್ದರೆ ಅದರ ಉದ್ದವು ಕನಿಷ್ಠ 3 ಆಗಿರುತ್ತದೆ ಮತ್ತು ಪ್ರತಿ 3 ಸತತ ಅಕ್ಷರಗಳು ವಿಭಿನ್ನವಾಗಿರುತ್ತವೆ \/\/ನಿಮ್ಮ ಕಾರ್ಯವು ಸ್ಟ್ರಿಂಗ್ ಹ್ಯಾಪ್ಗೊ ಅಥವಾ ಇಲ್ಲವೇ ಎಂಬುದನ್ನು ಪರಿಶೀಲಿಸುವುದು.\/\/ನಿಮಗೆ ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ನೀಡಲಾಗಿದೆ.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunc is_happy(s string) bool {\n","canonical_solution":"func is_happy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i <= len(s)-3; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestIs_Happy(t *testing.T) {\n  candidate := is_happy\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a\"), expected: false },\n     { actual: candidate(\"aa\"), expected: false },\n     { actual: candidate(\"abcd\"), expected: true },\n     { actual: candidate(\"aabb\"), expected: false },\n     { actual: candidate(\"adb\"), expected: true },\n     { actual: candidate(\"xyy\"), expected: false },\n     { actual: candidate(\"iopaxpoi\"), expected: true },\n     { actual: candidate(\"iopaxioi\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_81","nl":"kan_Knda","pl":"go_test.go","prompt":"package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/0.0 ಇ \/\/> 0.0 ಡಿ- \/\/> 0.7 ಡಿ \/\/> 1.0 ಡಿ + \/\/> 1.3 C- \/\/> 1.7 °C \/\/> 2.0 C+ \/\/> 2.3 ಬಿ- \/\/> 2.7 ಬಿ \/\/> 3.0 ಬಿ + \/\/> 3.3 ಎ- \/\/> 3.7 ಎ \/\/4.0 ಎ + \/\/GPA. ಅಕ್ಷರ ಶ್ರೇಣಿ.\/\/ಕೆಳಗಿನ ಕೋಷ್ಟಕವನ್ನು ಬಳಸಿಕೊಂಡು ಅಕ್ಷರ ಶ್ರೇಣಿಗಳ ಪಟ್ಟಿಯನ್ನು ಔಟ್ಪುಟ್ ಮಾಡುವ ಒಂದು ಕಾರ್ಯ: \/\/ಅವರು ನಿಮಗೆ ಕೆಲವು ವಿದ್ಯಾರ್ಥಿಗಳ GPA ಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದ್ದಾರೆ ಮತ್ತು ನೀವು ಬರೆಯಬೇಕಾಗಿದೆ.\/\/ಆದರೆ, ಅವಳು ಬಳಸುತ್ತಿದ್ದ ಕೋಡ್ ಅನ್ನು ಕಳೆದುಕೊಂಡಿದ್ದಾಳೆ.\/\/ಶಿಕ್ಷಕ ತನ್ನದೇ ಆದ ಶ್ರೇಣೀಕರಣದ ಕ್ರಮಾವಳಿಗಳನ್ನು ರಚಿಸುತ್ತಿದ್ದಾನೆ.\/\/ಇದು ಸೆಮಿಸ್ಟರ್ನ ಕೊನೆಯ ವಾರ ಮತ್ತು ಶಿಕ್ಷಕನು ಶ್ರೇಣಿಗಳನ್ನು ನೀಡಬೇಕಾಗಿದೆ \/\/ >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})\n\/\/ []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\nfunc numerical_letter_grade(grades []float64) []string {\n","canonical_solution":"func numerical_letter_grade(grades []float64) []string {\n    letterGrades := []string{}\n    for _, grade := range grades {\n        if grade == 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if grade > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if grade > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if grade > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if grade > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if grade > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if grade > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if grade > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if grade > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if grade > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if grade > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if grade > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}","tests":"func TestNumerical_Letter_Grade(t *testing.T) {\n  candidate := numerical_letter_grade\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"} },\n     { actual: candidate([]float64{1.2}), expected: []string{\"D+\"} },\n     { actual: candidate([]float64{0.5}), expected: []string{\"D-\"} },\n     { actual: candidate([]float64{0.0}), expected: []string{\"E\"} },\n     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"} },\n     { actual: candidate([]float64{0.0, 0.7}), expected: []string{\"E\", \"D-\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_82","nl":"kan_Knda","pl":"go_test.go","prompt":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಉದ್ದವು ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಾಗಿದ್ದರೆ ಅಥವಾ ಸುಳ್ಳು \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಮತ್ತು ಸ್ಟ್ರಿಂಗ್ \/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunc prime_length(myString string) bool {\n","canonical_solution":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc prime_length(myString string) bool {\n    length := len(myString)\n    return isPrime(length)\n}\n\nfunc TestPrimeLength(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected bool\n    }{\n        {\"Hello\", true},\n        {\"abcdcba\", true},\n        {\"kittens\", true},\n        {\"orange\", false},\n    }\n\n    for _, testCase := range testCases {\n        result := prime_length(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"prime_length(%v) returned %v, expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(prime_length(\"Hello\"))  \/\/ true\n    fmt.Println(prime_length(\"abcdcba\"))  \/\/ true\n    fmt.Println(prime_length(\"kittens\"))  \/\/ true\n    fmt.Println(prime_length(\"orange\"))  \/\/ false\n}","tests":"func TestPrime_Length(t *testing.T) {\n  candidate := prime_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello\"), expected: true },\n     { actual: candidate(\"abcdcba\"), expected: true },\n     { actual: candidate(\"kittens\"), expected: true },\n     { actual: candidate(\"orange\"), expected: false },\n     { actual: candidate(\"wow\"), expected: true },\n     { actual: candidate(\"world\"), expected: true },\n     { actual: candidate(\"MadaM\"), expected: true },\n     { actual: candidate(\"Wow\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"HI\"), expected: true },\n     { actual: candidate(\"go\"), expected: true },\n     { actual: candidate(\"gogo\"), expected: false },\n     { actual: candidate(\"aaaaaaaaaaaaaaa\"), expected: false },\n     { actual: candidate(\"Madam\"), expected: true },\n     { actual: candidate(\"M\"), expected: false },\n     { actual: candidate(\"0\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_83","nl":"kan_Knda","pl":"go_test.go","prompt":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/1 ರೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುವ ಅಥವಾ ಕೊನೆಗೊಳ್ಳುವ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳು.\/\/ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, n-ಅಂಕಿಯ ಸಂಖ್ಯೆಗಳ ಎಣಿಕೆಯನ್ನು ಹಿಂತಿರುಗಿ func starts_one_ends(n int) int {\n","canonical_solution":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the count of the numbers of n-digit\n\/\/ positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n    if n == 1 {\n        return 1\n    }\n\n    countStart1 := 1 * pow(10, n-1)\n    countEnd1 := 9 * pow(10, n-2)\n    \n    return countStart1 + countEnd1\n}\n\nfunc pow(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    result := 1\n    for i := 0; i < exp; i++ {\n        result *= base\n    }\n    return result\n}\n\nfunc TestStartsOneEnds(t *testing.T) {\n    tests := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 19},\n        {3, 189},\n        {4, 1899},\n        {5, 18999},\n    }\n\n    for _, tt := range tests {\n        testname := fmt.Sprintf(\"n=%d\", tt.n)\n        t.Run(testname, func(t *testing.T) {\n            result := starts_one_ends(tt.n)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}","tests":"func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected: 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_84","nl":"kan_Knda","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ \/\/ಒಂದು ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ N ನೀಡಿದರೆ, ಅದರ ಅಂಕೆಗಳ ಒಟ್ಟು ಮೊತ್ತವನ್ನು ಬೈನರಿ ರೂಪದಲ್ಲಿ ಹಿಂತಿರುಗಿಸಿ. \/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunc solve(N int) string {\n","canonical_solution":"func solve(N int) string {\n    sum := 0\n    for N > 0 {\n        sum += N % 10\n        N \/= 10\n    }\n    return fmt.Sprintf(\"%b\", sum)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1000), expected: \"1\" },\n     { actual: candidate(150), expected: \"110\" },\n     { actual: candidate(147), expected: \"1100\" },\n     { actual: candidate(333), expected: \"1001\" },\n     { actual: candidate(963), expected: \"10010\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_85","nl":"kan_Knda","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಪೂರ್ಣಾಂಕಗಳ ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ lst. ವಿಚಿತ್ರ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿರುವ ಸಮ ಅಂಶಗಳನ್ನು ಸೇರಿಸಿ.\/\/ >>> add([]int{4, 2, 6, 7})\n\/\/ 2\nfunc add(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 88}), expected: 88 },\n     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },\n     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },\n     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_86","nl":"kan_Knda","pl":"go_test.go","prompt":"package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಗಮನಿಸಿ: ವಾಕ್ಯದಲ್ಲಿನ ಪದಗಳ ಕ್ರಮ ಮತ್ತು ಖಾಲಿ ಜಾಗಗಳನ್ನು ನೀವು ಗಮನಿಸಬೇಕು.\/\/ವುಳ್ಳ ಮೌಲ್ಯದ ಆಧಾರದ ಮೇಲೆ ಏರುತ್ತಿರುವ ಕ್ರಮ.\/\/ ರಲ್ಲಿ ಎಲ್ಲಾ ಪಾತ್ರಗಳು ಜೋಡಿಸಲಾದ ಹೊಸ ಪದವನ್ನು ಬದಲಿಸಲಾಗುತ್ತದೆ\/\/ಸ್ಟ್ರಿಂಗ್ನ ಕ್ರಮಬದ್ಧ ಆವೃತ್ತಿ, ಎಲ್ಲಾ ಪದಗಳು (ಅಂತರದಿಂದ ಬೇರ್ಪಡಿಸಲ್ಪಟ್ಟ) \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಅದರ ಕ್ರಮಬದ್ಧ ಆವೃತ್ತಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ.\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s string) string {\n","canonical_solution":"package anti_shuffle_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc anti_shuffle(s string) string {\n    \/\/ Split the input string into words based on spaces\n    words := strings.Fields(s)\n\n    \/\/ Iterate over each word\n    for i, word := range words {\n        \/\/ Convert the word to a slice of runes for sorting\n        runes := []rune(word)\n        \/\/ Sort the runes using custom comparison\n        sort.Slice(runes, func(i, j int) bool {\n            return runes[i] < runes[j]\n        })\n        \/\/ Reassign the sorted runes back to the word\n        words[i] = string(runes)\n    }\n\n    \/\/ Rejoin the words into a single string, keeping original spaces\n    result := \"\"\n    inputIndex := 0\n\n    for _, word := range words {\n        \/\/ Add the spaces prior to the current word\n        for inputIndex < len(s) && s[inputIndex] == ' ' {\n            result += \" \"\n            inputIndex++\n        }\n        \/\/ Add the current sorted word\n        result += word\n        inputIndex += len(word)\n    }\n\n    \/\/ Add trailing spaces, if any.\n    for inputIndex < len(s) && s[inputIndex] == ' ' {\n        result += \" \"\n        inputIndex++\n    }\n\n    return result\n}","tests":"func TestAnti_Shuffle(t *testing.T) {\n  candidate := anti_shuffle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi\"), expected: \"Hi\" },\n     { actual: candidate(\"hello\"), expected: \"ehllo\" },\n     { actual: candidate(\"number\"), expected: \"bemnru\" },\n     { actual: candidate(\"abcd\"), expected: \"abcd\" },\n     { actual: candidate(\"Hello World!!!\"), expected: \"Hello !!!Wdlor\" },\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hi. My name is Mister Robot. How are you?\"), expected: \".Hi My aemn is Meirst .Rboot How aer ?ouy\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_87","nl":"kan_Knda","pl":"go_test.go","prompt":"package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಅಲ್ಲದೆ, ಸಾಲಿನ ನಿರ್ದೇಶಾಂಕಗಳನ್ನು ಕಾಲಮ್ಗಳ ಮೂಲಕ ಇಳಿಕೆಯ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಿ.\/\/ಆರಂಭದಲ್ಲಿ ಸಾಲುಗಳ ಮೂಲಕ ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ನಿರ್ದೇಶಾಂಕಗಳನ್ನು ವಿಂಗಡಿಸಿ.\/\/ಪ್ರತಿ ಪಟ್ಟಿಯು ಒಂದು ನಿರ್ದೇಶಾಂಕವಾಗಿದೆ - (ಸಾಲು, ಕಾಲಮ್ಗಳು), 0 ರಿಂದ ಪ್ರಾರಂಭವಾಗುತ್ತದೆ.\/\/ಮತ್ತು ಪಟ್ಟಿಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, [(x1, y1), (x2, y2) ...] ಅಂತಹ \/\/lst, ಮತ್ತು ಪೂರ್ಣಾಂಕ x ನೀಡಿದರೆ, ಪಟ್ಟಿಯಲ್ಲಿ ಪೂರ್ಣಾಂಕ x ಗಳನ್ನು ಹುಡುಕಿ,\/\/ಪ್ರತಿ ಸಾಲು ವಿಭಿನ್ನ ಸಂಖ್ಯೆಯ ಕಾಲಮ್ಗಳನ್ನು ಹೊಂದಿರಬಹುದು.\/\/ಇದು ಮ್ಯಾಟ್ರಿಕ್ಸ್ಗೆ ಹೋಲುತ್ತದೆ, ಆದರೆ ಮ್ಯಾಟ್ರಿಕ್ಸ್ಗಳಿಗೆ ಹೋಲುತ್ತದೆ,\/\/ನಿಮಗೆ 2 ಆಯಾಮದ ಡೇಟಾವನ್ನು ನೀಡಲಾಗಿದೆ, ಒಂದು ಗೂಡುಕಟ್ಟಿದ ಪಟ್ಟಿಗಳಂತೆ, \/\/ >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n\/\/ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n\/\/ >>> get_row([][]int{}, 1)\n\/\/ [][]interface{}{}\n\/\/ >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n\/\/ [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n","canonical_solution":"package get_row_test\n\nimport (\n\t\"sort\"\n)\n\nfunc get_row(lst [][]int, x int) [][]interface{} {\n\tvar result [][]interface{}\n\n\tfor i, row := range lst {\n\t\tvar temp []interface{}\n\t\tfor j, value := range row {\n\t\t\tif value == x {\n\t\t\t\ttemp = append(temp, []interface{}{i, j})\n\t\t\t}\n\t\t}\n\t\t\/\/ Sort columns in descending order for the current row\n\t\tsort.Slice(temp, func(a, b int) bool {\n\t\t\treturn temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)\n\t\t})\n\t\tresult = append(result, temp...)\n\t}\n\n\t\/\/ result is already sorted by rows since we've traversed `lst` row by row\n\treturn result\n}","tests":"func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_88","nl":"kan_Knda","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/* ನೀಡಲಾದ ಪಟ್ಟಿಯನ್ನು ಬದಲಾಯಿಸಬೇಡಿ. \/\/ಟಿಪ್ಪಣಿ: \/\/ಅಥವಾ ಮೊತ್ತವು ((ಮೊದಲ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ, ಕೊನೆಯ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ) ಸಮವಾಗಿದ್ದರೆ ಅದನ್ನು ಇಳಿಕೆಯ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಿ.\/\/ನೀವು ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯನ್ನು ಆರೋಹಣ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸುತ್ತೀರಿ, ಮೊತ್ತವು ((ಮೊದಲ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ, ಕೊನೆಯ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ) ಬೆಸವಾಗಿದ್ದರೆ, \/\/ಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ, ವಿಂಗಡಿಸಿದ ನಂತರ ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯ ಒಂದು ಕೋಟಾವನ್ನು ಹಿಂತಿರುಗಿಸಿ,\/\/ >>> sort_array([]int{})\n\/\/ []int{}\n\/\/ >>> sort_array([]int{5})\n\/\/ []int{5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n\/\/ []int{0, 1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n\/\/ []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return append([]int{}, array...)\n    }\n\n    result := append([]int{}, array...) \/\/ Copy the array to avoid mutating the input\n    if (result[0]+result[len(result)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(result))) \/\/ Sort in descending order\n    } else {\n        sort.Ints(result) \/\/ Sort in ascending order\n    }\n\n    return result\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_89","nl":"kan_Knda","pl":"go_test.go","prompt":"package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಎರಡು ಸ್ಥಳಗಳಿಗೆ ಎರಡು ಬಾರಿ ಕೆಳಗೆ ಚಲಿಸುವಂತೆ ಮಾಡಿ.\/\/ಅಕ್ಷರಗಳು \/\/ಅಕ್ಷರಮಾಲೆಯೊಂದಿಗೆ ತಿರುಗಿಸುವ ಮೂಲಕ ಎನ್ಕ್ರಿಪ್ಟ್ ಮಾಡಲಾದ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.\/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಆರ್ಗ್ಯುಮೆಂಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಎನ್ಕ್ರಿಪ್ಟ್ ಮಾಡಿ ಮತ್ತು \/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunc encrypt(s string) string {\n","canonical_solution":"func encrypt(s string) string {\n    result := []rune(s)\n    for i, char := range result {\n        if char >= 'a' && char <= 'z' {\n            result[i] = 'a' + (char-'a'+4)%26\n        } else if char >= 'A' && char <= 'Z' {\n            result[i] = 'A' + (char-'A'+4)%26\n        }\n    }\n    return string(result)\n}","tests":"func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected: \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual: candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual: candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_91","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ವಾಕ್ಯಗಳನ್ನು '', '?' ಅಥವಾ '!' ಗಳಿಂದ ಪ್ರತ್ಯೇಕಿಸಲಾಗುತ್ತದೆ.\/\/ಬೇಸರ. \"ನಾನು\" ಎಂಬ ಪದದಿಂದ ಪ್ರಾರಂಭವಾಗುವ ವಾಕ್ಯವು ಬೇಸರವಾಗಿದೆ.\/\/ನಿಮಗೆ ಪದಗಳ ಒಂದು ಸರಣಿಯನ್ನು ನೀಡಲಾಗುವುದು, ಮತ್ತು ನಿಮ್ಮ ಕಾರ್ಯವು ಸಂಖ್ಯೆಯನ್ನು ಎಣಿಸುವುದು.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunc is_bored(S string) int {\n","canonical_solution":"package is_bored_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_bored(S string) int {\n    sentences := strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?' || r == '!'\n    })\n    count := 0\n    for _, sentence := range sentences {\n        trimmed := strings.TrimSpace(sentence)\n        if strings.HasPrefix(trimmed, \"I \") {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestIsBored(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"Hello world\", 0},\n        {\"The sky is blue. The sun is shining. I love this weather\", 1},\n        {\"I am here. I am there. I am everywhere\", 3},\n        {\"What's up? Are you ok? Yes, I am!\", 1},\n        {\"\", 0},\n        {\"I.\", 1},\n        {\"I! am excited. I? am curious\", 2},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"is_bored(%q)\", tt.input), func(t *testing.T) {\n            got := is_bored(tt.input)\n            if got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}","tests":"func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"), expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual: candidate(\"I feel good today. I will be productive. will kill It\"), expected: 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_92","nl":"kan_Knda","pl":"go_test.go","prompt":"package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಯಾವುದೇ ಇತರ ಸಂದರ್ಭಗಳಲ್ಲಿ ತಪ್ಪು ಎಂದು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಒಂದು ಸಂಖ್ಯೆಯು ಇತರ ಎರಡು ಮೊತ್ತಕ್ಕೆ ಸಮನಾಗಿರುತ್ತದೆ ಮತ್ತು ಎಲ್ಲಾ ಸಂಖ್ಯೆಗಳು ಪೂರ್ಣಾಂಕಗಳಾಗಿದ್ದರೆ ನಿಜವಾದದು ಎಂದು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/3 ಸಂಖ್ಯೆಗಳನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ.\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunc any_int(x float64, y float64, z float64) bool {\n","canonical_solution":"package any_int_test\n\nimport (\n    \"testing\"\n)\n\nfunc any_int(x float64, y float64, z float64) bool {\n    \/\/ Check if x, y, and z are integers\n    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {\n        return false\n    }\n\n    \/\/ Check if one of the numbers is the sum of the other two\n    if x == y+z || y == x+z || z == x+y {\n        return true\n    }\n\n    return false\n}\n\nfunc TestAnyInt(t *testing.T) {\n    if !any_int(5, 2, 7) {\n        t.Errorf(\"Expected true for any_int(5, 2, 7)\")\n    }\n    if any_int(3, 2, 2) {\n        t.Errorf(\"Expected false for any_int(3, 2, 2)\")\n    }\n    if !any_int(3, -2, 1) {\n        t.Errorf(\"Expected true for any_int(3, -2, 1)\")\n    }\n    if any_int(3.6, -2.2, 2) {\n        t.Errorf(\"Expected false for any_int(3.6, -2.2, 2)\")\n    }\n}","tests":"func TestAny_Int(t *testing.T) {\n  candidate := any_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 3, 1), expected: true },\n     { actual: candidate(2.5, 2, 3), expected: false },\n     { actual: candidate(1.5, 5, 3.5), expected: false },\n     { actual: candidate(2, 6, 2), expected: false },\n     { actual: candidate(4, 2, 2), expected: true },\n     { actual: candidate(2.2, 2.2, 2.2), expected: false },\n     { actual: candidate(-4, 6, 2), expected: true },\n     { actual: candidate(2, 1, 1), expected: true },\n     { actual: candidate(3, 4, 7), expected: true },\n     { actual: candidate(3.0, 4, 7), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_93","nl":"kan_Knda","pl":"go_test.go","prompt":"package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಅಕ್ಷರಗಳನ್ನು ಮಾತ್ರ ಊಹಿಸಿ.\/\/ಇಂಗ್ಲಿಷ್ ಅಕ್ಷರಮಾಲೆಯ ಸ್ವರ.\/\/ಆ ಸಂದೇಶದ ಮುಂದೆ 2 ಸ್ಥಳಗಳಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುವ ಅಕ್ಷರದೊಂದಿಗೆ ಸಂದೇಶ \/\/ ರಲ್ಲಿನ ಎಲ್ಲಾ ಸ್ವರಗಳನ್ನು ಬದಲಾಯಿಸುತ್ತದೆ.\/\/ಒಂದು ಸಂದೇಶವನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ, ಮತ್ತು ಅಂತಹ ಒಂದು \/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message string) string {\n","canonical_solution":"package encode_test\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc encode(message string) string {\n\tvar encodedMessage strings.Builder\n\n\t\/\/ Mapping of vowels to the letter appearing 2 places ahead\n\tvowelReplacement := map[rune]rune{\n\t\t'a': 'c',\n\t\t'A': 'C',\n\t\t'e': 'g',\n\t\t'E': 'G',\n\t\t'i': 'k',\n\t\t'I': 'K',\n\t\t'o': 'q',\n\t\t'O': 'Q',\n\t\t'u': 'w',\n\t\t'U': 'W',\n\t}\n\n\tfor _, char := range message {\n\t\tif unicode.IsLetter(char) {\n\t\t\t\/\/ Swap case of the character\n\t\t\tif unicode.IsUpper(char) {\n\t\t\t\tchar = unicode.ToLower(char)\n\t\t\t} else {\n\t\t\t\tchar = unicode.ToUpper(char)\n\t\t\t}\n\n\t\t\t\/\/ Replace vowel if the character is a vowel\n\t\t\tif replacement, isVowel := vowelReplacement[char]; isVowel {\n\t\t\t\tchar = replacement\n\t\t\t}\n\t\t}\n\n\t\tencodedMessage.WriteRune(char)\n\t}\n\n\treturn encodedMessage.String()\n}","tests":"func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_94","nl":"kan_Knda","pl":"go_test.go","prompt":"package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ನೀವು ದೊಡ್ಡ ಅವಿಭಾಜ್ಯ ಮೌಲ್ಯವನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು ಮತ್ತು ಅದರ ಅಂಕೆಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.\/\/ನಿಮಗೆ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ.\/\/ >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\/\/ 10\n\/\/ >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\/\/ 25\n\/\/ >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\/\/ 13\n\/\/ >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\/\/ 11\n\/\/ >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\/\/ 3\n\/\/ >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\/\/ 7\nfunc skjkasdkd(lst []int) int {\n","canonical_solution":"package skjkasdkd_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\/\/ Function to calculate the sum of digits of a number\nfunc sumOfDigits(n int) int {\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\n\/\/ Function to find the largest prime and return the sum of its digits\nfunc skjkasdkd(lst []int) int {\n\tmaxPrime := -1\n\tfor _, num := range lst {\n\t\tif isPrime(num) && num > maxPrime {\n\t\t\tmaxPrime = num\n\t\t}\n\t}\n\tif maxPrime == -1 {\n\t\treturn 0\n\t}\n\treturn sumOfDigits(maxPrime)\n}\n\nfunc TestSkjkasdkd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n\t\t{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n\t\t{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n\t\t{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n\t\t{[]int{0, 81, 12, 3, 1, 21}, 3},\n\t\t{[]int{0, 8, 1, 2, 1, 7}, 7},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tresult := skjkasdkd(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"got %v, want %v\", result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     { actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_95","nl":"kan_Knda","pl":"go_test.go","prompt":"package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಈ ಕಾರ್ಯವು false ಅನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು, ಕೊಟ್ಟಿರುವ ನಕ್ಷೆಯು ಖಾಲಿಯಾಗಿದೆ.\/\/case ಅಥವಾ ಎಲ್ಲಾ ಕೀಲಿಗಳು ದೊಡ್ಡಕ್ಷರದಲ್ಲಿ ಸ್ಟ್ರಿಂಗ್ಗಳಾಗಿವೆ, ಇಲ್ಲದಿದ್ದರೆ false ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಒಂದು ನಕ್ಷೆಯನ್ನು ನೀಡಿದರೆ, ಎಲ್ಲಾ ಕೀಲಿಗಳು ಕಡಿಮೆ  ನಲ್ಲಿನ ಸ್ಟ್ರಿಂಗ್ಗಳಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunc check_dict_case(dict map[string]string) bool {\n","canonical_solution":"func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n\n    var allLowercase, allUppercase bool\n    for k := range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k) {\n            return false\n        }\n        if k == strings.ToLower(k) {\n            if allUppercase {\n                return false\n            }\n            allLowercase = true\n        }\n        if k == strings.ToUpper(k) {\n            if allLowercase {\n                return false\n            }\n            allUppercase = true\n        }\n    }\n\n    return allLowercase || allUppercase\n}","tests":"func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_96","nl":"kan_Knda","pl":"go_test.go","prompt":"package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳು ಮತ್ತು n ಗಿಂತ ಕಡಿಮೆ ಇರುವ ಪೂರ್ಣಾಂಕಗಳು.\/\/ಒಂದು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕವನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಮೊದಲ n ನ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸಿ \/\/ >>> count_up_to(5)\n\/\/ []int{2, 3}\n\/\/ >>> count_up_to(11)\n\/\/ []int{2, 3, 5, 7}\n\/\/ >>> count_up_to(0)\n\/\/ []int{}\n\/\/ >>> count_up_to(20)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17, 19}\n\/\/ >>> count_up_to(1)\n\/\/ []int{}\n\/\/ >>> count_up_to(18)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int {\n","canonical_solution":"func count_up_to(n int) []int {\n\tprimes := []int{}\n\tfor num := 2; num < n; num++ {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_97","nl":"kan_Knda","pl":"go_test.go","prompt":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಇನ್ಪುಟ್ ಯಾವಾಗಲೂ ಮಾನ್ಯವಾಗಿರುತ್ತದೆ ಎಂದು ಭಾವಿಸಿ.\/\/ಅವುಗಳ ಘಟಕ ಅಂಕಿಗಳ ಗುಣಾಂಕ.\/\/ಎರಡು ಪೂರ್ಣಾಂಕಗಳನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು  ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಕಾರ್ಯವನ್ನು ಪೂರ್ಣಗೊಳಿಸಿ.\/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunc multiply(a int, b int) int {\n","canonical_solution":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Complete the function that takes two integers and returns \n\/\/ the product of their unit digits.\n\/\/ Assume the input is always valid.\nfunc multiply(a int, b int) int {\n    unitA := abs(a) % 10\n    unitB := abs(b) % 10\n    return unitA * unitB\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}\n\nfunc TestMultiply(t *testing.T) {\n    fmt.Println(multiply(148, 412)) \/\/ 16\n    fmt.Println(multiply(19, 28))   \/\/ 72\n    fmt.Println(multiply(2020, 1851)) \/\/ 0\n    fmt.Println(multiply(14, -15))  \/\/ 20\n}","tests":"func TestMultiply(t *testing.T) {\n  candidate := multiply\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(148, 412), expected: 16 },\n     { actual: candidate(19, 28), expected: 72 },\n     { actual: candidate(2020, 1851), expected: 0 },\n     { actual: candidate(14, -15), expected: 20 },\n     { actual: candidate(76, 67), expected: 42 },\n     { actual: candidate(17, 27), expected: 49 },\n     { actual: candidate(0, 1), expected: 0 },\n     { actual: candidate(0, 0), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_98","nl":"kan_Knda","pl":"go_test.go","prompt":"package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ನೀಡಿದರೆ, ದೊಡ್ಡಕ್ಷರ ಸ್ವರಗಳ ಸಂಖ್ಯೆಯನ್ನು ಸಹ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ ಎಣಿಸಿ.\/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunc count_upper(s string) int {\n","canonical_solution":"package count_upper_test\n\nimport (\n    \"testing\"\n)\n\nfunc count_upper(s string) int {\n    uppercaseVowels := \"AEIOU\"\n    count := 0\n    \n    for i := 0; i < len(s); i += 2 {\n        if contains(uppercaseVowels, s[i]) {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc contains(vowels string, ch byte) bool {\n    for i := 0; i < len(vowels); i++ {\n        if vowels[i] == ch {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCountUpper(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestCount_Upper(t *testing.T) {\n  candidate := count_upper\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"aBCdEf\"), expected: 1 },\n     { actual: candidate(\"abcdefg\"), expected: 0 },\n     { actual: candidate(\"dBBE\"), expected: 0 },\n     { actual: candidate(\"B\"), expected: 0 },\n     { actual: candidate(\"U\"), expected: 1 },\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"EEEE\"), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_99","nl":"kan_Knda","pl":"go_test.go","prompt":"package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಎರಡು ಪೂರ್ಣಾಂಕಗಳಿಂದ, ಅದನ್ನು ಶೂನ್ಯದಿಂದ ದೂರವಿರಿಸಿ.\/\/ಮತ್ತು ಅದಕ್ಕೆ ಸಮೀಪವಿರುವ ಪೂರ್ಣಾಂಕವನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ. ಸಂಖ್ಯೆ ಸಮದೂರದಲ್ಲಿದ್ದರೆ \/\/ಒಂದು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಮೌಲ್ಯವನ್ನು (ಸ್ಟ್ರಿಂಗ್) ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ \/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n","canonical_solution":"package closest_integer_test\n\nimport (\n\t\"strconv\"\n\t\"math\"\n)\n\nfunc closest_integer(value string) int {\n\tnum, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn 0 \/\/ handle error appropriately in real scenarios\n\t}\n\tif num > 0 {\n\t\treturn int(math.Ceil(num - 0.5))\n\t}\n\treturn int(math.Floor(num + 0.5))\n}","tests":"func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_100","nl":"kan_Knda","pl":"go_test.go","prompt":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/i ಮಟ್ಟದಲ್ಲಿ ಕಲ್ಲುಗಳ ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ (i+1).\/\/ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿ ಪ್ರತಿ ಮಟ್ಟದಲ್ಲಿ ಕಲ್ಲುಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, ಅಲ್ಲಿ ಅಂಶವು ಸೂಚ್ಯಂಕದಲ್ಲಿ \/\/- ಮುಂದಿನ ಸಮ ಸಂಖ್ಯೆಯ n ಸಮ ವೇಳೆ.\/\/- n ಬೆಸವಾಗಿದ್ದರೆ ಮುಂದಿನ ಬೆಸ ಸಂಖ್ಯೆ.\/\/ಮುಂದಿನ ಹಂತದಲ್ಲಿ ಕಲ್ಲುಗಳ ಸಂಖ್ಯೆಃ \/\/ಮೊದಲ ಹಂತದಲ್ಲಿ n ಕಲ್ಲುಗಳು ಇವೆ.\/\/ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ಅನ್ನು ನೀಡಿದರೆ, ನೀವು n ಮಟ್ಟದ ಕಲ್ಲುಗಳ ರಾಶಿಯನ್ನು ಮಾಡಬೇಕು.\/\/ >>> make_a_pile(3)\n\/\/ []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n","canonical_solution":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc make_a_pile(n int) []int {\n    pile := make([]int, n)\n    currentStones := n\n\n    for i := 0; i < n; i++ {\n        pile[i] = currentStones\n        if n%2 == 0 {\n            currentStones += 2\n        } else {\n            currentStones += 2\n        }\n    }\n\n    return pile\n}\n\nfunc TestMakeAPile(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected []int\n    }{\n        {3, []int{3, 5, 7}},\n        {4, []int{4, 6, 8, 10}},\n        {1, []int{1}},\n        {5, []int{5, 7, 9, 11, 13}},\n    }\n\n    for _, c := range cases {\n        res := make_a_pile(c.input)\n        if fmt.Sprintf(\"%v\", res) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"make_a_pile(%d) == %v, expected %v\", c.input, res, c.expected)\n        }\n    }\n}","tests":"func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual: candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_101","nl":"kan_Knda","pl":"go_test.go","prompt":"package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಪದಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸಲು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಪದಗಳಾಗಿ ವಿಭಜಿಸಲು.\/\/ನಿಮಗೆ ಅಲ್ಪವಿರಾಮ ಅಥವಾ ಅಂತರಗಳಿಂದ ಬೇರ್ಪಡಿಸಲಾದ ಪದಗಳ ಒಂದು ಸರಣಿಯನ್ನು ನೀಡಲಾಗುವುದು. ನಿಮ್ಮ ಕಾರ್ಯವು \/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n","canonical_solution":"package words_string_test\n\nimport (\n    \"testing\"\n    \"strings\"\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc words_string(s string) []string {\n    re := regexp.MustCompile(`[,\\s]+`)\n    return re.Split(s, -1)\n}\n\nfunc TestWordsString(t *testing.T) {\n    tests := []struct{\n        input string\n        expected []string\n    }{\n        {\"Hi, my name is John\", []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}},\n        {\"One, two, three, four, five, six\", []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}},\n        {\"a,b,c\", []string{\"a\", \"b\", \"c\"}},\n        {\"hello world\", []string{\"hello\", \"world\"}},\n    }\n\n    for _, test := range tests {\n        result := words_string(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestWords_String(t *testing.T) {\n  candidate := words_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi, my name is John\"), expected: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"} },\n     { actual: candidate(\"One, two, three, four, five, six\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"Hi, my name\"), expected: []string{\"Hi\", \"my\", \"name\"} },\n     { actual: candidate(\"One,, two, three, four, five, six,\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"ahmed     , gamal\"), expected: []string{\"ahmed\", \"gamal\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_102","nl":"kan_Knda","pl":"go_test.go","prompt":"package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಅಂತಹ ಯಾವುದೇ ಸಂಖ್ಯೆ ಇಲ್ಲ, ಆಗ ಕಾರ್ಯವು -1 ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.\/\/[x, y] ವ್ಯಾಪ್ತಿಯಲ್ಲಿರುವ ಅತಿದೊಡ್ಡ ಸಮ ಸಮ ಪೂರ್ಣಾಂಕ ಸಂಖ್ಯೆ.\/\/ಈ ಕಾರ್ಯವು ಎರಡು ಧನಾತ್ಮಕ ಸಂಖ್ಯೆಗಳನ್ನು x ಮತ್ತು y ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು  ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ\/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunc choose_num(x int, y int) int {\n","canonical_solution":"func choose_num(x int, y int) int {\n\tif x > y {\n\t\treturn -1\n\t}\n\t\/\/ Start from y and move backwards looking for the largest even number\n\tfor i := y; i >= x; i-- {\n\t\tif i%2 == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc TestChooseNum(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, expected int\n\t}{\n\t\t{12, 15, 14},\n\t\t{13, 12, -1},\n\t\t{4, 10, 10},\n\t\t{5, 5, -1},\n\t\t{6, 6, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"x=%d_y=%d\", test.x, test.y), func(t *testing.T) {\n\t\t\tresult := choose_num(test.x, test.y)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For choose_num(%d, %d), expected %d, but got %d\", test.x, test.y, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestChoose_Num(t *testing.T) {\n  candidate := choose_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(12, 15), expected: 14 },\n     { actual: candidate(13, 12), expected: -1 },\n     { actual: candidate(33, 12354), expected: 12354 },\n     { actual: candidate(5234, 5233), expected: -1 },\n     { actual: candidate(6, 29), expected: 28 },\n     { actual: candidate(27, 10), expected: -1 },\n     { actual: candidate(7, 7), expected: -1 },\n     { actual: candidate(546, 546), expected: 546 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_104","nl":"kan_Knda","pl":"go_test.go","prompt":"package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಗಮನಿಸಿ: ಹಿಂದಿರುಗಿಸಿದ ಪಟ್ಟಿಯನ್ನು ಹೆಚ್ಚುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಬೇಕು.\/\/ಯಾವುದೇ ಜೋಡಿ ಅಂಕಿಯ ಅಂಶಗಳಿಲ್ಲ.\/\/ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ x. ಎಲ್ಲಾ  ನ ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ\/\/ >>> unique_digits([]int{15, 33, 1422, 1})\n\/\/ []int{1, 15, 33}\n\/\/ >>> unique_digits([]int{152, 323, 1422, 10})\n\/\/ []int{}\nfunc unique_digits(x []int) []int {\n","canonical_solution":"package unique_digits_test\n\nimport (\n    \"sort\"\n)\n\n\/\/ unique_digits returns a sorted list of all elements that don't have any even digit.\nfunc unique_digits(x []int) []int {\n    result := []int{}\n    for _, num := range x {\n        if hasEvenDigit(num) == false {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\n\/\/ hasEvenDigit checks if a given number contains any even digit.\nfunc hasEvenDigit(num int) bool {\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            return true\n        }\n        num \/= 10\n    }\n    return false\n}","tests":"func TestUnique_Digits(t *testing.T) {\n  candidate := unique_digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },\n     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },\n     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },\n     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_105","nl":"kan_Knda","pl":"go_test.go","prompt":"package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/\"ಒಂದು\", \"ಎರಡು\", \"ಮೂರು\", \"ನಾಲ್ಕು\", \"ಐದು\", \"ಆರು\", \"ಏಳು\", \"ಎಂಟು\", \"ಒಂಬತ್ತು\" \/\/ಫಲಿತಾಂಶದ ಪಟ್ಟಿಯನ್ನು ಹಿಮ್ಮುಖಗೊಳಿಸಿ, ನಂತರ ಪ್ರತಿ ಅಂಕಿಯನ್ನು ಅದರ ಅನುಗುಣವಾದ ಹೆಸರಿನಿಂದ \/\/ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, 1 ಮತ್ತು 9 ರ ನಡುವಿನ ಪೂರ್ಣಾಂಕಗಳನ್ನು ವಿಂಗಡಿಸಿ,\/\/ >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n\/\/ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\/\/ If the list is empty, return an empty list:\n\/\/ >>> by_length([]int{})\n\/\/ []string{}\n\/\/ If the list has any strange number ignore it:\n\/\/ >>> by_length([]int{1, -1, 55})\n\/\/ []string{\"One\"}\nfunc by_length(arr []int) []string {\n","canonical_solution":"package by_length_test\n\nimport (\n    \"testing\"\n    \"sort\"\n)\n\nfunc by_length(arr []int) []string {\n    \/\/ Filter numbers between 1 and 9\n    filtered := []int{}\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            filtered = append(filtered, num)\n        }\n    }\n\n    \/\/ Sort in ascending order\n    sort.Ints(filtered)\n\n    \/\/ Reverse the sorted slice\n    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n        filtered[i], filtered[j] = filtered[j], filtered[i]\n    }\n\n    \/\/ Map numbers to their corresponding names\n    numToString := map[int]string{\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\",\n    }\n\n    \/\/ Create the result slice with names\n    result := []string{}\n    for _, num := range filtered {\n        result = append(result, numToString[num])\n    }\n\n    return result\n}\n\nfunc TestByLength(t *testing.T) {\n    tests := []struct {\n        input []int\n        want  []string\n    }{\n        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}},\n        {[]int{}, []string{}},\n        {[]int{1, -1, 55}, []string{\"One\"}},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n            got := by_length(test.input)\n            if !equals(got, test.want) {\n                t.Errorf(\"got = %v; want %v\", got, test.want)\n            }\n        })\n    }\n}\n\nfunc equals(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_106","nl":"kan_Knda","pl":"go_test.go","prompt":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/i ನ ಅಂಶವು 1 ರಿಂದ i ಗೆ ಸಂಖ್ಯೆಗಳ ಗುಣಾಕಾರವಾಗಿದೆ (1 * 2 * . . . * i).\/\/i 1 ರಿಂದ ಪ್ರಾರಂಭವಾಗುತ್ತದೆ.\/\/ಅಥವಾ 1 ರಿಂದ i ರವರೆಗಿನ ಸಂಖ್ಯೆಗಳ ಮೊತ್ತ.\/\/ಮತ್ತು n ಗಾತ್ರದ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, ಅಂದರೆ ಸೂಚ್ಯಂಕ i ನಲ್ಲಿನ ಅಂಶದ ಮೌಲ್ಯವು i ನ ಅಂಶವಾಗಿದೆ, ಅದು i ಕೂಡಿದ್ದರೆ \/\/n ಅನ್ನು ನಿಯತಾಂಕವಾಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಕಾರ್ಯವನ್ನು f ಅನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸಿ, \/\/ >>> f(5)\n\/\/ []int{1, 2, 6, 24, 15}\nfunc f(n int) []int {\n","canonical_solution":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(num int) int {\n    if num <= 1 {\n        return 1\n    }\n    return num * factorial(num-1)\n}\n\nfunc sum(num int) int {\n    s := 0\n    for i := 1; i <= num; i++ {\n        s += i\n    }\n    return s\n}\n\nfunc TestF(t *testing.T) {\n    expected := []int{1, 2, 6, 24, 15}\n    result := f(5)\n    if !equals(expected, result) {\n        t.Errorf(\"Expected %v, got %v\", expected, result)\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(f(5)) \/\/ Output: []int{1, 2, 6, 24, 15}\n}","tests":"func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },\n     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },\n     { actual: candidate(1), expected: []int{1} },\n     { actual: candidate(3), expected: []int{1, 2, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_107","nl":"kan_Knda","pl":"go_test.go","prompt":"package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ 1: \/\/ವ್ಯಾಪ್ತಿಯಲ್ಲಿರುವ ಪೂರ್ಣಾಂಕ ಪಾಲಿಂಡ್ರೋಮ್ಗಳು ((1, n), ಸೇರಿದಂತೆ.\/\/ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, ಸಮ ಮತ್ತು ಅಪರೂಪದ ಸಂಖ್ಯೆಯನ್ನು ಹೊಂದಿರುವ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿ \/\/ >>> even_odd_palindrome(3)\n\/\/ []interface{}{1, 2}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ []interface{}{4, 6}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned list has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n int) []interface{} {\n","canonical_solution":"func isPalindrome(num int) bool {\n    original := num\n    reversed := 0\n    for num > 0 {\n        reversed = reversed*10 + num%10\n        num \/= 10\n    }\n    return original == reversed\n}\n\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount, oddCount := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n}","tests":"func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8, 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     { actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63), expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5, 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     { actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1), expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_108","nl":"kan_Knda","pl":"go_test.go","prompt":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ -123 ಅಂಕಿಗಳು -1, 2, ಮತ್ತು 3 \/\/ಒಂದು ಸಂಖ್ಯೆಯು ಋಣಾತ್ಮಕವಾಗಿದ್ದರೆ, ಅದರ ಮೊದಲ ಸಹಿ ಮಾಡಿದ ಅಂಕಿಯು ಋಣಾತ್ಮಕವಾಗಿರುತ್ತದೆ:\/\/ಅಂಶಗಳ ಸಂಖ್ಯೆ, ಇದರಲ್ಲಿ ಅಂಕೆಗಳ ಮೊತ್ತವು > 0 ಆಗಿದೆ.\/\/ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಹಿಂದಿರುಗಿಸುವ count_nums ಎಂಬ ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ \/\/ >>> count_nums([]int{})\n\/\/ 0\n\/\/ >>> count_nums([]int{-1, 11, -11})\n\/\/ 1\n\/\/ >>> count_nums([]int{1, 1, 2})\n\/\/ 3\nfunc count_nums(arr []int) int {\n","canonical_solution":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        digits := num\n        sum := 0\n\n        if digits < 0 {\n            sum = digits % 10\n            digits = -digits \/ 10\n        }\n\n        for digits > 0 {\n            sum += digits % 10\n            digits \/= 10\n        }\n\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCountNums(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{}, 0},\n        {[]int{-1, 11, -11}, 1},\n        {[]int{1, 1, 2}, 3},\n    }\n\n    for _, tc := range testCases {\n        result := count_nums(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %v, got %v\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(count_nums([]int{-1, 11, -11})) \/\/ Output: 1\n    fmt.Println(count_nums([]int{1, 1, 2}))    \/\/ Output: 3\n}","tests":"func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_109","nl":"kan_Knda","pl":"go_test.go","prompt":"package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಗಮನಿಸಿ: ನೀಡಲಾದ ಪಟ್ಟಿಯು ಅನನ್ಯ ಅಂಶಗಳನ್ನು ಹೊಂದಿರುವುದು ಖಾತರಿಪಡಿಸುತ್ತದೆ.\/\/ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯು ಖಾಲಿಯಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ನಂತರ true ಅನ್ನು ಹಿಂತಿರುಗಿ ಇಲ್ಲದಿದ್ದರೆ false ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಮೇಲಿನ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ನಿರ್ವಹಿಸುವ ಮೂಲಕ ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಪಡೆಯುವುದು ಸಾಧ್ಯವಿದ್ದರೆ \/\/ಪಟ್ಟಿಯಲ್ಲಿನ ಆರಂಭಿಕ ಸ್ಥಾನ ಅಂದರೆ 0 ನೇ ಸೂಚ್ಯಂಕ.\/\/ಪಟ್ಟಿಯ ಕೊನೆಯ ಅಂಶವನ್ನು  ಗೆ ಸರಿಸಲಾಗುವುದು\/\/ಒಂದು ಬಲಕ್ಕೆ ಚಲಿಸುವ ಕಾರ್ಯಾಚರಣೆಯು ಪಟ್ಟಿಯ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ಒಂದು ಮೂಲಕ ಚಲಿಸುವಂತೆ ಮಾಡುತ್ತದೆ.\/\/ನೀವು ಬಲ ಶಿಫ್ಟ್ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ಯಾವುದೇ ಸಂಖ್ಯೆಯ ಬಾರಿ ನಿರ್ವಹಿಸಲು ಅನುಮತಿಸಲಾಗಿದೆ.\/\/ಈ ಕೆಳಗಿನ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ನೀಡಿರುವ ಪಟ್ಟಿಯಲ್ಲಿ ಸೇರಿಸಲಾಗಿದೆಃ \/\/ ಅನ್ನು ನಿರ್ವಹಿಸುವ ಮೂಲಕ ಪಟ್ಟಿಯನ್ನು ಇಳಿಕೆಯಾಗದ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಲು ಸಾಧ್ಯವಿದೆ.\/\/ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸಂಖ್ಯೆಗಳನ್ನು ಯಾದೃಚ್ಛಿಕವಾಗಿ ಆದೇಶಿಸಲಾಗುತ್ತದೆ. ನಿಮ್ಮ ಕಾರ್ಯವು \/\/ನಾವು N ಪೂರ್ಣಾಂಕಗಳ arr[1], arr[2], ..., arr[N] ನ ಒಂದು ಪಟ್ಟಿಯನ್ನು ಹೊಂದಿದ್ದೇವೆ.\/\/ >>> move_one_ball([]int{3, 4, 5, 1, 2})\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given list.\n\/\/ >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n","canonical_solution":"func move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n\n    \/\/ Detect the point where the order breaks\n    countBreaks := 0\n    index := -1\n\n    for i := 0; i < n; i++ {\n        if arr[i] > arr[(i+1)%n] {\n            countBreaks++\n            index = i\n        }\n    }\n\n    \/\/ If there is at most one point where the order breaks\n    if countBreaks <= 1 {\n        return true\n    }\n\n    return false\n}","tests":"func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_110","nl":"kan_Knda","pl":"go_test.go","prompt":"package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಇಲ್ಲದಿದ್ದರೆ, \"NO\" ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/lst1 ನ ಎಲ್ಲಾ ಅಂಶಗಳು ಸಮವಾಗಿದ್ದರೆ, \"YES\" ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಇದು ಸಾಧ್ಯ ವೇಳೆ ಅಂಶಗಳನ್ನು ವಿನಿಮಯ ನಡುವೆ lst1 ಮತ್ತು lst2 ಮಾಡಲು \/\/lst1 ಮತ್ತು lst2 ನಡುವೆ ವಿನಿಮಯ ಮಾಡಿಕೊಳ್ಳುವ ಅಂಶಗಳ ಸಂಖ್ಯೆಗೆ ಯಾವುದೇ ಮಿತಿಯಿಲ್ಲ.\/\/ವು ಕೇವಲ ಸಮ ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ಮಾಡಲು.\/\/ಮತ್ತು ಅಂಶಗಳ ವಿನಿಮಯವನ್ನು ನಿರ್ವಹಿಸಲು ಸಾಧ್ಯವಿದೆಯೇ ಎಂದು ನಿರ್ಧರಿಸುತ್ತದೆ \/\/ಈ ಸಮಸ್ಯೆಯಲ್ಲಿ, ನೀವು ಎರಡು ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಗಳನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸುತ್ತೀರಿ, \/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})\n\/\/ \"YES\"\n\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})\n\/\/ \"NO\"\n\/\/ It is assumed that the input lists will be non-empty.\nfunc exchange(lst1 []int, lst2 []int) string {\n","canonical_solution":"func exchange(lst1 []int, lst2 []int) string {\n    hasEvenInLst2 := false\n    \n    for _, num := range lst2 {\n        if num%2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasEvenInLst2 {\n        return \"NO\"\n    }\n    \n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"YES\"\n        }\n    }\n\n    return \"YES\"\n}","tests":"func TestExchange(t *testing.T) {\n  candidate := exchange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: \"YES\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: \"NO\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: \"NO\" },\n     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: \"NO\" },\n     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: \"YES\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_111","nl":"kan_Knda","pl":"go_test.go","prompt":"package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಹಲವಾರು ಅಕ್ಷರಗಳು ಒಂದೇ ರೀತಿಯ ಸಂಭವವನ್ನು ಹೊಂದಿದ್ದರೆ, ಅವೆಲ್ಲವನ್ನೂ ಹಿಂತಿರುಗಿ.\/\/ಹೆಚ್ಚು ಪುನರಾವರ್ತನೆಯಾಗುವ ಅಕ್ಷರ ಮತ್ತು ಅದಕ್ಕೆ ಅನುಗುಣವಾದ ಸಂಖ್ಯೆಯನ್ನು ಹೊಂದಿರುವ ಅಕ್ಷರದ.\/\/ಒಂದು ಸ್ಥಳವನ್ನು ಪ್ರತ್ಯೇಕಿಸಿದ ಸಣ್ಣ ಅಕ್ಷರಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ನೀಡಲಾಗಿದೆ, ನಕ್ಷೆಯನ್ನು ಹಿಂತಿರುಗಿಸಿ \/\/ >>> histogram(\"a b c\")\n\/\/ map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ map[string]int{\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ map[string]int{}\nfunc histogram(test string) map[string]int {\n","canonical_solution":"package histogram_test\n\nimport (\n    \"strings\"\n)\n\nfunc histogram(test string) map[string]int {\n    if test == \"\" {\n        return map[string]int{}\n    }\n\n    counts := make(map[string]int)\n    words := strings.Fields(test)\n    \n    var maxCount int\n    for _, word := range words {\n        counts[word]++\n        if counts[word] > maxCount {\n            maxCount = counts[word]\n        }\n    }\n\n    result := make(map[string]int)\n    for key, count := range counts {\n        if count == maxCount {\n            result[key] = count\n        }\n    }\n\n    return result\n}","tests":"func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_112","nl":"kan_Knda","pl":"go_test.go","prompt":"package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ \/\/ನೀವು ಫಲಿತಾಂಶದ ಸ್ಟ್ರಿಂಗ್ ಮತ್ತು ಚೆಕ್ಗಾಗಿ true\/false ಅನ್ನು ಒಳಗೊಂಡಿರುವ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು.\/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಪಾಲಿಂಡ್ರೋಮ್ ಎಂದು ಕರೆಯಲಾಗುತ್ತದೆ, ಅದು ಹಿಂದಕ್ಕೆ ಮತ್ತು ಮುಂದಕ್ಕೆ ಒಂದೇ ರೀತಿ ಓದುತ್ತದೆ.\/\/ನಂತರ ಫಲಿತಾಂಶದ ಸ್ಟ್ರಿಂಗ್ ಪಾಲಿಂಡ್ರೋಮ್ ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.\/\/ನಮಗೆ s ಮತ್ತು c ಎಂಬ ಎರಡು ಸ್ಟ್ರಿಂಗ್ ಗಳು ನೀಡಲಾಗಿದೆ, ನೀವು s ನಲ್ಲಿರುವ ಎಲ್ಲಾ ಅಕ್ಷರಗಳನ್ನು ಅಳಿಸಬೇಕು ಅದು c ನಲ್ಲಿರುವ ಯಾವುದೇ ಅಕ್ಷರಕ್ಕೆ ಸಮನಾಗಿರುತ್ತದೆ \/\/ಕಾರ್ಯ \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ []interface{}{\"bcd\", false}\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ []interface{}{\"acdef\", false}\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ []interface{}{\"cdedc\", true}\nfunc reverse_delete(s string, c string) []interface{} {\n","canonical_solution":"func reverse_delete(s string, c string) []interface{} {\n    \/\/ Create a map to store the characters to be deleted\n    deleteMap := make(map[rune]bool)\n    for _, ch := range c {\n        deleteMap[ch] = true\n    }\n    \n    \/\/ Filter the string s by removing characters present in deleteMap\n    var filteredString []rune\n    for _, ch := range s {\n        if !deleteMap[ch] {\n            filteredString = append(filteredString, ch)\n        }\n    }\n    \n    \/\/ Check if the filtered string is a palindrome\n    n := len(filteredString)\n    isPalindrome := true\n    for i := 0; i < n\/2; i++ {\n        if filteredString[i] != filteredString[n-1-i] {\n            isPalindrome = false\n            break\n        }\n    }\n    \n    \/\/ Convert filteredString to a string and prepare result\n    resultString := string(filteredString)\n    return []interface{}{resultString, isPalindrome}\n}","tests":"func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\", \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_113","nl":"kan_Knda","pl":"go_test.go","prompt":"package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇನ್ಪುಟ್ನ i'th ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಬೆಸ ಅಂಕೆಗಳ ಸಂಖ್ಯೆ.\/\/ಇನ್ಪುಟ್ನ ಸ್ಟ್ರಿಂಗ್ i. \" ಅಲ್ಲಿ ಎಲ್ಲಾ i ಗಳನ್ನು ಸಂಖ್ಯೆಯಿಂದ ಬದಲಾಯಿಸಬೇಕು\/\/ಔಟ್ಪುಟ್ನ ಪ್ರತಿ ಅಂಶ i \"ಒಂದು  ರಲ್ಲಿ ಬೆಸ ಅಂಶಗಳ ಸಂಖ್ಯೆ ಇರಬೇಕು\/\/ಪ್ರತಿ ಸ್ಟ್ರಿಂಗ್ ಕೇವಲ ಅಂಕೆಗಳನ್ನು ಒಳಗೊಂಡಿರುವ ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ, ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.\/\/ >>> odd_count([]string{\"1234567\"})\n\/\/ []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n\/\/ >>> odd_count([]string{\"3\", \"11111111\"})\n\/\/ []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}\nfunc odd_count(lst []string) []string {\n","canonical_solution":"package odd_count_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc odd_count(lst []string) []string {\n\tresult := []string{}\n\tfor _, str := range lst {\n\t\toddCount := 0\n\t\tfor _, char := range str {\n\t\t\tif char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {\n\t\t\t\toddCount++\n\t\t\t}\n\t\t}\n\t\toutput := fmt.Sprintf(\"the number of odd elements %dn the str%1ng %d of the %dnput.\", oddCount, oddCount, oddCount)\n\t\tresult = append(result, output)\n\t}\n\treturn result\n}\n\nfunc TestOddCount(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{[]string{\"1234567\"}, []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}},\n\t\t{[]string{\"3\", \"11111111\"}, []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif result := odd_count(test.input); !equals(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equals(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOdd_Count(t *testing.T) {\n  candidate := odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"1234567\"}), expected: []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"} },\n     { actual: candidate([]string{\"3\", \"11111111\"}), expected: []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"} },\n     { actual: candidate([]string{\"271\", \"137\", \"314\"}), expected: []string{\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_114","nl":"kan_Knda","pl":"go_test.go","prompt":"package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ \/\/ಗಳು\/\/ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ಯಾವುದೇ ಖಾಲಿ ಅಲ್ಲದ ಉಪ-ಪಟ್ಟಿಯ ಕನಿಷ್ಠ ಮೊತ್ತವನ್ನು ಕಂಡುಹಿಡಿಯಿರಿ \/\/ >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n\/\/ 1\n\/\/ >>> minSubArraySum([]int{-1, -2, -3})\n\/\/ -6\nfunc minSubArraySum(nums []int) int {\n","canonical_solution":"if len(nums) == 0 {\n        return 0\n    }\n    \n    minEndingHere := nums[0]\n    minSoFar := nums[0]\n\n    for _, num := range nums[1:] {\n        if minEndingHere > 0 {\n            minEndingHere = num\n        } else {\n            minEndingHere += num\n        }\n        \n        if minEndingHere < minSoFar {\n            minSoFar = minEndingHere\n        }\n    }\n    \n    return minSoFar\n}","tests":"func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     { actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}), expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_115","nl":"kan_Knda","pl":"go_test.go","prompt":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ 1: \/\/ನೀವು ಬಕೆಟ್ಗಳನ್ನು ಕಡಿಮೆ ಮಾಡಲು ಅಗತ್ಯವಿರುವ ಬಾರಿ ಔಟ್ಪುಟ್. \/\/ನಿಮ್ಮ ಕೆಲಸವೆಂದರೆ ಬಕೆಟ್ ಗಳನ್ನು ಬಳಸಿಕೊಂಡು ಬಾವಿಯನ್ನು ಖಾಲಿ ಮಾಡುವುದು.\/\/ಮತ್ತು ಎಲ್ಲಾ ಬಕೆಟ್ಗಳು ಒಂದೇ ಸಾಮರ್ಥ್ಯವನ್ನು ಹೊಂದಿವೆ.\/\/ಪ್ರತಿಯೊಂದು ಬಾವಿಯಲ್ಲಿಯೂ ಅದಕ್ಕೆ ತಕ್ಕಂತೆ ಒಂದು ಬಕೆಟ್ ಇದೆ, ಅದನ್ನು ನೀರನ್ನು ಹೊರತೆಗೆಯಲು ಬಳಸಬಹುದು,\/\/ಮತ್ತು ಪ್ರತಿ 1 ರೇಖೆಯು ಒಂದು ಏಕ ಘಟಕ ನೀರನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.\/\/ನಿಮಗೆ ಒಂದು ಆಯತಾಕಾರದ ಗ್ರಿಡ್ ನೀಡಲಾಗಿದೆ. ಪ್ರತಿ ಸಾಲು ಒಂದೇ ಒಂದು ಬಾವಿಯನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ, \/\/ >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid [][]int, capacity int) int {\n","canonical_solution":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_fill(grid [][]int, capacity int) int {\n    totalLowerings := 0\n\n    for _, row := range grid {\n        waterInRow := 0\n        \n        for _, cell := range row {\n            if cell == 1 {\n                waterInRow++\n            }\n        }\n\n        totalLowerings += (waterInRow + capacity - 1) \/ capacity\n    }\n\n    return totalLowerings\n}\n\nfunc TestMaxFill(t *testing.T) {\n    tests := []struct {\n        grid     [][]int\n        capacity int\n        expected int\n    }{\n        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},\n        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},\n        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},\n    }\n\n    for _, test := range tests {\n        result := max_fill(test.grid, test.capacity)\n        if result != test.expected {\n            t.Errorf(\"For grid %v with capacity %d, expected %d but got %d\", test.grid, test.capacity, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) \/\/ Output: 6\n    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) \/\/ Output: 5\n    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) \/\/ Output: 0\n}","tests":"func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_116","nl":"kan_Knda","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಇದನ್ನು ಈ ರೀತಿ ಅನುಷ್ಠಾನಗೊಳಿಸಬೇಕು:\/\/ಒಂದೇ ರೀತಿಯ ಸಂಖ್ಯೆಯ ಒಂದುಗಳಿಗೆ, ದಶಮಾಂಶ ಮೌಲ್ಯದ ಆಧಾರದ ಮೇಲೆ ವಿಂಗಡಿಸಿ.\/\/ಅವುಗಳ ಬೈನರಿ ಪ್ರಾತಿನಿಧ್ಯದಲ್ಲಿ ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ಇರುವ ಒಂದುಗಳ ಸಂಖ್ಯೆ.\/\/ಈ ಕಟಾದಲ್ಲಿ, ನೀವು  ಪ್ರಕಾರ ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ವಿಂಗಡಿಸಬೇಕು\/\/ >>> sort_array([]int{1, 5, 2, 3, 4})\n\/\/ []int{1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{-2, -3, -4, -5, -6})\n\/\/ []int{-6, -5, -4, -3, -2}\n\/\/ >>> sort_array([]int{1, 0, 2, 3, 4})\n\/\/ []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(arr []int) []int {\n    sort.Slice(arr, func(i, j int) bool {\n        countOnes := func(x int) int {\n            count := 0\n            for x != 0 {\n                count += x & 1\n                x >>= 1\n            }\n            return count\n        }\n\n        countI := countOnes(arr[i])\n        countJ := countOnes(arr[j])\n\n        if countI == countJ {\n            return arr[i] < arr[j]\n        }\n        return countI < countJ\n    })\n    return arr\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_117","nl":"kan_Knda","pl":"go_test.go","prompt":"package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಗಮನಿಸಿ: ನೀವು ಇನ್ಪುಟ್ ಸ್ಟ್ರಿಂಗ್ ಅಕ್ಷರಗಳು ಮತ್ತು ಅಂತರಗಳನ್ನು ಮಾತ್ರ ಹೊಂದಿದೆ ಎಂದು ಭಾವಿಸಬಹುದು.\/\/ಸ್ಟ್ರಿಂಗ್ s ಖಾಲಿಯಾಗಿದ್ದರೆ, ಕಾರ್ಯವು ಖಾಲಿಯಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.\/\/n ವ್ಯಂಜನಗಳು, ಈ ಪದಗಳು ಸ್ಟ್ರಿಂಗ್ s ನಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುವ ಕ್ರಮದಲ್ಲಿ.\/\/ಒಂದು ಕಾರ್ಯವು ಸ್ಟ್ರಿಂಗ್ s ಯಿಂದ ಎಲ್ಲಾ ಪದಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ ಅದು ನಿಖರವಾಗಿ \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ಮತ್ತು ಒಂದು ನೈಸರ್ಗಿಕ ಸಂಖ್ಯೆಯನ್ನು ನೀಡಿದರೆ, ನೀವು ಕಾರ್ಯಗತಗೊಳಿಸಲು ಕಾರ್ಯಗತಗೊಳಿಸಿದ್ದೀರಿ \/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ []string{\"little\"}\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ []string{\"Mary\", \"lamb\"}\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []string{}\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ []string{\"world\"}\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n","canonical_solution":"package select_words_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc select_words(s string, n int) []string {\n\t\/\/ Define a helper function to check if a character is a consonant.\n\tisConsonant := func(c rune) bool {\n\t\tc = rune(strings.ToLower(string(c))[0])\n\t\treturn c >= 'a' && c <= 'z' && !strings.ContainsRune(\"aeiou\", c)\n\t}\n\n\t\/\/ Split the string into words.\n\twords := strings.Fields(s)\n\tvar result []string\n\n\t\/\/ Iterate over each word.\n\tfor _, word := range words {\n\t\tconsonantCount := 0\n\t\t\/\/ Count the consonants in the word.\n\t\tfor _, char := range word {\n\t\t\tif isConsonant(char) {\n\t\t\t\tconsonantCount++\n\t\t\t}\n\t\t}\n\t\t\/\/ If the number of consonants matches n, add the word to the result.\n\t\tif consonantCount == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestSelectWords(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tn        int\n\t\texpected []string\n\t}{\n\t\t{\"Mary had a little lamb\", 4, []string{\"little\"}},\n\t\t{\"Mary had a little lamb\", 3, []string{\"Mary\", \"lamb\"}},\n\t\t{\"simple white space\", 2, []string{}},\n\t\t{\"Hello world\", 4, []string{\"world\"}},\n\t\t{\"Uncle sam\", 3, []string{\"Uncle\"}},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tresult := select_words(testCase.s, testCase.n)\n\t\tif !equal(result, testCase.expected) {\n\t\t\tt.Errorf(\"For input '%s' with n=%d, expected %v, but got %v\", testCase.s, testCase.n, testCase.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_118","nl":"kan_Knda","pl":"go_test.go","prompt":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಕೊಟ್ಟಿರುವ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿ ಇಂಗ್ಲಿಷ್ ಅಕ್ಷರ ಮಾತ್ರ ಇದೆ ಎಂದು ನೀವು ಭಾವಿಸಬಹುದು.\/\/ಮೇಲಿನ ಸ್ಥಿತಿಯನ್ನು ಪೂರೈಸಿದ ಯಾವುದೇ ಸ್ವರವನ್ನು ಹುಡುಕಿ.\/\/ಆರಂಭದಲ್ಲಿ ಮತ್ತು ಅಂತ್ಯದಲ್ಲಿನ ಸ್ವರಗಳು ಎಣಿಸುವುದಿಲ್ಲ. ನೀವು ಮಾಡದಿದ್ದರೆ ಖಾಲಿ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿ \/\/ಪದದ ಬಲ ಭಾಗದಿಂದ ಎರಡು ವ್ಯಂಜನಗಳು (ಪ್ರಮಾಣದ ಸೂಕ್ಷ್ಮ).\/\/ನಿಮಗೆ ಒಂದು ಪದ ನೀಡಲಾಗಿದೆ. ನಿಮ್ಮ ಕಾರ್ಯವು  ನಡುವೆ ಇರುವ ಹತ್ತಿರದ ಸ್ವರವನ್ನು ಕಂಡುಹಿಡಿಯುವುದು\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunc get_closest_vowel(word string) string {\n","canonical_solution":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_closest_vowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    isVowel := make(map[rune]bool)\n    for _, v := range vowels {\n        isVowel[v] = true\n    }\n    \n    n := len(word)\n    for i := n-2; i > 0; i-- {\n        if isVowel[rune(word[i])] && \n           !isVowel[rune(word[i-1])] && \n           !isVowel[rune(word[i+1])] {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\/\/ Test functions\nfunc TestGetClosestVowel(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"yogurt\", \"u\"},\n        {\"FULL\", \"U\"},\n        {\"quick\", \"\"},\n        {\"ab\", \"\"},\n    }\n    \n    for _, test := range tests {\n        result := get_closest_vowel(test.input)\n        if result != test.expected {\n            t.Errorf(\"get_closest_vowel(%q) = %q; want %q\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(get_closest_vowel(\"yogurt\")) \/\/ Output: \"u\"\n    fmt.Println(get_closest_vowel(\"FULL\"))   \/\/ Output: \"U\"\n    fmt.Println(get_closest_vowel(\"quick\"))  \/\/ Output: \"\"\n    fmt.Println(get_closest_vowel(\"ab\"))     \/\/ Output: \"\"\n}","tests":"func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_119","nl":"kan_Knda","pl":"go_test.go","prompt":"package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಒಂದು ಉತ್ತಮ ಸ್ಟ್ರಿಂಗ್ ಮಾಡಲು ಒಂದು ಮಾರ್ಗವಿದ್ದರೆ 'ಹೌದು' ಅನ್ನು ಹಿಂತಿರುಗಿ, ಮತ್ತು ಇಲ್ಲದಿದ್ದರೆ 'ಇಲ್ಲ' ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/\" (()) \" ಅಲ್ಲ.\/\/ಸಮತೋಲಿತವಾಗಿದೆ. ಉದಾಹರಣೆಗೆ: '(((() ' ಸ್ಟ್ರಿಂಗ್ ಒಳ್ಳೆಯದು, ಆದರೆ ಸ್ಟ್ರಿಂಗ್ \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ S ಅನ್ನು ಉತ್ತಮವೆಂದು ಪರಿಗಣಿಸಲಾಗುತ್ತದೆ ಮತ್ತು ಎಲ್ಲಾ ಆವರಣಗಳು S \/\/ಕೆಲವು ಕ್ರಮದಲ್ಲಿ, ಪರಿಣಾಮವಾಗಿರುವ ಸ್ಟ್ರಿಂಗ್ ಉತ್ತಮವಾಗಿರುತ್ತದೆ.\/\/ನಿಮ್ಮ ಕೆಲಸವು ಎರಡು ತಂತಿಗಳನ್ನು ಸಂಯೋಜಿಸಲು ಸಾಧ್ಯವಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸುವುದು.\/\/ಬ್ರಾಂಡೆಸ್ \" ((\" ಅಥವಾ ಮುಚ್ಚಿದ ಬ್ರಾಂಡೆಸ್ \") \" ಮಾತ್ರ.\/\/ನೀವು ಎರಡು ತಂತಿಗಳನ್ನು ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗುತ್ತದೆ, ಎರಡೂ ತಂತಿಗಳು ಮುಕ್ತ ಒಳಗೊಂಡಿರುತ್ತವೆ \/\/ >>> match_parens([]string{\"()(\", \")\"})\n\/\/ \"Yes\"\n\/\/ >>> match_parens([]string{\")\", \")\"})\n\/\/ \"No\"\nfunc match_parens(lst []string) string {\n","canonical_solution":"func match_parens(lst []string) string {\n\tleft1, right1 := countParens(lst[0])\n\tleft2, right2 := countParens(lst[1])\n\n\tif left1+left2 == right1+right2 {\n\t\treturn \"Yes\"\n\t}\n\n\tif left1-right1+left2-right2 == 0 {\n\t\treturn \"Yes\"\n\t}\n\n\treturn \"No\"\n}\n\nfunc countParens(s string) (left int, right int) {\n\tfor _, c := range s {\n\t\tif c == '(' {\n\t\t\tleft++\n\t\t} else if c == ')' {\n\t\t\tright++\n\t\t}\n\t}\n\treturn\n}\n\nfunc TestMatchParens(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected string\n\t}{\n\t\t{[]string{\"()(\", \")\"}, \"Yes\"},\n\t\t{[]string{\")\", \")\"}, \"No\"},\n\t\t{[]string{\"(((\", \")))\"}, \"Yes\"},\n\t\t{[]string{\"(\", \")\"}, \"Yes\"},\n\t\t{[]string{\"))(\", \"(\"}, \"No\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tif got := match_parens(test.input); got != test.expected {\n\t\t\t\tt.Errorf(\"match_parens(%v) = %v; want %v\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_120","nl":"kan_Knda","pl":"go_test.go","prompt":"package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ 1: \/\/k ಉದ್ದದ ಗರಿಷ್ಠ k ಸಂಖ್ಯೆಗಳೊಂದಿಗೆ arr. \/\/ಪೂರ್ಣಾಂಕಗಳ arr ಪಟ್ಟಿಯನ್ನು ಮತ್ತು k ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕವನ್ನು ನೀಡಿದರೆ, ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ \/\/ >>> maximum([]int{-3, -4, 5}, 3)\n\/\/ []int{-4, -3, 5}\n\/\/ Example 2:\n\/\/ >>> maximum([]int{4, -4, 4}, 2)\n\/\/ []int{4, 4}\n\/\/ Example 3:\n\/\/ >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n\/\/ []int{2}\n\/\/ Note:\n\/\/ 1. The length of the list will be in the range of [1, 1000].\n\/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n","canonical_solution":"package maximum_test\n\nimport (\n    \"sort\"\n)\n\nfunc maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    \n    \/\/ Sort the array\n    sort.Ints(arr)\n    \n    \/\/ Get the last k elements, which are the largest\n    return arr[len(arr)-k:]\n}","tests":"func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_121","nl":"kan_Knda","pl":"go_test.go","prompt":"package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಪೂರ್ಣಾಂಕಗಳ ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ಸಮ ಸ್ಥಾನದಲ್ಲಿರುವ ಎಲ್ಲಾ ಬೆಸ ಅಂಶಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿಸಿ.\/\/ >>> solution([]int{5, 8, 7, 1})\n\/\/ 12\n\/\/ >>> solution([]int{3, 3, 3, 3, 3})\n\/\/ 9\n\/\/ >>> solution([]int{30, 13, 24, 321})\n\/\/ 0\nfunc solution(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 0; i < len(lst); i++ {\n        if i%2 == 0 && lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestSolution(t *testing.T) {\n  candidate := solution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },\n     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },\n     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },\n     { actual: candidate([]int{5, 9}), expected: 5 },\n     { actual: candidate([]int{2, 4, 8}), expected: 0 },\n     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },\n     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_122","nl":"kan_Knda","pl":"go_test.go","prompt":"package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/arr ನ ಮೊದಲ k ಅಂಶಗಳಿಂದ ಗರಿಷ್ಠ ಎರಡು ಅಂಕೆಗಳನ್ನು ಹೊಂದಿರುವ ಅಂಶಗಳ ಮೊತ್ತ. \/\/ಪೂರ್ಣಾಂಕಗಳ ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿ arr ಮತ್ತು ಒಂದು ಪೂರ್ಣಾಂಕ k ನೀಡಿದರೆ, return \/\/ >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n","canonical_solution":"func add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd_Elements(t *testing.T) {\n  candidate := add_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },\n     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },\n     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },\n     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },\n     { actual: candidate([]int{1}, 1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_123","nl":"kan_Knda","pl":"go_test.go","prompt":"package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/get_odd_collatz(5) [1, 5] ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ. # 5 ರ ಕೋಲಾಟ್ಜ್ ಅನುಕ್ರಮವು [5, 16, 8, 4, 2, 1], ಆದ್ದರಿಂದ ಬೆಸ ಸಂಖ್ಯೆಗಳು ಕೇವಲ 1, ಮತ್ತು 5 ಮಾತ್ರ.\/\/ಉದಾಹರಣೆಗೆ: \/\/2. ಹಿಂದಿರುಗಿದ ಪಟ್ಟಿ ಹೆಚ್ಚುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಲಾಗಿದೆ.\/\/1. ಕೊಲಾಟ್ಜ್ () = .\/\/ಟಿಪ್ಪಣಿ: \/\/ಪದರ + 1 ಅಂದಾಜು ಎನ್ ನ ಯಾವ ಮೌಲ್ಯವನ್ನು ಲೆಕ್ಕಿಸದೆ, ಅನುಕ್ರಮವು ಯಾವಾಗಲೂ 1 ಅನ್ನು ತಲುಪುತ್ತದೆ.\/\/ಹಿಂದಿನ ಪದವು ಬೆಸವಾಗಿದ್ದರೆ, ಮುಂದಿನ ಪದವು ಹಿಂದಿನ ಪದದ 3 ಪಟ್ಟು \/\/ಹಿಂದಿನ ಪದವು ಈ ಕೆಳಗಿನಂತೆಃ ಹಿಂದಿನ ಪದವು ಸಮವಾಗಿದ್ದರೆ, ಮುಂದಿನ ಪದವು ಅರ್ಧದಷ್ಟು ಇರುತ್ತದೆ.\/\/ಈ ಕೆಳಗಿನಂತೆ: ಯಾವುದೇ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೊಂದಿಗೆ ಪ್ರಾರಂಭಿಸಿ. ನಂತರ ಪ್ರತಿ ಪದವನ್ನು  ನಿಂದ ಪಡೆಯಲಾಗುತ್ತದೆ.\/\/ಕೋಲಾಟ್ಜ್ ಊಹೆಯು ಗಣಿತಶಾಸ್ತ್ರದಲ್ಲಿ ಒಂದು ಊಹೆಯಾಗಿದ್ದು ಅದು ವ್ಯಾಖ್ಯಾನಿಸಲಾದ ಅನುಕ್ರಮಕ್ಕೆ ಸಂಬಂಧಿಸಿದೆ .\/\/ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, ಒಂದು ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ ಅದು ಕೋಲಾಟ್ಜ್ ಅನುಕ್ರಮದಲ್ಲಿ ಬೆಸ ಸಂಖ್ಯೆಗಳನ್ನು ಹೊಂದಿದೆ.\/\/ >>> get_odd_collatz(5)\n\/\/ []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n","canonical_solution":"package get_odd_collatz_test\n\nimport (\n    \"sort\"\n)\n\nfunc get_odd_collatz(n int) []int {\n    oddNumbers := make(map[int]bool)\n\n    for n != 1 {\n        if n%2 != 0 {\n            oddNumbers[n] = true\n        }\n        if n%2 == 0 {\n            n \/= 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n\n    \/\/ Add 1 to the set of odd numbers because the sequence always ends at 1\n    oddNumbers[1] = true\n\n    \/\/ Extract the keys, which represent the odd numbers\n    result := make([]int, 0, len(oddNumbers))\n    for num := range oddNumbers {\n        result = append(result, num)\n    }\n\n    \/\/ Sort the result\n    sort.Ints(result)\n\n    return result\n}","tests":"func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_124","nl":"kan_Knda","pl":"go_test.go","prompt":"package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/4. ದಿನಾಂಕವು ಈ ಸ್ವರೂಪದಲ್ಲಿರಬೇಕು: mm-dd-yyyy \/\/3. ತಿಂಗಳುಗಳು 1 ಕ್ಕಿಂತ ಕಡಿಮೆ ಅಥವಾ 12 ಕ್ಕಿಂತ ಹೆಚ್ಚಿರಬಾರದು.\/\/2. ತಿಂಗಳು 1,3,5,7,8,10,12 ರ ದಿನಾಂಕವು 1 ಕ್ಕಿಂತ ಕಡಿಮೆಯಿಲ್ಲ ಅಥವಾ 31 ದಿನಗಳಿಗಿಂತ ಹೆಚ್ಚಿಲ್ಲ ಮತ್ತು ತಿಂಗಳು 4,6,9,11 ರ ದಿನಾಂಕವು 1 ಕ್ಕಿಂತ ಕಡಿಮೆಯಿಲ್ಲ ಅಥವಾ 30 ದಿನಗಳಿಗಿಂತ ಹೆಚ್ಚಿಲ್ಲ. ಮತ್ತು, ತಿಂಗಳ 2 ರ ದಿನಾಂಕವು 1 ಕ್ಕಿಂತ ಕಡಿಮೆಯಿಲ್ಲ ಅಥವಾ 29 ಕ್ಕಿಂತ ಹೆಚ್ಚಿಲ್ಲ.\/\/1. ದಿನಾಂಕದ ಸರಣಿಯು ಖಾಲಿಯಾಗಿಲ್ಲ.\/\/ಈ ಕೆಳಗಿನ ಎಲ್ಲಾ ನಿಯಮಗಳನ್ನು ಪೂರೈಸಿದರೆ ದಿನಾಂಕವು ಮಾನ್ಯವಾಗಿರುತ್ತದೆಃ \/\/ದಿನಾಂಕವು ಮಾನ್ಯವಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ ಇಲ್ಲದಿದ್ದರೆ false. \/\/ನೀವು ಒಂದು ನಿರ್ದಿಷ್ಟ ದಿನಾಂಕ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಮೌಲ್ಯೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಬೇಕು ಮತ್ತು \/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunc valid_date(date string) bool {\n","canonical_solution":"func valid_date(date string) bool {\n    if len(date) == 0 {\n        return false\n    }\n\n    var month, day, year int\n    n, err := fmt.Sscanf(date, \"%02d-%02d-%04d\", &month, &day, &year)\n\n    if err != nil || n != 3 {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n\n    return true\n}","tests":"func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_126","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಸಂಖ್ಯೆ, false ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ. ಯಾವುದೇ ಋಣಾತ್ಮಕ ಸಂಖ್ಯೆಗಳನ್ನು ಮತ್ತು ಪೂರ್ಣಾಂಕಗಳನ್ನು ಮಾತ್ರ ಊಹಿಸಿ.\/\/ ಪಟ್ಟಿಯಲ್ಲಿ ಒಂದಕ್ಕಿಂತ ಹೆಚ್ಚು ನಕಲು ಇದ್ದರೆ\/\/ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ, ಅವು ವಿಂಗಡಿಸಲ್ಪಟ್ಟಿರಲಿ ಅಥವಾ ಇಲ್ಲದಿರಲಿ \/\/ >>> is_sorted([]int{5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n\/\/ false\nfunc is_sorted(lst []int) bool {\n","canonical_solution":"func is_sorted(lst []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    \n    duplicateCount := make(map[int]int)\n\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        duplicateCount[lst[i]]++\n        if duplicateCount[lst[i]] > 1 {\n            return false\n        }\n    }\n    \n    \/\/ Check the last element for duplicate\n    duplicateCount[lst[len(lst)-1]]++\n    if duplicateCount[lst[len(lst)-1]] > 1 {\n        return false\n    }\n\n    return true\n}","tests":"func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_127","nl":"kan_Knda","pl":"go_test.go","prompt":"package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/[ಇನ್ಪುಟ್\/ಔಟ್ಪುಟ್] ಮಾದರಿಗಳು: \/\/ಎರಡು ಮಧ್ಯಂತರಗಳು ಛೇದಿಸದಿದ್ದರೆ, \"NO\" ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಇಲ್ಲದಿದ್ದರೆ, \"NO\" ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ ರೇಖೆಯ ಉದ್ದವು ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಾಗಿದ್ದರೆ, \"YES\" ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಅದರ ಉದ್ದವು 1 ಆಗಿರುತ್ತದೆ, ಅದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಲ್ಲ.\/\/ಉದಾಹರಣೆ, ಅಂತರಗಳ (1, 3), (2, 4) ಛೇದಕವು (2, 3) ಆಗಿದೆ.\/\/ಮಧ್ಯಂತರಗಳು ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಾಗಿದೆ.\/\/ನಿಮ್ಮ ಕಾರ್ಯವು ಈ ಎರಡು \/\/ಪ್ರತಿ ನಿರ್ದಿಷ್ಟ ಮಧ್ಯಂತರಕ್ಕೆ, ಅದರ ಆರಂಭವು ಅದರ ಅಂತ್ಯಕ್ಕಿಂತ ಕಡಿಮೆ ಅಥವಾ ಸಮನಾಗಿರುತ್ತದೆ ಎಂದು ಭಾವಿಸಲಾಗಿದೆ.\/\/ಆರಂಭ ಮತ್ತು ಅಂತ್ಯ ಎರಡನ್ನೂ ಒಳಗೊಂಡಿದೆ.\/\/ಕೊಟ್ಟಿರುವ ಮಧ್ಯಂತರಗಳು ಮುಚ್ಚಲ್ಪಟ್ಟಿವೆ ಅಂದರೆ ಮಧ್ಯಂತರ (ಆರಂಭ, ಅಂತ್ಯ) \/\/ಅಲ್ಲಿ ಪ್ರತಿ ಮಧ್ಯಂತರವು ಒಂದು ಜೋಡಿ ಪೂರ್ಣಾಂಕಗಳು. ಉದಾಹರಣೆಗೆ, ಮಧ್ಯಂತರ = (ಆರಂಭ, ಅಂತ್ಯ) = (1, 2).\/\/ನಿಮಗೆ ಎರಡು ಮಧ್ಯಂತರಗಳನ್ನು ನೀಡಲಾಗಿದೆ, \/\/ >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\/\/ \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n","canonical_solution":"package intersection_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to determine if a number is prime\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tif num == 2 {\n\t\treturn true\n\t}\n\tif num%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= num; i += 2 {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n\tstart1, end1 := interval1[0].(int), interval1[1].(int)\n\tstart2, end2 := interval2[0].(int), interval2[1].(int)\n\n\t\/\/ Determine the intersection of two intervals\n\tintersectStart := max(start1, start2)\n\tintersectEnd := min(end1, end2)\n\n\tif intersectStart > intersectEnd {\n\t\treturn \"NO\"\n\t}\n\n\t\/\/ The length of intersection is end - start\n\tlengthOfIntersection := intersectEnd - intersectStart\n\tif isPrime(lengthOfIntersection) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\n\/\/ Helper function to find the maximum of two integers\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\/\/ Helper function to find the minimum of two integers\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc TestIntersection(t *testing.T) {\n\tif intersection([]interface{}{1, 2}, []interface{}{2, 3}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != \"YES\" {\n\t\tt.Error(\"Expected YES\")\n\t}\n}","tests":"func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_129","nl":"kan_Knda","pl":"go_test.go","prompt":"package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಕನಿಷ್ಠ ಪಥವು ಹಾದುಹೋಗುವ ಕೋಶಗಳ ಮೇಲೆ ಮೌಲ್ಯಗಳ ಕ್ರಮಬದ್ಧ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಉತ್ತರವು ಅನನ್ಯವಾಗಿದೆ ಎಂದು ಖಾತರಿಪಡಿಸಲಾಗಿದೆ.\/\/lst_A[j] = lst_B[j]  ಎಂದು ಬರೆಯಲಾಗಿದೆ.\/\/lst_A[i] < lst_B[i] ಮತ್ತು ಯಾವುದೇ j (1 <= j < i) ಗಾಗಿ ನಾವು \/\/lst_B ಗಿಂತ, ಬೇರೆ ರೀತಿಯಲ್ಲಿ ಹೇಳುವುದಾದರೆ, ಒಂದು ಪೂರ್ಣಾಂಕ ಸೂಚ್ಯಂಕ i (1 <= i <= k)  ಅಸ್ತಿತ್ವದಲ್ಲಿದೆ\/\/ಮೂಲಕ (ನಾವು ಅವುಗಳನ್ನು lst_A ಮತ್ತು lst_B ಎಂದು ಕರೆಯೋಣ), lst_A ಶಬ್ದಕೋಶೀಯವಾಗಿ ಕಡಿಮೆ \/\/A ಮತ್ತು B ಗೆ ಹೋಗುವ ಕೋಶಗಳ ಮೇಲೆ ಮೌಲ್ಯಗಳ ಕ್ರಮಬದ್ಧ ಪಟ್ಟಿಗಳನ್ನು ಮಾಡಿದ ನಂತರ \/\/ಒಂದು ಪಥ A (ಉದ್ದ k) ಅನ್ನು ಒಂದು ಪಥ B (ಉದ್ದ k) ಗಿಂತ ಚಿಕ್ಕದಾಗಿ ಪರಿಗಣಿಸಲಾಗುತ್ತದೆ \/\/ನೀವು ಗ್ರಿಡ್ನಿಂದ ಹೊರಗೆ ಹೋಗಲು ಸಾಧ್ಯವಿಲ್ಲ.\/\/ಅಗತ್ಯವಾಗಿ ವಿಭಿನ್ನವಾಗಿವೆ).\/\/k ಉದ್ದದ ಪಥವು ನಿಖರವಾಗಿ k ಕೋಶಗಳನ್ನು ಭೇಟಿ ಮಾಡುವುದನ್ನು ಸೂಚಿಸುತ್ತದೆ (ಇಲ್ಲ \/\/\/\/ಅಂದರೆ, ನೀವು ನಿಮ್ಮ ಪ್ರವಾಹದೊಂದಿಗೆ ಅಂಚನ್ನು ಹಂಚಿಕೊಳ್ಳುವ ಕೋಶಗಳಿಗೆ ಹೋಗಬಹುದು.\/\/ಯಾವುದೇ ಕೋಶದಿಂದ, ಮತ್ತು ಪ್ರತಿ ಹಂತದಲ್ಲಿ ನೀವು ನೆರೆಯ ಕೋಶಗಳ ಯಾವುದೇ ಚಲಿಸಬಹುದು, \/\/ನೀವು ಗ್ರಿಡ್ನಲ್ಲಿ k ಉದ್ದದ ಕನಿಷ್ಠ ಮಾರ್ಗವನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು. ನೀವು ಪ್ರಾರಂಭಿಸಬಹುದು \/\/ಗ್ರಿಡ್ನ ಕೋಶಗಳಲ್ಲಿ ನಿಖರವಾಗಿ ಒಮ್ಮೆ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತದೆ.\/\/ಗ್ರಿಡ್ನ ಪ್ರತಿಯೊಂದು ಕೋಶವು ಒಂದು ಮೌಲ್ಯವನ್ನು ಹೊಂದಿರುತ್ತದೆ. [1, N * N] ವ್ಯಾಪ್ತಿಯಲ್ಲಿರುವ ಪ್ರತಿ ಪೂರ್ಣಾಂಕ \/\/N ಸಾಲುಗಳು ಮತ್ತು N ಕಾಲಮ್ಗಳನ್ನು ಹೊಂದಿರುವ ಗ್ರಿಡ್ ನೀಡಲಾಗಿದೆ (N >= 2) ಮತ್ತು k ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ, \/\/ >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)\n\/\/ []int{1, 2, 1}\n\/\/ >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)\n\/\/ []int{1}\nfunc minPath(grid [][]int, k int) []int {\n","canonical_solution":"package minPath_test\n\nimport (\n    \"sort\"\n)\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    \n    var dfs func(x, y, length int, path []int)\n    var minPath []int\n    minPath = make([]int, k)\n    for i := 0; i < k; i++ {\n        minPath[i] = n*n + 1\n    }\n\n    dfs = func(x, y, length int, path []int) {\n        if length == k {\n            if isLess(path, minPath) {\n                copy(minPath, path)\n            }\n            return\n        }\n        \n        for _, dir := range directions {\n            nx, ny := x+dir[0], y+dir[1]\n            if nx >= 0 && ny >= 0 && nx < n && ny < n {\n                path[length] = grid[nx][ny]\n                dfs(nx, ny, length+1, path)\n            }\n        }\n    }\n    \n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            path := make([]int, k)\n            path[0] = grid[i][j]\n            dfs(i, j, 1, path)\n        }\n    }\n    \n    return minPath\n}\n\nfunc isLess(a, b []int) bool {\n    for i := 0; i < len(a); i++ {\n        if a[i] < b[i] {\n            return true\n        }\n        if a[i] > b[i] {\n            return false\n        }\n    }\n    return false\n}","tests":"func TestMinpath(t *testing.T) {\n  candidate := minPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },\n     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },\n     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },\n     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },\n     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },\n     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },\n     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_130","nl":"kan_Knda","pl":"go_test.go","prompt":"package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಟ್ರಿಬೊನಾಕಿ ಅನುಕ್ರಮದ ಮೊದಲ n + 1 ಸಂಖ್ಯೆಗಳು.\/\/ನಿಮಗೆ ಒಂದು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕ n ನೀಡಲಾಗಿದೆ, ನೀವು  ನ ಪಟ್ಟಿಯನ್ನು ಮರಳಿ ಕೊಡಬೇಕು\/\/= 2 + 3 + 3 = 8 \/\/ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು\/\/೩ \/\/tri ((2) = 1 + (2 \/ 2) = 2 \/\/ಉದಾಹರಣೆಗೆ: \/\/n = n - 1) + n - 2) + n + 1) ಆಗಿದ್ದರೆ, n ಬೆಸವಾಗಿದೆ.\/\/tri (n) = 1 + n \/ 2, n ಸಮವಾಗಿದ್ದರೆ.\/\/ತ್ರಿ  1) = ೩\/\/ಟ್ರಿಬೊನಾಕಿ ಅನುಕ್ರಮವನ್ನು ಪುನರಾವರ್ತನೆಯಿಂದ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ: \/\/ಆದರೆ, ಜನರಿಗೆ ತಿಳಿದಿಲ್ಲದ ವಿಷಯವೆಂದರೆ ಟ್ರಿಬೊನಾಕಿ ಅನುಕ್ರಮ.\/\/ಪ್ರತಿಯೊಬ್ಬರೂ ಫಿಬೊನಾಕಿ ಅನುಕ್ರಮವನ್ನು ತಿಳಿದಿದ್ದಾರೆ, ಇದನ್ನು ಗಣಿತಜ್ಞರು ಆಳವಾಗಿ ಅಧ್ಯಯನ ಮಾಡಿದ್ದಾರೆ \/\/ >>> tri(3)\n\/\/ []int{1, 3, 2, 8}\nfunc tri(n int) []int {\n","canonical_solution":"func tri(n int) []int {\n    if n < 0 {\n        return []int{}\n    }\n    sequence := make([]int, n+1)\n    sequence[0] = 1 \/\/ tri(0) is not defined in problem, let's start with tri(1)\n    if n >= 1 {\n        sequence[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            sequence[i] = 1 + i\/2\n        } else {\n            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)\n        }\n    }\n    return sequence\n}\n\nfunc getNextTribonacci(n int) int {\n    if n%2 == 0 {\n        return 1 + n\/2\n    }\n    return getNextTribonacciRec(n+1)\n}\n\nfunc getNextTribonacciRec(n int) int {\n    triNext := make([]int, n+1)\n    triNext[0] = 1 \/\/ again assuming some base start\n    if n >= 1 {\n        triNext[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            triNext[i] = 1 + i\/2\n        } else {\n            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)\n        }\n    }\n    return triNext[n]\n}","tests":"func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0), expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_131","nl":"kan_Knda","pl":"go_test.go","prompt":"package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಎಲ್ಲಾ ಅಂಕೆಗಳು ಸಮವಾಗಿದ್ದರೆ 0 ಅನ್ನು ಹಿಂತಿರುಗಿ.\/\/ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, ಬೆಸ ಅಂಕೆಗಳ ಉತ್ಪನ್ನವನ್ನು ಹಿಂತಿರುಗಿ.\/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunc digits(n int) int {\n","canonical_solution":"product := 1\n    hasOdd := false\n\n    for n > 0 {\n        digit := n % 10\n        if digit%2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n \/= 10\n    }\n\n    if hasOdd {\n        return product\n    }\n    return 0\n}","tests":"func TestDigits(t *testing.T) {\n  candidate := digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 5 },\n     { actual: candidate(54), expected: 5 },\n     { actual: candidate(120), expected: 1 },\n     { actual: candidate(5014), expected: 5 },\n     { actual: candidate(98765), expected: 315 },\n     { actual: candidate(5576543), expected: 2625 },\n     { actual: candidate(2468), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_132","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಅಲ್ಲಿ ಕನಿಷ್ಠ ಒಂದು ಬ್ರಾಕೆಟ್ ಅನ್ನು ಸಬ್ಸೆಕ್ವೆನ್ಸಿಗಳಲ್ಲಿ ಗೂಡುಮಾಡಲಾಗಿದೆ.\/\/ಬ್ರಾಕೆಟ್ಗಳ ಮಾನ್ಯ ಉಪಕ್ರಮವಿದ್ದರೆ ಮಾತ್ರ ಮತ್ತು ಮಾತ್ರ ಕಾರ್ಯವು true ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು .\/\/ಕೇವಲ ಚದರ ಆವರಣಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ.\/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunc is_nested(myString string) bool {\n","canonical_solution":"func is_nested(myString string) bool {\n\tstack := []rune{}\n\tnestingFound := false\n\n\tfor _, char := range myString {\n\t\tif char == '[' {\n\t\t\tstack = append(stack, char)\n\t\t} else if char == ']' {\n\t\t\tif len(stack) > 0 {\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t\tif len(stack) > 0 {\n\t\t\t\t\tnestingFound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nestingFound\n}","tests":"func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_133","nl":"kan_Knda","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಪಟ್ಟಿಯಲ್ಲಿರುವ ಪ್ರತಿಯೊಂದು ಅಂಶವನ್ನು ಮೊದಲು ಮೇಲಿನ int ((ಸೀಲಿಂಗ್) ಗೆ ಸುತ್ತಿಕೊಳ್ಳಿ.\/\/ನೀವು ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸಂಖ್ಯೆಗಳ ಚೌಕದ ಮೊತ್ತವನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕಾಗಿದೆ, \/\/ನಿಮಗೆ ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿ ನೀಡಲಾಗಿದೆ.\/\/ >>> lst([]float64{1.0, 2.0, 3.0})\n\/\/ 14\n\/\/ >>> lst([]float64{1.0, 4.0, 9.0})\n\/\/ 98\n\/\/ >>> lst([]float64{1.0, 3.0, 5.0, 7.0})\n\/\/ 84\n\/\/ >>> lst([]float64{1.4, 4.2, 0.0})\n\/\/ 29\n\/\/ >>> lst([]float64{-2.4, 1.0, 1.0})\n\/\/ 6\nfunc sum_squares(lst []float64) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n\t\"math\"\n)\n\nfunc sum_squares(lst []float64) int {\n\tsum := 0\n\tfor _, num := range lst {\n\t\tceiledNum := math.Ceil(num)\n\t\tsum += int(ceiledNum * ceiledNum)\n\t}\n\treturn sum\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },\n     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },\n     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },\n     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },\n     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },\n     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },\n     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },\n     { actual: candidate([]float64{0.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0}), expected: 1 },\n     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_134","nl":"kan_Knda","pl":"go_test.go","prompt":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಗಮನಿಸಿ: \"ವರ್ಡ್\" ಎಂಬುದು ಅಕ್ಷರಗಳ ಗುಂಪಾಗಿದ್ದು, ಅಂತರದಿಂದ ಬೇರ್ಪಡಿಸಲಾಗಿದೆ.\/\/ಒಂದು ಪದದ ಒಂದು ಭಾಗ, ಮತ್ತು ಸುಳ್ಳು ಇಲ್ಲದಿದ್ದರೆ.\/\/ಒಂದು ನಿರ್ದಿಷ್ಟ ಸ್ಟ್ರಿಂಗ್ನ ಒಂದು ವರ್ಣಮಾಲೆಯ ಅಕ್ಷರವಾಗಿದೆ ಮತ್ತು  ಅಲ್ಲ.\/\/ಕೊನೆಯ ಅಕ್ಷರ  ಆಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ\/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n","canonical_solution":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"unicode\"\n)\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {\n        return false\n    }\n    \n    lastCharIndex := len(txt) - 1\n    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {\n        lastCharIndex--\n    }\n    \n    if lastCharIndex < 0 {\n        return false\n    }\n\n    if !unicode.IsLetter(rune(txt[lastCharIndex])) {\n        return false\n    }\n    \n    \/\/ Check if it's part of a word by looking at the previous character\n    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {\n        return false\n    }\n\n    return true\n}\n\nfunc TestCheckIfLastCharIsALetter(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n        {\"hello world\", true},\n        {\"a \", true},\n        {\" a\", true},\n        {\"abc\", false},\n        {\"abc \", false},\n    }\n\n    for _, c := range cases {\n        t.Run(c.input, func(t *testing.T) {\n            result := check_if_last_char_is_a_letter(c.input)\n            if result != c.expected {\n                t.Errorf(\"Expected %v, got %v for input \\\"%s\\\"\", c.expected, result, c.input)\n            }\n        })\n    }\n}","tests":"func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_135","nl":"kan_Knda","pl":"go_test.go","prompt":"package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಗಳು\/\/ಅಂತಹ ಯಾವುದೇ ಅಂಶವು ಅಸ್ತಿತ್ವದಲ್ಲಿಲ್ಲದಿದ್ದರೆ -1. ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯು  ಅನ್ನು ಹೊಂದಿರುವುದಿಲ್ಲ.\/\/ಇದು ತಕ್ಷಣವೇ ಅದರ ಹಿಂದಿನ ಅಂಶಕ್ಕಿಂತ ದೊಡ್ಡದಾಗಿದೆ ಅಥವಾ ಸಮನಾಗಿರುವುದಿಲ್ಲ.\/\/ಒಂದು ಅಂಶದ ಅತಿದೊಡ್ಡ ಸೂಚಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ ಅದು \/\/ >>> can_arrange([]int{1, 2, 4, 3, 5})\n\/\/ 3\n\/\/ >>> can_arrange([]int{1, 2, 3})\n\/\/ -1\nfunc can_arrange(arr []int) int {\n","canonical_solution":"package can_arrange_test\n\nfunc can_arrange(arr []int) int {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_136","nl":"kan_Knda","pl":"go_test.go","prompt":"package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಯಾವುದೇ ಋಣಾತ್ಮಕ ಅಥವಾ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳಿಲ್ಲದಿದ್ದರೆ, ಅವುಗಳನ್ನು ಶೂನ್ಯ ಎಂದು ಹಿಂತಿರುಗಿಸಿ.\/\/ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿನ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳ ಸಂಖ್ಯೆ.\/\/ದೊಡ್ಡದು, ಮತ್ತು 'b' ಚಿಕ್ಕದು \/\/ಒಂದು ಪಟ್ಟಿಯನ್ನು (a, b) ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ, ಅಲ್ಲಿ 'a' \/\/ >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\/\/ []interface{}{nil, 1}\n\/\/ >>> largest_smallest_integers([]int{})\n\/\/ []interface{}{nil, nil}\n\/\/ >>> largest_smallest_integers([]int{0})\n\/\/ []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n","canonical_solution":"func largest_smallest_integers(lst []int) []interface{} {\n    var largestNegative *int\n    var smallestPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            if largestNegative == nil || num > *largestNegative {\n                largestNegative = new(int)\n                *largestNegative = num\n            }\n        } else if num > 0 {\n            if smallestPositive == nil || num < *smallestPositive {\n                smallestPositive = new(int)\n                *smallestPositive = num\n            }\n        }\n    }\n\n    var result = []interface{}{nil, nil}\n    if largestNegative != nil {\n        result[0] = *largestNegative\n    }\n    if smallestPositive != nil {\n        result[1] = *smallestPositive\n    }\n\n    return result\n}","tests":"func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_138","nl":"kan_Knda","pl":"go_test.go","prompt":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ \/\/ಕೊಟ್ಟಿರುವ ಸಂಖ್ಯೆಯನ್ನು n ಅನ್ನು ನಿಖರವಾಗಿ 4 ಧನಾತ್ಮಕ ಸಮ ಸಂಖ್ಯೆಗಳ ಮೊತ್ತವಾಗಿ ಬರೆಯಬಹುದೇ ಎಂದು ಮೌಲ್ಯಮಾಪನ ಮಾಡಿ \/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n","canonical_solution":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n\/\/ Example\n\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n    \/\/ The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    \/\/ Therefore, n must be at least 8 and n must be even\n    return n >= 8 && n%2 == 0\n}\n\n\/\/ Testing the function\nfunc TestIsEqualToSumEven(t *testing.T) {\n    cases := []struct {\n        n      int\n        expect bool\n    }{\n        {4, false},\n        {6, false},\n        {8, true},\n        {10, true},\n        {12, true},\n        {14, true},\n        {16, true},\n    }\n\n    for _, c := range cases {\n        result := is_equal_to_sum_even(c.n)\n        if result != c.expect {\n            t.Errorf(\"is_equal_to_sum_even(%d) == %v, expect %v\", c.n, result, c.expect)\n        } else {\n            fmt.Printf(\"Success: is_equal_to_sum_even(%d) == %v\\n\", c.n, result)\n        }\n    }\n}","tests":"func TestIs_Equal_To_Sum_Even(t *testing.T) {\n  candidate := is_equal_to_sum_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: false },\n     { actual: candidate(6), expected: false },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: true },\n     { actual: candidate(11), expected: false },\n     { actual: candidate(12), expected: true },\n     { actual: candidate(13), expected: false },\n     { actual: candidate(16), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_139","nl":"kan_Knda","pl":"go_test.go","prompt":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಅಲ್ಲಿ n > 0 \/\/ಬ್ರೆಜಿಲಿಯನ್_ಫ್ಯಾಕ್ಟರಿಯಲ್ (n) = n! * (n-1)! * (n-2)! * . . . * 1! \/\/ಬ್ರೆಜಿಲಿಯನ್ ಫ್ಯಾಕ್ಟೊರಿಯಲ್ ಅನ್ನು ಹೀಗೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆಃ \/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunc special_factorial(n int) int {\n","canonical_solution":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc special_factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    \n    result := 1\n    for i := 1; i <= n; i++ {\n        result *= factorial(i)\n    }\n    \n    return result\n}\n\nfunc factorial(x int) int {\n    if x == 0 {\n        return 1\n    }\n    prod := 1\n    for i := 1; i <= x; i++ {\n        prod *= i\n    }\n    return prod\n}\n\nfunc TestSpecialFactorial(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {4, 288},      \/\/ 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n        {3, 12},       \/\/ 3! * 2! * 1! = 6 * 2 * 1 = 12\n        {2, 2},        \/\/ 2! * 1! = 2 * 1 = 2\n        {1, 1},        \/\/ 1! = 1\n        {0, 1},        \/\/ Edge case for n=0, considered as 1 for special factorial\n    }\n\n    for _, c := range cases {\n        result := special_factorial(c.input)\n        if result != c.expected {\n            t.Errorf(\"special_factorial(%d) == %d, want %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(special_factorial(4)) \/\/ Output: 288\n    fmt.Println(special_factorial(3)) \/\/ Output: 12\n}","tests":"func TestSpecial_Factorial(t *testing.T) {\n  candidate := special_factorial\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: 288 },\n     { actual: candidate(5), expected: 34560 },\n     { actual: candidate(7), expected: 125411328000 },\n     { actual: candidate(1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_140","nl":"kan_Knda","pl":"go_test.go","prompt":"package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ನಂತರ ಎಲ್ಲಾ ಸತತ ಅಂತರಗಳನ್ನು -  ನೊಂದಿಗೆ ಬದಲಾಯಿಸಿ\/\/ಮತ್ತು ಒಂದು ಸ್ಟ್ರಿಂಗ್ 2 ಕ್ಕಿಂತ ಹೆಚ್ಚು ಸತತ ಸ್ಥಳಗಳನ್ನು ಹೊಂದಿದ್ದರೆ, \/\/ಒಂದು ವಾಕ್ಯದ ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗಿದೆ, ಎಲ್ಲಾ ಸ್ಥಳಗಳನ್ನು ಅಂಡರ್ಸ್ಕೋರ್ಗಳೊಂದಿಗೆ ಬದಲಾಯಿಸಿ, \/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunc fix_spaces(text string) string {\n","canonical_solution":"package fix_spaces_test\n\nimport (\n    \"strings\"\n    \"testing\"\n)\n\nfunc fix_spaces(text string) string {\n    var result string\n    spaceCount := 0\n\n    for _, char := range text {\n        if char == ' ' {\n            spaceCount++\n        } else {\n            if spaceCount == 1 {\n                result += \"_\"\n            } else if spaceCount > 1 {\n                result += \"-\"\n            }\n            result += string(char)\n            spaceCount = 0\n        }\n    }\n\n    \/\/ Handle trailing spaces\n    if spaceCount == 1 {\n        result += \"_\"\n    } else if spaceCount > 1 {\n        result += \"-\"\n    }\n\n    return result\n}\n\nfunc TestFixSpaces(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected string\n    }{\n        {\" Example\", \"Example\"},\n        {\" Example 1\", \"Example_1\"},\n        {\" Example 2\", \"_Example_2\"},\n        {\" Example 3\", \"_Example-3\"},\n        {\" Hello    world\", \"_Hello-world\"},\n        {\"   Leading spaces\", \"-Leading_spaces\"},\n    }\n\n    for _, c := range cases {\n        result := fix_spaces(c.input)\n        if result != c.expected {\n            t.Errorf(\"fix_spaces(%q) == %q, expected %q\", c.input, result, c.expected)\n        }\n    }\n}","tests":"func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n     { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n     { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\" },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n     { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_141","nl":"kan_Knda","pl":"go_test.go","prompt":"package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/- ಡಾಟ್ ನಂತರದ ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಈ ಒಂದು ಆಗಿರಬೇಕುಃ ['txt', 'exe', 'dll'] \/\/ಲ್ಯಾಟಿನ್ ಅಕ್ಷರಮಾಲೆ ('a'-'z' ಮತ್ತು 'A'-'Z').\/\/- ಡಾಟ್ ಮೊದಲು ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಖಾಲಿ ಇರಬಾರದು, ಮತ್ತು ಇದು ಒಂದು ಅಕ್ಷರದೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುತ್ತದೆ \/\/- ಫೈಲ್ ಹೆಸರು ನಿಖರವಾಗಿ ಒಂದು ಚುಕ್ಕೆ '.' \/\/- ಫೈಲ್ ಹೆಸರಿನಲ್ಲಿ ಮೂರು ಅಂಕೆಗಳಿಗಿಂತ ಹೆಚ್ಚು ('0'-'9') ಇರಬಾರದು.\/\/ಈ ಕೆಳಗಿನವುಗಳನ್ನು ಪೂರೈಸಲಾಗಿದೆ:\/\/ಒಂದು ಕಡತದ ಹೆಸರು ಮಾನ್ಯವೆಂದು ಪರಿಗಣಿಸಲ್ಪಡುತ್ತದೆ ಮತ್ತು ಕೆಳಗಿನ ಎಲ್ಲಾ ಷರತ್ತುಗಳನ್ನು ಪೂರೈಸಿದರೆ ಮಾತ್ರ \/\/ಫೈಲ್ ಹೆಸರು ಮಾನ್ಯವಾಗಿದ್ದರೆ 'ಹೌದು' ಮತ್ತು ಇಲ್ಲದಿದ್ದರೆ 'ಇಲ್ಲ' ಎಂದು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಒಂದು ಫೈಲ್ನ ಹೆಸರನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು  ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ.\/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunc file_name_check(file_name string) string {\n","canonical_solution":"package file_name_check_test\n\nimport (\n    \"strings\"\n    \"unicode\"\n)\n\nfunc file_name_check(file_name string) string {\n    if len(file_name) == 0 {\n        return \"No\"\n    }\n\n    \/\/ Condition 2: Check for exactly one dot\n    dotIndex := strings.LastIndex(file_name, \".\")\n    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {\n        return \"No\"\n    }\n\n    \/\/ Split the file name into two parts\n    namePart := file_name[:dotIndex]\n    extension := file_name[dotIndex+1:]\n\n    \/\/ Condition 4: Check the extension\n    validExtensions := map[string]bool{\n        \"txt\": true,\n        \"exe\": true,\n        \"dll\": true,\n    }\n    if !validExtensions[extension] {\n        return \"No\"\n    }\n\n    \/\/ Condition 3: Check the first character before the dot\n    if !unicode.IsLetter(rune(namePart[0])) {\n        return \"No\"\n    }\n\n    \/\/ Condition 1: Count the digits in the file name\n    digitCount := 0\n    for _, char := range namePart {\n        if unicode.IsDigit(char) {\n            digitCount++\n        }\n    }\n    if digitCount > 3 {\n        return \"No\"\n    }\n\n    \/\/ If all conditions are met, return \"Yes\"\n    return \"Yes\"\n}","tests":"func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual: candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"\/this_is_valid.dll\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n     { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual: candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual: candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     { actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected: \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_142","nl":"kan_Knda","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಪಟ್ಟಿಯಲ್ಲಿರುವ ನಮೂದುಗಳನ್ನು ಬದಲಾಯಿಸಿ, ಅದರ ಸೂಚ್ಯಂಕಗಳು 3 ಅಥವಾ 4 ರ ಬಹುಸಂಖ್ಯೆಯಲ್ಲ. ನಂತರ ಕಾರ್ಯವು ಎಲ್ಲಾ ನಮೂದುಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/3 ರ ಬಹುಸಂಖ್ಯೆ ಮತ್ತು ಅದರ ಸೂಚ್ಯಂಕವು 4 ರ ಬಹುಸಂಖ್ಯೆಯಾಗಿದ್ದರೆ ಮತ್ತು 3 ರ ಬಹುಸಂಖ್ಯೆಯಲ್ಲದಿದ್ದರೆ ಪೂರ್ಣಾಂಕ ನಮೂದನ್ನು ಘನೀಕರಿಸುತ್ತದೆ. ಈ ಕಾರ್ಯವು \/\/ಈ ಕಾರ್ಯವು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ. ಪಟ್ಟಿಯಲ್ಲಿರುವ ಎಲ್ಲಾ ನಮೂದುಗಳಿಗೆ, ಅದರ ಸೂಚ್ಯಂಕವು a ಆಗಿದ್ದರೆ ಕಾರ್ಯವು ಪೂರ್ಣಾಂಕ ನಮೂದನ್ನು ಚೌಕೀಕರಿಸುತ್ತದೆ.\/\/\" \/\/ >>> lst\n\/\/ []int{1, 2, 3}\n\/\/ >>> lst\n\/\/ int{}\n\/\/ >>> lst\n\/\/ []int{-1, -5, 2, -1, -5}\nfunc sum_squares(lst []int) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n    \"testing\"\n)\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for i, val := range lst {\n        if i%3 == 0 {\n            sum += val * val\n        } else if i%4 == 0 {\n            sum += val * val * val\n        } else {\n            sum += val\n        }\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct {\n        lst      []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 10},   \/\/ 1^2 + 2 + 3 = 10\n        {[]int{}, 0},           \/\/ empty list\n        {[]int{-1, -5, 2, -1, -5}, 0}, \/\/ (-1)^2 + (-5)^3 + 2 + (-1) = -118\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.lst)\n        if result != test.expected {\n            t.Errorf(\"sum_squares(%v) = %d; expected %d\", test.lst, result, test.expected)\n        }\n    }\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 6 },\n     { actual: candidate([]int{1, 4, 9}), expected: 14 },\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },\n     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },\n     { actual: candidate([]int{0}), expected: 0 },\n     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },\n     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },\n     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },\n     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },\n     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_143","nl":"kan_Knda","pl":"go_test.go","prompt":"package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ 1: \/\/ಹೊಸ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಪದಗಳ ಕ್ರಮವು ಮೂಲದಂತೆಯೇ ಇರಬೇಕು.\/\/ಇದರ ಉದ್ದಗಳು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳಾಗಿವೆ, \/\/ಮತ್ತು ನೀವು ಮೂಲ ವಾಕ್ಯದಿಂದ ಪದಗಳನ್ನು ಹೊಂದಿರುವ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಮರಳಿ ಮಾಡಬೇಕು, \/\/ವಾಕ್ಯವು ಕೆಲವು ಪದಗಳನ್ನು ಒಳಗೊಂಡಿದೆ, \/\/ನಿಮಗೆ ಒಂದು ವಾಕ್ಯವನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗಿದೆ, \/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n","canonical_solution":"package words_in_sentence_test\n\nimport (\n    \"strings\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc words_in_sentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var result []string\n\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n\n    return strings.Join(result, \" \")\n}","tests":"func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_144","nl":"kan_Knda","pl":"go_test.go","prompt":"package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ನೀವು x, ಮತ್ತು n ಯನ್ನು ಮಾನ್ಯ ಭಿನ್ನರಾಶಿಗಳೆಂದು ಊಹಿಸಬಹುದು, ಮತ್ತು ಶೂನ್ಯವನ್ನು ನಾಮಕರಣವಾಗಿ ಹೊಂದಿಲ್ಲ.\/\/ಅಲ್ಲಿ ಎಣಿಕೆ ಮತ್ತು ನಾಮಕರಣ ಎರಡೂ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳಾಗಿವೆ.\/\/x ಮತ್ತು n ಎರಡೂ, ಒಂದು ಭಿನ್ನರಾಶಿಯ ಸ್ಟ್ರಿಂಗ್ ಪ್ರಾತಿನಿಧ್ಯವಾಗಿದೆ, ಮತ್ತು ಈ ಕೆಳಗಿನ ಸ್ವರೂಪವನ್ನು ಹೊಂದಿವೆ, \/\/x * n. x * n ಒಂದು ಪೂರ್ಣಾಂಕಕ್ಕೆ ಮೌಲ್ಯಮಾಪನ ಮಾಡಿದರೆ ಮತ್ತು false  ಎಂದು ಕಾರ್ಯವು true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.\/\/ನಿಮ್ಮ ಕಾರ್ಯವು ಅಭಿವ್ಯಕ್ತಿಯನ್ನು ಸರಳಗೊಳಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಅಳವಡಿಸುವುದು \/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunc simplify(x string, n string) bool {\n","canonical_solution":"package simplify_test\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc simplify(x string, n string) bool {\n    \/\/ Split the input strings into numerators and denominators\n    xParts := strings.Split(x, \"\/\")\n    nParts := strings.Split(n, \"\/\")\n\n    \/\/ Convert the string parts to integers\n    xNumerator, _ := strconv.Atoi(xParts[0])\n    xDenominator, _ := strconv.Atoi(xParts[1])\n    nNumerator, _ := strconv.Atoi(nParts[0])\n    nDenominator, _ := strconv.Atoi(nParts[1])\n\n    \/\/ Perform the multiplication (x * n) = (xNumerator\/nDenominator) * (nNumerator\/nDenominator)\n    resultNumerator := xNumerator * nNumerator\n    resultDenominator := xDenominator * nDenominator\n\n    \/\/ Check if the result is a whole number\n    return resultNumerator%resultDenominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n    if !simplify(\"1\/5\", \"5\/1\") {\n        t.Fatalf(\"Expected true, got false\")\n    }\n    if simplify(\"1\/6\", \"2\/1\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n    if simplify(\"7\/10\", \"10\/2\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n}","tests":"func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/6\", \"2\/1\"), expected: false },\n     { actual: candidate(\"5\/1\", \"3\/1\"), expected: true },\n     { actual: candidate(\"7\/10\", \"10\/2\"), expected: false },\n     { actual: candidate(\"2\/10\", \"50\/10\"), expected: true },\n     { actual: candidate(\"7\/2\", \"4\/2\"), expected: true },\n     { actual: candidate(\"11\/6\", \"6\/1\"), expected: true },\n     { actual: candidate(\"2\/3\", \"5\/2\"), expected: false },\n     { actual: candidate(\"5\/2\", \"3\/5\"), expected: false },\n     { actual: candidate(\"2\/4\", \"8\/4\"), expected: true },\n     { actual: candidate(\"2\/4\", \"4\/2\"), expected: true },\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/5\", \"1\/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_145","nl":"kan_Knda","pl":"go_test.go","prompt":"package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಮೂಲ ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸೂಚ್ಯಂಕದ ಆಧಾರದ ಮೇಲೆ ಅವುಗಳನ್ನು ಕ್ರಮಗೊಳಿಸಿ.\/\/ಗಮನಿಸಿಃ ಹಲವಾರು ಐಟಂಗಳು ತಮ್ಮ ಅಂಕೆಗಳ ಮೊತ್ತವನ್ನು ಹೊಂದಿದ್ದರೆ, \/\/ಅವುಗಳ ಅಂಕಿಗಳ ಮೊತ್ತದ ಪ್ರಕಾರ ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ.\/\/ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ವಿಂಗಡಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ \/\/ >>> order_by_points([]int{1, 11, -1, -11, -12})\n\/\/ []int{-1, -11, 1, -12, 11}\n\/\/ >>> order_by_points([]int{})\n\/\/ []int{}\nfunc order_by_points(nums []int) []int {\n","canonical_solution":"package order_by_points_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc digitSum(n int) int {\n\tn = abs(n) \/\/ Consider the absolute value for digit sum\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc order_by_points(nums []int) []int {\n\ttype numWithIndex struct {\n\t\tnum   int\n\t\tindex int\n\t}\n\n\tnumsWithIndex := make([]numWithIndex, len(nums))\n\tfor i, num := range nums {\n\t\tnumsWithIndex[i] = numWithIndex{num, i}\n\t}\n\n\tsort.Slice(numsWithIndex, func(i, j int) bool {\n\t\tsumI := digitSum(numsWithIndex[i].num)\n\t\tsumJ := digitSum(numsWithIndex[j].num)\n\t\tif sumI == sumJ {\n\t\t\treturn numsWithIndex[i].index < numsWithIndex[j].index\n\t\t}\n\t\treturn sumI < sumJ\n\t})\n\n\tsortedNums := make([]int, len(nums))\n\tfor i, nwi := range numsWithIndex {\n\t\tsortedNums[i] = nwi.num\n\t}\n\n\treturn sortedNums\n}\n\nfunc TestOrderByPoints(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := order_by_points(tc.input)\n\t\tif !equal(result, tc.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_146","nl":"kan_Knda","pl":"go_test.go","prompt":"package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಒಂದು ಸಂಖ್ಯೆಯ ಮೊದಲ ಮತ್ತು ಕೊನೆಯ ಅಂಕೆಗಳು ಬೆಸ (1, 3, 5, 7, 9).\/\/ಪಟ್ಟಿಯಲ್ಲಿನ ಅಂಶಗಳ ಸಂಖ್ಯೆ 10 ಕ್ಕಿಂತ ಹೆಚ್ಚಿದ್ದರೆ ಮತ್ತು ಎರಡೂ \/\/ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ರಿಟರ್ನ್ಸ್  ಎಂದು ಕರೆಯುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ\/\/ >>> specialFilter([]int{15, -73, 14, -15})\n\/\/ 1\n\/\/ >>> specialFilter([]int{33, -2, -3, 45, 21, 109})\n\/\/ 2\nfunc specialFilter(nums []int) int {\n","canonical_solution":"package specialFilter_test\n\nimport (\n\t\"testing\"\n)\n\nfunc specialFilter(nums []int) int {\n\tcount := 0\n\tfor _, num := range nums {\n\t\t\/\/ Consider the absolute value of the number\n\t\tabsNum := abs(num)\n\t\tif absNum > 10 {\n\t\t\tstrNum := fmt.Sprintf(\"%d\", absNum)\n\t\t\tfirstDigit := strNum[0]\n\t\t\tlastDigit := strNum[len(strNum)-1]\n\t\t\tif isOdd(firstDigit) && isOdd(lastDigit) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc isOdd(digit byte) bool {\n\treturn digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'\n}\n\nfunc TestSpecialFilter(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{15, -73, 14, -15}, 1},\n\t\t{[]int{33, -2, -3, 45, 21, 109}, 2},\n\t\t{[]int{8, 4, 12, 55, 99, 111}, 1},\n\t\t{[]int{-11, -22, -33, -44, -55}, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := specialFilter(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"specialFilter(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestSpecialfilter(t *testing.T) {\n  candidate := specialFilter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },\n     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },\n     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },\n     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },\n     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{}), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_147","nl":"kan_Knda","pl":"go_test.go","prompt":"package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಮತ್ತು a[i] + a[j] + a[k] ಎಂಬುದು 3 ರ ಬಹುಸಂಖ್ಯೆ.\/\/i < j < k,  ಎಂಬಲ್ಲಿ a ನ ಮೂರು ಪಟ್ಟುಗಳ ಸಂಖ್ಯೆಯನ್ನು (a[i], a[j], a[k]) ಹಿಂತಿರುಗಿ.\/\/ಪ್ರತಿ i (1 ≤ i ≤ n) ಗಾಗಿ, a[i] = i * i - i + 1 ರ ಮೌಲ್ಯವನ್ನು ನೀಡಲಾಗುತ್ತದೆ.\/\/ನಿಮಗೆ ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಲಾಗಿದೆ. ನೀವು ಉದ್ದ n ನ ಒಂದು ಪೂರ್ಣಾಂಕ ಪಟ್ಟಿಯನ್ನು ರಚಿಸಬೇಕು.\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n","canonical_solution":"package get_max_triples_test\n\nimport (\n    \"testing\"\n)\n\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    \n    count := 0\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\nfunc TestGetMaxTriples(t *testing.T) {\n    if get_max_triples(5) != 1 {\n        t.Errorf(\"Expected 1 but got %d\", get_max_triples(5))\n    }\n}","tests":"func TestGet_Max_Triples(t *testing.T) {\n  candidate := get_max_triples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 1 },\n     { actual: candidate(6), expected: 4 },\n     { actual: candidate(10), expected: 36 },\n     { actual: candidate(100), expected: 53361 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_148","nl":"kan_Knda","pl":"go_test.go","prompt":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಗ್ರಹಗಳ ಹೆಸರುಗಳು ಸರಿಯಾಗಿಲ್ಲ.\/\/ಕಾರ್ಯವು ಒಂದು ಖಾಲಿ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು planet1 ಅಥವಾ planet2 \/\/ಸೂರ್ಯನ ಸಮೀಪದಲ್ಲಿ.\/\/ಗ್ರಹ1ರ ಕಕ್ಷೆ ಮತ್ತು ಗ್ರಹ2ರ ಕಕ್ಷೆಯ ನಡುವೆ ಇದೆ, \/\/ಈ ಕಾರ್ಯವು \/\/ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಅದು ಎರಡು ಗ್ರಹಗಳ ಹೆಸರುಗಳನ್ನು ಸ್ಟ್ರಿಂಗ್ಸ್ planet1 ಮತ್ತು planet2 ಎಂದು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ.\/\/ಯುರೇನಸ್, ನೆಪ್ಚೂನ್ \/\/ಮರ್ಕ್ಯುರಿ, ಮುಂದಿನದು ಶುಕ್ರ, ನಂತರ ಭೂಮಿಯ, ಮಂಗಳ, ಗುರು, ಶನಿ, \/\/ನಮ್ಮ ಸೌರವ್ಯೂಹದಲ್ಲಿ ಎಂಟು ಗ್ರಹಗಳಿವೆ: ಸೂರ್ಯನಿಗೆ ಹತ್ತಿರದವು \/\/ >>> bf(\"Jupiter\", \"Neptune\")\n\/\/ []interface{}{\"Saturn\", \"Uranus\"}\n\/\/ >>> bf(\"Earth\", \"Mercury\")\n\/\/ \"Venus\"\n\/\/ >>> bf(\"Mercury\", \"Uranus\")\n\/\/ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n","canonical_solution":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Define the solar system slice with planets ordered by their proximity to the Sun\nvar solarSystem = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n    index1 := -1\n    index2 := -1\n\n    \/\/ Find the indices of the given planet names in the solarSystem slice\n    for i, planet := range solarSystem {\n        if planet == planet1 {\n            index1 = i\n        }\n        if planet == planet2 {\n            index2 = i\n        }\n    }\n\n    \/\/ If either planet name is incorrect, return an empty list\n    if index1 == -1 || index2 == -1 {\n        return []interface{}{}\n    }\n\n    \/\/ Ensure index1 is less than index2 to find planets between them\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\n    \/\/ Collect and return planets that are located between the two indices\n    var planetsBetween []interface{}\n    for i := index1 + 1; i < index2; i++ {\n        planetsBetween = append(planetsBetween, solarSystem[i])\n    }\n    \n    return planetsBetween\n}\n\nfunc TestBf(t *testing.T) {\n    fmt.Println(bf(\"Jupiter\", \"Neptune\")) \/\/ Should print: []interface{}{\"Saturn\", \"Uranus\"}\n    fmt.Println(bf(\"Earth\", \"Mercury\"))  \/\/ Should print: []interface{}{\"Venus\"}\n    fmt.Println(bf(\"Mercury\", \"Uranus\")) \/\/ Should print: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n}","tests":"func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_149","nl":"kan_Knda","pl":"go_test.go","prompt":"package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಎಲ್ಲಾ ಪದಗಳು ಒಂದೇ ಉದ್ದವನ್ನು ಹೊಂದಿರುತ್ತವೆ ಎಂದು ನೀವು ಭಾವಿಸಬಹುದು.\/\/ಈ ಕಾರ್ಯವು ಒಂದು ಶ್ರೇಣಿಯ ಸ್ಟ್ರಿಂಗ್ ಗಳ ಪಟ್ಟಿಯನ್ನು ವಿಂಗಡಿತ ಕ್ರಮದಲ್ಲಿ ಹಿಂದಿರುಗಿಸಬೇಕು.\/\/ಎರಡು ಪದಗಳು ಒಂದೇ ಉದ್ದವಿದ್ದರೆ, ಪಟ್ಟಿಯನ್ನು ವರ್ಣಮಾಲೆಯ ಪ್ರಕಾರ ವಿಂಗಡಿಸಿ.\/\/ಈ ನಿಯಮದ ಪ್ರಕಾರ ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು.\/\/ಪಟ್ಟಿಯ ಕ್ರಮವು ಪ್ರತಿ ಪದದ ಉದ್ದದಿಂದ ಏರಿಕೆಯಾಗಬೇಕು, ಮತ್ತು ನೀವು \/\/ಮತ್ತು ಅದು ನಕಲುಗಳನ್ನು ಹೊಂದಿರಬಹುದು.\/\/ಪಟ್ಟಿಯು ಯಾವಾಗಲೂ ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯಾಗಿದೆ ಮತ್ತು ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿ ಎಂದಿಗೂ,\/\/ಮತ್ತು ವಿಂಗಡಿಸಲಾದ ಕ್ರಮದೊಂದಿಗೆ ಫಲಿತಾಂಶದ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, \/\/ಅದರಿಂದ ವಿಚಿತ್ರ ಉದ್ದಗಳನ್ನು ಹೊಂದಿರುವ ತಂತಿಗಳನ್ನು ಅಳಿಸುತ್ತದೆ, \/\/ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಪಟ್ಟಿಯನ್ನು ನಿಯತಾಂಕವಾಗಿ ಸ್ವೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ, \/\/ >>> list_sort([]string{\"aa\", \"a\", \"aaa\"})\n\/\/ []string{\"aa\"}\n\/\/ >>> list_sort([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n\/\/ []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n","canonical_solution":"package sorted_list_sum_test\n\nimport (\n    \"sort\"\n)\n\nfunc sorted_list_sum(lst []string) []string {\n    \/\/ Filter out strings with odd lengths\n    filtered := []string{}\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            filtered = append(filtered, str)\n        }\n    }\n\n    \/\/ Sort the filtered list by length, then alphabetically\n    sort.Slice(filtered, func(i, j int) bool {\n        if len(filtered[i]) == len(filtered[j]) {\n            return filtered[i] < filtered[j]\n        }\n        return len(filtered[i]) < len(filtered[j])\n    })\n\n    return filtered\n}","tests":"func TestSorted_List_Sum(t *testing.T) {\n  candidate := sorted_list_sum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"aa\", \"a\", \"aaa\"}), expected: []string{\"aa\"} },\n     { actual: candidate([]string{\"school\", \"AI\", \"asdf\", \"b\"}), expected: []string{\"AI\", \"asdf\", \"school\"} },\n     { actual: candidate([]string{\"d\", \"b\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"d\", \"dcba\", \"abcd\", \"a\"}), expected: []string{\"abcd\", \"dcba\"} },\n     { actual: candidate([]string{\"AI\", \"ai\", \"au\"}), expected: []string{\"AI\", \"ai\", \"au\"} },\n     { actual: candidate([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}), expected: []string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_150","nl":"kan_Knda","pl":"go_test.go","prompt":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆ ಮತ್ತು y ನ ಮೌಲ್ಯವನ್ನು ಮರಳಿ ನೀಡಬೇಕು ಇಲ್ಲದಿದ್ದರೆ.\/\/ಒಂದು ಸರಳ ಪ್ರೋಗ್ರಾಂ ಇದು n  ಆಗಿದ್ದರೆ x ನ ಮೌಲ್ಯವನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು\/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunc x_or_y(n int, x int, y int) int {\n","canonical_solution":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    }\n    return y\n}\n\nfunc TestXOrY(t *testing.T) {\n    cases := []struct{\n        n, x, y, want int\n    }{\n        {7, 34, 12, 34},\n        {15, 8, 5, 5},\n        {2, 10, 20, 10},\n        {1, 5, 15, 15},\n    }\n\n    for _, c := range cases {\n        got := x_or_y(c.n, c.x, c.y)\n        if got != c.want {\n            t.Errorf(\"x_or_y(%d, %d, %d) == %d, want %d\", c.n, c.x, c.y, got, c.want)\n        }\n    }\n}","tests":"func TestX_Or_Y(t *testing.T) {\n  candidate := x_or_y\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7, 34, 12), expected: 34 },\n     { actual: candidate(15, 8, 5), expected: 5 },\n     { actual: candidate(3, 33, 5212), expected: 33 },\n     { actual: candidate(1259, 3, 52), expected: 3 },\n     { actual: candidate(7919, -1, 12), expected: -1 },\n     { actual: candidate(3609, 1245, 583), expected: 583 },\n     { actual: candidate(91, 56, 129), expected: 129 },\n     { actual: candidate(6, 34, 1234), expected: 1234 },\n     { actual: candidate(1, 2, 0), expected: 0 },\n     { actual: candidate(2, 2, 0), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_151","nl":"kan_Knda","pl":"go_test.go","prompt":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಪಟ್ಟಿಯಲ್ಲಿರುವ ಬೆಸ ಸಂಖ್ಯೆಗಳು. ಋಣಾತ್ಮಕ ಅಥವಾ ಪೂರ್ಣಾಂಕಗಳಲ್ಲದ ಸಂಖ್ಯೆಗಳನ್ನು ನಿರ್ಲಕ್ಷಿಸಿ.\/\/ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ಸಂಖ್ಯೆಗಳ ಚೌಕಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿ \/\/ >>> double_the_difference([]int{1, 3, 2, 0})\n\/\/ 10\n\/\/ >>> double_the_difference([]int{-1, -2, 0})\n\/\/ 0\n\/\/ >>> double_the_difference([]int{9, -2})\n\/\/ 81\n\/\/ >>> double_the_difference([]int{0})\n\/\/ 0\n\/\/ If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n","canonical_solution":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc double_the_difference(lst []float64) int {\n    sum := 0\n    for _, num := range lst {\n        if num >= 0 && math.Mod(num, 1) == 0 {\n            intNum := int(num)\n            if intNum%2 != 0 {\n                sum += intNum * intNum\n            }\n        }\n    }\n    return sum\n}\n\nfunc TestDoubleTheDifference(t *testing.T) {\n    cases := []struct {\n        input []float64\n        expected int\n    }{\n        {input: []float64{1, 3, 2, 0}, expected: 10},\n        {input: []float64{-1, -2, 0}, expected: 0},\n        {input: []float64{9, -2}, expected: 81},\n        {input: []float64{0}, expected: 0},\n        {input: []float64{}, expected: 0},\n    }\n\n    for _, c := range cases {\n        result := double_the_difference(c.input)\n        if result != c.expected {\n            t.Errorf(\"double_the_difference(%v) == %d, want %d\", c.input, result, c.expected)\n        } else {\n            fmt.Printf(\"Test passed for input %v. Result: %d\\n\", c.input, result)\n        }\n    }\n}","tests":"func TestDouble_The_Difference(t *testing.T) {\n  candidate := double_the_difference\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{}), expected: 0 },\n     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },\n     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },\n     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },\n     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },\n     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_152","nl":"kan_Knda","pl":"go_test.go","prompt":"package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಮೌಲ್ಯವು 0 ಆಗಿದ್ದರೆ, ಇಲ್ಲದಿದ್ದರೆ, ಮೌಲ್ಯವು ಊಹೆ ಮತ್ತು ಸ್ಕೋರ್ ನಡುವಿನ ಸಂಪೂರ್ಣ ವ್ಯತ್ಯಾಸವಾಗಿದೆ.\/\/ಪ್ರತಿ ಊಹೆಯು ಎಷ್ಟು ದೂರದಲ್ಲಿದೆ ಎಂಬುದನ್ನು ಸೂಚಿಸುವ ಅದೇ ಉದ್ದದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿ. ಅವರು ಸರಿಯಾಗಿ ಊಹಿಸಿದರೆ, \/\/ನಿಮಗೆ ಎರಡು ಪಟ್ಟಿಗಳ ಅಂಕಗಳು ಮತ್ತು ಊಹೆಗಳಿವೆ, ಪ್ರತಿ ಸೂಚ್ಯಂಕವು ಹೊಂದಾಣಿಕೆಯನ್ನು ತೋರಿಸುತ್ತದೆ.\/\/ನಿಮ್ಮ ಕೆಲಸವೆಂದರೆ, ಒಬ್ಬ ವ್ಯಕ್ತಿಯು ಹಲವಾರು ಪಂದ್ಯಗಳ ಫಲಿತಾಂಶಗಳನ್ನು ಸರಿಯಾಗಿ ಊಹಿಸಿದ್ದಾನೆಯೇ ಎಂಬುದನ್ನು ನಿರ್ಧರಿಸುವುದು.\/\/ಖಂಡಿತವಾಗಿಯೂ ಗಮನಿಸಬೇಕಾದ ಮತ್ತು ಹೋಲಿಸುವ ಮೌಲ್ಯದ.\/\/ಈ ಘಟನೆ ಅಂತಿಮವಾಗಿ ತಿಳಿದಿದೆ. ಆ ಕ್ಷಣದಲ್ಲಿ ನೀವು ಹೊಂದಿರುವ ಭಾವನೆಗಳು ಮತ್ತು ಆಲೋಚನೆಗಳು \/\/ನಾವು ದೀರ್ಘ ಕಾಯುತ್ತಿದ್ದವು ಕೆಲವು ಫಲಿತಾಂಶವನ್ನು ಆ ಭಾವನೆ ನೆನಪಿಡಿ ಭಾವಿಸುತ್ತೇನೆ \/\/ >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n\/\/ []int{0, 0, 0, 0, 3, 3}\n\/\/ >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n\/\/ []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n","canonical_solution":"package compare_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := 0; i < len(game); i++ {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc TestCompare(t *testing.T) {\n    tests := []struct {\n        game  []int\n        guess []int\n        want  []int\n    }{\n        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},\n        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%v vs %v\", tt.game, tt.guess), func(t *testing.T) {\n            got := compare(tt.game, tt.guess)\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"compare(%v, %v) = %v; want %v\", tt.game, tt.guess, got, tt.want)\n                }\n            }\n        })\n    }\n}","tests":"func TestCompare(t *testing.T) {\n  candidate := compare\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },\n     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },\n     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },\n     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_153","nl":"kan_Knda","pl":"go_test.go","prompt":"package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/(ಅದರ ಬಲವು -1) ಆಗಿದೆ.\/\/\"Slices.SErviNGSliCes\" ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ ಏಕೆಂದರೆ \"SErviNGSliCes\" ಎಂಬುದು ಪ್ರಬಲ ವಿಸ್ತರಣೆಯಾಗಿದೆ \/\/ವಿಸ್ತರಣೆಗಳುಃ ['SErviNGSliCes', 'Cheese', 'StuFfed'] ಆಗ ನೀವು \/\/ಉದಾಹರಣೆಗೆ, ನಿಮಗೆ \"ಸ್ಲೈಸ್\" ಅನ್ನು ವರ್ಗವಾಗಿ ನೀಡಿದರೆ ಮತ್ತು \/\/ ಪಟ್ಟಿಯಲ್ಲಿ ಮೊದಲನೆಯದನ್ನು ಆಯ್ಕೆಮಾಡಿ.\/\/ಎರಡು ಅಥವಾ ಅದಕ್ಕಿಂತ ಹೆಚ್ಚಿನ ವಿಸ್ತರಣೆಗಳು ಒಂದೇ ಬಲವನ್ನು ಹೊಂದಿದ್ದರೆ, ನೀವು \/\/ಸ್ವರೂಪ: ವರ್ಗದ ಹೆಸರು. ಬಲವಾದ ವಿಸ್ತರಣೆಯ ಹೆಸರು. \/\/ನೀವು ಬಲವಾದ ವಿಸ್ತರಣೆಯನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು ಮತ್ತು ಈ \/\/ವಿಸ್ತರಣೆಯ ಹೆಸರಿನಲ್ಲಿ, CAP - SM ಎಂಬ ಭಾಗದಿಂದ ಶಕ್ತಿಯನ್ನು ನೀಡಲಾಗುತ್ತದೆ.\/\/ವಿಸ್ತರಣೆಯ ಹೆಸರಿನಲ್ಲಿ ಅಕ್ಷರಗಳು, ಮತ್ತು SM ಚಿಕ್ಕ ಅಕ್ಷರಗಳ ಸಂಖ್ಯೆ ಆಗಿರಲಿ \/\/ವಿಸ್ತರಣೆಯ ಬಲವು ಈ ಕೆಳಗಿನಂತಿರುತ್ತದೆ: CAP ದೊಡ್ಡಕ್ಷರ ಸಂಖ್ಯೆಯಾಗಿರಲಿ \/\/ವಿಸ್ತರಣೆಗಳನ್ನು ವರ್ಗಕ್ಕೆ ಹೆಚ್ಚುವರಿ ವರ್ಗಗಳನ್ನು ಲೋಡ್ ಮಾಡಲು ಬಳಸಲಾಗುತ್ತದೆ.\/\/ನಿಮಗೆ ಒಂದು ವರ್ಗದ ಹೆಸರು (ಒಂದು ಸ್ಟ್ರಿಂಗ್) ಮತ್ತು ವಿಸ್ತರಣೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗುವುದು.\/\/ >>> Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"})\n\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name string, extensions []string) string {\n","canonical_solution":"func Strongest_Extension(class_name string, extensions []string) string {\n    strongestExtension := \"\"\n    maxStrength := -1 << 31\n\n    for _, extension := range extensions {\n        capCount, smCount := 0, 0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                capCount++\n            } else if char >= 'a' && char <= 'z' {\n                smCount++\n            }\n        }\n        strength := capCount - smCount\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    return fmt.Sprintf(\"%s.%s\", class_name, strongestExtension)\n}","tests":"func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected: \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected: \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\" },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n     { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_154","nl":"kan_Knda","pl":"go_test.go","prompt":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ನಿಮಗೆ 2 ಪದಗಳನ್ನು ನೀಡಲಾಗಿದೆ. ನೀವು ಎರಡನೇ ಪದ ಅಥವಾ ಅದರ ಯಾವುದೇ ತಿರುಗುವಿಕೆಗಳು ಮೊದಲ ಪದದಲ್ಲಿ ಉಪಸರಣಿಯಾಗಿದ್ದರೆ ನೀವು true ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕಾಗಿದೆ.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunc cycpattern_check(a string, b string) bool {\n","canonical_solution":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc cycpattern_check(a string, b string) bool {\n    n := len(b)\n    \n    \/\/ Generate all rotations of b\n    for i := 0; i < n; i++ {\n        rotated := b[i:] + b[:i]\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    \n    return false\n}","tests":"func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual: candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_155","nl":"kan_Knda","pl":"go_test.go","prompt":"package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಒಂದು ಪೂರ್ಣಾಂಕವನ್ನು ನೀಡಲಾಗಿದೆ. ಕ್ರಮವಾಗಿ ಸಮ ಮತ್ತು ಬೆಸ ಅಂಕೆಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹೊಂದಿರುವ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ >>> even_odd_count(-12)\n\/\/ []interface{}{1, 1}\n\/\/ >>> even_odd_count(123)\n\/\/ []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n","canonical_solution":"func even_odd_count(num int) []interface{} {\n    \/\/ Handle negative numbers by taking the absolute value\n    if num < 0 {\n        num = -num\n    }\n    \n    evenCount, oddCount := 0, 0\n\n    \/\/ Iterate over each digit in the number\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n        num \/= 10\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\nfunc TestEvenOddCount(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected []interface{}\n    }{\n        {-12, []interface{}{1, 1}},\n        {123, []interface{}{1, 2}},\n        {2468, []interface{}{4, 0}},\n        {1357, []interface{}{0, 4}},\n        {0, []interface{}{1, 0}},\n    }\n\n    for _, testCase := range testCases {\n        result := even_odd_count(testCase.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", testCase.expected) {\n            t.Errorf(\"even_odd_count(%d) = %v; expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}","tests":"func TestEven_Odd_Count(t *testing.T) {\n  candidate := even_odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7), expected: []interface{}{0, 1} },\n     { actual: candidate(-78), expected: []interface{}{1, 1} },\n     { actual: candidate(3452), expected: []interface{}{2, 2} },\n     { actual: candidate(346211), expected: []interface{}{3, 3} },\n     { actual: candidate(-345821), expected: []interface{}{3, 3} },\n     { actual: candidate(-2), expected: []interface{}{1, 0} },\n     { actual: candidate(-45347), expected: []interface{}{2, 3} },\n     { actual: candidate(0), expected: []interface{}{1, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_156","nl":"kan_Knda","pl":"go_test.go","prompt":"package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು: \/\/ನಿರ್ಬಂಧಗಳು: 1 <= num <= 1000 \/\/ಮತ್ತು ಅದನ್ನು ಸಣ್ಣ ಅಕ್ಷರಗಳಲ್ಲಿ ಹಿಂದಿರುಗಿಸಿ.\/\/ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕವನ್ನು ನೀಡಿದರೆ, ಅದರ ರೋಮನ್ ಸಂಖ್ಯಾ ಸಮಾನತೆಯನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಪಡೆಯಿರಿ, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n","canonical_solution":"package int_to_mini_roman_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc int_to_mini_roman(number int) string {\n\tvals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\tsymbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n\tvar roman strings.Builder\n\n\tfor i := 0; i < len(vals); i++ {\n\t\tfor number >= vals[i] {\n\t\t\tnumber -= vals[i]\n\t\t\troman.WriteString(symbols[i])\n\t\t}\n\t}\n\treturn roman.String()\n}\n\nfunc TestIntToMiniRoman(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected string\n\t}{\n\t\t{19, \"xix\"},\n\t\t{152, \"clii\"},\n\t\t{426, \"cdxxvi\"},\n\t\t{1000, \"m\"},\n\t\t{1, \"i\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d\", tt.input), func(t *testing.T) {\n\t\t\tresult := int_to_mini_roman(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Fatalf(\"expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_157","nl":"kan_Knda","pl":"go_test.go","prompt":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/90 ಡಿಗ್ರಿ \/\/ಒಂದು ಬಲ ಕೋನ ತ್ರಿಕೋನವು ಒಂದು ಕೋನವು ಬಲ ಕೋನ ಅಥವಾ \/\/ವು ಒಂದು ಬಲಕೋನೀಯ ತ್ರಿಕೋನವನ್ನು ರೂಪಿಸುತ್ತದೆ, ಇಲ್ಲದಿದ್ದರೆ ಅದು ಸುಳ್ಳು.\/\/ತ್ರಿಭುಜದ ಮೂರು ಬದಿಗಳ ಉದ್ದವನ್ನು ನೀಡಲಾಗಿದೆ. ತ್ರಿಭುಜದ ಮೂರು \/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunc right_angle_triangle(a int, b int, c int) bool {\n","canonical_solution":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n    \/\/ Squaring the sides\n    a2, b2, c2 := a*a, b*b, c*c\n    \/\/ Check the Pythagorean theorem for the combination of sides\n    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2\n}","tests":"func TestRight_Angle_Triangle(t *testing.T) {\n  candidate := right_angle_triangle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: true },\n     { actual: candidate(1, 2, 3), expected: false },\n     { actual: candidate(10, 6, 8), expected: true },\n     { actual: candidate(2, 2, 2), expected: false },\n     { actual: candidate(7, 24, 25), expected: true },\n     { actual: candidate(10, 5, 7), expected: false },\n     { actual: candidate(5, 12, 13), expected: true },\n     { actual: candidate(15, 8, 17), expected: true },\n     { actual: candidate(48, 55, 73), expected: true },\n     { actual: candidate(1, 1, 1), expected: false },\n     { actual: candidate(2, 2, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_158","nl":"kan_Knda","pl":"go_test.go","prompt":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಅಕ್ಷರಗಳ ಪಟ್ಟಿಯಲ್ಲಿ, ಶಬ್ದಕೋಶೀಯ ಕ್ರಮದಲ್ಲಿ ಮೊದಲು ಬರುವ ಅಕ್ಷರವನ್ನು ಹಿಂತಿರುಗಿಸಿ.\/\/ಬಹು ಸ್ಟ್ರಿಂಗ್ಗಳು ಗರಿಷ್ಠ ಸಂಖ್ಯೆಯ ಅನನ್ಯ \/\/ಈ ಪಟ್ಟಿಯು ವಿವಿಧ ಪದಗಳನ್ನು ಒಳಗೊಂಡಿದೆ. ಗರಿಷ್ಠ ಸಂಖ್ಯೆಯ ಪದವನ್ನು ಹಿಂತಿರುಗಿ \/\/ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯನ್ನು ಸ್ವೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ.\/\/ >>> find_max([]string{\"name\", \"of\", \"string\"})\n\/\/ \"string\"\n\/\/ >>> find_max([]string{\"name\", \"enam\", \"game\"})\n\/\/ \"enam\"\n\/\/ >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\/\/ \"aaaaaaa\"\nfunc find_max(words []string) string {\n","canonical_solution":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc find_max(words []string) string {\n    maxWord := \"\"\n    maxUnique := 0\n    \n    for _, word := range words {\n        uniqueChars := countUniqueChars(word)\n        if uniqueChars > maxUnique {\n            maxUnique = uniqueChars\n            maxWord = word\n        } else if uniqueChars == maxUnique {\n            if maxWord == \"\" || word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    \n    return maxWord\n}\n\nfunc countUniqueChars(word string) int {\n    charSet := make(map[rune]struct{})\n    for _, c := range word {\n        charSet[c] = struct{}{}\n    }\n    return len(charSet)\n}\n\n\/\/ Test case runs to verify the solution\nfunc TestFindMax(t *testing.T) {\n    testCases := []struct {\n        input []string\n        expected string\n    }{\n        {[]string{\"name\", \"of\", \"string\"}, \"string\"},\n        {[]string{\"name\", \"enam\", \"game\"}, \"enam\"},\n        {[]string{\"aaaaaaa\", \"bb\", \"cc\"}, \"aaaaaaa\"},\n    }\n\n    for _, tc := range testCases {\n        result := find_max(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"For input %v, expected %s, but got %s\", tc.input, tc.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", tc.input)\n        }\n    }\n}","tests":"func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_159","nl":"kan_Knda","pl":"go_test.go","prompt":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆ: \/\/ಉಳಿದಿರುವ ಸಾಕಷ್ಟು ಕ್ಯಾರೆಟ್ಗಳು ಇಲ್ಲದಿದ್ದರೆ, ನೀವು ಉಳಿದಿರುವ ಎಲ್ಲಾ ಕ್ಯಾರೆಟ್ಗಳನ್ನು ತಿನ್ನುತ್ತೀರಿ, ಆದರೆ ಇನ್ನೂ ಹಸಿವಿನಿಂದ ಇರುತ್ತೀರಿ.\/\/ನಿಮ್ಮ ಊಟದ ನಂತರ ಉಳಿದಿರುವ ಕ್ಯಾರೆಟ್ಗಳ ಸಂಖ್ಯೆ ] \/\/ನೀವು ಊಟದ ನಂತರ ಸೇವಿಸಿದ ಕ್ಯಾರೆಟ್ಗಳ ಒಟ್ಟು ಸಂಖ್ಯೆಯ ಪಟ್ಟಿಯನ್ನು ನೀವು ಹಿಂದಿರುಗಿಸಬೇಕು,\/\/ಆದರೆ ಈಗ ನೀವು ದಿನಕ್ಕೆ ಊಟವನ್ನು ಪೂರ್ಣಗೊಳಿಸಲು ಹೆಚ್ಚು ಕ್ಯಾರೆಟ್ಗಳನ್ನು ತಿನ್ನಬೇಕು.\/\/ನೀವು ಹಸಿದ ಮೊಲ, ಮತ್ತು ನೀವು ಈಗಾಗಲೇ ಕ್ಯಾರೆಟ್ ಒಂದು ನಿರ್ದಿಷ್ಟ ಸಂಖ್ಯೆಯ ತಿನ್ನುತ್ತಿದ್ದ, \/\/ >>> eat(5, 6, 10)\n\/\/ []int{11, 4}\n\/\/ >>> eat(4, 8, 9)\n\/\/ []int{12, 1}\n\/\/ >>> eat(1, 10, 10)\n\/\/ []int{11, 0}\n\/\/ >>> eat(2, 11, 5)\n\/\/ []int{7, 0}\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n","canonical_solution":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ eat calculates the total number of eaten carrots after meals and the number of carrots left.\nfunc eat(number int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{number + need, remaining - need}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n    tests := []struct {\n        number, need, remaining int\n        expected                []int\n    }{\n        {5, 6, 10, []int{11, 4}},\n        {4, 8, 9, []int{12, 1}},\n        {1, 10, 10, []int{11, 0}},\n        {2, 11, 5, []int{7, 0}},\n    }\n\n    for _, test := range tests {\n        result := eat(test.number, test.need, test.remaining)\n        if result[0] != test.expected[0] || result[1] != test.expected[1] {\n            t.Errorf(\"eat(%d, %d, %d) = %v; expected %v\", test.number, test.need, test.remaining, result, test.expected)\n        }\n    }\n}","tests":"func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_160","nl":"kan_Knda","pl":"go_test.go","prompt":"package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಆಪರೇಟರ್ ಪಟ್ಟಿಯಲ್ಲಿ ಕನಿಷ್ಠ ಒಂದು ಆಪರೇಟರ್ ಇದೆ, ಮತ್ತು ಆಪರೇಂಡ್ ಪಟ್ಟಿಯಲ್ಲಿ ಕನಿಷ್ಠ ಎರಡು ಆಪರೇಂಡ್ಗಳಿವೆ.\/\/ಆಪರೇಂಡ್ ವು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ಪಟ್ಟಿಯಾಗಿದೆ.\/\/ಆಪರೇಟರ್ ಪಟ್ಟಿಯ ಉದ್ದವು ಆಪರೇಂಡ್ ಪಟ್ಟಿಯ ಉದ್ದಕ್ಕೆ ಒಂದು ಮೈನಸ್ಗೆ ಸಮಾನವಾಗಿರುತ್ತದೆ.\/\/ಟಿಪ್ಪಣಿ: \/\/=> ಫಲಿತಾಂಶ = 9 \/\/ಫಲಿತಾಂಶ = 2 + 3 * 4 - 5 \/\/ಪಟ್ಟಿ = [2, 3, 4, 5] \/\/ನಿರ್ವಾಹಕ ['+', '*', '-'] \/\/ಉದಾಹರಣೆ: \/\/ಮಾಪಕೀಕರಣ (**) \/\/ನೆಲದ ವಿಭಾಗ ( \/\/ ) \/\/ಗುಣಾಕಾರ ( *) \/\/ಕಳೆಯುವಿಕೆ ( - ) \/\/ಸೇರ್ಪಡೆ (+) \/\/ಮೂಲಭೂತ ಬೀಜಗಣಿತದ ಕಾರ್ಯಾಚರಣೆಗಳು: \/\/ ಮತ್ತು ಈ ಅಭಿವ್ಯಕ್ತಿಯ ಮೌಲ್ಯಮಾಪನವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.\/\/ಎರಡನೇ ಪಟ್ಟಿಯು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯಾಗಿದೆ. ಅಲ್ಜೀಬ್ರಿಕ್ ಅನ್ನು ನಿರ್ಮಿಸಲು ಎರಡು ಪಟ್ಟಿಗಳನ್ನು ಬಳಸಿ \/\/ಎರಡು ಪಟ್ಟಿಗಳನ್ನು ನೀಡಲಾಗಿದೆ ಆಪರೇಟರ್, ಮತ್ತು ಆಪರೇಂಡ್. ಮೊದಲ ಪಟ್ಟಿಯಲ್ಲಿ ಮೂಲಭೂತ ಬೀಜಗಣಿತದ ಕಾರ್ಯಾಚರಣೆಗಳು ಇವೆ, ಮತ್ತು func do_algebra(operator []string, operand []int) int {\n","canonical_solution":"package do_algebra_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc do_algebra(operator []string, operand []int) int {\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n\n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"\/\/\":\n            result \/= operand[i+1]\n        case \"**\":\n            result = intPow(result, operand[i+1])\n        }\n    }\n\n    return result\n}\n\nfunc intPow(base, exp int) int {\n    result := 1\n    for exp != 0 {\n        if exp%2 == 1 {\n            result *= base\n        }\n        exp \/= 2\n        base *= base\n    }\n    return result\n}\n\nfunc TestDoAlgebra(t *testing.T) {\n    operators := []string{\"+\", \"*\", \"-\"}\n    operands := []int{2, 3, 4, 5}\n    expectedResult := 9\n    result := do_algebra(operators, operands)\n    if result != expectedResult {\n        t.Errorf(\"expected %d but got %d\", expectedResult, result)\n    }\n\n    fmt.Println(\"All tests passed.\")\n}","tests":"func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"\/\/\", \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_161","nl":"kan_Knda","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗಳು \/\/ಕಾರ್ಯವು ಫಲಿತಾಂಶದ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು.\/\/ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿ ಯಾವುದೇ ಅಕ್ಷರಗಳಿಲ್ಲದಿದ್ದರೆ, ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಮ್ಮುಖಗೊಳಿಸಿ.\/\/ಇಲ್ಲದಿದ್ದರೆ ಹಾಗೇ ಇಟ್ಟುಕೊಳ್ಳಿ.\/\/s[i] ಒಂದು ಅಕ್ಷರವಾಗಿದ್ದರೆ, ಅದರ ಪ್ರಕರಣವನ್ನು ಕೆಳಭಾಗದಿಂದ ಮೇಲಿನ ಕಡೆಗೆ ಅಥವಾ ಪ್ರತಿಯಾಗಿ ತಿರುಗಿಸಿ, \/\/ನಿಮಗೆ ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ನೀಡಲಾಗಿದೆ.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunc solve(s string) string {\n","canonical_solution":"package solve_test\n\nimport (\n    \"unicode\"\n)\n\nfunc solve(s string) string {\n    hasLetter := false\n    result := []rune(s)\n\n    for i, char := range result {\n        if unicode.IsLetter(char) {\n            hasLetter = true\n            if unicode.IsUpper(char) {\n                result[i] = unicode.ToLower(char)\n            } else {\n                result[i] = unicode.ToUpper(char)\n            }\n        }\n    }\n\n    if !hasLetter {\n        \/\/ reverse the string\n        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {\n            result[i], result[j] = result[j], result[i]\n        }\n    }\n\n    return string(result)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_163","nl":"kan_Knda","pl":"go_test.go","prompt":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ಉದಾಹರಣೆಗೆ: \/\/ಮತ್ತು b, ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ.\/\/ಎರಡು ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳನ್ನು ನೀಡಿದರೆ a ಮತ್ತು b, a  ನಡುವಿನ ಸಮ ಅಂಕೆಗಳನ್ನು ಹಿಂತಿರುಗಿ.\/\/ >>> generate_integers(2, 8)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(8, 2)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(10, 14)\n\/\/ []int{}\nfunc generate_integers(a int, b int) []int {\n","canonical_solution":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc generate_integers(a int, b int) []int {\n    start, end := a, b\n    if a > b {\n        start, end = b, a\n    }\n    \n    result := []int{}\n    for i := start; i <= end; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestGenerateIntegers(t *testing.T) {\n    tests := []struct {\n        a, b int\n        want []int\n    }{\n        {2, 8, []int{2, 4, 6, 8}},\n        {8, 2, []int{2, 4, 6, 8}},\n        {10, 14, []int{}},\n    }\n    \n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"generate_integers(%d, %d)\", tt.a, tt.b), func(t *testing.T) {\n            got := generate_integers(tt.a, tt.b)\n            if len(got) != len(tt.want) {\n                t.Errorf(\"expected %v, got %v\", tt.want, got)\n                return\n            }\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"expected %v, got %v\", tt.want, got)\n                    return\n                }\n            }\n        })\n    }\n}","tests":"func TestGenerate_Integers(t *testing.T) {\n  candidate := generate_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(17, 89), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]