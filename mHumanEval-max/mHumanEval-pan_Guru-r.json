[{"task_id":"HumanEval_0","nl":"pan_Guru","pl":"r","prompt":"ਦਿੱਤਾ ਗਿਆ ਥ੍ਰੈਸ਼ਹੋਲਡ।ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਦਿੱਤੇ ਗਏ ਨੰਬਰਾਂ ਦੀ ਸੂਚੀ ਵਿੱਚ, ਕੋਈ ਦੋ ਨੰਬਰ ਇੱਕ ਦੂਜੇ ਦੇ ਨੇੜੇ ਹਨ # >>> has_close_elements(c(1.0, 2.0, 3.0), 0.5)\n# FALSE\n# >>> has_close_elements(c(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n# TRUE\nhas_close_elements <- function(numbers, threshold) {","canonical_solution":"has_close_elements <- function(numbers, threshold) {\n  for (i in seq_along(numbers)) {\n    for (j in seq_along(numbers)) {\n      if (i != j && abs(numbers[i] - numbers[j]) < threshold) {\n        return(TRUE)\n      }\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- has_close_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.95), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.8), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 1.0), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 0.5), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_1","nl":"pan_Guru","pl":"r","prompt":"ਇਨਪੁਟ ਸਤਰ ਵਿੱਚ ਕਿਸੇ ਵੀ ਸਪੇਸ ਨੂੰ ਅਣਡਿੱਠਾ ਕਰੋ।ਵੱਖਰੇ ਸਮੂਹ ਸੰਤੁਲਿਤ ਹਨ (ਹਰੇਕ ਖੁੱਲ੍ਹੇ ਬਰੇਸ ਸਹੀ ਤਰ੍ਹਾਂ ਬੰਦ ਹੈ) ਅਤੇ ਇਕ ਦੂਜੇ ਦੇ ਅੰਦਰ ਨਹੀਂ ਹਨ ਉਹਨਾਂ ਸਮੂਹ ਨੂੰ ਵੱਖਰੇ ਸਤਰਾਂ ਵਿੱਚ ਵੱਖ ਕਰੋ ਅਤੇ ਉਹਨਾਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰੋ।ਇਸ ਫੰਕਸ਼ਨ ਲਈ ਇਨਪੁਟ ਇੱਕ ਸਤਰ ਹੈ ਜਿਸ ਵਿੱਚ ਨੇਸਟਡ ਬਰੈਂਚੈੱਸ ਦੇ ਕਈ ਸਮੂਹ ਹਨ. ਤੁਹਾਡਾ ਟੀਚਾ ਹੈ # >>> separate_paren_groups('( ) (( )) (( )( ))')\n# c('()', '(())', '(()())')\nseparate_paren_groups <- function(paren_string) {","canonical_solution":"separate_paren_groups <- function(paren_string) {\n  # Remove spaces from the input string\n  paren_string <- gsub(\" \", \"\", paren_string)\n  \n  # Initialize variables for processing\n  result <- c()\n  current_group <- \"\"\n  balance <- 0\n  \n  # Iterate through each character in the string\n  for (char in strsplit(paren_string, \"\")[[1]]) {\n    current_group <- paste0(current_group, char)\n    if (char == \"(\") {\n      balance <- balance + 1\n    } else if (char == \")\") {\n      balance <- balance - 1\n    }\n    \n    # If balance is zero, we found a complete group\n    if (balance == 0 && nchar(current_group) > 0) {\n      result <- c(result, current_group)\n      current_group <- \"\"\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- separate_paren_groups\n    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c('(()())', '((()))', '()', '((())()())'))))\n    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c('()', '(())', '((()))', '(((())))'))))\n    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c('(()(())((())))'))))\n    stopifnot(isTRUE(all.equal(candidate('( ) (( )) (( )( ))'), c('()', '(())', '(()())'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_2","nl":"pan_Guru","pl":"r","prompt":"ਸੰਖਿਆ ਦਾ ਦਸ਼ਮਲਵ ਹਿੱਸਾ ਵਾਪਸ ਕਰੋ।(ਬਚਿਆ ਹਿੱਸਾ ਹਮੇਸ਼ਾ 1 ਤੋਂ ਛੋਟਾ ਹੁੰਦਾ ਹੈ) ।ਅਤੇ ਪੂਰਨ ਅੰਕ ਭਾਗ (ਦਿੱਤੇ ਗਏ ਨੰਬਰ ਤੋਂ ਛੋਟਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ) ਅਤੇ ਦਸ਼ਮਲਵ ਇੱਕ ਸਕਾਰਾਤਮਕ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਨੰਬਰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਨੂੰ  ਵਿੱਚ ਵੰਡਿਆ ਜਾ ਸਕਦਾ ਹੈ# >>> truncate_number(3.5)\n# 0.5\ntruncate_number <- function(number) {","canonical_solution":"truncate_number <- function(number) {\n  return(number - floor(number))\n}","tests":"test_humaneval <- function() {\n    candidate <- truncate_number\n    stopifnot(isTRUE(all.equal(candidate(3.5), 0.5)))\n    stopifnot(isTRUE(all.equal(candidate(1.25), 0.25)))\n    stopifnot(isTRUE(all.equal(candidate(123.0), 0.0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_3","nl":"pan_Guru","pl":"r","prompt":"ਉਸ ਬਿੰਦੂ ਤੇ ਫੰਕਸ਼ਨ ਨੂੰ TRUE ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। ਨਹੀਂ ਤਾਂ ਇਹ FALSE ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।ਜ਼ੀਰੋ ਸੰਤੁਲਨ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਪਤਾ ਲਗਾਉਣਾ ਹੈ ਕਿ ਕਿਸੇ ਵੀ ਸਮੇਂ ਖਾਤੇ ਦਾ ਸੰਤੁਲਨ ਜ਼ੀਰੋ ਤੋਂ ਹੇਠਾਂ ਆ ਜਾਂਦਾ ਹੈ, ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਬੈਂਕ ਖਾਤੇ ਵਿੱਚ ਜਮ੍ਹਾਂ ਅਤੇ ਕਢਵਾਉਣ ਦੀਆਂ ਕਾਰਵਾਈਆਂ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ ਜੋ  ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ# >>> below_zero(c(1, 2, 3))\n# FALSE\n# >>> below_zero(c(1, 2, -4, 5))\n# TRUE\nbelow_zero <- function(operations) {","canonical_solution":"below_zero <- function(operations) {\n  balance <- 0\n  for (op in operations) {\n    balance <- balance + op\n    if (balance < 0) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- below_zero\n    stopifnot(isTRUE(all.equal(candidate(c()), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -3, 1, 2, -3)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -4, 5, 6)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -2, 2, -2, 5, -5, 4, -4)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_4","nl":"pan_Guru","pl":"r","prompt":"MAD = ਔਸਤ ∙ x - x_mean ∙ਤੱਤ ਅਤੇ ਇੱਕ ਕੇਂਦਰ ਬਿੰਦੂ (ਇਸ ਕੇਸ ਵਿੱਚ ਮਤਲਬ): ਮੱਧਮ ਅਸਲੀ ਭਟਕਣਾ ਹਰੇਕ ਵਿਚਕਾਰ ਔਸਤ ਅਸਲੀ ਅੰਤਰ ਹੈ।ਇਸ ਡੇਟਾ ਸੈੱਟ ਦੇ ਮੱਧ ਦੇ ਆਲੇ ਦੁਆਲੇ.ਇਨਪੁਟ ਨੰਬਰਾਂ ਦੀ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਲਈ, ਮੱਧਮ ਅਸਲੀ ਭਟਕਣ ਦੀ ਗਣਨਾ ਕਰੋ।# >>> mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))\n# 1.0\nmean_absolute_deviation <- function(numbers) {","canonical_solution":"mean_absolute_deviation <- function(numbers) {\n  x_mean <- mean(numbers)\n  mad <- mean(abs(numbers - x_mean))\n  return(mad)\n}\n\n# Example usage\nmean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))","tests":"test_humaneval <- function() {\n    candidate <- mean_absolute_deviation\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0)), 0.5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0)), 1.0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), 1.2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_5","nl":"pan_Guru","pl":"r","prompt":"ਇਨਪੁਟ ਸੂਚੀ ਦੇ ਹਰ ਦੋ ਲਗਾਤਾਰ ਤੱਤਾਂ ਵਿਚਕਾਰ ਇੱਕ ਨੰਬਰ 'ਡਿਲਿਮੀਟਰ' ਪਾਓ ∀numbers' # >>> intersperse(c(), 4)\n# c()\n# >>> intersperse(c(1, 2, 3), 4)\n# c(1, 4, 2, 4, 3)\nintersperse <- function(numbers, delimeter) {","canonical_solution":"intersperse <- function(numbers, delimeter) {\n  if (length(numbers) <= 1) {\n    return(numbers)\n  }\n  result <- c()\n  for (i in 1:(length(numbers) - 1)) {\n    result <- c(result, numbers[i], delimeter)\n  }\n  result <- c(result, numbers[length(numbers)])\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- intersperse\n    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_6","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਵਜੋਂ (() (()) ਵਿੱਚ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਪੱਧਰ ਦੇ ਨੇਸਟਿੰਗ ਹੁੰਦੇ ਹਨ ਜਦੋਂ ਕਿ ((())) ਵਿੱਚ ਤਿੰਨ ਹੁੰਦੇ ਹਨ। ਹਰੇਕ ਸਮੂਹ ਲਈ, ਬਰੈਂਚਜ਼ ਦੇ ਗੁੰਝਲਦਾਰ ਪੱਧਰ ਦਾ ਸਭ ਤੋਂ ਡੂੰਘਾ ਪੱਧਰ ਆਉਟਪੁੱਟ ਕਰੋ.ਇਸ ਫੰਕਸ਼ਨ ਦਾ ਇੰਪੁੱਟ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ ਨੇਸਟਡ ਬਰੈਂਚੈਸ ਲਈ ਮਲਟੀਪਲ ਗਰੁੱਪਾਂ ਦੀ ਨੁਮਾਇੰਦਗੀ ਕਰਨ ਵਾਲੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> parse_nested_parens('(()()) ((())) () ((())()())')\n# c(2, 3, 1, 3)\nparse_nested_parens <- function(paren_string) {","canonical_solution":"parse_nested_parens <- function(paren_string) {\n  sapply(strsplit(paren_string, \" \")[[1]], function(group) {\n    max_nesting <- 0\n    current_nesting <- 0\n    for (char in strsplit(group, \"\")[[1]]) {\n      if (char == \"(\") {\n        current_nesting <- current_nesting + 1\n        max_nesting <- max(max_nesting, current_nesting)\n      } else if (char == \")\") {\n        current_nesting <- current_nesting - 1\n      }\n    }\n    return(max_nesting)\n  })\n}","tests":"test_humaneval <- function() {\n    candidate <- parse_nested_parens\n    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c(2, 3, 1, 3))))\n    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c(4))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_7","nl":"pan_Guru","pl":"r","prompt":"ਸਤਰਾਂ ਦੀ ਇਨਪੁਟ ਸੂਚੀ ਨੂੰ ਸਿਰਫ਼ ਉਹਨਾਂ ਸਤਰਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ ਜਿਨ੍ਹਾਂ ਵਿੱਚ ਦਿੱਤੀ ਗਈ ਸਬਸਟ੍ਰਿੰਗ ਹੈ# >>> filter_by_substring(c(), 'a')\n# c()\n# >>> filter_by_substring(c('abc', 'bacd', 'cde', 'array'), 'a')\n# c('abc', 'bacd', 'array')\nfilter_by_substring <- function(strings, substring) {","canonical_solution":"filter_by_substring <- function(strings, substring) {\n  return(strings[grepl(substring, strings)])\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_by_substring\n    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'), 'xx'), c('xxx', 'aaaxxy', 'xxxAAA', 'xxx'))))\n    stopifnot(isTRUE(all.equal(candidate(c('grunt', 'trumpet', 'prune', 'gruesome'), 'run'), c('grunt', 'prune'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_8","nl":"pan_Guru","pl":"r","prompt":"ਖਾਲੀ ਜੋੜ 0 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਅਤੇ ਖਾਲੀ ਉਤਪਾਦ 1 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।ਪੂਰਨ ਅੰਕ ਦੀ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਲਈ, ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਸਾਰੇ ਪੂਰਨ ਅੰਕ ਦੇ ਜੋੜ ਅਤੇ ਉਤਪਾਦ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ।# >>> sum_product(c())\n# c(0, 1)\n# >>> sum_product(c(1, 2, 3, 4))\n# c(10, 24)\nsum_product <- function(numbers) {","canonical_solution":"sum_product <- function(numbers) {\n  sum_val <- sum(numbers)\n  prod_val <- ifelse(length(numbers) == 0, 1, prod(numbers))\n  return(c(sum_val, prod_val))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_product\n    stopifnot(isTRUE(all.equal(candidate(c()), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1)), c(3, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 0)), c(100, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 7)), c(15, 105))))\n    stopifnot(isTRUE(all.equal(candidate(c(10)), c(10, 10))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_9","nl":"pan_Guru","pl":"r","prompt":"ਕ੍ਰਮ ਵਿੱਚ।ਪੂਰਨ ਅੰਕ ਦੀ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਤੋਂ, ਦਿੱਤੇ ਗਏ ਪਲ ਤੱਕ ਮਿਲੀਆਂ ਰੋਲਿੰਗ ਅਧਿਕਤਮ ਤੱਤਾਂ ਦੀ ਸੂਚੀ ਤਿਆਰ ਕਰੋ # >>> rolling_max(c(1, 2, 3, 2, 3, 4, 2))\n# c(1, 2, 3, 3, 3, 4, 4)\nrolling_max <- function(numbers) {","canonical_solution":"rolling_max <- function(numbers) {\n  max_list <- c()\n  current_max <- -Inf\n  for (number in numbers) {\n    current_max <- max(current_max, number)\n    max_list <- c(max_list, current_max)\n  }\n  return(max_list)\n}","tests":"test_humaneval <- function() {\n    candidate <- rolling_max\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_10","nl":"pan_Guru","pl":"r","prompt":"- ਸਤਰ ਦੇ ਅੰਤ ਵਿੱਚ ਇੱਕ ਸਤਰ ਪ੍ਰੀਫਿਕਸ ਦੇ ਉਲਟ ਜੋੜੋ ਜੋ ਪਾਲੀਂਡਰੋਮਿਕ ਪਿਛੇਤਰ ਤੋਂ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ।- ਸਪਲਾਈ ਕੀਤੀ ਸਤਰ ਦਾ ਸਭ ਤੋਂ ਲੰਬਾ ਪੋਸਟਫਿਕਸ ਲੱਭੋ ਜੋ ਇਕ ਪਾਲੀਂਡਰੋਮ ਹੈ. ਐਲਗੋਰਿਥਮ ਦਾ ਵਿਚਾਰ ਸਰਲ ਹੈਃ ਸਭ ਤੋਂ ਛੋਟਾ ਪੈਲਿੰਡਰੋਮ ਲੱਭੋ ਜੋ ਸਪਲਾਈ ਕੀਤੀ ਸਤਰ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ.# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n# 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\nmake_palindrome <- function(string) {","canonical_solution":"make_palindrome <- function(string) {\n  is_palindrome <- function(s) {\n    return(s == stringi::stri_reverse(s))\n  }\n  \n  n <- nchar(string)\n  \n  for (i in seq(n, 0, by = -1)) {\n    suffix <- substr(string, i, n)\n    if (is_palindrome(suffix)) {\n      prefix <- substr(string, 1, i - 1)\n      return(paste0(string, stringi::stri_reverse(prefix)))\n    }\n  }\n  \n  return(string) # for the empty string case\n}","tests":"test_humaneval <- function() {\n    candidate <- make_palindrome\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('x'), 'x')))\n    stopifnot(isTRUE(all.equal(candidate('xyz'), 'xyzyx')))\n    stopifnot(isTRUE(all.equal(candidate('xyx'), 'xyx')))\n    stopifnot(isTRUE(all.equal(candidate('jerry'), 'jerryrrej')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_11","nl":"pan_Guru","pl":"r","prompt":"ਇਹਨਾਂ ਇੰਪੁੱਟਾਂ ਤੇ ਬਾਈਨਰੀ XOR ਕਰੋ ਅਤੇ ਨਤੀਜਾ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵੀ ਵਾਪਸ ਕਰੋ।ਇਨਪੁਟ ਦੋ ਸਤਰਾਂ ਹਨ a ਅਤੇ b ਜਿਨ੍ਹਾਂ ਵਿੱਚ ਸਿਰਫ 1 ਅਤੇ 0 ਹਨ।# >>> string_xor('010', '110')\n# '100'\nstring_xor <- function(a, b) {","canonical_solution":"string_xor <- function(a, b) {\n  xor_result <- mapply(function(x, y) { \n    ifelse(x == y, 0, 1) \n  }, strsplit(a, NULL)[[1]], strsplit(b, NULL)[[1]])\n  return(paste(xor_result, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- string_xor\n    stopifnot(isTRUE(all.equal(candidate('111000', '101010'), '010010')))\n    stopifnot(isTRUE(all.equal(candidate('1', '1'), '0')))\n    stopifnot(isTRUE(all.equal(candidate('0101', '0000'), '0101')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_12","nl":"pan_Guru","pl":"r","prompt":"ਇੱਕੋ ਲੰਬਾਈ ਦੀਆਂ ਸਤਰਾਂ. ਇਨਪੁਟ ਸੂਚੀ ਖਾਲੀ ਹੋਣ ਦੀ ਸਥਿਤੀ ਵਿੱਚ NULL ਵਾਪਸ ਕਰੋ.ਸਤਰਾਂ ਦੀ ਸੂਚੀ ਵਿੱਚੋਂ, ਸਭ ਤੋਂ ਲੰਬਾ ਸਤਰ ਵਾਪਸ ਕਰੋ। ਮਲਟੀਪਲ ਸਤਰਾਂ ਦੀ ਸਥਿਤੀ ਵਿੱਚ, ਪਹਿਲਾ ਸਤਰ ਵਾਪਸ ਕਰੋ।# >>> longest(c())\n# NULL\n# >>> longest(c('a', 'b', 'c'))\n# 'a'\n# >>> longest(c('a', 'bb', 'ccc'))\n# 'ccc'\nlongest <- function(strings) {","canonical_solution":"longest <- function(strings) {\n  if (length(strings) == 0) return(NULL)\n  longest_string <- strings[1]\n  for (s in strings) {\n    if (nchar(s) > nchar(longest_string)) {\n      longest_string <- s\n    }\n  }\n  return(longest_string)\n}","tests":"test_humaneval <- function() {\n    candidate <- longest\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'x')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc')), 'zzzz')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_13","nl":"pan_Guru","pl":"r","prompt":"ਦੋ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਸਾਂਝਾ ਭਾਗੀਦਾਰ ਵਾਪਸ ਕਰੋ # >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\ngreatest_common_divisor <- function(a, b) {","canonical_solution":"greatest_common_divisor <- function(a, b) {\n  while (b != 0) {\n    temp <- b\n    b <- a %% b\n    a <- temp\n  }\n  return(abs(a))\n}","tests":"test_humaneval <- function() {\n    candidate <- greatest_common_divisor\n    stopifnot(isTRUE(all.equal(candidate(3, 7), 1)))\n    stopifnot(isTRUE(all.equal(candidate(10, 15), 5)))\n    stopifnot(isTRUE(all.equal(candidate(49, 14), 7)))\n    stopifnot(isTRUE(all.equal(candidate(144, 60), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_14","nl":"pan_Guru","pl":"r","prompt":"ਸਭ ਤੋਂ ਛੋਟੀ ਤੋਂ ਲੰਮੀ ਇੰਪੁੱਟ ਸਤਰ ਦੇ ਸਾਰੇ ਪ੍ਰੀਫਿਕਸ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰੋ # >>> all_prefixes('abc')\n# c('a', 'ab', 'abc')\nall_prefixes <- function(string) {","canonical_solution":"all_prefixes <- function(string) {\n  prefixes <- character(nchar(string))\n  for (i in seq_along(prefixes)) {\n    prefixes[i] <- substr(string, 1, i)\n  }\n  return(prefixes)\n}","tests":"test_humaneval <- function() {\n    candidate <- all_prefixes\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('asdfgh'), c('a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'))))\n    stopifnot(isTRUE(all.equal(candidate('WWW'), c('W', 'WW', 'WWW'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_15","nl":"pan_Guru","pl":"r","prompt":"0 ਤੋਂ ਲੈ ਕੇ n ਤੱਕ ਸਮੇਤ ਸਪੇਸ-ਸੀਮਿਤ ਸੰਖਿਆਵਾਂ ਵਾਲੀ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰੋ।# >>> string_sequence(0)\n# '0'\n# >>> string_sequence(5)\n# '0 1 2 3 4 5'\nstring_sequence <- function(n) {","canonical_solution":"string_sequence <- function(n) {\n  return(paste(0:n, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- string_sequence\n    stopifnot(isTRUE(all.equal(candidate(0), '0')))\n    stopifnot(isTRUE(all.equal(candidate(3), '0 1 2 3')))\n    stopifnot(isTRUE(all.equal(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_16","nl":"pan_Guru","pl":"r","prompt":"ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਪਤਾ ਕਰੋ ਕਿ ਕਿੰਨੇ ਵੱਖਰੇ ਅੱਖਰ (ਕਿਸੇ ਵੀ ਕੇਸ ਦੇ) ਇਸ ਵਿੱਚ ਸ਼ਾਮਲ ਹਨ# >>> count_distinct_characters('xyzXYZ')\n# 3\n# >>> count_distinct_characters('Jerry')\n# 4\ncount_distinct_characters <- function(string) {","canonical_solution":"count_distinct_characters <- function(string) {\n  # Convert the string to lowercase to handle case insensitivity\n  lower_string <- tolower(string)\n  # Split the string into individual characters\n  chars <- strsplit(lower_string, NULL)[[1]]\n  # Find the unique characters and count them\n  distinct_count <- length(unique(chars))\n  return(distinct_count)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_distinct_characters\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))\n    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_17","nl":"pan_Guru","pl":"r","prompt":"'ਛੇਹ' - ਚੌਥਾ ਨੋਟ, ਇੱਕ ਧੜਕਣ ਤੱਕ ਰਹਿੰਦਾ ਹੈ।'ਓ-ਡਿਜ਼ਲ' - ਅੱਧਾ ਨੋਟ, ਦੋ ਧੜਕਣਾਂ ਤੱਕ ਚਲਦਾ ਹੈ।'ਓ' - ਪੂਰਾ ਨੋਟ, ਚਾਰ ਧੜਕਣਾਂ ਤੱਕ ਚਲਦਾ ਹੈ।ਇੱਥੇ ਇੱਕ ਦੰਤਕਥਾ ਹੈਃ ਆਖਰੀ ਨਹੀਂ।ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਸਤਰ ਨੂੰ ਪਾਰਸ ਕਰਨਾ ਹੈ ਅਤੇ ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨਾ ਹੈ ਜੋ ਹਰੇਕ ਨੂੰ ਕਿੰਨੇ ਬੀਟ ਕਰਦਾ ਹੈਇਸ ਫੰਕਸ਼ਨ ਦਾ ਇੰਪੁੱਟ ਇੱਕ ਵਿਸ਼ੇਸ਼ ਏਐਸਸੀਆਈਆਈ ਫਾਰਮੈਟ ਵਿੱਚ ਸੰਗੀਤ ਨੋਟਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)\nparse_music <- function(music_string) {","canonical_solution":"parse_music <- function(music_string) {\n  # Split the input string by spaces to get individual notes\n  notes <- strsplit(music_string, \" \")[[1]]\n  \n  # Map each note to its corresponding beat duration\n  beats <- sapply(notes, function(note) {\n    if (note == 'o') {\n      return(4)\n    } else if (note == 'o|') {\n      return(2)\n    } else if (note == '.|') {\n      return(1)\n    } else {\n      stop(\"Invalid note\")\n    }\n  })\n  \n  return(beats)\n}\n\n# Example usage:\n# parse_music('o o| .| o| o| .| .| .| .| o o')\n# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)","tests":"test_humaneval <- function() {\n    candidate <- parse_music\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('o o o o'), c(4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate('.| .| .| .|'), c(1, 1, 1, 1))))\n    stopifnot(isTRUE(all.equal(candidate('o| o| .| .| o o o o'), c(2, 2, 1, 1, 4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate('o| .| o| .| o o| o o|'), c(2, 1, 2, 1, 4, 2, 4, 2))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_18","nl":"pan_Guru","pl":"r","prompt":"ਪਤਾ ਕਰੋ ਕਿ ਅਸਲ ਸਤਰ ਵਿੱਚ ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਬਸਟ੍ਰਿੰਗ ਕਿੰਨੀ ਵਾਰ ਮਿਲ ਸਕਦੀ ਹੈ। ਓਵਰਲੈਪਿੰਗ ਕੇਸਾਂ ਦੀ ਗਿਣਤੀ ਕਰੋ।# >>> how_many_times('', 'a')\n# 0\n# >>> how_many_times('aaa', 'a')\n# 3\n# >>> how_many_times('aaaa', 'aa')\n# 3\nhow_many_times <- function(string, substring) {","canonical_solution":"how_many_times <- function(string, substring) {\n  if (nchar(substring) == 0) {\n    return(0)\n  }\n  \n  count <- 0\n  for (i in seq(nchar(string) - nchar(substring) + 1)) {\n    if (substr(string, i, i + nchar(substring) - 1) == substring) {\n      count <- count + 1\n    }\n  }\n  \n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- how_many_times\n    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_19","nl":"pan_Guru","pl":"r","prompt":"ਸਭ ਤੋਂ ਛੋਟੀ ਤੋਂ ਵੱਡੀ ਤੱਕ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਗਏ ਨੰਬਰਾਂ ਨਾਲ ਸਤਰ ਵਾਪਸ ਕਰੋਵੈਧ ਚੋਣਾਂ ਹਨ 'ਜ਼ੀਰੋ', 'ਇੱਕ', 'ਦੋ', 'ਤਿੰਨ', 'ਚਾਰ', 'ਪੰਜ', 'ਛੇ', 'ਸੱਤ', 'ਅੱਠ' ਅਤੇ 'ਨੌ'।ਇਨਪੁਟ 'ਜ਼ੀਰੋ' ਤੋਂ 'ਨੌ' ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦੀ ਸਪੇਸ-ਡਿਮਿਨੀਟਿਡ ਸਤਰ ਹੈ।# >>> sort_numbers('three one five')\n# 'one three five'\nsort_numbers <- function(numbers) {","canonical_solution":"sort_numbers <- function(numbers) {\n  words_to_numbers <- c(\n    \"zero\" = 0, \"one\" = 1, \"two\" = 2, \"three\" = 3, \"four\" = 4, \n    \"five\" = 5, \"six\" = 6, \"seven\" = 7, \"eight\" = 8, \"nine\" = 9\n  )\n  \n  number_list <- strsplit(numbers, \" \")[[1]]\n  sorted_numbers <- number_list[order(sapply(number_list, function(word) words_to_numbers[word]))]\n  return(paste(sorted_numbers, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_numbers\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))\n    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))\n    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))\n    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_20","nl":"pan_Guru","pl":"r","prompt":"ਹੋਰ ਅਤੇ ਉਹਨਾਂ ਨੂੰ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰੋ (ਘੱਟ ਗਿਣਤੀ, ਵੱਡੀ ਗਿਣਤੀ).ਨੰਬਰਾਂ ਦੀ ਇੱਕ ਸਪਲਾਈ ਕੀਤੀ ਸੂਚੀ ਵਿੱਚੋਂ (ਲੰਬਾਈ ਵਿੱਚ ਘੱਟੋ ਘੱਟ ਦੋ) ਚੁਣੋ ਅਤੇ ਦੋ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਹਰੇਕ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ ਹਨ # >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n# c(2.0, 2.2)\n# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n# c(2.0, 2.0)\nfind_closest_elements <- function(numbers) {","canonical_solution":"find_closest_elements <- function(numbers) {\n  sorted_numbers <- sort(numbers)\n  min_diff <- Inf\n  closest_pair <- c()\n\n  for (i in 1:(length(sorted_numbers) - 1)) {\n    diff <- sorted_numbers[i + 1] - sorted_numbers[i]\n    if (diff < min_diff) {\n      min_diff <- diff\n      closest_pair <- c(sorted_numbers[i], sorted_numbers[i + 1])\n    }\n  }\n\n  return(closest_pair)\n}","tests":"test_humaneval <- function() {\n    candidate <- find_closest_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_21","nl":"pan_Guru","pl":"r","prompt":"ਇਸ ਤਰ੍ਹਾਂ ਸਭ ਤੋਂ ਛੋਟੀ ਸੰਖਿਆ 0 ਬਣ ਜਾਵੇਗੀ ਅਤੇ ਸਭ ਤੋਂ ਵੱਡੀ 1 ਬਣ ਜਾਵੇਗੀ।ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ (ਘੱਟੋ ਘੱਟ ਦੋ ਤੱਤਾਂ ਦੀ), ਉਸ ਸੂਚੀ ਨੂੰ ਇੱਕ ਲੀਨੀਅਰ ਪਰਿਵਰਤਨ ਲਾਗੂ ਕਰੋ, # >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n# c(0.0, 0.25, 0.5, 0.75, 1.0)\nrescale_to_unit <- function(numbers) {","canonical_solution":"rescale_to_unit <- function(numbers) {\n  min_val <- min(numbers)\n  max_val <- max(numbers)\n  (numbers - min_val) \/ (max_val - min_val)\n}","tests":"test_humaneval <- function() {\n    candidate <- rescale_to_unit\n    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))\n    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_22","nl":"pan_Guru","pl":"r","prompt":"ਕਿਸੇ ਵੀ rthon ਮੁੱਲ ਦੀ ਦਿੱਤੀ ਸੂਚੀ ਨੂੰ ਸਿਰਫ ਪੂਰਨ ਅੰਕ ਲਈ ਫਿਲਟਰ ਕਰੋ# >>> filter_integers(list('a', 3.14, 5))\n# c(5)\n# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))\n# c(1, 2, 3)\nfilter_integers <- function(values) {","canonical_solution":"filter_integers <- function(values) {\n  return(unlist(Filter(is.integer, values)))\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_integers\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))\n    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_23","nl":"pan_Guru","pl":"r","prompt":"ਦਿੱਤੀ ਗਈ ਸਤਰ ਦੀ ਲੰਬਾਈ ਵਾਪਸ ਕਰੋ # >>> strlen('')\n# 0\n# >>> strlen('abc')\n# 3\nstrlen <- function(string) {","canonical_solution":"strlen <- function(string) {\n  return(nchar(string))\n}","tests":"test_humaneval <- function() {\n    candidate <- strlen\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('x'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_24","nl":"pan_Guru","pl":"r","prompt":"ਇੱਕ ਦਿੱਤੇ ਗਏ ਨੰਬਰ n ਲਈ, ਸਭ ਤੋਂ ਵੱਡੀ ਸੰਖਿਆ ਲੱਭੋ ਜੋ n ਨੂੰ ਬਰਾਬਰ ਵੰਡਦੀ ਹੈ, n ਤੋਂ ਛੋਟੀ ਹੈ # >>> largest_divisor(15)\n# 5\nlargest_divisor <- function(n) {","canonical_solution":"largest_divisor <- function(n) {\n  for (i in (n-1):1) {\n    if (n %% i == 0) {\n      return(i)\n    }\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_divisor\n    stopifnot(isTRUE(all.equal(candidate(3), 1)))\n    stopifnot(isTRUE(all.equal(candidate(7), 1)))\n    stopifnot(isTRUE(all.equal(candidate(10), 5)))\n    stopifnot(isTRUE(all.equal(candidate(100), 50)))\n    stopifnot(isTRUE(all.equal(candidate(49), 7)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_25","nl":"pan_Guru","pl":"r","prompt":"ਇੰਪੁੱਟ ਨੰਬਰ ਸਾਰੇ ਕਾਰਕਾਂ ਦੇ ਉਤਪਾਦ ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਹਰੇਕ ਕਾਰਕ ਨੂੰ ਉਸ ਸਮੇਂ ਦੀ ਗਿਣਤੀ ਦੇ ਅਨੁਸਾਰ ਸੂਚੀਬੱਧ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਜਦੋਂ ਉਹ ਕਾਰਕ ਨਿਰਧਾਰਨ ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ।ਦਿੱਤੇ ਗਏ ਪੂਰਨ ਅੰਕ ਦੇ ਪ੍ਰਾਇਮ ਫੈਕਟਰਾਂ ਦੀ ਸੂਚੀ ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਵੱਡੇ ਤੱਕ ਦੇ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰ ਦਿੰਦਾ ਹੈ।# >>> factorize(8)\n# c(2, 2, 2)\n# >>> factorize(25)\n# c(5, 5)\n# >>> factorize(70)\n# c(2, 5, 7)\nfactorize <- function(n) {","canonical_solution":"factorize <- function(n) {\n  if (n < 2) {\n    return(c())\n  }\n  factors <- c()\n  divisor <- 2\n  \n  while (n > 1) {\n    while (n %% divisor == 0) {\n      factors <- c(factors, divisor)\n      n <- n \/ divisor\n    }\n    divisor <- divisor + 1\n  }\n  \n  return(factors)\n}","tests":"test_humaneval <- function() {\n    candidate <- factorize\n    stopifnot(isTRUE(all.equal(candidate(2), c(2))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))\n    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_26","nl":"pan_Guru","pl":"r","prompt":"ਇੰਪੁੱਟ ਵਿੱਚ ਦਿੱਤੇ ਗਏ ਤੱਤਾਂ ਦਾ ਕ੍ਰਮ ਉਸੇ ਤਰ੍ਹਾਂ ਹੀ ਰੱਖੋ।ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਵਿੱਚੋਂ, ਸਾਰੇ ਤੱਤ ਹਟਾਓ ਜੋ ਇੱਕ ਤੋਂ ਵੱਧ ਵਾਰ ਵਾਪਰਦੇ ਹਨ।# >>> remove_duplicates(c(1, 2, 3, 2, 4))\n# c(1, 3, 4)\nremove_duplicates <- function(numbers) {","canonical_solution":"remove_duplicates <- function(numbers) {\n  unique_numbers <- numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]\n  return(unique_numbers)\n}","tests":"test_humaneval <- function() {\n    candidate <- remove_duplicates\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_27","nl":"pan_Guru","pl":"r","prompt":"ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਤਰ ਲਈ, ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਅਤੇ ਵੱਡੇ ਅੱਖਰਾਂ ਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਬਦਲੋ।# >>> flip_case('Hello')\n# 'hELLO'\nflip_case <- function(string) {","canonical_solution":"flip_case <- function(string) {\n  chars <- strsplit(string, NULL)[[1]]\n  flipped_chars <- sapply(chars, function(c) {\n    if (grepl(\"[a-z]\", c)) {\n      return(toupper(c))\n    } else if (grepl(\"[A-Z]\", c)) {\n      return(tolower(c))\n    } else {\n      return(c)\n    }\n  })\n  return(paste(flipped_chars, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- flip_case\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))\n    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_28","nl":"pan_Guru","pl":"r","prompt":"ਸਤਰਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਇੱਕ ਸਤਰ ਵਿੱਚ ਜੋੜਨਾ# >>> concatenate(c())\n# ''\n# >>> concatenate(c('a', 'b', 'c'))\n# 'abc'\nconcatenate <- function(strings) {","canonical_solution":"concatenate <- function(strings) {\n  paste(strings, collapse = \"\")\n}","tests":"test_humaneval <- function() {\n    candidate <- concatenate\n    stopifnot(isTRUE(all.equal(candidate(c()), '')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'xyz')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z', 'w', 'k')), 'xyzwk')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_29","nl":"pan_Guru","pl":"r","prompt":"ਸਤਰਾਂ ਦੀ ਇੱਕ ਇਨਪੁਟ ਸੂਚੀ ਨੂੰ ਸਿਰਫ ਉਹਨਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ ਜੋ ਇੱਕ ਦਿੱਤੇ ਪ੍ਰੀਫਿਕਸ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੇ ਹਨ।# >>> filter_by_prefix(c(), 'a')\n# c()\n# >>> filter_by_prefix(c('abc', 'bcd', 'cde', 'array'), 'a')\n# c('abc', 'array')\nfilter_by_prefix <- function(strings, prefix) {","canonical_solution":"filter_by_prefix <- function(strings, prefix) {\n  return(strings[startsWith(strings, prefix)])\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_by_prefix\n    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_30","nl":"pan_Guru","pl":"r","prompt":"ਸੂਚੀ ਵਿੱਚ ਕੇਵਲ ਸਕਾਰਾਤਮਕ ਸੰਖਿਆਵਾਂ ਹੀ ਵਾਪਸ ਕਰੋ।# >>> get_positive(c(-1, 2, -4, 5, 6))\n# c(2, 5, 6)\n# >>> get_positive(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n# c(5, 3, 2, 3, 9, 123, 1)\nget_positive <- function(l) {","canonical_solution":"get_positive <- function(l) {\n  return(l[l > 0])\n}","tests":"test_humaneval <- function() {\n    candidate <- get_positive\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 4, 5, 6)), c(4, 5, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)), c(5, 3, 2, 3, 3, 9, 123, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2)), c())))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_31","nl":"pan_Guru","pl":"r","prompt":"ਜੇਕਰ ਇੱਕ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ ਪ੍ਰਾਇਮ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਸ ਕਰੋ, ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ।# >>> is_prime(6)\n# FALSE\n# >>> is_prime(101)\n# TRUE\n# >>> is_prime(11)\n# TRUE\n# >>> is_prime(13441)\n# TRUE\n# >>> is_prime(61)\n# TRUE\n# >>> is_prime(4)\n# FALSE\n# >>> is_prime(1)\n# FALSE\nis_prime <- function(n) {","canonical_solution":"is_prime <- function(n) {\n  if (n <= 1) {\n    return(FALSE)\n  }\n  if (n <= 3) {\n    return(TRUE)\n  }\n  if (n %% 2 == 0 || n %% 3 == 0) {\n    return(FALSE)\n  }\n  i <- 5\n  while (i * i <= n) {\n    if (n %% i == 0 || n %% (i + 2) == 0) {\n      return(FALSE)\n    }\n    i <- i + 6\n  }\n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_prime\n    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(101), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(13441), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(61), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(17), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(85), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(77), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(255379), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_33","nl":"pan_Guru","pl":"r","prompt":"l ਦੇ ਅਨੁਸਾਰੀ ਸੂਚਕਾਂਕ ਦੇ ਮੁੱਲਾਂ ਨੂੰ, ਪਰ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ.l' ਇੰਡੈਕਸ ਵਿੱਚ l ਦੇ ਸਮਾਨ ਹੈ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਣ ਯੋਗ ਨਹੀਂ ਹਨ, ਜਦੋਂ ਕਿ ਇਸਦੇ ਮੁੱਲ ਇੰਡੈਕਸ ਵਿੱਚ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਣ ਯੋਗ ਹਨ, ਬਰਾਬਰ ਹਨ ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਸੂਚੀ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਸੂਚੀ l' ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਵੇਂ ਕਿ # >>> sort_third(c(1, 2, 3))\n# c(1, 2, 3)\n# >>> sort_third(c(5, 6, 3, 4, 8, 9, 2))\n# c(2, 6, 3, 4, 8, 9, 5)\nsort_third <- function(l) {","canonical_solution":"sort_third <- function(l) {\n  # Find the indices that are divisible by three\n  indices_div_by_3 <- seq(3, length(l), by = 3)\n  \n  # Extract the elements at those indices and sort them\n  elements_to_sort <- l[indices_div_by_3]\n  sorted_elements <- sort(elements_to_sort)\n  \n  # Replace the original elements at those indices with sorted ones\n  l[indices_div_by_3] <- sorted_elements\n  \n  return(l)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_third\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2)), c(2, 6, 3, 4, 8, 9, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 3, 4, 6, 9, 2)), c(2, 8, 3, 4, 6, 9, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 9, 4, 8, 3, 2)), c(2, 6, 9, 4, 8, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2, 1)), c(2, 6, 3, 4, 8, 9, 5, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_34","nl":"pan_Guru","pl":"r","prompt":"ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਲੜੀਬੱਧ ਵਿਲੱਖਣ ਤੱਤ ਵਾਪਸ ਕਰਦਾ ਹੈ# >>> unique(c(5, 3, 5, 2, 3, 3, 9, 0, 123))\n# c(0, 2, 3, 5, 9, 123)\nunique <- function(l) {","canonical_solution":"unique <- function(l) {\n  return(sort(unique(l)))\n}","tests":"test_humaneval <- function() {\n    candidate <- unique\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 5, 2, 3, 3, 9, 0, 123)), c(0, 2, 3, 5, 9, 123))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_35","nl":"pan_Guru","pl":"r","prompt":"ਸੂਚੀ ਵਿੱਚ ਅਧਿਕਤਮ ਤੱਤ ਵਾਪਸ ਕਰੋ।# >>> max_element(c(1, 2, 3))\n# 3\n# >>> max_element(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n# 123\nmax_element <- function(l) {","canonical_solution":"max_element <- function(l) {\n  return(max(l))\n}","tests":"test_humaneval <- function() {\n    candidate <- max_element\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10)), 124)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_36","nl":"pan_Guru","pl":"r","prompt":"ਅੰਕ 7 ਦੀ ਗਿਣਤੀ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ n ਤੋਂ ਘੱਟ ਪੂਰਨ ਅੰਕ ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ ਜੋ 11 ਜਾਂ 13 ਨਾਲ ਵੰਡਿਆ ਜਾਂਦਾ ਹੈ.# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n# 2\n# >>> fizz_buzz(79)\n# 3\nfizz_buzz <- function(n) {","canonical_solution":"fizz_buzz <- function(n) {\n  count <- 0\n  for (i in 1:(n-1)) {\n    if (i %% 11 == 0 || i %% 13 == 0) {\n      count <- count + sum(unlist(strsplit(as.character(i), \"\")) == \"7\")\n    }\n  }\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- fizz_buzz\n    stopifnot(isTRUE(all.equal(candidate(50), 0)))\n    stopifnot(isTRUE(all.equal(candidate(78), 2)))\n    stopifnot(isTRUE(all.equal(candidate(79), 3)))\n    stopifnot(isTRUE(all.equal(candidate(100), 3)))\n    stopifnot(isTRUE(all.equal(candidate(200), 6)))\n    stopifnot(isTRUE(all.equal(candidate(4000), 192)))\n    stopifnot(isTRUE(all.equal(candidate(10000), 639)))\n    stopifnot(isTRUE(all.equal(candidate(100000), 8026)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_37","nl":"pan_Guru","pl":"r","prompt":"l ਦੇ ਵੀ ਸੂਚਕਾਂਕ ਦੇ ਮੁੱਲਾਂ ਨੂੰ, ਪਰ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ.l' ਅਣਗਿਣਤ ਸੂਚਕਾਂ ਵਿੱਚ l ਦੇ ਸਮਾਨ ਹੈ, ਜਦੋਂ ਕਿ ਇਸ ਦੇ ਮੁੱਲ ਜੋੜੇ ਸੂਚਕਾਂ ਵਿੱਚ ਬਰਾਬਰ ਹਨ ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਸੂਚੀ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਸੂਚੀ l' ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਵੇਂ ਕਿ # >>> sort_even(c(1, 2, 3))\n# c(1, 2, 3)\n# >>> sort_even(c(5, 6, 3, 4))\n# c(3, 6, 5, 4)\nsort_even <- function(l) {","canonical_solution":"sort_even <- function(l) {\n  even_indices <- seq(2, length(l), by=2)\n  l[even_indices] <- sort(l[even_indices])\n  return(l)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_even\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(1, 2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)), c(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, -12, 4, 23, 2, 3, 11, 12, -10)), c(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_39","nl":"pan_Guru","pl":"r","prompt":"prime_fib n-th ਨੰਬਰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਕਿ ਇੱਕ ਫਿਬੋਨੈਕਸੀ ਨੰਬਰ ਹੈ ਅਤੇ ਇਹ ਵੀ ਪ੍ਰਾਇਮਰੀ ਹੈ. # >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\nprime_fib <- function(n) {","canonical_solution":"prime_fib <- function(n) {\n  is_prime <- function(num) {\n    if (num < 2) return(FALSE)\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  fibonacci <- function() {\n    a <- 0\n    b <- 1\n    while (TRUE) {\n      yield <- a + b\n      a <<- b\n      b <<- yield\n      yield\n    }\n  }\n  \n  fib_gen <- fibonacci()\n  count <- 0\n  repeat {\n    current_fib <- fib_gen()\n    if (is_prime(current_fib)) {\n      count <- count + 1\n      if (count == n) return(current_fib)\n    }\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- prime_fib\n    stopifnot(isTRUE(all.equal(candidate(1), 2)))\n    stopifnot(isTRUE(all.equal(candidate(2), 3)))\n    stopifnot(isTRUE(all.equal(candidate(3), 5)))\n    stopifnot(isTRUE(all.equal(candidate(4), 13)))\n    stopifnot(isTRUE(all.equal(candidate(5), 89)))\n    stopifnot(isTRUE(all.equal(candidate(6), 233)))\n    stopifnot(isTRUE(all.equal(candidate(7), 1597)))\n    stopifnot(isTRUE(all.equal(candidate(8), 28657)))\n    stopifnot(isTRUE(all.equal(candidate(9), 514229)))\n    stopifnot(isTRUE(all.equal(candidate(10), 433494437)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_40","nl":"pan_Guru","pl":"r","prompt":"0 ਅਤੇ FALSE ਨਹੀਂ।ਇਹ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸੂਚੀ ਵਿੱਚ ਤਿੰਨ ਵੱਖਰੇ ਤੱਤ ਹਨ ਜੋ triples_sum_to_zero ਇੱਕ ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਲੈਂਦਾ ਹੈ।# >>> triples_sum_to_zero(c(1, 3, 5, 0))\n# FALSE\n# >>> triples_sum_to_zero(c(1, 3, -2, 1))\n# TRUE\n# >>> triples_sum_to_zero(c(1, 2, 3, 7))\n# FALSE\n# >>> triples_sum_to_zero(c(2, 4, -5, 3, 9, 7))\n# TRUE\n# >>> triples_sum_to_zero(c(1))\n# FALSE\ntriples_sum_to_zero <- function(l) {","canonical_solution":"triples_sum_to_zero <- function(l) {\n  n <- length(l)\n  if (n < 3) {\n    return(FALSE)\n  }\n  for (i in 1:(n - 2)) {\n    for (j in (i + 1):(n - 1)) {\n      for (k in (j + 1):n) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return(TRUE)\n        }\n      }\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- triples_sum_to_zero\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 5, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 9, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -100)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 3, 5, -100)), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_41","nl":"pan_Guru","pl":"r","prompt":"ਇਹ ਫੰਕਸ਼ਨ ਅਜਿਹੇ ਟੱਕਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਆਉਟਪੁੱਟ ਦਿੰਦਾ ਹੈ।ਜਿਵੇਂ ਕਿ ਉਹ ਟਕਰਾਅ ਨਾ ਹੋਏ ਹੋਣ।ਹਾਲਾਂਕਿ, ਕਾਰਾਂ ਬੇਅੰਤ ਮਜ਼ਬੂਤ ਅਤੇ ਮਜ਼ਬੂਤ ਹਨ; ਨਤੀਜੇ ਵਜੋਂ, ਉਹ ਚਲਦੇ ਰਹਿੰਦੇ ਹਨ ਜਦੋਂ ਇੱਕ ਕਾਰ ਜੋ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ ਇੱਕ ਕਾਰ ਨੂੰ ਟੱਕਰ ਦਿੰਦੀ ਹੈ ਜੋ ਸੱਜੇ ਤੋਂ ਖੱਬੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ।ਇੱਕ ਦੂਜੇ ਨੂੰ. ਸਾਰੀਆਂ ਕਾਰਾਂ ਇੱਕੋ ਗਤੀ ਨਾਲ ਚਲਦੀਆਂ ਹਨ. ਦੋ ਕਾਰਾਂ ਨੂੰ ਟਕਰਾਉਣ ਲਈ ਕਿਹਾ ਜਾਂਦਾ ਹੈ.ਕਾਰਾਂ ਦੇ ਦੋ ਸੈੱਟ ਸ਼ੁਰੂ ਹੁੰਦੇ ਹਨ ਜੋ ਕਿ ਬਹੁਤ ਦੂਰ ਹੁੰਦੇ ਹਨn ਕਾਰਾਂ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀਆਂ ਹਨ; ਇੱਕੋ ਸਮੇਂ, n ਕਾਰਾਂ ਦਾ ਇੱਕ ਵੱਖਰਾ ਸਮੂਹ ਇੱਕ ਅਜਿਹੀ ਸੜਕ ਦੀ ਕਲਪਨਾ ਕਰੋ ਜੋ ਇੱਕ ਅਨੰਤ ਲੰਬੀ ਸਿੱਧੀ ਲਾਈਨ ਹੋਵੇ।car_race_collision <- function(n) {","canonical_solution":"car_race_collision <- function(n) {\n  # Each car moving left to right will eventually collide with each car moving right to left\n  return(n)\n}","tests":"test_humaneval <- function() {\n    candidate <- car_race_collision\n    stopifnot(isTRUE(all.equal(candidate(2), 4)))\n    stopifnot(isTRUE(all.equal(candidate(3), 9)))\n    stopifnot(isTRUE(all.equal(candidate(4), 16)))\n    stopifnot(isTRUE(all.equal(candidate(8), 64)))\n    stopifnot(isTRUE(all.equal(candidate(10), 100)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_42","nl":"pan_Guru","pl":"r","prompt":"1 ਨਾਲ ਵਧੇ ਹੋਏ ਤੱਤਾਂ ਨਾਲ ਵਾਪਸੀ ਸੂਚੀ।# >>> incr_list(c(1, 2, 3))\n# c(2, 3, 4)\n# >>> incr_list(c(5, 3, 5, 2, 3, 3, 9, 0, 123))\n# c(6, 4, 6, 3, 4, 4, 10, 1, 124)\nincr_list <- function(l) {","canonical_solution":"incr_list <- function(l) {\n  return(l + 1)\n}","tests":"test_humaneval <- function() {\n    candidate <- incr_list\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(4, 3, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 2, 5, 2, 3, 3, 9, 0, 123)), c(6, 3, 6, 3, 4, 4, 10, 1, 124))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_43","nl":"pan_Guru","pl":"r","prompt":"0 ਅਤੇ FALSE ਨਹੀਂ।ਇਹ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸੂਚੀ ਵਿੱਚ ਦੋ ਵੱਖਰੇ ਤੱਤ ਹਨ ਜੋ pairs_sum_to_zero ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਲੈਂਦਾ ਹੈ।# >>> pairs_sum_to_zero(c(1, 3, 5, 0))\n# FALSE\n# >>> pairs_sum_to_zero(c(1, 3, -2, 1))\n# FALSE\n# >>> pairs_sum_to_zero(c(1, 2, 3, 7))\n# FALSE\n# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))\n# TRUE\n# >>> pairs_sum_to_zero(c(1))\n# FALSE\npairs_sum_to_zero <- function(l) {","canonical_solution":"pairs_sum_to_zero <- function(l) {\n  n <- length(l)\n  if (n < 2) return(FALSE)\n  \n  for (i in 1:(n-1)) {\n    for (j in (i+1):n) {\n      if (l[i] + l[j] == 0) {\n        return(TRUE)\n      }\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- pairs_sum_to_zero\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_44","nl":"pan_Guru","pl":"r","prompt":"ਅਧਾਰ ਸੰਖਿਆਵਾਂ 10 ਤੋਂ ਘੱਟ ਹਨ।ਪਰਿਵਰਤਨ ਤੋਂ ਬਾਅਦ ਸਤਰ ਪ੍ਰਤੀਨਿਧਤਾ ਵਾਪਸ ਕਰੋ।ਇਨਪੁਟ ਨੰਬਰ x ਦਾ ਅੰਕੀ ਅਧਾਰ ਨੂੰ ਅਧਾਰ ਵਿੱਚ ਬਦਲੋ।# >>> change_base(8, 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'\nchange_base <- function(x, base) {","canonical_solution":"change_base <- function(x, base) {\n  if (x == 0) return('0')\n  result <- ''\n  while (x > 0) {\n    remainder <- x %% base\n    result <- paste0(remainder, result)\n    x <- x %\/% base\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- change_base\n    stopifnot(isTRUE(all.equal(candidate(8, 3), '22')))\n    stopifnot(isTRUE(all.equal(candidate(9, 3), '100')))\n    stopifnot(isTRUE(all.equal(candidate(234, 2), '11101010')))\n    stopifnot(isTRUE(all.equal(candidate(16, 2), '10000')))\n    stopifnot(isTRUE(all.equal(candidate(8, 2), '1000')))\n    stopifnot(isTRUE(all.equal(candidate(7, 2), '111')))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), '2')))\n    stopifnot(isTRUE(all.equal(candidate(3, 4), '3')))\n    stopifnot(isTRUE(all.equal(candidate(4, 5), '4')))\n    stopifnot(isTRUE(all.equal(candidate(5, 6), '5')))\n    stopifnot(isTRUE(all.equal(candidate(6, 7), '6')))\n    stopifnot(isTRUE(all.equal(candidate(7, 8), '7')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_45","nl":"pan_Guru","pl":"r","prompt":"ਇੱਕ ਤਿਕੋਣ ਲਈ ਇੱਕ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਅਤੇ ਉੱਚ ਵਾਪਸੀ ਖੇਤਰ ਦਿੱਤਾ ਗਿਆ ਹੈ.# >>> triangle_area(5, 3)\n# 7.5\ntriangle_area <- function(a, h) {","canonical_solution":"triangle_area <- function(a, h) {\n  return(0.5 * a * h)\n}","tests":"test_humaneval <- function() {\n    candidate <- triangle_area\n    stopifnot(isTRUE(all.equal(candidate(5, 3), 7.5)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2), 2.0)))\n    stopifnot(isTRUE(all.equal(candidate(10, 8), 40.0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_46","nl":"pan_Guru","pl":"r","prompt":"ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ fib4 ਨੰਬਰ ਸੀਕਵੈਂਸ ਦੇ n-ਵੇਂ ਐਲੀਮੈਂਟ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰੇ। ਰੀਕੌਰਸ਼ਨ ਦੀ ਵਰਤੋਂ ਨਾ ਕਰੋ।fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 Fib4 ਨੰਬਰ ਸੀਕਵੈਂਸ ਫਿਬੋਨੈਕਸੀ ਸੀਕਵੈਂਸ ਵਰਗੀ ਸੀਕਵੈਂਸ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤੀ ਗਈ ਹੈਃ # >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\nfib4 <- function(n) {","canonical_solution":"fib4 <- function(n) {\n  if (n == 0) return(0)\n  if (n == 1) return(0)\n  if (n == 2) return(2)\n  if (n == 3) return(0)\n  \n  fib_seq <- c(0, 0, 2, 0) # Initialize with base cases\n  for (i in 4:n) {\n    fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2] + fib_seq[i-3] + fib_seq[i-4]\n  }\n  return(fib_seq[n])\n}","tests":"test_humaneval <- function() {\n    candidate <- fib4\n    stopifnot(isTRUE(all.equal(candidate(5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(8), 28)))\n    stopifnot(isTRUE(all.equal(candidate(10), 104)))\n    stopifnot(isTRUE(all.equal(candidate(12), 386)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_47","nl":"pan_Guru","pl":"r","prompt":"ਸੂਚੀ ਵਿੱਚ ਤੱਤਾਂ ਦਾ ਵਾਪਸੀ ਦਾ ਮੱਧਮ l. # >>> median(c(3, 1, 2, 4, 5))\n# 3\n# >>> median(c(-10, 4, 6, 1000, 10, 20))\n# 15.0\nmedian <- function(l) {","canonical_solution":"median <- function(l) {\n  return(median(l))\n}","tests":"test_humaneval <- function() {\n    candidate <- median\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10, 4, 6, 1000, 10, 20)), 8.0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 5)), 5.5)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 1, 3, 9, 9, 2, 7)), 7)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_48","nl":"pan_Guru","pl":"r","prompt":"ਜਾਂਚ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸਤਰ ਇੱਕ ਪਾਲੀਂਡਰੋਮ ਹੈ # >>> is_palindrome('')\n# TRUE\n# >>> is_palindrome('aba')\n# TRUE\n# >>> is_palindrome('aaaaa')\n# TRUE\n# >>> is_palindrome('zbcd')\n# FALSE\nis_palindrome <- function(text) {","canonical_solution":"is_palindrome <- function(text) {\n  return(text == paste(rev(unlist(strsplit(text, NULL))), collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- is_palindrome\n    stopifnot(isTRUE(all.equal(candidate(''), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aba'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaa'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('zbcd'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('xywyx'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('xywyz'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('xywzx'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_49","nl":"pan_Guru","pl":"r","prompt":"2^n ਮਾਡੂਲੋ ਪੀ ਵਾਪਸ ਕਰੋ (ਅੰਕਾਂ ਨੂੰ ਧਿਆਨ ਵਿੱਚ ਰੱਖੋ) ।# >>> modp(3, 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100, 101)\n# 1\nmodp <- function(n, p) {","canonical_solution":"modp <- function(n, p) {\n  result <- 1\n  base <- 2\n  \n  while (n > 0) {\n    if (n %% 2 == 1) {\n      result <- (result * base) %% p\n    }\n    base <- (base * base) %% p\n    n <- n %\/% 2\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- modp\n    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))\n    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))\n    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))\n    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))\n    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))\n    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_51","nl":"pan_Guru","pl":"r","prompt":"remove_vowels ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਤਰ ਨੂੰ ਬਿਨਾਂ ਵੋਕਲ ਦੇ ਵਾਪਸ ਕਰਦਾ ਹੈ. # >>> remove_vowels('')\n# ''\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\nremove_vowels <- function(text) {","canonical_solution":"remove_vowels <- function(text) {\n  gsub(\"[aeiouAEIOU]\", \"\", text)\n}","tests":"test_humaneval <- function() {\n    candidate <- remove_vowels\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('abcdef\\nghijklm'), 'bcdf\\nghjklm')))\n    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))\n    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))\n    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))\n    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))\n    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_52","nl":"pan_Guru","pl":"r","prompt":"TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸੂਚੀ l ਦੇ ਸਾਰੇ ਨੰਬਰ ਥ੍ਰੈਸ਼ਹੋਲਡ t ਤੋਂ ਹੇਠਾਂ ਹਨ।# >>> below_threshold(c(1, 2, 4, 10), 100)\n# TRUE\n# >>> below_threshold(c(1, 20, 4, 10), 5)\n# FALSE\nbelow_threshold <- function(l, t) {","canonical_solution":"below_threshold <- function(l, t) {\n  return(all(l < t))\n}","tests":"test_humaneval <- function() {\n    candidate <- below_threshold\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_53","nl":"pan_Guru","pl":"r","prompt":"ਦੋ ਨੰਬਰ x ਅਤੇ y ਜੋੜੋ # >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\nadd <- function(x, y) {","canonical_solution":"add <- function(x, y) {\n  return(x + y)\n}","tests":"test_humaneval <- function() {\n    candidate <- add\n    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))\n    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))\n    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_54","nl":"pan_Guru","pl":"r","prompt":"ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਦੋ ਸ਼ਬਦਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੇ ਅੱਖਰ ਹਨ।# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# TRUE\n# >>> same_chars('abcd', 'dddddddabc')\n# TRUE\n# >>> same_chars('dddddddabc', 'abcd')\n# TRUE\n# >>> same_chars('eabcd', 'dddddddabc')\n# FALSE\n# >>> same_chars('abcd', 'dddddddabce')\n# FALSE\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# FALSE\nsame_chars <- function(s0, s1) {","canonical_solution":"same_chars <- function(s0, s1) {\n  return(identical(sort(unique(unlist(strsplit(s0, \"\")))), sort(unique(unlist(strsplit(s1, \"\"))))))\n}","tests":"test_humaneval <- function() {\n    candidate <- same_chars\n    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_55","nl":"pan_Guru","pl":"r","prompt":"n-th ਫਿਬੋਨੈਕਸੀ ਨੰਬਰ ਵਾਪਸ ਕਰੋ।# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\nfib <- function(n) {","canonical_solution":"fib <- function(n) {\n  if (n <= 1) {\n    return(n)\n  }\n  a <- 0\n  b <- 1\n  for (i in 2:n) {\n    temp <- b\n    b <- a + b\n    a <- temp\n  }\n  return(b)\n}","tests":"test_humaneval <- function() {\n    candidate <- fib\n    stopifnot(isTRUE(all.equal(candidate(10), 55)))\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(8), 21)))\n    stopifnot(isTRUE(all.equal(candidate(11), 89)))\n    stopifnot(isTRUE(all.equal(candidate(12), 144)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_56","nl":"pan_Guru","pl":"r","prompt":"TRUE ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਹਰੇਕ ਖੁੱਲਣ ਵਾਲੇ ਬਰੈਕਟ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬੰਦ ਕਰਨ ਵਾਲੇ ਬਰੈਕਟ ਹੋਵੇ।ਬਰੈਕਟ \"<\" ਅਤੇ \">\" ਦੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> correct_bracketing('<')\n# FALSE\n# >>> correct_bracketing('<>')\n# TRUE\n# >>> correct_bracketing('<<><>>')\n# TRUE\n# >>> correct_bracketing('><<>')\n# FALSE\ncorrect_bracketing <- function(brackets) {","canonical_solution":"correct_bracketing <- function(brackets) {\n  count <- 0\n  for (char in strsplit(brackets, NULL)[[1]]) {\n    if (char == \"<\") {\n      count <- count + 1\n    } else if (char == \">\") {\n      count <- count - 1\n    }\n    if (count < 0) {\n      return(FALSE)\n    }\n  }\n  return(count == 0)\n}","tests":"test_humaneval <- function() {\n    candidate <- correct_bracketing\n    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_57","nl":"pan_Guru","pl":"r","prompt":"TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇ ਸੂਚੀ ਦੇ ਤੱਤ ਇਕਸਾਰਤਾ ਨਾਲ ਵੱਧ ਰਹੇ ਹਨ ਜਾਂ ਘਟ ਰਹੇ ਹਨ।# >>> monotonic(c(1, 2, 4, 20))\n# TRUE\n# >>> monotonic(c(1, 20, 4, 10))\n# FALSE\n# >>> monotonic(c(4, 1, 0, -10))\n# TRUE\nmonotonic <- function(l) {","canonical_solution":"monotonic <- function(l) {\n  is_increasing <- all(diff(l) >= 0)\n  is_decreasing <- all(diff(l) <= 0)\n  return(is_increasing || is_decreasing)\n}","tests":"test_humaneval <- function() {\n    candidate <- monotonic\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_58","nl":"pan_Guru","pl":"r","prompt":"ਦੋ ਸੂਚੀਆਂ ਲਈ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਅਨੋਖੇ ਸਾਂਝੇ ਤੱਤ ਵਾਪਸ ਕਰੋ.# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# c(1, 5, 653)\n# >>> common(c(5, 3, 2, 8), c(3, 2))\n# c(2, 3)\ncommon <- function(l1, l2) {","canonical_solution":"common <- function(l1, l2) {\n  common_elements <- intersect(l1, l2)\n  sorted_unique_common <- sort(unique(common_elements))\n  return(sorted_unique_common)\n}","tests":"test_humaneval <- function() {\n    candidate <- common\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_59","nl":"pan_Guru","pl":"r","prompt":"n ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਇਮ ਫੈਕਟਰ ਵਾਪਸ ਕਰੋ. ਮੰਨ ਲਓ ਕਿ n > 1 ਹੈ ਅਤੇ ਪ੍ਰਾਇਮ ਨਹੀਂ ਹੈ। # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\nlargest_prime_factor <- function(n) {","canonical_solution":"largest_prime_factor <- function(n) {\n  # Initialize the largest prime factor\n  largest_prime <- -1\n  \n  # Remove factors of 2\n  while (n %% 2 == 0) {\n    largest_prime <- 2\n    n <- n \/ 2\n  }\n  \n  # Try odd factors from 3 upwards\n  factor <- 3\n  while (factor * factor <= n) {\n    while (n %% factor == 0) {\n      largest_prime <- factor\n      n <- n \/ factor\n    }\n    factor <- factor + 2\n  }\n  \n  # If n is a prime number greater than 2\n  if (n > 2) {\n    largest_prime <- n\n  }\n  \n  # Return the largest prime factor found\n  return(largest_prime)\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_prime_factor\n    stopifnot(isTRUE(all.equal(candidate(15), 5)))\n    stopifnot(isTRUE(all.equal(candidate(27), 3)))\n    stopifnot(isTRUE(all.equal(candidate(63), 7)))\n    stopifnot(isTRUE(all.equal(candidate(330), 11)))\n    stopifnot(isTRUE(all.equal(candidate(13195), 29)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_60","nl":"pan_Guru","pl":"r","prompt":"sum_to_n ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ 1 ਤੋਂ n ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ ਕਰਦਾ ਹੈ।# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\nsum_to_n <- function(n) {","canonical_solution":"sum_to_n <- function(n) {\n  return(sum(1:n))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_to_n\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(6), 21)))\n    stopifnot(isTRUE(all.equal(candidate(11), 66)))\n    stopifnot(isTRUE(all.equal(candidate(30), 465)))\n    stopifnot(isTRUE(all.equal(candidate(100), 5050)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_61","nl":"pan_Guru","pl":"r","prompt":"TRUE ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਹਰੇਕ ਖੁੱਲਣ ਵਾਲੇ ਬਰੈਕਟ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬੰਦ ਕਰਨ ਵਾਲੇ ਬਰੈਕਟ ਹੋਵੇ।ਬਰੈਕਟ \"(\" ਅਤੇ \"\") ਦੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> correct_bracketing('(')\n# FALSE\n# >>> correct_bracketing('()')\n# TRUE\n# >>> correct_bracketing('(()())')\n# TRUE\n# >>> correct_bracketing(')(()')\n# FALSE\ncorrect_bracketing <- function(brackets) {","canonical_solution":"correct_bracketing <- function(brackets) {\n  balance <- 0\n  for (char in strsplit(brackets, NULL)[[1]]) {\n    if (char == \"(\") {\n      balance <- balance + 1\n    } else if (char == \")\") {\n      balance <- balance - 1\n    }\n    if (balance < 0) {\n      return(FALSE)\n    }\n  }\n  return(balance == 0)\n}","tests":"test_humaneval <- function() {\n    candidate <- correct_bracketing\n    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_62","nl":"pan_Guru","pl":"r","prompt":"ਇਸ ਬਹੁ-ਅੰਕ ਦਾ ਉਸੇ ਰੂਪ ਵਿੱਚ ਡੈਰੀਵੇਟਿਵ ਵਾਪਸ ਕਰੋ.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs ਇੱਕ ਬਹੁ-ਅੰਕ ਦੇ ਗੁਣਾਂਕ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।# >>> derivative(c(3, 1, 2, 4, 5))\n# c(1, 4, 12, 20)\n# >>> derivative(c(1, 2, 3))\n# c(2, 6)\nderivative <- function(xs) {","canonical_solution":"derivative <- function(xs) {\n  n <- length(xs)\n  if (n <= 1) return(numeric(0))  # Derivative of a constant is zero\n  \n  deriv <- numeric(n - 1)\n  for (i in 2:n) {\n    deriv[i - 1] <- xs[i] * (i - 1)\n  }\n  return(deriv)\n}","tests":"test_humaneval <- function() {\n    candidate <- derivative\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), c(1, 4, 12, 20))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1, 0, 4)), c(2, 2, 0, 16))))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_63","nl":"pan_Guru","pl":"r","prompt":"ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਕਿ ਫਿਬਫਿਬ ਨੰਬਰ ਸੀਕਵੈਂਸ ਦੇ n-ਵੇਂ ਐਲੀਮੈਂਟ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰੇ।ਫਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਫਿਬਫਿਬ ਨੰਬਰ ਸੀਕਵੈਂਸ ਫਿਬੋਨੈਕਸੀ ਸੀਕਵੈਂਸ ਵਰਗੀ ਇਕ ਸੀਕਵੈਂਸ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤੀ ਗਈ ਹੈਃ # >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\nfibfib <- function(n) {","canonical_solution":"fibfib <- function(n) {\n  # Base cases\n  if (n == 0) return(0)\n  if (n == 1) return(0)\n  if (n == 2) return(1)\n\n  # Initialize the first three values\n  fibfib_values <- c(0, 0, 1)\n  \n  # Compute fibfib for the rest using iteration\n  for (i in 3:n) {\n    fibfib_values[i + 1] <- fibfib_values[i] + fibfib_values[i - 1] + fibfib_values[i - 2]\n  }\n  # Return the nth value\n  return(fibfib_values[n + 1])\n}","tests":"test_humaneval <- function() {\n    candidate <- fibfib\n    stopifnot(isTRUE(all.equal(candidate(2), 1)))\n    stopifnot(isTRUE(all.equal(candidate(1), 0)))\n    stopifnot(isTRUE(all.equal(candidate(5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(8), 24)))\n    stopifnot(isTRUE(all.equal(candidate(10), 81)))\n    stopifnot(isTRUE(all.equal(candidate(12), 274)))\n    stopifnot(isTRUE(all.equal(candidate(14), 927)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_64","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਵੋਕਲ, ਪਰ ਕੇਵਲ ਉਦੋਂ ਜਦੋਂ ਇਹ ਦਿੱਤੇ ਗਏ ਸ਼ਬਦ ਦੇ ਅੰਤ ਵਿੱਚ ਹੋਵੇ।ਇਸ ਮਾਮਲੇ ਵਿੱਚ ਧੁਨੀ 'a', 'e', 'i', 'o', 'u' ਹਨ। ਇੱਥੇ, 'y' ਵੀ ਇੱਕ ਹੈ।ਇੱਕ ਸ਼ਬਦ ਨੂੰ ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਅਤੇ ਸਤਰ ਵਿੱਚ ਵੋਕਲ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ# >>> vowels_count('abcde')\n# 2\n# >>> vowels_count('ACEDY')\n# 3\nvowels_count <- function(s) {","canonical_solution":"vowels_count <- function(s) {\n  s <- tolower(s)\n  n <- nchar(s)\n  count <- sum(unlist(strsplit(s, NULL)) %in% c('a', 'e', 'i', 'o', 'u'))\n  if (n > 0 && substr(s, n, n) == 'y') {\n    count <- count + 1\n  }\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- vowels_count\n    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))\n    stopifnot(isTRUE(all.equal(candidate('key'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_65","nl":"pan_Guru","pl":"r","prompt":"ਜੇ ਸ਼ਿਫਟ > ਅੰਕ ਦੀ ਗਿਣਤੀ, ਰਿਟਰਨ ਅੰਕ ਉਲਟ. ਅਤੇ ਨਤੀਜਾ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰ ਦਿੰਦਾ ਹੈ।ਸਰਕੂਲਰ ਪੂਰਨ ਅੰਕ x ਦੇ ਅੰਕ ਨੂੰ ਹਿਲਾਓ, ਹਿਲਾਓ ਦੇ ਕੇ ਅੰਕ ਨੂੰ ਸੱਜੇ ਪਾਸੇ ਹਿਲਾਓ # >>> circular_shift(12, 1)\n# '21'\n# >>> circular_shift(12, 2)\n# '12'\ncircular_shift <- function(x, shift) {","canonical_solution":"circular_shift <- function(x, shift) {\n  digits <- as.character(x)\n  n <- nchar(digits)\n  \n  if (shift > n) {\n    return(paste0(rev(unlist(strsplit(digits, \"\"))), collapse = \"\"))\n  }\n  \n  shift <- shift %% n\n  if (shift == 0) {\n    return(digits)\n  }\n  \n  right_part <- substr(digits, n - shift + 1, n)\n  left_part <- substr(digits, 1, n - shift)\n  result <- paste0(right_part, left_part)\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- circular_shift\n    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))\n    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))\n    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))\n    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))\n    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_66","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਏਐੱਸਸੀਆਈਆਈ ਕੋਡਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਿਰਫ ਉਪਰਲੇ ਅੱਖਰਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਦਾ ਹੈ' ਕੰਮ # >>> digitSum('')\n# 0\n# >>> digitSum('abAB')\n# 131\n# >>> digitSum('abcCd')\n# 67\n# >>> digitSum('helloE')\n# 69\n# >>> digitSum('woArBld')\n# 131\n# >>> digitSum('aAaaaXa')\n# 153\ndigitSum <- function(s) {","canonical_solution":"digitSum <- function(s) {\n  sum(sapply(unlist(strsplit(s, \"\")), function(x) {\n    if (grepl(\"[A-Z]\", x)) {\n      return(as.integer(charToRaw(x)))\n    } else {\n      return(0)\n    }\n  }))\n}","tests":"test_humaneval <- function() {\n    candidate <- digitSum\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('abAB'), 131)))\n    stopifnot(isTRUE(all.equal(candidate('abcCd'), 67)))\n    stopifnot(isTRUE(all.equal(candidate('helloE'), 69)))\n    stopifnot(isTRUE(all.equal(candidate('woArBld'), 131)))\n    stopifnot(isTRUE(all.equal(candidate('aAaaaXa'), 153)))\n    stopifnot(isTRUE(all.equal(candidate(' How are yOu?'), 151)))\n    stopifnot(isTRUE(all.equal(candidate('You arE Very Smart'), 327)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_67","nl":"pan_Guru","pl":"r","prompt":"ਲਈ ਐਕਸਾਮਬਲਃ ਟੋਕਰੀ ਵਿੱਚ ਟੋਕਰੀ ਵਿੱਚ ਅੰਬ ਦੇ ਫਲਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ।ਸੰਤਰੇ ਅਤੇ ਸੇਬ ਅਤੇ ਇੱਕ ਪੂਰਨ ਅੰਕ ਜੋ ਫਲ ਦੀ ਕੁੱਲ ਸੰਖਿਆ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ ਸੇਬ, ਸੰਤਰੇ ਅਤੇ ਅੰਬ ਦੇ ਫਲ ਦਿੱਤੇ ਗਏ ਸਤਰ ਜੋ ਕਿ  ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈਜੋ ਕਿ ਇੱਕ ਟੋਕਰੀ ਵਿੱਚ ਵੰਡਿਆ ਜਾਂਦਾ ਹੈ ਇਸ ਟੋਕਰੀ ਵਿੱਚ ਫਲਾਂ ਦੀ ਟੋਕਰੀ ਹੁੰਦੀ ਹੈ ਇਸ ਕੰਮ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ ਜੋ ਕਿ ਸੇਬ ਅਤੇ ਸੰਤਰੇ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ।# >>> fruit_distribution('5 apples and 6 oranges', 19)\n# 8\n# >>> fruit_distribution('0 apples and 1 oranges', 3)\n# 2\n# >>> fruit_distribution('2 apples and 3 oranges', 100)\n# 95\n# >>> fruit_distribution('100 apples and 1 oranges', 120)\n# 19\nfruit_distribution <- function(s, n) {","canonical_solution":"fruit_distribution <- function(s, n) {\n  # Extract numbers using regular expressions\n  matches <- regmatches(s, gregexpr(\"\\\\d+\", s))\n  # Convert extracted number strings to integers\n  fruits_count <- as.integer(unlist(matches))\n  # Total fruits described in the string\n  total_apples_oranges <- sum(fruits_count)\n  # Calculate mangoes\n  mangoes <- n - total_apples_oranges\n  return(mangoes)\n}","tests":"test_humaneval <- function() {\n    candidate <- fruit_distribution\n    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))\n    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))\n    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))\n    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))\n    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))\n    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))\n    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_68","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ 1: ਜੇ ਕੋਈ ਵੀ ਮੁੱਲ ਨਹੀਂ ਹਨ ਜਾਂ ਦਿੱਤਾ ਗਿਆ ਵੈਕਟਰ ਖਾਲੀ ਹੈ, ਵਾਪਸ ਕਰੋ [].ਚੁਣਿਆ ਗਿਆ ਨੋਡ ਨੂੰ ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਵਾਪਸ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ, [ smalest_value, ਇਸ ਦਾ ਇੰਡੈਕਸ ], ਜੇਕਰ ਇੱਕੋ ਜਿਹੇ ਸਭ ਤੋਂ ਛੋਟੇ ਬਰਾਬਰ ਮੁੱਲ ਵਾਲੇ ਕਈ ਨੋਡ ਮਿਲਦੇ ਹਨ ਤਾਂ ਨੋਡ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜਿਸਦਾ ਸਭ ਤੋਂ ਛੋਟਾ ਇੰਡੈਕਸ ਹੈ।ਚੁਣਿਆ ਗਿਆ ਨੋਡ ਸਭ ਤੋਂ ਛੋਟਾ ਜੋੜਾ ਮੁੱਲ ਵਾਲਾ ਨੋਡ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।ਤੁਹਾਡਾ ਕੰਮ ਨੋਡਾਂ ਵਿੱਚੋਂ ਇੱਕ ਨੂੰ ਕੱਢਣਾ ਅਤੇ ਇਸਨੂੰ ਵਾਪਸ ਕਰਨਾ ਹੈ।\"ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ ਜੋ ਇੱਕ ਰੁੱਖ ਦੀ ਇੱਕ ਸ਼ਾਖਾ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨੋਡ ਹਨ # >>> pluck(c(4, 2, 3))\n# c(2, 1)\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck(c(1, 2, 3))\n# c(2, 1)\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck(c())\n# c()\n# Example 4:\n# >>> pluck(c(5, 0, 3, 0, 4, 2))\n# c(0, 1)\n# Explanation: 0 is the smallest value, but  there are two zeros,\n#              so we will choose the first zero, which has the smallest index.\n# Constraints:\n#     * 1 <= nodes.length <= 10000\n#     * 0 <= node.value\npluck <- function(arr) {","canonical_solution":"pluck <- function(arr) {\n  # Find indices for even numbers in the array\n  even_indices <- which(arr %% 2 == 0)\n  \n  # If no even numbers are found, return an empty list\n  if (length(even_indices) == 0) {\n    return(c())\n  }\n  \n  # Extract even numbers\n  even_values <- arr[even_indices]\n  \n  # Find the smallest even value\n  min_even_value <- min(even_values)\n  \n  # Find the index of the first occurrence of the smallest even value\n  min_index <- even_indices[which.min(even_values)]\n  \n  # Return the smallest even value and its index (0-based index)\n  return(c(min_even_value, min_index - 1))\n}","tests":"test_humaneval <- function() {\n    candidate <- pluck\n    stopifnot(isTRUE(all.equal(candidate(c(4, 2, 3)), c(2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 0, 3, 0, 4, 2)), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 0, 5, 3)), c(0, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 8, 4, 8)), c(4, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 6, 7, 1)), c(6, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 7, 1)), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_69","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਜੇ ਅਜਿਹਾ ਕੋਈ ਮੁੱਲ ਮੌਜੂਦ ਨਹੀਂ ਹੈ, ਤਾਂ -1 ਵਾਪਸ ਕਰੋ।ਇੱਕ ਪੂਰਨ ਅੰਕ ਦੀ ਬਾਰੰਬਾਰਤਾ ਸੂਚੀ ਵਿੱਚ ਇਸ ਦੇ ਪ੍ਰਗਟ ਹੋਣ ਦੀ ਸੰਖਿਆ ਹੈ।ਜ਼ੀਰੋ ਹੈ, ਅਤੇ ਇਸ ਦੀ ਬਾਰੰਬਾਰਤਾ ਪੂਰਨ ਅੰਕ ਦੇ ਮੁੱਲ ਤੋਂ ਵੱਧ ਜਾਂ ਬਰਾਬਰ ਹੈ।ਤੁਹਾਨੂੰ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ. ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ ਵਾਪਸ ਕਰੋ ਜੋ  ਤੋਂ ਵੱਡਾ ਹੈ# >>> search(c(4, 1, 2, 2, 3, 1))\n# 2\n# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))\n# 3\n# >>> search(c(5, 5, 4, 4, 4))\n# -1\nsearch <- function(lst) {","canonical_solution":"search <- function(lst) {\n  # Calculate the frequency table\n  freq_table <- table(lst)\n  \n  # Convert to a data frame for easier processing\n  freq_df <- as.data.frame(freq_table)\n  \n  # Rename columns for convenience\n  names(freq_df) <- c(\"value\", \"frequency\")\n  \n  # Filter the values where the frequency is greater than or equal to the value itself\n  valid_values <- freq_df[freq_df$value <= freq_df$frequency, \"value\"]\n  \n  # If no valid values exist, return -1\n  if (length(valid_values) == 0) {\n    return(-1)\n  }\n  \n  # Otherwise, return the greatest valid value\n  return(max(valid_values))\n}","tests":"test_humaneval <- function() {\n    candidate <- search\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_70","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਫਿਰ ਬਾਕੀ ਪੂਰਨ ਅੰਕ ਦਾ ਅਧਿਕਤਮ, ਫਿਰ ਘੱਟੋ ਘੱਟ ਅਤੇ ਇਸ ਤਰ੍ਹਾਂ ਜਾਰੀ ਹੈ।ਅਜੀਬ ਤਰਤੀਬ, ਜਦੋਂ ਤੁਸੀਂ ਘੱਟੋ ਘੱਟ ਮੁੱਲ ਨਾਲ ਸ਼ੁਰੂ ਕਰਦੇ ਹੋ, ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ, ਅਜੀਬ ਕ੍ਰਮ ਵਿੱਚ ਸੂਚੀ ਵਾਪਸ ਕਰੋ.# >>> strange_sort_list(c(1, 2, 3, 4))\n# c(1, 4, 2, 3)\n# >>> strange_sort_list(c(5, 5, 5, 5))\n# c(5, 5, 5, 5)\n# >>> strange_sort_list(c())\n# c()\nstrange_sort_list <- function(lst) {","canonical_solution":"strange_sort_list <- function(lst) {\n  result <- c()\n  while (length(lst) > 0) {\n    # Find and append the minimum of the list\n    min_val <- min(lst)\n    result <- c(result, min_val)\n    lst <- lst[lst != min_val]\n    \n    # Check if list is not empty before finding maximum\n    if (length(lst) > 0) {\n      # Find and append the maximum of the list\n      max_val <- max(lst)\n      result <- c(result, max_val)\n      lst <- lst[lst != max_val]\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- strange_sort_list\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 4, 2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9)), c(5, 9, 6, 8, 7))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), c(1, 5, 2, 4, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9, 1)), c(1, 9, 5, 8, 6, 7))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5)), c(5, 5, 5, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8)), c(1, 8, 2, 7, 3, 6, 4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 2, 2, 2, 5, 5, -5, -5)), c(-5, 5, -5, 5, 0, 2, 2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(111111)), c(111111))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_71","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਤੀਜੇ ਪਾਸੇ ਤੋਂ ਵੱਧ.ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਜਾਇਜ਼ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ ਜਦੋਂ ਕਿਸੇ ਵੀ ਦੋ ਪਾਸਿਆਂ ਦਾ ਜੋੜ ਵੱਡਾ ਹੁੰਦਾ ਹੈ।ਨਹੀਂ ਤਾਂ ਵਾਪਸੀ -1 ਤਿਕੋਣ ਨੂੰ 2 ਦਸ਼ਮਲਵ ਬਿੰਦੂਆਂ ਤੱਕ ਗੋਲ ਕੀਤਾ ਜਾਂਦਾ ਹੈ ਜੇ ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਪ੍ਰਮਾਣਿਕ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ।ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ.  ਦਾ ਖੇਤਰ ਵਾਪਸ ਕਰੋ# >>> triangle_area(3, 4, 5)\n# 6.0\n# >>> triangle_area(1, 2, 10)\n# -1\ntriangle_area <- function(a, b, c) {","canonical_solution":"triangle_area <- function(a, b, c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    # Using Heron's formula\n    s <- (a + b + c) \/ 2\n    area <- sqrt(s * (s - a) * (s - b) * (s - c))\n    return(round(area, 2))\n  } else {\n    return(-1)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- triangle_area\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))\n    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))\n    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))\n    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_72","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਵਸਤੂ q ਉੱਡ ਜਾਵੇਗੀ ਜੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ (ਇਹ ਇੱਕ ਪਾਲੀਂਡਰੋਮਿਕ ਸੂਚੀ ਹੈ) ਅਤੇ ਇਸਦੇ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ w ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਵਸਤੂ q ਉਡਦੀ ਹੈ, ਅਤੇ FALSE ਨਹੀਂ ਤਾਂ. # >>> will_it_fly(c(1, 2), 5)\n# FALSE\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly(c(3, 2, 3), 1)\n# FALSE\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly(c(3, 2, 3), 9)\n# TRUE\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly(c(3), 5)\n# TRUE\n# # 3 is less than the maximum possible weight, and it's balanced.\nwill_it_fly <- function(q, w) {","canonical_solution":"will_it_fly <- function(q, w) {\n  is_palindromic <- function(lst) {\n    return(all(lst == rev(lst)))\n  }\n  \n  is_balanced <- is_palindromic(q)\n  sum_elements <- sum(q)\n  \n  return(is_balanced && (sum_elements <= w))\n}","tests":"test_humaneval <- function() {\n    candidate <- will_it_fly\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_73","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਇੱਕ ਤਬਦੀਲੀ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਤੱਤ ਨੂੰ ਕਿਸੇ ਹੋਰ ਤੱਤ ਵਿੱਚ ਬਦਲ ਸਕਦੇ ਹੋ।ਵੈਕਟਰ ਨੂੰ ਪਾਲੀਂਡਰੋਮਿਕ ਬਣਾਉਣ ਲਈ ਬਦਲਣ ਦੀ ਜ਼ਰੂਰਤ ਹੈ. ਇੱਕ ਪਾਲੀਂਡਰੋਮਿਕ ਵੈਕਟਰ ਇੱਕ ਵੈਕਟਰ ਹੈ ਜੋ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੱਤ ਦੀ ਘੱਟੋ ਘੱਟ ਗਿਣਤੀ ਲੱਭੋ ਜੋ ਕਿ # >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))\n# 4\n# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))\n# 1\n# >>> smallest_change(c(1, 2, 3, 2, 1))\n# 0\nsmallest_change <- function(arr) {","canonical_solution":"smallest_change <- function(arr) {\n  n <- length(arr)\n  changes <- 0\n  \n  for (i in 1:(n %\/% 2)) {\n    if (arr[i] != arr[n - i + 1]) {\n      changes <- changes + 1\n    }\n  }\n  \n  return(changes)\n}","tests":"test_humaneval <- function() {\n    candidate <- smallest_change\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_74","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਜੇ ਦੋ ਸੂਚੀਆਂ ਵਿੱਚ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਇੱਕੋ ਜਿਹੀ ਹੈ, ਤਾਂ ਪਹਿਲੀ ਸੂਚੀ ਵਾਪਸ ਕਰੋ।ਸੂਚੀ ਦੇ ਸਾਰੇ ਸਤਰਾਂ ਵਿੱਚ ਚਾਰਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਦੂਜੀ ਸੂਚੀ ਨਾਲੋਂ ਘੱਟ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੀਆਂ ਦੋ ਸੂਚੀਆਂ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ ਅਤੇ ਉਸ ਸੂਚੀ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ # >>> total_match(c(), c())\n# c()\n# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))\n# c('hI', 'Hi')\n# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))\n# c('hi', 'admin')\n# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))\n# c('hI', 'hi', 'hi')\n# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))\n# c('4')\ntotal_match <- function(lst1, lst2) {","canonical_solution":"total_match <- function(lst1, lst2) {\n  chars_count <- function(lst) {\n    sum(nchar(lst))\n  }\n  \n  count1 <- chars_count(lst1)\n  count2 <- chars_count(lst2)\n  \n  if (count1 < count2) {\n    return(lst1)\n  } else if (count1 > count2) {\n    return(lst2)\n  } else {\n    return(lst1)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- total_match\n    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))\n    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))\n    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_75","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਇਹ ਜਾਣ ਕੇ ਕਿ (a) 100 ਤੋਂ ਘੱਟ ਹੈ।ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇਕਰ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ 3 ਪ੍ਰਾਇਮ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ# >>> is_multiply_prime(30)\n# TRUE\n# 30 = 2 * 3 * 5\nis_multiply_prime <- function(a) {","canonical_solution":"is_multiply_prime <- function(a) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n <= 3) return(TRUE)\n    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)\n    i <- 5\n    while (i * i <= n) {\n      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)\n      i <- i + 6\n    }\n    return(TRUE)\n  }\n\n  if (a >= 100) return(FALSE)\n  \n  primes <- c()\n  for (i in 2:a) {\n    if (is_prime(i)) {\n      primes <- c(primes, i)\n    }\n  }\n  \n  for (i in 1:length(primes)) {\n    for (j in i:length(primes)) {\n      for (k in j:length(primes)) {\n        if (primes[i] * primes[j] * primes[k] == a) {\n          return(TRUE)\n        }\n      }\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_multiply_prime\n    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_76","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: x n ਦੀ ਇੱਕ ਸਧਾਰਨ ਸ਼ਕਤੀ ਹੈ ਜੇਕਰ n**int=x n ਦੀ ਸ਼ਕਤੀ ਅਤੇ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਗਲਤ ਹੈ।ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇਕਰ ਇੱਕ ਨੰਬਰ x ਇੱਕ ਸਧਾਰਨ ਹੈ # >>> is_simple_power(1, 4)\n# TRUE\n# >>> is_simple_power(2, 2)\n# TRUE\n# >>> is_simple_power(8, 2)\n# TRUE\n# >>> is_simple_power(3, 2)\n# FALSE\n# >>> is_simple_power(3, 1)\n# FALSE\n# >>> is_simple_power(5, 3)\n# FALSE\nis_simple_power <- function(x, n) {","canonical_solution":"is_simple_power <- function(x, n) {\n  if (x == 1) return(TRUE)\n  power <- 1\n  while (power < x) {\n    power <- power * n\n    if (power == x) return(TRUE)\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_simple_power\n    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_77","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਵੈਧ ਹੈ।ਜੇਕਰ ਇਹ ਇੰਗੇਜਰ ਕਿਸੇ ਪੂਰਨ ਅੰਕ ਦਾ ਘਣ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਪੂਰਨ ਅੰਕ a ਲੈਂਦਾ ਹੈ ਅਤੇ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ # >>> iscube(1)\n# TRUE\n# >>> iscube(2)\n# FALSE\n# >>> iscube(-1)\n# TRUE\n# >>> iscube(64)\n# TRUE\n# >>> iscube(0)\n# TRUE\n# >>> iscube(180)\n# FALSE\niscube <- function(a) {","canonical_solution":"iscube <- function(a) {\n  if (a == 0) return(TRUE)\n  root <- round(abs(a)^(1\/3))\n  return(root^3 == abs(a))\n}","tests":"test_humaneval <- function() {\n    candidate <- iscube\n    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_78","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਅਤੇ ਪ੍ਰਤੀਕ ਏ, ਬੀ, ਸੀ, ਡੀ, ਈ, ਐਫ ਹਮੇਸ਼ਾ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਹੁੰਦੇ ਹਨ।ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਸਹੀ ਜਾਂ ਖਾਲੀ ਸਤਰ ਹੈ, ਬੀ (= ਦਸਮ ਅੰਕ 11), ਡੀ (= ਦਸਮ ਅੰਕ 13). ਇਸ ਲਈ ਤੁਹਾਨੂੰ ਹੇਠ ਲਿਖੇ ਅੰਕ ਦੀ ਗਿਣਤੀ ਪਤਾ ਕਰਨੀ ਪਵੇਗੀ: 2, 3, 5, 7, ਪ੍ਰਾਇਮ ਨੰਬਰ 2, 3, 5, 7, 11, 13, 17,... ਹਨ।ਹੈਕਸਾਡੇਸਿਮਲ ਅੰਕ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ਏ, ਬੀ, ਸੀ, ਡੀ, ਈ, ਐਫ ਹਨ।1 ਤੋਂ ਵੱਡਾ ਹੈ ਜੋ ਕਿ ਦੋ ਛੋਟੇ ਕੁਦਰਤੀ ਸੰਖਿਆਵਾਂ ਦਾ ਉਤਪਾਦ ਨਹੀਂ ਹੈ) ।ਅੰਕ ਜੋ ਪ੍ਰਾਇਮ ਹਨ (ਪ੍ਰਾਇਮ ਨੰਬਰ, ਜਾਂ ਪ੍ਰਾਇਮ, ਇੱਕ ਕੁਦਰਤੀ ਸੰਖਿਆ ਹੈ)ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਇੱਕ ਹੈਕਸਾਡੇਸੀਮਲ ਨੰਬਰ ਅਤੇ ਹੈਕਸਾਡੇਸੀਮਲ ਦੀ ਗਿਣਤੀ ਗਿਣਦਾ ਹੈ ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣ ਲਈ ਕਿਹਾ ਗਿਆ ਹੈ ਜੋ ਪ੍ਰਾਪਤ ਕਰਦਾ ਹੈ# >>> hex_key('AB')\n# 1\n# >>> hex_key('1077E')\n# 2\n# >>> hex_key('ABED1A33')\n# 4\n# >>> hex_key('123456789ABCDEF0')\n# 6\n# >>> hex_key('2020')\n# 2\nhex_key <- function(num) {","canonical_solution":"hex_key <- function(num) {\n  # Define the set of prime hexadecimal digits\n  prime_hex_digits <- c('2', '3', '5', '7', 'B', 'D')\n  \n  # Initialize a counter\n  count <- 0\n  \n  # Convert the input string to a list of characters\n  chars <- strsplit(num, NULL)[[1]]\n  \n  # Loop over each character in the list\n  for (char in chars) {\n    # Check if the character is in the list of prime hexadecimal digits\n    if (char %in% prime_hex_digits) {\n      # Increment the count\n      count <- count + 1\n    }\n  }\n  \n  # Return the count\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- hex_key\n    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))\n    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_79","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਵਾਧੂ ਅੱਖਰ ਫਾਰਮੈਟ ਵਿੱਚ ਮਦਦ ਲਈ ਹਨ।ਸਤਰ ਦੇ ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ ਇੱਕ ਵਾਧੂ ਦੋ ਅੱਖਰ 'db' ਹੋਣਗੇ।ਸਤਰ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ '0' ਜਾਂ '1' ਹੋਵੇਗਾ।ਬਾਈਨਰੀ ਫਾਰਮੈਟ. ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ, ਜਿਸ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ ਇੱਕ ਬਾਈਨਰੀ  ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।ਤੁਹਾਨੂੰ ਦਸ਼ਮਲਵ ਰੂਪ ਵਿੱਚ ਇੱਕ ਨੰਬਰ ਦਿੱਤਾ ਜਾਵੇਗਾ ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਨੂੰ ਬਦਲਣਾ ਹੈ # >>> decimal_to_binary(15)\n# 'db1111db'\n# >>> decimal_to_binary(32)\n# 'db100000db'\ndecimal_to_binary <- function(decimal) {","canonical_solution":"decimal_to_binary <- function(decimal) {\n  binary_string <- as.character(intToBits(decimal))\n  binary_clean <- paste0(rev(binary_string), collapse = \"\")\n  binary_trimmed <- sub(\"^0+\", \"\", binary_clean)\n  return(paste0(\"db\", binary_trimmed, \"db\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- decimal_to_binary\n    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))\n    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))\n    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))\n    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_80","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਇੱਕ ਸਤਰ hapr ਹੈ ਜੇਕਰ ਇਸਦੀ ਲੰਬਾਈ ਘੱਟੋ ਘੱਟ 3 ਹੈ ਅਤੇ ਹਰ 3 ਲਗਾਤਾਰ ਅੱਖਰ ਵੱਖਰੇ ਹਨ ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚਣਾ ਹੈ ਕਿ ਸਤਰ ਹੈਰ ਹੈ ਜਾਂ ਨਹੀਂ।ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ।# >>> is_happy('a')\n# FALSE\n# >>> is_happy('aa')\n# FALSE\n# >>> is_happy('abcd')\n# TRUE\n# >>> is_happy('aabb')\n# FALSE\n# >>> is_happy('adb')\n# TRUE\n# >>> is_happy('xyy')\n# FALSE\nis_happy <- function(s) {","canonical_solution":"is_happy <- function(s) {\n  n <- nchar(s)\n  if (n < 3) {\n    return(FALSE)\n  }\n  for (i in 1:(n - 2)) {\n    if (length(unique(substring(s, i, i + 2))) != 3) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_happy\n    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_81","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ 0.0 ਈ> 0.0 D- > 0.7 D > 1.0 ਡੀ+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 ਬੀ- > 2.7 B > 3.0 ਬੀ+ > 3.3 ਏ- > 3.7 ਏ 4.0 ਏ+ GPA। ਪੱਤਰ ਗ੍ਰੇਡ।ਇੱਕ ਫੰਕਸ਼ਨ ਜੋ ਹੇਠਲੀ ਸਾਰਣੀ ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅੱਖਰ ਗ੍ਰੇਡਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਆਉਟਪੁੱਟ ਕਰ ਸਕਦਾ ਹੈਃ ਉਸਨੇ ਤੁਹਾਨੂੰ ਕੁਝ ਵਿਦਿਆਰਥੀਆਂ ਦੇ ਗਰੇਡ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਲਿਖਣਾ ਹੈ ।ਸਿਰਫ ਸਮੱਸਿਆ ਇਹ ਹੈ ਕਿ, ਉਸਨੇ ਗਰੇਡਿੰਗ ਲਈ ਵਰਤਿਆ ਕੋਡ ਗੁਆ ਦਿੱਤਾ ਹੈ।ਵਿਦਿਆਰਥੀਆਂ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣ ਲਈ ਅਧਿਆਪਕ ਆਪਣਾ ਅਲਗੋਰਿਦਮ ਬਣਾ ਰਿਹਾ ਹੈ।ਇਹ ਸਮੈਸਟਰ ਦਾ ਆਖਰੀ ਹਫ਼ਤਾ ਹੈ ਅਤੇ ਅਧਿਆਪਕ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣਾ ਹੈ # >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))\n# c('A+', 'B', 'C-', 'C', 'A-')\nnumerical_letter_grade <- function(grades) {","canonical_solution":"numerical_letter_grade <- function(grades) {\n  letter_grades <- sapply(grades, function(gpa) {\n    if (gpa == 4.0) {\n      \"A+\"\n    } else if (gpa > 3.7) {\n      \"A\"\n    } else if (gpa > 3.3) {\n      \"A-\"\n    } else if (gpa > 3.0) {\n      \"B+\"\n    } else if (gpa > 2.7) {\n      \"B\"\n    } else if (gpa > 2.3) {\n      \"B-\"\n    } else if (gpa > 2.0) {\n      \"C+\"\n    } else if (gpa > 1.7) {\n      \"C\"\n    } else if (gpa > 1.3) {\n      \"C-\"\n    } else if (gpa > 1.0) {\n      \"D+\"\n    } else if (gpa > 0.7) {\n      \"D\"\n    } else if (gpa > 0.0) {\n      \"D-\"\n    } else {\n      \"E\"\n    }\n  })\n  return(letter_grades)\n}","tests":"test_humaneval <- function() {\n    candidate <- numerical_letter_grade\n    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_82","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ length ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ ਜਾਂ ਨਹੀਂ ਤਾਂ FALSE ਹੈ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸਤਰ # >>> prime_length('Hello')\n# TRUE\n# >>> prime_length('abcdcba')\n# TRUE\n# >>> prime_length('kittens')\n# TRUE\n# >>> prime_length('orange')\n# FALSE\nprime_length <- function(string) {","canonical_solution":"prime_length <- function(string) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n <= 3) return(TRUE)\n    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)\n    \n    i <- 5\n    while (i * i <= n) {\n      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)\n      i <- i + 6\n    }\n    \n    return(TRUE)\n  }\n  \n  string_length <- nchar(string)\n  return(is_prime(string_length))\n}","tests":"test_humaneval <- function() {\n    candidate <- prime_length\n    stopifnot(isTRUE(all.equal(candidate('Hello'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abcdcba'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('kittens'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('orange'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('wow'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('world'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('MadaM'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('Wow'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('HI'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('go'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('gogo'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaaaaaaaaaaaa'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('Madam'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('M'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('0'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_83","nl":"pan_Guru","pl":"r","prompt":"ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਜੋ 1 ਨਾਲ ਸ਼ੁਰੂ ਜਾਂ ਖ਼ਤਮ ਹੁੰਦੇ ਹਨ।ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, n-ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ starts_one_ends <- function(n) {","canonical_solution":"starts_one_ends <- function(n) {\n  if (n == 1) {\n    return(1)\n  } else {\n    return(9 * (10^(n-2)) * 2)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- starts_one_ends\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(2), 18)))\n    stopifnot(isTRUE(all.equal(candidate(3), 180)))\n    stopifnot(isTRUE(all.equal(candidate(4), 1800)))\n    stopifnot(isTRUE(all.equal(candidate(5), 18000)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_84","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ N ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਅੰਕਾਂ ਦਾ ਕੁੱਲ ਜੋੜ ਬਾਈਨਰੀ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।# >>> solve(1000)\n# '1'\n# >>> solve(150)\n# '110'\n# >>> solve(147)\n# '1100'\n# Variables:\n#     @N integer\n#          Constraints: 0 ≤ N ≤ 10000.\n# Output:\n#      a string of binary number\nsolve <- function(N) {","canonical_solution":"solve <- function(N) {\n  # Sum the digits of the number\n  digit_sum <- sum(as.numeric(unlist(strsplit(as.character(N), \"\"))))\n  # Convert the sum to binary and return as a string\n  return(as.character(as.binary(digit_sum)))\n}\n\n# Helper function to convert number to binary\nas.binary <- function(number) {\n  if (number == 0) return(\"0\")\n  binary <- \"\"\n  while (number > 0) {\n    binary <- paste0(number %% 2, binary)\n    number <- number %\/% 2\n  }\n  return(binary)\n}","tests":"test_humaneval <- function() {\n    candidate <- solve\n    stopifnot(isTRUE(all.equal(candidate(1000), '1')))\n    stopifnot(isTRUE(all.equal(candidate(150), '110')))\n    stopifnot(isTRUE(all.equal(candidate(147), '1100')))\n    stopifnot(isTRUE(all.equal(candidate(333), '1001')))\n    stopifnot(isTRUE(all.equal(candidate(963), '10010')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_85","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ lst. ਜੋੜੇ ਤੱਤ ਜੋੜੋ ਜੋ ਅਜੀਬ ਸੂਚਕਾਂਕ ਤੇ ਹਨ .. # >>> add(c(4, 2, 6, 7))\n# 2\nadd <- function(lst) {","canonical_solution":"add <- function(lst) {\n  # Select elements at odd indices (which are even positions)\n  elements_at_odd_indices <- lst[seq(2, length(lst), by=2)]\n  # Keep only the even elements\n  even_elements <- elements_at_odd_indices[elements_at_odd_indices %% 2 == 0]\n  # Sum the even elements\n  sum(even_elements)\n}","tests":"test_humaneval <- function() {\n    candidate <- add\n    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_86","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਨੋਟਃ ਤੁਹਾਨੂੰ ਵਾਕ ਵਿੱਚ ਸ਼ਬਦਾਂ ਅਤੇ ਖਾਲੀ ਥਾਂਵਾਂ ਦੀ ਤਰਤੀਬ ਨੂੰ ਰੱਖਣਾ ਚਾਹੀਦਾ ਹੈ।ਅਸਕੀ ਮੁੱਲ ਦੇ ਆਧਾਰ 'ਤੇ ਵਧਦਾ ਕ੍ਰਮ।ਇੱਕ ਨਵੇਂ ਸ਼ਬਦ ਨਾਲ ਬਦਲਿਆ ਜਾਂਦਾ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਅੱਖਰ  ਵਿੱਚ ਵਿਵਸਥਿਤ ਹੁੰਦੇ ਹਨਸਤਰ ਦਾ ਆਰਡਰਡ ਵਰਜਨ, ਇੱਕ ਸਤਰ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਸ਼ਬਦ (ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ) ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਇਸਦਾ ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੰਸਕਰਣ ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> anti_shuffle('Hi')\n# 'Hi'\n# >>> anti_shuffle('hello')\n# 'ehllo'\n# >>> anti_shuffle('Hello World!!!')\n# 'Hello !!!Wdlor'\nanti_shuffle <- function(s) {","canonical_solution":"anti_shuffle <- function(s) {\n  words <- strsplit(s, \"(\\\\s+)\", perl = TRUE)[[1]]\n  sorted_words <- sapply(words, function(word) {\n    if (word == \"\") return(word)\n    chars <- unlist(strsplit(word, split = \"\"))\n    return(paste0(sort(chars), collapse = \"\"))\n  })\n  return(paste0(sorted_words, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- anti_shuffle\n    stopifnot(isTRUE(all.equal(candidate('Hi'), 'Hi')))\n    stopifnot(isTRUE(all.equal(candidate('hello'), 'ehllo')))\n    stopifnot(isTRUE(all.equal(candidate('number'), 'bemnru')))\n    stopifnot(isTRUE(all.equal(candidate('abcd'), 'abcd')))\n    stopifnot(isTRUE(all.equal(candidate('Hello World!!!'), 'Hello !!!Wdlor')))\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_87","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਨਾਲ ਹੀ, ਕਤਾਰ ਦੇ ਕੋਆਰਡੀਨੇਟ ਨੂੰ ਕਾਲਮਾਂ ਦੇ ਅਨੁਸਾਰ ਘਟਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ।ਸ਼ੁਰੂ ਵਿੱਚ ਕਤਾਰਾਂ ਵਿੱਚ ਨਿਰਦੇਸ਼-ਅੰਕ ਨੂੰ ਵੱਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ।ਹਰੇਕ ਸੂਚੀ ਇੱਕ ਕੋਆਰਡੀਨੇਟ ਹੈ - (ਕਤਾਰ, ਕਾਲਮ), 0 ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ।ਅਤੇ ਸੂਚੀਆਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰੋ, [(x1, y1), (x2, y2) ...] ਜਿਵੇਂ ਕਿ lst, ਅਤੇ ਪੂਰਨ ਅੰਕ x ਦਿੱਤੇ ਗਏ ਹਨ, ਸੂਚੀ ਵਿੱਚ ਪੂਰਨ ਅੰਕ x ਲੱਭੋ, ਹਰੇਕ ਕਤਾਰ ਵਿੱਚ ਵੱਖ-ਵੱਖ ਗਿਣਤੀ ਦੇ ਕਾਲਮ ਹੋ ਸਕਦੇ ਹਨ।ਜੋ ਕਿ ਮੈਟ੍ਰਿਕਸ ਦੇ ਸਮਾਨ ਹੈ, ਹਾਲਾਂਕਿ, ਮੈਟ੍ਰਿਕਸ ਦੇ ਉਲਟ, ਤੁਹਾਨੂੰ ਇੱਕ 2 ਅਯਾਮੀ ਡਾਟਾ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਨੇਸਟਡ ਸੂਚੀ ਦੇ ਰੂਪ ਵਿੱਚ, # >>> get_row(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1)\n# list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0))\n# >>> get_row(c(), 1)\n# c()\n# >>> get_row(list(c(), c(1), c(1, 2, 3)), 3)\n# list(c(2, 2))\nget_row <- function(lst, x) {","canonical_solution":"get_row <- function(lst, x) {\n  result <- list()\n  for (i in seq_along(lst)) {\n    row <- lst[[i]]\n    cols <- which(row == x)\n    for (col in rev(sort(cols - 1))) {\n      result <- append(result, list(c(i - 1, col)))\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- get_row\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0)))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6)), 2), list(c(0, 1), c(1, 1), c(2, 1), c(3, 1), c(4, 1), c(5, 1)))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 1, 3, 4, 5, 6), c(1, 2, 1, 4, 5, 6), c(1, 2, 3, 1, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 0), c(2, 1), c(2, 0), c(3, 2), c(3, 0), c(4, 3), c(4, 0), c(5, 4), c(5, 0), c(6, 5), c(6, 0)))))\n    stopifnot(isTRUE(all.equal(candidate(c(), 1), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1)), 2), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(c(), c(1), c(1, 2, 3)), 3), list(c(2, 2)))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_88","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ * ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਨੂੰ ਨਾ ਬਦਲੋ. ਨੋਟਃ ਜਾਂ ਇਸਨੂੰ ਘਟਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ ਜੇਕਰ ਜੋੜ ((ਪਹਿਲਾ ਇੰਡੈਕਸ ਮੁੱਲ, ਆਖਰੀ ਇੰਡੈਕਸ ਮੁੱਲ) ਜੋੜਾ ਹੈ।ਤੁਹਾਨੂੰ ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰ ਦੇਵੇਗਾ, ਜੇ ਜੋੜ ((ਪਹਿਲੇ ਇੰਡੈਕਸ ਮੁੱਲ, ਪਿਛਲੇ ਇੰਡੈਕਸ ਮੁੱਲ) ਅਜੀਬ ਹੈ, ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਕ੍ਰਮਬੱਧ ਕਰਨ ਤੋਂ ਬਾਅਦ ਦਿੱਤੇ ਵੈਕਟਰ ਦਾ ਇੱਕ ਕੋਰ ਵਾਪਸ ਕਰੋ, # >>> sort_array(c())\n# c()\n# >>> sort_array(c(5))\n# c(5)\n# >>> sort_array(c(2, 4, 3, 0, 1, 5))\n# c(0, 1, 2, 3, 4, 5)\n# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))\n# c(6, 5, 4, 3, 2, 1, 0)\nsort_array <- function(array) {","canonical_solution":"sort_array <- function(array) {\n  if (length(array) <= 1) {\n    return(array)\n  }\n  \n  first_value <- array[1]\n  last_value <- array[length(array)]\n  sum_values <- first_value + last_value\n  \n  if (sum_values %% 2 == 1) {\n    return(sort(array))\n  } else {\n    return(sort(array, decreasing = TRUE))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_array\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))\n    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_89","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਦੋ ਗੁਣਾ ਕਰਕੇ ਦੋ ਸਥਾਨਾਂ 'ਤੇ ਹੇਠਾਂ ਜਾਣ।ਅੱਖਰ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਘੁੰਮਾਇਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਕਿ ਅੱਖਰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਦੀ ਹੈ ਜੋ ਅੱਖਰ ਨੂੰ ਘੁੰਮਾਉਣ ਦੇ ਨਾਲ ਏਨਕ੍ਰਿਪਟ ਕੀਤੀ ਗਈ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇੱਕ ਆਰਗੂਮੈਂਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ # >>> encrypt('hi')\n# 'lm'\n# >>> encrypt('asdfghjkl')\n# 'ewhjklnop'\n# >>> encrypt('gf')\n# 'kj'\n# >>> encrypt('et')\n# 'ix'\nencrypt <- function(s) {","canonical_solution":"encrypt <- function(s) {\n  alphabet <- letters\n  shift <- 2 * 2\n  encrypted <- sapply(strsplit(s, NULL)[[1]], function(char) {\n    if (char %in% alphabet) {\n      new_index <- (match(char, alphabet) + shift - 1) %% 26 + 1\n      alphabet[new_index]\n    } else {\n      char\n    }\n  })\n  paste(encrypted, collapse = \"\")\n}","tests":"test_humaneval <- function() {\n    candidate <- encrypt\n    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))\n    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))\n    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))\n    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))\n    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))\n    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))\n    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))\n    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_90","nl":"pan_Guru","pl":"r","prompt":"NULL ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਤੱਤ ਨਹੀਂ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ next_smallest ਲਿਖੋ ਜੋ ਸੂਚੀ ਦੇ ਦੂਜੇ ਸਭ ਤੋਂ ਛੋਟੇ ਤੱਤ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ।# >>> next_smallest(c(1, 2, 3, 4, 5))\n# 2\n# >>> next_smallest(c(5, 1, 4, 3, 2))\n# 2\n# >>> next_smallest(c())\n# NULL\n# >>> next_smallest(c(1, 1))\n# NULL\nnext_smallest <- function(lst) {","canonical_solution":"next_smallest <- function(lst) {\n  # Sort the list and remove duplicates\n  unique_sorted_lst <- sort(unique(lst))\n  \n  # Check if list contains at least two distinct elements\n  if (length(unique_sorted_lst) < 2) {\n    return(NULL)\n  }\n  \n  # Return the second smallest element\n  return(unique_sorted_lst[2])\n}","tests":"test_humaneval <- function() {\n    candidate <- next_smallest\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_91","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਵਾਕਾਂ ਨੂੰ '', '?' ਜਾਂ '!' ਨਾਲ ਸੀਮਿਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ।ਇੱਕ ਬੋਰਡ ਇੱਕ ਵਾਕ ਹੈ ਜੋ \"I\" ਸ਼ਬਦ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ।ਤੁਹਾਨੂੰ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਲੜੀ ਦਿੱਤੀ ਜਾਵੇਗੀ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਨੰਬਰ ਗਿਣਨਾ ਹੈ।# >>> is_bored('Hello world')\n# 0\n# >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n# 1\nis_bored <- function(S) {","canonical_solution":"is_bored <- function(S) {\n  # Split the string into sentences using '.', '?', and '!' as delimiters\n  sentences <- unlist(strsplit(S, split = \"[.?!]\"))\n  \n  # Trim leading and trailing whitespace from each sentence\n  sentences <- trimws(sentences)\n  \n  # Count the number of sentences that start with \"I\"\n  boredom_count <- sum(startsWith(sentences, \"I\"))\n  \n  return(boredom_count)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_bored\n    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_92","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਕਿਸੇ ਵੀ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਗਲਤ ਵਾਪਿਸ ਕਰਦਾ ਹੈ।ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਇੱਕ ਨੰਬਰ ਦੂਜੇ ਦੋ ਦੇ ਜੋੜ ਦੇ ਬਰਾਬਰ ਹੈ, ਅਤੇ ਸਾਰੇ ਨੰਬਰ ਪੂਰਨ ਅੰਕ ਹਨ.ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ 3 ਨੰਬਰ ਲੈਂਦਾ ਹੈ.# >>> any_int(5, 2, 7)\n# TRUE\n# >>> any_int(3, 2, 2)\n# FALSE\n# >>> any_int(3, -2, 1)\n# TRUE\n# >>> any_int(3.6, -2.2, 2)\n# FALSE\nany_int <- function(x, y, z) {","canonical_solution":"any_int <- function(x, y, z) {\n  if (is.integer(x) && is.integer(y) && is.integer(z)) {\n    return(x == y + z || y == x + z || z == x + y)\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- any_int\n    stopifnot(isTRUE(all.equal(candidate(2, 3, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2.5, 2, 3), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1.5, 5, 3.5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 6, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(4, 2, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2.2, 2.2, 2.2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(-4, 6, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 1, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 7), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(3.0, 4, 7), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_93","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਕੇਵਲ ਅੱਖਰਾਂ ਨੂੰ ਹੀ ਮੰਨ ਲਓ।ਅੰਗਰੇਜ਼ੀ ਵਰਣਮਾਲਾ ਵਿੱਚ ਧੁਨੀ।ਉਸ ਤੋਂ ਦੋ ਸਥਾਨ ਅੱਗੇ ਦਿਖਾਈ ਦੇਣ ਵਾਲੇ ਅੱਖਰ ਵਾਲਾ ਸੰਦੇਸ਼ ਇਸ ਤਰ੍ਹਾਂ ਇਹ ਸਾਰੇ ਅੱਖਰਾਂ ਦੇ ਕੇਸ ਬਦਲਦਾ ਹੈ,  ਵਿੱਚ ਸਾਰੇ ਵੋਕਲਸ ਨੂੰ ਬਦਲਦਾ ਹੈਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸੰਦੇਸ਼ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਅਜਿਹੇ ਵਿੱਚ ਏਨਕੋਡ ਕਰਦਾ ਹੈ # >>> encode('test')\n# 'TGST'\n# >>> encode('This is a message')\n# 'tHKS KS C MGSSCGG'\nencode <- function(message) {","canonical_solution":"encode <- function(message) {\n  # Function to swap case of letters\n  swap_case <- function(char) {\n    if (grepl(\"[A-Za-z]\", char)) {\n      if (char %in% LETTERS) {\n        return(tolower(char))\n      } else {\n        return(toupper(char))\n      }\n    } else {\n      return(char)\n    }\n  }\n  \n  # Vowel replacement rules\n  vowel_replacement <- function(char) {\n    vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n    replacements <- c(\"c\", \"g\", \"k\", \"q\", \"w\", \"C\", \"G\", \"K\", \"Q\", \"W\")\n    if (char %in% vowels) {\n      index <- match(char, vowels)\n      return(replacements[index])\n    } else {\n      return(char)\n    }\n  }\n  \n  # Splitting the message into its characters\n  message_chars <- strsplit(message, \"\")[[1]]\n  \n  # Apply swap case and vowel replacement\n  encoded_chars <- sapply(message_chars, function(x) vowel_replacement(swap_case(x)))\n  \n  # Combine the characters back into a single string\n  return(paste(encoded_chars, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- encode\n    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))\n    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))\n    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))\n    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))\n    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_94","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਇਮ ਵੈਲਯੂ ਲੱਭਣ ਦੀ ਲੋੜ ਹੈ ਅਤੇ ਇਸਦੇ ਅੰਕ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ.ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ।# >>> skjkasdkd(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))\n# 10\n# >>> skjkasdkd(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))\n# 25\n# >>> skjkasdkd(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))\n# 13\n# >>> skjkasdkd(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))\n# 11\n# >>> skjkasdkd(c(0, 81, 12, 3, 1, 21))\n# 3\n# >>> skjkasdkd(c(0, 8, 1, 2, 1, 7))\n# 7\nskjkasdkd <- function(lst) {","canonical_solution":"skjkasdkd <- function(lst) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n == 2) return(TRUE)\n    if (n %% 2 == 0) return(FALSE)\n    for (i in 3:sqrt(n)) {\n      if (n %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  prime_values <- lst[sapply(lst, is_prime)]\n  if (length(prime_values) == 0) return(0)\n  \n  largest_prime <- max(prime_values)\n  \n  sum_of_digits <- function(n) {\n    sum(as.numeric(unlist(strsplit(as.character(n), \"\"))))\n  }\n  \n  return(sum_of_digits(largest_prime))\n}","tests":"test_humaneval <- function() {\n    candidate <- skjkasdkd\n    stopifnot(isTRUE(all.equal(candidate(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)), 10)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)), 25)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)), 13)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)), 11)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 81, 12, 3, 1, 21)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 8, 1, 2, 1, 7)), 7)))\n    stopifnot(isTRUE(all.equal(candidate(c(8191)), 19)))\n    stopifnot(isTRUE(all.equal(candidate(c(8191, 123456, 127, 7)), 19)))\n    stopifnot(isTRUE(all.equal(candidate(c(127, 97, 8192)), 10)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_95","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਫੰਕਸ਼ਨ ਨੂੰ FALSE ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ ਦਿੱਤੀ ਗਈ ਨਾਮ ਸੂਚੀ ਖਾਲੀ ਹੈ।ਕੇਸ ਜਾਂ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਤਰਾਂ ਹਨ, ਨਹੀਂ ਤਾਂ FALSE ਵਾਪਸ ਕਰੋ.ਇੱਕ ਨਾਮ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, TRUE ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਹੇਠਲੇ ਵਿੱਚ ਸਤਰਾਂ ਹਨ # >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))\n# TRUE\n# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))\n# FALSE\n# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))\n# FALSE\n# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))\n# FALSE\n# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))\n# TRUE\ncheck_dict_case <- function(dict) {","canonical_solution":"check_dict_case <- function(dict) {\n  if (length(dict) == 0) return(FALSE)\n  \n  keys <- names(dict)\n  \n  all_lower <- all(keys == tolower(keys))\n  all_upper <- all(keys == toupper(keys))\n  \n  return(all_lower || all_upper)\n}","tests":"test_humaneval <- function() {\n    candidate <- check_dict_case\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_96","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਪੂਰਨ ਅੰਕ ਜੋ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹਨ ਅਤੇ n ਤੋਂ ਘੱਟ ਹਨ।ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋ ਜੋ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਪਹਿਲੇ n ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਦਾ ਹੈ # >>> count_up_to(5)\n# c(2, 3)\n# >>> count_up_to(11)\n# c(2, 3, 5, 7)\n# >>> count_up_to(0)\n# c()\n# >>> count_up_to(20)\n# c(2, 3, 5, 7, 11, 13, 17, 19)\n# >>> count_up_to(1)\n# c()\n# >>> count_up_to(18)\n# c(2, 3, 5, 7, 11, 13, 17)\ncount_up_to <- function(n) {","canonical_solution":"count_up_to <- function(n) {\n  is_prime <- function(num) {\n    if (num <= 1) return(FALSE)\n    if (num == 2) return(TRUE)\n    if (num %% 2 == 0) return(FALSE)\n    for (i in 3:sqrt(num)) {\n      if (num %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  primes_below_n <- c()\n  for (i in 2:(n-1)) {\n    if (is_prime(i)) {\n      primes_below_n <- c(primes_below_n, i)\n    }\n  }\n  \n  return(primes_below_n)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_up_to\n    stopifnot(isTRUE(all.equal(candidate(5), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(2, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(2, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(10), c(2, 3, 5, 7))))\n    stopifnot(isTRUE(all.equal(candidate(0), c())))\n    stopifnot(isTRUE(all.equal(candidate(22), c(2, 3, 5, 7, 11, 13, 17, 19))))\n    stopifnot(isTRUE(all.equal(candidate(1), c())))\n    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 5, 7, 11, 13, 17))))\n    stopifnot(isTRUE(all.equal(candidate(47), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43))))\n    stopifnot(isTRUE(all.equal(candidate(101), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_97","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਮੰਨ ਲਓ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਵੈਧ ਹੈ।ਉਹਨਾਂ ਦੇ ਯੂਨਿਟ ਅੰਕ ਦੇ ਉਤਪਾਦ.ਫੰਕਸ਼ਨ ਨੂੰ ਪੂਰਾ ਕਰੋ ਜੋ ਦੋ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਿਸ ਆਉਂਦਾ ਹੈ # >>> multiply(148, 412)\n# 16\n# >>> multiply(19, 28)\n# 72\n# >>> multiply(2020, 1851)\n# 0\n# >>> multiply(14, -15)\n# 20\nmultiply <- function(a, b) {","canonical_solution":"multiply <- function(a, b) {\n  unit_digit_a <- abs(a) %% 10\n  unit_digit_b <- abs(b) %% 10\n  return(unit_digit_a * unit_digit_b)\n}","tests":"test_humaneval <- function() {\n    candidate <- multiply\n    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))\n    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))\n    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))\n    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))\n    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))\n    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))\n    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))\n    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_98","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ, ਜੋ ਕਿ ਵੀ ਸੂਚਕਾਂਕ ਵਿੱਚ ਵੱਡੇ ਅੱਖਰ ਦੇ ਵੋਕਲ ਦੀ ਗਿਣਤੀ ਗਿਣੋ.# >>> count_upper('aBCdEf')\n# 1\n# >>> count_upper('abcdefg')\n# 0\n# >>> count_upper('dBBE')\n# 0\ncount_upper <- function(s) {","canonical_solution":"count_upper <- function(s) {\n  # Define uppercase vowels\n  uppercase_vowels <- c('A', 'E', 'I', 'O', 'U')\n  \n  # Initialize counter\n  count <- 0\n  \n  # Iterate over string indices\n  for (i in seq(1, nchar(s), by=2)) {\n    # Check if character at even index is an uppercase vowel\n    if (substr(s, i, i) %in% uppercase_vowels) {\n      count <- count + 1\n    }\n  }\n  \n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_upper\n    stopifnot(isTRUE(all.equal(candidate('aBCdEf'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('abcdefg'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('dBBE'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('B'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('U'), 1)))\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('EEEE'), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_99","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਦੋ ਪੂਰਨ ਅੰਕ ਤੋਂ, ਇਸ ਨੂੰ ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਕਰ ਦਿਓ।ਅਤੇ ਇਸ ਦੇ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਜੇਕਰ ਨੰਬਰ ਬਰਾਬਰ ਹੈ ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਨੰਬਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ (ਸਟ੍ਰਿੰਗ)# >>> closest_integer('10')\n# 10\n# >>> closest_integer('15.3')\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer <- function(value) {","canonical_solution":"closest_integer <- function(value) {\n  num <- as.numeric(value)\n  if (num %% 1 == 0.5 || num %% 1 == -0.5) {\n    return(ifelse(num > 0, ceiling(num), floor(num)))\n  } else {\n    return(round(num))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- closest_integer\n    stopifnot(isTRUE(all.equal(candidate('10'), 10)))\n    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))\n    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))\n    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))\n    stopifnot(isTRUE(all.equal(candidate('0'), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_100","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ i ਪੱਧਰ (i+1) ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਸੰਖਿਆ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਹਰੇਕ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ, ਜਿੱਥੇ ਤੱਤ ਇੰਡੈਕਸ - ਅਗਲੀ ਜੋੜੀ ਸੰਖਿਆ ਜੇ n ਜੋੜੀ ਹੈ।- ਅਗਲਾ ਅਜੀਬ ਨੰਬਰ ਜੇ n ਅਜੀਬ ਹੈ.ਅਗਲੇ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਹੈਃ ਪਹਿਲੇ ਪੱਧਰ ਵਿੱਚ n ਪੱਥਰ ਹਨ।ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਪੱਥਰਾਂ ਦੇ n ਪੱਧਰਾਂ ਦਾ ਇੱਕ ਢੇਰ ਬਣਾਉਣਾ ਹੋਵੇਗਾ।# >>> make_a_pile(3)\n# c(3, 5, 7)\nmake_a_pile <- function(n) {","canonical_solution":"make_a_pile <- function(n) {\n  stones <- numeric(n)\n  stones[1] <- n\n  for (i in 2:n) {\n    if (n %% 2 == 0) {\n      stones[i] <- stones[i - 1] + 2\n    } else {\n      stones[i] <- stones[i - 1] + 2\n    }\n  }\n  return(stones)\n}","tests":"test_humaneval <- function() {\n    candidate <- make_a_pile\n    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_101","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਸਤਰ ਨੂੰ ਸ਼ਬਦਾਂ ਵਿੱਚ ਵੰਡਣ ਅਤੇ ਸ਼ਬਦਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਵਾਪਸ ਕਰਨ ਲਈ.ਤੁਹਾਨੂੰ ਕਾਮੇ ਜਾਂ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ। ਤੁਹਾਡਾ ਕੰਮ ਹੈ # >>> words_string('Hi, my name is John')\n# c('Hi', 'my', 'name', 'is', 'John')\n# >>> words_string('One, two, three, four, five, six')\n# c('One', 'two', 'three', 'four', 'five', 'six')\nwords_string <- function(s) {","canonical_solution":"words_string <- function(s) {\n  s <- gsub(\",\", \" \", s)\n  words <- unlist(strsplit(s, \"\\\\s+\"))\n  words <- words[words != \"\"]\n  return(words)\n}","tests":"test_humaneval <- function() {\n    candidate <- words_string\n    stopifnot(isTRUE(all.equal(candidate('Hi, my name is John'), c('Hi', 'my', 'name', 'is', 'John'))))\n    stopifnot(isTRUE(all.equal(candidate('One, two, three, four, five, six'), c('One', 'two', 'three', 'four', 'five', 'six'))))\n    stopifnot(isTRUE(all.equal(candidate('Hi, my name'), c('Hi', 'my', 'name'))))\n    stopifnot(isTRUE(all.equal(candidate('One,, two, three, four, five, six,'), c('One', 'two', 'three', 'four', 'five', 'six'))))\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('ahmed     , gamal'), c('ahmed', 'gamal'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_102","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਕੋਈ ਅਜਿਹੀ ਗਿਣਤੀ ਨਹੀਂ ਹੈ, ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ -1 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ.ਸਭ ਤੋਂ ਵੱਡੀ ਪੂਰਨ ਸੰਖਿਆ ਜੋ ਕਿ [x, y] ਦੀ ਰੇਂਜ ਵਿੱਚ ਹੈ।ਇਹ ਫੰਕਸ਼ਨ ਦੋ ਸਕਾਰਾਤਮਕ ਨੰਬਰ x ਅਤੇ y ਲੈਂਦਾ ਹੈ ਅਤੇ  ਵਾਪਸ ਕਰਦਾ ਹੈ# >>> choose_num(12, 15)\n# 14\n# >>> choose_num(13, 12)\n# -1\nchoose_num <- function(x, y) {","canonical_solution":"choose_num <- function(x, y) {\n  if (x > y) {\n    return(-1)\n  }\n  \n  for (num in seq(y, x, by = -1)) {\n    if (num %% 2 == 0) {\n      return(num)\n    }\n  }\n  \n  return(-1)\n}","tests":"test_humaneval <- function() {\n    candidate <- choose_num\n    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))\n    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))\n    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))\n    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))\n    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))\n    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))\n    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))\n    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_103","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਜੇ n m ਤੋਂ ਵੱਡਾ ਹੈ, ਤਾਂ -1 ਵਾਪਸ ਕਰੋ।ਉੱਤਰ ਨੂੰ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਤੇ ਗੋਲ ਕਰੋ ਅਤੇ ਇਸਨੂੰ ਬਾਈਨਰੀ ਵਿੱਚ ਤਬਦੀਲ ਕਰੋ।n ਤੋਂ m ਤੱਕ ਦੇ ਪੂਰਨ ਅੰਕ ਦਾ ਔਸਤ (n ਅਤੇ m ਸਮੇਤ) ।ਤੁਹਾਨੂੰ ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਅਤੇ m ਦਿੱਤੇ ਗਏ ਹਨ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ  ਦੀ ਗਣਨਾ ਕਰਨਾ ਹੈ# >>> rounded_avg(1, 5)\n# '0b11'\n# >>> rounded_avg(7, 5)\n# -1\n# >>> rounded_avg(10, 20)\n# '0b1111'\n# >>> rounded_avg(20, 33)\n# '0b11010'\nrounded_avg <- function(n, m) {","canonical_solution":"rounded_avg <- function(n, m) {\n  if (n > m) {\n    return(-1)\n  }\n  avg <- mean(n:m)\n  rounded_avg <- round(avg)\n  binary_avg <- as.character(as.binary(rounded_avg))\n  return(paste0(\"0b\", binary_avg))\n}\n\nas.binary <- function(num) {\n  if (num == 0) {\n    return(\"0\")\n  }\n  binary <- \"\"\n  while (num > 0) {\n    binary <- paste0(num %% 2, binary)\n    num <- num %\/% 2\n  }\n  return(binary)\n}","tests":"test_humaneval <- function() {\n    candidate <- rounded_avg\n    stopifnot(isTRUE(all.equal(candidate(1, 5), '0b11')))\n    stopifnot(isTRUE(all.equal(candidate(7, 13), '0b1010')))\n    stopifnot(isTRUE(all.equal(candidate(964, 977), '0b1111001010')))\n    stopifnot(isTRUE(all.equal(candidate(996, 997), '0b1111100100')))\n    stopifnot(isTRUE(all.equal(candidate(560, 851), '0b1011000010')))\n    stopifnot(isTRUE(all.equal(candidate(185, 546), '0b101101110')))\n    stopifnot(isTRUE(all.equal(candidate(362, 496), '0b110101101')))\n    stopifnot(isTRUE(all.equal(candidate(350, 902), '0b1001110010')))\n    stopifnot(isTRUE(all.equal(candidate(197, 233), '0b11010111')))\n    stopifnot(isTRUE(all.equal(candidate(7, 5), -1)))\n    stopifnot(isTRUE(all.equal(candidate(5, 1), -1)))\n    stopifnot(isTRUE(all.equal(candidate(5, 5), '0b101')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_104","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਨੋਟਃ ਵਾਪਸ ਕੀਤੀ ਗਈ ਸੂਚੀ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ।ਉਹ ਤੱਤ ਜਿਸ ਵਿੱਚ ਕੋਈ ਵੀ ਅੰਕ ਨਾ ਹੋਵੇ।ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ x ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ। ਸਭ ਦੀ ਇੱਕ ਲੜੀਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰੋ # >>> unique_digits(c(15, 33, 1422, 1))\n# c(1, 15, 33)\n# >>> unique_digits(c(152, 323, 1422, 10))\n# c()\nunique_digits <- function(x) {","canonical_solution":"unique_digits <- function(x) {\n  has_no_even_digit <- function(num) {\n    digits <- as.numeric(strsplit(as.character(num), \"\")[[1]])\n    return(all(digits %% 2 != 0))\n  }\n  \n  result <- Filter(has_no_even_digit, x)\n  return(sort(result))\n}","tests":"test_humaneval <- function() {\n    candidate <- unique_digits\n    stopifnot(isTRUE(all.equal(candidate(c(15, 33, 1422, 1)), c(1, 15, 33))))\n    stopifnot(isTRUE(all.equal(candidate(c(152, 323, 1422, 10)), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(12345, 2033, 111, 151)), c(111, 151))))\n    stopifnot(isTRUE(all.equal(candidate(c(135, 103, 31)), c(31, 135))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_105","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: \"ਇੱਕ\", \"ਦੋ\", \"ਤਿੰਨ\", \"ਚਾਰ\", \"ਪੰਜ\", \"ਛੇ\", \"ਸੱਤ\", \"ਅੱਠ\", \"ਨੌ\" ਨਤੀਜਾ ਵੈਕਟਰ ਨੂੰ ਉਲਟਾਓ, ਅਤੇ ਫਿਰ ਹਰੇਕ ਅੰਕ ਨੂੰ ਇਸਦੇ ਅਨੁਸਾਰੀ ਨਾਮ ਨਾਲ ਬਦਲੋ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਪੂਰਨ ਅੰਕ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰੋ ਜੋ 1 ਅਤੇ 9 ਦੇ ਵਿਚਕਾਰ ਹਨ,# >>> by_length(c(2, 1, 1, 4, 5, 8, 2, 3))\n# c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One')\n#   If the vector is empty, return an empty vector:\n# >>> by_length(c())\n# c()\n#   If the vector has any strange number ignore it:\n# >>> by_length(c(1, -1, 55))\n# c('One')\nby_length <- function(arr) {","canonical_solution":"by_length <- function(arr) {\n  # Filter numbers between 1 and 9\n  valid_nums <- arr[arr >= 1 & arr <= 9]\n  # Sort the numbers\n  sorted_nums <- sort(valid_nums, decreasing = TRUE)\n  # Map numbers to their names\n  num_to_name <- c(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n  result <- num_to_name[sorted_nums]\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- by_length\n    stopifnot(isTRUE(all.equal(candidate(c(2, 1, 1, 4, 5, 8, 2, 3)), c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 55)), c('One'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 3, 2)), c('Three', 'Two', 'One'))))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 4, 8)), c('Nine', 'Eight', 'Four'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_106","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ i ਦਾ ਫੈਕਟੋਰਿਅਲ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ (1 * 2 * ... * i).i 1 ਤੋਂ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ।ਜਾਂ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ।ਅਤੇ ਅਕਾਰ n ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿਵੇਂ ਕਿ ਸੂਚਕਾਂਕ i ਤੇ ਤੱਤ ਦਾ ਮੁੱਲ i ਦਾ ਫੈਕਟਰੀਅਲ ਹੈ ਜੇ i ਵੀ ਹੈ ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰੋ f ਜੋ ਕਿ n ਨੂੰ ਇੱਕ ਪੈਰਾਮੀਟਰ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ, # >>> f(5)\n# c(1, 2, 6, 24, 15)\nf <- function(n) {","canonical_solution":"f <- function(n) {\n  result <- numeric(n)  # Initialize a numeric vector of length n\n  for (i in 1:n) {\n    if (i %% 2 == 0) {  # Check if i is even\n      result[i] <- factorial(i)\n    } else {\n      result[i] <- sum(1:i)\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- f\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_107","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ 1: ਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ ਜੋ ਕਿ ਰੇਂਜ ਦੇ ਅੰਦਰ ਆਉਂਦੇ ਹਨ ((1, n), ਸਮੇਤ.ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਵੀ ਅਤੇ ਅਜੀਬ ਦੀ ਗਿਣਤੀ ਹੈ # >>> even_odd_palindrome(3)\n# c(1, 2)\n#     Explanation:\n#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome(12)\n# c(4, 6)\n#     Explanation:\n#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n#     1. 1 <= n <= 10^3\n#     2. returned list has the number of even and odd integer palindromes respectively.\neven_odd_palindrome <- function(n) {","canonical_solution":"even_odd_palindrome <- function(n) {\n  is_palindrome <- function(x) {\n    str_x <- as.character(x)\n    return(str_x == paste(rev(unlist(strsplit(str_x, \"\"))), collapse = \"\"))\n  }\n  \n  even_count <- 0\n  odd_count <- 0\n  \n  for (i in 1:n) {\n    if (is_palindrome(i)) {\n      if (i %% 2 == 0) {\n        even_count <- even_count + 1\n      } else {\n        odd_count <- odd_count + 1\n      }\n    }\n  }\n  \n  return(c(even_count, odd_count))\n}","tests":"test_humaneval <- function() {\n    candidate <- even_odd_palindrome\n    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))\n    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))\n    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_108","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ ਲਈ -123 ਦੇ ਅੰਕ -1, 2 ਅਤੇ 3 ਹਨ।ਜੇਕਰ ਕੋਈ ਸੰਖਿਆ ਨਕਾਰਾਤਮਕ ਹੈ, ਤਾਂ ਇਸਦਾ ਪਹਿਲਾ ਦਸਤਖਤ ਕੀਤਾ ਅੰਕ ਨਕਾਰਾਤਮਕ ਹੋਵੇਗਾ: ਤੱਤਾਂ ਦੀ ਸੰਖਿਆ ਜਿਸ ਦੇ ਅੰਕ ਦਾ ਜੋੜ > 0 ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ count_nums ਲਿਖੋ ਜੋ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਿਸ ਆਉਂਦਾ ਹੈ # >>> count_nums(c())\n# 0\n# >>> count_nums(c(-1, 11, -11))\n# 1\n# >>> count_nums(c(1, 1, 2))\n# 3\ncount_nums <- function(arr) {","canonical_solution":"count_nums <- function(arr) {\n  # Helper function to calculate sum of digits\n  sum_of_digits <- function(num) {\n    digits <- as.numeric(unlist(strsplit(as.character(num), \"\")))\n    return(sum(digits, na.rm = TRUE))\n  }\n  \n  # Apply the sum_of_digits function and count numbers with sum > 0\n  return(sum(sapply(arr, sum_of_digits) > 0))\n}","tests":"test_humaneval <- function() {\n    candidate <- count_nums\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_109","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਨੋਟਃ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਵਿੱਚ ਵਿਲੱਖਣ ਤੱਤ ਹੋਣ ਦੀ ਗਾਰੰਟੀ ਹੈ।ਜੇ ਦਿੱਤਾ ਗਿਆ ਵੈਕਟਰ ਖਾਲੀ ਹੈ ਤਾਂ TRUE ਵਾਪਸ ਕਰੋ. ਫਿਰ TRUE ਵਾਪਸ ਕਰੋ ਜਾਂ ਫਿਰ FALSE ਵਾਪਸ ਕਰੋਜੇਕਰ ਉਪਰੋਕਤ ਕਾਰਵਾਈ ਕਰ ਕੇ ਕ੍ਰਮਬੱਧ ਵੈਕਟਰ ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਹੈ ਵੈਕਟਰ ਵਿੱਚ ਸ਼ੁਰੂਆਤੀ ਸਥਿਤੀ ਯਾਨੀ 0th ਇੰਡੈਕਸ।ਸਹੀ ਦਿਸ਼ਾ ਵਿੱਚ ਸਥਿਤੀ. ਵੈਕਟਰ ਦੇ ਆਖਰੀ ਤੱਤ ਨੂੰ  ਵਿੱਚ ਭੇਜਿਆ ਜਾਵੇਗਾਇੱਕ ਸੱਜੇ ਪਾਸੇ ਜਾਣ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਵੈਕਟਰ ਦੇ ਸਾਰੇ ਤੱਤਾਂ ਨੂੰ ਇੱਕ ਨਾਲ ਬਦਲਣਾ।ਤੁਹਾਨੂੰ ਸੱਜੇ ਸ਼ਿਫਟ ਆਪਰੇਸ਼ਨ ਨੂੰ ਕਿਸੇ ਵੀ ਗਿਣਤੀ ਵਿੱਚ ਵਾਰ ਕਰਨ ਦੀ ਆਗਿਆ ਹੈ।ਦਿੱਤੇ ਗਏ ਵੈਕਟਰ 'ਤੇ ਹੇਠ ਲਿਖੀ ਕਾਰਵਾਈ: ਇਹ ਸੰਭਵ ਹੈ ਕਿ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਗੈਰ-ਘਟਾਉਣ ਵਾਲੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾ ਸਕੇ ਵੈਕਟਰ ਵਿੱਚ ਨੰਬਰ ਬੇਤਰਤੀਬੇ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਜਾਣਗੇ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਸਾਡੇ ਕੋਲ N ਪੂਰਨ ਅੰਕ arr[1], arr[2], ..., arr[N] ਦਾ ਇੱਕ ਵੈਕਟਰ 'arr' ਹੈ।# >>> move_one_ball(c(3, 4, 5, 1, 2))\n# TRUE\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n#              be achieved for the given vector.\n# >>> move_one_ball(c(3, 5, 4, 1, 2))\n# FALSE\n# Explanation:It is not possible to get non-decreasing order for the given\n#             vector by performing any number of right shift operations.\nmove_one_ball <- function(arr) {","canonical_solution":"move_one_ball <- function(arr) {\n  if (length(arr) == 0) {\n    return(TRUE)\n  }\n  \n  n <- length(arr)\n  for (i in 1:n) {\n    shifted_arr <- c(tail(arr, n - i), head(arr, i))\n    if (all(diff(shifted_arr) >= 0)) {\n      return(TRUE)\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- move_one_ball\n    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_110","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਨਹੀਂ ਤਾਂ, \"NO\" ਵਾਪਸ ਕਰੋ।lst1 ਦੇ ਸਾਰੇ ਤੱਤ ਨੂੰ ਵੀ ਹੋਣ ਲਈ, \"YES\" ਵਾਪਸ ਕਰੋ.ਜੇ ਇਹ ਸੰਭਵ ਹੈ ਕਿ lst1 ਅਤੇ lst2 ਵਿਚਕਾਰ ਤੱਤ ਨੂੰ ਬਦਲਣ ਲਈ lst1 ਅਤੇ lst2 ਦੇ ਵਿਚਕਾਰ ਵਟਾਂਦਰੇ ਵਾਲੇ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਦੀ ਕੋਈ ਸੀਮਾ ਨਹੀਂ ਹੈ। ਸਿਰਫ ਬਰਾਬਰ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਬਣਾਉਣ ਲਈ।ਅਤੇ ਇਹ ਨਿਰਧਾਰਤ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਤੱਤਾਂ ਦਾ ਆਦਾਨ-ਪ੍ਰਦਾਨ ਕਰਨਾ ਸੰਭਵ ਹੈ ਇਸ ਸਮੱਸਿਆ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋਗੇ ਜੋ ਨੰਬਰਾਂ ਦੀਆਂ ਦੋ ਸੂਚੀਆਂ ਲੈਂਦਾ ਹੈ, # >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))\n# 'YES'\n# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))\n# 'NO'\n# It is assumed that the input lists will be non-empty.\nexchange <- function(lst1, lst2) {","canonical_solution":"exchange <- function(lst1, lst2) {\n  # Identify even and odd numbers in lst1\n  lst1_even <- lst1[lst1 %% 2 == 0]\n  lst1_odd <- lst1[lst1 %% 2 != 0]\n  \n  # Identify even numbers in lst2\n  lst2_even <- lst2[lst2 %% 2 == 0]\n  \n  # Check if the number of odd elements in lst1 can be replaced with even elements from lst2\n  if (length(lst1_odd) <= length(lst2_even)) {\n    return(\"YES\")\n  } else {\n    return(\"NO\")\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- exchange\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_111","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਜੇ ਕਈ ਅੱਖਰਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੀ ਘਟਨਾ ਹੋਵੇ, ਤਾਂ ਉਨ੍ਹਾਂ ਸਾਰਿਆਂ ਨੂੰ ਵਾਪਸ ਕਰੋ।ਸਭ ਤੋਂ ਵੱਧ ਵਾਰ ਦੁਹਰਾਉਣ ਵਾਲੇ ਅਤੇ ਅਨੁਸਾਰੀ ਗਿਣਤੀ ਵਾਲੇ ਅੱਖਰ ਦਾ.ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਇੱਕ ਸਪੇਸ ਵੱਖ ਕੀਤੇ ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, ਇੱਕ ਨਾਮ ਸੂਚੀ ਵਾਪਸ ਕਰੋ # >>> histogram('a b c')\n# list('a' = 1, 'b' = 1, 'c' = 1)\n# >>> histogram('a b b a')\n# list('a' = 2, 'b' = 2)\n# >>> histogram('a b c a b')\n# list('a' = 2, 'b' = 2)\n# >>> histogram('b b b b a')\n# list('b' = 4)\n# >>> histogram('')\n# list()\nhistogram <- function(test) {","canonical_solution":"histogram <- function(test) {\n  # Split the string into individual letters.\n  letters <- unlist(strsplit(test, \" \"))\n  \n  # Create a table to count the occurrences of each letter.\n  count_table <- table(letters)\n  \n  # Find the maximum frequency of occurrences.\n  max_count <- max(count_table, na.rm = TRUE)\n  \n  # Find all letters that have the maximum frequency.\n  max_letters <- names(count_table[count_table == max_count])\n  \n  # Create a named list with letters as names and their max occurrences as values.\n  result <- setNames(as.list(rep(max_count, length(max_letters))), max_letters)\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- histogram\n    stopifnot(isTRUE(all.equal(candidate('a b b a'), list('a' = 2, 'b' = 2))))\n    stopifnot(isTRUE(all.equal(candidate('a b c a b'), list('a' = 2, 'b' = 2))))\n    stopifnot(isTRUE(all.equal(candidate('a b c d g'), list('a' = 1, 'b' = 1, 'c' = 1, 'd' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate('b b b b a'), list('b' = 4))))\n    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate(''), list())))\n    stopifnot(isTRUE(all.equal(candidate('a'), list('a' = 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_112","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ ਤੁਹਾਨੂੰ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ ਜਿਸ ਵਿੱਚ ਨਤੀਜਾ ਸਤਰ ਅਤੇ TRUE\/FALSE ਚੈੱਕ ਲਈ ਹੋਵੇ।ਇੱਕ ਸਤਰ ਨੂੰ ਪਾਲੀਂਡਰੋਮ ਕਿਹਾ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਇਹ ਅੱਗੇ ਵਾਂਗ ਹੀ ਪਿੱਛੇ ਵੱਲ ਪੜ੍ਹਦਾ ਹੈ।ਫਿਰ ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਨਤੀਜਾ ਸਤਰ ਪਾਲੀਂਡਰੋਮ ਹੈ।ਸਾਨੂੰ ਦੋ ਸਤਰਾਂ s ਅਤੇ c ਦਿੱਤੀਆਂ ਗਈਆਂ ਹਨ, ਤੁਹਾਨੂੰ s ਵਿੱਚ ਸਾਰੇ ਅੱਖਰਾਂ ਨੂੰ ਮਿਟਾਉਣਾ ਹੈ ਜੋ c ਵਿੱਚ ਕਿਸੇ ਵੀ ਅੱਖਰ ਦੇ ਬਰਾਬਰ ਹਨ ਕੰਮ # >>> reverse_delete('abcde', 'ae')\n# list('bcd', FALSE)\n# >>> reverse_delete('abcdef', 'b')\n# list('acdef', FALSE)\n# >>> reverse_delete('abcdedcba', 'ab')\n# list('cdedc', TRUE)\nreverse_delete <- function(s, c) {","canonical_solution":"reverse_delete <- function(s, c) {\n  # Remove characters in 'c' from 's'\n  for (char in strsplit(c, '')[[1]]) {\n    s <- gsub(char, \"\", s)\n  }\n  \n  # Check if the resultant string is a palindrome\n  is_palindrome <- s == paste(rev(strsplit(s, NULL)[[1]]), collapse = \"\")\n  \n  # Return the resultant string and the palindrome check result\n  return(list(s, is_palindrome))\n}","tests":"test_humaneval <- function() {\n    candidate <- reverse_delete\n    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_113","nl":"pan_Guru","pl":"r","prompt":"ਇੰਪੁੱਟ ਦੇ i'th ਸਤਰ ਵਿੱਚ ਅਜੀਬ ਅੰਕ ਦੇ.ਇੰਪੁੱਟ ਦੀ ਸਤਰ i. \" ਜਿੱਥੇ ਸਾਰੇ i ਨੂੰ ਨੰਬਰ ਨਾਲ ਬਦਲਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਆਉਟਪੁੱਟ ਦੇ ਹਰੇਕ ਤੱਤ i ਨੂੰ \"ਇੱਕ ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈਸਤਰਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਜਿੱਥੇ ਹਰ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੰਕ ਹੁੰਦੇ ਹਨ, ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ.# >>> odd_count(c('1234567'))\n# c('the number of odd elements 4n the str4ng 4 of the 4nput.')\n# >>> odd_count(c('3', '11111111'))\n# c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.')\nodd_count <- function(lst) {","canonical_solution":"odd_count <- function(lst) {\n  sapply(lst, function(x) {\n    odd_digits <- sum(as.numeric(unlist(strsplit(x, \"\"))) %% 2 == 1)\n    sprintf(\"the number of odd elements %dn the str%2$sing %1$d of the %3$nput.\", odd_digits, odd_digits, odd_digits)\n  })\n}\n\n# Example usage\nprint(odd_count(c('1234567')))\nprint(odd_count(c('3', '11111111')))","tests":"test_humaneval <- function() {\n    candidate <- odd_count\n    stopifnot(isTRUE(all.equal(candidate(c('1234567')), c('the number of odd elements 4n the str4ng 4 of the 4nput.'))))\n    stopifnot(isTRUE(all.equal(candidate(c('3', '11111111')), c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'))))\n    stopifnot(isTRUE(all.equal(candidate(c('271', '137', '314')), c('the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_114","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ ਪੂਰਨ ਅੰਕ n ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਕਿਸੇ ਵੀ ਗੈਰ-ਖਾਲੀ ਸਬ-ਵੈਕਟਰ ਦਾ ਘੱਟੋ ਘੱਟ ਜੋੜ ਲੱਭੋ # >>> minSubArraySum(c(2, 3, 4, 1, 2, 4))\n# 1\n# >>> minSubArraySum(c(-1, -2, -3))\n# -6\nminSubArraySum <- function(nums) {","canonical_solution":"minSubArraySum <- function(nums) {\n  min_sum <- nums[1]\n  current_sum <- 0\n  \n  for (num in nums) {\n    if (current_sum > 0) {\n      current_sum <- 0\n    }\n    current_sum <- current_sum + num\n    if (current_sum < min_sum) {\n      min_sum <- current_sum\n    }\n  }\n  \n  return(min_sum)\n}","tests":"test_humaneval <- function() {\n    candidate <- minSubArraySum\n    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 4, 1, 2, 4)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 2, -10)), -14)))\n    stopifnot(isTRUE(all.equal(candidate(c(-9999999999999999)), -9999999999999999)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 10, 20, 1000000)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 10, -5)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, -1, -2, -3, 10, -5)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(10, 11, 13, 8, 3, 4)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, -33, 32, -1, 0, -2)), -33)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10)), -10)))\n    stopifnot(isTRUE(all.equal(candidate(c(7)), 7)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1)), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_115","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ 1: ਬਕਸੇ ਨੂੰ ਘੱਟ ਕਰਨ ਲਈ ਤੁਹਾਨੂੰ ਕਿੰਨੀ ਵਾਰ ਲੋੜ ਹੈ ਆਉਟਪੁੱਟ ਦਿਓ.ਤੁਹਾਡਾ ਕੰਮ ਖੂਹਾਂ ਨੂੰ ਖਾਲੀ ਕਰਨ ਲਈ ਡੱਬਿਆਂ ਦੀ ਵਰਤੋਂ ਕਰਨਾ ਹੈ।ਅਤੇ ਸਾਰੇ ਡੱਬਿਆਂ ਦੀ ਸਮਰੱਥਾ ਇੱਕੋ ਜਿਹੀ ਹੈ।ਹਰੇਕ ਖੂਹ ਵਿੱਚ ਇੱਕ ਬਕਵਾਸ ਹੈ ਜਿਸਦੀ ਵਰਤੋਂ ਇਸ ਤੋਂ ਪਾਣੀ ਕੱਢਣ ਲਈ ਕੀਤੀ ਜਾ ਸਕਦੀ ਹੈ, ਅਤੇ ਹਰ ਇੱਕ ਕਤਾਰ ਵਿੱਚ 1 ਪਾਣੀ ਦੀ ਇੱਕ ਇਕਾਈ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।ਤੁਹਾਨੂੰ ਖੂਹਾਂ ਦਾ ਇੱਕ ਆਇਤਾਕਾਰ ਗਰਿੱਡ ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ। ਹਰ ਕਤਾਰ ਇੱਕ ਸਿੰਗਲ ਖੂਹ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, # >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)\n# 6\n# Example 2:\n# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)\n# 5\n# Example 3:\n# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)\n# 0\n# Constraints:\n#     * all wells have the same length\n#     * 1 <= grid.length <= 10^2\n#     * 1 <= grid[:,1].length <= 10^2\n#     * grid[i][j] -> 0 | 1\n#     * 1 <= capacity <= 10\nmax_fill <- function(grid, capacity) {","canonical_solution":"max_fill <- function(grid, capacity) {\n  total_water <- sum(unlist(grid))\n  num_buckets_needed <- ceiling(total_water \/ capacity)\n  return(num_buckets_needed)\n}","tests":"test_humaneval <- function() {\n    candidate <- max_fill\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_116","nl":"pan_Guru","pl":"r","prompt":"ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਲਾਗੂ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈਃ ਇੱਕੋ ਜਿਹੀ ਗਿਣਤੀ ਦੇ ਲਈ, ਦਸ਼ਮਲਵ ਮੁੱਲ ਦੇ ਆਧਾਰ ਤੇ ਕ੍ਰਮਬੱਧ ਕਰੋ।ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਉਹਨਾਂ ਦੀ ਬਾਈਨਰੀ ਪ੍ਰਤੀਨਿਧਤਾ ਵਿੱਚ ਇੱਕਾਂ ਦੀ ਗਿਣਤੀ।ਇਸ ਕਾਟਾ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰਨਾ ਹੈ # >>> sort_array(c(1, 5, 2, 3, 4))\n# c(1, 2, 3, 4, 5)\n# >>> sort_array(c(-2, -3, -4, -5, -6))\n# c(-6, -5, -4, -3, -2)\n# >>> sort_array(c(1, 0, 2, 3, 4))\n# c(0, 1, 2, 3, 4)\nsort_array <- function(arr) {","canonical_solution":"sort_array <- function(arr) {\n  # Filter out negative numbers and sort them directly\n  negative_numbers <- sort(arr[arr < 0])\n  \n  # Process non-negative numbers\n  non_negative_numbers <- arr[arr >= 0]\n  \n  # Sort non-negative numbers based on number of 1s in binary representation, then by decimal value\n  sorted_non_negative_numbers <- non_negative_numbers[order(sapply(non_negative_numbers, function(x) {\n    sum(as.integer(intToBits(x)))\n  }), non_negative_numbers)]\n  \n  # Combine sorted negative and non-negative numbers\n  c(negative_numbers, sorted_non_negative_numbers)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_array\n    stopifnot(isTRUE(all.equal(candidate(c(1, 5, 2, 3, 4)), c(1, 2, 4, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, -3, -4, -5, -6)), c(-4, -2, -6, -5, -3))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 2, 3, 4)), c(0, 1, 2, 4, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4)), c(2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 6, 44, 12, 32, 5)), c(32, 3, 5, 6, 12, 44))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_117","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਨੋਟਃ ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੱਖਰ ਅਤੇ ਸਪੇਸ ਹਨ।ਜੇਕਰ ਸਤਰ s ਖਾਲੀ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।n ਧੁਨੀ, ਕ੍ਰਮ ਵਿੱਚ ਇਹ ਸ਼ਬਦ ਸਤਰ s ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦੇ ਹਨ।ਇੱਕ ਫੰਕਸ਼ਨ ਜੋ ਸਤਰ s ਤੋਂ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਬਿਲਕੁਲ ਇੱਕ ਸਤਰ s ਅਤੇ ਇੱਕ ਕੁਦਰਤੀ ਸੰਖਿਆ n ਦਿੱਤੀ ਗਈ ਹੈ, ਤੁਹਾਨੂੰ ਲਾਗੂ ਕਰਨ ਦਾ ਕੰਮ ਦਿੱਤਾ ਗਿਆ ਹੈ # >>> select_words('Mary had a little lamb', 4)\n# c('little')\n# >>> select_words('Mary had a little lamb', 3)\n# c('Mary', 'lamb')\n# >>> select_words('simple white space', 2)\n# c()\n# >>> select_words('Hello world', 4)\n# c('world')\n# >>> select_words('Uncle sam', 3)\n# c('Uncle')\nselect_words <- function(s, n) {","canonical_solution":"select_words <- function(s, n) {\n  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n  words <- strsplit(s, \" \")[[1]]\n  result <- sapply(words, function(word) {\n    consonants_count <- nchar(gsub(paste(vowels, collapse = \"|\"), \"\", word))\n    if (consonants_count == n) return(word)\n    else return(NULL)\n  })\n  result <- result[!sapply(result, is.null)]\n  unname(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- select_words\n    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 4), c('little'))))\n    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 3), c('Mary', 'lamb'))))\n    stopifnot(isTRUE(all.equal(candidate('simple white space', 2), c())))\n    stopifnot(isTRUE(all.equal(candidate('Hello world', 4), c('world'))))\n    stopifnot(isTRUE(all.equal(candidate('Uncle sam', 3), c('Uncle'))))\n    stopifnot(isTRUE(all.equal(candidate('', 4), c())))\n    stopifnot(isTRUE(all.equal(candidate('a b c d e f', 1), c('b', 'c', 'd', 'f'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_118","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਦਿੱਤੇ ਗਏ ਸਤਰ ਵਿੱਚ ਕੇਵਲ ਅੰਗਰੇਜ਼ੀ ਅੱਖਰ ਹਨ।ਉਪਰੋਕਤ ਸ਼ਰਤ ਨੂੰ ਪੂਰਾ ਕਰਨ ਵਾਲਾ ਕੋਈ ਵੀ ਸਵੈ-ਹਵਾਲਾ ਲੱਭੋ.ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ ਅਖਰ ਗਿਣਦੇ ਨਹੀਂ ਹਨ। ਜੇਕਰ ਤੁਸੀਂ ਨਹੀਂ ਕੀਤਾ ਤਾਂ ਖਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰੋ ਸ਼ਬਦ ਦੇ ਸੱਜੇ ਪਾਸੇ ਤੋਂ ਦੋ ਧੁਨੀ (ਕੇਸ ਸੰਵੇਦਨਸ਼ੀਲ) ।ਤੁਹਾਨੂੰ ਇੱਕ ਸ਼ਬਦ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਸਵੈਰ ਲੱਭਣਾ ਹੈ ਜੋ ਵਿਚਕਾਰ ਖੜ੍ਹਾ ਹੈ # >>> get_closest_vowel('yogurt')\n# 'u'\n# >>> get_closest_vowel('FULL')\n# 'U'\n# >>> get_closest_vowel('quick')\n# ''\n# >>> get_closest_vowel('ab')\n# ''\nget_closest_vowel <- function(word) {","canonical_solution":"get_closest_vowel <- function(word) {\n  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n  n <- nchar(word)\n  \n  # Iterate from the second to last position to the second position\n  for (i in (n-1):2) {\n    if (substr(word, i, i) %in% vowels) {\n      if (!substr(word, i-1, i-1) %in% vowels && !substr(word, i+1, i+1) %in% vowels) {\n        return(substr(word, i, i))\n      }\n    }\n  }\n  \n  # Return empty string if no vowel is found\n  return('')\n}","tests":"test_humaneval <- function() {\n    candidate <- get_closest_vowel\n    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))\n    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))\n    stopifnot(isTRUE(all.equal(candidate('easy'), '')))\n    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))\n    stopifnot(isTRUE(all.equal(candidate('ali'), '')))\n    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))\n    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))\n    stopifnot(isTRUE(all.equal(candidate('ab'), '')))\n    stopifnot(isTRUE(all.equal(candidate('ba'), '')))\n    stopifnot(isTRUE(all.equal(candidate('quick'), '')))\n    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))\n    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))\n    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_119","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ 'ਹਾਂ' ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਇੱਕ ਚੰਗੀ ਸਤਰ ਬਣਾਉਣ ਦਾ ਕੋਈ ਤਰੀਕਾ ਹੈ, ਅਤੇ 'ਨਹੀਂ' ਵਾਪਸ ਕਰੋ ਨਹੀਂ ਤਾਂ.\"()) \" ਨਹੀਂ ਹੈ।ਸੰਤੁਲਿਤ ਹਨ. ਉਦਾਹਰਣ ਲਈਃ ਸਤਰ '(()))) ਚੰਗੀ ਹੈ, ਜਦੋਂ ਕਿ ਸਤਰ ਇੱਕ ਸਤਰ S ਨੂੰ ਚੰਗੀ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇ ਅਤੇ ਕੇਵਲ ਤਾਂ ਹੀ ਜੇ S ਵਿੱਚ ਸਾਰੇ ਬਰੈਂਚੈਸ ਕੁਝ ਕ੍ਰਮ, ਜੋ ਕਿ ਨਤੀਜੇ ਸਤਰ ਚੰਗਾ ਹੋ ਜਾਵੇਗਾ.ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚਣਾ ਹੈ ਕਿ ਕੀ ਦੋ ਸਤਰਾਂ ਨੂੰ ਜੋੜਨਾ ਸੰਭਵ ਹੈ ਸਿਰਫ ' (_) ' ਜਾਂ ') ' parentheses ਵਿੱਚ ਹੀ ਪਾਓ।ਤੁਹਾਨੂੰ ਦੋ ਸਤਰਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਦੋਵੇਂ ਸਤਰਾਂ ਵਿੱਚ ਖੁੱਲਾ ਸ਼ਾਮਲ ਹੈ # >>> match_parens(c('()(', ')'))\n# 'Yes'\n# >>> match_parens(c(')', ')'))\n# 'No'\nmatch_parens <- function(lst) {","canonical_solution":"match_parens <- function(lst) {\n  is_balanced <- function(s) {\n    balance <- 0\n    for (ch in strsplit(s, \"\")[[1]]) {\n      if (ch == '(') {\n        balance <- balance + 1\n      } else {\n        balance <- balance - 1\n      }\n      if (balance < 0) return(FALSE)\n    }\n    return(balance == 0)\n  }\n  \n  s1 <- lst[1]\n  s2 <- lst[2]\n  \n  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {\n    return('Yes')\n  } else {\n    return('No')\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- match_parens\n    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_120","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ 1: ਲੰਬਾਈ k ਦੇ ਨਾਲ ਵੱਧ ਤੋਂ ਵੱਧ k ਨੰਬਰਾਂ ਦੇ ਨਾਲ.ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਵੈਕਟਰ arr ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰੋ # >>> maximum(c(-3, -4, 5), 3)\n# c(-4, -3, 5)\n# Example 2:\n# >>> maximum(c(4, -4, 4), 2)\n# c(4, 4)\n# Example 3:\n# >>> maximum(c(-3, 2, 1, 2, -1, -2, 1), 1)\n# c(2)\n# Note:\n#     1. The length of the vector will be in the range of [1, 1000].\n#     2. The elements in the vector will be in the range of [-1000, 1000].\n#     3. 0 <= k <= len(arr)\nmaximum <- function(arr, k) {","canonical_solution":"maximum <- function(arr, k) {\n  return(sort(tail(sort(arr), k)))\n}","tests":"test_humaneval <- function() {\n    candidate <- maximum\n    stopifnot(isTRUE(all.equal(candidate(c(-3, -4, 5), 3), c(-4, -3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, -4, 4), 2), c(4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 2, 1, 2, -1, -2, 1), 1), c(2))))\n    stopifnot(isTRUE(all.equal(candidate(c(123, -123, 20, 0, 1, 2, -3), 3), c(2, 20, 123))))\n    stopifnot(isTRUE(all.equal(candidate(c(-123, 20, 0, 1, 2, -3), 4), c(0, 1, 2, 20))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 15, 0, 3, -13, -8, 0), 7), c(-13, -8, 0, 0, 3, 5, 15))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 2, 5, 3, -10), 2), c(3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 5, -7), 1), c(5))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, -4), 2), c(-4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(-10, 10), 2), c(-10, 10))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, -23, 243, -400, 0), 0), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_121","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਸਾਰੇ ਅਜੀਬ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ ਬਰਾਬਰ ਦੀਆਂ ਅਹੁਦਿਆਂ ਤੇ ਹਨ.# >>> solution(c(5, 8, 7, 1))\n# 12\n# >>> solution(c(3, 3, 3, 3, 3))\n# 9\n# >>> solution(c(30, 13, 24, 321))\n# 0\nsolution <- function(lst) {","canonical_solution":"solution <- function(lst) {\n  sum(lst[seq(2, length(lst), by = 2)][lst[seq(2, length(lst), by = 2)] %% 2 != 0])\n}","tests":"test_humaneval <- function() {\n    candidate <- solution\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_122","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ arr ਦੇ ਪਹਿਲੇ k ਤੱਤਾਂ ਦੇ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਅੰਕਾਂ ਵਾਲੇ ਤੱਤਾਂ ਦਾ ਜੋੜ।ਪੂਰਨ ਅੰਕ arr ਅਤੇ ਪੂਰਨ ਅੰਕ k ਦੇ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਵੈਕਟਰ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਵਾਪਸੀ # >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)\n# 24\n# Constraints:\n#     1. 1 <= len(arr) <= 100\n#     2. 1 <= k <= len(arr)\nadd_elements <- function(arr, k) {","canonical_solution":"add_elements <- function(arr, k) {\n  sum(arr[1:k][nchar(abs(arr[1:k])) <= 2])\n}","tests":"test_humaneval <- function() {\n    candidate <- add_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))\n    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))\n    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))\n    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_123","nl":"pan_Guru","pl":"r","prompt":"get_odd_collatz(5) ਵਾਪਸ ਕਰਦਾ ਹੈ [1, 5] # 5 ਲਈ collatz ਲੜੀ [5, 16, 8, 4, 2, 1], ਇਸ ਲਈ ਅਜੀਬ ਨੰਬਰ ਸਿਰਫ 1, ਅਤੇ 5 ਹਨ. ਉਦਾਹਰਣ ਲਈ: 2. ਵਾਪਸ ਕੀਤੀ ਸੂਚੀ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ।1. Collatz(1) [1] ਹੈ।ਨੋਟਃ ਇਹ ਅਨੁਮਾਨ ਹੈ ਕਿ n ਦਾ ਕੋਈ ਵੀ ਮੁੱਲ ਹੋਵੇ, ਤਰਤੀਬ ਹਮੇਸ਼ਾ 1 ਤੱਕ ਪਹੁੰਚੇਗੀ।ਜੇ ਪਿਛਲਾ ਸ਼ਬਦ ਅਜੀਬ ਹੈ, ਤਾਂ ਅਗਲਾ ਸ਼ਬਦ 3 ਗੁਣਾ ਹੈ।ਪਿਛਲੀ ਅਵਧੀ ਇਸ ਪ੍ਰਕਾਰ ਹੈਃ ਜੇ ਪਿਛਲੀ ਅਵਧੀ ਜਮ੍ਹਾ ਹੈ, ਅਗਲੀ ਅਵਧੀ  ਦਾ ਅੱਧਾ ਹਿੱਸਾ ਹੈਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰਃ ਕਿਸੇ ਵੀ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਨਾਲ ਸ਼ੁਰੂ ਕਰੋ। ਫਿਰ ਹਰ ਸ਼ਬਦ ਨੂੰ  ਤੋਂ ਪ੍ਰਾਪਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ।ਕੋਲੈਟਜ਼ ਅਨੁਮਾਨ ਗਣਿਤ ਵਿੱਚ ਇੱਕ ਅਨੁਮਾਨ ਹੈ ਜੋ ਪਰਿਭਾਸ਼ਿਤ ਕ੍ਰਮ ਨਾਲ ਸਬੰਧਤ ਹੈ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕੋਲੈਟਜ਼ ਕ੍ਰਮ ਵਿੱਚ ਅਜੀਬ ਨੰਬਰ ਹਨ।# >>> get_odd_collatz(5)\n# c(1, 5)\nget_odd_collatz <- function(n) {","canonical_solution":"get_odd_collatz <- function(n) {\n  collatz_sequence <- function(n) {\n    sequence <- c(n)\n    while (n != 1) {\n      if (n %% 2 == 0) {\n        n <- n \/ 2\n      } else {\n        n <- 3 * n + 1\n      }\n      sequence <- c(sequence, n)\n    }\n    return(sequence)\n  }\n  \n  sequence <- collatz_sequence(n)\n  odd_numbers <- unique(sequence[sequence %% 2 != 0])\n  return(sort(odd_numbers))\n}","tests":"test_humaneval <- function() {\n    candidate <- get_odd_collatz\n    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))\n    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_124","nl":"pan_Guru","pl":"r","prompt":"4. ਤਾਰੀਖ ਨੂੰ ਇਸ ਫਾਰਮੈਟ ਵਿੱਚ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈਃ ਐਮ.ਐਮ.ਡੀ.ਡੀ.ਐਮ.3. ਮਹੀਨਿਆਂ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 12 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ।2. ਮਹੀਨਿਆਂ 1,3,5,7,8,10,12 ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 31 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ ਅਤੇ ਮਹੀਨਿਆਂ 4,6,9,11 ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 30 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ ਅਤੇ ਮਹੀਨੇ 2 ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 29 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ।1. ਤਾਰੀਖ ਸਤਰ ਖਾਲੀ ਨਹੀਂ ਹੈ।ਤਾਰੀਖ ਉਦੋਂ ਵੈਧ ਹੁੰਦੀ ਹੈ ਜਦੋਂ ਹੇਠ ਲਿਖੇ ਸਾਰੇ ਨਿਯਮ ਪੂਰੇ ਹੋਣ:TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਤਾਰੀਖ ਠੀਕ ਹੈ ਨਹੀਂ ਤਾਂ FALSE।ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਪਵੇਗਾ ਜੋ ਇੱਕ ਦਿੱਤੀ ਗਈ ਤਾਰੀਖ ਸਤਰ ਨੂੰ ਪ੍ਰਮਾਣਿਤ ਕਰਦਾ ਹੈ ਅਤੇ # >>> valid_date('03-11-2000')\n# TRUE\n# >>> valid_date('15-01-2012')\n# FALSE\n# >>> valid_date('04-0-2040')\n# FALSE\n# >>> valid_date('06-04-2020')\n# TRUE\n# >>> valid_date('06\/04\/2020')\n# FALSE\nvalid_date <- function(date) {","canonical_solution":"valid_date <- function(date) {\n  # Check if the date is not empty\n  if (date == \"\") {\n    return(FALSE)\n  }\n  \n  # Check the format of the date\n  if (!grepl(\"^\\\\d{2}-\\\\d{2}-\\\\d{4}$\", date)) {\n    return(FALSE)\n  }\n  \n  # Extract the month, day, and year\n  parts <- unlist(strsplit(date, \"-\"))\n  month <- as.numeric(parts[1])\n  day <- as.numeric(parts[2])\n  year <- as.numeric(parts[3])\n  \n  # Check if the month is valid\n  if (month < 1 || month > 12) {\n    return(FALSE)\n  }\n  \n  # Check if the day is valid\n  if (month %in% c(1, 3, 5, 7, 8, 10, 12) && (day < 1 || day > 31)) {\n    return(FALSE)\n  }\n  \n  if (month %in% c(4, 6, 9, 11) && (day < 1 || day > 30)) {\n    return(FALSE)\n  }\n  \n  if (month == 2 && (day < 1 || day > 29)) {\n    return(FALSE)\n  }\n  \n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- valid_date\n    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_125","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਅੱਖਰ, ਆਰਡਰ 'a') = 0, ਆਰਡਰ 'b') = 1, ... ਆਰਡਰ 'z') = 25 ਜੇਕਰ ਕੋਈ ਕਾਮੇ ਮੌਜੂਦ ਨਹੀਂ ਹਨ ਤਾਂ ਤੁਹਾਨੂੰ  ਵਿੱਚ ਅਣਗਿਣਤ ਕ੍ਰਮ ਨਾਲ ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਜੇਕਰ ਤੁਸੀਂ ਟੈਕਸਟ ਵਿੱਚ ਕੋਈ ਵੀ ਵਾਈਟਸਪੇਸ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਵਾਈਟਸਪੇਸ ਤੇ ਵੰਡਿਆ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ # >>> split_words('Hello world!')\n# c('Hello', 'world!')\n# >>> split_words('Hello,world!')\n# c('Hello', 'world!')\n# >>> split_words('abcdef')\n# 3\nsplit_words <- function(txt) {","canonical_solution":"split_words <- function(txt) {\n  if (grepl(\"\\\\s\", txt)) {\n    return(strsplit(txt, \"\\\\s+\")[[1]])\n  } else if (grepl(\",\", txt)) {\n    return(strsplit(txt, \",\")[[1]])\n  } else {\n    odd_order_count <- sum(\n      sapply(unlist(strsplit(txt, \"\")), function(x) {\n        ord <- utf8ToInt(tolower(x)) - utf8ToInt(\"a\")\n        ord %% 2 == 1\n      })\n    )\n    return(odd_order_count)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- split_words\n    stopifnot(isTRUE(all.equal(candidate('Hello world!'), c('Hello', 'world!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello,world!'), c('Hello', 'world!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello world,!'), c('Hello', 'world,!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello,Hello,world !'), c('Hello,Hello,world', '!'))))\n    stopifnot(isTRUE(all.equal(candidate('abcdef'), 3)))\n    stopifnot(isTRUE(all.equal(candidate('aaabb'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('aaaBb'), 1)))\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_126","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਨੰਬਰ, ਵਾਪਸ FALSE. ਕੋਈ ਨਕਾਰਾਤਮਕ ਨੰਬਰ ਅਤੇ ਸਿਰਫ ਪੂਰਨ ਅੰਕ ਮੰਨ ਲਓ. ਜੇ ਸੂਚੀ ਵਿੱਚ ਇੱਕ ਤੋਂ ਵੱਧ ਡੁਪਲੀਕੇਟ ਹਨ ਤਾਂ ਇੱਕੋ ਸੂਚੀ ਵਿੱਚ ਇੱਕ ਤੋਂ ਵੱਧ ਡੁਪਲੀਕੇਟ ਹਨ।ਨੰਬਰਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਉਹਨਾਂ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ ਜਾਂ ਨਹੀਂ, ਵਾਪਸ ਕਰੋ # >>> is_sorted(c(5))\n# TRUE\n# >>> is_sorted(c(1, 2, 3, 4, 5))\n# TRUE\n# >>> is_sorted(c(1, 3, 2, 4, 5))\n# FALSE\n# >>> is_sorted(c(1, 2, 3, 4, 5, 6))\n# TRUE\n# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))\n# TRUE\n# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))\n# FALSE\n# >>> is_sorted(c(1, 2, 2, 3, 3, 4))\n# TRUE\n# >>> is_sorted(c(1, 2, 2, 2, 3, 4))\n# FALSE\nis_sorted <- function(lst) {","canonical_solution":"is_sorted <- function(lst) {\n  if (length(lst) <= 1) {\n    return(TRUE)\n  }\n  \n  # Check for duplicates more than once\n  tbl <- table(lst)\n  if (any(tbl > 2)) {\n    return(FALSE)\n  }\n  \n  # Check if the list is sorted in ascending order\n  for (i in 2:length(lst)) {\n    if (lst[i] < lst[i - 1]) {\n      return(FALSE)\n    }\n  }\n  \n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_sorted\n    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_127","nl":"pan_Guru","pl":"r","prompt":"[ਇੰਪੁੱਟ\/ਆਉਟਪੁੱਟ] ਨਮੂਨੇਃ ਜੇ ਦੋ ਅੰਤਰਾਲਾਂ ਨੂੰ ਕੱਟਿਆ ਨਹੀਂ ਜਾਂਦਾ, ਤਾਂ \"NO\" ਵਾਪਸ ਕਰੋ.ਨਹੀਂ ਤਾਂ, \"NO\" ਵਾਪਸ ਕਰੋ।ਜੇ ਇੰਟਰਸੈਕਸ਼ਨ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ, ਤਾਂ \"YES\" ਵਾਪਸ ਕਰੋ, ਜਿਸਦੀ ਲੰਬਾਈ 1 ਹੈ, ਜੋ ਕਿ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਨਹੀਂ ਹੈ।ਉਦਾਹਰਨ ਲਈ, ਅੰਤਰਾਲਾਂ (1, 3), (2, 4) ਦਾ ਅੰਤਰਾਲ (2, 3) ਹੈ।ਅੰਤਰਾਲ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ।ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਇਹਨਾਂ ਦੋਵਾਂ ਦੀ ਲਾਂਘੇ ਦੀ ਲੰਬਾਈ ਹਰੇਕ ਦਿੱਤੇ ਅੰਤਰਾਲ ਲਈ, ਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਸ ਦੀ ਸ਼ੁਰੂਆਤ ਇਸ ਦੇ ਅੰਤ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ।ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਦੋਵੇਂ ਸ਼ਾਮਲ ਹਨ।ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਬੰਦ ਹਨ ਜਿਸਦਾ ਮਤਲਬ ਹੈ ਕਿ ਅੰਤਰਾਲ (ਸ਼ੁਰੂਆਤ, ਅੰਤ) ਜਿੱਥੇ ਹਰ ਅੰਤਰਾਲ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਜੋੜਾ ਹੁੰਦਾ ਹੈ। ਉਦਾਹਰਣ ਲਈ, ਅੰਤਰਾਲ = (ਸ਼ੁਰੂਆਤ, ਅੰਤ) = (1, 2).ਤੁਹਾਨੂੰ ਦੋ ਅੰਤਰਾਲ ਦਿੱਤੇ ਗਏ ਹਨ, # >>> intersection(c(1, 2), c(2, 3))\n# 'NO'\n# >>> intersection(c(-1, 1), c(0, 4))\n# 'NO'\n# >>> intersection(c(-3, -1), c(-5, 5))\n# 'YES'\nintersection <- function(interval1, interval2) {","canonical_solution":"intersection <- function(interval1, interval2) {\n  start1 <- interval1[1]\n  end1 <- interval1[2]\n  start2 <- interval2[1]\n  end2 <- interval2[2]\n  \n  # Determine the start and end of the intersection\n  intersection_start <- max(start1, start2)\n  intersection_end <- min(end1, end2)\n  \n  # Calculate the length of the intersection\n  length_of_intersection <- intersection_end - intersection_start\n  \n  # If there's no intersection, return \"NO\"\n  if (length_of_intersection < 0) {\n    return('NO')\n  }\n  \n  # Check if the length is a prime number\n  is_prime <- function(num) {\n    if (num <= 1) {\n      return(FALSE)\n    }\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  \n  # Return \"YES\" if the length is prime, otherwise \"NO\"\n  if (is_prime(length_of_intersection)) {\n    return('YES')\n  } else {\n    return('NO')\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- intersection\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(2, 3)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1), c(0, 4)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, -1), c(-5, 5)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, 2), c(-4, 0)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(-11, 2), c(-1, -1)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(3, 5)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(1, 2)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, -2), c(-3, -2)), 'NO')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_128","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਨੋਟਃ ਖਾਲੀ arr ਲਈ NULL ਵਾਪਸ ਕਰੋ।ਵੈਕਟਰ ਵਿੱਚ ਹਰੇਕ ਨੰਬਰ ਦੇ, 1, -1 ਜਾਂ 0 ਦੁਆਰਾ ਦਰਸਾਏ ਗਏ ਹਨ।ਪੂਰਨ ਅੰਕ ਦੇ ਆਕਾਰ ਦਾ ਜੋੜ ਸਾਰੇ ਸੰਕੇਤਾਂ ਦੇ ਉਤਪਾਦ ਨਾਲ ਗੁਣਾ ਕੀਤਾ ਗਿਆ ਹੈ ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਵੈਕਟਰ ਦਿੱਤਾ ਗਿਆ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ # >>> prod_signs(c(1, 2, 2, -4))\n# 9\n# >>> prod_signs(c(0, 1))\n# 0\n# >>> prod_signs(c())\n# NULL\nprod_signs <- function(arr) {","canonical_solution":"prod_signs <- function(arr) {\n  if (length(arr) == 0) {\n    return(NULL)\n  }\n  magnitude_sum <- sum(abs(arr))\n  sign_product <- prod(sign(arr))\n  return(magnitude_sum * sign_product)\n}","tests":"test_humaneval <- function() {\n    candidate <- prod_signs\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, -4)), -9)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 2, 3, -1, 1)), -10)))\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 2, -1, -1, 9)), 20)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, -1, 1)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 1)), -4)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 0)), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_129","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਸੈੱਲਾਂ ਦੇ ਮੁੱਲਾਂ ਦੀ ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚੋਂ ਘੱਟੋ ਘੱਟ ਮਾਰਗ ਲੰਘਦਾ ਹੈ।ਇਸ ਦਾ ਜਵਾਬ ਗਾਰੰਟੀਸ਼ੁਦਾ ਹੈ ਕਿ ਵਿਲੱਖਣ ਹੈ।lst_A[j] = lst_B[j]. ਅਜਿਹੇ lst_A[i] < lst_B[i] ਅਤੇ ਕਿਸੇ ਵੀ j (1 <= j <i) ਲਈ ਸਾਡੇ ਕੋਲ lst_B ਤੋਂ, ਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਇੱਕ ਪੂਰਨ ਅੰਕ ਸੂਚਕ i (1 <= i <= k) ਮੌਜੂਦ ਹੈ।ਦੁਆਰਾ (ਆਓ ਉਨ੍ਹਾਂ ਨੂੰ lst_A ਅਤੇ lst_B ਕਹਿੰਦੇ ਹਾਂ), lst_A ਲੈਕਸੀਕੋਗ੍ਰਾਫਿਕ ਤੌਰ ਤੇ ਘੱਟ ਹੈ ਸੈੱਲਾਂ 'ਤੇ ਮੁੱਲਾਂ ਦੀ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਬਣਾਉਣ ਤੋਂ ਬਾਅਦ ਕਿ A ਅਤੇ B ਜਾਓ ਇੱਕ ਮਾਰਗ A (ਲੰਬਾਈ k) ਨੂੰ ਇੱਕ ਮਾਰਗ B (ਲੰਬਾਈ k) ਤੋਂ ਛੋਟਾ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਤੁਸੀਂ ਗ੍ਰੀਡ ਤੋਂ ਬਾਹਰ ਨਹੀਂ ਜਾ ਸਕਦੇ।ਜ਼ਰੂਰੀ ਤੌਰ ਤੇ ਵੱਖਰੇ).ਕਿਰਪਾ ਕਰਕੇ ਨੋਟ ਕਰੋ ਕਿ ਲੰਬਾਈ k ਦੇ ਮਾਰਗ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਬਿਲਕੁਲ k ਸੈੱਲਾਂ ਦਾ ਦੌਰਾ ਕਰਨਾ (ਨਾ ਕਿ ਮੋਬਾਈਲਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਤੁਸੀਂ ਉਹਨਾਂ ਸੈੱਲਾਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ ਜੋ ਤੁਹਾਡੇ ਨਾਲ ਇੱਕ ਕਿਨਾਰੇ ਸਾਂਝੇ ਕਰਦੇ ਹਨ।ਕਿਸੇ ਵੀ ਸੈੱਲ ਤੋਂ, ਅਤੇ ਹਰ ਕਦਮ ਵਿੱਚ ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਗੁਆਂਢੀ ਸੈੱਲਾਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ, ਤੁਹਾਨੂੰ ਗਰਿੱਡ ਵਿੱਚ ਲੰਬਾਈ k ਦਾ ਘੱਟੋ ਘੱਟ ਮਾਰਗ ਲੱਭਣਾ ਹੈ. ਤੁਸੀਂ ਸ਼ੁਰੂ ਕਰ ਸਕਦੇ ਹੋ ਗ੍ਰੇਡ ਦੇ ਸੈੱਲਾਂ ਵਿੱਚ ਬਿਲਕੁਲ ਇੱਕ ਵਾਰ ਸ਼ਾਮਲ ਹੁੰਦਾ ਹੈ।ਗਰਿੱਡ ਦੇ ਹਰੇਕ ਸੈੱਲ ਵਿੱਚ ਇੱਕ ਮੁੱਲ ਹੁੰਦਾ ਹੈ। [1, N * N] ਦੀ ਸੀਮਾ ਵਿੱਚ ਹਰ ਪੂਰਨ ਅੰਕ N ਕਤਾਰਾਂ ਅਤੇ N ਕਾਲਮਾਂ (N >= 2) ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k, ਨਾਲ ਇੱਕ ਗਰਿੱਡ ਦਿੱਤੀ ਗਈ ਹੈ, # >>> minPath(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3)\n# c(1, 2, 1)\n# >>> minPath(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1)\n# c(1)\nminPath <- function(grid, k) {","canonical_solution":"minPath <- function(grid, k) {\n  N <- length(grid)\n  directions <- list(c(0, 1), c(1, 0), c(0, -1), c(-1, 0))\n  \n  is_valid <- function(x, y) {\n    return(x >= 1 && x <= N && y >= 1 && y <= N)\n  }\n  \n  # DFS to find all paths\n  dfs <- function(x, y, path) {\n    if (length(path) == k) {\n      paths <<- append(paths, list(path))\n      return()\n    }\n    \n    for (direction in directions) {\n      nx <- x + direction[1]\n      ny <- y + direction[2]\n      if (is_valid(nx, ny)) {\n        dfs(nx, ny, c(path, grid[[nx]][[ny]]))\n      }\n    }\n  }\n  \n  paths <- list()\n  \n  # Start from every cell\n  for (i in 1:N) {\n    for (j in 1:N) {\n      dfs(i, j, c(grid[[i]][[j]]))\n    }\n  }\n  \n  # Find and return the lexicographically smallest path\n  min_path <- paths[[1]]\n  for (path in paths) {\n    if (path < min_path) {\n      min_path <- path\n    }\n  }\n  \n  return(min_path)\n}","tests":"test_humaneval <- function() {\n    candidate <- minPath\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3), c(1, 2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4), c(5, 6, 7, 8), c(9, 10, 11, 12), c(13, 14, 15, 16)), 4), c(1, 2, 1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(6, 4, 13, 10), c(5, 7, 12, 1), c(3, 16, 11, 15), c(8, 14, 9, 2)), 7), c(1, 10, 1, 10, 1, 10, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(8, 14, 9, 2), c(6, 4, 13, 15), c(5, 7, 1, 12), c(3, 10, 11, 16)), 5), c(1, 7, 1, 7, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(11, 8, 7, 2), c(5, 16, 14, 4), c(9, 3, 15, 6), c(12, 13, 10, 1)), 9), c(1, 6, 1, 6, 1, 6, 1, 6, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(12, 13, 10, 1), c(9, 3, 15, 6), c(5, 16, 14, 4), c(11, 8, 7, 2)), 12), c(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(2, 7, 4), c(3, 1, 5), c(6, 8, 9)), 8), c(1, 3, 1, 3, 1, 3, 1, 3))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(6, 1, 5), c(3, 8, 9), c(2, 7, 4)), 8), c(1, 5, 1, 5, 1, 5, 1, 5))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2), c(3, 4)), 10), c(1, 2, 1, 2, 1, 2, 1, 2, 1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 3), c(3, 2)), 10), c(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_130","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਟ੍ਰਿਬੋਨੈਕਸੀ ਲੜੀ ਦੇ ਪਹਿਲੇ n + 1 ਨੰਬਰ. ਤੁਹਾਨੂੰ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਇੱਕ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਪਵੇਗੀ = 2 + 3 + 3 = 8 ਤ੍ਰਿਏਕ (3) = ਤ੍ਰਿਏਕ (2) + ਤ੍ਰਿਏਕ (1) + ਤ੍ਰਿਏਕ (4)ਤ੍ਰਿ) = 3 tri(2) = 1 + (2 \/ 2) = 2 ਉਦਾਹਰਣ ਲਈ: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ਜੇ n ਅਜੀਬ ਹੈ. tri (n) = 1 + n \/ 2, ਜੇ n ਜਮ੍ਹਾ ਹੈ. tri(1) = 3 ਟ੍ਰਿਬੋਨੈਕਸੀ ਕ੍ਰਮ ਨੂੰ ਮੁੜ-ਉਪਲੱਬਧਤਾ ਦੁਆਰਾ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ ਪਰ, ਜੋ ਲੋਕ ਨਹੀਂ ਜਾਣਦੇ ਉਹ ਹੈ ਟ੍ਰਿਬੋਨੈਕਸੀ ਕ੍ਰਮ।ਹਰ ਕੋਈ ਫਿਬੋਨਾਚੀ ਕ੍ਰਮ ਨੂੰ ਜਾਣਦਾ ਹੈ, ਇਸ ਦਾ ਗਣਿਤ ਵਿਗਿਆਨੀਆਂ ਦੁਆਰਾ ੧ ਵਿੱਚ ਡੂੰਘਾ ਅਧਿਐਨ ਕੀਤਾ ਗਿਆ ਸੀ # >>> tri(3)\n# c(1, 3, 2, 8)\ntri <- function(n) {","canonical_solution":"tri <- function(n) {\n  if (n == 0) return(c(3))\n  \n  tribonacci <- numeric(n + 1)\n  tribonacci[1] <- 3\n  \n  for (i in 2:(n + 1)) {\n    if (i %% 2 == 0) {\n      tribonacci[i] <- 1 + i \/ 2\n    } else {\n      if (i == 3) {\n        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1]  # tri(3) requires tri(4)\n      } else {\n        # When i > 3 and i is odd, dependencies are always available\n        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3 + 2]  # i + 1 becomes i - 3 + 2\n      }\n    }\n  }\n  \n  return(tribonacci)\n}","tests":"test_humaneval <- function() {\n    candidate <- tri\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))\n    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))\n    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))\n    stopifnot(isTRUE(all.equal(candidate(0), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_131","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: 0 ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸਾਰੇ ਅੰਕ ਜੋੜੇ ਹਨ।ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਅਜੀਬ ਅੰਕ ਦੇ ਉਤਪਾਦ ਨੂੰ ਵਾਪਸ ਕਰੋ. # >>> digits(1)\n# 1\n# >>> digits(4)\n# 0\n# >>> digits(235)\n# 15\ndigits <- function(n) {","canonical_solution":"digits <- function(n) {\n  # Convert the number to a character vector\n  digits_vector <- unlist(strsplit(as.character(n), \"\"))\n  \n  # Convert the character vector back to numeric\n  digits_vector <- as.numeric(digits_vector)\n  \n  # Filter out the odd digits\n  odd_digits <- digits_vector[digits_vector %% 2 != 0]\n  \n  # If all digits are even, return 0\n  if (length(odd_digits) == 0) {\n    return(0)\n  }\n  \n  # Calculate and return the product of odd digits\n  return(prod(odd_digits))\n}","tests":"test_humaneval <- function() {\n    candidate <- digits\n    stopifnot(isTRUE(all.equal(candidate(5), 5)))\n    stopifnot(isTRUE(all.equal(candidate(54), 5)))\n    stopifnot(isTRUE(all.equal(candidate(120), 1)))\n    stopifnot(isTRUE(all.equal(candidate(5014), 5)))\n    stopifnot(isTRUE(all.equal(candidate(98765), 315)))\n    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))\n    stopifnot(isTRUE(all.equal(candidate(2468), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_132","nl":"pan_Guru","pl":"r","prompt":"ਜਿੱਥੇ ਕਿ ਘੱਟੋ-ਘੱਟ ਇੱਕ ਬ੍ਰੇਕ ਵਿੱਚ ਉਪ-ਕ੍ਰਮ ਵਿੱਚ ਘੇਰਿਆ ਹੋਇਆ ਹੈ।ਫੰਕਸ਼ਨ ਨੂੰ TRUE ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ ਅਤੇ ਕੇਵਲ ਜੇਕਰ ਬਰੈਕਟਾਂ ਦਾ ਇੱਕ ਵੈਧ ਉਪ-ਕ੍ਰਮ ਹੈ ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਿਰਫ ਵਰਗ ਬਰੈਕਟ ਹੁੰਦੇ ਹਨ.# >>> is_nested('[[]]')\n# TRUE\n# >>> is_nested('[]]]]]]][[[[[]')\n# FALSE\n# >>> is_nested('[][]')\n# FALSE\n# >>> is_nested('[]')\n# FALSE\n# >>> is_nested('[[][]]')\n# TRUE\n# >>> is_nested('[[]][[')\n# TRUE\nis_nested <- function(string) {","canonical_solution":"is_nested <- function(string) {\n  open_count <- 0\n  for (char in unlist(strsplit(string, \"\"))) {\n    if (char == \"[\") {\n      open_count <- open_count + 1\n    } else if (char == \"]\") {\n      if (open_count > 1) {\n        return(TRUE)\n      }\n      open_count <- open_count - 1\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_nested\n    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_133","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਸੂਚੀ ਵਿੱਚ ਹਰੇਕ ਤੱਤ ਨੂੰ ਪਹਿਲਾਂ ਉਪਰਲੇ int ((ceiling) ਤੱਕ ਗੋਲ ਕਰੋ।ਤੁਹਾਨੂੰ ਦਿੱਤੇ ਗਏ ਸੂਚੀ ਵਿੱਚ ਨੰਬਰ ਦੇ ਵਰਗ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ, ਤੁਹਾਨੂੰ ਨੰਬਰਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ।# >>> lst(c(1.0, 2.0, 3.0))\n# 14\n# >>> lst(c(1.0, 4.0, 9.0))\n# 98\n# >>> lst(c(1.0, 3.0, 5.0, 7.0))\n# 84\n# >>> lst(c(1.4, 4.2, 0.0))\n# 29\n# >>> lst(c(-2.4, 1.0, 1.0))\n# 6\nsum_squares <- function(lst) {","canonical_solution":"sum_squares <- function(lst) {\n  sum(ceiling(lst)^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_squares\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))\n    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))\n    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_134","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਨੋਟਃ \"ਵਰਡ\" ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਅੱਖਰਾਂ ਦਾ ਸਮੂਹ ਹੈ।ਇੱਕ ਸ਼ਬਦ ਦਾ ਇੱਕ ਹਿੱਸਾ, ਅਤੇ ਹੋਰ FALSE. ਇੱਕ ਦਿੱਤੇ ਗਏ ਸਤਰ ਦਾ ਇੱਕ ਵਰਣਮਾਲਾ ਅੱਖਰ ਹੈ ਅਤੇ  ਨਹੀਂ ਹੈਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਆਖਰੀ ਅੱਖਰ  ਹੈ# >>> check_if_last_char_is_a_letter('apple pie')\n# FALSE\n# >>> check_if_last_char_is_a_letter('apple pi e')\n# TRUE\n# >>> check_if_last_char_is_a_letter('apple pi e ')\n# FALSE\n# >>> check_if_last_char_is_a_letter('')\n# FALSE\ncheck_if_last_char_is_a_letter <- function(txt) {","canonical_solution":"check_if_last_char_is_a_letter <- function(txt) {\n  # Trim any trailing whitespace\n  trimmed_txt <- trimws(txt, which = \"right\")\n  \n  # If the trimmed text is empty, return FALSE\n  if (nchar(trimmed_txt) == 0) {\n    return(FALSE)\n  }\n  \n  # Get the last character\n  last_char <- substr(trimmed_txt, nchar(trimmed_txt), nchar(trimmed_txt))\n  \n  # Check if the last character is an alphabetical character\n  if (grepl(\"[a-zA-Z]\", last_char)) {\n    # Split the text by spaces\n    words <- strsplit(trimmed_txt, \" \")[[1]]\n    # Get the last word\n    last_word <- tail(words, n = 1)\n    # If last character is the only character in the last \"word\", return TRUE\n    # Otherwise, it is part of a word, return FALSE\n    return(nchar(last_word) == 1)\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- check_if_last_char_is_a_letter\n    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_135","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਡੁਪਲੀਕੇਟ ਮੁੱਲ।ਕੋਈ ਅਜਿਹਾ ਤੱਤ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਵਾਪਸੀ -1. ਦਿੱਤਾ ਗਿਆ ਵੈਕਟਰ ਵਿੱਚ ਸ਼ਾਮਲ ਨਹੀਂ ਹੋਵੇਗਾ ਤੋਂ ਵੱਧ ਜਾਂ ਬਰਾਬਰ ਨਹੀਂ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਕਿਸੇ ਐਲੀਮੈਂਟ ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਇੰਡੈਕਸ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ # >>> can_arrange(c(1, 2, 4, 3, 5))\n# 3\n# >>> can_arrange(c(1, 2, 3))\n# -1\ncan_arrange <- function(arr) {","canonical_solution":"can_arrange <- function(arr) {\n  for (i in seq(length(arr) - 1, 1)) {\n    if (arr[i] > arr[i + 1]) {\n      return(i)\n    }\n  }\n  return(-1)\n}","tests":"test_humaneval <- function() {\n    candidate <- can_arrange\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c()), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_136","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਜੇ ਕੋਈ ਨਕਾਰਾਤਮਕ ਜਾਂ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ, ਤਾਂ ਉਹਨਾਂ ਨੂੰ NULL ਦੇ ਤੌਰ ਤੇ ਵਾਪਸ ਕਰੋ.ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਗਿਣਤੀ।ਸਭ ਤੋਂ ਵੱਡਾ ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਹੈ, ਅਤੇ 'ਬੀ' ਸਭ ਤੋਂ ਛੋਟਾ ਹੈ ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸੂਚੀ (a, b) ਵਾਪਸ ਕਰਦੀ ਹੈ, ਜਿੱਥੇ 'a'  ਹੈ# >>> largest_smallest_integers(c(2, 4, 1, 3, 5, 7))\n# list(NULL, 1)\n# >>> largest_smallest_integers(c())\n# list(NULL, NULL)\n# >>> largest_smallest_integers(c(0))\n# list(NULL, NULL)\nlargest_smallest_integers <- function(lst) {","canonical_solution":"largest_smallest_integers <- function(lst) {\n  negatives <- lst[lst < 0]\n  positives <- lst[lst > 0]\n  \n  largest_negative <- if(length(negatives) > 0) max(negatives) else NULL\n  smallest_positive <- if(length(positives) > 0) min(positives) else NULL\n  \n  list(largest_negative, smallest_positive)\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_smallest_integers\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7)), list(NULL, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7, 0)), list(NULL, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, -2)), c(-2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 3, 6, 2, 7, -7)), c(-7, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 3, 8, 4, 9, 2, 5, -9)), c(-9, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c()), list(NULL, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(0)), list(NULL, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6)), list(-1, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6, 0)), list(-1, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, 1)), c(-3, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, -100, 1)), c(-3, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_137","nl":"pan_Guru","pl":"r","prompt":"ਨੋਟਃ ਜੇਕਰ ਇੱਕ ਅਸਲੀ ਸੰਖਿਆ ਨੂੰ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਦਰਸਾਇਆ ਗਿਆ ਹੈ, ਤਾਂ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਹੋ ਸਕਦਾ ਹੈ . ਜਾਂ , ਜੇ ਮੁੱਲ ਬਰਾਬਰ ਹਨ ਤਾਂ NULL ਵਾਪਸ ਕਰੋ।ਅਸਲ ਨੰਬਰ, ਅਤੇ ਇਸ ਦੇ ਦਿੱਤੇ ਗਏ ਵੇਰੀਏਬਲ ਕਿਸਮ ਵਿੱਚ ਵੱਡਾ ਵੇਰੀਏਬਲ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਪੂਰਨ ਅੰਕ, ਫਲੋਟਸ, ਜਾਂ ਸਤਰਾਂ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ # >>> compare_one(1, 2.5)\n# 2.5\n# >>> compare_one(1, '2,3')\n# '2,3'\n# >>> compare_one('5,1', '6')\n# '6'\n# >>> compare_one('1', 1)\n# NULL\ncompare_one <- function(a, b) {","canonical_solution":"compare_one <- function(a, b) {\n  to_number <- function(x) {\n    if (is.character(x)) {\n      x <- gsub(\",\", \".\", x)\n      as.numeric(x)\n    } else {\n      as.numeric(x)\n    }\n  }\n  \n  a_num <- to_number(a)\n  b_num <- to_number(b)\n  \n  if (a_num == b_num) {\n    return(NULL)\n  } else if (a_num > b_num) {\n    return(a)\n  } else {\n    return(b)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- compare_one\n    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))\n    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))\n    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))\n    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))\n    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))\n    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_138","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ ਮੁਲਾਂਕਣ ਕਰੋ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ n ਨੂੰ ਬਿਲਕੁਲ 4 ਸਕਾਰਾਤਮਕ ਜੋੜ ਸੰਖਿਆਵਾਂ ਦੇ ਜੋੜ ਦੇ ਰੂਪ ਵਿੱਚ ਲਿਖਿਆ ਜਾ ਸਕਦਾ ਹੈ # >>> is_equal_to_sum_even(4)\n# FALSE\n# >>> is_equal_to_sum_even(6)\n# FALSE\n# >>> is_equal_to_sum_even(8)\n# TRUE\nis_equal_to_sum_even <- function(n) {","canonical_solution":"is_equal_to_sum_even <- function(n) {\n  if (n <= 0 || n %% 2 != 0 || n < 8) {\n    return(FALSE)\n  }\n  remaining_sum <- n\n  count <- 0\n  for (i in seq(2, n, by = 2)) {\n    if (remaining_sum - i >= 2 * (4 - count - 1)) {\n      remaining_sum <- remaining_sum - i\n      count <- count + 1\n    }\n    if (count == 4) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}\n\n# Examples\nis_equal_to_sum_even(4)   # FALSE\nis_equal_to_sum_even(6)   # FALSE\nis_equal_to_sum_even(8)   # TRUE","tests":"test_humaneval <- function() {\n    candidate <- is_equal_to_sum_even\n    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_139","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਜਿੱਥੇ n > 0 ਬ੍ਰਾਜ਼ੀਲੀਅਨ_ਫੈਕਟੋਰੀਅਲ (n) = n! * (n-1)! * (n-2)! * ... * 1! ਬ੍ਰਾਜ਼ੀਲ ਦੇ ਫੈਕਟਰੀਅਲ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ # >>> special_factorial(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\nspecial_factorial <- function(n) {","canonical_solution":"special_factorial <- function(n) {\n  result <- 1\n  for (i in 1:n) {\n    result <- result * factorial(i)\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- special_factorial\n    stopifnot(isTRUE(all.equal(candidate(4), 288)))\n    stopifnot(isTRUE(all.equal(candidate(5), 34560)))\n    stopifnot(isTRUE(all.equal(candidate(7), 125411328000)))\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_140","nl":"pan_Guru","pl":"r","prompt":"ਫਿਰ ਸਾਰੇ ਲਗਾਤਾਰ ਸਪੇਸਾਂ ਨੂੰ -  ਨਾਲ ਬਦਲੋਅਤੇ ਜੇਕਰ ਇੱਕ ਸਤਰ ਵਿੱਚ 2 ਤੋਂ ਵੱਧ ਲਗਾਤਾਰ ਸਪੇਸ ਹਨ, ਇੱਕ ਟੈਕਸਟ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਇਸ ਵਿੱਚ ਸਾਰੇ ਸਪੇਸਾਂ ਨੂੰ ਅੰਡਰਸਕੋਰ ਨਾਲ ਬਦਲੋ, # >>> fix_spaces(' Example')\n# 'Example'\n# >>> fix_spaces(' Example 1')\n# 'Example_1'\n# >>> fix_spaces(' Example 2')\n# '_Example_2'\n# >>> fix_spaces(' Example 3')\n# '_Example-3'\nfix_spaces <- function(text) {","canonical_solution":"fix_spaces <- function(text) {\n  # Trim leading and trailing spaces\n  text <- trimws(text)\n  # Replace 3 or more consecutive spaces with a dash\n  text <- gsub(\" {3,}\", \"-\", text)\n  # Replace remaining spaces with underscores\n  text <- gsub(\" \", \"_\", text)\n  return(text)\n}","tests":"test_humaneval <- function() {\n    candidate <- fix_spaces\n    stopifnot(isTRUE(all.equal(candidate('Example'), 'Example')))\n    stopifnot(isTRUE(all.equal(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')))\n    stopifnot(isTRUE(all.equal(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')))\n    stopifnot(isTRUE(all.equal(candidate('Exa   mple'), 'Exa-mple')))\n    stopifnot(isTRUE(all.equal(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_141","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ - ਡੌਟ ਤੋਂ ਬਾਅਦ ਸਬਸਟ੍ਰਿੰਗ ਇਹਨਾਂ ਵਿੱਚੋਂ ਇੱਕ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈਃ ['txt', 'exe', 'dll'] ਲਾਤੀਨੀ ਅੱਖਰ ('a'-'z' ਅਤੇ 'A'-'Z').- ਡੌਟ ਤੋਂ ਪਹਿਲਾਂ ਸਬਸਟ੍ਰਿੰਗ ਖਾਲੀ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ, ਅਤੇ ਇਹ  ਤੋਂ ਇੱਕ ਅੱਖਰ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ- ਫਾਈਲ ਦੇ ਨਾਮ ਵਿੱਚ ਬਿਲਕੁਲ ਇੱਕ ਬਿੰਦੀ ਹੈ '.'- ਫਾਈਲ ਦੇ ਨਾਮ ਵਿੱਚ ਤਿੰਨ ਤੋਂ ਵੱਧ ਅੰਕ ('0'-'9') ਨਹੀਂ ਹੋਣੇ ਚਾਹੀਦੇ।ਨੂੰ ਪੂਰਾ ਕੀਤਾ ਜਾਂਦਾ ਹੈ: ਇੱਕ ਫਾਈਲ ਦਾ ਨਾਮ ਵੈਧ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਅਤੇ ਕੇਵਲ ਜੇਕਰ ਹੇਠ ਲਿਖੀਆਂ ਸਾਰੀਆਂ ਸ਼ਰਤਾਂ ਪੂਰੀਆਂ ਹੁੰਦੀਆਂ ਹਨ 'ਹਾਂ' ਜੇ ਫਾਈਲ ਦਾ ਨਾਮ ਠੀਕ ਹੈ, ਅਤੇ 'ਨਹੀਂ' ਵਾਪਸ ਕਰਦਾ ਹੈ।ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਫਾਈਲ ਦੇ ਨਾਮ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਸਤਰ ਲੈਂਦੀ ਹੈ, ਅਤੇ ਵਾਪਸ ਕਰਦੀ ਹੈ # >>> file_name_check('example.txt')\n# 'Yes'\n# >>> file_name_check('1example.dll')\n# 'No'\nfile_name_check <- function(file_name) {","canonical_solution":"file_name_check <- function(file_name) {\n  # Split the file name into the name part and the extension part\n  parts <- strsplit(file_name, \"\\\\.\", fixed = TRUE)[[1]]\n  \n  # Check there is exactly one dot\n  if (length(parts) != 2) {\n    return('No')\n  }\n  \n  # Extract the name and extension\n  name_part <- parts[1]\n  ext_part <- parts[2]\n  \n  # Check the extension is valid\n  if (!(ext_part %in% c('txt', 'exe', 'dll'))) {\n    return('No')\n  }\n  \n  # Check the name part is not empty and starts with a letter\n  if (nchar(name_part) == 0 || !grepl(\"^[A-Za-z]\", name_part)) {\n    return('No')\n  }\n  \n  # Count digits in the name part\n  digit_count <- nchar(gsub(\"[^0-9]\", \"\", name_part))\n  \n  # Check there are no more than three digits\n  if (digit_count > 3) {\n    return('No')\n  }\n  \n  return('Yes')\n}","tests":"test_humaneval <- function() {\n    candidate <- file_name_check\n    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('\/this_is_valid.dll'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_142","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਸੂਚੀ ਵਿੱਚ ਉਹ ਐਂਟਰੀਆਂ ਬਦਲੋ ਜਿਨ੍ਹਾਂ ਦੇ ਇੰਡੈਕਸ 3 ਜਾਂ 4 ਦੇ ਗੁਣਾ ਨਹੀਂ ਹਨ। ਫੰਕਸ਼ਨ ਫਿਰ ਸਾਰੀਆਂ ਐਂਟਰੀਆਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੇਗਾ।3 ਦਾ ਬਹੁਲ ਹੈ ਅਤੇ ਪੂਰਨ ਅੰਕ ਇੰਦਰਾਜ਼ ਨੂੰ ਘਣ ਕਰੇਗਾ ਜੇਕਰ ਇਸ ਦਾ ਸੂਚਕ 4 ਦਾ ਬਹੁਲ ਹੈ ਅਤੇ 3 ਦਾ ਬਹੁਲ ਨਹੀਂ ਹੈ. ਫੰਕਸ਼ਨ ਨਹੀਂ ਕਰੇਗਾ ਇਹ ਫੰਕਸ਼ਨ ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਲਵੇਗਾ। ਸੂਚੀ ਵਿੱਚ ਸਾਰੀਆਂ ਐਂਟਰੀਆਂ ਲਈ, ਫੰਕਸ਼ਨ ਪੂਰਨ ਅੰਕ ਐਂਟਰੀ ਨੂੰ ਵਰਗ ਦੇਵੇਗੀ ਜੇ ਇਸਦਾ ਇੰਡੈਕਸ ਇੱਕ  ਹੈ।\" # >>> lst\n# c(1, 2, 3)\n# >>> lst\n# c()\n# >>> lst\n# c(-1, -5, 2, -1, -5)\nsum_squares <- function(lst) {","canonical_solution":"sum_squares <- function(lst) {\n  lst <- sapply(seq_along(lst), function(i) {\n    if (i %% 3 == 0) {\n      return(lst[i]^2)\n    } else if (i %% 4 == 0) {\n      return(lst[i]^3)\n    } else {\n      return(lst[i])\n    }\n  })\n  return(sum(lst))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_squares\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 9)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 1, 1, 1, 1, 1)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -1, -1, -1, -1, -1, -1, -1, -1)), -3)))\n    stopifnot(isTRUE(all.equal(candidate(c(0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -5, 2, -1, -5)), -126)))\n    stopifnot(isTRUE(all.equal(candidate(c(-56, -99, 1, 0, -2)), 3030)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 0, 0, 0, 0, 0, 0, -1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)), -14196)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)), -1448)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_143","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ 1: ਨਵੇਂ ਸਤਰ ਵਿੱਚ ਸ਼ਬਦਾਂ ਦਾ ਕ੍ਰਮ ਮੂਲ ਸਤਰ ਦੇ ਸਮਾਨ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।ਜਿਸ ਦੀ ਲੰਬਾਈ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹਨ, ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਪਵੇਗੀ ਜਿਸ ਵਿੱਚ ਮੂਲ ਵਾਕ ਦੇ ਸ਼ਬਦ ਸ਼ਾਮਲ ਹਨ, ਵਾਕ ਵਿੱਚ ਕੁਝ ਸ਼ਬਦ ਹਨ ਜੋ ਇੱਕ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ ਹਨ, ਤੁਹਾਨੂੰ ਇੱਕ ਵਾਕ ਨੂੰ ਦਰਸਾਉਣ ਵਾਲੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ, # >>> words_in_sentence('This is a test')\n# 'is'\n# Example 2:\n# >>> words_in_sentence('lets go for swimming')\n# 'go for'\n# Constraints:\n#     * 1 <= len(sentence) <= 100\n#     * sentence contains only letters\nwords_in_sentence <- function(sentence) {","canonical_solution":"words_in_sentence <- function(sentence) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n == 2) return(TRUE)\n    for (i in 2:sqrt(n)) {\n      if (n %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  words <- strsplit(sentence, \" \")[[1]]\n  prime_words <- words[sapply(words, function(word) is_prime(nchar(word)))]\n  return(paste(prime_words, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- words_in_sentence\n    stopifnot(isTRUE(all.equal(candidate('This is a test'), 'is')))\n    stopifnot(isTRUE(all.equal(candidate('lets go for swimming'), 'go for')))\n    stopifnot(isTRUE(all.equal(candidate('there is no place available here'), 'there is no place')))\n    stopifnot(isTRUE(all.equal(candidate('Hi I am Hussein'), 'Hi am Hussein')))\n    stopifnot(isTRUE(all.equal(candidate('go for it'), 'go for it')))\n    stopifnot(isTRUE(all.equal(candidate('here'), '')))\n    stopifnot(isTRUE(all.equal(candidate('here is'), 'is')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_144","nl":"pan_Guru","pl":"r","prompt":"ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ x, ਅਤੇ n ਜਾਇਜ਼ ਭਿੰਨ ਹਨ, ਅਤੇ ਨਾਮਾਤਰ ਦੇ ਤੌਰ ਤੇ ਜ਼ੀਰੋ ਨਹੀਂ ਹੈ.<ਅੰਕ>\/<ਅੰਕ> ਜਿੱਥੇ ਕਿ ਦੋਵੇਂ ਅੰਕਾਂ ਅਤੇ ਨਾਮਾਂਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਹਨ।x ਅਤੇ n, ਦੋਵੇਂ ਹੀ ਇੱਕ ਭੰਡਾਰ ਦੀ ਸਤਰ ਪ੍ਰਤੀਨਿਧਤਾ ਹਨ, ਅਤੇ ਇਹਨਾਂ ਦਾ ਹੇਠਲਾ ਫਾਰਮੈਟ ਹੈ, x * n. ਫੰਕਸ਼ਨ TRUE ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ x * n ਇੱਕ ਪੂਰਨ ਅੰਕ ਅਤੇ FALSE ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰਨਾ ਹੈ ਜੋ ਸਮੀਕਰਨ ਨੂੰ ਸਰਲ ਬਣਾਏਗਾ # >>> simplify('1\/5', '5\/1')\n# TRUE\n# >>> simplify('1\/6', '2\/1')\n# FALSE\n# >>> simplify('7\/10', '10\/2')\n# FALSE\nsimplify <- function(x, n) {","canonical_solution":"simplify <- function(x, n) {\n  parse_fraction <- function(fraction) {\n    parts <- strsplit(fraction, \"\/\")[[1]]\n    return(as.numeric(parts[1]) \/ as.numeric(parts[2]))\n  }\n  \n  x_value <- parse_fraction(x)\n  n_value <- parse_fraction(n)\n  \n  product <- x_value * n_value\n  \n  # Check if the product is a whole number\n  return(product == floor(product))\n}","tests":"test_humaneval <- function() {\n    candidate <- simplify\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '5\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/6', '2\/1'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('5\/1', '3\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('7\/10', '10\/2'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/10', '50\/10'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('7\/2', '4\/2'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('11\/6', '6\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/3', '5\/2'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('5\/2', '3\/5'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/4', '8\/4'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/4', '4\/2'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '5\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '1\/5'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_145","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਉਹਨਾਂ ਨੂੰ ਮੂਲ ਸੂਚੀ ਵਿੱਚ ਉਹਨਾਂ ਦੇ ਇੰਡੈਕਸ ਦੇ ਆਧਾਰ ਤੇ ਕ੍ਰਮਬੱਧ ਕਰੋ।ਨੋਟਃ ਜੇ ਕਈ ਆਈਟਮਾਂ ਹਨ ਜਿਨ੍ਹਾਂ ਦੇ ਅੰਕ ਦਾ ਜੋੜ ਸਮਾਨ ਹੈ, ਉਨ੍ਹਾਂ ਦੇ ਅੰਕਾਂ ਦੇ ਜੋੜ ਦੇ ਅਨੁਸਾਰ ਵੱਧਦੇ ਕ੍ਰਮ ਵਿੱਚ।ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਪੂਰਨ ਅੰਕ ਦੀ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰੇ # >>> order_by_points(c(1, 11, -1, -11, -12))\n# c(-1, -11, 1, -12, 11)\n# >>> order_by_points(c())\n# c()\norder_by_points <- function(nums) {","canonical_solution":"order_by_points <- function(nums) {\n  # Helper function to calculate the sum of digits\n  sum_of_digits <- function(n) {\n    sum(as.integer(unlist(strsplit(as.character(abs(n)), \"\"))))\n  }\n  \n  # Order the numbers based on the sum of their digits first, \n  # and then by their original index\n  indices <- seq_along(nums)\n  nums[order(sapply(nums, sum_of_digits), indices)]\n}","tests":"test_humaneval <- function() {\n    candidate <- order_by_points\n    stopifnot(isTRUE(all.equal(candidate(c(1, 11, -1, -11, -12)), c(-1, -11, 1, -12, 11))))\n    stopifnot(isTRUE(all.equal(candidate(c(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)), c(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -11, -32, 43, 54, -98, 2, -3)), c(-3, -32, -98, -11, 1, 2, 43, 54))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), c(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 6, 6, -76, -21, 23, 4)), c(-76, -21, 0, 4, 23, 6, 6))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_146","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਇੱਕ ਸੰਖਿਆ ਦੇ ਪਹਿਲੇ ਅਤੇ ਆਖਰੀ ਅੰਕ ਅਜੀਬ ਹਨ (1, 3, 5, 7, 9).ਵੈਕਟਰ ਵਿਚ ਤੱਤ ਦੀ ਗਿਣਤੀ ਹੈ, ਜੋ ਕਿ ਵੱਧ 10 ਅਤੇ ਦੋਨੋ ਹਨ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੰਪੁੱਟ ਅਤੇ ਰਿਟਰਨ ਦੇ ਤੌਰ ਤੇ ਸੰਖਿਆਵਾਂ ਦਾ ਇੱਕ ਵੈਕਟਰ ਲੈਂਦਾ ਹੈ # >>> specialFilter(c(15, -73, 14, -15))\n# 1\n# >>> specialFilter(c(33, -2, -3, 45, 21, 109))\n# 2\nspecialFilter <- function(nums) {","canonical_solution":"specialFilter <- function(nums) {\n  # Helper function to check if both first and last digits are odd\n  are_first_last_digits_odd <- function(x) {\n    str_num <- as.character(abs(x))\n    first_digit <- as.numeric(substr(str_num, 1, 1))\n    last_digit <- as.numeric(substr(str_num, nchar(str_num), nchar(str_num)))\n    first_digit %% 2 == 1 && last_digit %% 2 == 1\n  }\n\n  # Filter numbers greater than 10 with both first and last digits odd\n  filtered_nums <- nums[nums > 10 & sapply(nums, are_first_last_digits_odd)]\n  \n  # Return the count of such numbers\n  length(filtered_nums)\n}","tests":"test_humaneval <- function() {\n    candidate <- specialFilter\n    stopifnot(isTRUE(all.equal(candidate(c(5, -2, 1, -5)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(15, -73, 14, -15)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(33, -2, -3, 45, 21, 109)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(43, -12, 93, 125, 121, 109)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(71, -2, -33, 75, 21, 19)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_147","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨ:ਅਤੇ a[i] + a[j] + a[k] 3 ਦਾ ਗੁਣਾ ਹੈ।a ਦੇ ਤ੍ਰਿਪੋਲਾਂ ਦੀ ਗਿਣਤੀ (a[i], a[j], a[k]) ਵਾਪਸ ਕਰੋ ਜਿੱਥੇ i < j < k, ਹਰੇਕ i (1 ≤ i ≤ n) ਲਈ, a[i] = i * i - i + 1 ਦਾ ਮੁੱਲ।ਤੁਹਾਨੂੰ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਨੂੰ ਲੰਬਾਈ n ਦਾ ਇੱਕ ਪੂਰਨ ਅੰਕ ਵੈਕਟਰ a ਬਣਾਉਣਾ ਹੈ।#     >>> get_max_triples(5)\n#     1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\nget_max_triples <- function(n) {","canonical_solution":"get_max_triples <- function(n) {\n  # Create the vector a according to the given rule\n  a <- sapply(1:n, function(i) i * i - i + 1)\n  \n  # Initialize the count of valid triples\n  count <- 0\n  \n  # Iterate over all possible triples (i, j, k) with i < j < k\n  for (i in 1:(n-2)) {\n    for (j in (i+1):(n-1)) {\n      for (k in (j+1):n) {\n        # Check if the sum of the selected triple is a multiple of 3\n        if ((a[i] + a[j] + a[k]) %% 3 == 0) {\n          count <- count + 1\n        }\n      }\n    }\n  }\n  \n  # Return the count of valid triples\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- get_max_triples\n    stopifnot(isTRUE(all.equal(candidate(5), 1)))\n    stopifnot(isTRUE(all.equal(candidate(6), 4)))\n    stopifnot(isTRUE(all.equal(candidate(10), 36)))\n    stopifnot(isTRUE(all.equal(candidate(100), 53361)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_148","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਸਹੀ ਗ੍ਰਹਿ ਨਾਂ ਨਹੀਂ ਹਨ।ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ ਜੇ planet1 ਜਾਂ planet2 ਸੂਰਜ ਦੇ ਨੇੜੇ ਹੋਣਾ।ਗ੍ਰਹਿ 1 ਦੀ ਘੁੰਮਣ-ਘੇਰੀ ਅਤੇ ਗ੍ਰਹਿ 2 ਦੀ ਘੁੰਮਣ-ਘੇਰੀ ਦੇ ਵਿਚਕਾਰ ਸਥਿਤ,  ਦੁਆਰਾ ਕ੍ਰਮਬੱਧਫੰਕਸ਼ਨ ਨੂੰ ਉਹਨਾਂ ਸਾਰੇ ਗ੍ਰਹਿਆਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ ਜਿਨ੍ਹਾਂ ਦੀਆਂ ਗੋਲੀਆਂ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦੋ ਗ੍ਰਹਿ ਨਾਮਾਂ ਨੂੰ ਸਤਰਾਂ ਦੇ ਰੂਪ ਵਿੱਚ ਗ੍ਰਹਿ 1 ਅਤੇ ਗ੍ਰਹਿ 2 ਦੇ ਰੂਪ ਵਿੱਚ ਲੈਂਦਾ ਹੈ.ਯੂਰੇਨਸ, ਨੈਪਚੂਨ।ਹੈ, ਅਗਲਾ ਹੈ, ਫਿਰ ਧਰਤੀ, ਮੰਗਲ, ਜੁਪੀਟਰ, ਸ਼ਨੀ,ਸਾਡੇ ਸੂਰਜੀ ਪ੍ਰਣਾਲੀ ਵਿੱਚ ਅੱਠ ਗ੍ਰਹਿ ਹਨ: ਸੂਰਜ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ# >>> bf('Jupiter', 'Neptune')\n# c('Saturn', 'Uranus')\n# >>> bf('Earth', 'Mercury')\n# 'Venus'\n# >>> bf('Mercury', 'Uranus')\n# c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\nbf <- function(planet1, planet2) {","canonical_solution":"bf <- function(planet1, planet2) {\n  planets <- c('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n  if (!(planet1 %in% planets) || !(planet2 %in% planets)) {\n    return(c())\n  }\n  \n  index1 <- which(planets == planet1)\n  index2 <- which(planets == planet2)\n  \n  if (index1 < index2) {\n    return(planets[(index1 + 1):(index2 - 1)])\n  } else if (index2 < index1) {\n    return(planets[(index2 + 1):(index1 - 1)])\n  } else {\n    return(c())\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- bf\n    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Neptune'), c('Saturn', 'Uranus'))))\n    stopifnot(isTRUE(all.equal(candidate('Earth', 'Mercury'), c('Venus'))))\n    stopifnot(isTRUE(all.equal(candidate('Mercury', 'Uranus'), c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'))))\n    stopifnot(isTRUE(all.equal(candidate('Neptune', 'Venus'), c('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'))))\n    stopifnot(isTRUE(all.equal(candidate('Earth', 'Earth'), c())))\n    stopifnot(isTRUE(all.equal(candidate('Mars', 'Earth'), c())))\n    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Makemake'), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_149","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੋਵੇਗੀ।ਫੰਕਸ਼ਨ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਵਿੱਚ ਸਤਰਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।ਜੇ ਦੋ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੈ, ਤਾਂ ਸੂਚੀ ਨੂੰ ਵਰਣਮਾਲਾ ਅਨੁਸਾਰ ਕ੍ਰਮਬੱਧ ਕਰੋ।ਇਸ ਨਿਯਮ ਦੇ ਅਨੁਸਾਰ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰ ਦੇਵੇ।ਸੂਚੀ ਦਾ ਕ੍ਰਮ ਹਰੇਕ ਸ਼ਬਦ ਦੀ ਲੰਬਾਈ ਦੇ ਅਨੁਸਾਰ ਵੱਧਣਾ ਚਾਹੀਦਾ ਹੈ, ਅਤੇ ਤੁਸੀਂ ਅਤੇ ਇਸ ਵਿੱਚ ਡੁਪਲੀਕੇਟ ਹੋ ਸਕਦੇ ਹਨ।ਸੂਚੀ ਹਮੇਸ਼ਾਂ ਸਤਰਾਂ ਦੀ ਸੂਚੀ ਹੁੰਦੀ ਹੈ ਅਤੇ ਕਦੇ ਵੀ ਸੰਖਿਆਵਾਂ ਦਾ ਵੈਕਟਰ ਨਹੀਂ ਹੁੰਦਾ, ਅਤੇ ਇੱਕ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਨਾਲ ਨਤੀਜੇ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਉਹ ਸਤਰਾਂ ਨੂੰ ਮਿਟਾ ਦਿੰਦਾ ਹੈ ਜਿਨ੍ਹਾਂ ਦੀ ਲੰਬਾਈ ਇਸ ਤੋਂ ਅਣਗਿਣਤ ਹੈ, ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਪੈਰਾਮੀਟਰ ਦੇ ਤੌਰ ਤੇ ਸਤਰਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ,# >>> list_sort(c('aa', 'a', 'aaa'))\n# c('aa')\n# >>> list_sort(c('ab', 'a', 'aaa', 'cd'))\n# c('ab', 'cd')\nsorted_list_sum <- function(lst) {","canonical_solution":"list_sort <- function(lst) {\n  # Filter out strings with odd lengths\n  filtered_list <- lst[nchar(lst) %% 2 == 0]\n  \n  # Sort the list first by length, then alphabetically\n  sorted_list <- filtered_list[order(nchar(filtered_list), filtered_list)]\n  \n  return(sorted_list)\n}","tests":"test_humaneval <- function() {\n    candidate <- sorted_list_sum\n    stopifnot(isTRUE(all.equal(candidate(c('aa', 'a', 'aaa')), c('aa'))))\n    stopifnot(isTRUE(all.equal(candidate(c('school', 'AI', 'asdf', 'b')), c('AI', 'asdf', 'school'))))\n    stopifnot(isTRUE(all.equal(candidate(c('d', 'b', 'c', 'a')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('d', 'dcba', 'abcd', 'a')), c('abcd', 'dcba'))))\n    stopifnot(isTRUE(all.equal(candidate(c('AI', 'ai', 'au')), c('AI', 'ai', 'au'))))\n    stopifnot(isTRUE(all.equal(candidate(c('a', 'b', 'b', 'c', 'c', 'a')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('aaaa', 'bbbb', 'dd', 'cc')), c('cc', 'dd', 'aaaa', 'bbbb'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_150","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ ਅਤੇ y ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਨਹੀਂ ਤਾਂ.ਇੱਕ ਸਧਾਰਨ ਪ੍ਰੋਗਰਾਮ ਜਿਸ ਨੂੰ x ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ n  ਹੈ# >>> x_or_y(7, 34, 12)\n# 34\n# >>> x_or_y(15, 8, 5)\n# 5\nx_or_y <- function(n, x, y) {","canonical_solution":"x_or_y <- function(n, x, y) {\n  is_prime <- function(num) {\n    if (num <= 1) {\n      return(FALSE)\n    }\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  \n  if (is_prime(n)) {\n    return(x)\n  } else {\n    return(y)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- x_or_y\n    stopifnot(isTRUE(all.equal(candidate(7, 34, 12), 34)))\n    stopifnot(isTRUE(all.equal(candidate(15, 8, 5), 5)))\n    stopifnot(isTRUE(all.equal(candidate(3, 33, 5212), 33)))\n    stopifnot(isTRUE(all.equal(candidate(1259, 3, 52), 3)))\n    stopifnot(isTRUE(all.equal(candidate(7919, -1, 12), -1)))\n    stopifnot(isTRUE(all.equal(candidate(3609, 1245, 583), 583)))\n    stopifnot(isTRUE(all.equal(candidate(91, 56, 129), 129)))\n    stopifnot(isTRUE(all.equal(candidate(6, 34, 1234), 1234)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 0), 0)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 0), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_151","nl":"pan_Guru","pl":"r","prompt":"ਸੂਚੀ ਵਿੱਚ ਜੋ ਅਜੀਬ ਹਨ. ਉਹ ਨੰਬਰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ ਜੋ ਨਕਾਰਾਤਮਕ ਹਨ ਜਾਂ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ.ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਸੰਖਿਆਵਾਂ ਦੇ ਵਰਗ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ # >>> double_the_difference(c(1, 3, 2, 0))\n# 10\n# >>> double_the_difference(c(-1, -2, 0))\n# 0\n# >>> double_the_difference(c(9, -2))\n# 81\n# >>> double_the_difference(c(0))\n# 0\n# If the input list is empty, return 0.\ndouble_the_difference <- function(lst) {","canonical_solution":"double_the_difference <- function(lst) {\n  # Filter out non-positive, non-integer, and non-odd numbers\n  lst <- lst[lst > 0 & lst %% 1 == 0 & lst %% 2 == 1]\n  # Calculate the sum of squares of remaining numbers\n  sum(lst^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- double_the_difference\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5.0, 4.0)), 25)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.1, 0.2, 0.3)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10.0, -20.0, -30.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0, -2.0, 8.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.2, 3.0, 5.0)), 34)))\n    stopifnot(isTRUE(all.equal(candidate(c(-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0)), 165)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_152","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਮੁੱਲ 0 ਹੈ ਅਤੇ ਜੇਕਰ ਨਹੀਂ, ਤਾਂ ਮੁੱਲ ਅਨੁਮਾਨ ਅਤੇ ਸਕੋਰ ਦੇ ਵਿਚਕਾਰ ਪੂਰਨ ਅੰਤਰ ਹੈ।ਇੱਕੋ ਲੰਬਾਈ ਦੇ ਇੱਕ ਵੈਕਟਰ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਦਰਸਾਉਂਦਾ ਹੈ ਕਿ ਹਰ ਅੰਦਾਜ਼ਾ ਕਿੰਨਾ ਦੂਰ ਸੀ. ਜੇ ਉਨ੍ਹਾਂ ਨੇ ਸਹੀ ਅੰਦਾਜ਼ਾ ਲਗਾਇਆ ਹੈ, ਤੁਹਾਨੂੰ ਬਰਾਬਰ ਲੰਬਾਈ ਦੇ ਸਕੋਰ ਅਤੇ ਅਨੁਮਾਨਾਂ ਦੇ ਦੋ ਵੈਕਟਰ ਦਿੱਤੇ ਗਏ ਹਨ, ਜਿੱਥੇ ਹਰੇਕ ਸੂਚਕ ਇੱਕ ਮੈਚ ਦਿਖਾਉਂਦਾ ਹੈ।ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਤੈਅ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਕਿਸੇ ਵਿਅਕਤੀ ਨੇ ਕਈ ਮੈਚਾਂ ਦੇ ਨਤੀਜਿਆਂ ਦਾ ਸਹੀ ਅੰਦਾਜ਼ਾ ਲਗਾਇਆ ਹੈ।ਨਿਸ਼ਚਿਤ ਤੌਰ ਤੇ ਨੋਟ ਕਰਨ ਅਤੇ ਤੁਲਨਾ ਕਰਨ ਦੇ ਯੋਗ ਹੈ।ਇਸ ਘਟਨਾ ਬਾਰੇ ਅੰਤ ਵਿੱਚ ਪਤਾ ਲੱਗ ਜਾਂਦਾ ਹੈ। ਉਸ ਸਮੇਂ ਤੁਹਾਡੇ ਕੋਲ ਜੋ ਭਾਵਨਾਵਾਂ ਅਤੇ ਵਿਚਾਰ ਹਨ ਉਹ ਹਨ ਮੈਨੂੰ ਲਗਦਾ ਹੈ ਕਿ ਸਾਨੂੰ ਸਾਰਿਆਂ ਨੂੰ ਉਹ ਭਾਵਨਾ ਯਾਦ ਹੈ ਜਦੋਂ ਕਿਸੇ ਲੰਬੇ ਸਮੇਂ ਤੋਂ ਉਡੀਕਿਆ ਹੋਇਆ ਨਤੀਜਾ# >>> compare(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2))\n# c(0, 0, 0, 0, 3, 3)\n# >>> compare(c(0, 5, 0, 0, 0, 4), c(4, 1, 1, 0, 0, -2))\n# c(4, 4, 1, 0, 0, 6)\ncompare <- function(game, guess) {","canonical_solution":"compare <- function(game, guess) {\n  abs(game - guess)\n}","tests":"test_humaneval <- function() {\n    candidate <- compare\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2)), c(0, 0, 0, 0, 3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 0, 0, 0, 0, 0), c(0, 0, 0, 0, 0, 0)), c(0, 0, 0, 0, 0, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), c(-1, -2, -3)), c(2, 4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5), c(-1, 2, 3, 4)), c(2, 0, 0, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_153","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ (ਇਸਦੀ ਤਾਕਤ -1) ਹੈ।return 'Slices.SErviNGSliCes' ਕਿਉਂਕਿ 'SErviNGSliCes' ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਹੈ ਐਕਸਟੈਂਸ਼ਨਾਂਃ ['SErviNGSliCes', 'Cheese', 'StuFfed'] ਤਾਂ ਤੁਹਾਨੂੰ ਚਾਹੀਦਾ ਹੈ ਉਦਾਹਰਣ ਦੇ ਲਈ, ਜੇ ਤੁਹਾਨੂੰ ਕਲਾਸ ਦੇ ਤੌਰ ਤੇ \"ਸਲਾਈਸ\" ਅਤੇ ਕਲਾਸ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ ਸੂਚੀ ਵਿੱਚ ਸਭ ਤੋਂ ਪਹਿਲਾਂ ਆਉਣ ਵਾਲੀ ਚੋਣ ਕਰੋ।ਜੇ ਦੋ ਜਾਂ ਜ਼ਿਆਦਾ ਐਕਸਟੈਂਸ਼ਨਾਂ ਇੱਕੋ ਜਿਹੀ ਤਾਕਤ ਨਾਲ ਹਨ, ਤਾਂ ਤੁਹਾਨੂੰ ਫਾਰਮੈਟਃ ClassName.StrongestExtensionName. ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਲੱਭਣੀ ਚਾਹੀਦੀ ਹੈ ਅਤੇ ਇਸ ਵਿੱਚ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ, ਤਾਕਤ CAP - SM ਫ੍ਰੈਕਸ਼ਨ ਦੁਆਰਾ ਦਿੱਤੀ ਗਈ ਹੈ।ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ ਅੱਖਰ, ਅਤੇ SM ਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਮੰਨ ਲਓ ਐਕਸਟੈਂਸ਼ਨ ਦੀ ਤਾਕਤ ਇਸ ਪ੍ਰਕਾਰ ਹੈਃ CAP ਨੂੰ ਵੱਡੇ ਅੱਖਰ ਦੀ ਸੰਖਿਆ ਮੰਨ ਲਓ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਵਰਤੋਂ ਕਲਾਸ ਵਿੱਚ ਵਾਧੂ ਕਲਾਸਾਂ ਨੂੰ ਲੋਡ ਕਰਨ ਲਈ ਕੀਤੀ ਜਾਣੀ ਹੈ।ਤੁਹਾਨੂੰ ਇੱਕ ਕਲਾਸ ਦਾ ਨਾਮ (ਇੱਕ ਸਤਰ) ਅਤੇ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਜਾਵੇਗੀ।# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))\n# 'my_class.AA'\nStrongest_Extension <- function(class_name, extensions) {","canonical_solution":"Strongest_Extension <- function(class_name, extensions) {\n  # Function to calculate the strength of an extension\n  extension_strength <- function(ext) {\n    cap_count <- sum(grepl(\"[A-Z]\", strsplit(ext, \"\")[[1]]))\n    sm_count <- sum(grepl(\"[a-z]\", strsplit(ext, \"\")[[1]]))\n    return(cap_count - sm_count)\n  }\n  \n  # Calculate strength for each extension and find the strongest one\n  strengths <- sapply(extensions, extension_strength)\n  max_strength_index <- which.max(strengths)\n  \n  # Construct the result string\n  return(paste0(class_name, \".\", extensions[max_strength_index]))\n}","tests":"test_humaneval <- function() {\n    candidate <- Strongest_Extension\n    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))\n    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))\n    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))\n    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))\n    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))\n    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))\n    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))\n    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))\n    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_154","nl":"pan_Guru","pl":"r","prompt":"ਤੁਹਾਨੂੰ 2 ਸ਼ਬਦ ਦਿੱਤੇ ਗਏ ਹਨ. ਤੁਹਾਨੂੰ TRUE ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ ਜੇ ਦੂਜਾ ਸ਼ਬਦ ਜਾਂ ਇਸਦੇ ਕਿਸੇ ਵੀ ਘੁੰਮਣ ਨੂੰ ਪਹਿਲੇ ਸ਼ਬਦ ਵਿੱਚ ਇੱਕ ਸਬਸਟ੍ਰਿੰਗ ਹੈ # >>> cycpattern_check('abcd', 'abd')\n# FALSE\n# >>> cycpattern_check('hello', 'ell')\n# TRUE\n# >>> cycpattern_check('whassup', 'psus')\n# FALSE\n# >>> cycpattern_check('abab', 'baa')\n# TRUE\n# >>> cycpattern_check('efef', 'eeff')\n# FALSE\n# >>> cycpattern_check('himenss', 'simen')\n# TRUE\ncycpattern_check <- function(a, b) {","canonical_solution":"cycpattern_check <- function(a, b) {\n  n <- nchar(b)\n  # Check all rotations of b\n  for (i in 0:(n-1)) {\n    # Rotate the string b by i characters\n    rotated_b <- substring(b, i+1, n) %\/% substring(b, 1, i)\n    # Check if the rotated string is a substring of a\n    if (grepl(rotated_b, a)) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- cycpattern_check\n    stopifnot(isTRUE(all.equal(candidate('xyzw', 'xyw'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('yello', 'ell'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('whattup', 'ptut'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('efef', 'fee'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abab', 'aabb'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('winemtt', 'tinem'), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_155","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਇੱਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕ੍ਰਮਵਾਰ ਜੋੜ ਅਤੇ ਅਜੀਬ ਅੰਕ ਦੀ ਗਿਣਤੀ ਹੈ. #     >>> even_odd_count(-12)\n#     c(1, 1)\n#     >>> even_odd_count(123)\n#     c(1, 2)\neven_odd_count <- function(num) {","canonical_solution":"even_odd_count <- function(num) {\n  # Handle negative numbers by taking the absolute value\n  num <- abs(num)\n  \n  # Convert the number to a character vector to access digits\n  digits <- unlist(strsplit(as.character(num), \"\"))\n  \n  # Convert character vector back to integer\n  digits <- as.integer(digits)\n  \n  # Count even digits\n  even_count <- sum(digits %% 2 == 0)\n  \n  # Count odd digits\n  odd_count <- length(digits) - even_count\n  \n  # Return a vector with even and odd counts\n  return(c(even_count, odd_count))\n}","tests":"test_humaneval <- function() {\n    candidate <- even_odd_count\n    stopifnot(isTRUE(all.equal(candidate(7), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(-78), c(1, 1))))\n    stopifnot(isTRUE(all.equal(candidate(3452), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(346211), c(3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(-345821), c(3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(-2), c(1, 0))))\n    stopifnot(isTRUE(all.equal(candidate(-45347), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(0), c(1, 0))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_156","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਃ ਪਾਬੰਦੀਆਂ: 1 <= num <= 1000 ਅਤੇ ਇਸਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਰੋਮਨ ਅੰਕਾਂ ਦੇ ਬਰਾਬਰ ਨੂੰ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਪ੍ਰਾਪਤ ਕਰੋ, # >>> int_to_mini_roman(19)\n# 'xix'\n# >>> int_to_mini_roman(152)\n# 'clii'\n# >>> int_to_mini_roman(426)\n# 'cdxxvi'\nint_to_mini_roman <- function(number) {","canonical_solution":"int_to_mini_roman <- function(number) {\n  values <- c(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n  numerals <- c(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n  \n  result <- \"\"\n  remainder <- number\n  \n  for (i in seq_along(values)) {\n    while (remainder >= values[i]) {\n      result <- paste0(result, numerals[i])\n      remainder <- remainder - values[i]\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- int_to_mini_roman\n    stopifnot(isTRUE(all.equal(candidate(19), 'xix')))\n    stopifnot(isTRUE(all.equal(candidate(152), 'clii')))\n    stopifnot(isTRUE(all.equal(candidate(251), 'ccli')))\n    stopifnot(isTRUE(all.equal(candidate(426), 'cdxxvi')))\n    stopifnot(isTRUE(all.equal(candidate(500), 'd')))\n    stopifnot(isTRUE(all.equal(candidate(1), 'i')))\n    stopifnot(isTRUE(all.equal(candidate(4), 'iv')))\n    stopifnot(isTRUE(all.equal(candidate(43), 'xliii')))\n    stopifnot(isTRUE(all.equal(candidate(90), 'xc')))\n    stopifnot(isTRUE(all.equal(candidate(94), 'xciv')))\n    stopifnot(isTRUE(all.equal(candidate(532), 'dxxxii')))\n    stopifnot(isTRUE(all.equal(candidate(900), 'cm')))\n    stopifnot(isTRUE(all.equal(candidate(994), 'cmxciv')))\n    stopifnot(isTRUE(all.equal(candidate(1000), 'm')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_157","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ 90 ਡਿਗਰੀ।ਇੱਕ ਸਿੱਧਾ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣਾ ਇੱਕ ਤਿਕੋਣਾ ਹੈ ਜਿਸ ਵਿੱਚ ਇੱਕ ਕੋਣ ਸਿੱਧਾ ਕੋਣ ਹੈ ਜਾਂਪਾਸੇ ਇੱਕ ਸਹੀ-ਕੋਣ ਵਾਲੇ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ, ਨਹੀਂ ਤਾਂ ਗਲਤ ਹੈ।ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ. TRUE ਵਾਪਸ ਕਰੋ ਜੇ ਤਿੰਨ # >>> right_angle_triangle(3, 4, 5)\n# TRUE\n# >>> right_angle_triangle(1, 2, 3)\n# FALSE\nright_angle_triangle <- function(a, b, c) {","canonical_solution":"right_angle_triangle <- function(a, b, c) {\n  # Sort the sides to easily compare the largest side\n  sides <- sort(c(a, b, c))\n  \n  # Check if the sum of squares of the two smaller sides equals the square of the largest side\n  return(sides[1]^2 + sides[2]^2 == sides[3]^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- right_angle_triangle\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(10, 6, 8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(7, 24, 25), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(5, 12, 13), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(15, 8, 17), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(48, 55, 73), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_158","nl":"pan_Guru","pl":"r","prompt":"ਅੱਖਰ, ਉਹ ਵਾਪਸ ਕਰੋ ਜੋ ਸ਼ਬਦਕੋਸ਼ਿਕ ਕ੍ਰਮ ਵਿੱਚ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ. ਵਿਲੱਖਣ ਅੱਖਰਾਂ ਦੀ ਵੱਧ ਤੋਂ ਵੱਧ ਗਿਣਤੀ ਹੈ।ਸੂਚੀ ਵਿੱਚ ਵੱਖਰੇ ਸ਼ਬਦ ਹਨ. ਵੱਧ ਤੋਂ ਵੱਧ ਗਿਣਤੀ ਵਾਲੇ ਸ਼ਬਦ ਨੂੰ ਵਾਪਸ ਕਰੋ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ।# >>> find_max(c('name', 'of', 'string'))\n# 'string'\n# >>> find_max(c('name', 'enam', 'game'))\n# 'enam'\n# >>> find_max(c('aaaaaaa', 'bb', 'cc'))\n# 'aaaaaaa'\nfind_max <- function(words) {","canonical_solution":"find_max <- function(words) {\n  max_unique_chars <- 0\n  result <- \"\"\n  \n  for (word in words) {\n    unique_chars_count <- length(unique(strsplit(word, NULL)[[1]]))\n    \n    if (unique_chars_count > max_unique_chars ||\n       (unique_chars_count == max_unique_chars && word < result)) {\n      max_unique_chars <- unique_chars_count\n      result <- word\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- find_max\n    stopifnot(isTRUE(all.equal(candidate(c('name', 'of', 'string')), 'string')))\n    stopifnot(isTRUE(all.equal(candidate(c('name', 'enam', 'game')), 'enam')))\n    stopifnot(isTRUE(all.equal(candidate(c('aaaaaaa', 'bb', 'cc')), 'aaaaaaa')))\n    stopifnot(isTRUE(all.equal(candidate(c('abc', 'cba')), 'abc')))\n    stopifnot(isTRUE(all.equal(candidate(c('play', 'this', 'game', 'of', 'footbott')), 'footbott')))\n    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'gonna', 'rock')), 'gonna')))\n    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'a', 'mad', 'nation')), 'nation')))\n    stopifnot(isTRUE(all.equal(candidate(c('this', 'is', 'a', 'prrk')), 'this')))\n    stopifnot(isTRUE(all.equal(candidate(c('b')), 'b')))\n    stopifnot(isTRUE(all.equal(candidate(c('play', 'play', 'play')), 'play')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_159","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਨਃ ਜੇ ਤੁਹਾਡੇ ਕੋਲ ਕਾਫ਼ੀ ਗਾਜਰ ਨਹੀਂ ਬਚੇ ਹਨ, ਤਾਂ ਤੁਸੀਂ ਬਾਕੀ ਸਾਰੇ ਗਾਜਰ ਖਾ ਲਓਗੇ, ਪਰ ਫਿਰ ਵੀ ਭੁੱਖੇ ਰਹੋਗੇ।ਤੁਹਾਡੇ ਖਾਣੇ ਤੋਂ ਬਾਅਦ ਬਚੇ ਹੋਏ ਗਾਜਰ ਦੀ ਗਿਣਤੀ ] ਤੁਹਾਨੂੰ [ਤੁਹਾਡੇ ਖਾਣੇ ਤੋਂ ਬਾਅਦ ਖਾਧੇ ਗਏ ਗਾਜਰ ਦੀ ਕੁੱਲ ਗਿਣਤੀ, ਪਰ ਹੁਣ ਤੁਹਾਨੂੰ ਦਿਨ ਦੇ ਖਾਣੇ ਨੂੰ ਪੂਰਾ ਕਰਨ ਲਈ ਹੋਰ ਗਾਜਰ ਖਾਣ ਦੀ ਲੋੜ ਹੈ।ਤੁਸੀਂ ਇੱਕ ਭੁੱਖਾ ਖਰਗੋਸ਼ ਹੋ, ਅਤੇ ਤੁਸੀਂ ਪਹਿਲਾਂ ਹੀ ਕੁਝ ਗਾਜਰ ਖਾ ਚੁੱਕੇ ਹੋ, # >>> eat(5, 6, 10)\n# c(11, 4)\n# >>> eat(4, 8, 9)\n# c(12, 1)\n# >>> eat(1, 10, 10)\n# c(11, 0)\n# >>> eat(2, 11, 5)\n# c(7, 0)\n# Variables:\n# @number : integer\n#     the number of carrots that you have eaten.\n# @need : integer\n#     the number of carrots that you need to eat.\n# @remaining : integer\n#     the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\neat <- function(number, need, remaining) {","canonical_solution":"eat <- function(number, need, remaining) {\n  total_eaten <- number + min(need, remaining)\n  remaining_carrots <- max(0, remaining - need)\n  return(c(total_eaten, remaining_carrots))\n}","tests":"test_humaneval <- function() {\n    candidate <- eat\n    stopifnot(isTRUE(all.equal(candidate(5, 6, 10), c(11, 4))))\n    stopifnot(isTRUE(all.equal(candidate(4, 8, 9), c(12, 1))))\n    stopifnot(isTRUE(all.equal(candidate(1, 10, 10), c(11, 0))))\n    stopifnot(isTRUE(all.equal(candidate(2, 11, 5), c(7, 0))))\n    stopifnot(isTRUE(all.equal(candidate(4, 5, 7), c(9, 2))))\n    stopifnot(isTRUE(all.equal(candidate(4, 5, 1), c(5, 0))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_160","nl":"pan_Guru","pl":"r","prompt":"ਆਪਰੇਟਰ ਸੂਚੀ ਵਿੱਚ ਘੱਟੋ ਘੱਟ ਇੱਕ ਆਪਰੇਟਰ ਹੁੰਦਾ ਹੈ, ਅਤੇ ਓਪਰੇਂਡ ਸੂਚੀ ਵਿੱਚ ਘੱਟੋ ਘੱਟ ਦੋ ਓਪਰੇਂਡ ਹੁੰਦੇ ਹਨ।ਓਪਰੇਂਡ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਸੂਚੀ ਹੈ।ਆਪਰੇਟਰ ਸੂਚੀ ਦੀ ਲੰਬਾਈ ਓਪਰੇਂਡ ਸੂਚੀ ਦੀ ਲੰਬਾਈ ਘਟਾ ਕੇ ਇੱਕ ਦੇ ਬਰਾਬਰ ਹੈ।ਨੋਟਃ => ਨਤੀਜਾ = 9 ਨਤੀਜਾ = 2 + 3 * 4 - 5 ਵੈਕਟਰ = [2, 3, 4, 5] ਆਪਰੇਟਰ['+', '*', '-'] ਉਦਾਹਰਨਃ ਐਕਸਪੋਨੈਂਸ਼ਨ (**) ਮੰਜ਼ਿਲ ਵੰਡ ( \/\/ ) ਗੁਣਾ (*) ਘਟਾਓ ( - ) ਜੋੜ (+) ਬੁਨਿਆਦੀ ਅਲਜਬਰਾ ਕਾਰਜ: ਸਮੀਕਰਨ ਅਤੇ ਇਸ ਸਮੀਕਰਨ ਦਾ ਮੁਲਾਂਕਣ ਵਾਪਸ ਕਰੋ.ਦੂਜੀ ਸੂਚੀ ਪੂਰਨ ਅੰਕ ਦੀ ਸੂਚੀ ਹੈ। ਅਲਜਬ੍ਰਿਕ ਬਣਾਉਣ ਲਈ ਦੋ ਦਿੱਤੀਆਂ ਗਈਆਂ ਸੂਚੀਆਂ ਦੀ ਵਰਤੋਂ ਕਰੋ ਦੋ ਸੂਚੀਆਂ ਆਪਰੇਟਰ ਅਤੇ ਓਪਰੇਂਡ ਦਿੱਤੀਆਂ ਗਈਆਂ ਹਨ। ਪਹਿਲੀ ਸੂਚੀ ਵਿੱਚ ਬੁਨਿਆਦੀ ਅਲਜਬਰਾ ਓਪਰੇਸ਼ਨ ਹਨ, ਅਤੇ do_algebra <- function(operator, operand) {","canonical_solution":"do_algebra <- function(operator, operand) {\n  if (length(operator) != length(operand) - 1) {\n    stop(\"The length of operator list must be equal to the length of operand list minus one.\")\n  }\n  \n  # Initialize the result with the first operand\n  result <- operand[1]\n  \n  # Iterate through the operators and operands\n  for (i in 1:length(operator)) {\n    op <- operator[i]\n    num <- operand[i + 1]\n    \n    # Apply the appropriate operation\n    if (op == '+') {\n      result <- result + num\n    } else if (op == '-') {\n      result <- result - num\n    } else if (op == '*') {\n      result <- result * num\n    } else if (op == '\/\/') {\n      result <- result %\/% num\n    } else if (op == '**') {\n      result <- result ^ num\n    } else {\n      stop(\"Unsupported operation\")\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- do_algebra\n    stopifnot(isTRUE(all.equal(candidate(c('**', '*', '+'), c(2, 3, 4, 5)), 37)))\n    stopifnot(isTRUE(all.equal(candidate(c('+', '*', '-'), c(2, 3, 4, 5)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c('\/\/', '*'), c(7, 3, 4)), 8)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_161","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣਾਂ ਫੰਕਸ਼ਨ ਨੂੰ ਨਤੀਜੇ ਵਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।ਜੇਕਰ ਸਤਰ ਵਿੱਚ ਕੋਈ ਅੱਖਰ ਨਹੀਂ ਹਨ, ਤਾਂ ਸਤਰ ਨੂੰ ਉਲਟਾ ਦਿਓ।ਨਹੀਂ ਤਾਂ ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਹੀ ਰੱਖੋ।ਜੇ s[i] ਇੱਕ ਅੱਖਰ ਹੈ, ਤਾਂ ਇਸਦੇ ਕੇਸ ਨੂੰ ਹੇਠਲੇ ਤੋਂ ਉੱਪਰਲੇ ਜਾਂ ਉਲਟ ਰੂਪ ਵਿੱਚ ਬਦਲੋ, ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ।# >>> solve('1234')\n# '4321'\n# >>> solve('ab')\n# 'AB'\n# >>> solve('#a@C')\n# '#A@c'\nsolve <- function(s) {","canonical_solution":"solve <- function(s) {\n  if (grepl(\"[a-zA-Z]\", s)) {\n    return(chartr(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n                  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", s))\n  } else {\n    return(intToUtf8(rev(utf8ToInt(s))))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- solve\n    stopifnot(isTRUE(all.equal(candidate('AsDf'), 'aSdF')))\n    stopifnot(isTRUE(all.equal(candidate('1234'), '4321')))\n    stopifnot(isTRUE(all.equal(candidate('ab'), 'AB')))\n    stopifnot(isTRUE(all.equal(candidate('#a@C'), '#A@c')))\n    stopifnot(isTRUE(all.equal(candidate('#AsdfW^45'), '#aSDFw^45')))\n    stopifnot(isTRUE(all.equal(candidate('#6@2'), '2@6#')))\n    stopifnot(isTRUE(all.equal(candidate('#$a^D'), '#$A^d')))\n    stopifnot(isTRUE(all.equal(candidate('#ccc'), '#CCC')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_162","nl":"pan_Guru","pl":"r","prompt":"ਜੇ 'text' ਇੱਕ ਖਾਲੀ ਸਤਰ ਹੈ, ਤਾਂ NULL ਵਾਪਸ ਕਰੋ।ਇੱਕ ਸਤਰ 'text' ਦਿੱਤੀ ਗਈ ਹੈ, ਇਸਦੀ md5 ਹੈਸ਼ ਬਰਾਬਰ ਸਤਰ ਵਾਪਸ ਕਰੋ।# >>> string_to_md5('Hello world')\n# '3e25960a79dbc69b674cd4ec67a72c62'\nstring_to_md5 <- function(text) {","canonical_solution":"string_to_md5 <- function(text) {\n  if (text == \"\") {\n    return(NULL)\n  } else {\n    return(digest::digest(text, algo = \"md5\", serialize = FALSE))\n  }\n}\n\n# Ensure the required library is loaded\nif(!requireNamespace(\"digest\", quietly = TRUE)) {\n  install.packages(\"digest\")\n}\n\n# Load the digest library\nlibrary(digest)","tests":"test_humaneval <- function() {\n    candidate <- string_to_md5\n    stopifnot(isTRUE(all.equal(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')))\n    stopifnot(isTRUE(all.equal(candidate(''), NULL)))\n    stopifnot(isTRUE(all.equal(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')))\n    stopifnot(isTRUE(all.equal(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_163","nl":"pan_Guru","pl":"r","prompt":"ਉਦਾਹਰਣ ਲਈ: ਅਤੇ b, ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ।ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਿੱਤੇ ਗਏ ਹਨ, a  ਦੇ ਵਿਚਕਾਰ ਜੋੜੇ ਅੰਕ ਵਾਪਸ ਕਰੋ# >>> generate_integers(2, 8)\n# c(2, 4, 6, 8)\n# >>> generate_integers(8, 2)\n# c(2, 4, 6, 8)\n# >>> generate_integers(10, 14)\n# c()\ngenerate_integers <- function(a, b) {","canonical_solution":"generate_integers <- function(a, b) {\n  start <- min(a, b)\n  end <- max(a, b)\n  even_digits <- seq(start, end)[seq(start, end) %% 2 == 0 & seq(start, end) <= 8]\n  return(even_digits)\n}","tests":"test_humaneval <- function() {\n    candidate <- generate_integers\n    stopifnot(isTRUE(all.equal(candidate(2, 10), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(10, 2), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(132, 2), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(17, 89), c())))\n}\ntest_humaneval()"}]